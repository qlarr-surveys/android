;
(function () {
  const _excluded4 = ["icon", "width", "sx"],
    _excluded5 = ["children"],
    _excluded6 = ["name"],
    _excluded7 = ["_f"],
    _excluded8 = ["_f"],
    _excluded9 = ["ref", "message", "type"],
    _excluded10 = ["name", "native", "maxHeight", "helperText", "children", "PaperPropsSx", "label", "onChange", "value"],
    _excluded11 = ["name", "chip", "label", "options", "checkbox", "placeholder", "helperText", "isOptionDisabled"],
    _excluded12 = ["value", "length", "autoFocus", "onChange", "TextFieldsProps", "onComplete", "validateChar", "className", "onBlur"],
    _excluded13 = ["onPaste", "onFocus", "onKeyDown", "className", "onBlur"],
    _excluded14 = ["name"],
    _excluded15 = ["name", "helperText"],
    _excluded16 = ["name", "helperText", "type"];
  function _toArray(r) { return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest(); }
  function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
  function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
  function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
  function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
  function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose2(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
  function _objectWithoutPropertiesLoose2(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }
  function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty3(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  function _defineProperty3(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
  function _toPropertyKey(t) { var i = _toPrimitive2(t, "string"); return "symbol" == typeof i ? i : i + ""; }
  function _toPrimitive2(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
  function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
  function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
  function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
  function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
  System.register(['./index-legacy-ppEgxGbl.js', './use-service-legacy-BbL3A7cT.js', './Checkbox-legacy-BOCzBChM.js', './Tabs-legacy-CXNTfVGs.js', './radioClasses-legacy-Cc_gAbFN.js', './tableRowClasses-legacy-DKGRrcou.js', './TextField-legacy-Dle1a096.js', './FormControlLabel-legacy-BPCe018b.js', './SwitchBase-legacy-tIJzAgb-.js'], function (exports, module) {
    'use strict';

    var _extends$1, createTheme, reactExports, useTheme, extendSxProp, _objectWithoutPropertiesLoose, jsxRuntimeExports, clsx, generateUtilityClass, generateUtilityClasses, capitalize, darken_1, lighten_1, alpha_1, keyframes, css, emphasize_1, commonjsGlobal, interopRequireDefaultExports, useNavigate, Box, useLocation, React, createCache, CacheProvider, getDefaultExportFromCjs, createTheme$1, Link, __vitePreload, useParams, LoadingDots, useSearchParams, Routes, Route, Navigate, styled, isMuiElement, useThemeProps, composeClasses, resolveComponentProps, mergeSlotProps, useForkRef, appendOwnerState, createSvgIcon, styled$1, Paper, useDefaultProps, IconButton, ButtonBase, useEventCallback, ownerDocument, GlobalStyles, Typography, rootShouldForwardProp, ListContext, useEnhancedEffect, isHostComponent, getListItemIconUtilityClass, useTimeout, extractEventHandlers, useTheme$1, useSlotProps, Grow, useRtl, useControlled, useId, useIsFocusVisible, Timeout, propTypesExports, useSelector, TokenService, requireCreateSvgIcon, useTranslation, Select, MenuItem, CookiesService, setDocumentLang, useService, useDispatch, getDirFromSession, Menu, setLoading, ErrorLayout, onEditErrorSeen, grey, alpha, PropTypes, stylisRTLPlugin, primary, info, secondary, success, warning, error, menuItemClasses, dividerClasses, drawerClasses, svgIconClasses, buttonClasses, listClasses, SvgIcon, paperClasses, listItemIconClasses, iconButtonClasses, formControlClasses, inputBaseClasses, outlinedInputClasses, filledInputClasses, typographyClasses, rtlLanguage, palette, ThemeProvider$1, CompactLayout, Image$1, setLangFromSession, cacheRtl, Provider, manageStore, FormControl, LANGUAGE_DEF, changeLang, onBaseLangChanged, onAdditionalLangAdded, onAdditionalLangRemoved, List, hasMajorSetup, resetSetup, resetLang, setup, themeSetup, languageSetup, reorderSetup, onAddComponentsVisibilityChange, GetData, surveyReceived, designStateReceived, Container, Stack, Modal, Button, PROCESSED_ERRORS, getparam, SurveyIcon, BG_COLOR, runStore, checkboxClasses, Checkbox, DialogContext, getDialogTitleUtilityClass, Popper, tabClasses, Dialog, DialogContent, useMediaQuery, Tabs, Tab, radioClasses, tableRowClasses, tableCellClasses, inputLabelClasses, InputLabel, FormLabel, FormHelperText, TextField, FormControlLabel, SwitchBase;
    return {
      setters: [module => {
        _extends$1 = module._;
        createTheme = module.c;
        reactExports = module.r;
        useTheme = module.a;
        extendSxProp = module.e;
        _objectWithoutPropertiesLoose = module.b;
        jsxRuntimeExports = module.j;
        clsx = module.d;
        generateUtilityClass = module.g;
        generateUtilityClasses = module.f;
        capitalize = module.h;
        darken_1 = module.i;
        lighten_1 = module.l;
        alpha_1 = module.k;
        keyframes = module.m;
        css = module.n;
        emphasize_1 = module.o;
        commonjsGlobal = module.p;
        interopRequireDefaultExports = module.q;
        useNavigate = module.s;
        Box = module.B;
        useLocation = module.t;
        React = module.R;
        createCache = module.v;
        CacheProvider = module.C;
        getDefaultExportFromCjs = module.w;
        createTheme$1 = module.x;
        Link = module.L;
        __vitePreload = module.y;
        useParams = module.u;
        LoadingDots = module.z;
        useSearchParams = module.A;
        Routes = module.D;
        Route = module.E;
        Navigate = module.N;
      }, module => {
        styled = module.s;
        isMuiElement = module.i;
        useThemeProps = module.u;
        composeClasses = module.c;
        resolveComponentProps = module.a;
        mergeSlotProps = module.m;
        useForkRef = module.b;
        appendOwnerState = module.d;
        createSvgIcon = module.e;
        styled$1 = module.f;
        Paper = module.h;
        useDefaultProps = module.j;
        IconButton = module.I;
        ButtonBase = module.B;
        useEventCallback = module.k;
        ownerDocument = module.o;
        GlobalStyles = module.G;
        Typography = module.T;
        rootShouldForwardProp = module.l;
        ListContext = module.L;
        useEnhancedEffect = module.n;
        isHostComponent = module.p;
        getListItemIconUtilityClass = module.q;
        useTimeout = module.t;
        extractEventHandlers = module.v;
        useTheme$1 = module.w;
        useSlotProps = module.x;
        Grow = module.y;
        useRtl = module.z;
        useControlled = module.A;
        useId = module.C;
        useIsFocusVisible = module.D;
        Timeout = module.E;
        propTypesExports = module.F;
        useSelector = module.H;
        TokenService = module.J;
        requireCreateSvgIcon = module.K;
        useTranslation = module.M;
        Select = module.S;
        MenuItem = module.N;
        CookiesService = module.O;
        setDocumentLang = module.Q;
        useService = module.R;
        useDispatch = module.U;
        getDirFromSession = module.V;
        Menu = module.W;
        setLoading = module.X;
        ErrorLayout = module.Y;
        onEditErrorSeen = module.Z;
        grey = module._;
        alpha = module.$;
        PropTypes = module.a0;
        stylisRTLPlugin = module.a1;
        primary = module.a2;
        info = module.a3;
        secondary = module.a4;
        success = module.a5;
        warning = module.a6;
        error = module.a7;
        menuItemClasses = module.a8;
        dividerClasses = module.a9;
        drawerClasses = module.aa;
        svgIconClasses = module.ab;
        buttonClasses = module.ac;
        listClasses = module.ad;
        SvgIcon = module.ae;
        paperClasses = module.af;
        listItemIconClasses = module.ag;
        iconButtonClasses = module.ah;
        formControlClasses = module.ai;
        inputBaseClasses = module.aj;
        outlinedInputClasses = module.ak;
        filledInputClasses = module.al;
        typographyClasses = module.am;
        rtlLanguage = module.an;
        palette = module.ao;
        ThemeProvider$1 = module.ap;
        CompactLayout = module.aq;
        Image$1 = module.ar;
        setLangFromSession = module.as;
        cacheRtl = module.at;
        Provider = module.P;
        manageStore = module.au;
        FormControl = module.av;
        LANGUAGE_DEF = module.aw;
        changeLang = module.ax;
        onBaseLangChanged = module.ay;
        onAdditionalLangAdded = module.az;
        onAdditionalLangRemoved = module.aA;
        List = module.aB;
        hasMajorSetup = module.aC;
        resetSetup = module.aD;
        resetLang = module.aE;
        setup = module.aF;
        themeSetup = module.aG;
        languageSetup = module.aH;
        reorderSetup = module.aI;
        onAddComponentsVisibilityChange = module.aJ;
        GetData = module.aK;
        surveyReceived = module.aL;
        designStateReceived = module.aM;
        Container = module.aN;
        Stack = module.aO;
        Modal = module.aP;
        Button = module.aQ;
        PROCESSED_ERRORS = module.aR;
        getparam = module.g;
        SurveyIcon = module.aS;
        BG_COLOR = module.aT;
        runStore = module.r;
      }, module => {
        checkboxClasses = module.c;
        Checkbox = module.C;
      }, module => {
        DialogContext = module.D;
        getDialogTitleUtilityClass = module.g;
        Popper = module.P;
        tabClasses = module.t;
        Dialog = module.a;
        DialogContent = module.b;
        useMediaQuery = module.u;
        Tabs = module.T;
        Tab = module.c;
      }, module => {
        radioClasses = module.r;
      }, module => {
        tableRowClasses = module.t;
        tableCellClasses = module.a;
      }, module => {
        inputLabelClasses = module.i;
        InputLabel = module.I;
        FormLabel = module.F;
        FormHelperText = module.a;
        TextField = module.T;
      }, module => {
        FormControlLabel = module.F;
      }, module => {
        SwitchBase = module.S;
      }],
      execute: function execute() {
        var __vite_style__ = document.createElement('style');
        __vite_style__.textContent = "._loading_c5al4_1 {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  display: block;\n  width: 100vw;\n  height: 100vh;\n  z-index: 1000;\n  background: rgba(0, 0, 0, .2);\n}\n\n._loadingWrapper_c5al4_14 {\n  position: relative;\n  top: 50%;\n  left: 50%;\n  display: inline-block;\n  margin: auto;\n  transform: translate(-50%, -50%);\n}\n._header_zp577_1 {\n  position: relative;\n  display: flex;\n  align-items: center;\n  padding: 0rem 3.5rem;\n  height: 4rem;\n}\n@media (max-width: 768px) {\n  ._header_zp577_1 {\n    justify-content: space-between;\n    padding: 0rem 0.5rem;\n  }\n  ._imageContainer_zp577_13._imageContainer_zp577_13 {\n    position: relative;\n  }\n  ._userInfo_zp577_16._userInfo_zp577_16 {\n    right: auto;\n    position: relative;\n  }\n  ._textCenter_zp577_20._textCenter_zp577_20 {\n    display: none;\n  }\n}\n\n._textCenter_zp577_20 {\n  display: flex;\n  justify-content: center;\n  width: 100%;\n}\n\n._userInfo_zp577_16 {\n  position: absolute;\n  display: flex;\n  align-items: center;\n  gap: 20px;\n}\n\n._imageContainer_zp577_13 {\n  position: absolute;\n}\n._logo_21mob_1 {\n  cursor: pointer;\n}\n._savingProgress_tmvkb_1 {\n  margin: 0px 8px !important;\n  width: 16px !important;\n  height: 16px !important;\n}\n\n._snackBar_tmvkb_7 {\n  left: 56px !important;\n}\n\n._wrapper_1tgcz_2 {\n  width: 100%;\n  height: calc(100vh - 64px);\n  background-color: #f7f8fc;\n}\n\n._surveyHeader_6kre5_1 {\n  background-color: #16205b;\n  position: relative;\n  width: 3.5rem;\n  z-index: 9999;\n  height: 100vh;\n}\n\n._icon_6kre5_9 {\n  height: 1em;\n  width: 1em;\n}\n._launchContainer_6kre5_13 {\n  position: relative;\n}\n._unpublishedChangesDot_6kre5_16 {\n  position: absolute;\n  top: -5px;\n  right: -10px;\n  width: 8px;\n  height: 8px;\n  background-color: #ff0000;\n  border-radius: 50%;\n  border: 1px solid white;\n}\n._authContainer_1r79w_1 { \n    height: 100%;\noverflow: auto;\n}._container_f0r9q_1 {\n  display: flex;\n  text-align: center;\n  vertical-align: middle;\n  flex-direction: column;\n  height: 100%;\n  overflow: auto;\n  height: 100%;\n}\n\n._onlinePreview_f0r9q_11 {\n  flex: 1;\n  border: none;\n  width: 100%;\n}\n\n._icon_f0r9q_17 {\n  height: 1em;\n  width: 1em;\n}\n\n._offlinePreview_f0r9q_22 {\n  position: absolute;\n  top: 108px;\n  left: calc(50% - 189.5px);\n  border: 0;\n  width: 375px;\n  height: 664px;\n}\n\n._wrapperMob_f0r9q_31 {\n  height: calc(100vh - 64px);\n  overflow: auto;\n  position: relative;\n}\n\n._phoneBg_f0r9q_37 {\n  width: 472px;\n  max-height: 888px;\n}\n\n._iconButton_f0r9q_42._iconButton_f0r9q_42 {\n  border: 1px solid #ececfd;\n  border-radius: 10px;\n  padding: 0.25rem 2rem;\n  height: fit-content;\n  position: absolute;\n  right: 3.5rem;\n}\n._wrapper_ar1uh_1 {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background: #ffffff;\n  box-shadow: 0px 0px 20px rgba(0, 0, 0, 0.1);\n  border-radius: 8px;\n  padding: 20px;\n}\n\n._action_ar1uh_12 {\n  text-align: end;\n  margin-top: 16px;\n}\n\n._errorText_ar1uh_17 {\n  color: #eb5757 !important;\n}\n/*$vite$:1*/";
        document.head.appendChild(__vite_style__);
        exports({
          F: FormProvider,
          J: getAutocompleteUtilityClass,
          M: getButtonGroupUtilityClass,
          O: getSliderUtilityClass,
          R: RHFTextField,
          S: SavingSurvey,
          V: ManageLanguages,
          e: RHFSelect,
          g: getBadgeUtilityClass,
          j: getLoadingButtonUtilityClass,
          n: useWatch,
          o: RHFMultiSelect,
          p: RHFCode,
          q: RHFSwitch,
          u: useForm,
          w: useSlot,
          x: getAccordionUtilityClass,
          z: getAccordionSummaryUtilityClass
        });
        const filterBreakpointKeys = (breakpointsKeys, responsiveKeys) => breakpointsKeys.filter(key => responsiveKeys.includes(key));
        const traverseBreakpoints = (breakpoints, responsive, iterator) => {
          const smallestBreakpoint = breakpoints.keys[0]; // the keys is sorted from smallest to largest by `createBreakpoints`.

          if (Array.isArray(responsive)) {
            responsive.forEach((breakpointValue, index) => {
              iterator((responsiveStyles, style) => {
                if (index <= breakpoints.keys.length - 1) {
                  if (index === 0) {
                    Object.assign(responsiveStyles, style);
                  } else {
                    responsiveStyles[breakpoints.up(breakpoints.keys[index])] = style;
                  }
                }
              }, breakpointValue);
            });
          } else if (responsive && typeof responsive === 'object') {
            // prevent null
            // responsive could be a very big object, pick the smallest responsive values

            const keys = Object.keys(responsive).length > breakpoints.keys.length ? breakpoints.keys : filterBreakpointKeys(breakpoints.keys, Object.keys(responsive));
            keys.forEach(key => {
              if (breakpoints.keys.indexOf(key) !== -1) {
                // @ts-ignore already checked that responsive is an object
                const breakpointValue = responsive[key];
                if (breakpointValue !== undefined) {
                  iterator((responsiveStyles, style) => {
                    if (smallestBreakpoint === key) {
                      Object.assign(responsiveStyles, style);
                    } else {
                      responsiveStyles[breakpoints.up(key)] = style;
                    }
                  }, breakpointValue);
                }
              }
            });
          } else if (typeof responsive === 'number' || typeof responsive === 'string') {
            iterator((responsiveStyles, style) => {
              Object.assign(responsiveStyles, style);
            }, responsive);
          }
        };
        function appendLevel(level) {
          if (!level) {
            return '';
          }
          return `Level${level}`;
        }
        function isNestedContainer(ownerState) {
          return ownerState.unstable_level > 0 && ownerState.container;
        }
        function createGetSelfSpacing(ownerState) {
          return function getSelfSpacing(axis) {
            return `var(--Grid-${axis}Spacing${appendLevel(ownerState.unstable_level)})`;
          };
        }
        function createGetParentSpacing(ownerState) {
          return function getParentSpacing(axis) {
            if (ownerState.unstable_level === 0) {
              return `var(--Grid-${axis}Spacing)`;
            }
            return `var(--Grid-${axis}Spacing${appendLevel(ownerState.unstable_level - 1)})`;
          };
        }
        function getParentColumns(ownerState) {
          if (ownerState.unstable_level === 0) {
            return `var(--Grid-columns)`;
          }
          return `var(--Grid-columns${appendLevel(ownerState.unstable_level - 1)})`;
        }
        const generateGridSizeStyles = ({
          theme,
          ownerState
        }) => {
          const getSelfSpacing = createGetSelfSpacing(ownerState);
          const styles = {};
          traverseBreakpoints(theme.breakpoints, ownerState.gridSize, (appendStyle, value) => {
            let style = {};
            if (value === true) {
              style = {
                flexBasis: 0,
                flexGrow: 1,
                maxWidth: '100%'
              };
            }
            if (value === 'auto') {
              style = {
                flexBasis: 'auto',
                flexGrow: 0,
                flexShrink: 0,
                maxWidth: 'none',
                width: 'auto'
              };
            }
            if (typeof value === 'number') {
              style = {
                flexGrow: 0,
                flexBasis: 'auto',
                width: `calc(100% * ${value} / ${getParentColumns(ownerState)}${isNestedContainer(ownerState) ? ` + ${getSelfSpacing('column')}` : ''})`
              };
            }
            appendStyle(styles, style);
          });
          return styles;
        };
        const generateGridOffsetStyles = ({
          theme,
          ownerState
        }) => {
          const styles = {};
          traverseBreakpoints(theme.breakpoints, ownerState.gridOffset, (appendStyle, value) => {
            let style = {};
            if (value === 'auto') {
              style = {
                marginLeft: 'auto'
              };
            }
            if (typeof value === 'number') {
              style = {
                marginLeft: value === 0 ? '0px' : `calc(100% * ${value} / ${getParentColumns(ownerState)})`
              };
            }
            appendStyle(styles, style);
          });
          return styles;
        };
        const generateGridColumnsStyles = ({
          theme,
          ownerState
        }) => {
          if (!ownerState.container) {
            return {};
          }
          const styles = isNestedContainer(ownerState) ? {
            [`--Grid-columns${appendLevel(ownerState.unstable_level)}`]: getParentColumns(ownerState)
          } : {
            '--Grid-columns': 12
          };
          traverseBreakpoints(theme.breakpoints, ownerState.columns, (appendStyle, value) => {
            appendStyle(styles, {
              [`--Grid-columns${appendLevel(ownerState.unstable_level)}`]: value
            });
          });
          return styles;
        };
        const generateGridRowSpacingStyles = ({
          theme,
          ownerState
        }) => {
          if (!ownerState.container) {
            return {};
          }
          const getParentSpacing = createGetParentSpacing(ownerState);
          const styles = isNestedContainer(ownerState) ? {
            // Set the default spacing as its parent spacing.
            // It will be overridden if spacing props are provided
            [`--Grid-rowSpacing${appendLevel(ownerState.unstable_level)}`]: getParentSpacing('row')
          } : {};
          traverseBreakpoints(theme.breakpoints, ownerState.rowSpacing, (appendStyle, value) => {
            var _theme$spacing;
            appendStyle(styles, {
              [`--Grid-rowSpacing${appendLevel(ownerState.unstable_level)}`]: typeof value === 'string' ? value : (_theme$spacing = theme.spacing) == null ? void 0 : _theme$spacing.call(theme, value)
            });
          });
          return styles;
        };
        const generateGridColumnSpacingStyles = ({
          theme,
          ownerState
        }) => {
          if (!ownerState.container) {
            return {};
          }
          const getParentSpacing = createGetParentSpacing(ownerState);
          const styles = isNestedContainer(ownerState) ? {
            // Set the default spacing as its parent spacing.
            // It will be overridden if spacing props are provided
            [`--Grid-columnSpacing${appendLevel(ownerState.unstable_level)}`]: getParentSpacing('column')
          } : {};
          traverseBreakpoints(theme.breakpoints, ownerState.columnSpacing, (appendStyle, value) => {
            var _theme$spacing2;
            appendStyle(styles, {
              [`--Grid-columnSpacing${appendLevel(ownerState.unstable_level)}`]: typeof value === 'string' ? value : (_theme$spacing2 = theme.spacing) == null ? void 0 : _theme$spacing2.call(theme, value)
            });
          });
          return styles;
        };
        const generateGridDirectionStyles = ({
          theme,
          ownerState
        }) => {
          if (!ownerState.container) {
            return {};
          }
          const styles = {};
          traverseBreakpoints(theme.breakpoints, ownerState.direction, (appendStyle, value) => {
            appendStyle(styles, {
              flexDirection: value
            });
          });
          return styles;
        };
        const generateGridStyles = ({
          ownerState
        }) => {
          const getSelfSpacing = createGetSelfSpacing(ownerState);
          const getParentSpacing = createGetParentSpacing(ownerState);
          return _extends$1({
            minWidth: 0,
            boxSizing: 'border-box'
          }, ownerState.container && _extends$1({
            display: 'flex',
            flexWrap: 'wrap'
          }, ownerState.wrap && ownerState.wrap !== 'wrap' && {
            flexWrap: ownerState.wrap
          }, {
            margin: `calc(${getSelfSpacing('row')} / -2) calc(${getSelfSpacing('column')} / -2)`
          }, ownerState.disableEqualOverflow && {
            margin: `calc(${getSelfSpacing('row')} * -1) 0px 0px calc(${getSelfSpacing('column')} * -1)`
          }), (!ownerState.container || isNestedContainer(ownerState)) && _extends$1({
            padding: `calc(${getParentSpacing('row')} / 2) calc(${getParentSpacing('column')} / 2)`
          }, (ownerState.disableEqualOverflow || ownerState.parentDisableEqualOverflow) && {
            padding: `${getParentSpacing('row')} 0px 0px ${getParentSpacing('column')}`
          }));
        };
        const generateSizeClassNames = gridSize => {
          const classNames = [];
          Object.entries(gridSize).forEach(([key, value]) => {
            if (value !== false && value !== undefined) {
              classNames.push(`grid-${key}-${String(value)}`);
            }
          });
          return classNames;
        };
        const generateSpacingClassNames = (spacing, smallestBreakpoint = 'xs') => {
          function isValidSpacing(val) {
            if (val === undefined) {
              return false;
            }
            return typeof val === 'string' && !Number.isNaN(Number(val)) || typeof val === 'number' && val > 0;
          }
          if (isValidSpacing(spacing)) {
            return [`spacing-${smallestBreakpoint}-${String(spacing)}`];
          }
          if (typeof spacing === 'object' && !Array.isArray(spacing)) {
            const classNames = [];
            Object.entries(spacing).forEach(([key, value]) => {
              if (isValidSpacing(value)) {
                classNames.push(`spacing-${key}-${String(value)}`);
              }
            });
            return classNames;
          }
          return [];
        };
        const generateDirectionClasses = direction => {
          if (direction === undefined) {
            return [];
          }
          if (typeof direction === 'object') {
            return Object.entries(direction).map(([key, value]) => `direction-${key}-${value}`);
          }
          return [`direction-xs-${String(direction)}`];
        };
        const _excluded$d = ["className", "children", "columns", "container", "component", "direction", "wrap", "spacing", "rowSpacing", "columnSpacing", "disableEqualOverflow", "unstable_level"];
        const defaultTheme = createTheme();
        const defaultCreateStyledComponent = styled("div", {
          name: "MuiGrid",
          slot: "Root",
          overridesResolver: (props, styles) => styles.root
        });
        function useThemePropsDefault(props) {
          return useThemeProps({
            props,
            name: "MuiGrid",
            defaultTheme
          });
        }
        function createGrid(options = {}) {
          const _options$createStyled = options.createStyledComponent,
            createStyledComponent = _options$createStyled === void 0 ? defaultCreateStyledComponent : _options$createStyled,
            _options$useThemeProp = options.useThemeProps,
            useThemeProps = _options$useThemeProp === void 0 ? useThemePropsDefault : _options$useThemeProp,
            _options$componentNam = options.componentName,
            componentName = _options$componentNam === void 0 ? "MuiGrid" : _options$componentNam;
          const GridOverflowContext = /* @__PURE__ */reactExports.createContext(void 0);
          const useUtilityClasses = (ownerState, theme) => {
            const container = ownerState.container,
              direction = ownerState.direction,
              spacing = ownerState.spacing,
              wrap = ownerState.wrap,
              gridSize = ownerState.gridSize;
            const slots = {
              root: ["root", container && "container", wrap !== "wrap" && `wrap-xs-${String(wrap)}`, ...generateDirectionClasses(direction), ...generateSizeClassNames(gridSize), ...(container ? generateSpacingClassNames(spacing, theme.breakpoints.keys[0]) : [])]
            };
            return composeClasses(slots, slot => generateUtilityClass(componentName, slot), {});
          };
          const GridRoot = createStyledComponent(generateGridColumnsStyles, generateGridColumnSpacingStyles, generateGridRowSpacingStyles, generateGridSizeStyles, generateGridDirectionStyles, generateGridStyles, generateGridOffsetStyles);
          const Grid = /* @__PURE__ */reactExports.forwardRef(function Grid2(inProps, ref) {
            var _inProps$columns, _inProps$spacing, _ref, _inProps$rowSpacing, _ref2, _inProps$columnSpacin, _ref3, _disableEqualOverflow;
            const theme = useTheme();
            const themeProps = useThemeProps(inProps);
            const props = extendSxProp(themeProps);
            const overflow = reactExports.useContext(GridOverflowContext);
            const className = props.className,
              children = props.children,
              _props$columns = props.columns,
              columnsProp = _props$columns === void 0 ? 12 : _props$columns,
              _props$container = props.container,
              container = _props$container === void 0 ? false : _props$container,
              _props$component = props.component,
              component = _props$component === void 0 ? "div" : _props$component,
              _props$direction = props.direction,
              direction = _props$direction === void 0 ? "row" : _props$direction,
              _props$wrap = props.wrap,
              wrap = _props$wrap === void 0 ? "wrap" : _props$wrap,
              _props$spacing = props.spacing,
              spacingProp = _props$spacing === void 0 ? 0 : _props$spacing,
              _props$rowSpacing = props.rowSpacing,
              rowSpacingProp = _props$rowSpacing === void 0 ? spacingProp : _props$rowSpacing,
              _props$columnSpacing = props.columnSpacing,
              columnSpacingProp = _props$columnSpacing === void 0 ? spacingProp : _props$columnSpacing,
              themeDisableEqualOverflow = props.disableEqualOverflow,
              _props$unstable_level = props.unstable_level,
              level = _props$unstable_level === void 0 ? 0 : _props$unstable_level,
              rest = _objectWithoutPropertiesLoose(props, _excluded$d);
            let disableEqualOverflow = themeDisableEqualOverflow;
            if (level && themeDisableEqualOverflow !== void 0) {
              disableEqualOverflow = inProps.disableEqualOverflow;
            }
            const gridSize = {};
            const gridOffset = {};
            const other = {};
            Object.entries(rest).forEach(([key, val]) => {
              if (theme.breakpoints.values[key] !== void 0) {
                gridSize[key] = val;
              } else if (theme.breakpoints.values[key.replace("Offset", "")] !== void 0) {
                gridOffset[key.replace("Offset", "")] = val;
              } else {
                other[key] = val;
              }
            });
            const columns = (_inProps$columns = inProps.columns) != null ? _inProps$columns : level ? void 0 : columnsProp;
            const spacing = (_inProps$spacing = inProps.spacing) != null ? _inProps$spacing : level ? void 0 : spacingProp;
            const rowSpacing = (_ref = (_inProps$rowSpacing = inProps.rowSpacing) != null ? _inProps$rowSpacing : inProps.spacing) != null ? _ref : level ? void 0 : rowSpacingProp;
            const columnSpacing = (_ref2 = (_inProps$columnSpacin = inProps.columnSpacing) != null ? _inProps$columnSpacin : inProps.spacing) != null ? _ref2 : level ? void 0 : columnSpacingProp;
            const ownerState = _extends$1({}, props, {
              level,
              columns,
              container,
              direction,
              wrap,
              spacing,
              rowSpacing,
              columnSpacing,
              gridSize,
              gridOffset,
              disableEqualOverflow: (_ref3 = (_disableEqualOverflow = disableEqualOverflow) != null ? _disableEqualOverflow : overflow) != null ? _ref3 : false,
              // use context value if exists.
              parentDisableEqualOverflow: overflow
              // for nested grid
            });
            const classes = useUtilityClasses(ownerState, theme);
            let result = /* @__PURE__ */jsxRuntimeExports.jsx(GridRoot, _extends$1({
              ref,
              as: component,
              ownerState,
              className: clsx(classes.root, className)
            }, other, {
              children: reactExports.Children.map(children, child => {
                if (/* @__PURE__ */reactExports.isValidElement(child) && isMuiElement(child, ["Grid"])) {
                  var _child$props$unstable;
                  return /* @__PURE__ */reactExports.cloneElement(child, {
                    unstable_level: (_child$props$unstable = child.props.unstable_level) != null ? _child$props$unstable : level + 1
                  });
                }
                return child;
              })
            }));
            if (disableEqualOverflow !== void 0 && disableEqualOverflow !== (overflow != null ? overflow : false)) {
              result = /* @__PURE__ */jsxRuntimeExports.jsx(GridOverflowContext.Provider, {
                value: disableEqualOverflow,
                children: result
              });
            }
            return result;
          });
          Grid.muiName = "Grid";
          return Grid;
        }
        const _excluded$c = ["className", "elementType", "ownerState", "externalForwardedProps", "getSlotOwnerState", "internalForwardedProps"],
          _excluded2$2 = ["component", "slots", "slotProps"],
          _excluded3 = ["component"];
        /**
         * An internal function to create a Material UI slot.
         *
         * This is an advanced version of Base UI `useSlotProps` because Material UI allows leaf component to be customized via `component` prop
         * while Base UI does not need to support leaf component customization.
         *
         * @param {string} name: name of the slot
         * @param {object} parameters
         * @returns {[Slot, slotProps]} The slot's React component and the slot's props
         *
         * Note: the returned slot's props
         * - will never contain `component` prop.
         * - might contain `as` prop.
         */
        function useSlot(
        /**
         * The slot's name. All Material UI components should have `root` slot.
         *
         * If the name is `root`, the logic behaves differently from other slots,
         * e.g. the `externalForwardedProps` are spread to `root` slot but not other slots.
         */
        name, parameters) {
          const className = parameters.className,
            initialElementType = parameters.elementType,
            ownerState = parameters.ownerState,
            externalForwardedProps = parameters.externalForwardedProps,
            getSlotOwnerState = parameters.getSlotOwnerState,
            internalForwardedProps = parameters.internalForwardedProps,
            useSlotPropsParams = _objectWithoutPropertiesLoose(parameters, _excluded$c);
          const rootComponent = externalForwardedProps.component,
            _externalForwardedPro = externalForwardedProps.slots,
            slots = _externalForwardedPro === void 0 ? {
              [name]: undefined
            } : _externalForwardedPro,
            _externalForwardedPro2 = externalForwardedProps.slotProps,
            slotProps = _externalForwardedPro2 === void 0 ? {
              [name]: undefined
            } : _externalForwardedPro2,
            other = _objectWithoutPropertiesLoose(externalForwardedProps, _excluded2$2);
          const elementType = slots[name] || initialElementType;

          // `slotProps[name]` can be a callback that receives the component's ownerState.
          // `resolvedComponentsProps` is always a plain object.
          const resolvedComponentsProps = resolveComponentProps(slotProps[name], ownerState);
          const _mergeSlotProps = mergeSlotProps(_extends$1({
              className
            }, useSlotPropsParams, {
              externalForwardedProps: name === 'root' ? other : undefined,
              externalSlotProps: resolvedComponentsProps
            })),
            slotComponent = _mergeSlotProps.props.component,
            internalRef = _mergeSlotProps.internalRef,
            mergedProps = _objectWithoutPropertiesLoose(_mergeSlotProps.props, _excluded3);
          const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, parameters.ref);
          const slotOwnerState = getSlotOwnerState ? getSlotOwnerState(mergedProps) : {};
          const finalOwnerState = _extends$1({}, ownerState, slotOwnerState);
          const LeafComponent = name === 'root' ? slotComponent || rootComponent : slotComponent;
          const props = appendOwnerState(elementType, _extends$1({}, name === 'root' && !rootComponent && !slots[name] && internalForwardedProps, name !== 'root' && !slots[name] && internalForwardedProps, mergedProps, LeafComponent && {
            as: LeafComponent
          }, {
            ref
          }), finalOwnerState);
          Object.keys(slotOwnerState).forEach(propName => {
            delete props[propName];
          });
          return [elementType, props];
        }
        function getAccordionUtilityClass(slot) {
          return generateUtilityClass('MuiAccordion', slot);
        }
        const accordionClasses = exports("v", generateUtilityClasses('MuiAccordion', ['root', 'rounded', 'expanded', 'disabled', 'gutters', 'region']));
        function getAccordionSummaryUtilityClass(slot) {
          return generateUtilityClass('MuiAccordionSummary', slot);
        }
        const accordionSummaryClasses = exports("y", generateUtilityClasses('MuiAccordionSummary', ['root', 'expanded', 'focusVisible', 'disabled', 'gutters', 'contentGutters', 'content', 'expandIconWrapper']));
        function getAlertUtilityClass(slot) {
          return generateUtilityClass('MuiAlert', slot);
        }
        const alertClasses = generateUtilityClasses('MuiAlert', ['root', 'action', 'icon', 'message', 'filled', 'colorSuccess', 'colorInfo', 'colorWarning', 'colorError', 'filledSuccess', 'filledInfo', 'filledWarning', 'filledError', 'outlined', 'outlinedSuccess', 'outlinedInfo', 'outlinedWarning', 'outlinedError', 'standard', 'standardSuccess', 'standardInfo', 'standardWarning', 'standardError']);
        const SuccessOutlinedIcon = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
        }), 'SuccessOutlined');
        const ReportProblemOutlinedIcon = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
        }), 'ReportProblemOutlined');
        const ErrorOutlineIcon = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
        }), 'ErrorOutline');
        const InfoOutlinedIcon = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
        }), 'InfoOutlined');
        const ClearIcon = exports("G", createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
        }), 'Close'));
        const _excluded$b = ["action", "children", "className", "closeText", "color", "components", "componentsProps", "icon", "iconMapping", "onClose", "role", "severity", "slotProps", "slots", "variant"];
        const useUtilityClasses$b = ownerState => {
          const variant = ownerState.variant,
            color = ownerState.color,
            severity = ownerState.severity,
            classes = ownerState.classes;
          const slots = {
            root: ["root", `color${capitalize(color || severity)}`, `${variant}${capitalize(color || severity)}`, `${variant}`],
            icon: ["icon"],
            message: ["message"],
            action: ["action"]
          };
          return composeClasses(slots, getAlertUtilityClass, classes);
        };
        const AlertRoot = styled$1(Paper, {
          name: "MuiAlert",
          slot: "Root",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.root, styles[ownerState.variant], styles[`${ownerState.variant}${capitalize(ownerState.color || ownerState.severity)}`]];
          }
        })(({
          theme
        }) => {
          const getColor = theme.palette.mode === "light" ? darken_1 : lighten_1;
          const getBackgroundColor = theme.palette.mode === "light" ? lighten_1 : darken_1;
          return _extends$1({}, theme.typography.body2, {
            backgroundColor: "transparent",
            display: "flex",
            padding: "6px 16px",
            variants: [...Object.entries(theme.palette).filter(([, value]) => value.main && value.light).map(([color]) => ({
              props: {
                colorSeverity: color,
                variant: "standard"
              },
              style: {
                color: theme.vars ? theme.vars.palette.Alert[`${color}Color`] : getColor(theme.palette[color].light, 0.6),
                backgroundColor: theme.vars ? theme.vars.palette.Alert[`${color}StandardBg`] : getBackgroundColor(theme.palette[color].light, 0.9),
                [`& .${alertClasses.icon}`]: theme.vars ? {
                  color: theme.vars.palette.Alert[`${color}IconColor`]
                } : {
                  color: theme.palette[color].main
                }
              }
            })), ...Object.entries(theme.palette).filter(([, value]) => value.main && value.light).map(([color]) => ({
              props: {
                colorSeverity: color,
                variant: "outlined"
              },
              style: {
                color: theme.vars ? theme.vars.palette.Alert[`${color}Color`] : getColor(theme.palette[color].light, 0.6),
                border: `1px solid ${(theme.vars || theme).palette[color].light}`,
                [`& .${alertClasses.icon}`]: theme.vars ? {
                  color: theme.vars.palette.Alert[`${color}IconColor`]
                } : {
                  color: theme.palette[color].main
                }
              }
            })), ...Object.entries(theme.palette).filter(([, value]) => value.main && value.dark).map(([color]) => ({
              props: {
                colorSeverity: color,
                variant: "filled"
              },
              style: _extends$1({
                fontWeight: theme.typography.fontWeightMedium
              }, theme.vars ? {
                color: theme.vars.palette.Alert[`${color}FilledColor`],
                backgroundColor: theme.vars.palette.Alert[`${color}FilledBg`]
              } : {
                backgroundColor: theme.palette.mode === "dark" ? theme.palette[color].dark : theme.palette[color].main,
                color: theme.palette.getContrastText(theme.palette[color].main)
              })
            }))]
          });
        });
        const AlertIcon = styled$1("div", {
          name: "MuiAlert",
          slot: "Icon",
          overridesResolver: (props, styles) => styles.icon
        })({
          marginRight: 12,
          padding: "7px 0",
          display: "flex",
          fontSize: 22,
          opacity: 0.9
        });
        const AlertMessage = styled$1("div", {
          name: "MuiAlert",
          slot: "Message",
          overridesResolver: (props, styles) => styles.message
        })({
          padding: "8px 0",
          minWidth: 0,
          overflow: "auto"
        });
        const AlertAction = styled$1("div", {
          name: "MuiAlert",
          slot: "Action",
          overridesResolver: (props, styles) => styles.action
        })({
          display: "flex",
          alignItems: "flex-start",
          padding: "4px 0 0 16px",
          marginLeft: "auto",
          marginRight: -8
        });
        const defaultIconMapping = {
          success: /* @__PURE__ */jsxRuntimeExports.jsx(SuccessOutlinedIcon, {
            fontSize: "inherit"
          }),
          warning: /* @__PURE__ */jsxRuntimeExports.jsx(ReportProblemOutlinedIcon, {
            fontSize: "inherit"
          }),
          error: /* @__PURE__ */jsxRuntimeExports.jsx(ErrorOutlineIcon, {
            fontSize: "inherit"
          }),
          info: /* @__PURE__ */jsxRuntimeExports.jsx(InfoOutlinedIcon, {
            fontSize: "inherit"
          })
        };
        const Alert = exports("A", /* @__PURE__ */reactExports.forwardRef(function Alert2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiAlert"
          });
          const action = props.action,
            children = props.children,
            className = props.className,
            _props$closeText = props.closeText,
            closeText = _props$closeText === void 0 ? "Close" : _props$closeText,
            color = props.color,
            _props$components = props.components,
            components = _props$components === void 0 ? {} : _props$components,
            _props$componentsProp = props.componentsProps,
            componentsProps = _props$componentsProp === void 0 ? {} : _props$componentsProp,
            icon = props.icon,
            _props$iconMapping = props.iconMapping,
            iconMapping = _props$iconMapping === void 0 ? defaultIconMapping : _props$iconMapping,
            onClose = props.onClose,
            _props$role = props.role,
            role = _props$role === void 0 ? "alert" : _props$role,
            _props$severity = props.severity,
            severity = _props$severity === void 0 ? "success" : _props$severity,
            _props$slotProps = props.slotProps,
            slotProps = _props$slotProps === void 0 ? {} : _props$slotProps,
            _props$slots = props.slots,
            slots = _props$slots === void 0 ? {} : _props$slots,
            _props$variant = props.variant,
            variant = _props$variant === void 0 ? "standard" : _props$variant,
            other = _objectWithoutPropertiesLoose(props, _excluded$b);
          const ownerState = _extends$1({}, props, {
            color,
            severity,
            variant,
            colorSeverity: color || severity
          });
          const classes = useUtilityClasses$b(ownerState);
          const externalForwardedProps = {
            slots: _extends$1({
              closeButton: components.CloseButton,
              closeIcon: components.CloseIcon
            }, slots),
            slotProps: _extends$1({}, componentsProps, slotProps)
          };
          const _useSlot = useSlot("closeButton", {
              elementType: IconButton,
              externalForwardedProps,
              ownerState
            }),
            _useSlot2 = _slicedToArray(_useSlot, 2),
            CloseButtonSlot = _useSlot2[0],
            closeButtonProps = _useSlot2[1];
          const _useSlot3 = useSlot("closeIcon", {
              elementType: ClearIcon,
              externalForwardedProps,
              ownerState
            }),
            _useSlot4 = _slicedToArray(_useSlot3, 2),
            CloseIconSlot = _useSlot4[0],
            closeIconProps = _useSlot4[1];
          return /* @__PURE__ */jsxRuntimeExports.jsxs(AlertRoot, _extends$1({
            role,
            elevation: 0,
            ownerState,
            className: clsx(classes.root, className),
            ref
          }, other, {
            children: [icon !== false ? /* @__PURE__ */jsxRuntimeExports.jsx(AlertIcon, {
              ownerState,
              className: classes.icon,
              children: icon || iconMapping[severity] || defaultIconMapping[severity]
            }) : null, /* @__PURE__ */jsxRuntimeExports.jsx(AlertMessage, {
              ownerState,
              className: classes.message,
              children
            }), action != null ? /* @__PURE__ */jsxRuntimeExports.jsx(AlertAction, {
              ownerState,
              className: classes.action,
              children: action
            }) : null, action == null && onClose ? /* @__PURE__ */jsxRuntimeExports.jsx(AlertAction, {
              ownerState,
              className: classes.action,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(CloseButtonSlot, _extends$1({
                size: "small",
                "aria-label": closeText,
                title: closeText,
                color: "inherit",
                onClick: onClose
              }, closeButtonProps, {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(CloseIconSlot, _extends$1({
                  fontSize: "small"
                }, closeIconProps))
              }))
            }) : null]
          }));
        }));
        const CancelIcon = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
        }), 'Cancel');
        function getChipUtilityClass(slot) {
          return generateUtilityClass('MuiChip', slot);
        }
        const chipClasses = generateUtilityClasses('MuiChip', ['root', 'sizeSmall', 'sizeMedium', 'colorError', 'colorInfo', 'colorPrimary', 'colorSecondary', 'colorSuccess', 'colorWarning', 'disabled', 'clickable', 'clickableColorPrimary', 'clickableColorSecondary', 'deletable', 'deletableColorPrimary', 'deletableColorSecondary', 'outlined', 'filled', 'outlinedPrimary', 'outlinedSecondary', 'filledPrimary', 'filledSecondary', 'avatar', 'avatarSmall', 'avatarMedium', 'avatarColorPrimary', 'avatarColorSecondary', 'icon', 'iconSmall', 'iconMedium', 'iconColorPrimary', 'iconColorSecondary', 'label', 'labelSmall', 'labelMedium', 'deleteIcon', 'deleteIconSmall', 'deleteIconMedium', 'deleteIconColorPrimary', 'deleteIconColorSecondary', 'deleteIconOutlinedColorPrimary', 'deleteIconOutlinedColorSecondary', 'deleteIconFilledColorPrimary', 'deleteIconFilledColorSecondary', 'focusVisible']);
        const _excluded$a = ["avatar", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant", "tabIndex", "skipFocusWhenDisabled"];
        const useUtilityClasses$a = ownerState => {
          const classes = ownerState.classes,
            disabled = ownerState.disabled,
            size = ownerState.size,
            color = ownerState.color,
            iconColor = ownerState.iconColor,
            onDelete = ownerState.onDelete,
            clickable = ownerState.clickable,
            variant = ownerState.variant;
          const slots = {
            root: ["root", variant, disabled && "disabled", `size${capitalize(size)}`, `color${capitalize(color)}`, clickable && "clickable", clickable && `clickableColor${capitalize(color)}`, onDelete && "deletable", onDelete && `deletableColor${capitalize(color)}`, `${variant}${capitalize(color)}`],
            label: ["label", `label${capitalize(size)}`],
            avatar: ["avatar", `avatar${capitalize(size)}`, `avatarColor${capitalize(color)}`],
            icon: ["icon", `icon${capitalize(size)}`, `iconColor${capitalize(iconColor)}`],
            deleteIcon: ["deleteIcon", `deleteIcon${capitalize(size)}`, `deleteIconColor${capitalize(color)}`, `deleteIcon${capitalize(variant)}Color${capitalize(color)}`]
          };
          return composeClasses(slots, getChipUtilityClass, classes);
        };
        const ChipRoot = styled$1("div", {
          name: "MuiChip",
          slot: "Root",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            const color = ownerState.color,
              iconColor = ownerState.iconColor,
              clickable = ownerState.clickable,
              onDelete = ownerState.onDelete,
              size = ownerState.size,
              variant = ownerState.variant;
            return [{
              [`& .${chipClasses.avatar}`]: styles.avatar
            }, {
              [`& .${chipClasses.avatar}`]: styles[`avatar${capitalize(size)}`]
            }, {
              [`& .${chipClasses.avatar}`]: styles[`avatarColor${capitalize(color)}`]
            }, {
              [`& .${chipClasses.icon}`]: styles.icon
            }, {
              [`& .${chipClasses.icon}`]: styles[`icon${capitalize(size)}`]
            }, {
              [`& .${chipClasses.icon}`]: styles[`iconColor${capitalize(iconColor)}`]
            }, {
              [`& .${chipClasses.deleteIcon}`]: styles.deleteIcon
            }, {
              [`& .${chipClasses.deleteIcon}`]: styles[`deleteIcon${capitalize(size)}`]
            }, {
              [`& .${chipClasses.deleteIcon}`]: styles[`deleteIconColor${capitalize(color)}`]
            }, {
              [`& .${chipClasses.deleteIcon}`]: styles[`deleteIcon${capitalize(variant)}Color${capitalize(color)}`]
            }, styles.root, styles[`size${capitalize(size)}`], styles[`color${capitalize(color)}`], clickable && styles.clickable, clickable && color !== "default" && styles[`clickableColor${capitalize(color)})`], onDelete && styles.deletable, onDelete && color !== "default" && styles[`deletableColor${capitalize(color)}`], styles[variant], styles[`${variant}${capitalize(color)}`]];
          }
        })(({
          theme,
          ownerState
        }) => {
          const textColor = theme.palette.mode === "light" ? theme.palette.grey[700] : theme.palette.grey[300];
          return _extends$1({
            maxWidth: "100%",
            fontFamily: theme.typography.fontFamily,
            fontSize: theme.typography.pxToRem(13),
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center",
            height: 32,
            color: (theme.vars || theme).palette.text.primary,
            backgroundColor: (theme.vars || theme).palette.action.selected,
            borderRadius: 32 / 2,
            whiteSpace: "nowrap",
            transition: theme.transitions.create(["background-color", "box-shadow"]),
            // reset cursor explicitly in case ButtonBase is used
            cursor: "unset",
            // We disable the focus ring for mouse, touch and keyboard users.
            outline: 0,
            textDecoration: "none",
            border: 0,
            // Remove `button` border
            padding: 0,
            // Remove `button` padding
            verticalAlign: "middle",
            boxSizing: "border-box",
            [`&.${chipClasses.disabled}`]: {
              opacity: (theme.vars || theme).palette.action.disabledOpacity,
              pointerEvents: "none"
            },
            [`& .${chipClasses.avatar}`]: {
              marginLeft: 5,
              marginRight: -6,
              width: 24,
              height: 24,
              color: theme.vars ? theme.vars.palette.Chip.defaultAvatarColor : textColor,
              fontSize: theme.typography.pxToRem(12)
            },
            [`& .${chipClasses.avatarColorPrimary}`]: {
              color: (theme.vars || theme).palette.primary.contrastText,
              backgroundColor: (theme.vars || theme).palette.primary.dark
            },
            [`& .${chipClasses.avatarColorSecondary}`]: {
              color: (theme.vars || theme).palette.secondary.contrastText,
              backgroundColor: (theme.vars || theme).palette.secondary.dark
            },
            [`& .${chipClasses.avatarSmall}`]: {
              marginLeft: 4,
              marginRight: -4,
              width: 18,
              height: 18,
              fontSize: theme.typography.pxToRem(10)
            },
            [`& .${chipClasses.icon}`]: _extends$1({
              marginLeft: 5,
              marginRight: -6
            }, ownerState.size === "small" && {
              fontSize: 18,
              marginLeft: 4,
              marginRight: -4
            }, ownerState.iconColor === ownerState.color && _extends$1({
              color: theme.vars ? theme.vars.palette.Chip.defaultIconColor : textColor
            }, ownerState.color !== "default" && {
              color: "inherit"
            })),
            [`& .${chipClasses.deleteIcon}`]: _extends$1({
              WebkitTapHighlightColor: "transparent",
              color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.26)` : alpha_1(theme.palette.text.primary, 0.26),
              fontSize: 22,
              cursor: "pointer",
              margin: "0 5px 0 -6px",
              "&:hover": {
                color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.4)` : alpha_1(theme.palette.text.primary, 0.4)
              }
            }, ownerState.size === "small" && {
              fontSize: 16,
              marginRight: 4,
              marginLeft: -4
            }, ownerState.color !== "default" && {
              color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].contrastTextChannel} / 0.7)` : alpha_1(theme.palette[ownerState.color].contrastText, 0.7),
              "&:hover, &:active": {
                color: (theme.vars || theme).palette[ownerState.color].contrastText
              }
            })
          }, ownerState.size === "small" && {
            height: 24
          }, ownerState.color !== "default" && {
            backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
            color: (theme.vars || theme).palette[ownerState.color].contrastText
          }, ownerState.onDelete && {
            [`&.${chipClasses.focusVisible}`]: {
              backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha_1(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
            }
          }, ownerState.onDelete && ownerState.color !== "default" && {
            [`&.${chipClasses.focusVisible}`]: {
              backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
            }
          });
        }, ({
          theme,
          ownerState
        }) => _extends$1({}, ownerState.clickable && {
          userSelect: "none",
          WebkitTapHighlightColor: "transparent",
          cursor: "pointer",
          "&:hover": {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha_1(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity)
          },
          [`&.${chipClasses.focusVisible}`]: {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha_1(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
          },
          "&:active": {
            boxShadow: (theme.vars || theme).shadows[1]
          }
        }, ownerState.clickable && ownerState.color !== "default" && {
          [`&:hover, &.${chipClasses.focusVisible}`]: {
            backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
          }
        }), ({
          theme,
          ownerState
        }) => _extends$1({}, ownerState.variant === "outlined" && {
          backgroundColor: "transparent",
          border: theme.vars ? `1px solid ${theme.vars.palette.Chip.defaultBorder}` : `1px solid ${theme.palette.mode === "light" ? theme.palette.grey[400] : theme.palette.grey[700]}`,
          [`&.${chipClasses.clickable}:hover`]: {
            backgroundColor: (theme.vars || theme).palette.action.hover
          },
          [`&.${chipClasses.focusVisible}`]: {
            backgroundColor: (theme.vars || theme).palette.action.focus
          },
          [`& .${chipClasses.avatar}`]: {
            marginLeft: 4
          },
          [`& .${chipClasses.avatarSmall}`]: {
            marginLeft: 2
          },
          [`& .${chipClasses.icon}`]: {
            marginLeft: 4
          },
          [`& .${chipClasses.iconSmall}`]: {
            marginLeft: 2
          },
          [`& .${chipClasses.deleteIcon}`]: {
            marginRight: 5
          },
          [`& .${chipClasses.deleteIconSmall}`]: {
            marginRight: 3
          }
        }, ownerState.variant === "outlined" && ownerState.color !== "default" && {
          color: (theme.vars || theme).palette[ownerState.color].main,
          border: `1px solid ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha_1(theme.palette[ownerState.color].main, 0.7)}`,
          [`&.${chipClasses.clickable}:hover`]: {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity)
          },
          [`&.${chipClasses.focusVisible}`]: {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha_1(theme.palette[ownerState.color].main, theme.palette.action.focusOpacity)
          },
          [`& .${chipClasses.deleteIcon}`]: {
            color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha_1(theme.palette[ownerState.color].main, 0.7),
            "&:hover, &:active": {
              color: (theme.vars || theme).palette[ownerState.color].main
            }
          }
        }));
        const ChipLabel = styled$1("span", {
          name: "MuiChip",
          slot: "Label",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            const size = ownerState.size;
            return [styles.label, styles[`label${capitalize(size)}`]];
          }
        })(({
          ownerState
        }) => _extends$1({
          overflow: "hidden",
          textOverflow: "ellipsis",
          paddingLeft: 12,
          paddingRight: 12,
          whiteSpace: "nowrap"
        }, ownerState.variant === "outlined" && {
          paddingLeft: 11,
          paddingRight: 11
        }, ownerState.size === "small" && {
          paddingLeft: 8,
          paddingRight: 8
        }, ownerState.size === "small" && ownerState.variant === "outlined" && {
          paddingLeft: 7,
          paddingRight: 7
        }));
        function isDeleteKeyboardEvent(keyboardEvent) {
          return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
        }
        const Chip = exports("H", /* @__PURE__ */reactExports.forwardRef(function Chip2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiChip"
          });
          const avatarProp = props.avatar,
            className = props.className,
            clickableProp = props.clickable,
            _props$color = props.color,
            color = _props$color === void 0 ? "default" : _props$color,
            ComponentProp = props.component,
            deleteIconProp = props.deleteIcon,
            _props$disabled = props.disabled,
            disabled = _props$disabled === void 0 ? false : _props$disabled,
            iconProp = props.icon,
            label = props.label,
            onClick = props.onClick,
            onDelete = props.onDelete,
            onKeyDown = props.onKeyDown,
            onKeyUp = props.onKeyUp,
            _props$size = props.size,
            size = _props$size === void 0 ? "medium" : _props$size,
            _props$variant2 = props.variant,
            variant = _props$variant2 === void 0 ? "filled" : _props$variant2,
            tabIndex = props.tabIndex,
            _props$skipFocusWhenD = props.skipFocusWhenDisabled,
            skipFocusWhenDisabled = _props$skipFocusWhenD === void 0 ? false : _props$skipFocusWhenD,
            other = _objectWithoutPropertiesLoose(props, _excluded$a);
          const chipRef = reactExports.useRef(null);
          const handleRef = useForkRef(chipRef, ref);
          const handleDeleteIconClick = event => {
            event.stopPropagation();
            if (onDelete) {
              onDelete(event);
            }
          };
          const handleKeyDown = event => {
            if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
              event.preventDefault();
            }
            if (onKeyDown) {
              onKeyDown(event);
            }
          };
          const handleKeyUp = event => {
            if (event.currentTarget === event.target) {
              if (onDelete && isDeleteKeyboardEvent(event)) {
                onDelete(event);
              } else if (event.key === "Escape" && chipRef.current) {
                chipRef.current.blur();
              }
            }
            if (onKeyUp) {
              onKeyUp(event);
            }
          };
          const clickable = clickableProp !== false && onClick ? true : clickableProp;
          const component = clickable || onDelete ? ButtonBase : ComponentProp || "div";
          const ownerState = _extends$1({}, props, {
            component,
            disabled,
            size,
            color,
            iconColor: /* @__PURE__ */reactExports.isValidElement(iconProp) ? iconProp.props.color || color : color,
            onDelete: !!onDelete,
            clickable,
            variant
          });
          const classes = useUtilityClasses$a(ownerState);
          const moreProps = component === ButtonBase ? _extends$1({
            component: ComponentProp || "div",
            focusVisibleClassName: classes.focusVisible
          }, onDelete && {
            disableRipple: true
          }) : {};
          let deleteIcon = null;
          if (onDelete) {
            deleteIcon = deleteIconProp && /* @__PURE__ */reactExports.isValidElement(deleteIconProp) ? /* @__PURE__ */reactExports.cloneElement(deleteIconProp, {
              className: clsx(deleteIconProp.props.className, classes.deleteIcon),
              onClick: handleDeleteIconClick
            }) : /* @__PURE__ */jsxRuntimeExports.jsx(CancelIcon, {
              className: clsx(classes.deleteIcon),
              onClick: handleDeleteIconClick
            });
          }
          let avatar = null;
          if (avatarProp && /* @__PURE__ */reactExports.isValidElement(avatarProp)) {
            avatar = /* @__PURE__ */reactExports.cloneElement(avatarProp, {
              className: clsx(classes.avatar, avatarProp.props.className)
            });
          }
          let icon = null;
          if (iconProp && /* @__PURE__ */reactExports.isValidElement(iconProp)) {
            icon = /* @__PURE__ */reactExports.cloneElement(iconProp, {
              className: clsx(classes.icon, iconProp.props.className)
            });
          }
          return /* @__PURE__ */jsxRuntimeExports.jsxs(ChipRoot, _extends$1({
            as: component,
            className: clsx(classes.root, className),
            disabled: clickable && disabled ? true : void 0,
            onClick,
            onKeyDown: handleKeyDown,
            onKeyUp: handleKeyUp,
            ref: handleRef,
            tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex,
            ownerState
          }, moreProps, other, {
            children: [avatar || icon, /* @__PURE__ */jsxRuntimeExports.jsx(ChipLabel, {
              className: clsx(classes.label),
              ownerState,
              children: label
            }), deleteIcon]
          }));
        }));
        function getAutocompleteUtilityClass(slot) {
          return generateUtilityClass('MuiAutocomplete', slot);
        }
        const autocompleteClasses = exports("B", generateUtilityClasses('MuiAutocomplete', ['root', 'expanded', 'fullWidth', 'focused', 'focusVisible', 'tag', 'tagSizeSmall', 'tagSizeMedium', 'hasPopupIcon', 'hasClearIcon', 'inputRoot', 'input', 'inputFocused', 'endAdornment', 'clearIndicator', 'popupIndicator', 'popupIndicatorOpen', 'popper', 'popperDisablePortal', 'paper', 'listbox', 'loading', 'noOptions', 'option', 'groupLabel', 'groupUl']));
        const avatarGroupClasses = generateUtilityClasses('MuiAvatarGroup', ['root', 'avatar']);
        function getBadgeUtilityClass(slot) {
          return generateUtilityClass('MuiBadge', slot);
        }
        const badgeClasses = exports("b", generateUtilityClasses('MuiBadge', ['root', 'badge', 'dot', 'standard', 'anchorOriginTopRight', 'anchorOriginBottomRight', 'anchorOriginTopLeft', 'anchorOriginBottomLeft', 'invisible', 'colorError', 'colorInfo', 'colorPrimary', 'colorSecondary', 'colorSuccess', 'colorWarning', 'overlapRectangular', 'overlapCircular',
        // TODO: v6 remove the overlap value from these class keys
        'anchorOriginTopLeftCircular', 'anchorOriginTopLeftRectangular', 'anchorOriginTopRightCircular', 'anchorOriginTopRightRectangular', 'anchorOriginBottomLeftCircular', 'anchorOriginBottomLeftRectangular', 'anchorOriginBottomRightCircular', 'anchorOriginBottomRightRectangular']));
        function getButtonGroupUtilityClass(slot) {
          return generateUtilityClass('MuiButtonGroup', slot);
        }
        const buttonGroupClasses = exports("L", generateUtilityClasses('MuiButtonGroup', ['root', 'contained', 'outlined', 'text', 'disableElevation', 'disabled', 'firstButton', 'fullWidth', 'vertical', 'grouped', 'groupedHorizontal', 'groupedVertical', 'groupedText', 'groupedTextHorizontal', 'groupedTextVertical', 'groupedTextPrimary', 'groupedTextSecondary', 'groupedOutlined', 'groupedOutlinedHorizontal', 'groupedOutlinedVertical', 'groupedOutlinedPrimary', 'groupedOutlinedSecondary', 'groupedContained', 'groupedContainedHorizontal', 'groupedContainedVertical', 'groupedContainedPrimary', 'groupedContainedSecondary', 'lastButton', 'middleButton']));
        function getCircularProgressUtilityClass(slot) {
          return generateUtilityClass('MuiCircularProgress', slot);
        }
        const circularProgressClasses = generateUtilityClasses('MuiCircularProgress', ['root', 'determinate', 'indeterminate', 'colorPrimary', 'colorSecondary', 'svg', 'circle', 'circleDeterminate', 'circleIndeterminate', 'circleDisableShrink']);
        const _excluded$9 = ["className", "color", "disableShrink", "size", "style", "thickness", "value", "variant"];
        let _ = t => t,
          _t,
          _t2,
          _t3,
          _t4;
        const SIZE = 44;
        const circularRotateKeyframe = keyframes(_t || (_t = _`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`));
        const circularDashKeyframe = keyframes(_t2 || (_t2 = _`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`));
        const useUtilityClasses$9 = ownerState => {
          const classes = ownerState.classes,
            variant = ownerState.variant,
            color = ownerState.color,
            disableShrink = ownerState.disableShrink;
          const slots = {
            root: ["root", variant, `color${capitalize(color)}`],
            svg: ["svg"],
            circle: ["circle", `circle${capitalize(variant)}`, disableShrink && "circleDisableShrink"]
          };
          return composeClasses(slots, getCircularProgressUtilityClass, classes);
        };
        const CircularProgressRoot = styled$1("span", {
          name: "MuiCircularProgress",
          slot: "Root",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.root, styles[ownerState.variant], styles[`color${capitalize(ownerState.color)}`]];
          }
        })(({
          ownerState,
          theme
        }) => _extends$1({
          display: "inline-block"
        }, ownerState.variant === "determinate" && {
          transition: theme.transitions.create("transform")
        }, ownerState.color !== "inherit" && {
          color: (theme.vars || theme).palette[ownerState.color].main
        }), ({
          ownerState
        }) => ownerState.variant === "indeterminate" && css(_t3 || (_t3 = _`
      animation: ${0} 1.4s linear infinite;
    `), circularRotateKeyframe));
        const CircularProgressSVG = styled$1("svg", {
          name: "MuiCircularProgress",
          slot: "Svg",
          overridesResolver: (props, styles) => styles.svg
        })({
          display: "block"
          // Keeps the progress centered
        });
        const CircularProgressCircle = styled$1("circle", {
          name: "MuiCircularProgress",
          slot: "Circle",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.circle, styles[`circle${capitalize(ownerState.variant)}`], ownerState.disableShrink && styles.circleDisableShrink];
          }
        })(({
          ownerState,
          theme
        }) => _extends$1({
          stroke: "currentColor"
        }, ownerState.variant === "determinate" && {
          transition: theme.transitions.create("stroke-dashoffset")
        }, ownerState.variant === "indeterminate" && {
          // Some default value that looks fine waiting for the animation to kicks in.
          strokeDasharray: "80px, 200px",
          strokeDashoffset: 0
          // Add the unit to fix a Edge 16 and below bug.
        }), ({
          ownerState
        }) => ownerState.variant === "indeterminate" && !ownerState.disableShrink && css(_t4 || (_t4 = _`
      animation: ${0} 1.4s ease-in-out infinite;
    `), circularDashKeyframe));
        const CircularProgress = exports("C", /* @__PURE__ */reactExports.forwardRef(function CircularProgress2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiCircularProgress"
          });
          const className = props.className,
            _props$color2 = props.color,
            color = _props$color2 === void 0 ? "primary" : _props$color2,
            _props$disableShrink = props.disableShrink,
            disableShrink = _props$disableShrink === void 0 ? false : _props$disableShrink,
            _props$size2 = props.size,
            size = _props$size2 === void 0 ? 40 : _props$size2,
            style = props.style,
            _props$thickness = props.thickness,
            thickness = _props$thickness === void 0 ? 3.6 : _props$thickness,
            _props$value = props.value,
            value = _props$value === void 0 ? 0 : _props$value,
            _props$variant3 = props.variant,
            variant = _props$variant3 === void 0 ? "indeterminate" : _props$variant3,
            other = _objectWithoutPropertiesLoose(props, _excluded$9);
          const ownerState = _extends$1({}, props, {
            color,
            disableShrink,
            size,
            thickness,
            value,
            variant
          });
          const classes = useUtilityClasses$9(ownerState);
          const circleStyle = {};
          const rootStyle = {};
          const rootProps = {};
          if (variant === "determinate") {
            const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
            circleStyle.strokeDasharray = circumference.toFixed(3);
            rootProps["aria-valuenow"] = Math.round(value);
            circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
            rootStyle.transform = "rotate(-90deg)";
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(CircularProgressRoot, _extends$1({
            className: clsx(classes.root, className),
            style: _extends$1({
              width: size,
              height: size
            }, rootStyle, style),
            ownerState,
            ref,
            role: "progressbar"
          }, rootProps, other, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx(CircularProgressSVG, {
              className: classes.svg,
              ownerState,
              viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(CircularProgressCircle, {
                className: classes.circle,
                style: circleStyle,
                ownerState,
                cx: SIZE,
                cy: SIZE,
                r: (SIZE - thickness) / 2,
                fill: "none",
                strokeWidth: thickness
              })
            })
          }));
        }));
        function mapEventPropToEvent(eventProp) {
          return eventProp.substring(2).toLowerCase();
        }
        function clickedRootScrollbar(event, doc) {
          return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
        }
        function ClickAwayListener(props) {
          const children = props.children,
            _props$disableReactTr = props.disableReactTree,
            disableReactTree = _props$disableReactTr === void 0 ? false : _props$disableReactTr,
            _props$mouseEvent = props.mouseEvent,
            mouseEvent = _props$mouseEvent === void 0 ? "onClick" : _props$mouseEvent,
            onClickAway = props.onClickAway,
            _props$touchEvent = props.touchEvent,
            touchEvent = _props$touchEvent === void 0 ? "onTouchEnd" : _props$touchEvent;
          const movedRef = reactExports.useRef(false);
          const nodeRef = reactExports.useRef(null);
          const activatedRef = reactExports.useRef(false);
          const syntheticEventRef = reactExports.useRef(false);
          reactExports.useEffect(() => {
            setTimeout(() => {
              activatedRef.current = true;
            }, 0);
            return () => {
              activatedRef.current = false;
            };
          }, []);
          const handleRef = useForkRef(
          // @ts-expect-error TODO upstream fix
          children.ref, nodeRef);
          const handleClickAway = useEventCallback(event => {
            const insideReactTree = syntheticEventRef.current;
            syntheticEventRef.current = false;
            const doc = ownerDocument(nodeRef.current);
            if (!activatedRef.current || !nodeRef.current || "clientX" in event && clickedRootScrollbar(event, doc)) {
              return;
            }
            if (movedRef.current) {
              movedRef.current = false;
              return;
            }
            let insideDOM;
            if (event.composedPath) {
              insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
            } else {
              insideDOM = !doc.documentElement.contains(
              // @ts-expect-error returns `false` as intended when not dispatched from a Node
              event.target) || nodeRef.current.contains(
              // @ts-expect-error returns `false` as intended when not dispatched from a Node
              event.target);
            }
            if (!insideDOM && (disableReactTree || !insideReactTree)) {
              onClickAway(event);
            }
          });
          const createHandleSynthetic = handlerName => event => {
            syntheticEventRef.current = true;
            const childrenPropsHandler = children.props[handlerName];
            if (childrenPropsHandler) {
              childrenPropsHandler(event);
            }
          };
          const childrenProps = {
            ref: handleRef
          };
          if (touchEvent !== false) {
            childrenProps[touchEvent] = createHandleSynthetic(touchEvent);
          }
          reactExports.useEffect(() => {
            if (touchEvent !== false) {
              const mappedTouchEvent = mapEventPropToEvent(touchEvent);
              const doc = ownerDocument(nodeRef.current);
              const handleTouchMove = () => {
                movedRef.current = true;
              };
              doc.addEventListener(mappedTouchEvent, handleClickAway);
              doc.addEventListener("touchmove", handleTouchMove);
              return () => {
                doc.removeEventListener(mappedTouchEvent, handleClickAway);
                doc.removeEventListener("touchmove", handleTouchMove);
              };
            }
            return void 0;
          }, [handleClickAway, touchEvent]);
          if (mouseEvent !== false) {
            childrenProps[mouseEvent] = createHandleSynthetic(mouseEvent);
          }
          reactExports.useEffect(() => {
            if (mouseEvent !== false) {
              const mappedMouseEvent = mapEventPropToEvent(mouseEvent);
              const doc = ownerDocument(nodeRef.current);
              doc.addEventListener(mappedMouseEvent, handleClickAway);
              return () => {
                doc.removeEventListener(mappedMouseEvent, handleClickAway);
              };
            }
            return void 0;
          }, [handleClickAway, mouseEvent]);
          return /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Fragment, {
            children: /* @__PURE__ */reactExports.cloneElement(children, childrenProps)
          });
        }
        const html = (theme, enableColorScheme) => _extends$1({
          WebkitFontSmoothing: "antialiased",
          // Antialiasing.
          MozOsxFontSmoothing: "grayscale",
          // Antialiasing.
          // Change from `box-sizing: content-box` so that `width`
          // is not affected by `padding` or `border`.
          boxSizing: "border-box",
          // Fix font resize problem in iOS
          WebkitTextSizeAdjust: "100%"
        }, enableColorScheme && !theme.vars && {
          colorScheme: theme.palette.mode
        });
        const body = theme => _extends$1({
          color: (theme.vars || theme).palette.text.primary
        }, theme.typography.body1, {
          backgroundColor: (theme.vars || theme).palette.background.default,
          "@media print": {
            // Save printer ink.
            backgroundColor: (theme.vars || theme).palette.common.white
          }
        });
        const styles$a = (theme, enableColorScheme = false) => {
          var _theme$components;
          const colorSchemeStyles = {};
          if (enableColorScheme && theme.colorSchemes) {
            Object.entries(theme.colorSchemes).forEach(([key, scheme]) => {
              var _scheme$palette;
              colorSchemeStyles[theme.getColorSchemeSelector(key).replace(/\s*&/, "")] = {
                colorScheme: (_scheme$palette = scheme.palette) == null ? void 0 : _scheme$palette.mode
              };
            });
          }
          let defaultStyles = _extends$1({
            html: html(theme, enableColorScheme),
            "*, *::before, *::after": {
              boxSizing: "inherit"
            },
            "strong, b": {
              fontWeight: theme.typography.fontWeightBold
            },
            body: _extends$1({
              margin: 0
            }, body(theme), {
              // Add support for document.body.requestFullScreen().
              // Other elements, if background transparent, are not supported.
              "&::backdrop": {
                backgroundColor: (theme.vars || theme).palette.background.default
              }
            })
          }, colorSchemeStyles);
          const themeOverrides = (_theme$components = theme.components) == null || (_theme$components = _theme$components.MuiCssBaseline) == null ? void 0 : _theme$components.styleOverrides;
          if (themeOverrides) {
            defaultStyles = [defaultStyles, themeOverrides];
          }
          return defaultStyles;
        };
        function CssBaseline(inProps) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiCssBaseline"
          });
          const children = props.children,
            _props$enableColorSch = props.enableColorScheme,
            enableColorScheme = _props$enableColorSch === void 0 ? false : _props$enableColorSch;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(GlobalStyles, {
              styles: theme => styles$a(theme, enableColorScheme)
            }), children]
          });
        }
        const _excluded$8 = ["className", "id"];
        const useUtilityClasses$8 = ownerState => {
          const classes = ownerState.classes;
          const slots = {
            root: ["root"]
          };
          return composeClasses(slots, getDialogTitleUtilityClass, classes);
        };
        const DialogTitleRoot = styled$1(Typography, {
          name: "MuiDialogTitle",
          slot: "Root",
          overridesResolver: (props, styles) => styles.root
        })({
          padding: "16px 24px",
          flex: "0 0 auto"
        });
        const DialogTitle = exports("D", /* @__PURE__ */reactExports.forwardRef(function DialogTitle2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiDialogTitle"
          });
          const className = props.className,
            idProp = props.id,
            other = _objectWithoutPropertiesLoose(props, _excluded$8);
          const ownerState = props;
          const classes = useUtilityClasses$8(ownerState);
          const _reactExports$useCont = reactExports.useContext(DialogContext),
            _reactExports$useCont2 = _reactExports$useCont.titleId,
            titleId = _reactExports$useCont2 === void 0 ? idProp : _reactExports$useCont2;
          return /* @__PURE__ */jsxRuntimeExports.jsx(DialogTitleRoot, _extends$1({
            component: "h2",
            className: clsx(classes.root, className),
            ownerState,
            ref,
            variant: "h6",
            id: idProp != null ? idProp : titleId
          }, other));
        }));
        const fabClasses = generateUtilityClasses('MuiFab', ['root', 'primary', 'secondary', 'extended', 'circular', 'focusVisible', 'disabled', 'colorInherit', 'sizeSmall', 'sizeMedium', 'sizeLarge', 'info', 'error', 'warning', 'success']);
        const Grid2 = createGrid({
          createStyledComponent: styled$1("div", {
            name: "MuiGrid2",
            slot: "Root",
            overridesResolver: (props, styles) => styles.root
          }),
          componentName: "MuiGrid2",
          useThemeProps: inProps => useDefaultProps({
            props: inProps,
            name: "MuiGrid2"
          })
        });
        const linearProgressClasses = generateUtilityClasses('MuiLinearProgress', ['root', 'colorPrimary', 'colorSecondary', 'determinate', 'indeterminate', 'buffer', 'query', 'dashed', 'dashedColorPrimary', 'dashedColorSecondary', 'bar', 'barColorPrimary', 'barColorSecondary', 'bar1Indeterminate', 'bar1Determinate', 'bar1Buffer', 'bar2Indeterminate', 'bar2Buffer']);
        function getListItemUtilityClass(slot) {
          return generateUtilityClass('MuiListItem', slot);
        }
        const listItemClasses = generateUtilityClasses('MuiListItem', ['root', 'container', 'focusVisible', 'dense', 'alignItemsFlexStart', 'disabled', 'divider', 'gutters', 'padding', 'button', 'secondaryAction', 'selected']);
        function getListItemButtonUtilityClass(slot) {
          return generateUtilityClass('MuiListItemButton', slot);
        }
        const listItemButtonClasses = generateUtilityClasses('MuiListItemButton', ['root', 'focusVisible', 'dense', 'alignItemsFlexStart', 'disabled', 'divider', 'gutters', 'selected']);
        const _excluded$7 = ["alignItems", "autoFocus", "component", "children", "dense", "disableGutters", "divider", "focusVisibleClassName", "selected", "className"];
        const overridesResolver$1 = (props, styles) => {
          const ownerState = props.ownerState;
          return [styles.root, ownerState.dense && styles.dense, ownerState.alignItems === "flex-start" && styles.alignItemsFlexStart, ownerState.divider && styles.divider, !ownerState.disableGutters && styles.gutters];
        };
        const useUtilityClasses$7 = ownerState => {
          const alignItems = ownerState.alignItems,
            classes = ownerState.classes,
            dense = ownerState.dense,
            disabled = ownerState.disabled,
            disableGutters = ownerState.disableGutters,
            divider = ownerState.divider,
            selected = ownerState.selected;
          const slots = {
            root: ["root", dense && "dense", !disableGutters && "gutters", divider && "divider", disabled && "disabled", alignItems === "flex-start" && "alignItemsFlexStart", selected && "selected"]
          };
          const composedClasses = composeClasses(slots, getListItemButtonUtilityClass, classes);
          return _extends$1({}, classes, composedClasses);
        };
        const ListItemButtonRoot = styled$1(ButtonBase, {
          shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === "classes",
          name: "MuiListItemButton",
          slot: "Root",
          overridesResolver: overridesResolver$1
        })(({
          theme,
          ownerState
        }) => _extends$1({
          display: "flex",
          flexGrow: 1,
          justifyContent: "flex-start",
          alignItems: "center",
          position: "relative",
          textDecoration: "none",
          minWidth: 0,
          boxSizing: "border-box",
          textAlign: "left",
          paddingTop: 8,
          paddingBottom: 8,
          transition: theme.transitions.create("background-color", {
            duration: theme.transitions.duration.shortest
          }),
          "&:hover": {
            textDecoration: "none",
            backgroundColor: (theme.vars || theme).palette.action.hover,
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              backgroundColor: "transparent"
            }
          },
          [`&.${listItemButtonClasses.selected}`]: {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity),
            [`&.${listItemButtonClasses.focusVisible}`]: {
              backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
            }
          },
          [`&.${listItemButtonClasses.selected}:hover`]: {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity)
            }
          },
          [`&.${listItemButtonClasses.focusVisible}`]: {
            backgroundColor: (theme.vars || theme).palette.action.focus
          },
          [`&.${listItemButtonClasses.disabled}`]: {
            opacity: (theme.vars || theme).palette.action.disabledOpacity
          }
        }, ownerState.divider && {
          borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
          backgroundClip: "padding-box"
        }, ownerState.alignItems === "flex-start" && {
          alignItems: "flex-start"
        }, !ownerState.disableGutters && {
          paddingLeft: 16,
          paddingRight: 16
        }, ownerState.dense && {
          paddingTop: 4,
          paddingBottom: 4
        }));
        const ListItemButton = /* @__PURE__ */reactExports.forwardRef(function ListItemButton2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiListItemButton"
          });
          const _props$alignItems = props.alignItems,
            alignItems = _props$alignItems === void 0 ? "center" : _props$alignItems,
            _props$autoFocus = props.autoFocus,
            autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,
            _props$component2 = props.component,
            component = _props$component2 === void 0 ? "div" : _props$component2,
            children = props.children,
            _props$dense = props.dense,
            dense = _props$dense === void 0 ? false : _props$dense,
            _props$disableGutters = props.disableGutters,
            disableGutters = _props$disableGutters === void 0 ? false : _props$disableGutters,
            _props$divider = props.divider,
            divider = _props$divider === void 0 ? false : _props$divider,
            focusVisibleClassName = props.focusVisibleClassName,
            _props$selected = props.selected,
            selected = _props$selected === void 0 ? false : _props$selected,
            className = props.className,
            other = _objectWithoutPropertiesLoose(props, _excluded$7);
          const context = reactExports.useContext(ListContext);
          const childContext = reactExports.useMemo(() => ({
            dense: dense || context.dense || false,
            alignItems,
            disableGutters
          }), [alignItems, context.dense, dense, disableGutters]);
          const listItemRef = reactExports.useRef(null);
          useEnhancedEffect(() => {
            if (autoFocus) {
              if (listItemRef.current) {
                listItemRef.current.focus();
              }
            }
          }, [autoFocus]);
          const ownerState = _extends$1({}, props, {
            alignItems,
            dense: childContext.dense,
            disableGutters,
            divider,
            selected
          });
          const classes = useUtilityClasses$7(ownerState);
          const handleRef = useForkRef(listItemRef, ref);
          return /* @__PURE__ */jsxRuntimeExports.jsx(ListContext.Provider, {
            value: childContext,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(ListItemButtonRoot, _extends$1({
              ref: handleRef,
              href: other.href || other.to,
              component: (other.href || other.to) && component === "div" ? "button" : component,
              focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
              ownerState,
              className: clsx(classes.root, className)
            }, other, {
              classes,
              children
            }))
          });
        });
        function getListItemSecondaryActionClassesUtilityClass(slot) {
          return generateUtilityClass('MuiListItemSecondaryAction', slot);
        }
        generateUtilityClasses('MuiListItemSecondaryAction', ['root', 'disableGutters']);
        const _excluded$6 = ["className"];
        const useUtilityClasses$6 = ownerState => {
          const disableGutters = ownerState.disableGutters,
            classes = ownerState.classes;
          const slots = {
            root: ["root", disableGutters && "disableGutters"]
          };
          return composeClasses(slots, getListItemSecondaryActionClassesUtilityClass, classes);
        };
        const ListItemSecondaryActionRoot = styled$1("div", {
          name: "MuiListItemSecondaryAction",
          slot: "Root",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.root, ownerState.disableGutters && styles.disableGutters];
          }
        })(({
          ownerState
        }) => _extends$1({
          position: "absolute",
          right: 16,
          top: "50%",
          transform: "translateY(-50%)"
        }, ownerState.disableGutters && {
          right: 0
        }));
        const ListItemSecondaryAction = /* @__PURE__ */reactExports.forwardRef(function ListItemSecondaryAction2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiListItemSecondaryAction"
          });
          const className = props.className,
            other = _objectWithoutPropertiesLoose(props, _excluded$6);
          const context = reactExports.useContext(ListContext);
          const ownerState = _extends$1({}, props, {
            disableGutters: context.disableGutters
          });
          const classes = useUtilityClasses$6(ownerState);
          return /* @__PURE__ */jsxRuntimeExports.jsx(ListItemSecondaryActionRoot, _extends$1({
            className: clsx(classes.root, className),
            ownerState,
            ref
          }, other));
        });
        ListItemSecondaryAction.muiName = "ListItemSecondaryAction";
        const _excluded$5 = ["className"],
          _excluded2$1 = ["alignItems", "autoFocus", "button", "children", "className", "component", "components", "componentsProps", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "disablePadding", "divider", "focusVisibleClassName", "secondaryAction", "selected", "slotProps", "slots"];
        const overridesResolver = (props, styles) => {
          const ownerState = props.ownerState;
          return [styles.root, ownerState.dense && styles.dense, ownerState.alignItems === "flex-start" && styles.alignItemsFlexStart, ownerState.divider && styles.divider, !ownerState.disableGutters && styles.gutters, !ownerState.disablePadding && styles.padding, ownerState.button && styles.button, ownerState.hasSecondaryAction && styles.secondaryAction];
        };
        const useUtilityClasses$5 = ownerState => {
          const alignItems = ownerState.alignItems,
            button = ownerState.button,
            classes = ownerState.classes,
            dense = ownerState.dense,
            disabled = ownerState.disabled,
            disableGutters = ownerState.disableGutters,
            disablePadding = ownerState.disablePadding,
            divider = ownerState.divider,
            hasSecondaryAction = ownerState.hasSecondaryAction,
            selected = ownerState.selected;
          const slots = {
            root: ["root", dense && "dense", !disableGutters && "gutters", !disablePadding && "padding", divider && "divider", disabled && "disabled", button && "button", alignItems === "flex-start" && "alignItemsFlexStart", hasSecondaryAction && "secondaryAction", selected && "selected"],
            container: ["container"]
          };
          return composeClasses(slots, getListItemUtilityClass, classes);
        };
        const ListItemRoot = styled$1("div", {
          name: "MuiListItem",
          slot: "Root",
          overridesResolver
        })(({
          theme,
          ownerState
        }) => _extends$1({
          display: "flex",
          justifyContent: "flex-start",
          alignItems: "center",
          position: "relative",
          textDecoration: "none",
          width: "100%",
          boxSizing: "border-box",
          textAlign: "left"
        }, !ownerState.disablePadding && _extends$1({
          paddingTop: 8,
          paddingBottom: 8
        }, ownerState.dense && {
          paddingTop: 4,
          paddingBottom: 4
        }, !ownerState.disableGutters && {
          paddingLeft: 16,
          paddingRight: 16
        }, !!ownerState.secondaryAction && {
          // Add some space to avoid collision as `ListItemSecondaryAction`
          // is absolutely positioned.
          paddingRight: 48
        }), !!ownerState.secondaryAction && {
          [`& > .${listItemButtonClasses.root}`]: {
            paddingRight: 48
          }
        }, {
          [`&.${listItemClasses.focusVisible}`]: {
            backgroundColor: (theme.vars || theme).palette.action.focus
          },
          [`&.${listItemClasses.selected}`]: {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity),
            [`&.${listItemClasses.focusVisible}`]: {
              backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
            }
          },
          [`&.${listItemClasses.disabled}`]: {
            opacity: (theme.vars || theme).palette.action.disabledOpacity
          }
        }, ownerState.alignItems === "flex-start" && {
          alignItems: "flex-start"
        }, ownerState.divider && {
          borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
          backgroundClip: "padding-box"
        }, ownerState.button && {
          transition: theme.transitions.create("background-color", {
            duration: theme.transitions.duration.shortest
          }),
          "&:hover": {
            textDecoration: "none",
            backgroundColor: (theme.vars || theme).palette.action.hover,
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              backgroundColor: "transparent"
            }
          },
          [`&.${listItemClasses.selected}:hover`]: {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity)
            }
          }
        }, ownerState.hasSecondaryAction && {
          // Add some space to avoid collision as `ListItemSecondaryAction`
          // is absolutely positioned.
          paddingRight: 48
        }));
        const ListItemContainer = styled$1("li", {
          name: "MuiListItem",
          slot: "Container",
          overridesResolver: (props, styles) => styles.container
        })({
          position: "relative"
        });
        const ListItem = /* @__PURE__ */reactExports.forwardRef(function ListItem2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiListItem"
          });
          const _props$alignItems2 = props.alignItems,
            alignItems = _props$alignItems2 === void 0 ? "center" : _props$alignItems2,
            _props$autoFocus2 = props.autoFocus,
            autoFocus = _props$autoFocus2 === void 0 ? false : _props$autoFocus2,
            _props$button = props.button,
            button = _props$button === void 0 ? false : _props$button,
            childrenProp = props.children,
            className = props.className,
            componentProp = props.component,
            _props$components2 = props.components,
            components = _props$components2 === void 0 ? {} : _props$components2,
            _props$componentsProp2 = props.componentsProps,
            componentsProps = _props$componentsProp2 === void 0 ? {} : _props$componentsProp2,
            _props$ContainerCompo = props.ContainerComponent,
            ContainerComponent = _props$ContainerCompo === void 0 ? "li" : _props$ContainerCompo,
            _props$ContainerProps = props.ContainerProps,
            _props$ContainerProps2 = _props$ContainerProps === void 0 ? {} : _props$ContainerProps,
            ContainerClassName = _props$ContainerProps2.className,
            _props$dense2 = props.dense,
            dense = _props$dense2 === void 0 ? false : _props$dense2,
            _props$disabled2 = props.disabled,
            disabled = _props$disabled2 === void 0 ? false : _props$disabled2,
            _props$disableGutters2 = props.disableGutters,
            disableGutters = _props$disableGutters2 === void 0 ? false : _props$disableGutters2,
            _props$disablePadding = props.disablePadding,
            disablePadding = _props$disablePadding === void 0 ? false : _props$disablePadding,
            _props$divider2 = props.divider,
            divider = _props$divider2 === void 0 ? false : _props$divider2,
            focusVisibleClassName = props.focusVisibleClassName,
            secondaryAction = props.secondaryAction,
            _props$selected2 = props.selected,
            selected = _props$selected2 === void 0 ? false : _props$selected2,
            _props$slotProps2 = props.slotProps,
            slotProps = _props$slotProps2 === void 0 ? {} : _props$slotProps2,
            _props$slots2 = props.slots,
            slots = _props$slots2 === void 0 ? {} : _props$slots2,
            ContainerProps = _objectWithoutPropertiesLoose(props.ContainerProps, _excluded$5),
            other = _objectWithoutPropertiesLoose(props, _excluded2$1);
          const context = reactExports.useContext(ListContext);
          const childContext = reactExports.useMemo(() => ({
            dense: dense || context.dense || false,
            alignItems,
            disableGutters
          }), [alignItems, context.dense, dense, disableGutters]);
          const listItemRef = reactExports.useRef(null);
          useEnhancedEffect(() => {
            if (autoFocus) {
              if (listItemRef.current) {
                listItemRef.current.focus();
              }
            }
          }, [autoFocus]);
          const children = reactExports.Children.toArray(childrenProp);
          const hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ["ListItemSecondaryAction"]);
          const ownerState = _extends$1({}, props, {
            alignItems,
            autoFocus,
            button,
            dense: childContext.dense,
            disabled,
            disableGutters,
            disablePadding,
            divider,
            hasSecondaryAction,
            selected
          });
          const classes = useUtilityClasses$5(ownerState);
          const handleRef = useForkRef(listItemRef, ref);
          const Root = slots.root || components.Root || ListItemRoot;
          const rootProps = slotProps.root || componentsProps.root || {};
          const componentProps = _extends$1({
            className: clsx(classes.root, rootProps.className, className),
            disabled
          }, other);
          let Component = componentProp || "li";
          if (button) {
            componentProps.component = componentProp || "div";
            componentProps.focusVisibleClassName = clsx(listItemClasses.focusVisible, focusVisibleClassName);
            Component = ButtonBase;
          }
          if (hasSecondaryAction) {
            Component = !componentProps.component && !componentProp ? "div" : Component;
            if (ContainerComponent === "li") {
              if (Component === "li") {
                Component = "div";
              } else if (componentProps.component === "li") {
                componentProps.component = "div";
              }
            }
            return /* @__PURE__ */jsxRuntimeExports.jsx(ListContext.Provider, {
              value: childContext,
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(ListItemContainer, _extends$1({
                as: ContainerComponent,
                className: clsx(classes.container, ContainerClassName),
                ref: handleRef,
                ownerState
              }, ContainerProps, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Root, _extends$1({}, rootProps, !isHostComponent(Root) && {
                  as: Component,
                  ownerState: _extends$1({}, ownerState, rootProps.ownerState)
                }, componentProps, {
                  children
                })), children.pop()]
              }))
            });
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(ListContext.Provider, {
            value: childContext,
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(Root, _extends$1({}, rootProps, {
              as: Component,
              ref: handleRef
            }, !isHostComponent(Root) && {
              ownerState: _extends$1({}, ownerState, rootProps.ownerState)
            }, componentProps, {
              children: [children, secondaryAction && /* @__PURE__ */jsxRuntimeExports.jsx(ListItemSecondaryAction, {
                children: secondaryAction
              })]
            }))
          });
        });
        const _excluded$4 = ["className"];
        const useUtilityClasses$4 = ownerState => {
          const alignItems = ownerState.alignItems,
            classes = ownerState.classes;
          const slots = {
            root: ["root", alignItems === "flex-start" && "alignItemsFlexStart"]
          };
          return composeClasses(slots, getListItemIconUtilityClass, classes);
        };
        const ListItemIconRoot = styled$1("div", {
          name: "MuiListItemIcon",
          slot: "Root",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.root, ownerState.alignItems === "flex-start" && styles.alignItemsFlexStart];
          }
        })(({
          theme,
          ownerState
        }) => _extends$1({
          minWidth: 56,
          color: (theme.vars || theme).palette.action.active,
          flexShrink: 0,
          display: "inline-flex"
        }, ownerState.alignItems === "flex-start" && {
          marginTop: 8
        }));
        const ListItemIcon = exports("Q", /* @__PURE__ */reactExports.forwardRef(function ListItemIcon2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiListItemIcon"
          });
          const className = props.className,
            other = _objectWithoutPropertiesLoose(props, _excluded$4);
          const context = reactExports.useContext(ListContext);
          const ownerState = _extends$1({}, props, {
            alignItems: context.alignItems
          });
          const classes = useUtilityClasses$4(ownerState);
          return /* @__PURE__ */jsxRuntimeExports.jsx(ListItemIconRoot, _extends$1({
            className: clsx(classes.root, className),
            ownerState,
            ref
          }, other));
        }));
        const paginationItemClasses = generateUtilityClasses('MuiPaginationItem', ['root', 'page', 'sizeSmall', 'sizeLarge', 'text', 'textPrimary', 'textSecondary', 'outlined', 'outlinedPrimary', 'outlinedSecondary', 'rounded', 'ellipsis', 'firstLast', 'previousNext', 'focusVisible', 'disabled', 'selected', 'icon', 'colorPrimary', 'colorSecondary']);
        const ratingClasses = generateUtilityClasses('MuiRating', ['root', 'sizeSmall', 'sizeMedium', 'sizeLarge', 'readOnly', 'disabled', 'focusVisible', 'visuallyHidden', 'pristine', 'label', 'labelEmptyValueActive', 'icon', 'iconEmpty', 'iconFilled', 'iconHover', 'iconFocus', 'iconActive', 'decimal']);
        function getSliderUtilityClass(slot) {
          return generateUtilityClass('MuiSlider', slot);
        }
        const sliderClasses = exports("N", generateUtilityClasses('MuiSlider', ['root', 'active', 'colorPrimary', 'colorSecondary', 'colorError', 'colorInfo', 'colorSuccess', 'colorWarning', 'disabled', 'dragging', 'focusVisible', 'mark', 'markActive', 'marked', 'markLabel', 'markLabelActive', 'rail', 'sizeSmall', 'thumb', 'thumbColorPrimary', 'thumbColorSecondary', 'thumbColorError', 'thumbColorSuccess', 'thumbColorInfo', 'thumbColorWarning', 'track', 'trackInverted', 'trackFalse', 'thumbSizeSmall', 'valueLabel', 'valueLabelOpen', 'valueLabelCircle', 'valueLabelLabel', 'vertical']));

        /**
         * The basic building block for creating custom snackbar.
         *
         * Demos:
         *
         * - [Snackbar](https://mui.com/base-ui/react-snackbar/#hook)
         *
         * API:
         *
         * - [useSnackbar API](https://mui.com/base-ui/react-snackbar/hooks-api/#use-snackbar)
         */
        function useSnackbar(parameters = {}) {
          const _parameters$autoHideD = parameters.autoHideDuration,
            autoHideDuration = _parameters$autoHideD === void 0 ? null : _parameters$autoHideD,
            _parameters$disableWi = parameters.disableWindowBlurListener,
            disableWindowBlurListener = _parameters$disableWi === void 0 ? false : _parameters$disableWi,
            onClose = parameters.onClose,
            open = parameters.open,
            resumeHideDuration = parameters.resumeHideDuration;
          const timerAutoHide = useTimeout();
          reactExports.useEffect(() => {
            if (!open) {
              return undefined;
            }

            /**
             * @param {KeyboardEvent} nativeEvent
             */
            function handleKeyDown(nativeEvent) {
              if (!nativeEvent.defaultPrevented) {
                // IE11, Edge (prior to using Blink?) use 'Esc'
                if (nativeEvent.key === 'Escape' || nativeEvent.key === 'Esc') {
                  // not calling `preventDefault` since we don't know if people may ignore this event e.g. a permanently open snackbar
                  onClose == null || onClose(nativeEvent, 'escapeKeyDown');
                }
              }
            }
            document.addEventListener('keydown', handleKeyDown);
            return () => {
              document.removeEventListener('keydown', handleKeyDown);
            };
          }, [open, onClose]);
          const handleClose = useEventCallback((event, reason) => {
            onClose == null || onClose(event, reason);
          });
          const setAutoHideTimer = useEventCallback(autoHideDurationParam => {
            if (!onClose || autoHideDurationParam == null) {
              return;
            }
            timerAutoHide.start(autoHideDurationParam, () => {
              handleClose(null, 'timeout');
            });
          });
          reactExports.useEffect(() => {
            if (open) {
              setAutoHideTimer(autoHideDuration);
            }
            return timerAutoHide.clear;
          }, [open, autoHideDuration, setAutoHideTimer, timerAutoHide]);
          const handleClickAway = event => {
            onClose == null || onClose(event, 'clickaway');
          };

          // Pause the timer when the user is interacting with the Snackbar
          // or when the user hide the window.
          const handlePause = timerAutoHide.clear;

          // Restart the timer when the user is no longer interacting with the Snackbar
          // or when the window is shown back.
          const handleResume = reactExports.useCallback(() => {
            if (autoHideDuration != null) {
              setAutoHideTimer(resumeHideDuration != null ? resumeHideDuration : autoHideDuration * 0.5);
            }
          }, [autoHideDuration, resumeHideDuration, setAutoHideTimer]);
          const createHandleBlur = otherHandlers => event => {
            const onBlurCallback = otherHandlers.onBlur;
            onBlurCallback == null || onBlurCallback(event);
            handleResume();
          };
          const createHandleFocus = otherHandlers => event => {
            const onFocusCallback = otherHandlers.onFocus;
            onFocusCallback == null || onFocusCallback(event);
            handlePause();
          };
          const createMouseEnter = otherHandlers => event => {
            const onMouseEnterCallback = otherHandlers.onMouseEnter;
            onMouseEnterCallback == null || onMouseEnterCallback(event);
            handlePause();
          };
          const createMouseLeave = otherHandlers => event => {
            const onMouseLeaveCallback = otherHandlers.onMouseLeave;
            onMouseLeaveCallback == null || onMouseLeaveCallback(event);
            handleResume();
          };
          reactExports.useEffect(() => {
            // TODO: window global should be refactored here
            if (!disableWindowBlurListener && open) {
              window.addEventListener('focus', handleResume);
              window.addEventListener('blur', handlePause);
              return () => {
                window.removeEventListener('focus', handleResume);
                window.removeEventListener('blur', handlePause);
              };
            }
            return undefined;
          }, [disableWindowBlurListener, open, handleResume, handlePause]);
          const getRootProps = (externalProps = {}) => {
            const externalEventHandlers = _extends$1({}, extractEventHandlers(parameters), extractEventHandlers(externalProps));
            return _extends$1({
              // ClickAwayListener adds an `onClick` prop which results in the alert not being announced.
              // See https://github.com/mui/material-ui/issues/29080
              role: 'presentation'
            }, externalProps, externalEventHandlers, {
              onBlur: createHandleBlur(externalEventHandlers),
              onFocus: createHandleFocus(externalEventHandlers),
              onMouseEnter: createMouseEnter(externalEventHandlers),
              onMouseLeave: createMouseLeave(externalEventHandlers)
            });
          };
          return {
            getRootProps,
            onClickAway: handleClickAway
          };
        }
        function getSnackbarContentUtilityClass(slot) {
          return generateUtilityClass('MuiSnackbarContent', slot);
        }
        generateUtilityClasses('MuiSnackbarContent', ['root', 'message', 'action']);
        const _excluded$3 = ["action", "className", "message", "role"];
        const useUtilityClasses$3 = ownerState => {
          const classes = ownerState.classes;
          const slots = {
            root: ["root"],
            action: ["action"],
            message: ["message"]
          };
          return composeClasses(slots, getSnackbarContentUtilityClass, classes);
        };
        const SnackbarContentRoot = styled$1(Paper, {
          name: "MuiSnackbarContent",
          slot: "Root",
          overridesResolver: (props, styles) => styles.root
        })(({
          theme
        }) => {
          const emphasis = theme.palette.mode === "light" ? 0.8 : 0.98;
          const backgroundColor = emphasize_1(theme.palette.background.default, emphasis);
          return _extends$1({}, theme.typography.body2, {
            color: theme.vars ? theme.vars.palette.SnackbarContent.color : theme.palette.getContrastText(backgroundColor),
            backgroundColor: theme.vars ? theme.vars.palette.SnackbarContent.bg : backgroundColor,
            display: "flex",
            alignItems: "center",
            flexWrap: "wrap",
            padding: "6px 16px",
            borderRadius: (theme.vars || theme).shape.borderRadius,
            flexGrow: 1,
            [theme.breakpoints.up("sm")]: {
              flexGrow: "initial",
              minWidth: 288
            }
          });
        });
        const SnackbarContentMessage = styled$1("div", {
          name: "MuiSnackbarContent",
          slot: "Message",
          overridesResolver: (props, styles) => styles.message
        })({
          padding: "8px 0"
        });
        const SnackbarContentAction = styled$1("div", {
          name: "MuiSnackbarContent",
          slot: "Action",
          overridesResolver: (props, styles) => styles.action
        })({
          display: "flex",
          alignItems: "center",
          marginLeft: "auto",
          paddingLeft: 16,
          marginRight: -8
        });
        const SnackbarContent = /* @__PURE__ */reactExports.forwardRef(function SnackbarContent2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiSnackbarContent"
          });
          const action = props.action,
            className = props.className,
            message = props.message,
            _props$role2 = props.role,
            role = _props$role2 === void 0 ? "alert" : _props$role2,
            other = _objectWithoutPropertiesLoose(props, _excluded$3);
          const ownerState = props;
          const classes = useUtilityClasses$3(ownerState);
          return /* @__PURE__ */jsxRuntimeExports.jsxs(SnackbarContentRoot, _extends$1({
            role,
            square: true,
            elevation: 6,
            className: clsx(classes.root, className),
            ownerState,
            ref
          }, other, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(SnackbarContentMessage, {
              className: classes.message,
              ownerState,
              children: message
            }), action ? /* @__PURE__ */jsxRuntimeExports.jsx(SnackbarContentAction, {
              className: classes.action,
              ownerState,
              children: action
            }) : null]
          }));
        });
        function getSnackbarUtilityClass(slot) {
          return generateUtilityClass('MuiSnackbar', slot);
        }
        generateUtilityClasses('MuiSnackbar', ['root', 'anchorOriginTopCenter', 'anchorOriginBottomCenter', 'anchorOriginTopRight', 'anchorOriginBottomRight', 'anchorOriginTopLeft', 'anchorOriginBottomLeft']);
        const _excluded$2 = ["onEnter", "onExited"],
          _excluded2 = ["action", "anchorOrigin", "autoHideDuration", "children", "className", "ClickAwayListenerProps", "ContentProps", "disableWindowBlurListener", "message", "onBlur", "onClose", "onFocus", "onMouseEnter", "onMouseLeave", "open", "resumeHideDuration", "TransitionComponent", "transitionDuration", "TransitionProps"];
        const useUtilityClasses$2 = ownerState => {
          const classes = ownerState.classes,
            anchorOrigin = ownerState.anchorOrigin;
          const slots = {
            root: ["root", `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`]
          };
          return composeClasses(slots, getSnackbarUtilityClass, classes);
        };
        const SnackbarRoot = styled$1("div", {
          name: "MuiSnackbar",
          slot: "Root",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.root, styles[`anchorOrigin${capitalize(ownerState.anchorOrigin.vertical)}${capitalize(ownerState.anchorOrigin.horizontal)}`]];
          }
        })(({
          theme,
          ownerState
        }) => {
          const center = {
            left: "50%",
            right: "auto",
            transform: "translateX(-50%)"
          };
          return _extends$1({
            zIndex: (theme.vars || theme).zIndex.snackbar,
            position: "fixed",
            display: "flex",
            left: 8,
            right: 8,
            justifyContent: "center",
            alignItems: "center"
          }, ownerState.anchorOrigin.vertical === "top" ? {
            top: 8
          } : {
            bottom: 8
          }, ownerState.anchorOrigin.horizontal === "left" && {
            justifyContent: "flex-start"
          }, ownerState.anchorOrigin.horizontal === "right" && {
            justifyContent: "flex-end"
          }, {
            [theme.breakpoints.up("sm")]: _extends$1({}, ownerState.anchorOrigin.vertical === "top" ? {
              top: 24
            } : {
              bottom: 24
            }, ownerState.anchorOrigin.horizontal === "center" && center, ownerState.anchorOrigin.horizontal === "left" && {
              left: 24,
              right: "auto"
            }, ownerState.anchorOrigin.horizontal === "right" && {
              right: 24,
              left: "auto"
            })
          });
        });
        const Snackbar = exports("a", /* @__PURE__ */reactExports.forwardRef(function Snackbar2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiSnackbar"
          });
          const theme = useTheme$1();
          const defaultTransitionDuration = {
            enter: theme.transitions.duration.enteringScreen,
            exit: theme.transitions.duration.leavingScreen
          };
          const action = props.action,
            _props$anchorOrigin = props.anchorOrigin,
            _props$anchorOrigin2 = _props$anchorOrigin === void 0 ? {
              vertical: "bottom",
              horizontal: "left"
            } : _props$anchorOrigin,
            vertical = _props$anchorOrigin2.vertical,
            horizontal = _props$anchorOrigin2.horizontal,
            _props$autoHideDurati = props.autoHideDuration,
            autoHideDuration = _props$autoHideDurati === void 0 ? null : _props$autoHideDurati,
            children = props.children,
            className = props.className,
            ClickAwayListenerProps = props.ClickAwayListenerProps,
            ContentProps = props.ContentProps,
            _props$disableWindowB = props.disableWindowBlurListener,
            disableWindowBlurListener = _props$disableWindowB === void 0 ? false : _props$disableWindowB,
            message = props.message,
            open = props.open,
            _props$TransitionComp = props.TransitionComponent,
            TransitionComponent = _props$TransitionComp === void 0 ? Grow : _props$TransitionComp,
            _props$transitionDura = props.transitionDuration,
            transitionDuration = _props$transitionDura === void 0 ? defaultTransitionDuration : _props$transitionDura,
            _props$TransitionProp = props.TransitionProps,
            _props$TransitionProp2 = _props$TransitionProp === void 0 ? {} : _props$TransitionProp,
            onEnter = _props$TransitionProp2.onEnter,
            onExited = _props$TransitionProp2.onExited,
            TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$2),
            other = _objectWithoutPropertiesLoose(props, _excluded2);
          const ownerState = _extends$1({}, props, {
            anchorOrigin: {
              vertical,
              horizontal
            },
            autoHideDuration,
            disableWindowBlurListener,
            TransitionComponent,
            transitionDuration
          });
          const classes = useUtilityClasses$2(ownerState);
          const _useSnackbar = useSnackbar(_extends$1({}, ownerState)),
            getRootProps = _useSnackbar.getRootProps,
            onClickAway = _useSnackbar.onClickAway;
          const _reactExports$useStat = reactExports.useState(true),
            _reactExports$useStat2 = _slicedToArray(_reactExports$useStat, 2),
            exited = _reactExports$useStat2[0],
            setExited = _reactExports$useStat2[1];
          const rootProps = useSlotProps({
            elementType: SnackbarRoot,
            getSlotProps: getRootProps,
            externalForwardedProps: other,
            ownerState,
            additionalProps: {
              ref
            },
            className: [classes.root, className]
          });
          const handleExited = node => {
            setExited(true);
            if (onExited) {
              onExited(node);
            }
          };
          const handleEnter = (node, isAppearing) => {
            setExited(false);
            if (onEnter) {
              onEnter(node, isAppearing);
            }
          };
          if (!open && exited) {
            return null;
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(ClickAwayListener, _extends$1({
            onClickAway
          }, ClickAwayListenerProps, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx(SnackbarRoot, _extends$1({}, rootProps, {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
                appear: true,
                in: open,
                timeout: transitionDuration,
                direction: vertical === "top" ? "down" : "up",
                onEnter: handleEnter,
                onExited: handleExited
              }, TransitionProps, {
                children: children || /* @__PURE__ */jsxRuntimeExports.jsx(SnackbarContent, _extends$1({
                  message,
                  action
                }, ContentProps))
              }))
            }))
          }));
        }));
        function getTooltipUtilityClass(slot) {
          return generateUtilityClass('MuiTooltip', slot);
        }
        const tooltipClasses = generateUtilityClasses('MuiTooltip', ['popper', 'popperInteractive', 'popperArrow', 'popperClose', 'tooltip', 'tooltipArrow', 'touch', 'tooltipPlacementLeft', 'tooltipPlacementRight', 'tooltipPlacementTop', 'tooltipPlacementBottom', 'arrow']);
        const _excluded$1 = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"];
        function round(value) {
          return Math.round(value * 1e5) / 1e5;
        }
        const useUtilityClasses$1 = ownerState => {
          const classes = ownerState.classes,
            disableInteractive = ownerState.disableInteractive,
            arrow = ownerState.arrow,
            touch = ownerState.touch,
            placement = ownerState.placement;
          const slots = {
            popper: ["popper", !disableInteractive && "popperInteractive", arrow && "popperArrow"],
            tooltip: ["tooltip", arrow && "tooltipArrow", touch && "touch", `tooltipPlacement${capitalize(placement.split("-")[0])}`],
            arrow: ["arrow"]
          };
          return composeClasses(slots, getTooltipUtilityClass, classes);
        };
        const TooltipPopper = styled$1(Popper, {
          name: "MuiTooltip",
          slot: "Popper",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.popper, !ownerState.disableInteractive && styles.popperInteractive, ownerState.arrow && styles.popperArrow, !ownerState.open && styles.popperClose];
          }
        })(({
          theme,
          ownerState,
          open
        }) => _extends$1({
          zIndex: (theme.vars || theme).zIndex.tooltip,
          pointerEvents: "none"
        }, !ownerState.disableInteractive && {
          pointerEvents: "auto"
        }, !open && {
          pointerEvents: "none"
        }, ownerState.arrow && {
          [`&[data-popper-placement*="bottom"] .${tooltipClasses.arrow}`]: {
            top: 0,
            marginTop: "-0.71em",
            "&::before": {
              transformOrigin: "0 100%"
            }
          },
          [`&[data-popper-placement*="top"] .${tooltipClasses.arrow}`]: {
            bottom: 0,
            marginBottom: "-0.71em",
            "&::before": {
              transformOrigin: "100% 0"
            }
          },
          [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: _extends$1({}, !ownerState.isRtl ? {
            left: 0,
            marginLeft: "-0.71em"
          } : {
            right: 0,
            marginRight: "-0.71em"
          }, {
            height: "1em",
            width: "0.71em",
            "&::before": {
              transformOrigin: "100% 100%"
            }
          }),
          [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: _extends$1({}, !ownerState.isRtl ? {
            right: 0,
            marginRight: "-0.71em"
          } : {
            left: 0,
            marginLeft: "-0.71em"
          }, {
            height: "1em",
            width: "0.71em",
            "&::before": {
              transformOrigin: "0 0"
            }
          })
        }));
        const TooltipTooltip = styled$1("div", {
          name: "MuiTooltip",
          slot: "Tooltip",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.tooltip, ownerState.touch && styles.touch, ownerState.arrow && styles.tooltipArrow, styles[`tooltipPlacement${capitalize(ownerState.placement.split("-")[0])}`]];
          }
        })(({
          theme,
          ownerState
        }) => _extends$1({
          backgroundColor: theme.vars ? theme.vars.palette.Tooltip.bg : alpha_1(theme.palette.grey[700], 0.92),
          borderRadius: (theme.vars || theme).shape.borderRadius,
          color: (theme.vars || theme).palette.common.white,
          fontFamily: theme.typography.fontFamily,
          padding: "4px 8px",
          fontSize: theme.typography.pxToRem(11),
          maxWidth: 300,
          margin: 2,
          wordWrap: "break-word",
          fontWeight: theme.typography.fontWeightMedium
        }, ownerState.arrow && {
          position: "relative",
          margin: 0
        }, ownerState.touch && {
          padding: "8px 16px",
          fontSize: theme.typography.pxToRem(14),
          lineHeight: `${round(16 / 14)}em`,
          fontWeight: theme.typography.fontWeightRegular
        }, {
          [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: _extends$1({
            transformOrigin: "right center"
          }, !ownerState.isRtl ? _extends$1({
            marginRight: "14px"
          }, ownerState.touch && {
            marginRight: "24px"
          }) : _extends$1({
            marginLeft: "14px"
          }, ownerState.touch && {
            marginLeft: "24px"
          })),
          [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: _extends$1({
            transformOrigin: "left center"
          }, !ownerState.isRtl ? _extends$1({
            marginLeft: "14px"
          }, ownerState.touch && {
            marginLeft: "24px"
          }) : _extends$1({
            marginRight: "14px"
          }, ownerState.touch && {
            marginRight: "24px"
          })),
          [`.${tooltipClasses.popper}[data-popper-placement*="top"] &`]: _extends$1({
            transformOrigin: "center bottom",
            marginBottom: "14px"
          }, ownerState.touch && {
            marginBottom: "24px"
          }),
          [`.${tooltipClasses.popper}[data-popper-placement*="bottom"] &`]: _extends$1({
            transformOrigin: "center top",
            marginTop: "14px"
          }, ownerState.touch && {
            marginTop: "24px"
          })
        }));
        const TooltipArrow = styled$1("span", {
          name: "MuiTooltip",
          slot: "Arrow",
          overridesResolver: (props, styles) => styles.arrow
        })(({
          theme
        }) => ({
          overflow: "hidden",
          position: "absolute",
          width: "1em",
          height: "0.71em",
          boxSizing: "border-box",
          color: theme.vars ? theme.vars.palette.Tooltip.bg : alpha_1(theme.palette.grey[700], 0.9),
          "&::before": {
            content: '""',
            margin: "auto",
            display: "block",
            width: "100%",
            height: "100%",
            backgroundColor: "currentColor",
            transform: "rotate(45deg)"
          }
        }));
        let hystersisOpen = false;
        const hystersisTimer = new Timeout();
        let cursorPosition = {
          x: 0,
          y: 0
        };
        function composeEventHandler(handler, eventHandler) {
          return (event, ...params) => {
            if (eventHandler) {
              eventHandler(event, ...params);
            }
            handler(event, ...params);
          };
        }
        const Tooltip = exports("T", /* @__PURE__ */reactExports.forwardRef(function Tooltip2(inProps, ref) {
          var _ref, _slots$popper, _ref2, _ref3, _slots$transition, _ref4, _slots$tooltip, _ref5, _slots$arrow, _slotProps$popper, _ref6, _slotProps$popper2, _slotProps$transition, _slotProps$tooltip, _ref7, _slotProps$tooltip2, _slotProps$arrow, _ref8, _slotProps$arrow2;
          const props = useDefaultProps({
            props: inProps,
            name: "MuiTooltip"
          });
          const _props$arrow = props.arrow,
            arrow = _props$arrow === void 0 ? false : _props$arrow,
            childrenProp = props.children,
            _props$components3 = props.components,
            components = _props$components3 === void 0 ? {} : _props$components3,
            _props$componentsProp3 = props.componentsProps,
            componentsProps = _props$componentsProp3 === void 0 ? {} : _props$componentsProp3,
            _props$describeChild = props.describeChild,
            describeChild = _props$describeChild === void 0 ? false : _props$describeChild,
            _props$disableFocusLi = props.disableFocusListener,
            disableFocusListener = _props$disableFocusLi === void 0 ? false : _props$disableFocusLi,
            _props$disableHoverLi = props.disableHoverListener,
            disableHoverListener = _props$disableHoverLi === void 0 ? false : _props$disableHoverLi,
            _props$disableInterac = props.disableInteractive,
            disableInteractiveProp = _props$disableInterac === void 0 ? false : _props$disableInterac,
            _props$disableTouchLi = props.disableTouchListener,
            disableTouchListener = _props$disableTouchLi === void 0 ? false : _props$disableTouchLi,
            _props$enterDelay = props.enterDelay,
            enterDelay = _props$enterDelay === void 0 ? 100 : _props$enterDelay,
            _props$enterNextDelay = props.enterNextDelay,
            enterNextDelay = _props$enterNextDelay === void 0 ? 0 : _props$enterNextDelay,
            _props$enterTouchDela = props.enterTouchDelay,
            enterTouchDelay = _props$enterTouchDela === void 0 ? 700 : _props$enterTouchDela,
            _props$followCursor = props.followCursor,
            followCursor = _props$followCursor === void 0 ? false : _props$followCursor,
            idProp = props.id,
            _props$leaveDelay = props.leaveDelay,
            leaveDelay = _props$leaveDelay === void 0 ? 0 : _props$leaveDelay,
            _props$leaveTouchDela = props.leaveTouchDelay,
            leaveTouchDelay = _props$leaveTouchDela === void 0 ? 1500 : _props$leaveTouchDela,
            onClose = props.onClose,
            onOpen = props.onOpen,
            openProp = props.open,
            _props$placement = props.placement,
            placement = _props$placement === void 0 ? "bottom" : _props$placement,
            PopperComponentProp = props.PopperComponent,
            _props$PopperProps = props.PopperProps,
            PopperProps = _props$PopperProps === void 0 ? {} : _props$PopperProps,
            _props$slotProps3 = props.slotProps,
            slotProps = _props$slotProps3 === void 0 ? {} : _props$slotProps3,
            _props$slots3 = props.slots,
            slots = _props$slots3 === void 0 ? {} : _props$slots3,
            title = props.title,
            _props$TransitionComp2 = props.TransitionComponent,
            TransitionComponentProp = _props$TransitionComp2 === void 0 ? Grow : _props$TransitionComp2,
            TransitionProps = props.TransitionProps,
            other = _objectWithoutPropertiesLoose(props, _excluded$1);
          const children = /* @__PURE__ */reactExports.isValidElement(childrenProp) ? childrenProp : /* @__PURE__ */jsxRuntimeExports.jsx("span", {
            children: childrenProp
          });
          const theme = useTheme$1();
          const isRtl = useRtl();
          const _reactExports$useStat3 = reactExports.useState(),
            _reactExports$useStat4 = _slicedToArray(_reactExports$useStat3, 2),
            childNode = _reactExports$useStat4[0],
            setChildNode = _reactExports$useStat4[1];
          const _reactExports$useStat5 = reactExports.useState(null),
            _reactExports$useStat6 = _slicedToArray(_reactExports$useStat5, 2),
            arrowRef = _reactExports$useStat6[0],
            setArrowRef = _reactExports$useStat6[1];
          const ignoreNonTouchEvents = reactExports.useRef(false);
          const disableInteractive = disableInteractiveProp || followCursor;
          const closeTimer = useTimeout();
          const enterTimer = useTimeout();
          const leaveTimer = useTimeout();
          const touchTimer = useTimeout();
          const _useControlled = useControlled({
              controlled: openProp,
              default: false,
              name: "Tooltip",
              state: "open"
            }),
            _useControlled2 = _slicedToArray(_useControlled, 2),
            openState = _useControlled2[0],
            setOpenState = _useControlled2[1];
          let open = openState;
          const id = useId(idProp);
          const prevUserSelect = reactExports.useRef();
          const stopTouchInteraction = useEventCallback(() => {
            if (prevUserSelect.current !== void 0) {
              document.body.style.WebkitUserSelect = prevUserSelect.current;
              prevUserSelect.current = void 0;
            }
            touchTimer.clear();
          });
          reactExports.useEffect(() => stopTouchInteraction, [stopTouchInteraction]);
          const handleOpen = event => {
            hystersisTimer.clear();
            hystersisOpen = true;
            setOpenState(true);
            if (onOpen && !open) {
              onOpen(event);
            }
          };
          const handleClose = useEventCallback(
          /**
           * @param {React.SyntheticEvent | Event} event
           */
          event => {
            hystersisTimer.start(800 + leaveDelay, () => {
              hystersisOpen = false;
            });
            setOpenState(false);
            if (onClose && open) {
              onClose(event);
            }
            closeTimer.start(theme.transitions.duration.shortest, () => {
              ignoreNonTouchEvents.current = false;
            });
          });
          const handleMouseOver = event => {
            if (ignoreNonTouchEvents.current && event.type !== "touchstart") {
              return;
            }
            if (childNode) {
              childNode.removeAttribute("title");
            }
            enterTimer.clear();
            leaveTimer.clear();
            if (enterDelay || hystersisOpen && enterNextDelay) {
              enterTimer.start(hystersisOpen ? enterNextDelay : enterDelay, () => {
                handleOpen(event);
              });
            } else {
              handleOpen(event);
            }
          };
          const handleMouseLeave = event => {
            enterTimer.clear();
            leaveTimer.start(leaveDelay, () => {
              handleClose(event);
            });
          };
          const _useIsFocusVisible = useIsFocusVisible(),
            isFocusVisibleRef = _useIsFocusVisible.isFocusVisibleRef,
            handleBlurVisible = _useIsFocusVisible.onBlur,
            handleFocusVisible = _useIsFocusVisible.onFocus,
            focusVisibleRef = _useIsFocusVisible.ref;
          const _reactExports$useStat7 = reactExports.useState(false),
            _reactExports$useStat8 = _slicedToArray(_reactExports$useStat7, 2),
            setChildIsFocusVisible = _reactExports$useStat8[1];
          const handleBlur = event => {
            handleBlurVisible(event);
            if (isFocusVisibleRef.current === false) {
              setChildIsFocusVisible(false);
              handleMouseLeave(event);
            }
          };
          const handleFocus = event => {
            if (!childNode) {
              setChildNode(event.currentTarget);
            }
            handleFocusVisible(event);
            if (isFocusVisibleRef.current === true) {
              setChildIsFocusVisible(true);
              handleMouseOver(event);
            }
          };
          const detectTouchStart = event => {
            ignoreNonTouchEvents.current = true;
            const childrenProps2 = children.props;
            if (childrenProps2.onTouchStart) {
              childrenProps2.onTouchStart(event);
            }
          };
          const handleTouchStart = event => {
            detectTouchStart(event);
            leaveTimer.clear();
            closeTimer.clear();
            stopTouchInteraction();
            prevUserSelect.current = document.body.style.WebkitUserSelect;
            document.body.style.WebkitUserSelect = "none";
            touchTimer.start(enterTouchDelay, () => {
              document.body.style.WebkitUserSelect = prevUserSelect.current;
              handleMouseOver(event);
            });
          };
          const handleTouchEnd = event => {
            if (children.props.onTouchEnd) {
              children.props.onTouchEnd(event);
            }
            stopTouchInteraction();
            leaveTimer.start(leaveTouchDelay, () => {
              handleClose(event);
            });
          };
          reactExports.useEffect(() => {
            if (!open) {
              return void 0;
            }
            function handleKeyDown(nativeEvent) {
              if (nativeEvent.key === "Escape" || nativeEvent.key === "Esc") {
                handleClose(nativeEvent);
              }
            }
            document.addEventListener("keydown", handleKeyDown);
            return () => {
              document.removeEventListener("keydown", handleKeyDown);
            };
          }, [handleClose, open]);
          const handleRef = useForkRef(children.ref, focusVisibleRef, setChildNode, ref);
          if (!title && title !== 0) {
            open = false;
          }
          const popperRef = reactExports.useRef();
          const handleMouseMove = event => {
            const childrenProps2 = children.props;
            if (childrenProps2.onMouseMove) {
              childrenProps2.onMouseMove(event);
            }
            cursorPosition = {
              x: event.clientX,
              y: event.clientY
            };
            if (popperRef.current) {
              popperRef.current.update();
            }
          };
          const nameOrDescProps = {};
          const titleIsString = typeof title === "string";
          if (describeChild) {
            nameOrDescProps.title = !open && titleIsString && !disableHoverListener ? title : null;
            nameOrDescProps["aria-describedby"] = open ? id : null;
          } else {
            nameOrDescProps["aria-label"] = titleIsString ? title : null;
            nameOrDescProps["aria-labelledby"] = open && !titleIsString ? id : null;
          }
          const childrenProps = _extends$1({}, nameOrDescProps, other, children.props, {
            className: clsx(other.className, children.props.className),
            onTouchStart: detectTouchStart,
            ref: handleRef
          }, followCursor ? {
            onMouseMove: handleMouseMove
          } : {});
          const interactiveWrapperListeners = {};
          if (!disableTouchListener) {
            childrenProps.onTouchStart = handleTouchStart;
            childrenProps.onTouchEnd = handleTouchEnd;
          }
          if (!disableHoverListener) {
            childrenProps.onMouseOver = composeEventHandler(handleMouseOver, childrenProps.onMouseOver);
            childrenProps.onMouseLeave = composeEventHandler(handleMouseLeave, childrenProps.onMouseLeave);
            if (!disableInteractive) {
              interactiveWrapperListeners.onMouseOver = handleMouseOver;
              interactiveWrapperListeners.onMouseLeave = handleMouseLeave;
            }
          }
          if (!disableFocusListener) {
            childrenProps.onFocus = composeEventHandler(handleFocus, childrenProps.onFocus);
            childrenProps.onBlur = composeEventHandler(handleBlur, childrenProps.onBlur);
            if (!disableInteractive) {
              interactiveWrapperListeners.onFocus = handleFocus;
              interactiveWrapperListeners.onBlur = handleBlur;
            }
          }
          const popperOptions = reactExports.useMemo(() => {
            var _PopperProps$popperOp;
            let tooltipModifiers = [{
              name: "arrow",
              enabled: Boolean(arrowRef),
              options: {
                element: arrowRef,
                padding: 4
              }
            }];
            if ((_PopperProps$popperOp = PopperProps.popperOptions) != null && _PopperProps$popperOp.modifiers) {
              tooltipModifiers = tooltipModifiers.concat(PopperProps.popperOptions.modifiers);
            }
            return _extends$1({}, PopperProps.popperOptions, {
              modifiers: tooltipModifiers
            });
          }, [arrowRef, PopperProps]);
          const ownerState = _extends$1({}, props, {
            isRtl,
            arrow,
            disableInteractive,
            placement,
            PopperComponentProp,
            touch: ignoreNonTouchEvents.current
          });
          const classes = useUtilityClasses$1(ownerState);
          const PopperComponent = (_ref = (_slots$popper = slots.popper) != null ? _slots$popper : components.Popper) != null ? _ref : TooltipPopper;
          const TransitionComponent = (_ref2 = (_ref3 = (_slots$transition = slots.transition) != null ? _slots$transition : components.Transition) != null ? _ref3 : TransitionComponentProp) != null ? _ref2 : Grow;
          const TooltipComponent = (_ref4 = (_slots$tooltip = slots.tooltip) != null ? _slots$tooltip : components.Tooltip) != null ? _ref4 : TooltipTooltip;
          const ArrowComponent = (_ref5 = (_slots$arrow = slots.arrow) != null ? _slots$arrow : components.Arrow) != null ? _ref5 : TooltipArrow;
          const popperProps = appendOwnerState(PopperComponent, _extends$1({}, PopperProps, (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper, {
            className: clsx(classes.popper, PopperProps == null ? void 0 : PopperProps.className, (_ref6 = (_slotProps$popper2 = slotProps.popper) != null ? _slotProps$popper2 : componentsProps.popper) == null ? void 0 : _ref6.className)
          }), ownerState);
          const transitionProps = appendOwnerState(TransitionComponent, _extends$1({}, TransitionProps, (_slotProps$transition = slotProps.transition) != null ? _slotProps$transition : componentsProps.transition), ownerState);
          const tooltipProps = appendOwnerState(TooltipComponent, _extends$1({}, (_slotProps$tooltip = slotProps.tooltip) != null ? _slotProps$tooltip : componentsProps.tooltip, {
            className: clsx(classes.tooltip, (_ref7 = (_slotProps$tooltip2 = slotProps.tooltip) != null ? _slotProps$tooltip2 : componentsProps.tooltip) == null ? void 0 : _ref7.className)
          }), ownerState);
          const tooltipArrowProps = appendOwnerState(ArrowComponent, _extends$1({}, (_slotProps$arrow = slotProps.arrow) != null ? _slotProps$arrow : componentsProps.arrow, {
            className: clsx(classes.arrow, (_ref8 = (_slotProps$arrow2 = slotProps.arrow) != null ? _slotProps$arrow2 : componentsProps.arrow) == null ? void 0 : _ref8.className)
          }), ownerState);
          return /* @__PURE__ */jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [/* @__PURE__ */reactExports.cloneElement(children, childrenProps), /* @__PURE__ */jsxRuntimeExports.jsx(PopperComponent, _extends$1({
              as: PopperComponentProp != null ? PopperComponentProp : Popper,
              placement,
              anchorEl: followCursor ? {
                getBoundingClientRect: () => ({
                  top: cursorPosition.y,
                  left: cursorPosition.x,
                  right: cursorPosition.x,
                  bottom: cursorPosition.y,
                  width: 0,
                  height: 0
                })
              } : childNode,
              popperRef,
              open: childNode ? open : false,
              id,
              transition: true
            }, interactiveWrapperListeners, popperProps, {
              popperOptions,
              children: ({
                TransitionProps: TransitionPropsInner
              }) => /* @__PURE__ */jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
                timeout: theme.transitions.duration.shorter
              }, TransitionPropsInner, transitionProps, {
                children: /* @__PURE__ */jsxRuntimeExports.jsxs(TooltipComponent, _extends$1({}, tooltipProps, {
                  children: [title, arrow ? /* @__PURE__ */jsxRuntimeExports.jsx(ArrowComponent, _extends$1({}, tooltipArrowProps, {
                    ref: setArrowRef
                  })) : null]
                }))
              }))
            }))]
          });
        }));
        function getSwitchUtilityClass(slot) {
          return generateUtilityClass('MuiSwitch', slot);
        }
        const switchClasses = generateUtilityClasses('MuiSwitch', ['root', 'edgeStart', 'edgeEnd', 'switchBase', 'colorPrimary', 'colorSecondary', 'sizeSmall', 'sizeMedium', 'checked', 'disabled', 'input', 'thumb', 'track']);
        const _excluded = ["className", "color", "edge", "size", "sx"];
        const useUtilityClasses = ownerState => {
          const classes = ownerState.classes,
            edge = ownerState.edge,
            size = ownerState.size,
            color = ownerState.color,
            checked = ownerState.checked,
            disabled = ownerState.disabled;
          const slots = {
            root: ["root", edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`],
            switchBase: ["switchBase", `color${capitalize(color)}`, checked && "checked", disabled && "disabled"],
            thumb: ["thumb"],
            track: ["track"],
            input: ["input"]
          };
          const composedClasses = composeClasses(slots, getSwitchUtilityClass, classes);
          return _extends$1({}, classes, composedClasses);
        };
        const SwitchRoot = styled$1("span", {
          name: "MuiSwitch",
          slot: "Root",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.root, ownerState.edge && styles[`edge${capitalize(ownerState.edge)}`], styles[`size${capitalize(ownerState.size)}`]];
          }
        })({
          display: "inline-flex",
          width: 34 + 12 * 2,
          height: 14 + 12 * 2,
          overflow: "hidden",
          padding: 12,
          boxSizing: "border-box",
          position: "relative",
          flexShrink: 0,
          zIndex: 0,
          // Reset the stacking context.
          verticalAlign: "middle",
          // For correct alignment with the text.
          "@media print": {
            colorAdjust: "exact"
          },
          variants: [{
            props: {
              edge: "start"
            },
            style: {
              marginLeft: -8
            }
          }, {
            props: {
              edge: "end"
            },
            style: {
              marginRight: -8
            }
          }, {
            props: {
              size: "small"
            },
            style: {
              width: 40,
              height: 24,
              padding: 7,
              [`& .${switchClasses.thumb}`]: {
                width: 16,
                height: 16
              },
              [`& .${switchClasses.switchBase}`]: {
                padding: 4,
                [`&.${switchClasses.checked}`]: {
                  transform: "translateX(16px)"
                }
              }
            }
          }]
        });
        const SwitchSwitchBase = styled$1(SwitchBase, {
          name: "MuiSwitch",
          slot: "SwitchBase",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.switchBase, {
              [`& .${switchClasses.input}`]: styles.input
            }, ownerState.color !== "default" && styles[`color${capitalize(ownerState.color)}`]];
          }
        })(({
          theme
        }) => ({
          position: "absolute",
          top: 0,
          left: 0,
          zIndex: 1,
          // Render above the focus ripple.
          color: theme.vars ? theme.vars.palette.Switch.defaultColor : `${theme.palette.mode === "light" ? theme.palette.common.white : theme.palette.grey[300]}`,
          transition: theme.transitions.create(["left", "transform"], {
            duration: theme.transitions.duration.shortest
          }),
          [`&.${switchClasses.checked}`]: {
            transform: "translateX(20px)"
          },
          [`&.${switchClasses.disabled}`]: {
            color: theme.vars ? theme.vars.palette.Switch.defaultDisabledColor : `${theme.palette.mode === "light" ? theme.palette.grey[100] : theme.palette.grey[600]}`
          },
          [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
            opacity: 0.5
          },
          [`&.${switchClasses.disabled} + .${switchClasses.track}`]: {
            opacity: theme.vars ? theme.vars.opacity.switchTrackDisabled : `${theme.palette.mode === "light" ? 0.12 : 0.2}`
          },
          [`& .${switchClasses.input}`]: {
            left: "-100%",
            width: "300%"
          }
        }), ({
          theme
        }) => ({
          "&:hover": {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette.action.active, theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              backgroundColor: "transparent"
            }
          },
          variants: [...Object.entries(theme.palette).filter(([, value]) => value.main && value.light).map(([color]) => ({
            props: {
              color
            },
            style: {
              [`&.${switchClasses.checked}`]: {
                color: (theme.vars || theme).palette[color].main,
                "&:hover": {
                  backgroundColor: theme.vars ? `rgba(${theme.vars.palette[color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette[color].main, theme.palette.action.hoverOpacity),
                  "@media (hover: none)": {
                    backgroundColor: "transparent"
                  }
                },
                [`&.${switchClasses.disabled}`]: {
                  color: theme.vars ? theme.vars.palette.Switch[`${color}DisabledColor`] : `${theme.palette.mode === "light" ? lighten_1(theme.palette[color].main, 0.62) : darken_1(theme.palette[color].main, 0.55)}`
                }
              },
              [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
                backgroundColor: (theme.vars || theme).palette[color].main
              }
            }
          }))]
        }));
        const SwitchTrack = styled$1("span", {
          name: "MuiSwitch",
          slot: "Track",
          overridesResolver: (props, styles) => styles.track
        })(({
          theme
        }) => ({
          height: "100%",
          width: "100%",
          borderRadius: 14 / 2,
          zIndex: -1,
          transition: theme.transitions.create(["opacity", "background-color"], {
            duration: theme.transitions.duration.shortest
          }),
          backgroundColor: theme.vars ? theme.vars.palette.common.onBackground : `${theme.palette.mode === "light" ? theme.palette.common.black : theme.palette.common.white}`,
          opacity: theme.vars ? theme.vars.opacity.switchTrack : `${theme.palette.mode === "light" ? 0.38 : 0.3}`
        }));
        const SwitchThumb = styled$1("span", {
          name: "MuiSwitch",
          slot: "Thumb",
          overridesResolver: (props, styles) => styles.thumb
        })(({
          theme
        }) => ({
          boxShadow: (theme.vars || theme).shadows[1],
          backgroundColor: "currentColor",
          width: 20,
          height: 20,
          borderRadius: "50%"
        }));
        const Switch = exports("P", /* @__PURE__ */reactExports.forwardRef(function Switch2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiSwitch"
          });
          const className = props.className,
            _props$color3 = props.color,
            color = _props$color3 === void 0 ? "primary" : _props$color3,
            _props$edge = props.edge,
            edge = _props$edge === void 0 ? false : _props$edge,
            _props$size3 = props.size,
            size = _props$size3 === void 0 ? "medium" : _props$size3,
            sx = props.sx,
            other = _objectWithoutPropertiesLoose(props, _excluded);
          const ownerState = _extends$1({}, props, {
            color,
            edge,
            size
          });
          const classes = useUtilityClasses(ownerState);
          const icon = /* @__PURE__ */jsxRuntimeExports.jsx(SwitchThumb, {
            className: classes.thumb,
            ownerState
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs(SwitchRoot, {
            className: clsx(classes.root, className),
            sx,
            ownerState,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(SwitchSwitchBase, _extends$1({
              type: "checkbox",
              icon,
              checkedIcon: icon,
              ref,
              ownerState
            }, other, {
              classes: _extends$1({}, classes, {
                root: classes.switchBase
              })
            })), /* @__PURE__ */jsxRuntimeExports.jsx(SwitchTrack, {
              className: classes.track,
              ownerState
            })]
          });
        }));
        const toggleButtonClasses = generateUtilityClasses('MuiToggleButton', ['root', 'disabled', 'selected', 'standard', 'primary', 'secondary', 'sizeSmall', 'sizeMedium', 'sizeLarge', 'fullWidth']);
        const Edit = exports("E", createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75z"
        }), 'Edit'));
        const GTranslate = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M21 4H11l-1-3H3c-1.1 0-2 .9-2 2v15c0 1.1.9 2 2 2h8l1 3h9c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2M7 16c-2.76 0-5-2.24-5-5s2.24-5 5-5c1.35 0 2.48.5 3.35 1.3L9.03 8.57c-.38-.36-1.04-.78-2.03-.78-1.74 0-3.15 1.44-3.15 3.21S5.26 14.21 7 14.21c2.01 0 2.84-1.44 2.92-2.41H7v-1.71h4.68c.07.31.12.61.12 1.02C11.8 13.97 9.89 16 7 16m6.17-5.42h3.7c-.43 1.25-1.11 2.43-2.05 3.47-.31-.35-.6-.72-.86-1.1zm8.33 9.92c0 .55-.45 1-1 1H14l2-2.5-1.04-3.1 3.1 3.1.92-.92-3.3-3.25.02-.02c1.13-1.25 1.93-2.69 2.4-4.22H20v-1.3h-4.53V8h-1.29v1.29h-1.44L11.46 5.5h9.04c.55 0 1 .45 1 1z"
        }), 'GTranslate');
        const KeyboardArrowDown = exports("K", createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6z"
        }), 'KeyboardArrowDown'));
        const KeyboardArrowUp = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M7.41 15.41 12 10.83l4.59 4.58L18 14l-6-6-6 6z"
        }), 'KeyboardArrowUp');
        const LogoutOutlined = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "m17 8-1.41 1.41L17.17 11H9v2h8.17l-1.58 1.58L17 16l4-4zM5 5h7V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h7v-2H5z"
        }), 'LogoutOutlined');
        const Palette = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M12 2C6.49 2 2 6.49 2 12s4.49 10 10 10c1.38 0 2.5-1.12 2.5-2.5 0-.61-.23-1.2-.64-1.67-.08-.1-.13-.21-.13-.33 0-.28.22-.5.5-.5H16c3.31 0 6-2.69 6-6 0-4.96-4.49-9-10-9m5.5 11c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5m-3-4c-.83 0-1.5-.67-1.5-1.5S13.67 6 14.5 6s1.5.67 1.5 1.5S15.33 9 14.5 9M5 11.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5S7.33 13 6.5 13 5 12.33 5 11.5m6-4c0 .83-.67 1.5-1.5 1.5S8 8.33 8 7.5 8.67 6 9.5 6s1.5.67 1.5 1.5"
        }), 'Palette');
        const Person = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4m0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4"
        }), 'Person');
        const Settings = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6"
        }), 'Settings');
        const Visibility = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5M12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5m0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"
        }), 'Visibility');
        const MANAGE_SURVEY_LANDING_PAGES = {
          DESIGN: "design-survey",
          PREVIEW: "preview",
          RESPONSES: "responses",
          SETTINGS: "edit-survey",
          RESPONSE: "response"
        };
        const DESIGN_SURVEY_MODE = exports("W", {
          THEME: "theme",
          LANGUAGES: "languages",
          REORDER: "reorder"
        });
        const PREVIEW_MODE = {
          ONLINE: "online",
          ONLINE_PHONE: "online-phone",
          OFFLINE: "offline"
        };
        const routes = exports("r", {
          designSurvey: `/${MANAGE_SURVEY_LANDING_PAGES.DESIGN}/:surveyId`,
          editSurvey: `/${MANAGE_SURVEY_LANDING_PAGES.SETTINGS}/:surveyId`,
          responses: `/${MANAGE_SURVEY_LANDING_PAGES.RESPONSES}/:surveyId`,
          runSurvey: "/run-survey/:surveyId",
          resumeSurvey: "/resume-survey/:surveyId/:responseId",
          iframePreviewSurvey: "/preview-survey/:surveyId",
          iframePreviewGuestSurvey: "/preview-guest-survey/:surveyId",
          guestPreview: "/guest/preview/:surveyId",
          preview: "/preview/:surveyId",
          login: "/login",
          confirmNewUser: "/confirm-new-user/:token",
          forgotPassword: "/forgot-password",
          resetPassword: "/reset-password",
          dashboard: "/",
          manageUsers: "/manage-users",
          addUser: "/add-user",
          editUser: "/edit-user/:userId",
          profile: "/profile",
          createSurvey: "/create-survey",
          dashboard1: "",
          page404: "*"
        });
        var dist = {};
        var _extends = {};
        var _global = {
          exports: {}
        };

        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
        var global$4 = _global.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
        // eslint-disable-next-line no-new-func
        : Function('return this')();
        if (typeof __g == 'number') __g = global$4; // eslint-disable-line no-undef

        var _globalExports = _global.exports;
        var _core = {
          exports: {}
        };
        var core$4 = _core.exports = {
          version: '2.6.12'
        };
        if (typeof __e == 'number') __e = core$4; // eslint-disable-line no-undef

        var _coreExports = _core.exports;
        var _aFunction = function _aFunction(it) {
          if (typeof it != 'function') throw TypeError(it + ' is not a function!');
          return it;
        };

        // optional / simple context binding
        var aFunction = _aFunction;
        var _ctx = function _ctx(fn, that, length) {
          aFunction(fn);
          if (that === undefined) return fn;
          switch (length) {
            case 1:
              return function (a) {
                return fn.call(that, a);
              };
            case 2:
              return function (a, b) {
                return fn.call(that, a, b);
              };
            case 3:
              return function (a, b, c) {
                return fn.call(that, a, b, c);
              };
          }
          return function /* ...args */
          () {
            return fn.apply(that, arguments);
          };
        };
        var _objectDp = {};
        var _isObject = function _isObject(it) {
          return typeof it === 'object' ? it !== null : typeof it === 'function';
        };
        var isObject$4 = _isObject;
        var _anObject = function _anObject(it) {
          if (!isObject$4(it)) throw TypeError(it + ' is not an object!');
          return it;
        };
        var _fails = function _fails(exec) {
          try {
            return !!exec();
          } catch (e) {
            return true;
          }
        };
        var _descriptors;
        var hasRequired_descriptors;
        function require_descriptors() {
          if (hasRequired_descriptors) return _descriptors;
          hasRequired_descriptors = 1;
          // Thank's IE8 for his funny defineProperty
          _descriptors = !_fails(function () {
            return Object.defineProperty({}, 'a', {
              get: function get() {
                return 7;
              }
            }).a != 7;
          });
          return _descriptors;
        }
        var _domCreate;
        var hasRequired_domCreate;
        function require_domCreate() {
          if (hasRequired_domCreate) return _domCreate;
          hasRequired_domCreate = 1;
          var isObject = _isObject;
          var document = _globalExports.document;
          // typeof document.createElement is 'object' in old IE
          var is = isObject(document) && isObject(document.createElement);
          _domCreate = function _domCreate(it) {
            return is ? document.createElement(it) : {};
          };
          return _domCreate;
        }
        var _ie8DomDefine;
        var hasRequired_ie8DomDefine;
        function require_ie8DomDefine() {
          if (hasRequired_ie8DomDefine) return _ie8DomDefine;
          hasRequired_ie8DomDefine = 1;
          _ie8DomDefine = !require_descriptors() && !_fails(function () {
            return Object.defineProperty(require_domCreate()('div'), 'a', {
              get: function get() {
                return 7;
              }
            }).a != 7;
          });
          return _ie8DomDefine;
        }

        // 7.1.1 ToPrimitive(input [, PreferredType])
        var isObject$3 = _isObject;
        // instead of the ES6 spec version, we didn't implement @@toPrimitive case
        // and the second argument - flag - preferred type is a string
        var _toPrimitive = function _toPrimitive(it, S) {
          if (!isObject$3(it)) return it;
          var fn, val;
          if (S && typeof (fn = it.toString) == 'function' && !isObject$3(val = fn.call(it))) return val;
          if (typeof (fn = it.valueOf) == 'function' && !isObject$3(val = fn.call(it))) return val;
          if (!S && typeof (fn = it.toString) == 'function' && !isObject$3(val = fn.call(it))) return val;
          throw TypeError("Can't convert object to primitive value");
        };
        var hasRequired_objectDp;
        function require_objectDp() {
          if (hasRequired_objectDp) return _objectDp;
          hasRequired_objectDp = 1;
          var anObject = _anObject;
          var IE8_DOM_DEFINE = require_ie8DomDefine();
          var toPrimitive = _toPrimitive;
          var dP = Object.defineProperty;
          _objectDp.f = require_descriptors() ? Object.defineProperty : function defineProperty(O, P, Attributes) {
            anObject(O);
            P = toPrimitive(P, true);
            anObject(Attributes);
            if (IE8_DOM_DEFINE) try {
              return dP(O, P, Attributes);
            } catch (e) {/* empty */}
            if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
            if ('value' in Attributes) O[P] = Attributes.value;
            return O;
          };
          return _objectDp;
        }
        var _propertyDesc = function _propertyDesc(bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value: value
          };
        };
        var dP$2 = require_objectDp();
        var createDesc$2 = _propertyDesc;
        var _hide = require_descriptors() ? function (object, key, value) {
          return dP$2.f(object, key, createDesc$2(1, value));
        } : function (object, key, value) {
          object[key] = value;
          return object;
        };
        var hasOwnProperty = {}.hasOwnProperty;
        var _has = function _has(it, key) {
          return hasOwnProperty.call(it, key);
        };
        var global$3 = _globalExports;
        var core$3 = _coreExports;
        var ctx = _ctx;
        var hide$2 = _hide;
        var has$6 = _has;
        var PROTOTYPE$2 = 'prototype';
        var _$export$ = function $export$7(type, name, source) {
          var IS_FORCED = type & _$export$.F;
          var IS_GLOBAL = type & _$export$.G;
          var IS_STATIC = type & _$export$.S;
          var IS_PROTO = type & _$export$.P;
          var IS_BIND = type & _$export$.B;
          var IS_WRAP = type & _$export$.W;
          var exports = IS_GLOBAL ? core$3 : core$3[name] || (core$3[name] = {});
          var expProto = exports[PROTOTYPE$2];
          var target = IS_GLOBAL ? global$3 : IS_STATIC ? global$3[name] : (global$3[name] || {})[PROTOTYPE$2];
          var key, own, out;
          if (IS_GLOBAL) source = name;
          for (key in source) {
            // contains in native
            own = !IS_FORCED && target && target[key] !== undefined;
            if (own && has$6(exports, key)) continue;
            // export native or passed
            out = own ? target[key] : source[key];
            // prevent global pollution for namespaces
            exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
            // bind timers to global for call from export context
            : IS_BIND && own ? ctx(out, global$3)
            // wrap global constructors for prevent change them in library
            : IS_WRAP && target[key] == out ? function (C) {
              var F = function F(a, b, c) {
                if (this instanceof C) {
                  switch (arguments.length) {
                    case 0:
                      return new C();
                    case 1:
                      return new C(a);
                    case 2:
                      return new C(a, b);
                  }
                  return new C(a, b, c);
                }
                return C.apply(this, arguments);
              };
              F[PROTOTYPE$2] = C[PROTOTYPE$2];
              return F;
              // make static versions for prototype methods
            }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
            // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
            if (IS_PROTO) {
              (exports.virtual || (exports.virtual = {}))[key] = out;
              // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
              if (type & _$export$.R && expProto && !expProto[key]) hide$2(expProto, key, out);
            }
          }
        };
        // type bitmap
        _$export$.F = 1; // forced
        _$export$.G = 2; // global
        _$export$.S = 4; // static
        _$export$.P = 8; // proto
        _$export$.B = 16; // bind
        _$export$.W = 32; // wrap
        _$export$.U = 64; // safe
        _$export$.R = 128; // real proto method for `library`
        var _export = _$export$;
        var toString$1 = {}.toString;
        var _cof = function _cof(it) {
          return toString$1.call(it).slice(8, -1);
        };
        var _iobject;
        var hasRequired_iobject;
        function require_iobject() {
          if (hasRequired_iobject) return _iobject;
          hasRequired_iobject = 1;
          // fallback for non-array-like ES3 and non-enumerable old V8 strings
          var cof = _cof;
          // eslint-disable-next-line no-prototype-builtins
          _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
            return cof(it) == 'String' ? it.split('') : Object(it);
          };
          return _iobject;
        }

        // 7.2.1 RequireObjectCoercible(argument)
        var _defined = function _defined(it) {
          if (it == undefined) throw TypeError("Can't call method on  " + it);
          return it;
        };

        // to indexed object, toObject with fallback for non-array-like ES3 strings
        var IObject = require_iobject();
        var defined$2 = _defined;
        var _toIobject = function _toIobject(it) {
          return IObject(defined$2(it));
        };

        // 7.1.4 ToInteger
        var ceil = Math.ceil;
        var floor = Math.floor;
        var _toInteger = function _toInteger(it) {
          return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
        };

        // 7.1.15 ToLength
        var toInteger$2 = _toInteger;
        var min$1 = Math.min;
        var _toLength = function _toLength(it) {
          return it > 0 ? min$1(toInteger$2(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
        };
        var toInteger$1 = _toInteger;
        var max = Math.max;
        var min = Math.min;
        var _toAbsoluteIndex = function _toAbsoluteIndex(index, length) {
          index = toInteger$1(index);
          return index < 0 ? max(index + length, 0) : min(index, length);
        };

        // false -> Array#indexOf
        // true  -> Array#includes
        var toIObject$5 = _toIobject;
        var toLength = _toLength;
        var toAbsoluteIndex = _toAbsoluteIndex;
        var _arrayIncludes = function _arrayIncludes(IS_INCLUDES) {
          return function ($this, el, fromIndex) {
            var O = toIObject$5($this);
            var length = toLength(O.length);
            var index = toAbsoluteIndex(fromIndex, length);
            var value;
            // Array#includes uses SameValueZero equality algorithm
            // eslint-disable-next-line no-self-compare
            if (IS_INCLUDES && el != el) while (length > index) {
              value = O[index++];
              // eslint-disable-next-line no-self-compare
              if (value != value) return true;
              // Array#indexOf ignores holes, Array#includes - not
            } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
              if (O[index] === el) return IS_INCLUDES || index || 0;
            }
            return !IS_INCLUDES && -1;
          };
        };
        var _shared = {
          exports: {}
        };
        var _library = true;
        var core$2 = _coreExports;
        var global$2 = _globalExports;
        var SHARED = '__core-js_shared__';
        var store$1 = global$2[SHARED] || (global$2[SHARED] = {});
        (_shared.exports = function (key, value) {
          return store$1[key] || (store$1[key] = value !== undefined ? value : {});
        })('versions', []).push({
          version: core$2.version,
          mode: 'pure',
          copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
        });
        var _sharedExports = _shared.exports;
        var id$1 = 0;
        var px = Math.random();
        var _uid = function _uid(key) {
          return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id$1 + px).toString(36));
        };
        var shared$1 = _sharedExports('keys');
        var uid$2 = _uid;
        var _sharedKey = function _sharedKey(key) {
          return shared$1[key] || (shared$1[key] = uid$2(key));
        };
        var has$5 = _has;
        var toIObject$4 = _toIobject;
        var arrayIndexOf = _arrayIncludes(false);
        var IE_PROTO$2 = _sharedKey('IE_PROTO');
        var _objectKeysInternal = function _objectKeysInternal(object, names) {
          var O = toIObject$4(object);
          var i = 0;
          var result = [];
          var key;
          for (key in O) if (key != IE_PROTO$2) has$5(O, key) && result.push(key);
          // Don't enum bug & hidden keys
          while (names.length > i) if (has$5(O, key = names[i++])) {
            ~arrayIndexOf(result, key) || result.push(key);
          }
          return result;
        };

        // IE 8- don't enum bug keys
        var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

        // 19.1.2.14 / 15.2.3.14 Object.keys(O)
        var $keys$2 = _objectKeysInternal;
        var enumBugKeys$1 = _enumBugKeys;
        var _objectKeys = Object.keys || function keys(O) {
          return $keys$2(O, enumBugKeys$1);
        };
        var _objectGops = {};
        _objectGops.f = Object.getOwnPropertySymbols;
        var _objectPie = {};
        var hasRequired_objectPie;
        function require_objectPie() {
          if (hasRequired_objectPie) return _objectPie;
          hasRequired_objectPie = 1;
          _objectPie.f = {}.propertyIsEnumerable;
          return _objectPie;
        }

        // 7.1.13 ToObject(argument)
        var defined$1 = _defined;
        var _toObject = function _toObject(it) {
          return Object(defined$1(it));
        };
        var _objectAssign;
        var hasRequired_objectAssign;
        function require_objectAssign() {
          if (hasRequired_objectAssign) return _objectAssign;
          hasRequired_objectAssign = 1;
          // 19.1.2.1 Object.assign(target, source, ...)
          var DESCRIPTORS = require_descriptors();
          var getKeys = _objectKeys;
          var gOPS = _objectGops;
          var pIE = require_objectPie();
          var toObject = _toObject;
          var IObject = require_iobject();
          var $assign = Object.assign;

          // should work with symbols and should have deterministic property order (V8 bug)
          _objectAssign = !$assign || _fails(function () {
            var A = {};
            var B = {};
            // eslint-disable-next-line no-undef
            var S = Symbol();
            var K = 'abcdefghijklmnopqrst';
            A[S] = 7;
            K.split('').forEach(function (k) {
              B[k] = k;
            });
            return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
          }) ? function assign(target, source) {
            // eslint-disable-line no-unused-vars
            var T = toObject(target);
            var aLen = arguments.length;
            var index = 1;
            var getSymbols = gOPS.f;
            var isEnum = pIE.f;
            while (aLen > index) {
              var S = IObject(arguments[index++]);
              var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
              var length = keys.length;
              var j = 0;
              var key;
              while (length > j) {
                key = keys[j++];
                if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
              }
            }
            return T;
          } : $assign;
          return _objectAssign;
        }

        // 19.1.3.1 Object.assign(target, source)
        var $export$6 = _export;
        $export$6($export$6.S + $export$6.F, 'Object', {
          assign: require_objectAssign()
        });
        var assign$1 = _coreExports.Object.assign;
        var assign = {
          "default": assign$1,
          __esModule: true
        };
        _extends.__esModule = true;
        var _assign = assign;
        var _assign2 = _interopRequireDefault$a(_assign);
        function _interopRequireDefault$a(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        _extends.default = _assign2.default || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };

        // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
        var has$4 = _has;
        var toObject$2 = _toObject;
        var IE_PROTO$1 = _sharedKey('IE_PROTO');
        var ObjectProto$1 = Object.prototype;
        var _objectGpo = Object.getPrototypeOf || function (O) {
          O = toObject$2(O);
          if (has$4(O, IE_PROTO$1)) return O[IE_PROTO$1];
          if (typeof O.constructor == 'function' && O instanceof O.constructor) {
            return O.constructor.prototype;
          }
          return O instanceof Object ? ObjectProto$1 : null;
        };

        // most Object methods by ES6 should accept primitives
        var $export$5 = _export;
        var core$1 = _coreExports;
        var fails = _fails;
        var _objectSap = function _objectSap(KEY, exec) {
          var fn = (core$1.Object || {})[KEY] || Object[KEY];
          var exp = {};
          exp[KEY] = exec(fn);
          $export$5($export$5.S + $export$5.F * fails(function () {
            fn(1);
          }), 'Object', exp);
        };

        // 19.1.2.9 Object.getPrototypeOf(O)
        var toObject$1 = _toObject;
        var $getPrototypeOf = _objectGpo;
        _objectSap('getPrototypeOf', function () {
          return function getPrototypeOf(it) {
            return $getPrototypeOf(toObject$1(it));
          };
        });
        var getPrototypeOf$2 = _coreExports.Object.getPrototypeOf;
        var getPrototypeOf$1 = {
          "default": getPrototypeOf$2,
          __esModule: true
        };
        var classCallCheck = {};
        classCallCheck.__esModule = true;
        classCallCheck.default = function (instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        };
        var createClass = {};
        var $export$4 = _export;
        // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
        $export$4($export$4.S + $export$4.F * !require_descriptors(), 'Object', {
          defineProperty: require_objectDp().f
        });
        var $Object$1 = _coreExports.Object;
        var defineProperty$2 = function defineProperty(it, key, desc) {
          return $Object$1.defineProperty(it, key, desc);
        };
        var defineProperty$1 = {
          "default": defineProperty$2,
          __esModule: true
        };
        createClass.__esModule = true;
        var _defineProperty = defineProperty$1;
        var _defineProperty2 = _interopRequireDefault$9(_defineProperty);
        function _interopRequireDefault$9(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        createClass.default = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              (0, _defineProperty2.default)(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var possibleConstructorReturn = {};
        var _typeof$1 = {};
        var toInteger = _toInteger;
        var defined = _defined;
        // true  -> String#at
        // false -> String#codePointAt
        var _stringAt = function _stringAt(TO_STRING) {
          return function (that, pos) {
            var s = String(defined(that));
            var i = toInteger(pos);
            var l = s.length;
            var a, b;
            if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
            a = s.charCodeAt(i);
            return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
          };
        };
        var _redefine = _hide;
        var _iterators = {};
        var dP$1 = require_objectDp();
        var anObject$2 = _anObject;
        var getKeys$1 = _objectKeys;
        var _objectDps = require_descriptors() ? Object.defineProperties : function defineProperties(O, Properties) {
          anObject$2(O);
          var keys = getKeys$1(Properties);
          var length = keys.length;
          var i = 0;
          var P;
          while (length > i) dP$1.f(O, P = keys[i++], Properties[P]);
          return O;
        };
        var _html;
        var hasRequired_html;
        function require_html() {
          if (hasRequired_html) return _html;
          hasRequired_html = 1;
          var document = _globalExports.document;
          _html = document && document.documentElement;
          return _html;
        }

        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        var anObject$1 = _anObject;
        var dPs = _objectDps;
        var enumBugKeys = _enumBugKeys;
        var IE_PROTO = _sharedKey('IE_PROTO');
        var Empty = function Empty() {/* empty */};
        var PROTOTYPE$1 = 'prototype';

        // Create object with fake `null` prototype: use iframe Object with cleared prototype
        var _createDict = function createDict() {
          // Thrash, waste and sodomy: IE GC bug
          var iframe = require_domCreate()('iframe');
          var i = enumBugKeys.length;
          var lt = '<';
          var gt = '>';
          var iframeDocument;
          iframe.style.display = 'none';
          require_html().appendChild(iframe);
          iframe.src = 'javascript:'; // eslint-disable-line no-script-url
          // createDict = iframe.contentWindow.Object;
          // html.removeChild(iframe);
          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
          iframeDocument.close();
          _createDict = iframeDocument.F;
          while (i--) delete _createDict[PROTOTYPE$1][enumBugKeys[i]];
          return _createDict();
        };
        var _objectCreate = Object.create || function create(O, Properties) {
          var result;
          if (O !== null) {
            Empty[PROTOTYPE$1] = anObject$1(O);
            result = new Empty();
            Empty[PROTOTYPE$1] = null;
            // add "__proto__" for Object.getPrototypeOf polyfill
            result[IE_PROTO] = O;
          } else result = _createDict();
          return Properties === undefined ? result : dPs(result, Properties);
        };
        var _wks = {
          exports: {}
        };
        var store = _sharedExports('wks');
        var uid$1 = _uid;
        var Symbol$1 = _globalExports.Symbol;
        var USE_SYMBOL = typeof Symbol$1 == 'function';
        var $exports = _wks.exports = function (name) {
          return store[name] || (store[name] = USE_SYMBOL && Symbol$1[name] || (USE_SYMBOL ? Symbol$1 : uid$1)('Symbol.' + name));
        };
        $exports.store = store;
        var _wksExports = _wks.exports;
        var def = require_objectDp().f;
        var has$3 = _has;
        var TAG = _wksExports('toStringTag');
        var _setToStringTag = function _setToStringTag(it, tag, stat) {
          if (it && !has$3(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
            configurable: true,
            value: tag
          });
        };
        var create$2 = _objectCreate;
        var descriptor = _propertyDesc;
        var setToStringTag$2 = _setToStringTag;
        var IteratorPrototype = {};

        // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
        _hide(IteratorPrototype, _wksExports('iterator'), function () {
          return this;
        });
        var _iterCreate = function _iterCreate(Constructor, NAME, next) {
          Constructor.prototype = create$2(IteratorPrototype, {
            next: descriptor(1, next)
          });
          setToStringTag$2(Constructor, NAME + ' Iterator');
        };
        var $export$3 = _export;
        var redefine$1 = _redefine;
        var hide$1 = _hide;
        var Iterators$2 = _iterators;
        var $iterCreate = _iterCreate;
        var setToStringTag$1 = _setToStringTag;
        var getPrototypeOf = _objectGpo;
        var ITERATOR = _wksExports('iterator');
        var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
        var FF_ITERATOR = '@@iterator';
        var KEYS = 'keys';
        var VALUES = 'values';
        var returnThis = function returnThis() {
          return this;
        };
        var _iterDefine = function _iterDefine(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
          $iterCreate(Constructor, NAME, next);
          var getMethod = function getMethod(kind) {
            if (!BUGGY && kind in proto) return proto[kind];
            switch (kind) {
              case KEYS:
                return function keys() {
                  return new Constructor(this, kind);
                };
              case VALUES:
                return function values() {
                  return new Constructor(this, kind);
                };
            }
            return function entries() {
              return new Constructor(this, kind);
            };
          };
          var TAG = NAME + ' Iterator';
          var DEF_VALUES = DEFAULT == VALUES;
          var VALUES_BUG = false;
          var proto = Base.prototype;
          var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
          var $default = $native || getMethod(DEFAULT);
          var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
          var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
          var methods, key, IteratorPrototype;
          // Fix native
          if ($anyNative) {
            IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
            if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
              // Set @@toStringTag to native iterators
              setToStringTag$1(IteratorPrototype, TAG, true);
            }
          }
          // fix Array#{values, @@iterator}.name in V8 / FF
          if (DEF_VALUES && $native && $native.name !== VALUES) {
            VALUES_BUG = true;
            $default = function values() {
              return $native.call(this);
            };
          }
          // Define iterator
          if (FORCED && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
            hide$1(proto, ITERATOR, $default);
          }
          // Plug for library
          Iterators$2[NAME] = $default;
          Iterators$2[TAG] = returnThis;
          if (DEFAULT) {
            methods = {
              values: DEF_VALUES ? $default : getMethod(VALUES),
              keys: IS_SET ? $default : getMethod(KEYS),
              entries: $entries
            };
            if (FORCED) for (key in methods) {
              if (!(key in proto)) redefine$1(proto, key, methods[key]);
            } else $export$3($export$3.P + $export$3.F * (BUGGY || VALUES_BUG), NAME, methods);
          }
          return methods;
        };
        var $at = _stringAt(true);

        // 21.1.3.27 String.prototype[@@iterator]()
        _iterDefine(String, 'String', function (iterated) {
          this._t = String(iterated); // target
          this._i = 0; // next index
          // 21.1.5.2.1 %StringIteratorPrototype%.next()
        }, function () {
          var O = this._t;
          var index = this._i;
          var point;
          if (index >= O.length) return {
            value: undefined,
            done: true
          };
          point = $at(O, index);
          this._i += point.length;
          return {
            value: point,
            done: false
          };
        });
        var _iterStep = function _iterStep(done, value) {
          return {
            value: value,
            done: !!done
          };
        };
        var step = _iterStep;
        var Iterators$1 = _iterators;
        var toIObject$3 = _toIobject;

        // 22.1.3.4 Array.prototype.entries()
        // 22.1.3.13 Array.prototype.keys()
        // 22.1.3.29 Array.prototype.values()
        // 22.1.3.30 Array.prototype[@@iterator]()
        _iterDefine(Array, 'Array', function (iterated, kind) {
          this._t = toIObject$3(iterated); // target
          this._i = 0; // next index
          this._k = kind; // kind
          // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
        }, function () {
          var O = this._t;
          var kind = this._k;
          var index = this._i++;
          if (!O || index >= O.length) {
            this._t = undefined;
            return step(1);
          }
          if (kind == 'keys') return step(0, index);
          if (kind == 'values') return step(0, O[index]);
          return step(0, [index, O[index]]);
        }, 'values');

        // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
        Iterators$1.Arguments = Iterators$1.Array;
        var global$1 = _globalExports;
        var hide = _hide;
        var Iterators = _iterators;
        var TO_STRING_TAG = _wksExports('toStringTag');
        var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' + 'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' + 'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' + 'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' + 'TextTrackList,TouchList').split(',');
        for (var i = 0; i < DOMIterables.length; i++) {
          var NAME = DOMIterables[i];
          var Collection = global$1[NAME];
          var proto = Collection && Collection.prototype;
          if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
          Iterators[NAME] = Iterators.Array;
        }
        var _wksExt = {};
        _wksExt.f = _wksExports;
        var iterator$1 = _wksExt.f('iterator');
        var iterator = {
          "default": iterator$1,
          __esModule: true
        };
        var _meta = {
          exports: {}
        };
        var META$1 = _uid('meta');
        var isObject$2 = _isObject;
        var has$2 = _has;
        var setDesc = require_objectDp().f;
        var id = 0;
        var isExtensible = Object.isExtensible || function () {
          return true;
        };
        var FREEZE = !_fails(function () {
          return isExtensible(Object.preventExtensions({}));
        });
        var setMeta = function setMeta(it) {
          setDesc(it, META$1, {
            value: {
              i: 'O' + ++id,
              // object ID
              w: {} // weak collections IDs
            }
          });
        };
        var fastKey = function fastKey(it, create) {
          // return primitive with prefix
          if (!isObject$2(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
          if (!has$2(it, META$1)) {
            // can't set metadata to uncaught frozen object
            if (!isExtensible(it)) return 'F';
            // not necessary to add metadata
            if (!create) return 'E';
            // add missing metadata
            setMeta(it);
            // return object ID
          }
          return it[META$1].i;
        };
        var getWeak = function getWeak(it, create) {
          if (!has$2(it, META$1)) {
            // can't set metadata to uncaught frozen object
            if (!isExtensible(it)) return true;
            // not necessary to add metadata
            if (!create) return false;
            // add missing metadata
            setMeta(it);
            // return hash weak collections IDs
          }
          return it[META$1].w;
        };
        // add metadata on freeze-family methods calling
        var onFreeze = function onFreeze(it) {
          if (FREEZE && meta.NEED && isExtensible(it) && !has$2(it, META$1)) setMeta(it);
          return it;
        };
        var meta = _meta.exports = {
          KEY: META$1,
          NEED: false,
          fastKey: fastKey,
          getWeak: getWeak,
          onFreeze: onFreeze
        };
        var _metaExports = _meta.exports;
        var core = _coreExports;
        var wksExt$1 = _wksExt;
        var defineProperty = require_objectDp().f;
        var _wksDefine = function _wksDefine(name) {
          var $Symbol = core.Symbol || (core.Symbol = {});
          if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
            value: wksExt$1.f(name)
          });
        };

        // all enumerable object keys, includes symbols
        var getKeys = _objectKeys;
        var gOPS = _objectGops;
        var pIE$1 = require_objectPie();
        var _enumKeys = function _enumKeys(it) {
          var result = getKeys(it);
          var getSymbols = gOPS.f;
          if (getSymbols) {
            var symbols = getSymbols(it);
            var isEnum = pIE$1.f;
            var i = 0;
            var key;
            while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
          }
          return result;
        };

        // 7.2.2 IsArray(argument)
        var cof = _cof;
        var _isArray = Array.isArray || function isArray(arg) {
          return cof(arg) == 'Array';
        };
        var _objectGopnExt = {};
        var _objectGopn = {};

        // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
        var $keys$1 = _objectKeysInternal;
        var hiddenKeys = _enumBugKeys.concat('length', 'prototype');
        _objectGopn.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
          return $keys$1(O, hiddenKeys);
        };

        // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
        var toIObject$2 = _toIobject;
        var gOPN$1 = _objectGopn.f;
        var toString = {}.toString;
        var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        var getWindowNames = function getWindowNames(it) {
          try {
            return gOPN$1(it);
          } catch (e) {
            return windowNames.slice();
          }
        };
        _objectGopnExt.f = function getOwnPropertyNames(it) {
          return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN$1(toIObject$2(it));
        };
        var _objectGopd = {};
        var pIE = require_objectPie();
        var createDesc$1 = _propertyDesc;
        var toIObject$1 = _toIobject;
        var toPrimitive$1 = _toPrimitive;
        var has$1 = _has;
        var IE8_DOM_DEFINE = require_ie8DomDefine();
        var gOPD$1 = Object.getOwnPropertyDescriptor;
        _objectGopd.f = require_descriptors() ? gOPD$1 : function getOwnPropertyDescriptor(O, P) {
          O = toIObject$1(O);
          P = toPrimitive$1(P, true);
          if (IE8_DOM_DEFINE) try {
            return gOPD$1(O, P);
          } catch (e) {/* empty */}
          if (has$1(O, P)) return createDesc$1(!pIE.f.call(O, P), O[P]);
        };

        // ECMAScript 6 symbols shim
        var global = _globalExports;
        var has = _has;
        var DESCRIPTORS = require_descriptors();
        var $export$2 = _export;
        var redefine = _redefine;
        var META = _metaExports.KEY;
        var $fails = _fails;
        var shared = _sharedExports;
        var setToStringTag = _setToStringTag;
        var uid = _uid;
        var wks = _wksExports;
        var wksExt = _wksExt;
        var wksDefine = _wksDefine;
        var enumKeys = _enumKeys;
        var isArray = _isArray;
        var anObject = _anObject;
        var isObject$1 = _isObject;
        var toObject = _toObject;
        var toIObject = _toIobject;
        var toPrimitive = _toPrimitive;
        var createDesc = _propertyDesc;
        var _create$1 = _objectCreate;
        var gOPNExt = _objectGopnExt;
        var $GOPD = _objectGopd;
        var $GOPS = _objectGops;
        var $DP = require_objectDp();
        var $keys = _objectKeys;
        var gOPD = $GOPD.f;
        var dP = $DP.f;
        var gOPN = gOPNExt.f;
        var $Symbol = global.Symbol;
        var $JSON = global.JSON;
        var _stringify = $JSON && $JSON.stringify;
        var PROTOTYPE = 'prototype';
        var HIDDEN = wks('_hidden');
        var TO_PRIMITIVE = wks('toPrimitive');
        var isEnum = {}.propertyIsEnumerable;
        var SymbolRegistry = shared('symbol-registry');
        var AllSymbols = shared('symbols');
        var OPSymbols = shared('op-symbols');
        var ObjectProto = Object[PROTOTYPE];
        var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
        var QObject = global.QObject;
        // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
        var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

        // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
        var setSymbolDesc = DESCRIPTORS && $fails(function () {
          return _create$1(dP({}, 'a', {
            get: function get() {
              return dP(this, 'a', {
                value: 7
              }).a;
            }
          })).a != 7;
        }) ? function (it, key, D) {
          var protoDesc = gOPD(ObjectProto, key);
          if (protoDesc) delete ObjectProto[key];
          dP(it, key, D);
          if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
        } : dP;
        var wrap = function wrap(tag) {
          var sym = AllSymbols[tag] = _create$1($Symbol[PROTOTYPE]);
          sym._k = tag;
          return sym;
        };
        var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
          return typeof it == 'symbol';
        } : function (it) {
          return it instanceof $Symbol;
        };
        var $defineProperty = function defineProperty(it, key, D) {
          if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
          anObject(it);
          key = toPrimitive(key, true);
          anObject(D);
          if (has(AllSymbols, key)) {
            if (!D.enumerable) {
              if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
              it[HIDDEN][key] = true;
            } else {
              if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
              D = _create$1(D, {
                enumerable: createDesc(0, false)
              });
            }
            return setSymbolDesc(it, key, D);
          }
          return dP(it, key, D);
        };
        var $defineProperties = function defineProperties(it, P) {
          anObject(it);
          var keys = enumKeys(P = toIObject(P));
          var i = 0;
          var l = keys.length;
          var key;
          while (l > i) $defineProperty(it, key = keys[i++], P[key]);
          return it;
        };
        var $create = function create(it, P) {
          return P === undefined ? _create$1(it) : $defineProperties(_create$1(it), P);
        };
        var $propertyIsEnumerable = function propertyIsEnumerable(key) {
          var E = isEnum.call(this, key = toPrimitive(key, true));
          if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
          return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
        };
        var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
          it = toIObject(it);
          key = toPrimitive(key, true);
          if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
          var D = gOPD(it, key);
          if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
          return D;
        };
        var $getOwnPropertyNames = function getOwnPropertyNames(it) {
          var names = gOPN(toIObject(it));
          var result = [];
          var i = 0;
          var key;
          while (names.length > i) {
            if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
          }
          return result;
        };
        var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
          var IS_OP = it === ObjectProto;
          var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
          var result = [];
          var i = 0;
          var key;
          while (names.length > i) {
            if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
          }
          return result;
        };

        // 19.4.1.1 Symbol([description])
        if (!USE_NATIVE) {
          $Symbol = function Symbol() {
            if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
            var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
            var _$set = function $set(value) {
              if (this === ObjectProto) _$set.call(OPSymbols, value);
              if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
              setSymbolDesc(this, tag, createDesc(1, value));
            };
            if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
              configurable: true,
              set: _$set
            });
            return wrap(tag);
          };
          redefine($Symbol[PROTOTYPE], 'toString', function toString() {
            return this._k;
          });
          $GOPD.f = $getOwnPropertyDescriptor;
          $DP.f = $defineProperty;
          _objectGopn.f = gOPNExt.f = $getOwnPropertyNames;
          require_objectPie().f = $propertyIsEnumerable;
          $GOPS.f = $getOwnPropertySymbols;
          if (DESCRIPTORS && !_library) {
            redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable);
          }
          wksExt.f = function (name) {
            return wrap(wks(name));
          };
        }
        $export$2($export$2.G + $export$2.W + $export$2.F * !USE_NATIVE, {
          Symbol: $Symbol
        });
        for (var es6Symbols =
          // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
          'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) wks(es6Symbols[j++]);
        for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);
        $export$2($export$2.S + $export$2.F * !USE_NATIVE, 'Symbol', {
          // 19.4.2.1 Symbol.for(key)
          'for': function _for(key) {
            return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
          },
          // 19.4.2.5 Symbol.keyFor(sym)
          keyFor: function keyFor(sym) {
            if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
            for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
          },
          useSetter: function useSetter() {
            setter = true;
          },
          useSimple: function useSimple() {
            setter = false;
          }
        });
        $export$2($export$2.S + $export$2.F * !USE_NATIVE, 'Object', {
          // 19.1.2.2 Object.create(O [, Properties])
          create: $create,
          // 19.1.2.4 Object.defineProperty(O, P, Attributes)
          defineProperty: $defineProperty,
          // 19.1.2.3 Object.defineProperties(O, Properties)
          defineProperties: $defineProperties,
          // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
          getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
          // 19.1.2.7 Object.getOwnPropertyNames(O)
          getOwnPropertyNames: $getOwnPropertyNames,
          // 19.1.2.8 Object.getOwnPropertySymbols(O)
          getOwnPropertySymbols: $getOwnPropertySymbols
        });

        // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
        // https://bugs.chromium.org/p/v8/issues/detail?id=3443
        var FAILS_ON_PRIMITIVES = $fails(function () {
          $GOPS.f(1);
        });
        $export$2($export$2.S + $export$2.F * FAILS_ON_PRIMITIVES, 'Object', {
          getOwnPropertySymbols: function getOwnPropertySymbols(it) {
            return $GOPS.f(toObject(it));
          }
        });

        // 24.3.2 JSON.stringify(value [, replacer [, space]])
        $JSON && $export$2($export$2.S + $export$2.F * (!USE_NATIVE || $fails(function () {
          var S = $Symbol();
          // MS Edge converts symbol values to JSON as {}
          // WebKit converts symbol values to JSON as null
          // V8 throws on boxed symbols
          return _stringify([S]) != '[null]' || _stringify({
            a: S
          }) != '{}' || _stringify(Object(S)) != '{}';
        })), 'JSON', {
          stringify: function stringify(it) {
            var args = [it];
            var i = 1;
            var replacer, $replacer;
            while (arguments.length > i) args.push(arguments[i++]);
            $replacer = replacer = args[1];
            if (!isObject$1(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
            if (!isArray(replacer)) replacer = function replacer(key, value) {
              if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
              if (!isSymbol(value)) return value;
            };
            args[1] = replacer;
            return _stringify.apply($JSON, args);
          }
        });

        // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
        $Symbol[PROTOTYPE][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
        // 19.4.3.5 Symbol.prototype[@@toStringTag]
        setToStringTag($Symbol, 'Symbol');
        // 20.2.1.9 Math[@@toStringTag]
        setToStringTag(Math, 'Math', true);
        // 24.3.3 JSON[@@toStringTag]
        setToStringTag(global.JSON, 'JSON', true);
        _wksDefine('asyncIterator');
        _wksDefine('observable');
        var symbol$1 = _coreExports.Symbol;
        var symbol = {
          "default": symbol$1,
          __esModule: true
        };
        _typeof$1.__esModule = true;
        var _iterator = iterator;
        var _iterator2 = _interopRequireDefault$8(_iterator);
        var _symbol = symbol;
        var _symbol2 = _interopRequireDefault$8(_symbol);
        var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) {
          return typeof obj;
        } : function (obj) {
          return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj;
        };
        function _interopRequireDefault$8(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        _typeof$1.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
          return typeof obj === "undefined" ? "undefined" : _typeof(obj);
        } : function (obj) {
          return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
        };
        possibleConstructorReturn.__esModule = true;
        var _typeof2$1 = _typeof$1;
        var _typeof3$1 = _interopRequireDefault$7(_typeof2$1);
        function _interopRequireDefault$7(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        possibleConstructorReturn.default = function (self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3$1.default)(call)) === "object" || typeof call === "function") ? call : self;
        };
        var inherits = {};
        var _setProto;
        var hasRequired_setProto;
        function require_setProto() {
          if (hasRequired_setProto) return _setProto;
          hasRequired_setProto = 1;
          // Works with __proto__ only. Old v8 can't work with null proto objects.
          /* eslint-disable no-proto */
          var isObject = _isObject;
          var anObject = _anObject;
          var check = function check(O, proto) {
            anObject(O);
            if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
          };
          _setProto = {
            set: Object.setPrototypeOf || ('__proto__' in {} ?
            // eslint-disable-line
            function (test, buggy, set) {
              try {
                set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
                set(test, []);
                buggy = !(test instanceof Array);
              } catch (e) {
                buggy = true;
              }
              return function setPrototypeOf(O, proto) {
                check(O, proto);
                if (buggy) O.__proto__ = proto;else set(O, proto);
                return O;
              };
            }({}, false) : undefined),
            check: check
          };
          return _setProto;
        }

        // 19.1.3.19 Object.setPrototypeOf(O, proto)
        var $export$1 = _export;
        $export$1($export$1.S, 'Object', {
          setPrototypeOf: require_setProto().set
        });
        var setPrototypeOf$1 = _coreExports.Object.setPrototypeOf;
        var setPrototypeOf = {
          "default": setPrototypeOf$1,
          __esModule: true
        };
        var $export = _export;
        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        $export($export.S, 'Object', {
          create: _objectCreate
        });
        var $Object = _coreExports.Object;
        var create$1 = function create(P, D) {
          return $Object.create(P, D);
        };
        var create = {
          "default": create$1,
          __esModule: true
        };
        inherits.__esModule = true;
        var _setPrototypeOf = setPrototypeOf;
        var _setPrototypeOf2 = _interopRequireDefault$6(_setPrototypeOf);
        var _create = create;
        var _create2 = _interopRequireDefault$6(_create);
        var _typeof2 = _typeof$1;
        var _typeof3 = _interopRequireDefault$6(_typeof2);
        function _interopRequireDefault$6(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        inherits.default = function (subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
          }
          subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
        };
        var lottie = {
          exports: {}
        };
        (function (module, exports) {
          typeof navigator !== "undefined" && function (global, factory) {
            module.exports = factory();
          }(commonjsGlobal, function () {
            var svgNS = 'http://www.w3.org/2000/svg';
            var locationHref = '';
            var _useWebWorker = false;
            var initialDefaultFrame = -999999;
            var setWebWorker = function setWebWorker(flag) {
              _useWebWorker = !!flag;
            };
            var getWebWorker = function getWebWorker() {
              return _useWebWorker;
            };
            var setLocationHref = function setLocationHref(value) {
              locationHref = value;
            };
            var getLocationHref = function getLocationHref() {
              return locationHref;
            };
            function createTag(type) {
              // return {appendChild:function(){},setAttribute:function(){},style:{}}
              return document.createElement(type);
            }
            function extendPrototype(sources, destination) {
              var i;
              var len = sources.length;
              var sourcePrototype;
              for (i = 0; i < len; i += 1) {
                sourcePrototype = sources[i].prototype;
                for (var attr in sourcePrototype) {
                  if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];
                }
              }
            }
            function getDescriptor(object, prop) {
              return Object.getOwnPropertyDescriptor(object, prop);
            }
            function createProxyFunction(prototype) {
              function ProxyFunction() {}
              ProxyFunction.prototype = prototype;
              return ProxyFunction;
            }

            // import Howl from '../../3rd_party/howler';
            var audioControllerFactory = function () {
              function AudioController(audioFactory) {
                this.audios = [];
                this.audioFactory = audioFactory;
                this._volume = 1;
                this._isMuted = false;
              }
              AudioController.prototype = {
                addAudio: function addAudio(audio) {
                  this.audios.push(audio);
                },
                pause: function pause() {
                  var i;
                  var len = this.audios.length;
                  for (i = 0; i < len; i += 1) {
                    this.audios[i].pause();
                  }
                },
                resume: function resume() {
                  var i;
                  var len = this.audios.length;
                  for (i = 0; i < len; i += 1) {
                    this.audios[i].resume();
                  }
                },
                setRate: function setRate(rateValue) {
                  var i;
                  var len = this.audios.length;
                  for (i = 0; i < len; i += 1) {
                    this.audios[i].setRate(rateValue);
                  }
                },
                createAudio: function createAudio(assetPath) {
                  if (this.audioFactory) {
                    return this.audioFactory(assetPath);
                  }
                  if (window.Howl) {
                    return new window.Howl({
                      src: [assetPath]
                    });
                  }
                  return {
                    isPlaying: false,
                    play: function play() {
                      this.isPlaying = true;
                    },
                    seek: function seek() {
                      this.isPlaying = false;
                    },
                    playing: function playing() {},
                    rate: function rate() {},
                    setVolume: function setVolume() {}
                  };
                },
                setAudioFactory: function setAudioFactory(audioFactory) {
                  this.audioFactory = audioFactory;
                },
                setVolume: function setVolume(value) {
                  this._volume = value;
                  this._updateVolume();
                },
                mute: function mute() {
                  this._isMuted = true;
                  this._updateVolume();
                },
                unmute: function unmute() {
                  this._isMuted = false;
                  this._updateVolume();
                },
                getVolume: function getVolume() {
                  return this._volume;
                },
                _updateVolume: function _updateVolume() {
                  var i;
                  var len = this.audios.length;
                  for (i = 0; i < len; i += 1) {
                    this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));
                  }
                }
              };
              return function () {
                return new AudioController();
              };
            }();
            var createTypedArray = function () {
              function createRegularArray(type, len) {
                var i = 0;
                var arr = [];
                var value;
                switch (type) {
                  case 'int16':
                  case 'uint8c':
                    value = 1;
                    break;
                  default:
                    value = 1.1;
                    break;
                }
                for (i = 0; i < len; i += 1) {
                  arr.push(value);
                }
                return arr;
              }
              function createTypedArrayFactory(type, len) {
                if (type === 'float32') {
                  return new Float32Array(len);
                }
                if (type === 'int16') {
                  return new Int16Array(len);
                }
                if (type === 'uint8c') {
                  return new Uint8ClampedArray(len);
                }
                return createRegularArray(type, len);
              }
              if (typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {
                return createTypedArrayFactory;
              }
              return createRegularArray;
            }();
            function createSizedArray(len) {
              return Array.apply(null, {
                length: len
              });
            }
            function _typeof$6(obj) {
              "@babel/helpers - typeof";

              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof$6 = function _typeof(obj) {
                  return typeof obj;
                };
              } else {
                _typeof$6 = function _typeof(obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
              }
              return _typeof$6(obj);
            }
            var subframeEnabled = true;
            var expressionsPlugin = null;
            var expressionsInterfaces = null;
            var idPrefix$1 = '';
            var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            var bmPow = Math.pow;
            var bmSqrt = Math.sqrt;
            var bmFloor = Math.floor;
            var bmMax = Math.max;
            var bmMin = Math.min;
            var BMMath = {};
            (function () {
              var propertyNames = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'atan2', 'ceil', 'cbrt', 'expm1', 'clz32', 'cos', 'cosh', 'exp', 'floor', 'fround', 'hypot', 'imul', 'log', 'log1p', 'log2', 'log10', 'max', 'min', 'pow', 'random', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc', 'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'PI', 'SQRT1_2', 'SQRT2'];
              var i;
              var len = propertyNames.length;
              for (i = 0; i < len; i += 1) {
                BMMath[propertyNames[i]] = Math[propertyNames[i]];
              }
            })();
            BMMath.random = Math.random;
            BMMath.abs = function (val) {
              var tOfVal = _typeof$6(val);
              if (tOfVal === 'object' && val.length) {
                var absArr = createSizedArray(val.length);
                var i;
                var len = val.length;
                for (i = 0; i < len; i += 1) {
                  absArr[i] = Math.abs(val[i]);
                }
                return absArr;
              }
              return Math.abs(val);
            };
            var defaultCurveSegments = 150;
            var degToRads = Math.PI / 180;
            var roundCorner = 0.5519;
            function styleDiv(element) {
              element.style.position = 'absolute';
              element.style.top = 0;
              element.style.left = 0;
              element.style.display = 'block';
              element.style.transformOrigin = '0 0';
              element.style.webkitTransformOrigin = '0 0';
              element.style.backfaceVisibility = 'visible';
              element.style.webkitBackfaceVisibility = 'visible';
              element.style.transformStyle = 'preserve-3d';
              element.style.webkitTransformStyle = 'preserve-3d';
              element.style.mozTransformStyle = 'preserve-3d';
            }
            function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
              this.type = type;
              this.currentTime = currentTime;
              this.totalTime = totalTime;
              this.direction = frameMultiplier < 0 ? -1 : 1;
            }
            function BMCompleteEvent(type, frameMultiplier) {
              this.type = type;
              this.direction = frameMultiplier < 0 ? -1 : 1;
            }
            function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
              this.type = type;
              this.currentLoop = currentLoop;
              this.totalLoops = totalLoops;
              this.direction = frameMultiplier < 0 ? -1 : 1;
            }
            function BMSegmentStartEvent(type, firstFrame, totalFrames) {
              this.type = type;
              this.firstFrame = firstFrame;
              this.totalFrames = totalFrames;
            }
            function BMDestroyEvent(type, target) {
              this.type = type;
              this.target = target;
            }
            function BMRenderFrameErrorEvent(nativeError, currentTime) {
              this.type = 'renderFrameError';
              this.nativeError = nativeError;
              this.currentTime = currentTime;
            }
            function BMConfigErrorEvent(nativeError) {
              this.type = 'configError';
              this.nativeError = nativeError;
            }
            var createElementID = function () {
              var _count = 0;
              return function createID() {
                _count += 1;
                return idPrefix$1 + '__lottie_element_' + _count;
              };
            }();
            function HSVtoRGB(h, s, v) {
              var r;
              var g;
              var b;
              var i;
              var f;
              var p;
              var q;
              var t;
              i = Math.floor(h * 6);
              f = h * 6 - i;
              p = v * (1 - s);
              q = v * (1 - f * s);
              t = v * (1 - (1 - f) * s);
              switch (i % 6) {
                case 0:
                  r = v;
                  g = t;
                  b = p;
                  break;
                case 1:
                  r = q;
                  g = v;
                  b = p;
                  break;
                case 2:
                  r = p;
                  g = v;
                  b = t;
                  break;
                case 3:
                  r = p;
                  g = q;
                  b = v;
                  break;
                case 4:
                  r = t;
                  g = p;
                  b = v;
                  break;
                case 5:
                  r = v;
                  g = p;
                  b = q;
                  break;
              }
              return [r, g, b];
            }
            function RGBtoHSV(r, g, b) {
              var max = Math.max(r, g, b);
              var min = Math.min(r, g, b);
              var d = max - min;
              var h;
              var s = max === 0 ? 0 : d / max;
              var v = max / 255;
              switch (max) {
                case min:
                  h = 0;
                  break;
                case r:
                  h = g - b + d * (g < b ? 6 : 0);
                  h /= 6 * d;
                  break;
                case g:
                  h = b - r + d * 2;
                  h /= 6 * d;
                  break;
                case b:
                  h = r - g + d * 4;
                  h /= 6 * d;
                  break;
              }
              return [h, s, v];
            }
            function addSaturationToRGB(color, offset) {
              var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
              hsv[1] += offset;
              if (hsv[1] > 1) {
                hsv[1] = 1;
              } else if (hsv[1] <= 0) {
                hsv[1] = 0;
              }
              return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
            }
            function addBrightnessToRGB(color, offset) {
              var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
              hsv[2] += offset;
              if (hsv[2] > 1) {
                hsv[2] = 1;
              } else if (hsv[2] < 0) {
                hsv[2] = 0;
              }
              return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
            }
            function addHueToRGB(color, offset) {
              var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
              hsv[0] += offset / 360;
              if (hsv[0] > 1) {
                hsv[0] -= 1;
              } else if (hsv[0] < 0) {
                hsv[0] += 1;
              }
              return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
            }
            var rgbToHex = function () {
              var colorMap = [];
              var i;
              var hex;
              for (i = 0; i < 256; i += 1) {
                hex = i.toString(16);
                colorMap[i] = hex.length === 1 ? '0' + hex : hex;
              }
              return function (r, g, b) {
                if (r < 0) {
                  r = 0;
                }
                if (g < 0) {
                  g = 0;
                }
                if (b < 0) {
                  b = 0;
                }
                return '#' + colorMap[r] + colorMap[g] + colorMap[b];
              };
            }();
            var setSubframeEnabled = function setSubframeEnabled(flag) {
              subframeEnabled = !!flag;
            };
            var getSubframeEnabled = function getSubframeEnabled() {
              return subframeEnabled;
            };
            var setExpressionsPlugin = function setExpressionsPlugin(value) {
              expressionsPlugin = value;
            };
            var getExpressionsPlugin = function getExpressionsPlugin() {
              return expressionsPlugin;
            };
            var setExpressionInterfaces = function setExpressionInterfaces(value) {
              expressionsInterfaces = value;
            };
            var getExpressionInterfaces = function getExpressionInterfaces() {
              return expressionsInterfaces;
            };
            var setDefaultCurveSegments = function setDefaultCurveSegments(value) {
              defaultCurveSegments = value;
            };
            var getDefaultCurveSegments = function getDefaultCurveSegments() {
              return defaultCurveSegments;
            };
            var setIdPrefix = function setIdPrefix(value) {
              idPrefix$1 = value;
            };
            function createNS(type) {
              // return {appendChild:function(){},setAttribute:function(){},style:{}}
              return document.createElementNS(svgNS, type);
            }
            function _typeof$5(obj) {
              "@babel/helpers - typeof";

              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof$5 = function _typeof(obj) {
                  return typeof obj;
                };
              } else {
                _typeof$5 = function _typeof(obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
              }
              return _typeof$5(obj);
            }
            var dataManager = function () {
              var _counterId = 1;
              var processes = [];
              var workerFn;
              var workerInstance;
              var workerProxy = {
                onmessage: function onmessage() {},
                postMessage: function postMessage(path) {
                  workerFn({
                    data: path
                  });
                }
              };
              var _workerSelf = {
                postMessage: function postMessage(data) {
                  workerProxy.onmessage({
                    data: data
                  });
                }
              };
              function createWorker(fn) {
                if (window.Worker && window.Blob && getWebWorker()) {
                  var blob = new Blob(['var _workerSelf = self; self.onmessage = ', fn.toString()], {
                    type: 'text/javascript'
                  }); // var blob = new Blob(['self.onmessage = ', fn.toString()], { type: 'text/javascript' });

                  var url = URL.createObjectURL(blob);
                  return new Worker(url);
                }
                workerFn = fn;
                return workerProxy;
              }
              function setupWorker() {
                if (!workerInstance) {
                  workerInstance = createWorker(function workerStart(e) {
                    function dataFunctionManager() {
                      function completeLayers(layers, comps) {
                        var layerData;
                        var i;
                        var len = layers.length;
                        var j;
                        var jLen;
                        var k;
                        var kLen;
                        for (i = 0; i < len; i += 1) {
                          layerData = layers[i];
                          if ('ks' in layerData && !layerData.completed) {
                            layerData.completed = true;
                            if (layerData.hasMask) {
                              var maskProps = layerData.masksProperties;
                              jLen = maskProps.length;
                              for (j = 0; j < jLen; j += 1) {
                                if (maskProps[j].pt.k.i) {
                                  convertPathsToAbsoluteValues(maskProps[j].pt.k);
                                } else {
                                  kLen = maskProps[j].pt.k.length;
                                  for (k = 0; k < kLen; k += 1) {
                                    if (maskProps[j].pt.k[k].s) {
                                      convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
                                    }
                                    if (maskProps[j].pt.k[k].e) {
                                      convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
                                    }
                                  }
                                }
                              }
                            }
                            if (layerData.ty === 0) {
                              layerData.layers = findCompLayers(layerData.refId, comps);
                              completeLayers(layerData.layers, comps);
                            } else if (layerData.ty === 4) {
                              completeShapes(layerData.shapes);
                            } else if (layerData.ty === 5) {
                              completeText(layerData);
                            }
                          }
                        }
                      }
                      function completeChars(chars, assets) {
                        if (chars) {
                          var i = 0;
                          var len = chars.length;
                          for (i = 0; i < len; i += 1) {
                            if (chars[i].t === 1) {
                              // var compData = findComp(chars[i].data.refId, assets);
                              chars[i].data.layers = findCompLayers(chars[i].data.refId, assets); // chars[i].data.ip = 0;
                              // chars[i].data.op = 99999;
                              // chars[i].data.st = 0;
                              // chars[i].data.sr = 1;
                              // chars[i].w = compData.w;
                              // chars[i].data.ks = {
                              //   a: { k: [0, 0, 0], a: 0 },
                              //   p: { k: [0, -compData.h, 0], a: 0 },
                              //   r: { k: 0, a: 0 },
                              //   s: { k: [100, 100], a: 0 },
                              //   o: { k: 100, a: 0 },
                              // };

                              completeLayers(chars[i].data.layers, assets);
                            }
                          }
                        }
                      }
                      function findComp(id, comps) {
                        var i = 0;
                        var len = comps.length;
                        while (i < len) {
                          if (comps[i].id === id) {
                            return comps[i];
                          }
                          i += 1;
                        }
                        return null;
                      }
                      function findCompLayers(id, comps) {
                        var comp = findComp(id, comps);
                        if (comp) {
                          if (!comp.layers.__used) {
                            comp.layers.__used = true;
                            return comp.layers;
                          }
                          return JSON.parse(JSON.stringify(comp.layers));
                        }
                        return null;
                      }
                      function completeShapes(arr) {
                        var i;
                        var len = arr.length;
                        var j;
                        var jLen;
                        for (i = len - 1; i >= 0; i -= 1) {
                          if (arr[i].ty === 'sh') {
                            if (arr[i].ks.k.i) {
                              convertPathsToAbsoluteValues(arr[i].ks.k);
                            } else {
                              jLen = arr[i].ks.k.length;
                              for (j = 0; j < jLen; j += 1) {
                                if (arr[i].ks.k[j].s) {
                                  convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
                                }
                                if (arr[i].ks.k[j].e) {
                                  convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
                                }
                              }
                            }
                          } else if (arr[i].ty === 'gr') {
                            completeShapes(arr[i].it);
                          }
                        }
                      }
                      function convertPathsToAbsoluteValues(path) {
                        var i;
                        var len = path.i.length;
                        for (i = 0; i < len; i += 1) {
                          path.i[i][0] += path.v[i][0];
                          path.i[i][1] += path.v[i][1];
                          path.o[i][0] += path.v[i][0];
                          path.o[i][1] += path.v[i][1];
                        }
                      }
                      function checkVersion(minimum, animVersionString) {
                        var animVersion = animVersionString ? animVersionString.split('.') : [100, 100, 100];
                        if (minimum[0] > animVersion[0]) {
                          return true;
                        }
                        if (animVersion[0] > minimum[0]) {
                          return false;
                        }
                        if (minimum[1] > animVersion[1]) {
                          return true;
                        }
                        if (animVersion[1] > minimum[1]) {
                          return false;
                        }
                        if (minimum[2] > animVersion[2]) {
                          return true;
                        }
                        if (animVersion[2] > minimum[2]) {
                          return false;
                        }
                        return null;
                      }
                      var checkText = function () {
                        var minimumVersion = [4, 4, 14];
                        function updateTextLayer(textLayer) {
                          var documentData = textLayer.t.d;
                          textLayer.t.d = {
                            k: [{
                              s: documentData,
                              t: 0
                            }]
                          };
                        }
                        function iterateLayers(layers) {
                          var i;
                          var len = layers.length;
                          for (i = 0; i < len; i += 1) {
                            if (layers[i].ty === 5) {
                              updateTextLayer(layers[i]);
                            }
                          }
                        }
                        return function (animationData) {
                          if (checkVersion(minimumVersion, animationData.v)) {
                            iterateLayers(animationData.layers);
                            if (animationData.assets) {
                              var i;
                              var len = animationData.assets.length;
                              for (i = 0; i < len; i += 1) {
                                if (animationData.assets[i].layers) {
                                  iterateLayers(animationData.assets[i].layers);
                                }
                              }
                            }
                          }
                        };
                      }();
                      var checkChars = function () {
                        var minimumVersion = [4, 7, 99];
                        return function (animationData) {
                          if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
                            var i;
                            var len = animationData.chars.length;
                            for (i = 0; i < len; i += 1) {
                              var charData = animationData.chars[i];
                              if (charData.data && charData.data.shapes) {
                                completeShapes(charData.data.shapes);
                                charData.data.ip = 0;
                                charData.data.op = 99999;
                                charData.data.st = 0;
                                charData.data.sr = 1;
                                charData.data.ks = {
                                  p: {
                                    k: [0, 0],
                                    a: 0
                                  },
                                  s: {
                                    k: [100, 100],
                                    a: 0
                                  },
                                  a: {
                                    k: [0, 0],
                                    a: 0
                                  },
                                  r: {
                                    k: 0,
                                    a: 0
                                  },
                                  o: {
                                    k: 100,
                                    a: 0
                                  }
                                };
                                if (!animationData.chars[i].t) {
                                  charData.data.shapes.push({
                                    ty: 'no'
                                  });
                                  charData.data.shapes[0].it.push({
                                    p: {
                                      k: [0, 0],
                                      a: 0
                                    },
                                    s: {
                                      k: [100, 100],
                                      a: 0
                                    },
                                    a: {
                                      k: [0, 0],
                                      a: 0
                                    },
                                    r: {
                                      k: 0,
                                      a: 0
                                    },
                                    o: {
                                      k: 100,
                                      a: 0
                                    },
                                    sk: {
                                      k: 0,
                                      a: 0
                                    },
                                    sa: {
                                      k: 0,
                                      a: 0
                                    },
                                    ty: 'tr'
                                  });
                                }
                              }
                            }
                          }
                        };
                      }();
                      var checkPathProperties = function () {
                        var minimumVersion = [5, 7, 15];
                        function updateTextLayer(textLayer) {
                          var pathData = textLayer.t.p;
                          if (typeof pathData.a === 'number') {
                            pathData.a = {
                              a: 0,
                              k: pathData.a
                            };
                          }
                          if (typeof pathData.p === 'number') {
                            pathData.p = {
                              a: 0,
                              k: pathData.p
                            };
                          }
                          if (typeof pathData.r === 'number') {
                            pathData.r = {
                              a: 0,
                              k: pathData.r
                            };
                          }
                        }
                        function iterateLayers(layers) {
                          var i;
                          var len = layers.length;
                          for (i = 0; i < len; i += 1) {
                            if (layers[i].ty === 5) {
                              updateTextLayer(layers[i]);
                            }
                          }
                        }
                        return function (animationData) {
                          if (checkVersion(minimumVersion, animationData.v)) {
                            iterateLayers(animationData.layers);
                            if (animationData.assets) {
                              var i;
                              var len = animationData.assets.length;
                              for (i = 0; i < len; i += 1) {
                                if (animationData.assets[i].layers) {
                                  iterateLayers(animationData.assets[i].layers);
                                }
                              }
                            }
                          }
                        };
                      }();
                      var checkColors = function () {
                        var minimumVersion = [4, 1, 9];
                        function iterateShapes(shapes) {
                          var i;
                          var len = shapes.length;
                          var j;
                          var jLen;
                          for (i = 0; i < len; i += 1) {
                            if (shapes[i].ty === 'gr') {
                              iterateShapes(shapes[i].it);
                            } else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {
                              if (shapes[i].c.k && shapes[i].c.k[0].i) {
                                jLen = shapes[i].c.k.length;
                                for (j = 0; j < jLen; j += 1) {
                                  if (shapes[i].c.k[j].s) {
                                    shapes[i].c.k[j].s[0] /= 255;
                                    shapes[i].c.k[j].s[1] /= 255;
                                    shapes[i].c.k[j].s[2] /= 255;
                                    shapes[i].c.k[j].s[3] /= 255;
                                  }
                                  if (shapes[i].c.k[j].e) {
                                    shapes[i].c.k[j].e[0] /= 255;
                                    shapes[i].c.k[j].e[1] /= 255;
                                    shapes[i].c.k[j].e[2] /= 255;
                                    shapes[i].c.k[j].e[3] /= 255;
                                  }
                                }
                              } else {
                                shapes[i].c.k[0] /= 255;
                                shapes[i].c.k[1] /= 255;
                                shapes[i].c.k[2] /= 255;
                                shapes[i].c.k[3] /= 255;
                              }
                            }
                          }
                        }
                        function iterateLayers(layers) {
                          var i;
                          var len = layers.length;
                          for (i = 0; i < len; i += 1) {
                            if (layers[i].ty === 4) {
                              iterateShapes(layers[i].shapes);
                            }
                          }
                        }
                        return function (animationData) {
                          if (checkVersion(minimumVersion, animationData.v)) {
                            iterateLayers(animationData.layers);
                            if (animationData.assets) {
                              var i;
                              var len = animationData.assets.length;
                              for (i = 0; i < len; i += 1) {
                                if (animationData.assets[i].layers) {
                                  iterateLayers(animationData.assets[i].layers);
                                }
                              }
                            }
                          }
                        };
                      }();
                      var checkShapes = function () {
                        var minimumVersion = [4, 4, 18];
                        function completeClosingShapes(arr) {
                          var i;
                          var len = arr.length;
                          var j;
                          var jLen;
                          for (i = len - 1; i >= 0; i -= 1) {
                            if (arr[i].ty === 'sh') {
                              if (arr[i].ks.k.i) {
                                arr[i].ks.k.c = arr[i].closed;
                              } else {
                                jLen = arr[i].ks.k.length;
                                for (j = 0; j < jLen; j += 1) {
                                  if (arr[i].ks.k[j].s) {
                                    arr[i].ks.k[j].s[0].c = arr[i].closed;
                                  }
                                  if (arr[i].ks.k[j].e) {
                                    arr[i].ks.k[j].e[0].c = arr[i].closed;
                                  }
                                }
                              }
                            } else if (arr[i].ty === 'gr') {
                              completeClosingShapes(arr[i].it);
                            }
                          }
                        }
                        function iterateLayers(layers) {
                          var layerData;
                          var i;
                          var len = layers.length;
                          var j;
                          var jLen;
                          var k;
                          var kLen;
                          for (i = 0; i < len; i += 1) {
                            layerData = layers[i];
                            if (layerData.hasMask) {
                              var maskProps = layerData.masksProperties;
                              jLen = maskProps.length;
                              for (j = 0; j < jLen; j += 1) {
                                if (maskProps[j].pt.k.i) {
                                  maskProps[j].pt.k.c = maskProps[j].cl;
                                } else {
                                  kLen = maskProps[j].pt.k.length;
                                  for (k = 0; k < kLen; k += 1) {
                                    if (maskProps[j].pt.k[k].s) {
                                      maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
                                    }
                                    if (maskProps[j].pt.k[k].e) {
                                      maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
                                    }
                                  }
                                }
                              }
                            }
                            if (layerData.ty === 4) {
                              completeClosingShapes(layerData.shapes);
                            }
                          }
                        }
                        return function (animationData) {
                          if (checkVersion(minimumVersion, animationData.v)) {
                            iterateLayers(animationData.layers);
                            if (animationData.assets) {
                              var i;
                              var len = animationData.assets.length;
                              for (i = 0; i < len; i += 1) {
                                if (animationData.assets[i].layers) {
                                  iterateLayers(animationData.assets[i].layers);
                                }
                              }
                            }
                          }
                        };
                      }();
                      function completeData(animationData) {
                        if (animationData.__complete) {
                          return;
                        }
                        checkColors(animationData);
                        checkText(animationData);
                        checkChars(animationData);
                        checkPathProperties(animationData);
                        checkShapes(animationData);
                        completeLayers(animationData.layers, animationData.assets);
                        completeChars(animationData.chars, animationData.assets);
                        animationData.__complete = true;
                      }
                      function completeText(data) {
                        if (data.t.a.length === 0 && !('m' in data.t.p)) ;
                      }
                      var moduleOb = {};
                      moduleOb.completeData = completeData;
                      moduleOb.checkColors = checkColors;
                      moduleOb.checkChars = checkChars;
                      moduleOb.checkPathProperties = checkPathProperties;
                      moduleOb.checkShapes = checkShapes;
                      moduleOb.completeLayers = completeLayers;
                      return moduleOb;
                    }
                    if (!_workerSelf.dataManager) {
                      _workerSelf.dataManager = dataFunctionManager();
                    }
                    if (!_workerSelf.assetLoader) {
                      _workerSelf.assetLoader = function () {
                        function formatResponse(xhr) {
                          // using typeof doubles the time of execution of this method,
                          // so if available, it's better to use the header to validate the type
                          var contentTypeHeader = xhr.getResponseHeader('content-type');
                          if (contentTypeHeader && xhr.responseType === 'json' && contentTypeHeader.indexOf('json') !== -1) {
                            return xhr.response;
                          }
                          if (xhr.response && _typeof$5(xhr.response) === 'object') {
                            return xhr.response;
                          }
                          if (xhr.response && typeof xhr.response === 'string') {
                            return JSON.parse(xhr.response);
                          }
                          if (xhr.responseText) {
                            return JSON.parse(xhr.responseText);
                          }
                          return null;
                        }
                        function loadAsset(path, fullPath, callback, errorCallback) {
                          var response;
                          var xhr = new XMLHttpRequest(); // set responseType after calling open or IE will break.

                          try {
                            // This crashes on Android WebView prior to KitKat
                            xhr.responseType = 'json';
                          } catch (err) {} // eslint-disable-line no-empty

                          xhr.onreadystatechange = function () {
                            if (xhr.readyState === 4) {
                              if (xhr.status === 200) {
                                response = formatResponse(xhr);
                                callback(response);
                              } else {
                                try {
                                  response = formatResponse(xhr);
                                  callback(response);
                                } catch (err) {
                                  if (errorCallback) {
                                    errorCallback(err);
                                  }
                                }
                              }
                            }
                          };
                          try {
                            // Hack to workaround banner validation
                            xhr.open(['G', 'E', 'T'].join(''), path, true);
                          } catch (error) {
                            // Hack to workaround banner validation
                            xhr.open(['G', 'E', 'T'].join(''), fullPath + '/' + path, true);
                          }
                          xhr.send();
                        }
                        return {
                          load: loadAsset
                        };
                      }();
                    }
                    if (e.data.type === 'loadAnimation') {
                      _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function (data) {
                        _workerSelf.dataManager.completeData(data);
                        _workerSelf.postMessage({
                          id: e.data.id,
                          payload: data,
                          status: 'success'
                        });
                      }, function () {
                        _workerSelf.postMessage({
                          id: e.data.id,
                          status: 'error'
                        });
                      });
                    } else if (e.data.type === 'complete') {
                      var animation = e.data.animation;
                      _workerSelf.dataManager.completeData(animation);
                      _workerSelf.postMessage({
                        id: e.data.id,
                        payload: animation,
                        status: 'success'
                      });
                    } else if (e.data.type === 'loadData') {
                      _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function (data) {
                        _workerSelf.postMessage({
                          id: e.data.id,
                          payload: data,
                          status: 'success'
                        });
                      }, function () {
                        _workerSelf.postMessage({
                          id: e.data.id,
                          status: 'error'
                        });
                      });
                    }
                  });
                  workerInstance.onmessage = function (event) {
                    var data = event.data;
                    var id = data.id;
                    var process = processes[id];
                    processes[id] = null;
                    if (data.status === 'success') {
                      process.onComplete(data.payload);
                    } else if (process.onError) {
                      process.onError();
                    }
                  };
                }
              }
              function createProcess(onComplete, onError) {
                _counterId += 1;
                var id = 'processId_' + _counterId;
                processes[id] = {
                  onComplete: onComplete,
                  onError: onError
                };
                return id;
              }
              function loadAnimation(path, onComplete, onError) {
                setupWorker();
                var processId = createProcess(onComplete, onError);
                workerInstance.postMessage({
                  type: 'loadAnimation',
                  path: path,
                  fullPath: window.location.origin + window.location.pathname,
                  id: processId
                });
              }
              function loadData(path, onComplete, onError) {
                setupWorker();
                var processId = createProcess(onComplete, onError);
                workerInstance.postMessage({
                  type: 'loadData',
                  path: path,
                  fullPath: window.location.origin + window.location.pathname,
                  id: processId
                });
              }
              function completeAnimation(anim, onComplete, onError) {
                setupWorker();
                var processId = createProcess(onComplete, onError);
                workerInstance.postMessage({
                  type: 'complete',
                  animation: anim,
                  id: processId
                });
              }
              return {
                loadAnimation: loadAnimation,
                loadData: loadData,
                completeAnimation: completeAnimation
              };
            }();
            var ImagePreloader = function () {
              var proxyImage = function () {
                var canvas = createTag('canvas');
                canvas.width = 1;
                canvas.height = 1;
                var ctx = canvas.getContext('2d');
                ctx.fillStyle = 'rgba(0,0,0,0)';
                ctx.fillRect(0, 0, 1, 1);
                return canvas;
              }();
              function imageLoaded() {
                this.loadedAssets += 1;
                if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
                  if (this.imagesLoadedCb) {
                    this.imagesLoadedCb(null);
                  }
                }
              }
              function footageLoaded() {
                this.loadedFootagesCount += 1;
                if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
                  if (this.imagesLoadedCb) {
                    this.imagesLoadedCb(null);
                  }
                }
              }
              function getAssetsPath(assetData, assetsPath, originalPath) {
                var path = '';
                if (assetData.e) {
                  path = assetData.p;
                } else if (assetsPath) {
                  var imagePath = assetData.p;
                  if (imagePath.indexOf('images/') !== -1) {
                    imagePath = imagePath.split('/')[1];
                  }
                  path = assetsPath + imagePath;
                } else {
                  path = originalPath;
                  path += assetData.u ? assetData.u : '';
                  path += assetData.p;
                }
                return path;
              }
              function testImageLoaded(img) {
                var _count = 0;
                var intervalId = setInterval(function () {
                  var box = img.getBBox();
                  if (box.width || _count > 500) {
                    this._imageLoaded();
                    clearInterval(intervalId);
                  }
                  _count += 1;
                }.bind(this), 50);
              }
              function createImageData(assetData) {
                var path = getAssetsPath(assetData, this.assetsPath, this.path);
                var img = createNS('image');
                if (isSafari) {
                  this.testImageLoaded(img);
                } else {
                  img.addEventListener('load', this._imageLoaded, false);
                }
                img.addEventListener('error', function () {
                  ob.img = proxyImage;
                  this._imageLoaded();
                }.bind(this), false);
                img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);
                if (this._elementHelper.append) {
                  this._elementHelper.append(img);
                } else {
                  this._elementHelper.appendChild(img);
                }
                var ob = {
                  img: img,
                  assetData: assetData
                };
                return ob;
              }
              function createImgData(assetData) {
                var path = getAssetsPath(assetData, this.assetsPath, this.path);
                var img = createTag('img');
                img.crossOrigin = 'anonymous';
                img.addEventListener('load', this._imageLoaded, false);
                img.addEventListener('error', function () {
                  ob.img = proxyImage;
                  this._imageLoaded();
                }.bind(this), false);
                img.src = path;
                var ob = {
                  img: img,
                  assetData: assetData
                };
                return ob;
              }
              function createFootageData(data) {
                var ob = {
                  assetData: data
                };
                var path = getAssetsPath(data, this.assetsPath, this.path);
                dataManager.loadData(path, function (footageData) {
                  ob.img = footageData;
                  this._footageLoaded();
                }.bind(this), function () {
                  ob.img = {};
                  this._footageLoaded();
                }.bind(this));
                return ob;
              }
              function loadAssets(assets, cb) {
                this.imagesLoadedCb = cb;
                var i;
                var len = assets.length;
                for (i = 0; i < len; i += 1) {
                  if (!assets[i].layers) {
                    if (!assets[i].t || assets[i].t === 'seq') {
                      this.totalImages += 1;
                      this.images.push(this._createImageData(assets[i]));
                    } else if (assets[i].t === 3) {
                      this.totalFootages += 1;
                      this.images.push(this.createFootageData(assets[i]));
                    }
                  }
                }
              }
              function setPath(path) {
                this.path = path || '';
              }
              function setAssetsPath(path) {
                this.assetsPath = path || '';
              }
              function getAsset(assetData) {
                var i = 0;
                var len = this.images.length;
                while (i < len) {
                  if (this.images[i].assetData === assetData) {
                    return this.images[i].img;
                  }
                  i += 1;
                }
                return null;
              }
              function destroy() {
                this.imagesLoadedCb = null;
                this.images.length = 0;
              }
              function loadedImages() {
                return this.totalImages === this.loadedAssets;
              }
              function loadedFootages() {
                return this.totalFootages === this.loadedFootagesCount;
              }
              function setCacheType(type, elementHelper) {
                if (type === 'svg') {
                  this._elementHelper = elementHelper;
                  this._createImageData = this.createImageData.bind(this);
                } else {
                  this._createImageData = this.createImgData.bind(this);
                }
              }
              function ImagePreloaderFactory() {
                this._imageLoaded = imageLoaded.bind(this);
                this._footageLoaded = footageLoaded.bind(this);
                this.testImageLoaded = testImageLoaded.bind(this);
                this.createFootageData = createFootageData.bind(this);
                this.assetsPath = '';
                this.path = '';
                this.totalImages = 0;
                this.totalFootages = 0;
                this.loadedAssets = 0;
                this.loadedFootagesCount = 0;
                this.imagesLoadedCb = null;
                this.images = [];
              }
              ImagePreloaderFactory.prototype = {
                loadAssets: loadAssets,
                setAssetsPath: setAssetsPath,
                setPath: setPath,
                loadedImages: loadedImages,
                loadedFootages: loadedFootages,
                destroy: destroy,
                getAsset: getAsset,
                createImgData: createImgData,
                createImageData: createImageData,
                imageLoaded: imageLoaded,
                footageLoaded: footageLoaded,
                setCacheType: setCacheType
              };
              return ImagePreloaderFactory;
            }();
            function BaseEvent() {}
            BaseEvent.prototype = {
              triggerEvent: function triggerEvent(eventName, args) {
                if (this._cbs[eventName]) {
                  var callbacks = this._cbs[eventName];
                  for (var i = 0; i < callbacks.length; i += 1) {
                    callbacks[i](args);
                  }
                }
              },
              addEventListener: function addEventListener(eventName, callback) {
                if (!this._cbs[eventName]) {
                  this._cbs[eventName] = [];
                }
                this._cbs[eventName].push(callback);
                return function () {
                  this.removeEventListener(eventName, callback);
                }.bind(this);
              },
              removeEventListener: function removeEventListener(eventName, callback) {
                if (!callback) {
                  this._cbs[eventName] = null;
                } else if (this._cbs[eventName]) {
                  var i = 0;
                  var len = this._cbs[eventName].length;
                  while (i < len) {
                    if (this._cbs[eventName][i] === callback) {
                      this._cbs[eventName].splice(i, 1);
                      i -= 1;
                      len -= 1;
                    }
                    i += 1;
                  }
                  if (!this._cbs[eventName].length) {
                    this._cbs[eventName] = null;
                  }
                }
              }
            };
            var markerParser = function () {
              function parsePayloadLines(payload) {
                var lines = payload.split('\r\n');
                var keys = {};
                var line;
                var keysCount = 0;
                for (var i = 0; i < lines.length; i += 1) {
                  line = lines[i].split(':');
                  if (line.length === 2) {
                    keys[line[0]] = line[1].trim();
                    keysCount += 1;
                  }
                }
                if (keysCount === 0) {
                  throw new Error();
                }
                return keys;
              }
              return function (_markers) {
                var markers = [];
                for (var i = 0; i < _markers.length; i += 1) {
                  var _marker = _markers[i];
                  var markerData = {
                    time: _marker.tm,
                    duration: _marker.dr
                  };
                  try {
                    markerData.payload = JSON.parse(_markers[i].cm);
                  } catch (_) {
                    try {
                      markerData.payload = parsePayloadLines(_markers[i].cm);
                    } catch (__) {
                      markerData.payload = {
                        name: _markers[i].cm
                      };
                    }
                  }
                  markers.push(markerData);
                }
                return markers;
              };
            }();
            var ProjectInterface = function () {
              function registerComposition(comp) {
                this.compositions.push(comp);
              }
              return function () {
                function _thisProjectFunction(name) {
                  var i = 0;
                  var len = this.compositions.length;
                  while (i < len) {
                    if (this.compositions[i].data && this.compositions[i].data.nm === name) {
                      if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {
                        this.compositions[i].prepareFrame(this.currentFrame);
                      }
                      return this.compositions[i].compInterface;
                    }
                    i += 1;
                  }
                  return null;
                }
                _thisProjectFunction.compositions = [];
                _thisProjectFunction.currentFrame = 0;
                _thisProjectFunction.registerComposition = registerComposition;
                return _thisProjectFunction;
              };
            }();
            var renderers = {};
            var registerRenderer = function registerRenderer(key, value) {
              renderers[key] = value;
            };
            function getRenderer(key) {
              return renderers[key];
            }
            function getRegisteredRenderer() {
              // Returns canvas by default for compatibility
              if (renderers.canvas) {
                return 'canvas';
              } // Returns any renderer that is registered

              for (var key in renderers) {
                if (renderers[key]) {
                  return key;
                }
              }
              return '';
            }
            function _typeof$4(obj) {
              "@babel/helpers - typeof";

              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof$4 = function _typeof(obj) {
                  return typeof obj;
                };
              } else {
                _typeof$4 = function _typeof(obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
              }
              return _typeof$4(obj);
            }
            var AnimationItem = function AnimationItem() {
              this._cbs = [];
              this.name = '';
              this.path = '';
              this.isLoaded = false;
              this.currentFrame = 0;
              this.currentRawFrame = 0;
              this.firstFrame = 0;
              this.totalFrames = 0;
              this.frameRate = 0;
              this.frameMult = 0;
              this.playSpeed = 1;
              this.playDirection = 1;
              this.playCount = 0;
              this.animationData = {};
              this.assets = [];
              this.isPaused = true;
              this.autoplay = false;
              this.loop = true;
              this.renderer = null;
              this.animationID = createElementID();
              this.assetsPath = '';
              this.timeCompleted = 0;
              this.segmentPos = 0;
              this.isSubframeEnabled = getSubframeEnabled();
              this.segments = [];
              this._idle = true;
              this._completedLoop = false;
              this.projectInterface = ProjectInterface();
              this.imagePreloader = new ImagePreloader();
              this.audioController = audioControllerFactory();
              this.markers = [];
              this.configAnimation = this.configAnimation.bind(this);
              this.onSetupError = this.onSetupError.bind(this);
              this.onSegmentComplete = this.onSegmentComplete.bind(this);
              this.drawnFrameEvent = new BMEnterFrameEvent('drawnFrame', 0, 0, 0);
              this.expressionsPlugin = getExpressionsPlugin();
            };
            extendPrototype([BaseEvent], AnimationItem);
            AnimationItem.prototype.setParams = function (params) {
              if (params.wrapper || params.container) {
                this.wrapper = params.wrapper || params.container;
              }
              var animType = 'svg';
              if (params.animType) {
                animType = params.animType;
              } else if (params.renderer) {
                animType = params.renderer;
              }
              var RendererClass = getRenderer(animType);
              this.renderer = new RendererClass(this, params.rendererSettings);
              this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
              this.renderer.setProjectInterface(this.projectInterface);
              this.animType = animType;
              if (params.loop === '' || params.loop === null || params.loop === undefined || params.loop === true) {
                this.loop = true;
              } else if (params.loop === false) {
                this.loop = false;
              } else {
                this.loop = parseInt(params.loop, 10);
              }
              this.autoplay = 'autoplay' in params ? params.autoplay : true;
              this.name = params.name ? params.name : '';
              this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, 'autoloadSegments') ? params.autoloadSegments : true;
              this.assetsPath = params.assetsPath;
              this.initialSegment = params.initialSegment;
              if (params.audioFactory) {
                this.audioController.setAudioFactory(params.audioFactory);
              }
              if (params.animationData) {
                this.setupAnimation(params.animationData);
              } else if (params.path) {
                if (params.path.lastIndexOf('\\') !== -1) {
                  this.path = params.path.substr(0, params.path.lastIndexOf('\\') + 1);
                } else {
                  this.path = params.path.substr(0, params.path.lastIndexOf('/') + 1);
                }
                this.fileName = params.path.substr(params.path.lastIndexOf('/') + 1);
                this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json'));
                dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);
              }
            };
            AnimationItem.prototype.onSetupError = function () {
              this.trigger('data_failed');
            };
            AnimationItem.prototype.setupAnimation = function (data) {
              dataManager.completeAnimation(data, this.configAnimation);
            };
            AnimationItem.prototype.setData = function (wrapper, animationData) {
              if (animationData) {
                if (_typeof$4(animationData) !== 'object') {
                  animationData = JSON.parse(animationData);
                }
              }
              var params = {
                wrapper: wrapper,
                animationData: animationData
              };
              var wrapperAttributes = wrapper.attributes;
              params.path = wrapperAttributes.getNamedItem('data-animation-path') // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem('data-animation-path').value : wrapperAttributes.getNamedItem('data-bm-path') // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem('data-bm-path').value : wrapperAttributes.getNamedItem('bm-path') ? wrapperAttributes.getNamedItem('bm-path').value : '';
              params.animType = wrapperAttributes.getNamedItem('data-anim-type') // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem('data-anim-type').value : wrapperAttributes.getNamedItem('data-bm-type') // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem('data-bm-type').value : wrapperAttributes.getNamedItem('bm-type') // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem('bm-type').value : wrapperAttributes.getNamedItem('data-bm-renderer') // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem('data-bm-renderer').value : wrapperAttributes.getNamedItem('bm-renderer') ? wrapperAttributes.getNamedItem('bm-renderer').value : getRegisteredRenderer() || 'canvas';
              var loop = wrapperAttributes.getNamedItem('data-anim-loop') // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem('data-anim-loop').value : wrapperAttributes.getNamedItem('data-bm-loop') // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem('data-bm-loop').value : wrapperAttributes.getNamedItem('bm-loop') ? wrapperAttributes.getNamedItem('bm-loop').value : '';
              if (loop === 'false') {
                params.loop = false;
              } else if (loop === 'true') {
                params.loop = true;
              } else if (loop !== '') {
                params.loop = parseInt(loop, 10);
              }
              var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem('data-anim-autoplay').value : wrapperAttributes.getNamedItem('data-bm-autoplay') // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem('data-bm-autoplay').value : wrapperAttributes.getNamedItem('bm-autoplay') ? wrapperAttributes.getNamedItem('bm-autoplay').value : true;
              params.autoplay = autoplay !== 'false';
              params.name = wrapperAttributes.getNamedItem('data-name') // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem('data-name').value : wrapperAttributes.getNamedItem('data-bm-name') // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem('data-bm-name').value : wrapperAttributes.getNamedItem('bm-name') ? wrapperAttributes.getNamedItem('bm-name').value : '';
              var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem('data-anim-prerender').value : wrapperAttributes.getNamedItem('data-bm-prerender') // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem('data-bm-prerender').value : wrapperAttributes.getNamedItem('bm-prerender') ? wrapperAttributes.getNamedItem('bm-prerender').value : '';
              if (prerender === 'false') {
                params.prerender = false;
              }
              if (!params.path) {
                this.trigger('destroy');
              } else {
                this.setParams(params);
              }
            };
            AnimationItem.prototype.includeLayers = function (data) {
              if (data.op > this.animationData.op) {
                this.animationData.op = data.op;
                this.totalFrames = Math.floor(data.op - this.animationData.ip);
              }
              var layers = this.animationData.layers;
              var i;
              var len = layers.length;
              var newLayers = data.layers;
              var j;
              var jLen = newLayers.length;
              for (j = 0; j < jLen; j += 1) {
                i = 0;
                while (i < len) {
                  if (layers[i].id === newLayers[j].id) {
                    layers[i] = newLayers[j];
                    break;
                  }
                  i += 1;
                }
              }
              if (data.chars || data.fonts) {
                this.renderer.globalData.fontManager.addChars(data.chars);
                this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
              }
              if (data.assets) {
                len = data.assets.length;
                for (i = 0; i < len; i += 1) {
                  this.animationData.assets.push(data.assets[i]);
                }
              }
              this.animationData.__complete = false;
              dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
            };
            AnimationItem.prototype.onSegmentComplete = function (data) {
              this.animationData = data;
              var expressionsPlugin = getExpressionsPlugin();
              if (expressionsPlugin) {
                expressionsPlugin.initExpressions(this);
              }
              this.loadNextSegment();
            };
            AnimationItem.prototype.loadNextSegment = function () {
              var segments = this.animationData.segments;
              if (!segments || segments.length === 0 || !this.autoloadSegments) {
                this.trigger('data_ready');
                this.timeCompleted = this.totalFrames;
                return;
              }
              var segment = segments.shift();
              this.timeCompleted = segment.time * this.frameRate;
              var segmentPath = this.path + this.fileName + '_' + this.segmentPos + '.json';
              this.segmentPos += 1;
              dataManager.loadData(segmentPath, this.includeLayers.bind(this), function () {
                this.trigger('data_failed');
              }.bind(this));
            };
            AnimationItem.prototype.loadSegments = function () {
              var segments = this.animationData.segments;
              if (!segments) {
                this.timeCompleted = this.totalFrames;
              }
              this.loadNextSegment();
            };
            AnimationItem.prototype.imagesLoaded = function () {
              this.trigger('loaded_images');
              this.checkLoaded();
            };
            AnimationItem.prototype.preloadImages = function () {
              this.imagePreloader.setAssetsPath(this.assetsPath);
              this.imagePreloader.setPath(this.path);
              this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
            };
            AnimationItem.prototype.configAnimation = function (animData) {
              if (!this.renderer) {
                return;
              }
              try {
                this.animationData = animData;
                if (this.initialSegment) {
                  this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
                  this.firstFrame = Math.round(this.initialSegment[0]);
                } else {
                  this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
                  this.firstFrame = Math.round(this.animationData.ip);
                }
                this.renderer.configAnimation(animData);
                if (!animData.assets) {
                  animData.assets = [];
                }
                this.assets = this.animationData.assets;
                this.frameRate = this.animationData.fr;
                this.frameMult = this.animationData.fr / 1000;
                this.renderer.searchExtraCompositions(animData.assets);
                this.markers = markerParser(animData.markers || []);
                this.trigger('config_ready');
                this.preloadImages();
                this.loadSegments();
                this.updaFrameModifier();
                this.waitForFontsLoaded();
                if (this.isPaused) {
                  this.audioController.pause();
                }
              } catch (error) {
                this.triggerConfigError(error);
              }
            };
            AnimationItem.prototype.waitForFontsLoaded = function () {
              if (!this.renderer) {
                return;
              }
              if (this.renderer.globalData.fontManager.isLoaded) {
                this.checkLoaded();
              } else {
                setTimeout(this.waitForFontsLoaded.bind(this), 20);
              }
            };
            AnimationItem.prototype.checkLoaded = function () {
              if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== 'canvas') && this.imagePreloader.loadedFootages()) {
                this.isLoaded = true;
                var expressionsPlugin = getExpressionsPlugin();
                if (expressionsPlugin) {
                  expressionsPlugin.initExpressions(this);
                }
                this.renderer.initItems();
                setTimeout(function () {
                  this.trigger('DOMLoaded');
                }.bind(this), 0);
                this.gotoFrame();
                if (this.autoplay) {
                  this.play();
                }
              }
            };
            AnimationItem.prototype.resize = function (width, height) {
              // Adding this validation for backwards compatibility in case an event object was being passed down
              var _width = typeof width === 'number' ? width : undefined;
              var _height = typeof height === 'number' ? height : undefined;
              this.renderer.updateContainerSize(_width, _height);
            };
            AnimationItem.prototype.setSubframe = function (flag) {
              this.isSubframeEnabled = !!flag;
            };
            AnimationItem.prototype.gotoFrame = function () {
              this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame; // eslint-disable-line no-bitwise

              if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
                this.currentFrame = this.timeCompleted;
              }
              this.trigger('enterFrame');
              this.renderFrame();
              this.trigger('drawnFrame');
            };
            AnimationItem.prototype.renderFrame = function () {
              if (this.isLoaded === false || !this.renderer) {
                return;
              }
              try {
                if (this.expressionsPlugin) {
                  this.expressionsPlugin.resetFrame();
                }
                this.renderer.renderFrame(this.currentFrame + this.firstFrame);
              } catch (error) {
                this.triggerRenderFrameError(error);
              }
            };
            AnimationItem.prototype.play = function (name) {
              if (name && this.name !== name) {
                return;
              }
              if (this.isPaused === true) {
                this.isPaused = false;
                this.trigger('_play');
                this.audioController.resume();
                if (this._idle) {
                  this._idle = false;
                  this.trigger('_active');
                }
              }
            };
            AnimationItem.prototype.pause = function (name) {
              if (name && this.name !== name) {
                return;
              }
              if (this.isPaused === false) {
                this.isPaused = true;
                this.trigger('_pause');
                this._idle = true;
                this.trigger('_idle');
                this.audioController.pause();
              }
            };
            AnimationItem.prototype.togglePause = function (name) {
              if (name && this.name !== name) {
                return;
              }
              if (this.isPaused === true) {
                this.play();
              } else {
                this.pause();
              }
            };
            AnimationItem.prototype.stop = function (name) {
              if (name && this.name !== name) {
                return;
              }
              this.pause();
              this.playCount = 0;
              this._completedLoop = false;
              this.setCurrentRawFrameValue(0);
            };
            AnimationItem.prototype.getMarkerData = function (markerName) {
              var marker;
              for (var i = 0; i < this.markers.length; i += 1) {
                marker = this.markers[i];
                if (marker.payload && marker.payload.name === markerName) {
                  return marker;
                }
              }
              return null;
            };
            AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {
              if (name && this.name !== name) {
                return;
              }
              var numValue = Number(value);
              if (isNaN(numValue)) {
                var marker = this.getMarkerData(value);
                if (marker) {
                  this.goToAndStop(marker.time, true);
                }
              } else if (isFrame) {
                this.setCurrentRawFrameValue(value);
              } else {
                this.setCurrentRawFrameValue(value * this.frameModifier);
              }
              this.pause();
            };
            AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {
              if (name && this.name !== name) {
                return;
              }
              var numValue = Number(value);
              if (isNaN(numValue)) {
                var marker = this.getMarkerData(value);
                if (marker) {
                  if (!marker.duration) {
                    this.goToAndStop(marker.time, true);
                  } else {
                    this.playSegments([marker.time, marker.time + marker.duration], true);
                  }
                }
              } else {
                this.goToAndStop(numValue, isFrame, name);
              }
              this.play();
            };
            AnimationItem.prototype.advanceTime = function (value) {
              if (this.isPaused === true || this.isLoaded === false) {
                return;
              }
              var nextValue = this.currentRawFrame + value * this.frameModifier;
              var _isComplete = false; // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.
              // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.

              if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
                if (!this.loop || this.playCount === this.loop) {
                  if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
                    _isComplete = true;
                    nextValue = this.totalFrames - 1;
                  }
                } else if (nextValue >= this.totalFrames) {
                  this.playCount += 1;
                  if (!this.checkSegments(nextValue % this.totalFrames)) {
                    this.setCurrentRawFrameValue(nextValue % this.totalFrames);
                    this._completedLoop = true;
                    this.trigger('loopComplete');
                  }
                } else {
                  this.setCurrentRawFrameValue(nextValue);
                }
              } else if (nextValue < 0) {
                if (!this.checkSegments(nextValue % this.totalFrames)) {
                  if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
                    // eslint-disable-line no-plusplus
                    this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);
                    if (!this._completedLoop) {
                      this._completedLoop = true;
                    } else {
                      this.trigger('loopComplete');
                    }
                  } else {
                    _isComplete = true;
                    nextValue = 0;
                  }
                }
              } else {
                this.setCurrentRawFrameValue(nextValue);
              }
              if (_isComplete) {
                this.setCurrentRawFrameValue(nextValue);
                this.pause();
                this.trigger('complete');
              }
            };
            AnimationItem.prototype.adjustSegment = function (arr, offset) {
              this.playCount = 0;
              if (arr[1] < arr[0]) {
                if (this.frameModifier > 0) {
                  if (this.playSpeed < 0) {
                    this.setSpeed(-this.playSpeed);
                  } else {
                    this.setDirection(-1);
                  }
                }
                this.totalFrames = arr[0] - arr[1];
                this.timeCompleted = this.totalFrames;
                this.firstFrame = arr[1];
                this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);
              } else if (arr[1] > arr[0]) {
                if (this.frameModifier < 0) {
                  if (this.playSpeed < 0) {
                    this.setSpeed(-this.playSpeed);
                  } else {
                    this.setDirection(1);
                  }
                }
                this.totalFrames = arr[1] - arr[0];
                this.timeCompleted = this.totalFrames;
                this.firstFrame = arr[0];
                this.setCurrentRawFrameValue(0.001 + offset);
              }
              this.trigger('segmentStart');
            };
            AnimationItem.prototype.setSegment = function (init, end) {
              var pendingFrame = -1;
              if (this.isPaused) {
                if (this.currentRawFrame + this.firstFrame < init) {
                  pendingFrame = init;
                } else if (this.currentRawFrame + this.firstFrame > end) {
                  pendingFrame = end - init;
                }
              }
              this.firstFrame = init;
              this.totalFrames = end - init;
              this.timeCompleted = this.totalFrames;
              if (pendingFrame !== -1) {
                this.goToAndStop(pendingFrame, true);
              }
            };
            AnimationItem.prototype.playSegments = function (arr, forceFlag) {
              if (forceFlag) {
                this.segments.length = 0;
              }
              if (_typeof$4(arr[0]) === 'object') {
                var i;
                var len = arr.length;
                for (i = 0; i < len; i += 1) {
                  this.segments.push(arr[i]);
                }
              } else {
                this.segments.push(arr);
              }
              if (this.segments.length && forceFlag) {
                this.adjustSegment(this.segments.shift(), 0);
              }
              if (this.isPaused) {
                this.play();
              }
            };
            AnimationItem.prototype.resetSegments = function (forceFlag) {
              this.segments.length = 0;
              this.segments.push([this.animationData.ip, this.animationData.op]);
              if (forceFlag) {
                this.checkSegments(0);
              }
            };
            AnimationItem.prototype.checkSegments = function (offset) {
              if (this.segments.length) {
                this.adjustSegment(this.segments.shift(), offset);
                return true;
              }
              return false;
            };
            AnimationItem.prototype.destroy = function (name) {
              if (name && this.name !== name || !this.renderer) {
                return;
              }
              this.renderer.destroy();
              this.imagePreloader.destroy();
              this.trigger('destroy');
              this._cbs = null;
              this.onEnterFrame = null;
              this.onLoopComplete = null;
              this.onComplete = null;
              this.onSegmentStart = null;
              this.onDestroy = null;
              this.renderer = null;
              this.expressionsPlugin = null;
              this.imagePreloader = null;
              this.projectInterface = null;
            };
            AnimationItem.prototype.setCurrentRawFrameValue = function (value) {
              this.currentRawFrame = value;
              this.gotoFrame();
            };
            AnimationItem.prototype.setSpeed = function (val) {
              this.playSpeed = val;
              this.updaFrameModifier();
            };
            AnimationItem.prototype.setDirection = function (val) {
              this.playDirection = val < 0 ? -1 : 1;
              this.updaFrameModifier();
            };
            AnimationItem.prototype.setLoop = function (isLooping) {
              this.loop = isLooping;
            };
            AnimationItem.prototype.setVolume = function (val, name) {
              if (name && this.name !== name) {
                return;
              }
              this.audioController.setVolume(val);
            };
            AnimationItem.prototype.getVolume = function () {
              return this.audioController.getVolume();
            };
            AnimationItem.prototype.mute = function (name) {
              if (name && this.name !== name) {
                return;
              }
              this.audioController.mute();
            };
            AnimationItem.prototype.unmute = function (name) {
              if (name && this.name !== name) {
                return;
              }
              this.audioController.unmute();
            };
            AnimationItem.prototype.updaFrameModifier = function () {
              this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
              this.audioController.setRate(this.playSpeed * this.playDirection);
            };
            AnimationItem.prototype.getPath = function () {
              return this.path;
            };
            AnimationItem.prototype.getAssetsPath = function (assetData) {
              var path = '';
              if (assetData.e) {
                path = assetData.p;
              } else if (this.assetsPath) {
                var imagePath = assetData.p;
                if (imagePath.indexOf('images/') !== -1) {
                  imagePath = imagePath.split('/')[1];
                }
                path = this.assetsPath + imagePath;
              } else {
                path = this.path;
                path += assetData.u ? assetData.u : '';
                path += assetData.p;
              }
              return path;
            };
            AnimationItem.prototype.getAssetData = function (id) {
              var i = 0;
              var len = this.assets.length;
              while (i < len) {
                if (id === this.assets[i].id) {
                  return this.assets[i];
                }
                i += 1;
              }
              return null;
            };
            AnimationItem.prototype.hide = function () {
              this.renderer.hide();
            };
            AnimationItem.prototype.show = function () {
              this.renderer.show();
            };
            AnimationItem.prototype.getDuration = function (isFrame) {
              return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
            };
            AnimationItem.prototype.updateDocumentData = function (path, documentData, index) {
              try {
                var element = this.renderer.getElementByPath(path);
                element.updateDocumentData(documentData, index);
              } catch (error) {// TODO: decide how to handle catch case
              }
            };
            AnimationItem.prototype.trigger = function (name) {
              if (this._cbs && this._cbs[name]) {
                switch (name) {
                  case 'enterFrame':
                    this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));
                    break;
                  case 'drawnFrame':
                    this.drawnFrameEvent.currentTime = this.currentFrame;
                    this.drawnFrameEvent.totalTime = this.totalFrames;
                    this.drawnFrameEvent.direction = this.frameModifier;
                    this.triggerEvent(name, this.drawnFrameEvent);
                    break;
                  case 'loopComplete':
                    this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
                    break;
                  case 'complete':
                    this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));
                    break;
                  case 'segmentStart':
                    this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
                    break;
                  case 'destroy':
                    this.triggerEvent(name, new BMDestroyEvent(name, this));
                    break;
                  default:
                    this.triggerEvent(name);
                }
              }
              if (name === 'enterFrame' && this.onEnterFrame) {
                this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));
              }
              if (name === 'loopComplete' && this.onLoopComplete) {
                this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
              }
              if (name === 'complete' && this.onComplete) {
                this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));
              }
              if (name === 'segmentStart' && this.onSegmentStart) {
                this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
              }
              if (name === 'destroy' && this.onDestroy) {
                this.onDestroy.call(this, new BMDestroyEvent(name, this));
              }
            };
            AnimationItem.prototype.triggerRenderFrameError = function (nativeError) {
              var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
              this.triggerEvent('error', error);
              if (this.onError) {
                this.onError.call(this, error);
              }
            };
            AnimationItem.prototype.triggerConfigError = function (nativeError) {
              var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
              this.triggerEvent('error', error);
              if (this.onError) {
                this.onError.call(this, error);
              }
            };
            var animationManager = function () {
              var moduleOb = {};
              var registeredAnimations = [];
              var initTime = 0;
              var len = 0;
              var playingAnimationsNum = 0;
              var _stopped = true;
              var _isFrozen = false;
              function removeElement(ev) {
                var i = 0;
                var animItem = ev.target;
                while (i < len) {
                  if (registeredAnimations[i].animation === animItem) {
                    registeredAnimations.splice(i, 1);
                    i -= 1;
                    len -= 1;
                    if (!animItem.isPaused) {
                      subtractPlayingCount();
                    }
                  }
                  i += 1;
                }
              }
              function registerAnimation(element, animationData) {
                if (!element) {
                  return null;
                }
                var i = 0;
                while (i < len) {
                  if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {
                    return registeredAnimations[i].animation;
                  }
                  i += 1;
                }
                var animItem = new AnimationItem();
                setupAnimation(animItem, element);
                animItem.setData(element, animationData);
                return animItem;
              }
              function getRegisteredAnimations() {
                var i;
                var lenAnims = registeredAnimations.length;
                var animations = [];
                for (i = 0; i < lenAnims; i += 1) {
                  animations.push(registeredAnimations[i].animation);
                }
                return animations;
              }
              function addPlayingCount() {
                playingAnimationsNum += 1;
                activate();
              }
              function subtractPlayingCount() {
                playingAnimationsNum -= 1;
              }
              function setupAnimation(animItem, element) {
                animItem.addEventListener('destroy', removeElement);
                animItem.addEventListener('_active', addPlayingCount);
                animItem.addEventListener('_idle', subtractPlayingCount);
                registeredAnimations.push({
                  elem: element,
                  animation: animItem
                });
                len += 1;
              }
              function loadAnimation(params) {
                var animItem = new AnimationItem();
                setupAnimation(animItem, null);
                animItem.setParams(params);
                return animItem;
              }
              function setSpeed(val, animation) {
                var i;
                for (i = 0; i < len; i += 1) {
                  registeredAnimations[i].animation.setSpeed(val, animation);
                }
              }
              function setDirection(val, animation) {
                var i;
                for (i = 0; i < len; i += 1) {
                  registeredAnimations[i].animation.setDirection(val, animation);
                }
              }
              function play(animation) {
                var i;
                for (i = 0; i < len; i += 1) {
                  registeredAnimations[i].animation.play(animation);
                }
              }
              function resume(nowTime) {
                var elapsedTime = nowTime - initTime;
                var i;
                for (i = 0; i < len; i += 1) {
                  registeredAnimations[i].animation.advanceTime(elapsedTime);
                }
                initTime = nowTime;
                if (playingAnimationsNum && !_isFrozen) {
                  window.requestAnimationFrame(resume);
                } else {
                  _stopped = true;
                }
              }
              function first(nowTime) {
                initTime = nowTime;
                window.requestAnimationFrame(resume);
              }
              function pause(animation) {
                var i;
                for (i = 0; i < len; i += 1) {
                  registeredAnimations[i].animation.pause(animation);
                }
              }
              function goToAndStop(value, isFrame, animation) {
                var i;
                for (i = 0; i < len; i += 1) {
                  registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);
                }
              }
              function stop(animation) {
                var i;
                for (i = 0; i < len; i += 1) {
                  registeredAnimations[i].animation.stop(animation);
                }
              }
              function togglePause(animation) {
                var i;
                for (i = 0; i < len; i += 1) {
                  registeredAnimations[i].animation.togglePause(animation);
                }
              }
              function destroy(animation) {
                var i;
                for (i = len - 1; i >= 0; i -= 1) {
                  registeredAnimations[i].animation.destroy(animation);
                }
              }
              function searchAnimations(animationData, standalone, renderer) {
                var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')), [].slice.call(document.getElementsByClassName('bodymovin')));
                var i;
                var lenAnims = animElements.length;
                for (i = 0; i < lenAnims; i += 1) {
                  if (renderer) {
                    animElements[i].setAttribute('data-bm-type', renderer);
                  }
                  registerAnimation(animElements[i], animationData);
                }
                if (standalone && lenAnims === 0) {
                  if (!renderer) {
                    renderer = 'svg';
                  }
                  var body = document.getElementsByTagName('body')[0];
                  body.innerText = '';
                  var div = createTag('div');
                  div.style.width = '100%';
                  div.style.height = '100%';
                  div.setAttribute('data-bm-type', renderer);
                  body.appendChild(div);
                  registerAnimation(div, animationData);
                }
              }
              function resize() {
                var i;
                for (i = 0; i < len; i += 1) {
                  registeredAnimations[i].animation.resize();
                }
              }
              function activate() {
                if (!_isFrozen && playingAnimationsNum) {
                  if (_stopped) {
                    window.requestAnimationFrame(first);
                    _stopped = false;
                  }
                }
              }
              function freeze() {
                _isFrozen = true;
              }
              function unfreeze() {
                _isFrozen = false;
                activate();
              }
              function setVolume(val, animation) {
                var i;
                for (i = 0; i < len; i += 1) {
                  registeredAnimations[i].animation.setVolume(val, animation);
                }
              }
              function mute(animation) {
                var i;
                for (i = 0; i < len; i += 1) {
                  registeredAnimations[i].animation.mute(animation);
                }
              }
              function unmute(animation) {
                var i;
                for (i = 0; i < len; i += 1) {
                  registeredAnimations[i].animation.unmute(animation);
                }
              }
              moduleOb.registerAnimation = registerAnimation;
              moduleOb.loadAnimation = loadAnimation;
              moduleOb.setSpeed = setSpeed;
              moduleOb.setDirection = setDirection;
              moduleOb.play = play;
              moduleOb.pause = pause;
              moduleOb.stop = stop;
              moduleOb.togglePause = togglePause;
              moduleOb.searchAnimations = searchAnimations;
              moduleOb.resize = resize; // moduleOb.start = start;

              moduleOb.goToAndStop = goToAndStop;
              moduleOb.destroy = destroy;
              moduleOb.freeze = freeze;
              moduleOb.unfreeze = unfreeze;
              moduleOb.setVolume = setVolume;
              moduleOb.mute = mute;
              moduleOb.unmute = unmute;
              moduleOb.getRegisteredAnimations = getRegisteredAnimations;
              return moduleOb;
            }();

            /* eslint-disable */
            var BezierFactory = function () {
              /**
                 * BezierEasing - use bezier curve for transition easing function
                 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
                 *
                 * Credits: is based on Firefox's nsSMILKeySpline.cpp
                 * Usage:
                 * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
                 * spline.get(x) => returns the easing value | x must be in [0, 1] range
                 *
                 */
              var ob = {};
              ob.getBezierEasing = getBezierEasing;
              var beziers = {};
              function getBezierEasing(a, b, c, d, nm) {
                var str = nm || ('bez_' + a + '_' + b + '_' + c + '_' + d).replace(/\./g, 'p');
                if (beziers[str]) {
                  return beziers[str];
                }
                var bezEasing = new BezierEasing([a, b, c, d]);
                beziers[str] = bezEasing;
                return bezEasing;
              } // These values are established by empiricism with tests (tradeoff: performance VS precision)

              var NEWTON_ITERATIONS = 4;
              var NEWTON_MIN_SLOPE = 0.001;
              var SUBDIVISION_PRECISION = 0.0000001;
              var SUBDIVISION_MAX_ITERATIONS = 10;
              var kSplineTableSize = 11;
              var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
              var float32ArraySupported = typeof Float32Array === 'function';
              function A(aA1, aA2) {
                return 1.0 - 3.0 * aA2 + 3.0 * aA1;
              }
              function B(aA1, aA2) {
                return 3.0 * aA2 - 6.0 * aA1;
              }
              function C(aA1) {
                return 3.0 * aA1;
              } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.

              function calcBezier(aT, aA1, aA2) {
                return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
              } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.

              function getSlope(aT, aA1, aA2) {
                return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
              }
              function binarySubdivide(aX, aA, aB, mX1, mX2) {
                var currentX,
                  currentT,
                  i = 0;
                do {
                  currentT = aA + (aB - aA) / 2.0;
                  currentX = calcBezier(currentT, mX1, mX2) - aX;
                  if (currentX > 0.0) {
                    aB = currentT;
                  } else {
                    aA = currentT;
                  }
                } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
                return currentT;
              }
              function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
                for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
                  var currentSlope = getSlope(aGuessT, mX1, mX2);
                  if (currentSlope === 0.0) return aGuessT;
                  var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                  aGuessT -= currentX / currentSlope;
                }
                return aGuessT;
              }
              /**
                 * points is an array of [ mX1, mY1, mX2, mY2 ]
                 */

              function BezierEasing(points) {
                this._p = points;
                this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
                this._precomputed = false;
                this.get = this.get.bind(this);
              }
              BezierEasing.prototype = {
                get: function get(x) {
                  var mX1 = this._p[0],
                    mY1 = this._p[1],
                    mX2 = this._p[2],
                    mY2 = this._p[3];
                  if (!this._precomputed) this._precompute();
                  if (mX1 === mY1 && mX2 === mY2) return x; // linear
                  // Because JavaScript number are imprecise, we should guarantee the extremes are right.

                  if (x === 0) return 0;
                  if (x === 1) return 1;
                  return calcBezier(this._getTForX(x), mY1, mY2);
                },
                // Private part
                _precompute: function _precompute() {
                  var mX1 = this._p[0],
                    mY1 = this._p[1],
                    mX2 = this._p[2],
                    mY2 = this._p[3];
                  this._precomputed = true;
                  if (mX1 !== mY1 || mX2 !== mY2) {
                    this._calcSampleValues();
                  }
                },
                _calcSampleValues: function _calcSampleValues() {
                  var mX1 = this._p[0],
                    mX2 = this._p[2];
                  for (var i = 0; i < kSplineTableSize; ++i) {
                    this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
                  }
                },
                /**
                     * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
                     */
                _getTForX: function _getTForX(aX) {
                  var mX1 = this._p[0],
                    mX2 = this._p[2],
                    mSampleValues = this._mSampleValues;
                  var intervalStart = 0.0;
                  var currentSample = 1;
                  var lastSample = kSplineTableSize - 1;
                  for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
                    intervalStart += kSampleStepSize;
                  }
                  --currentSample; // Interpolate to provide an initial guess for t

                  var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
                  var guessForT = intervalStart + dist * kSampleStepSize;
                  var initialSlope = getSlope(guessForT, mX1, mX2);
                  if (initialSlope >= NEWTON_MIN_SLOPE) {
                    return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
                  }
                  if (initialSlope === 0.0) {
                    return guessForT;
                  }
                  return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
                }
              };
              return ob;
            }();
            var pooling = function () {
              function _double(arr) {
                return arr.concat(createSizedArray(arr.length));
              }
              return {
                "double": _double
              };
            }();
            var poolFactory = function () {
              return function (initialLength, _create, _release) {
                var _length = 0;
                var _maxLength = initialLength;
                var pool = createSizedArray(_maxLength);
                var ob = {
                  newElement: newElement,
                  release: release
                };
                function newElement() {
                  var element;
                  if (_length) {
                    _length -= 1;
                    element = pool[_length];
                  } else {
                    element = _create();
                  }
                  return element;
                }
                function release(element) {
                  if (_length === _maxLength) {
                    pool = pooling["double"](pool);
                    _maxLength *= 2;
                  }
                  if (_release) {
                    _release(element);
                  }
                  pool[_length] = element;
                  _length += 1;
                }
                return ob;
              };
            }();
            var bezierLengthPool = function () {
              function create() {
                return {
                  addedLength: 0,
                  percents: createTypedArray('float32', getDefaultCurveSegments()),
                  lengths: createTypedArray('float32', getDefaultCurveSegments())
                };
              }
              return poolFactory(8, create);
            }();
            var segmentsLengthPool = function () {
              function create() {
                return {
                  lengths: [],
                  totalLength: 0
                };
              }
              function release(element) {
                var i;
                var len = element.lengths.length;
                for (i = 0; i < len; i += 1) {
                  bezierLengthPool.release(element.lengths[i]);
                }
                element.lengths.length = 0;
              }
              return poolFactory(8, create, release);
            }();
            function bezFunction() {
              var math = Math;
              function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
                var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
                return det1 > -0.001 && det1 < 0.001;
              }
              function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
                if (z1 === 0 && z2 === 0 && z3 === 0) {
                  return pointOnLine2D(x1, y1, x2, y2, x3, y3);
                }
                var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
                var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
                var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
                var diffDist;
                if (dist1 > dist2) {
                  if (dist1 > dist3) {
                    diffDist = dist1 - dist2 - dist3;
                  } else {
                    diffDist = dist3 - dist2 - dist1;
                  }
                } else if (dist3 > dist2) {
                  diffDist = dist3 - dist2 - dist1;
                } else {
                  diffDist = dist2 - dist1 - dist3;
                }
                return diffDist > -0.0001 && diffDist < 0.0001;
              }
              var getBezierLength = function () {
                return function (pt1, pt2, pt3, pt4) {
                  var curveSegments = getDefaultCurveSegments();
                  var k;
                  var i;
                  var len;
                  var ptCoord;
                  var perc;
                  var addedLength = 0;
                  var ptDistance;
                  var point = [];
                  var lastPoint = [];
                  var lengthData = bezierLengthPool.newElement();
                  len = pt3.length;
                  for (k = 0; k < curveSegments; k += 1) {
                    perc = k / (curveSegments - 1);
                    ptDistance = 0;
                    for (i = 0; i < len; i += 1) {
                      ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];
                      point[i] = ptCoord;
                      if (lastPoint[i] !== null) {
                        ptDistance += bmPow(point[i] - lastPoint[i], 2);
                      }
                      lastPoint[i] = point[i];
                    }
                    if (ptDistance) {
                      ptDistance = bmSqrt(ptDistance);
                      addedLength += ptDistance;
                    }
                    lengthData.percents[k] = perc;
                    lengthData.lengths[k] = addedLength;
                  }
                  lengthData.addedLength = addedLength;
                  return lengthData;
                };
              }();
              function getSegmentsLength(shapeData) {
                var segmentsLength = segmentsLengthPool.newElement();
                var closed = shapeData.c;
                var pathV = shapeData.v;
                var pathO = shapeData.o;
                var pathI = shapeData.i;
                var i;
                var len = shapeData._length;
                var lengths = segmentsLength.lengths;
                var totalLength = 0;
                for (i = 0; i < len - 1; i += 1) {
                  lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);
                  totalLength += lengths[i].addedLength;
                }
                if (closed && len) {
                  lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);
                  totalLength += lengths[i].addedLength;
                }
                segmentsLength.totalLength = totalLength;
                return segmentsLength;
              }
              function BezierData(length) {
                this.segmentLength = 0;
                this.points = new Array(length);
              }
              function PointData(partial, point) {
                this.partialLength = partial;
                this.point = point;
              }
              var buildBezierData = function () {
                var storedData = {};
                return function (pt1, pt2, pt3, pt4) {
                  var bezierName = (pt1[0] + '_' + pt1[1] + '_' + pt2[0] + '_' + pt2[1] + '_' + pt3[0] + '_' + pt3[1] + '_' + pt4[0] + '_' + pt4[1]).replace(/\./g, 'p');
                  if (!storedData[bezierName]) {
                    var curveSegments = getDefaultCurveSegments();
                    var k;
                    var i;
                    var len;
                    var ptCoord;
                    var perc;
                    var addedLength = 0;
                    var ptDistance;
                    var point;
                    var lastPoint = null;
                    if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
                      curveSegments = 2;
                    }
                    var bezierData = new BezierData(curveSegments);
                    len = pt3.length;
                    for (k = 0; k < curveSegments; k += 1) {
                      point = createSizedArray(len);
                      perc = k / (curveSegments - 1);
                      ptDistance = 0;
                      for (i = 0; i < len; i += 1) {
                        ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];
                        point[i] = ptCoord;
                        if (lastPoint !== null) {
                          ptDistance += bmPow(point[i] - lastPoint[i], 2);
                        }
                      }
                      ptDistance = bmSqrt(ptDistance);
                      addedLength += ptDistance;
                      bezierData.points[k] = new PointData(ptDistance, point);
                      lastPoint = point;
                    }
                    bezierData.segmentLength = addedLength;
                    storedData[bezierName] = bezierData;
                  }
                  return storedData[bezierName];
                };
              }();
              function getDistancePerc(perc, bezierData) {
                var percents = bezierData.percents;
                var lengths = bezierData.lengths;
                var len = percents.length;
                var initPos = bmFloor((len - 1) * perc);
                var lengthPos = perc * bezierData.addedLength;
                var lPerc = 0;
                if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
                  return percents[initPos];
                }
                var dir = lengths[initPos] > lengthPos ? -1 : 1;
                var flag = true;
                while (flag) {
                  if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
                    lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
                    flag = false;
                  } else {
                    initPos += dir;
                  }
                  if (initPos < 0 || initPos >= len - 1) {
                    // FIX for TypedArrays that don't store floating point values with enough accuracy
                    if (initPos === len - 1) {
                      return percents[initPos];
                    }
                    flag = false;
                  }
                }
                return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
              }
              function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
                var t1 = getDistancePerc(percent, bezierData);
                var u1 = 1 - t1;
                var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;
                var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;
                return [ptX, ptY];
              }
              var bezierSegmentPoints = createTypedArray('float32', 8);
              function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
                if (startPerc < 0) {
                  startPerc = 0;
                } else if (startPerc > 1) {
                  startPerc = 1;
                }
                var t0 = getDistancePerc(startPerc, bezierData);
                endPerc = endPerc > 1 ? 1 : endPerc;
                var t1 = getDistancePerc(endPerc, bezierData);
                var i;
                var len = pt1.length;
                var u0 = 1 - t0;
                var u1 = 1 - t1;
                var u0u0u0 = u0 * u0 * u0;
                var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase

                var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase

                var t0t0t0 = t0 * t0 * t0; //

                var u0u0u1 = u0 * u0 * u1;
                var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase

                var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase

                var t0t0t1 = t0 * t0 * t1; //

                var u0u1u1 = u0 * u1 * u1;
                var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase

                var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase

                var t0t1t1 = t0 * t1 * t1; //

                var u1u1u1 = u1 * u1 * u1;
                var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase

                var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase

                var t1t1t1 = t1 * t1 * t1;
                for (i = 0; i < len; i += 1) {
                  bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase

                  bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase

                  bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase

                  bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
                }
                return bezierSegmentPoints;
              }
              return {
                getSegmentsLength: getSegmentsLength,
                getNewSegment: getNewSegment,
                getPointInSegment: getPointInSegment,
                buildBezierData: buildBezierData,
                pointOnLine2D: pointOnLine2D,
                pointOnLine3D: pointOnLine3D
              };
            }
            var bez = bezFunction();
            var initFrame = initialDefaultFrame;
            var mathAbs = Math.abs;
            function interpolateValue(frameNum, caching) {
              var offsetTime = this.offsetTime;
              var newValue;
              if (this.propType === 'multidimensional') {
                newValue = createTypedArray('float32', this.pv.length);
              }
              var iterationIndex = caching.lastIndex;
              var i = iterationIndex;
              var len = this.keyframes.length - 1;
              var flag = true;
              var keyData;
              var nextKeyData;
              var keyframeMetadata;
              while (flag) {
                keyData = this.keyframes[i];
                nextKeyData = this.keyframes[i + 1];
                if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
                  if (keyData.h) {
                    keyData = nextKeyData;
                  }
                  iterationIndex = 0;
                  break;
                }
                if (nextKeyData.t - offsetTime > frameNum) {
                  iterationIndex = i;
                  break;
                }
                if (i < len - 1) {
                  i += 1;
                } else {
                  iterationIndex = 0;
                  flag = false;
                }
              }
              keyframeMetadata = this.keyframesMetadata[i] || {};
              var k;
              var kLen;
              var perc;
              var jLen;
              var j;
              var fnc;
              var nextKeyTime = nextKeyData.t - offsetTime;
              var keyTime = keyData.t - offsetTime;
              var endValue;
              if (keyData.to) {
                if (!keyframeMetadata.bezierData) {
                  keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
                }
                var bezierData = keyframeMetadata.bezierData;
                if (frameNum >= nextKeyTime || frameNum < keyTime) {
                  var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
                  kLen = bezierData.points[ind].point.length;
                  for (k = 0; k < kLen; k += 1) {
                    newValue[k] = bezierData.points[ind].point[k];
                  } // caching._lastKeyframeIndex = -1;
                } else {
                  if (keyframeMetadata.__fnct) {
                    fnc = keyframeMetadata.__fnct;
                  } else {
                    fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
                    keyframeMetadata.__fnct = fnc;
                  }
                  perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                  var distanceInLine = bezierData.segmentLength * perc;
                  var segmentPerc;
                  var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;
                  j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0;
                  flag = true;
                  jLen = bezierData.points.length;
                  while (flag) {
                    addedLength += bezierData.points[j].partialLength;
                    if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
                      kLen = bezierData.points[j].point.length;
                      for (k = 0; k < kLen; k += 1) {
                        newValue[k] = bezierData.points[j].point[k];
                      }
                      break;
                    } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
                      segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
                      kLen = bezierData.points[j].point.length;
                      for (k = 0; k < kLen; k += 1) {
                        newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
                      }
                      break;
                    }
                    if (j < jLen - 1) {
                      j += 1;
                    } else {
                      flag = false;
                    }
                  }
                  caching._lastPoint = j;
                  caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
                  caching._lastKeyframeIndex = i;
                }
              } else {
                var outX;
                var outY;
                var inX;
                var inY;
                var keyValue;
                len = keyData.s.length;
                endValue = nextKeyData.s || keyData.e;
                if (this.sh && keyData.h !== 1) {
                  if (frameNum >= nextKeyTime) {
                    newValue[0] = endValue[0];
                    newValue[1] = endValue[1];
                    newValue[2] = endValue[2];
                  } else if (frameNum <= keyTime) {
                    newValue[0] = keyData.s[0];
                    newValue[1] = keyData.s[1];
                    newValue[2] = keyData.s[2];
                  } else {
                    var quatStart = createQuaternion(keyData.s);
                    var quatEnd = createQuaternion(endValue);
                    var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
                    quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
                  }
                } else {
                  for (i = 0; i < len; i += 1) {
                    if (keyData.h !== 1) {
                      if (frameNum >= nextKeyTime) {
                        perc = 1;
                      } else if (frameNum < keyTime) {
                        perc = 0;
                      } else {
                        if (keyData.o.x.constructor === Array) {
                          if (!keyframeMetadata.__fnct) {
                            keyframeMetadata.__fnct = [];
                          }
                          if (!keyframeMetadata.__fnct[i]) {
                            outX = keyData.o.x[i] === undefined ? keyData.o.x[0] : keyData.o.x[i];
                            outY = keyData.o.y[i] === undefined ? keyData.o.y[0] : keyData.o.y[i];
                            inX = keyData.i.x[i] === undefined ? keyData.i.x[0] : keyData.i.x[i];
                            inY = keyData.i.y[i] === undefined ? keyData.i.y[0] : keyData.i.y[i];
                            fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                            keyframeMetadata.__fnct[i] = fnc;
                          } else {
                            fnc = keyframeMetadata.__fnct[i];
                          }
                        } else if (!keyframeMetadata.__fnct) {
                          outX = keyData.o.x;
                          outY = keyData.o.y;
                          inX = keyData.i.x;
                          inY = keyData.i.y;
                          fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                          keyData.keyframeMetadata = fnc;
                        } else {
                          fnc = keyframeMetadata.__fnct;
                        }
                        perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                      }
                    }
                    endValue = nextKeyData.s || keyData.e;
                    keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;
                    if (this.propType === 'multidimensional') {
                      newValue[i] = keyValue;
                    } else {
                      newValue = keyValue;
                    }
                  }
                }
              }
              caching.lastIndex = iterationIndex;
              return newValue;
            } // based on @Toji's https://github.com/toji/gl-matrix/

            function slerp(a, b, t) {
              var out = [];
              var ax = a[0];
              var ay = a[1];
              var az = a[2];
              var aw = a[3];
              var bx = b[0];
              var by = b[1];
              var bz = b[2];
              var bw = b[3];
              var omega;
              var cosom;
              var sinom;
              var scale0;
              var scale1;
              cosom = ax * bx + ay * by + az * bz + aw * bw;
              if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
              }
              if (1.0 - cosom > 0.000001) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
              } else {
                scale0 = 1.0 - t;
                scale1 = t;
              }
              out[0] = scale0 * ax + scale1 * bx;
              out[1] = scale0 * ay + scale1 * by;
              out[2] = scale0 * az + scale1 * bz;
              out[3] = scale0 * aw + scale1 * bw;
              return out;
            }
            function quaternionToEuler(out, quat) {
              var qx = quat[0];
              var qy = quat[1];
              var qz = quat[2];
              var qw = quat[3];
              var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
              var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
              var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
              out[0] = heading / degToRads;
              out[1] = attitude / degToRads;
              out[2] = bank / degToRads;
            }
            function createQuaternion(values) {
              var heading = values[0] * degToRads;
              var attitude = values[1] * degToRads;
              var bank = values[2] * degToRads;
              var c1 = Math.cos(heading / 2);
              var c2 = Math.cos(attitude / 2);
              var c3 = Math.cos(bank / 2);
              var s1 = Math.sin(heading / 2);
              var s2 = Math.sin(attitude / 2);
              var s3 = Math.sin(bank / 2);
              var w = c1 * c2 * c3 - s1 * s2 * s3;
              var x = s1 * s2 * c3 + c1 * c2 * s3;
              var y = s1 * c2 * c3 + c1 * s2 * s3;
              var z = c1 * s2 * c3 - s1 * c2 * s3;
              return [x, y, z, w];
            }
            function getValueAtCurrentTime() {
              var frameNum = this.comp.renderedFrame - this.offsetTime;
              var initTime = this.keyframes[0].t - this.offsetTime;
              var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
              if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
                if (this._caching.lastFrame >= frameNum) {
                  this._caching._lastKeyframeIndex = -1;
                  this._caching.lastIndex = 0;
                }
                var renderResult = this.interpolateValue(frameNum, this._caching);
                this.pv = renderResult;
              }
              this._caching.lastFrame = frameNum;
              return this.pv;
            }
            function setVValue(val) {
              var multipliedValue;
              if (this.propType === 'unidimensional') {
                multipliedValue = val * this.mult;
                if (mathAbs(this.v - multipliedValue) > 0.00001) {
                  this.v = multipliedValue;
                  this._mdf = true;
                }
              } else {
                var i = 0;
                var len = this.v.length;
                while (i < len) {
                  multipliedValue = val[i] * this.mult;
                  if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {
                    this.v[i] = multipliedValue;
                    this._mdf = true;
                  }
                  i += 1;
                }
              }
            }
            function processEffectsSequence() {
              if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
                return;
              }
              if (this.lock) {
                this.setVValue(this.pv);
                return;
              }
              this.lock = true;
              this._mdf = this._isFirstFrame;
              var i;
              var len = this.effectsSequence.length;
              var finalValue = this.kf ? this.pv : this.data.k;
              for (i = 0; i < len; i += 1) {
                finalValue = this.effectsSequence[i](finalValue);
              }
              this.setVValue(finalValue);
              this._isFirstFrame = false;
              this.lock = false;
              this.frameId = this.elem.globalData.frameId;
            }
            function addEffect(effectFunction) {
              this.effectsSequence.push(effectFunction);
              this.container.addDynamicProperty(this);
            }
            function ValueProperty(elem, data, mult, container) {
              this.propType = 'unidimensional';
              this.mult = mult || 1;
              this.data = data;
              this.v = mult ? data.k * mult : data.k;
              this.pv = data.k;
              this._mdf = false;
              this.elem = elem;
              this.container = container;
              this.comp = elem.comp;
              this.k = false;
              this.kf = false;
              this.vel = 0;
              this.effectsSequence = [];
              this._isFirstFrame = true;
              this.getValue = processEffectsSequence;
              this.setVValue = setVValue;
              this.addEffect = addEffect;
            }
            function MultiDimensionalProperty(elem, data, mult, container) {
              this.propType = 'multidimensional';
              this.mult = mult || 1;
              this.data = data;
              this._mdf = false;
              this.elem = elem;
              this.container = container;
              this.comp = elem.comp;
              this.k = false;
              this.kf = false;
              this.frameId = -1;
              var i;
              var len = data.k.length;
              this.v = createTypedArray('float32', len);
              this.pv = createTypedArray('float32', len);
              this.vel = createTypedArray('float32', len);
              for (i = 0; i < len; i += 1) {
                this.v[i] = data.k[i] * this.mult;
                this.pv[i] = data.k[i];
              }
              this._isFirstFrame = true;
              this.effectsSequence = [];
              this.getValue = processEffectsSequence;
              this.setVValue = setVValue;
              this.addEffect = addEffect;
            }
            function KeyframedValueProperty(elem, data, mult, container) {
              this.propType = 'unidimensional';
              this.keyframes = data.k;
              this.keyframesMetadata = [];
              this.offsetTime = elem.data.st;
              this.frameId = -1;
              this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: 0,
                _lastKeyframeIndex: -1
              };
              this.k = true;
              this.kf = true;
              this.data = data;
              this.mult = mult || 1;
              this.elem = elem;
              this.container = container;
              this.comp = elem.comp;
              this.v = initFrame;
              this.pv = initFrame;
              this._isFirstFrame = true;
              this.getValue = processEffectsSequence;
              this.setVValue = setVValue;
              this.interpolateValue = interpolateValue;
              this.effectsSequence = [getValueAtCurrentTime.bind(this)];
              this.addEffect = addEffect;
            }
            function KeyframedMultidimensionalProperty(elem, data, mult, container) {
              this.propType = 'multidimensional';
              var i;
              var len = data.k.length;
              var s;
              var e;
              var to;
              var ti;
              for (i = 0; i < len - 1; i += 1) {
                if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {
                  s = data.k[i].s;
                  e = data.k[i + 1].s;
                  to = data.k[i].to;
                  ti = data.k[i].ti;
                  if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {
                    data.k[i].to = null;
                    data.k[i].ti = null;
                  }
                  if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
                    if (s.length === 2 || s[2] === e[2] && to[2] === 0 && ti[2] === 0) {
                      data.k[i].to = null;
                      data.k[i].ti = null;
                    }
                  }
                }
              }
              this.effectsSequence = [getValueAtCurrentTime.bind(this)];
              this.data = data;
              this.keyframes = data.k;
              this.keyframesMetadata = [];
              this.offsetTime = elem.data.st;
              this.k = true;
              this.kf = true;
              this._isFirstFrame = true;
              this.mult = mult || 1;
              this.elem = elem;
              this.container = container;
              this.comp = elem.comp;
              this.getValue = processEffectsSequence;
              this.setVValue = setVValue;
              this.interpolateValue = interpolateValue;
              this.frameId = -1;
              var arrLen = data.k[0].s.length;
              this.v = createTypedArray('float32', arrLen);
              this.pv = createTypedArray('float32', arrLen);
              for (i = 0; i < arrLen; i += 1) {
                this.v[i] = initFrame;
                this.pv[i] = initFrame;
              }
              this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: createTypedArray('float32', arrLen)
              };
              this.addEffect = addEffect;
            }
            var PropertyFactory = function () {
              function getProp(elem, data, type, mult, container) {
                if (data.sid) {
                  data = elem.globalData.slotManager.getProp(data);
                }
                var p;
                if (!data.k.length) {
                  p = new ValueProperty(elem, data, mult, container);
                } else if (typeof data.k[0] === 'number') {
                  p = new MultiDimensionalProperty(elem, data, mult, container);
                } else {
                  switch (type) {
                    case 0:
                      p = new KeyframedValueProperty(elem, data, mult, container);
                      break;
                    case 1:
                      p = new KeyframedMultidimensionalProperty(elem, data, mult, container);
                      break;
                  }
                }
                if (p.effectsSequence.length) {
                  container.addDynamicProperty(p);
                }
                return p;
              }
              var ob = {
                getProp: getProp
              };
              return ob;
            }();
            function DynamicPropertyContainer() {}
            DynamicPropertyContainer.prototype = {
              addDynamicProperty: function addDynamicProperty(prop) {
                if (this.dynamicProperties.indexOf(prop) === -1) {
                  this.dynamicProperties.push(prop);
                  this.container.addDynamicProperty(this);
                  this._isAnimated = true;
                }
              },
              iterateDynamicProperties: function iterateDynamicProperties() {
                this._mdf = false;
                var i;
                var len = this.dynamicProperties.length;
                for (i = 0; i < len; i += 1) {
                  this.dynamicProperties[i].getValue();
                  if (this.dynamicProperties[i]._mdf) {
                    this._mdf = true;
                  }
                }
              },
              initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {
                this.container = container;
                this.dynamicProperties = [];
                this._mdf = false;
                this._isAnimated = false;
              }
            };
            var pointPool = function () {
              function create() {
                return createTypedArray('float32', 2);
              }
              return poolFactory(8, create);
            }();
            function ShapePath() {
              this.c = false;
              this._length = 0;
              this._maxLength = 8;
              this.v = createSizedArray(this._maxLength);
              this.o = createSizedArray(this._maxLength);
              this.i = createSizedArray(this._maxLength);
            }
            ShapePath.prototype.setPathData = function (closed, len) {
              this.c = closed;
              this.setLength(len);
              var i = 0;
              while (i < len) {
                this.v[i] = pointPool.newElement();
                this.o[i] = pointPool.newElement();
                this.i[i] = pointPool.newElement();
                i += 1;
              }
            };
            ShapePath.prototype.setLength = function (len) {
              while (this._maxLength < len) {
                this.doubleArrayLength();
              }
              this._length = len;
            };
            ShapePath.prototype.doubleArrayLength = function () {
              this.v = this.v.concat(createSizedArray(this._maxLength));
              this.i = this.i.concat(createSizedArray(this._maxLength));
              this.o = this.o.concat(createSizedArray(this._maxLength));
              this._maxLength *= 2;
            };
            ShapePath.prototype.setXYAt = function (x, y, type, pos, replace) {
              var arr;
              this._length = Math.max(this._length, pos + 1);
              if (this._length >= this._maxLength) {
                this.doubleArrayLength();
              }
              switch (type) {
                case 'v':
                  arr = this.v;
                  break;
                case 'i':
                  arr = this.i;
                  break;
                case 'o':
                  arr = this.o;
                  break;
                default:
                  arr = [];
                  break;
              }
              if (!arr[pos] || arr[pos] && !replace) {
                arr[pos] = pointPool.newElement();
              }
              arr[pos][0] = x;
              arr[pos][1] = y;
            };
            ShapePath.prototype.setTripleAt = function (vX, vY, oX, oY, iX, iY, pos, replace) {
              this.setXYAt(vX, vY, 'v', pos, replace);
              this.setXYAt(oX, oY, 'o', pos, replace);
              this.setXYAt(iX, iY, 'i', pos, replace);
            };
            ShapePath.prototype.reverse = function () {
              var newPath = new ShapePath();
              newPath.setPathData(this.c, this._length);
              var vertices = this.v;
              var outPoints = this.o;
              var inPoints = this.i;
              var init = 0;
              if (this.c) {
                newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
                init = 1;
              }
              var cnt = this._length - 1;
              var len = this._length;
              var i;
              for (i = init; i < len; i += 1) {
                newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
                cnt -= 1;
              }
              return newPath;
            };
            ShapePath.prototype.length = function () {
              return this._length;
            };
            var shapePool = function () {
              function create() {
                return new ShapePath();
              }
              function release(shapePath) {
                var len = shapePath._length;
                var i;
                for (i = 0; i < len; i += 1) {
                  pointPool.release(shapePath.v[i]);
                  pointPool.release(shapePath.i[i]);
                  pointPool.release(shapePath.o[i]);
                  shapePath.v[i] = null;
                  shapePath.i[i] = null;
                  shapePath.o[i] = null;
                }
                shapePath._length = 0;
                shapePath.c = false;
              }
              function clone(shape) {
                var cloned = factory.newElement();
                var i;
                var len = shape._length === undefined ? shape.v.length : shape._length;
                cloned.setLength(len);
                cloned.c = shape.c;
                for (i = 0; i < len; i += 1) {
                  cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);
                }
                return cloned;
              }
              var factory = poolFactory(4, create, release);
              factory.clone = clone;
              return factory;
            }();
            function ShapeCollection() {
              this._length = 0;
              this._maxLength = 4;
              this.shapes = createSizedArray(this._maxLength);
            }
            ShapeCollection.prototype.addShape = function (shapeData) {
              if (this._length === this._maxLength) {
                this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
                this._maxLength *= 2;
              }
              this.shapes[this._length] = shapeData;
              this._length += 1;
            };
            ShapeCollection.prototype.releaseShapes = function () {
              var i;
              for (i = 0; i < this._length; i += 1) {
                shapePool.release(this.shapes[i]);
              }
              this._length = 0;
            };
            var shapeCollectionPool = function () {
              var ob = {
                newShapeCollection: newShapeCollection,
                release: release
              };
              var _length = 0;
              var _maxLength = 4;
              var pool = createSizedArray(_maxLength);
              function newShapeCollection() {
                var shapeCollection;
                if (_length) {
                  _length -= 1;
                  shapeCollection = pool[_length];
                } else {
                  shapeCollection = new ShapeCollection();
                }
                return shapeCollection;
              }
              function release(shapeCollection) {
                var i;
                var len = shapeCollection._length;
                for (i = 0; i < len; i += 1) {
                  shapePool.release(shapeCollection.shapes[i]);
                }
                shapeCollection._length = 0;
                if (_length === _maxLength) {
                  pool = pooling["double"](pool);
                  _maxLength *= 2;
                }
                pool[_length] = shapeCollection;
                _length += 1;
              }
              return ob;
            }();
            var ShapePropertyFactory = function () {
              var initFrame = -999999;
              function interpolateShape(frameNum, previousValue, caching) {
                var iterationIndex = caching.lastIndex;
                var keyPropS;
                var keyPropE;
                var isHold;
                var j;
                var k;
                var jLen;
                var kLen;
                var perc;
                var vertexValue;
                var kf = this.keyframes;
                if (frameNum < kf[0].t - this.offsetTime) {
                  keyPropS = kf[0].s[0];
                  isHold = true;
                  iterationIndex = 0;
                } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
                  keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
                  /* if(kf[kf.length - 1].s){
                            keyPropS = kf[kf.length - 1].s[0];
                        }else{
                            keyPropS = kf[kf.length - 2].e[0];
                        } */

                  isHold = true;
                } else {
                  var i = iterationIndex;
                  var len = kf.length - 1;
                  var flag = true;
                  var keyData;
                  var nextKeyData;
                  var keyframeMetadata;
                  while (flag) {
                    keyData = kf[i];
                    nextKeyData = kf[i + 1];
                    if (nextKeyData.t - this.offsetTime > frameNum) {
                      break;
                    }
                    if (i < len - 1) {
                      i += 1;
                    } else {
                      flag = false;
                    }
                  }
                  keyframeMetadata = this.keyframesMetadata[i] || {};
                  isHold = keyData.h === 1;
                  iterationIndex = i;
                  if (!isHold) {
                    if (frameNum >= nextKeyData.t - this.offsetTime) {
                      perc = 1;
                    } else if (frameNum < keyData.t - this.offsetTime) {
                      perc = 0;
                    } else {
                      var fnc;
                      if (keyframeMetadata.__fnct) {
                        fnc = keyframeMetadata.__fnct;
                      } else {
                        fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
                        keyframeMetadata.__fnct = fnc;
                      }
                      perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
                    }
                    keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
                  }
                  keyPropS = keyData.s[0];
                }
                jLen = previousValue._length;
                kLen = keyPropS.i[0].length;
                caching.lastIndex = iterationIndex;
                for (j = 0; j < jLen; j += 1) {
                  for (k = 0; k < kLen; k += 1) {
                    vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
                    previousValue.i[j][k] = vertexValue;
                    vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
                    previousValue.o[j][k] = vertexValue;
                    vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
                    previousValue.v[j][k] = vertexValue;
                  }
                }
              }
              function interpolateShapeCurrentTime() {
                var frameNum = this.comp.renderedFrame - this.offsetTime;
                var initTime = this.keyframes[0].t - this.offsetTime;
                var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
                var lastFrame = this._caching.lastFrame;
                if (!(lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
                  /// /
                  this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
                  this.interpolateShape(frameNum, this.pv, this._caching); /// /
                }
                this._caching.lastFrame = frameNum;
                return this.pv;
              }
              function resetShape() {
                this.paths = this.localShapeCollection;
              }
              function shapesEqual(shape1, shape2) {
                if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
                  return false;
                }
                var i;
                var len = shape1._length;
                for (i = 0; i < len; i += 1) {
                  if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) {
                    return false;
                  }
                }
                return true;
              }
              function setVValue(newPath) {
                if (!shapesEqual(this.v, newPath)) {
                  this.v = shapePool.clone(newPath);
                  this.localShapeCollection.releaseShapes();
                  this.localShapeCollection.addShape(this.v);
                  this._mdf = true;
                  this.paths = this.localShapeCollection;
                }
              }
              function processEffectsSequence() {
                if (this.elem.globalData.frameId === this.frameId) {
                  return;
                }
                if (!this.effectsSequence.length) {
                  this._mdf = false;
                  return;
                }
                if (this.lock) {
                  this.setVValue(this.pv);
                  return;
                }
                this.lock = true;
                this._mdf = false;
                var finalValue;
                if (this.kf) {
                  finalValue = this.pv;
                } else if (this.data.ks) {
                  finalValue = this.data.ks.k;
                } else {
                  finalValue = this.data.pt.k;
                }
                var i;
                var len = this.effectsSequence.length;
                for (i = 0; i < len; i += 1) {
                  finalValue = this.effectsSequence[i](finalValue);
                }
                this.setVValue(finalValue);
                this.lock = false;
                this.frameId = this.elem.globalData.frameId;
              }
              function ShapeProperty(elem, data, type) {
                this.propType = 'shape';
                this.comp = elem.comp;
                this.container = elem;
                this.elem = elem;
                this.data = data;
                this.k = false;
                this.kf = false;
                this._mdf = false;
                var pathData = type === 3 ? data.pt.k : data.ks.k;
                this.v = shapePool.clone(pathData);
                this.pv = shapePool.clone(this.v);
                this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                this.paths = this.localShapeCollection;
                this.paths.addShape(this.v);
                this.reset = resetShape;
                this.effectsSequence = [];
              }
              function addEffect(effectFunction) {
                this.effectsSequence.push(effectFunction);
                this.container.addDynamicProperty(this);
              }
              ShapeProperty.prototype.interpolateShape = interpolateShape;
              ShapeProperty.prototype.getValue = processEffectsSequence;
              ShapeProperty.prototype.setVValue = setVValue;
              ShapeProperty.prototype.addEffect = addEffect;
              function KeyframedShapeProperty(elem, data, type) {
                this.propType = 'shape';
                this.comp = elem.comp;
                this.elem = elem;
                this.container = elem;
                this.offsetTime = elem.data.st;
                this.keyframes = type === 3 ? data.pt.k : data.ks.k;
                this.keyframesMetadata = [];
                this.k = true;
                this.kf = true;
                var len = this.keyframes[0].s[0].i.length;
                this.v = shapePool.newElement();
                this.v.setPathData(this.keyframes[0].s[0].c, len);
                this.pv = shapePool.clone(this.v);
                this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                this.paths = this.localShapeCollection;
                this.paths.addShape(this.v);
                this.lastFrame = initFrame;
                this.reset = resetShape;
                this._caching = {
                  lastFrame: initFrame,
                  lastIndex: 0
                };
                this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
              }
              KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
              KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
              KeyframedShapeProperty.prototype.setVValue = setVValue;
              KeyframedShapeProperty.prototype.addEffect = addEffect;
              var EllShapeProperty = function () {
                var cPoint = roundCorner;
                function EllShapePropertyFactory(elem, data) {
                  this.v = shapePool.newElement();
                  this.v.setPathData(true, 4);
                  this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                  this.paths = this.localShapeCollection;
                  this.localShapeCollection.addShape(this.v);
                  this.d = data.d;
                  this.elem = elem;
                  this.comp = elem.comp;
                  this.frameId = -1;
                  this.initDynamicPropertyContainer(elem);
                  this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
                  this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
                  if (this.dynamicProperties.length) {
                    this.k = true;
                  } else {
                    this.k = false;
                    this.convertEllToPath();
                  }
                }
                EllShapePropertyFactory.prototype = {
                  reset: resetShape,
                  getValue: function getValue() {
                    if (this.elem.globalData.frameId === this.frameId) {
                      return;
                    }
                    this.frameId = this.elem.globalData.frameId;
                    this.iterateDynamicProperties();
                    if (this._mdf) {
                      this.convertEllToPath();
                    }
                  },
                  convertEllToPath: function convertEllToPath() {
                    var p0 = this.p.v[0];
                    var p1 = this.p.v[1];
                    var s0 = this.s.v[0] / 2;
                    var s1 = this.s.v[1] / 2;
                    var _cw = this.d !== 3;
                    var _v = this.v;
                    _v.v[0][0] = p0;
                    _v.v[0][1] = p1 - s1;
                    _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
                    _v.v[1][1] = p1;
                    _v.v[2][0] = p0;
                    _v.v[2][1] = p1 + s1;
                    _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
                    _v.v[3][1] = p1;
                    _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                    _v.i[0][1] = p1 - s1;
                    _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
                    _v.i[1][1] = p1 - s1 * cPoint;
                    _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                    _v.i[2][1] = p1 + s1;
                    _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
                    _v.i[3][1] = p1 + s1 * cPoint;
                    _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                    _v.o[0][1] = p1 - s1;
                    _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
                    _v.o[1][1] = p1 + s1 * cPoint;
                    _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                    _v.o[2][1] = p1 + s1;
                    _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
                    _v.o[3][1] = p1 - s1 * cPoint;
                  }
                };
                extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);
                return EllShapePropertyFactory;
              }();
              var StarShapeProperty = function () {
                function StarShapePropertyFactory(elem, data) {
                  this.v = shapePool.newElement();
                  this.v.setPathData(true, 0);
                  this.elem = elem;
                  this.comp = elem.comp;
                  this.data = data;
                  this.frameId = -1;
                  this.d = data.d;
                  this.initDynamicPropertyContainer(elem);
                  if (data.sy === 1) {
                    this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);
                    this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);
                    this.convertToPath = this.convertStarToPath;
                  } else {
                    this.convertToPath = this.convertPolygonToPath;
                  }
                  this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);
                  this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
                  this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);
                  this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);
                  this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);
                  this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                  this.localShapeCollection.addShape(this.v);
                  this.paths = this.localShapeCollection;
                  if (this.dynamicProperties.length) {
                    this.k = true;
                  } else {
                    this.k = false;
                    this.convertToPath();
                  }
                }
                StarShapePropertyFactory.prototype = {
                  reset: resetShape,
                  getValue: function getValue() {
                    if (this.elem.globalData.frameId === this.frameId) {
                      return;
                    }
                    this.frameId = this.elem.globalData.frameId;
                    this.iterateDynamicProperties();
                    if (this._mdf) {
                      this.convertToPath();
                    }
                  },
                  convertStarToPath: function convertStarToPath() {
                    var numPts = Math.floor(this.pt.v) * 2;
                    var angle = Math.PI * 2 / numPts;
                    /* this.v.v.length = numPts;
                            this.v.i.length = numPts;
                            this.v.o.length = numPts; */

                    var longFlag = true;
                    var longRad = this.or.v;
                    var shortRad = this.ir.v;
                    var longRound = this.os.v;
                    var shortRound = this.is.v;
                    var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
                    var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
                    var i;
                    var rad;
                    var roundness;
                    var perimSegment;
                    var currentAng = -Math.PI / 2;
                    currentAng += this.r.v;
                    var dir = this.data.d === 3 ? -1 : 1;
                    this.v._length = 0;
                    for (i = 0; i < numPts; i += 1) {
                      rad = longFlag ? longRad : shortRad;
                      roundness = longFlag ? longRound : shortRound;
                      perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
                      var x = rad * Math.cos(currentAng);
                      var y = rad * Math.sin(currentAng);
                      var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                      var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                      x += +this.p.v[0];
                      y += +this.p.v[1];
                      this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
                      /* this.v.v[i] = [x,y];
                                this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
                                this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
                                this.v._length = numPts; */

                      longFlag = !longFlag;
                      currentAng += angle * dir;
                    }
                  },
                  convertPolygonToPath: function convertPolygonToPath() {
                    var numPts = Math.floor(this.pt.v);
                    var angle = Math.PI * 2 / numPts;
                    var rad = this.or.v;
                    var roundness = this.os.v;
                    var perimSegment = 2 * Math.PI * rad / (numPts * 4);
                    var i;
                    var currentAng = -Math.PI * 0.5;
                    var dir = this.data.d === 3 ? -1 : 1;
                    currentAng += this.r.v;
                    this.v._length = 0;
                    for (i = 0; i < numPts; i += 1) {
                      var x = rad * Math.cos(currentAng);
                      var y = rad * Math.sin(currentAng);
                      var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                      var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                      x += +this.p.v[0];
                      y += +this.p.v[1];
                      this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
                      currentAng += angle * dir;
                    }
                    this.paths.length = 0;
                    this.paths[0] = this.v;
                  }
                };
                extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);
                return StarShapePropertyFactory;
              }();
              var RectShapeProperty = function () {
                function RectShapePropertyFactory(elem, data) {
                  this.v = shapePool.newElement();
                  this.v.c = true;
                  this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                  this.localShapeCollection.addShape(this.v);
                  this.paths = this.localShapeCollection;
                  this.elem = elem;
                  this.comp = elem.comp;
                  this.frameId = -1;
                  this.d = data.d;
                  this.initDynamicPropertyContainer(elem);
                  this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
                  this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
                  this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);
                  if (this.dynamicProperties.length) {
                    this.k = true;
                  } else {
                    this.k = false;
                    this.convertRectToPath();
                  }
                }
                RectShapePropertyFactory.prototype = {
                  convertRectToPath: function convertRectToPath() {
                    var p0 = this.p.v[0];
                    var p1 = this.p.v[1];
                    var v0 = this.s.v[0] / 2;
                    var v1 = this.s.v[1] / 2;
                    var round = bmMin(v0, v1, this.r.v);
                    var cPoint = round * (1 - roundCorner);
                    this.v._length = 0;
                    if (this.d === 2 || this.d === 1) {
                      this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
                      this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
                      if (round !== 0) {
                        this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
                        this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
                        this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
                        this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
                        this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
                        this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
                      } else {
                        this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
                        this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
                      }
                    } else {
                      this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
                      if (round !== 0) {
                        this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
                        this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
                        this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
                        this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
                        this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
                        this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
                        this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
                      } else {
                        this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
                        this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
                        this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
                      }
                    }
                  },
                  getValue: function getValue() {
                    if (this.elem.globalData.frameId === this.frameId) {
                      return;
                    }
                    this.frameId = this.elem.globalData.frameId;
                    this.iterateDynamicProperties();
                    if (this._mdf) {
                      this.convertRectToPath();
                    }
                  },
                  reset: resetShape
                };
                extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);
                return RectShapePropertyFactory;
              }();
              function getShapeProp(elem, data, type) {
                var prop;
                if (type === 3 || type === 4) {
                  var dataProp = type === 3 ? data.pt : data.ks;
                  var keys = dataProp.k;
                  if (keys.length) {
                    prop = new KeyframedShapeProperty(elem, data, type);
                  } else {
                    prop = new ShapeProperty(elem, data, type);
                  }
                } else if (type === 5) {
                  prop = new RectShapeProperty(elem, data);
                } else if (type === 6) {
                  prop = new EllShapeProperty(elem, data);
                } else if (type === 7) {
                  prop = new StarShapeProperty(elem, data);
                }
                if (prop.k) {
                  elem.addDynamicProperty(prop);
                }
                return prop;
              }
              function getConstructorFunction() {
                return ShapeProperty;
              }
              function getKeyframedConstructorFunction() {
                return KeyframedShapeProperty;
              }
              var ob = {};
              ob.getShapeProp = getShapeProp;
              ob.getConstructorFunction = getConstructorFunction;
              ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
              return ob;
            }();

            /*!
             Transformation Matrix v2.0
             (c) Epistemex 2014-2015
             www.epistemex.com
             By Ken Fyrstenberg
             Contributions by leeoniya.
             License: MIT, header required.
             */

            /**
             * 2D transformation matrix object initialized with identity matrix.
             *
             * The matrix can synchronize a canvas context by supplying the context
             * as an argument, or later apply current absolute transform to an
             * existing context.
             *
             * All values are handled as floating point values.
             *
             * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
             * @prop {number} a - scale x
             * @prop {number} b - shear y
             * @prop {number} c - shear x
             * @prop {number} d - scale y
             * @prop {number} e - translate x
             * @prop {number} f - translate y
             * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
             * @constructor
             */

            var Matrix = function () {
              var _cos = Math.cos;
              var _sin = Math.sin;
              var _tan = Math.tan;
              var _rnd = Math.round;
              function reset() {
                this.props[0] = 1;
                this.props[1] = 0;
                this.props[2] = 0;
                this.props[3] = 0;
                this.props[4] = 0;
                this.props[5] = 1;
                this.props[6] = 0;
                this.props[7] = 0;
                this.props[8] = 0;
                this.props[9] = 0;
                this.props[10] = 1;
                this.props[11] = 0;
                this.props[12] = 0;
                this.props[13] = 0;
                this.props[14] = 0;
                this.props[15] = 1;
                return this;
              }
              function rotate(angle) {
                if (angle === 0) {
                  return this;
                }
                var mCos = _cos(angle);
                var mSin = _sin(angle);
                return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
              }
              function rotateX(angle) {
                if (angle === 0) {
                  return this;
                }
                var mCos = _cos(angle);
                var mSin = _sin(angle);
                return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
              }
              function rotateY(angle) {
                if (angle === 0) {
                  return this;
                }
                var mCos = _cos(angle);
                var mSin = _sin(angle);
                return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
              }
              function rotateZ(angle) {
                if (angle === 0) {
                  return this;
                }
                var mCos = _cos(angle);
                var mSin = _sin(angle);
                return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
              }
              function shear(sx, sy) {
                return this._t(1, sy, sx, 1, 0, 0);
              }
              function skew(ax, ay) {
                return this.shear(_tan(ax), _tan(ay));
              }
              function skewFromAxis(ax, angle) {
                var mCos = _cos(angle);
                var mSin = _sin(angle);
                return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
              }
              function scale(sx, sy, sz) {
                if (!sz && sz !== 0) {
                  sz = 1;
                }
                if (sx === 1 && sy === 1 && sz === 1) {
                  return this;
                }
                return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
              }
              function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
                this.props[0] = a;
                this.props[1] = b;
                this.props[2] = c;
                this.props[3] = d;
                this.props[4] = e;
                this.props[5] = f;
                this.props[6] = g;
                this.props[7] = h;
                this.props[8] = i;
                this.props[9] = j;
                this.props[10] = k;
                this.props[11] = l;
                this.props[12] = m;
                this.props[13] = n;
                this.props[14] = o;
                this.props[15] = p;
                return this;
              }
              function translate(tx, ty, tz) {
                tz = tz || 0;
                if (tx !== 0 || ty !== 0 || tz !== 0) {
                  return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
                }
                return this;
              }
              function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
                var _p = this.props;
                if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
                  // NOTE: commenting this condition because TurboFan deoptimizes code when present
                  // if(m2 !== 0 || n2 !== 0 || o2 !== 0){
                  _p[12] = _p[12] * a2 + _p[15] * m2;
                  _p[13] = _p[13] * f2 + _p[15] * n2;
                  _p[14] = _p[14] * k2 + _p[15] * o2;
                  _p[15] *= p2; // }

                  this._identityCalculated = false;
                  return this;
                }
                var a1 = _p[0];
                var b1 = _p[1];
                var c1 = _p[2];
                var d1 = _p[3];
                var e1 = _p[4];
                var f1 = _p[5];
                var g1 = _p[6];
                var h1 = _p[7];
                var i1 = _p[8];
                var j1 = _p[9];
                var k1 = _p[10];
                var l1 = _p[11];
                var m1 = _p[12];
                var n1 = _p[13];
                var o1 = _p[14];
                var p1 = _p[15];
                /* matrix order (canvas compatible):
                     * ace
                     * bdf
                     * 001
                     */

                _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
                _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
                _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
                _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;
                _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
                _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
                _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
                _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;
                _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
                _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
                _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
                _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;
                _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
                _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
                _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
                _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;
                this._identityCalculated = false;
                return this;
              }
              function multiply(matrix) {
                var matrixProps = matrix.props;
                return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);
              }
              function isIdentity() {
                if (!this._identityCalculated) {
                  this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
                  this._identityCalculated = true;
                }
                return this._identity;
              }
              function equals(matr) {
                var i = 0;
                while (i < 16) {
                  if (matr.props[i] !== this.props[i]) {
                    return false;
                  }
                  i += 1;
                }
                return true;
              }
              function clone(matr) {
                var i;
                for (i = 0; i < 16; i += 1) {
                  matr.props[i] = this.props[i];
                }
                return matr;
              }
              function cloneFromProps(props) {
                var i;
                for (i = 0; i < 16; i += 1) {
                  this.props[i] = props[i];
                }
              }
              function applyToPoint(x, y, z) {
                return {
                  x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
                  y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
                  z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
                };
                /* return {
                     x: x * me.a + y * me.c + me.e,
                     y: x * me.b + y * me.d + me.f
                     }; */
              }
              function applyToX(x, y, z) {
                return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
              }
              function applyToY(x, y, z) {
                return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
              }
              function applyToZ(x, y, z) {
                return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
              }
              function getInverseMatrix() {
                var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
                var a = this.props[5] / determinant;
                var b = -this.props[1] / determinant;
                var c = -this.props[4] / determinant;
                var d = this.props[0] / determinant;
                var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
                var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
                var inverseMatrix = new Matrix();
                inverseMatrix.props[0] = a;
                inverseMatrix.props[1] = b;
                inverseMatrix.props[4] = c;
                inverseMatrix.props[5] = d;
                inverseMatrix.props[12] = e;
                inverseMatrix.props[13] = f;
                return inverseMatrix;
              }
              function inversePoint(pt) {
                var inverseMatrix = this.getInverseMatrix();
                return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
              }
              function inversePoints(pts) {
                var i;
                var len = pts.length;
                var retPts = [];
                for (i = 0; i < len; i += 1) {
                  retPts[i] = inversePoint(pts[i]);
                }
                return retPts;
              }
              function applyToTriplePoints(pt1, pt2, pt3) {
                var arr = createTypedArray('float32', 6);
                if (this.isIdentity()) {
                  arr[0] = pt1[0];
                  arr[1] = pt1[1];
                  arr[2] = pt2[0];
                  arr[3] = pt2[1];
                  arr[4] = pt3[0];
                  arr[5] = pt3[1];
                } else {
                  var p0 = this.props[0];
                  var p1 = this.props[1];
                  var p4 = this.props[4];
                  var p5 = this.props[5];
                  var p12 = this.props[12];
                  var p13 = this.props[13];
                  arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
                  arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
                  arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
                  arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
                  arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
                  arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
                }
                return arr;
              }
              function applyToPointArray(x, y, z) {
                var arr;
                if (this.isIdentity()) {
                  arr = [x, y, z];
                } else {
                  arr = [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12], x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13], x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];
                }
                return arr;
              }
              function applyToPointStringified(x, y) {
                if (this.isIdentity()) {
                  return x + ',' + y;
                }
                var _p = this.props;
                return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + ',' + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
              }
              function toCSS() {
                // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.

                /* if(this.isIdentity()) {
                        return '';
                    } */
                var i = 0;
                var props = this.props;
                var cssValue = 'matrix3d(';
                var v = 10000;
                while (i < 16) {
                  cssValue += _rnd(props[i] * v) / v;
                  cssValue += i === 15 ? ')' : ',';
                  i += 1;
                }
                return cssValue;
              }
              function roundMatrixProperty(val) {
                var v = 10000;
                if (val < 0.000001 && val > 0 || val > -0.000001 && val < 0) {
                  return _rnd(val * v) / v;
                }
                return val;
              }
              function to2dCSS() {
                // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.

                /* if(this.isIdentity()) {
                        return '';
                    } */
                var props = this.props;
                var _a = roundMatrixProperty(props[0]);
                var _b = roundMatrixProperty(props[1]);
                var _c = roundMatrixProperty(props[4]);
                var _d = roundMatrixProperty(props[5]);
                var _e = roundMatrixProperty(props[12]);
                var _f = roundMatrixProperty(props[13]);
                return 'matrix(' + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ')';
              }
              return function () {
                this.reset = reset;
                this.rotate = rotate;
                this.rotateX = rotateX;
                this.rotateY = rotateY;
                this.rotateZ = rotateZ;
                this.skew = skew;
                this.skewFromAxis = skewFromAxis;
                this.shear = shear;
                this.scale = scale;
                this.setTransform = setTransform;
                this.translate = translate;
                this.transform = transform;
                this.multiply = multiply;
                this.applyToPoint = applyToPoint;
                this.applyToX = applyToX;
                this.applyToY = applyToY;
                this.applyToZ = applyToZ;
                this.applyToPointArray = applyToPointArray;
                this.applyToTriplePoints = applyToTriplePoints;
                this.applyToPointStringified = applyToPointStringified;
                this.toCSS = toCSS;
                this.to2dCSS = to2dCSS;
                this.clone = clone;
                this.cloneFromProps = cloneFromProps;
                this.equals = equals;
                this.inversePoints = inversePoints;
                this.inversePoint = inversePoint;
                this.getInverseMatrix = getInverseMatrix;
                this._t = this.transform;
                this.isIdentity = isIdentity;
                this._identity = true;
                this._identityCalculated = false;
                this.props = createTypedArray('float32', 16);
                this.reset();
              };
            }();
            function _typeof$3(obj) {
              "@babel/helpers - typeof";

              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof$3 = function _typeof(obj) {
                  return typeof obj;
                };
              } else {
                _typeof$3 = function _typeof(obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
              }
              return _typeof$3(obj);
            }
            var lottie = {};
            function setLocation(href) {
              setLocationHref(href);
            }
            function searchAnimations() {
              {
                animationManager.searchAnimations();
              }
            }
            function setSubframeRendering(flag) {
              setSubframeEnabled(flag);
            }
            function setPrefix(prefix) {
              setIdPrefix(prefix);
            }
            function loadAnimation(params) {
              return animationManager.loadAnimation(params);
            }
            function setQuality(value) {
              if (typeof value === 'string') {
                switch (value) {
                  case 'high':
                    setDefaultCurveSegments(200);
                    break;
                  default:
                  case 'medium':
                    setDefaultCurveSegments(50);
                    break;
                  case 'low':
                    setDefaultCurveSegments(10);
                    break;
                }
              } else if (!isNaN(value) && value > 1) {
                setDefaultCurveSegments(value);
              }
            }
            function inBrowser() {
              return typeof navigator !== 'undefined';
            }
            function installPlugin(type, plugin) {
              if (type === 'expressions') {
                setExpressionsPlugin(plugin);
              }
            }
            function getFactory(name) {
              switch (name) {
                case 'propertyFactory':
                  return PropertyFactory;
                case 'shapePropertyFactory':
                  return ShapePropertyFactory;
                case 'matrix':
                  return Matrix;
                default:
                  return null;
              }
            }
            lottie.play = animationManager.play;
            lottie.pause = animationManager.pause;
            lottie.setLocationHref = setLocation;
            lottie.togglePause = animationManager.togglePause;
            lottie.setSpeed = animationManager.setSpeed;
            lottie.setDirection = animationManager.setDirection;
            lottie.stop = animationManager.stop;
            lottie.searchAnimations = searchAnimations;
            lottie.registerAnimation = animationManager.registerAnimation;
            lottie.loadAnimation = loadAnimation;
            lottie.setSubframeRendering = setSubframeRendering;
            lottie.resize = animationManager.resize; // lottie.start = start;

            lottie.goToAndStop = animationManager.goToAndStop;
            lottie.destroy = animationManager.destroy;
            lottie.setQuality = setQuality;
            lottie.inBrowser = inBrowser;
            lottie.installPlugin = installPlugin;
            lottie.freeze = animationManager.freeze;
            lottie.unfreeze = animationManager.unfreeze;
            lottie.setVolume = animationManager.setVolume;
            lottie.mute = animationManager.mute;
            lottie.unmute = animationManager.unmute;
            lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
            lottie.useWebWorker = setWebWorker;
            lottie.setIDPrefix = setPrefix;
            lottie.__getFactory = getFactory;
            lottie.version = '5.12.2';
            function checkReady() {
              if (document.readyState === 'complete') {
                clearInterval(readyStateCheckInterval);
                searchAnimations();
              }
            }
            function getQueryVariable(variable) {
              var vars = queryString.split('&');
              for (var i = 0; i < vars.length; i += 1) {
                var pair = vars[i].split('=');
                if (decodeURIComponent(pair[0]) == variable) {
                  // eslint-disable-line eqeqeq
                  return decodeURIComponent(pair[1]);
                }
              }
              return null;
            }
            var queryString = '';
            {
              var scripts = document.getElementsByTagName('script');
              var index = scripts.length - 1;
              var myScript = scripts[index] || {
                src: ''
              };
              queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, '') : ''; // eslint-disable-line no-useless-escape

              getQueryVariable('renderer');
            }
            var readyStateCheckInterval = setInterval(checkReady, 100); // this adds bodymovin to the window object for backwards compatibility

            try {
              if (!(('object' === "undefined" ? "undefined" : _typeof$3(exports)) === 'object' && 'object' !== 'undefined') && !(typeof undefined === 'function' && undefined.amd) // eslint-disable-line no-undef
              ) {
                window.bodymovin = lottie;
              }
            } catch (err) {//
            }
            var ShapeModifiers = function () {
              var ob = {};
              var modifiers = {};
              ob.registerModifier = registerModifier;
              ob.getModifier = getModifier;
              function registerModifier(nm, factory) {
                if (!modifiers[nm]) {
                  modifiers[nm] = factory;
                }
              }
              function getModifier(nm, elem, data) {
                return new modifiers[nm](elem, data);
              }
              return ob;
            }();
            function ShapeModifier() {}
            ShapeModifier.prototype.initModifierProperties = function () {};
            ShapeModifier.prototype.addShapeToModifier = function () {};
            ShapeModifier.prototype.addShape = function (data) {
              if (!this.closed) {
                // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.
                data.sh.container.addDynamicProperty(data.sh);
                var shapeData = {
                  shape: data.sh,
                  data: data,
                  localShapeCollection: shapeCollectionPool.newShapeCollection()
                };
                this.shapes.push(shapeData);
                this.addShapeToModifier(shapeData);
                if (this._isAnimated) {
                  data.setAsAnimated();
                }
              }
            };
            ShapeModifier.prototype.init = function (elem, data) {
              this.shapes = [];
              this.elem = elem;
              this.initDynamicPropertyContainer(elem);
              this.initModifierProperties(elem, data);
              this.frameId = initialDefaultFrame;
              this.closed = false;
              this.k = false;
              if (this.dynamicProperties.length) {
                this.k = true;
              } else {
                this.getValue(true);
              }
            };
            ShapeModifier.prototype.processKeys = function () {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }
              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();
            };
            extendPrototype([DynamicPropertyContainer], ShapeModifier);
            function TrimModifier() {}
            extendPrototype([ShapeModifier], TrimModifier);
            TrimModifier.prototype.initModifierProperties = function (elem, data) {
              this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
              this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
              this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
              this.sValue = 0;
              this.eValue = 0;
              this.getValue = this.processKeys;
              this.m = data.m;
              this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
            };
            TrimModifier.prototype.addShapeToModifier = function (shapeData) {
              shapeData.pathsData = [];
            };
            TrimModifier.prototype.calculateShapeEdges = function (s, e, shapeLength, addedLength, totalModifierLength) {
              var segments = [];
              if (e <= 1) {
                segments.push({
                  s: s,
                  e: e
                });
              } else if (s >= 1) {
                segments.push({
                  s: s - 1,
                  e: e - 1
                });
              } else {
                segments.push({
                  s: s,
                  e: 1
                });
                segments.push({
                  s: 0,
                  e: e - 1
                });
              }
              var shapeSegments = [];
              var i;
              var len = segments.length;
              var segmentOb;
              for (i = 0; i < len; i += 1) {
                segmentOb = segments[i];
                if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
                  var shapeS;
                  var shapeE;
                  if (segmentOb.s * totalModifierLength <= addedLength) {
                    shapeS = 0;
                  } else {
                    shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
                  }
                  if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
                    shapeE = 1;
                  } else {
                    shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
                  }
                  shapeSegments.push([shapeS, shapeE]);
                }
              }
              if (!shapeSegments.length) {
                shapeSegments.push([0, 0]);
              }
              return shapeSegments;
            };
            TrimModifier.prototype.releasePathsData = function (pathsData) {
              var i;
              var len = pathsData.length;
              for (i = 0; i < len; i += 1) {
                segmentsLengthPool.release(pathsData[i]);
              }
              pathsData.length = 0;
              return pathsData;
            };
            TrimModifier.prototype.processShapes = function (_isFirstFrame) {
              var s;
              var e;
              if (this._mdf || _isFirstFrame) {
                var o = this.o.v % 360 / 360;
                if (o < 0) {
                  o += 1;
                }
                if (this.s.v > 1) {
                  s = 1 + o;
                } else if (this.s.v < 0) {
                  s = 0 + o;
                } else {
                  s = this.s.v + o;
                }
                if (this.e.v > 1) {
                  e = 1 + o;
                } else if (this.e.v < 0) {
                  e = 0 + o;
                } else {
                  e = this.e.v + o;
                }
                if (s > e) {
                  var _s = s;
                  s = e;
                  e = _s;
                }
                s = Math.round(s * 10000) * 0.0001;
                e = Math.round(e * 10000) * 0.0001;
                this.sValue = s;
                this.eValue = e;
              } else {
                s = this.sValue;
                e = this.eValue;
              }
              var shapePaths;
              var i;
              var len = this.shapes.length;
              var j;
              var jLen;
              var pathsData;
              var pathData;
              var totalShapeLength;
              var totalModifierLength = 0;
              if (e === s) {
                for (i = 0; i < len; i += 1) {
                  this.shapes[i].localShapeCollection.releaseShapes();
                  this.shapes[i].shape._mdf = true;
                  this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
                  if (this._mdf) {
                    this.shapes[i].pathsData.length = 0;
                  }
                }
              } else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {
                var segments = [];
                var shapeData;
                var localShapeCollection;
                for (i = 0; i < len; i += 1) {
                  shapeData = this.shapes[i]; // if shape hasn't changed and trim properties haven't changed, cached previous path can be used

                  if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
                    shapeData.shape.paths = shapeData.localShapeCollection;
                  } else {
                    shapePaths = shapeData.shape.paths;
                    jLen = shapePaths._length;
                    totalShapeLength = 0;
                    if (!shapeData.shape._mdf && shapeData.pathsData.length) {
                      totalShapeLength = shapeData.totalShapeLength;
                    } else {
                      pathsData = this.releasePathsData(shapeData.pathsData);
                      for (j = 0; j < jLen; j += 1) {
                        pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
                        pathsData.push(pathData);
                        totalShapeLength += pathData.totalLength;
                      }
                      shapeData.totalShapeLength = totalShapeLength;
                      shapeData.pathsData = pathsData;
                    }
                    totalModifierLength += totalShapeLength;
                    shapeData.shape._mdf = true;
                  }
                }
                var shapeS = s;
                var shapeE = e;
                var addedLength = 0;
                var edges;
                for (i = len - 1; i >= 0; i -= 1) {
                  shapeData = this.shapes[i];
                  if (shapeData.shape._mdf) {
                    localShapeCollection = shapeData.localShapeCollection;
                    localShapeCollection.releaseShapes(); // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group

                    if (this.m === 2 && len > 1) {
                      edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
                      addedLength += shapeData.totalShapeLength;
                    } else {
                      edges = [[shapeS, shapeE]];
                    }
                    jLen = edges.length;
                    for (j = 0; j < jLen; j += 1) {
                      shapeS = edges[j][0];
                      shapeE = edges[j][1];
                      segments.length = 0;
                      if (shapeE <= 1) {
                        segments.push({
                          s: shapeData.totalShapeLength * shapeS,
                          e: shapeData.totalShapeLength * shapeE
                        });
                      } else if (shapeS >= 1) {
                        segments.push({
                          s: shapeData.totalShapeLength * (shapeS - 1),
                          e: shapeData.totalShapeLength * (shapeE - 1)
                        });
                      } else {
                        segments.push({
                          s: shapeData.totalShapeLength * shapeS,
                          e: shapeData.totalShapeLength
                        });
                        segments.push({
                          s: 0,
                          e: shapeData.totalShapeLength * (shapeE - 1)
                        });
                      }
                      var newShapesData = this.addShapes(shapeData, segments[0]);
                      if (segments[0].s !== segments[0].e) {
                        if (segments.length > 1) {
                          var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
                          if (lastShapeInCollection.c) {
                            var lastShape = newShapesData.pop();
                            this.addPaths(newShapesData, localShapeCollection);
                            newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                          } else {
                            this.addPaths(newShapesData, localShapeCollection);
                            newShapesData = this.addShapes(shapeData, segments[1]);
                          }
                        }
                        this.addPaths(newShapesData, localShapeCollection);
                      }
                    }
                    shapeData.shape.paths = localShapeCollection;
                  }
                }
              } else if (this._mdf) {
                for (i = 0; i < len; i += 1) {
                  // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.
                  // Don't remove this even if it's losing cached info.
                  this.shapes[i].pathsData.length = 0;
                  this.shapes[i].shape._mdf = true;
                }
              }
            };
            TrimModifier.prototype.addPaths = function (newPaths, localShapeCollection) {
              var i;
              var len = newPaths.length;
              for (i = 0; i < len; i += 1) {
                localShapeCollection.addShape(newPaths[i]);
              }
            };
            TrimModifier.prototype.addSegment = function (pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
              shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);
              shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);
              if (newShape) {
                shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);
              }
              shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);
            };
            TrimModifier.prototype.addSegmentFromArray = function (points, shapePath, pos, newShape) {
              shapePath.setXYAt(points[1], points[5], 'o', pos);
              shapePath.setXYAt(points[2], points[6], 'i', pos + 1);
              if (newShape) {
                shapePath.setXYAt(points[0], points[4], 'v', pos);
              }
              shapePath.setXYAt(points[3], points[7], 'v', pos + 1);
            };
            TrimModifier.prototype.addShapes = function (shapeData, shapeSegment, shapePath) {
              var pathsData = shapeData.pathsData;
              var shapePaths = shapeData.shape.paths.shapes;
              var i;
              var len = shapeData.shape.paths._length;
              var j;
              var jLen;
              var addedLength = 0;
              var currentLengthData;
              var segmentCount;
              var lengths;
              var segment;
              var shapes = [];
              var initPos;
              var newShape = true;
              if (!shapePath) {
                shapePath = shapePool.newElement();
                segmentCount = 0;
                initPos = 0;
              } else {
                segmentCount = shapePath._length;
                initPos = shapePath._length;
              }
              shapes.push(shapePath);
              for (i = 0; i < len; i += 1) {
                lengths = pathsData[i].lengths;
                shapePath.c = shapePaths[i].c;
                jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
                for (j = 1; j < jLen; j += 1) {
                  currentLengthData = lengths[j - 1];
                  if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
                    addedLength += currentLengthData.addedLength;
                    shapePath.c = false;
                  } else if (addedLength > shapeSegment.e) {
                    shapePath.c = false;
                    break;
                  } else {
                    if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
                      this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
                      newShape = false;
                    } else {
                      segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
                      this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);

                      newShape = false;
                      shapePath.c = false;
                    }
                    addedLength += currentLengthData.addedLength;
                    segmentCount += 1;
                  }
                }
                if (shapePaths[i].c && lengths.length) {
                  currentLengthData = lengths[j - 1];
                  if (addedLength <= shapeSegment.e) {
                    var segmentLength = lengths[j - 1].addedLength;
                    if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
                      this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
                      newShape = false;
                    } else {
                      segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
                      this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);

                      newShape = false;
                      shapePath.c = false;
                    }
                  } else {
                    shapePath.c = false;
                  }
                  addedLength += currentLengthData.addedLength;
                  segmentCount += 1;
                }
                if (shapePath._length) {
                  shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);
                  shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], 'o', shapePath._length - 1);
                }
                if (addedLength > shapeSegment.e) {
                  break;
                }
                if (i < len - 1) {
                  shapePath = shapePool.newElement();
                  newShape = true;
                  shapes.push(shapePath);
                  segmentCount = 0;
                }
              }
              return shapes;
            };
            function PuckerAndBloatModifier() {}
            extendPrototype([ShapeModifier], PuckerAndBloatModifier);
            PuckerAndBloatModifier.prototype.initModifierProperties = function (elem, data) {
              this.getValue = this.processKeys;
              this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
              this._isAnimated = !!this.amount.effectsSequence.length;
            };
            PuckerAndBloatModifier.prototype.processPath = function (path, amount) {
              var percent = amount / 100;
              var centerPoint = [0, 0];
              var pathLength = path._length;
              var i = 0;
              for (i = 0; i < pathLength; i += 1) {
                centerPoint[0] += path.v[i][0];
                centerPoint[1] += path.v[i][1];
              }
              centerPoint[0] /= pathLength;
              centerPoint[1] /= pathLength;
              var clonedPath = shapePool.newElement();
              clonedPath.c = path.c;
              var vX;
              var vY;
              var oX;
              var oY;
              var iX;
              var iY;
              for (i = 0; i < pathLength; i += 1) {
                vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;
                vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;
                oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;
                oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;
                iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;
                iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;
                clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);
              }
              return clonedPath;
            };
            PuckerAndBloatModifier.prototype.processShapes = function (_isFirstFrame) {
              var shapePaths;
              var i;
              var len = this.shapes.length;
              var j;
              var jLen;
              var amount = this.amount.v;
              if (amount !== 0) {
                var shapeData;
                var localShapeCollection;
                for (i = 0; i < len; i += 1) {
                  shapeData = this.shapes[i];
                  localShapeCollection = shapeData.localShapeCollection;
                  if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                    localShapeCollection.releaseShapes();
                    shapeData.shape._mdf = true;
                    shapePaths = shapeData.shape.paths.shapes;
                    jLen = shapeData.shape.paths._length;
                    for (j = 0; j < jLen; j += 1) {
                      localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
                    }
                  }
                  shapeData.shape.paths = shapeData.localShapeCollection;
                }
              }
              if (!this.dynamicProperties.length) {
                this._mdf = false;
              }
            };
            var TransformPropertyFactory = function () {
              var defaultVector = [0, 0];
              function applyToMatrix(mat) {
                var _mdf = this._mdf;
                this.iterateDynamicProperties();
                this._mdf = this._mdf || _mdf;
                if (this.a) {
                  mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
                }
                if (this.s) {
                  mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
                }
                if (this.sk) {
                  mat.skewFromAxis(-this.sk.v, this.sa.v);
                }
                if (this.r) {
                  mat.rotate(-this.r.v);
                } else {
                  mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
                }
                if (this.data.p.s) {
                  if (this.data.p.z) {
                    mat.translate(this.px.v, this.py.v, -this.pz.v);
                  } else {
                    mat.translate(this.px.v, this.py.v, 0);
                  }
                } else {
                  mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
                }
              }
              function processKeys(forceRender) {
                if (this.elem.globalData.frameId === this.frameId) {
                  return;
                }
                if (this._isDirty) {
                  this.precalculateMatrix();
                  this._isDirty = false;
                }
                this.iterateDynamicProperties();
                if (this._mdf || forceRender) {
                  var frameRate;
                  this.v.cloneFromProps(this.pre.props);
                  if (this.appliedTransformations < 1) {
                    this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
                  }
                  if (this.appliedTransformations < 2) {
                    this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
                  }
                  if (this.sk && this.appliedTransformations < 3) {
                    this.v.skewFromAxis(-this.sk.v, this.sa.v);
                  }
                  if (this.r && this.appliedTransformations < 4) {
                    this.v.rotate(-this.r.v);
                  } else if (!this.r && this.appliedTransformations < 4) {
                    this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
                  }
                  if (this.autoOriented) {
                    var v1;
                    var v2;
                    frameRate = this.elem.globalData.frameRate;
                    if (this.p && this.p.keyframes && this.p.getValueAtTime) {
                      if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
                        v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
                        v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
                      } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                        v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
                        v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
                      } else {
                        v1 = this.p.pv;
                        v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
                      }
                    } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                      v1 = [];
                      v2 = [];
                      var px = this.px;
                      var py = this.py;
                      if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
                        v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
                        v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
                        v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
                        v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
                      } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
                        v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
                        v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
                        v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
                        v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
                      } else {
                        v1 = [px.pv, py.pv];
                        v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
                        v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
                      }
                    } else {
                      v2 = defaultVector;
                      v1 = v2;
                    }
                    this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
                  }
                  if (this.data.p && this.data.p.s) {
                    if (this.data.p.z) {
                      this.v.translate(this.px.v, this.py.v, -this.pz.v);
                    } else {
                      this.v.translate(this.px.v, this.py.v, 0);
                    }
                  } else {
                    this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
                  }
                }
                this.frameId = this.elem.globalData.frameId;
              }
              function precalculateMatrix() {
                this.appliedTransformations = 0;
                this.pre.reset();
                if (!this.a.effectsSequence.length) {
                  this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
                  this.appliedTransformations = 1;
                } else {
                  return;
                }
                if (!this.s.effectsSequence.length) {
                  this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
                  this.appliedTransformations = 2;
                } else {
                  return;
                }
                if (this.sk) {
                  if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
                    this.pre.skewFromAxis(-this.sk.v, this.sa.v);
                    this.appliedTransformations = 3;
                  } else {
                    return;
                  }
                }
                if (this.r) {
                  if (!this.r.effectsSequence.length) {
                    this.pre.rotate(-this.r.v);
                    this.appliedTransformations = 4;
                  }
                } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
                  this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
                  this.appliedTransformations = 4;
                }
              }
              function autoOrient() {//
                // var prevP = this.getValueAtTime();
              }
              function addDynamicProperty(prop) {
                this._addDynamicProperty(prop);
                this.elem.addDynamicProperty(prop);
                this._isDirty = true;
              }
              function TransformProperty(elem, data, container) {
                this.elem = elem;
                this.frameId = -1;
                this.propType = 'transform';
                this.data = data;
                this.v = new Matrix(); // Precalculated matrix with non animated properties

                this.pre = new Matrix();
                this.appliedTransformations = 0;
                this.initDynamicPropertyContainer(container || elem);
                if (data.p && data.p.s) {
                  this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);
                  this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);
                  if (data.p.z) {
                    this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);
                  }
                } else {
                  this.p = PropertyFactory.getProp(elem, data.p || {
                    k: [0, 0, 0]
                  }, 1, 0, this);
                }
                if (data.rx) {
                  this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
                  this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
                  this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);
                  if (data.or.k[0].ti) {
                    var i;
                    var len = data.or.k.length;
                    for (i = 0; i < len; i += 1) {
                      data.or.k[i].to = null;
                      data.or.k[i].ti = null;
                    }
                  }
                  this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this); // sh Indicates it needs to be capped between -180 and 180

                  this.or.sh = true;
                } else {
                  this.r = PropertyFactory.getProp(elem, data.r || {
                    k: 0
                  }, 0, degToRads, this);
                }
                if (data.sk) {
                  this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
                  this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
                }
                this.a = PropertyFactory.getProp(elem, data.a || {
                  k: [0, 0, 0]
                }, 1, 0, this);
                this.s = PropertyFactory.getProp(elem, data.s || {
                  k: [100, 100, 100]
                }, 1, 0.01, this); // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.

                if (data.o) {
                  this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);
                } else {
                  this.o = {
                    _mdf: false,
                    v: 1
                  };
                }
                this._isDirty = true;
                if (!this.dynamicProperties.length) {
                  this.getValue(true);
                }
              }
              TransformProperty.prototype = {
                applyToMatrix: applyToMatrix,
                getValue: processKeys,
                precalculateMatrix: precalculateMatrix,
                autoOrient: autoOrient
              };
              extendPrototype([DynamicPropertyContainer], TransformProperty);
              TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
              TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
              function getTransformProperty(elem, data, container) {
                return new TransformProperty(elem, data, container);
              }
              return {
                getTransformProperty: getTransformProperty
              };
            }();
            function RepeaterModifier() {}
            extendPrototype([ShapeModifier], RepeaterModifier);
            RepeaterModifier.prototype.initModifierProperties = function (elem, data) {
              this.getValue = this.processKeys;
              this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);
              this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);
              this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);
              this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);
              this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);
              this.data = data;
              if (!this.dynamicProperties.length) {
                this.getValue(true);
              }
              this._isAnimated = !!this.dynamicProperties.length;
              this.pMatrix = new Matrix();
              this.rMatrix = new Matrix();
              this.sMatrix = new Matrix();
              this.tMatrix = new Matrix();
              this.matrix = new Matrix();
            };
            RepeaterModifier.prototype.applyTransforms = function (pMatrix, rMatrix, sMatrix, transform, perc, inv) {
              var dir = inv ? -1 : 1;
              var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
              var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
              pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
              rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
              rMatrix.rotate(-transform.r.v * dir * perc);
              rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
              sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
              sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
              sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
            };
            RepeaterModifier.prototype.init = function (elem, arr, pos, elemsData) {
              this.elem = elem;
              this.arr = arr;
              this.pos = pos;
              this.elemsData = elemsData;
              this._currentCopies = 0;
              this._elements = [];
              this._groups = [];
              this.frameId = -1;
              this.initDynamicPropertyContainer(elem);
              this.initModifierProperties(elem, arr[pos]);
              while (pos > 0) {
                pos -= 1; // this._elements.unshift(arr.splice(pos,1)[0]);

                this._elements.unshift(arr[pos]);
              }
              if (this.dynamicProperties.length) {
                this.k = true;
              } else {
                this.getValue(true);
              }
            };
            RepeaterModifier.prototype.resetElements = function (elements) {
              var i;
              var len = elements.length;
              for (i = 0; i < len; i += 1) {
                elements[i]._processed = false;
                if (elements[i].ty === 'gr') {
                  this.resetElements(elements[i].it);
                }
              }
            };
            RepeaterModifier.prototype.cloneElements = function (elements) {
              var newElements = JSON.parse(JSON.stringify(elements));
              this.resetElements(newElements);
              return newElements;
            };
            RepeaterModifier.prototype.changeGroupRender = function (elements, renderFlag) {
              var i;
              var len = elements.length;
              for (i = 0; i < len; i += 1) {
                elements[i]._render = renderFlag;
                if (elements[i].ty === 'gr') {
                  this.changeGroupRender(elements[i].it, renderFlag);
                }
              }
            };
            RepeaterModifier.prototype.processShapes = function (_isFirstFrame) {
              var items;
              var itemsTransform;
              var i;
              var dir;
              var cont;
              var hasReloaded = false;
              if (this._mdf || _isFirstFrame) {
                var copies = Math.ceil(this.c.v);
                if (this._groups.length < copies) {
                  while (this._groups.length < copies) {
                    var group = {
                      it: this.cloneElements(this._elements),
                      ty: 'gr'
                    };
                    group.it.push({
                      a: {
                        a: 0,
                        ix: 1,
                        k: [0, 0]
                      },
                      nm: 'Transform',
                      o: {
                        a: 0,
                        ix: 7,
                        k: 100
                      },
                      p: {
                        a: 0,
                        ix: 2,
                        k: [0, 0]
                      },
                      r: {
                        a: 1,
                        ix: 6,
                        k: [{
                          s: 0,
                          e: 0,
                          t: 0
                        }, {
                          s: 0,
                          e: 0,
                          t: 1
                        }]
                      },
                      s: {
                        a: 0,
                        ix: 3,
                        k: [100, 100]
                      },
                      sa: {
                        a: 0,
                        ix: 5,
                        k: 0
                      },
                      sk: {
                        a: 0,
                        ix: 4,
                        k: 0
                      },
                      ty: 'tr'
                    });
                    this.arr.splice(0, 0, group);
                    this._groups.splice(0, 0, group);
                    this._currentCopies += 1;
                  }
                  this.elem.reloadShapes();
                  hasReloaded = true;
                }
                cont = 0;
                var renderFlag;
                for (i = 0; i <= this._groups.length - 1; i += 1) {
                  renderFlag = cont < copies;
                  this._groups[i]._render = renderFlag;
                  this.changeGroupRender(this._groups[i].it, renderFlag);
                  if (!renderFlag) {
                    var elems = this.elemsData[i].it;
                    var transformData = elems[elems.length - 1];
                    if (transformData.transform.op.v !== 0) {
                      transformData.transform.op._mdf = true;
                      transformData.transform.op.v = 0;
                    } else {
                      transformData.transform.op._mdf = false;
                    }
                  }
                  cont += 1;
                }
                this._currentCopies = copies; /// /

                var offset = this.o.v;
                var offsetModulo = offset % 1;
                var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
                var pProps = this.pMatrix.props;
                var rProps = this.rMatrix.props;
                var sProps = this.sMatrix.props;
                this.pMatrix.reset();
                this.rMatrix.reset();
                this.sMatrix.reset();
                this.tMatrix.reset();
                this.matrix.reset();
                var iteration = 0;
                if (offset > 0) {
                  while (iteration < roundOffset) {
                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                    iteration += 1;
                  }
                  if (offsetModulo) {
                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
                    iteration += offsetModulo;
                  }
                } else if (offset < 0) {
                  while (iteration > roundOffset) {
                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
                    iteration -= 1;
                  }
                  if (offsetModulo) {
                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
                    iteration -= offsetModulo;
                  }
                }
                i = this.data.m === 1 ? 0 : this._currentCopies - 1;
                dir = this.data.m === 1 ? 1 : -1;
                cont = this._currentCopies;
                var j;
                var jLen;
                while (cont) {
                  items = this.elemsData[i].it;
                  itemsTransform = items[items.length - 1].transform.mProps.v.props;
                  jLen = itemsTransform.length;
                  items[items.length - 1].transform.mProps._mdf = true;
                  items[items.length - 1].transform.op._mdf = true;
                  items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));
                  if (iteration !== 0) {
                    if (i !== 0 && dir === 1 || i !== this._currentCopies - 1 && dir === -1) {
                      this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                    }
                    this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
                    this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
                    this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);
                    for (j = 0; j < jLen; j += 1) {
                      itemsTransform[j] = this.matrix.props[j];
                    }
                    this.matrix.reset();
                  } else {
                    this.matrix.reset();
                    for (j = 0; j < jLen; j += 1) {
                      itemsTransform[j] = this.matrix.props[j];
                    }
                  }
                  iteration += 1;
                  cont -= 1;
                  i += dir;
                }
              } else {
                cont = this._currentCopies;
                i = 0;
                dir = 1;
                while (cont) {
                  items = this.elemsData[i].it;
                  itemsTransform = items[items.length - 1].transform.mProps.v.props;
                  items[items.length - 1].transform.mProps._mdf = false;
                  items[items.length - 1].transform.op._mdf = false;
                  cont -= 1;
                  i += dir;
                }
              }
              return hasReloaded;
            };
            RepeaterModifier.prototype.addShape = function () {};
            function RoundCornersModifier() {}
            extendPrototype([ShapeModifier], RoundCornersModifier);
            RoundCornersModifier.prototype.initModifierProperties = function (elem, data) {
              this.getValue = this.processKeys;
              this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);
              this._isAnimated = !!this.rd.effectsSequence.length;
            };
            RoundCornersModifier.prototype.processPath = function (path, round) {
              var clonedPath = shapePool.newElement();
              clonedPath.c = path.c;
              var i;
              var len = path._length;
              var currentV;
              var currentI;
              var currentO;
              var closerV;
              var distance;
              var newPosPerc;
              var index = 0;
              var vX;
              var vY;
              var oX;
              var oY;
              var iX;
              var iY;
              for (i = 0; i < len; i += 1) {
                currentV = path.v[i];
                currentO = path.o[i];
                currentI = path.i[i];
                if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
                  if ((i === 0 || i === len - 1) && !path.c) {
                    clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);
                    /* clonedPath.v[index] = currentV;
                            clonedPath.o[index] = currentO;
                            clonedPath.i[index] = currentI; */

                    index += 1;
                  } else {
                    if (i === 0) {
                      closerV = path.v[len - 1];
                    } else {
                      closerV = path.v[i - 1];
                    }
                    distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
                    newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
                    iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                    vX = iX;
                    iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
                    vY = iY;
                    oX = vX - (vX - currentV[0]) * roundCorner;
                    oY = vY - (vY - currentV[1]) * roundCorner;
                    clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
                    index += 1;
                    if (i === len - 1) {
                      closerV = path.v[0];
                    } else {
                      closerV = path.v[i + 1];
                    }
                    distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
                    newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
                    oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                    vX = oX;
                    oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
                    vY = oY;
                    iX = vX - (vX - currentV[0]) * roundCorner;
                    iY = vY - (vY - currentV[1]) * roundCorner;
                    clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
                    index += 1;
                  }
                } else {
                  clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);
                  index += 1;
                }
              }
              return clonedPath;
            };
            RoundCornersModifier.prototype.processShapes = function (_isFirstFrame) {
              var shapePaths;
              var i;
              var len = this.shapes.length;
              var j;
              var jLen;
              var rd = this.rd.v;
              if (rd !== 0) {
                var shapeData;
                var localShapeCollection;
                for (i = 0; i < len; i += 1) {
                  shapeData = this.shapes[i];
                  localShapeCollection = shapeData.localShapeCollection;
                  if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                    localShapeCollection.releaseShapes();
                    shapeData.shape._mdf = true;
                    shapePaths = shapeData.shape.paths.shapes;
                    jLen = shapeData.shape.paths._length;
                    for (j = 0; j < jLen; j += 1) {
                      localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
                    }
                  }
                  shapeData.shape.paths = shapeData.localShapeCollection;
                }
              }
              if (!this.dynamicProperties.length) {
                this._mdf = false;
              }
            };
            function floatEqual(a, b) {
              return Math.abs(a - b) * 100000 <= Math.min(Math.abs(a), Math.abs(b));
            }
            function floatZero(f) {
              return Math.abs(f) <= 0.00001;
            }
            function lerp(p0, p1, amount) {
              return p0 * (1 - amount) + p1 * amount;
            }
            function lerpPoint(p0, p1, amount) {
              return [lerp(p0[0], p1[0], amount), lerp(p0[1], p1[1], amount)];
            }
            function quadRoots(a, b, c) {
              // no root
              if (a === 0) return [];
              var s = b * b - 4 * a * c; // Complex roots

              if (s < 0) return [];
              var singleRoot = -b / (2 * a); // 1 root

              if (s === 0) return [singleRoot];
              var delta = Math.sqrt(s) / (2 * a); // 2 roots

              return [singleRoot - delta, singleRoot + delta];
            }
            function polynomialCoefficients(p0, p1, p2, p3) {
              return [-p0 + 3 * p1 - 3 * p2 + p3, 3 * p0 - 6 * p1 + 3 * p2, -3 * p0 + 3 * p1, p0];
            }
            function singlePoint(p) {
              return new PolynomialBezier(p, p, p, p, false);
            }
            function PolynomialBezier(p0, p1, p2, p3, linearize) {
              if (linearize && pointEqual(p0, p1)) {
                p1 = lerpPoint(p0, p3, 1 / 3);
              }
              if (linearize && pointEqual(p2, p3)) {
                p2 = lerpPoint(p0, p3, 2 / 3);
              }
              var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);
              var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);
              this.a = [coeffx[0], coeffy[0]];
              this.b = [coeffx[1], coeffy[1]];
              this.c = [coeffx[2], coeffy[2]];
              this.d = [coeffx[3], coeffy[3]];
              this.points = [p0, p1, p2, p3];
            }
            PolynomialBezier.prototype.point = function (t) {
              return [((this.a[0] * t + this.b[0]) * t + this.c[0]) * t + this.d[0], ((this.a[1] * t + this.b[1]) * t + this.c[1]) * t + this.d[1]];
            };
            PolynomialBezier.prototype.derivative = function (t) {
              return [(3 * t * this.a[0] + 2 * this.b[0]) * t + this.c[0], (3 * t * this.a[1] + 2 * this.b[1]) * t + this.c[1]];
            };
            PolynomialBezier.prototype.tangentAngle = function (t) {
              var p = this.derivative(t);
              return Math.atan2(p[1], p[0]);
            };
            PolynomialBezier.prototype.normalAngle = function (t) {
              var p = this.derivative(t);
              return Math.atan2(p[0], p[1]);
            };
            PolynomialBezier.prototype.inflectionPoints = function () {
              var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];
              if (floatZero(denom)) return [];
              var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;
              var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;
              if (square < 0) return [];
              var root = Math.sqrt(square);
              if (floatZero(root)) {
                if (root > 0 && root < 1) return [tcusp];
                return [];
              }
              return [tcusp - root, tcusp + root].filter(function (r) {
                return r > 0 && r < 1;
              });
            };
            PolynomialBezier.prototype.split = function (t) {
              if (t <= 0) return [singlePoint(this.points[0]), this];
              if (t >= 1) return [this, singlePoint(this.points[this.points.length - 1])];
              var p10 = lerpPoint(this.points[0], this.points[1], t);
              var p11 = lerpPoint(this.points[1], this.points[2], t);
              var p12 = lerpPoint(this.points[2], this.points[3], t);
              var p20 = lerpPoint(p10, p11, t);
              var p21 = lerpPoint(p11, p12, t);
              var p3 = lerpPoint(p20, p21, t);
              return [new PolynomialBezier(this.points[0], p10, p20, p3, true), new PolynomialBezier(p3, p21, p12, this.points[3], true)];
            };
            function extrema(bez, comp) {
              var min = bez.points[0][comp];
              var max = bez.points[bez.points.length - 1][comp];
              if (min > max) {
                var e = max;
                max = min;
                min = e;
              } // Derivative roots to find min/max

              var f = quadRoots(3 * bez.a[comp], 2 * bez.b[comp], bez.c[comp]);
              for (var i = 0; i < f.length; i += 1) {
                if (f[i] > 0 && f[i] < 1) {
                  var val = bez.point(f[i])[comp];
                  if (val < min) min = val;else if (val > max) max = val;
                }
              }
              return {
                min: min,
                max: max
              };
            }
            PolynomialBezier.prototype.bounds = function () {
              return {
                x: extrema(this, 0),
                y: extrema(this, 1)
              };
            };
            PolynomialBezier.prototype.boundingBox = function () {
              var bounds = this.bounds();
              return {
                left: bounds.x.min,
                right: bounds.x.max,
                top: bounds.y.min,
                bottom: bounds.y.max,
                width: bounds.x.max - bounds.x.min,
                height: bounds.y.max - bounds.y.min,
                cx: (bounds.x.max + bounds.x.min) / 2,
                cy: (bounds.y.max + bounds.y.min) / 2
              };
            };
            function intersectData(bez, t1, t2) {
              var box = bez.boundingBox();
              return {
                cx: box.cx,
                cy: box.cy,
                width: box.width,
                height: box.height,
                bez: bez,
                t: (t1 + t2) / 2,
                t1: t1,
                t2: t2
              };
            }
            function splitData(data) {
              var split = data.bez.split(0.5);
              return [intersectData(split[0], data.t1, data.t), intersectData(split[1], data.t, data.t2)];
            }
            function boxIntersect(b1, b2) {
              return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;
            }
            function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {
              if (!boxIntersect(d1, d2)) return;
              if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {
                intersections.push([d1.t, d2.t]);
                return;
              }
              var d1s = splitData(d1);
              var d2s = splitData(d2);
              intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
              intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
              intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
              intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
            }
            PolynomialBezier.prototype.intersections = function (other, tolerance, maxRecursion) {
              if (tolerance === undefined) tolerance = 2;
              if (maxRecursion === undefined) maxRecursion = 7;
              var intersections = [];
              intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);
              return intersections;
            };
            PolynomialBezier.shapeSegment = function (shapePath, index) {
              var nextIndex = (index + 1) % shapePath.length();
              return new PolynomialBezier(shapePath.v[index], shapePath.o[index], shapePath.i[nextIndex], shapePath.v[nextIndex], true);
            };
            PolynomialBezier.shapeSegmentInverted = function (shapePath, index) {
              var nextIndex = (index + 1) % shapePath.length();
              return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index], shapePath.v[index], true);
            };
            function crossProduct(a, b) {
              return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
            }
            function lineIntersection(start1, end1, start2, end2) {
              var v1 = [start1[0], start1[1], 1];
              var v2 = [end1[0], end1[1], 1];
              var v3 = [start2[0], start2[1], 1];
              var v4 = [end2[0], end2[1], 1];
              var r = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));
              if (floatZero(r[2])) return null;
              return [r[0] / r[2], r[1] / r[2]];
            }
            function polarOffset(p, angle, length) {
              return [p[0] + Math.cos(angle) * length, p[1] - Math.sin(angle) * length];
            }
            function pointDistance(p1, p2) {
              return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);
            }
            function pointEqual(p1, p2) {
              return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);
            }
            function ZigZagModifier() {}
            extendPrototype([ShapeModifier], ZigZagModifier);
            ZigZagModifier.prototype.initModifierProperties = function (elem, data) {
              this.getValue = this.processKeys;
              this.amplitude = PropertyFactory.getProp(elem, data.s, 0, null, this);
              this.frequency = PropertyFactory.getProp(elem, data.r, 0, null, this);
              this.pointsType = PropertyFactory.getProp(elem, data.pt, 0, null, this);
              this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;
            };
            function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {
              var angO = angle - Math.PI / 2;
              var angI = angle + Math.PI / 2;
              var px = point[0] + Math.cos(angle) * direction * amplitude;
              var py = point[1] - Math.sin(angle) * direction * amplitude;
              outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());
            }
            function getPerpendicularVector(pt1, pt2) {
              var vector = [pt2[0] - pt1[0], pt2[1] - pt1[1]];
              var rot = -Math.PI * 0.5;
              var rotatedVector = [Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1], Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]];
              return rotatedVector;
            }
            function getProjectingAngle(path, cur) {
              var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;
              var nextIndex = (cur + 1) % path.length();
              var prevPoint = path.v[prevIndex];
              var nextPoint = path.v[nextIndex];
              var pVector = getPerpendicularVector(prevPoint, nextPoint);
              return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);
            }
            function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {
              var angle = getProjectingAngle(path, cur);
              var point = path.v[cur % path._length];
              var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];
              var nextPoint = path.v[(cur + 1) % path._length];
              var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;
              var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;
              setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2));
            }
            function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {
              for (var i = 0; i < frequency; i += 1) {
                var t = (i + 1) / (frequency + 1);
                var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;
                var angle = segment.normalAngle(t);
                var point = segment.point(t);
                setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2));
                direction = -direction;
              }
              return direction;
            }
            ZigZagModifier.prototype.processPath = function (path, amplitude, frequency, pointType) {
              var count = path._length;
              var clonedPath = shapePool.newElement();
              clonedPath.c = path.c;
              if (!path.c) {
                count -= 1;
              }
              if (count === 0) return clonedPath;
              var direction = -1;
              var segment = PolynomialBezier.shapeSegment(path, 0);
              zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);
              for (var i = 0; i < count; i += 1) {
                direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);
                if (i === count - 1 && !path.c) {
                  segment = null;
                } else {
                  segment = PolynomialBezier.shapeSegment(path, (i + 1) % count);
                }
                zigZagCorner(clonedPath, path, i + 1, amplitude, frequency, pointType, direction);
              }
              return clonedPath;
            };
            ZigZagModifier.prototype.processShapes = function (_isFirstFrame) {
              var shapePaths;
              var i;
              var len = this.shapes.length;
              var j;
              var jLen;
              var amplitude = this.amplitude.v;
              var frequency = Math.max(0, Math.round(this.frequency.v));
              var pointType = this.pointsType.v;
              if (amplitude !== 0) {
                var shapeData;
                var localShapeCollection;
                for (i = 0; i < len; i += 1) {
                  shapeData = this.shapes[i];
                  localShapeCollection = shapeData.localShapeCollection;
                  if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                    localShapeCollection.releaseShapes();
                    shapeData.shape._mdf = true;
                    shapePaths = shapeData.shape.paths.shapes;
                    jLen = shapeData.shape.paths._length;
                    for (j = 0; j < jLen; j += 1) {
                      localShapeCollection.addShape(this.processPath(shapePaths[j], amplitude, frequency, pointType));
                    }
                  }
                  shapeData.shape.paths = shapeData.localShapeCollection;
                }
              }
              if (!this.dynamicProperties.length) {
                this._mdf = false;
              }
            };
            function linearOffset(p1, p2, amount) {
              var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);
              return [polarOffset(p1, angle, amount), polarOffset(p2, angle, amount)];
            }
            function offsetSegment(segment, amount) {
              var p0;
              var p1a;
              var p1b;
              var p2b;
              var p2a;
              var p3;
              var e;
              e = linearOffset(segment.points[0], segment.points[1], amount);
              p0 = e[0];
              p1a = e[1];
              e = linearOffset(segment.points[1], segment.points[2], amount);
              p1b = e[0];
              p2b = e[1];
              e = linearOffset(segment.points[2], segment.points[3], amount);
              p2a = e[0];
              p3 = e[1];
              var p1 = lineIntersection(p0, p1a, p1b, p2b);
              if (p1 === null) p1 = p1a;
              var p2 = lineIntersection(p2a, p3, p1b, p2b);
              if (p2 === null) p2 = p2a;
              return new PolynomialBezier(p0, p1, p2, p3);
            }
            function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {
              var p0 = seg1.points[3];
              var p1 = seg2.points[0]; // Bevel

              if (lineJoin === 3) return p0; // Connected, they don't need a joint

              if (pointEqual(p0, p1)) return p0; // Round

              if (lineJoin === 2) {
                var angleOut = -seg1.tangentAngle(1);
                var angleIn = -seg2.tangentAngle(0) + Math.PI;
                var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));
                var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;
                var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);
                outputBezier.setXYAt(tan[0], tan[1], 'o', outputBezier.length() - 1);
                tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);
                outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());
                return p1;
              } // Miter

              var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];
              var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];
              var intersection = lineIntersection(t0, p0, p1, t1);
              if (intersection && pointDistance(intersection, p0) < miterLimit) {
                outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());
                return intersection;
              }
              return p0;
            }
            function getIntersection(a, b) {
              var intersect = a.intersections(b);
              if (intersect.length && floatEqual(intersect[0][0], 1)) intersect.shift();
              if (intersect.length) return intersect[0];
              return null;
            }
            function pruneSegmentIntersection(a, b) {
              var outa = a.slice();
              var outb = b.slice();
              var intersect = getIntersection(a[a.length - 1], b[0]);
              if (intersect) {
                outa[a.length - 1] = a[a.length - 1].split(intersect[0])[0];
                outb[0] = b[0].split(intersect[1])[1];
              }
              if (a.length > 1 && b.length > 1) {
                intersect = getIntersection(a[0], b[b.length - 1]);
                if (intersect) {
                  return [[a[0].split(intersect[0])[0]], [b[b.length - 1].split(intersect[1])[1]]];
                }
              }
              return [outa, outb];
            }
            function pruneIntersections(segments) {
              var e;
              for (var i = 1; i < segments.length; i += 1) {
                e = pruneSegmentIntersection(segments[i - 1], segments[i]);
                segments[i - 1] = e[0];
                segments[i] = e[1];
              }
              if (segments.length > 1) {
                e = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);
                segments[segments.length - 1] = e[0];
                segments[0] = e[1];
              }
              return segments;
            }
            function offsetSegmentSplit(segment, amount) {
              /*
                We split each bezier segment into smaller pieces based
                on inflection points, this ensures the control point
                polygon is convex.
                  (A cubic bezier can have none, one, or two inflection points)
              */
              var flex = segment.inflectionPoints();
              var left;
              var right;
              var split;
              var mid;
              if (flex.length === 0) {
                return [offsetSegment(segment, amount)];
              }
              if (flex.length === 1 || floatEqual(flex[1], 1)) {
                split = segment.split(flex[0]);
                left = split[0];
                right = split[1];
                return [offsetSegment(left, amount), offsetSegment(right, amount)];
              }
              split = segment.split(flex[0]);
              left = split[0];
              var t = (flex[1] - flex[0]) / (1 - flex[0]);
              split = split[1].split(t);
              mid = split[0];
              right = split[1];
              return [offsetSegment(left, amount), offsetSegment(mid, amount), offsetSegment(right, amount)];
            }
            function OffsetPathModifier() {}
            extendPrototype([ShapeModifier], OffsetPathModifier);
            OffsetPathModifier.prototype.initModifierProperties = function (elem, data) {
              this.getValue = this.processKeys;
              this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
              this.miterLimit = PropertyFactory.getProp(elem, data.ml, 0, null, this);
              this.lineJoin = data.lj;
              this._isAnimated = this.amount.effectsSequence.length !== 0;
            };
            OffsetPathModifier.prototype.processPath = function (inputBezier, amount, lineJoin, miterLimit) {
              var outputBezier = shapePool.newElement();
              outputBezier.c = inputBezier.c;
              var count = inputBezier.length();
              if (!inputBezier.c) {
                count -= 1;
              }
              var i;
              var j;
              var segment;
              var multiSegments = [];
              for (i = 0; i < count; i += 1) {
                segment = PolynomialBezier.shapeSegment(inputBezier, i);
                multiSegments.push(offsetSegmentSplit(segment, amount));
              }
              if (!inputBezier.c) {
                for (i = count - 1; i >= 0; i -= 1) {
                  segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i);
                  multiSegments.push(offsetSegmentSplit(segment, amount));
                }
              }
              multiSegments = pruneIntersections(multiSegments); // Add bezier segments to the output and apply line joints

              var lastPoint = null;
              var lastSeg = null;
              for (i = 0; i < multiSegments.length; i += 1) {
                var multiSegment = multiSegments[i];
                if (lastSeg) lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);
                lastSeg = multiSegment[multiSegment.length - 1];
                for (j = 0; j < multiSegment.length; j += 1) {
                  segment = multiSegment[j];
                  if (lastPoint && pointEqual(segment.points[0], lastPoint)) {
                    outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], 'o', outputBezier.length() - 1);
                  } else {
                    outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());
                  }
                  outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());
                  lastPoint = segment.points[3];
                }
              }
              if (multiSegments.length) joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);
              return outputBezier;
            };
            OffsetPathModifier.prototype.processShapes = function (_isFirstFrame) {
              var shapePaths;
              var i;
              var len = this.shapes.length;
              var j;
              var jLen;
              var amount = this.amount.v;
              var miterLimit = this.miterLimit.v;
              var lineJoin = this.lineJoin;
              if (amount !== 0) {
                var shapeData;
                var localShapeCollection;
                for (i = 0; i < len; i += 1) {
                  shapeData = this.shapes[i];
                  localShapeCollection = shapeData.localShapeCollection;
                  if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                    localShapeCollection.releaseShapes();
                    shapeData.shape._mdf = true;
                    shapePaths = shapeData.shape.paths.shapes;
                    jLen = shapeData.shape.paths._length;
                    for (j = 0; j < jLen; j += 1) {
                      localShapeCollection.addShape(this.processPath(shapePaths[j], amount, lineJoin, miterLimit));
                    }
                  }
                  shapeData.shape.paths = shapeData.localShapeCollection;
                }
              }
              if (!this.dynamicProperties.length) {
                this._mdf = false;
              }
            };
            function getFontProperties(fontData) {
              var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];
              var fWeight = 'normal';
              var fStyle = 'normal';
              var len = styles.length;
              var styleName;
              for (var i = 0; i < len; i += 1) {
                styleName = styles[i].toLowerCase();
                switch (styleName) {
                  case 'italic':
                    fStyle = 'italic';
                    break;
                  case 'bold':
                    fWeight = '700';
                    break;
                  case 'black':
                    fWeight = '900';
                    break;
                  case 'medium':
                    fWeight = '500';
                    break;
                  case 'regular':
                  case 'normal':
                    fWeight = '400';
                    break;
                  case 'light':
                  case 'thin':
                    fWeight = '200';
                    break;
                }
              }
              return {
                style: fStyle,
                weight: fontData.fWeight || fWeight
              };
            }
            var FontManager = function () {
              var maxWaitingTime = 5000;
              var emptyChar = {
                w: 0,
                size: 0,
                shapes: [],
                data: {
                  shapes: []
                }
              };
              var combinedCharacters = []; // Hindi characters

              combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
              var BLACK_FLAG_CODE_POINT = 127988;
              var CANCEL_TAG_CODE_POINT = 917631;
              var A_TAG_CODE_POINT = 917601;
              var Z_TAG_CODE_POINT = 917626;
              var VARIATION_SELECTOR_16_CODE_POINT = 65039;
              var ZERO_WIDTH_JOINER_CODE_POINT = 8205;
              var REGIONAL_CHARACTER_A_CODE_POINT = 127462;
              var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;
              var surrogateModifiers = ['d83cdffb', 'd83cdffc', 'd83cdffd', 'd83cdffe', 'd83cdfff'];
              function trimFontOptions(font) {
                var familyArray = font.split(',');
                var i;
                var len = familyArray.length;
                var enabledFamilies = [];
                for (i = 0; i < len; i += 1) {
                  if (familyArray[i] !== 'sans-serif' && familyArray[i] !== 'monospace') {
                    enabledFamilies.push(familyArray[i]);
                  }
                }
                return enabledFamilies.join(',');
              }
              function setUpNode(font, family) {
                var parentNode = createTag('span'); // Node is invisible to screen readers.

                parentNode.setAttribute('aria-hidden', true);
                parentNode.style.fontFamily = family;
                var node = createTag('span'); // Characters that vary significantly among different fonts

                node.innerText = 'giItT1WQy@!-/#'; // Visible - so we can measure it - but not on the screen

                parentNode.style.position = 'absolute';
                parentNode.style.left = '-10000px';
                parentNode.style.top = '-10000px'; // Large font size makes even subtle changes obvious

                parentNode.style.fontSize = '300px'; // Reset any font properties

                parentNode.style.fontVariant = 'normal';
                parentNode.style.fontStyle = 'normal';
                parentNode.style.fontWeight = 'normal';
                parentNode.style.letterSpacing = '0';
                parentNode.appendChild(node);
                document.body.appendChild(parentNode); // Remember width with no applied web font

                var width = node.offsetWidth;
                node.style.fontFamily = trimFontOptions(font) + ', ' + family;
                return {
                  node: node,
                  w: width,
                  parent: parentNode
                };
              }
              function checkLoadedFonts() {
                var i;
                var len = this.fonts.length;
                var node;
                var w;
                var loadedCount = len;
                for (i = 0; i < len; i += 1) {
                  if (this.fonts[i].loaded) {
                    loadedCount -= 1;
                  } else if (this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0) {
                    this.fonts[i].loaded = true;
                  } else {
                    node = this.fonts[i].monoCase.node;
                    w = this.fonts[i].monoCase.w;
                    if (node.offsetWidth !== w) {
                      loadedCount -= 1;
                      this.fonts[i].loaded = true;
                    } else {
                      node = this.fonts[i].sansCase.node;
                      w = this.fonts[i].sansCase.w;
                      if (node.offsetWidth !== w) {
                        loadedCount -= 1;
                        this.fonts[i].loaded = true;
                      }
                    }
                    if (this.fonts[i].loaded) {
                      this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
                      this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
                    }
                  }
                }
                if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
                  setTimeout(this.checkLoadedFontsBinded, 20);
                } else {
                  setTimeout(this.setIsLoadedBinded, 10);
                }
              }
              function createHelper(fontData, def) {
                var engine = document.body && def ? 'svg' : 'canvas';
                var helper;
                var fontProps = getFontProperties(fontData);
                if (engine === 'svg') {
                  var tHelper = createNS('text');
                  tHelper.style.fontSize = '100px'; // tHelper.style.fontFamily = fontData.fFamily;

                  tHelper.setAttribute('font-family', fontData.fFamily);
                  tHelper.setAttribute('font-style', fontProps.style);
                  tHelper.setAttribute('font-weight', fontProps.weight);
                  tHelper.textContent = '1';
                  if (fontData.fClass) {
                    tHelper.style.fontFamily = 'inherit';
                    tHelper.setAttribute('class', fontData.fClass);
                  } else {
                    tHelper.style.fontFamily = fontData.fFamily;
                  }
                  def.appendChild(tHelper);
                  helper = tHelper;
                } else {
                  var tCanvasHelper = new OffscreenCanvas(500, 500).getContext('2d');
                  tCanvasHelper.font = fontProps.style + ' ' + fontProps.weight + ' 100px ' + fontData.fFamily;
                  helper = tCanvasHelper;
                }
                function measure(text) {
                  if (engine === 'svg') {
                    helper.textContent = text;
                    return helper.getComputedTextLength();
                  }
                  return helper.measureText(text).width;
                }
                return {
                  measureText: measure
                };
              }
              function addFonts(fontData, defs) {
                if (!fontData) {
                  this.isLoaded = true;
                  return;
                }
                if (this.chars) {
                  this.isLoaded = true;
                  this.fonts = fontData.list;
                  return;
                }
                if (!document.body) {
                  this.isLoaded = true;
                  fontData.list.forEach(function (data) {
                    data.helper = createHelper(data);
                    data.cache = {};
                  });
                  this.fonts = fontData.list;
                  return;
                }
                var fontArr = fontData.list;
                var i;
                var len = fontArr.length;
                var _pendingFonts = len;
                for (i = 0; i < len; i += 1) {
                  var shouldLoadFont = true;
                  var loadedSelector;
                  var j;
                  fontArr[i].loaded = false;
                  fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, 'monospace');
                  fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, 'sans-serif');
                  if (!fontArr[i].fPath) {
                    fontArr[i].loaded = true;
                    _pendingFonts -= 1;
                  } else if (fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3) {
                    loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i].fFamily + '"]');
                    if (loadedSelector.length > 0) {
                      shouldLoadFont = false;
                    }
                    if (shouldLoadFont) {
                      var s = createTag('style');
                      s.setAttribute('f-forigin', fontArr[i].fOrigin);
                      s.setAttribute('f-origin', fontArr[i].origin);
                      s.setAttribute('f-family', fontArr[i].fFamily);
                      s.type = 'text/css';
                      s.innerText = '@font-face {font-family: ' + fontArr[i].fFamily + "; font-style: normal; src: url('" + fontArr[i].fPath + "');}";
                      defs.appendChild(s);
                    }
                  } else if (fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1) {
                    loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
                    for (j = 0; j < loadedSelector.length; j += 1) {
                      if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {
                        // Font is already loaded
                        shouldLoadFont = false;
                      }
                    }
                    if (shouldLoadFont) {
                      var l = createTag('link');
                      l.setAttribute('f-forigin', fontArr[i].fOrigin);
                      l.setAttribute('f-origin', fontArr[i].origin);
                      l.type = 'text/css';
                      l.rel = 'stylesheet';
                      l.href = fontArr[i].fPath;
                      document.body.appendChild(l);
                    }
                  } else if (fontArr[i].fOrigin === 't' || fontArr[i].origin === 2) {
                    loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
                    for (j = 0; j < loadedSelector.length; j += 1) {
                      if (fontArr[i].fPath === loadedSelector[j].src) {
                        // Font is already loaded
                        shouldLoadFont = false;
                      }
                    }
                    if (shouldLoadFont) {
                      var sc = createTag('link');
                      sc.setAttribute('f-forigin', fontArr[i].fOrigin);
                      sc.setAttribute('f-origin', fontArr[i].origin);
                      sc.setAttribute('rel', 'stylesheet');
                      sc.setAttribute('href', fontArr[i].fPath);
                      defs.appendChild(sc);
                    }
                  }
                  fontArr[i].helper = createHelper(fontArr[i], defs);
                  fontArr[i].cache = {};
                  this.fonts.push(fontArr[i]);
                }
                if (_pendingFonts === 0) {
                  this.isLoaded = true;
                } else {
                  // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.
                  // Adding this timeout seems to fix it
                  setTimeout(this.checkLoadedFonts.bind(this), 100);
                }
              }
              function addChars(chars) {
                if (!chars) {
                  return;
                }
                if (!this.chars) {
                  this.chars = [];
                }
                var i;
                var len = chars.length;
                var j;
                var jLen = this.chars.length;
                var found;
                for (i = 0; i < len; i += 1) {
                  j = 0;
                  found = false;
                  while (j < jLen) {
                    if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {
                      found = true;
                    }
                    j += 1;
                  }
                  if (!found) {
                    this.chars.push(chars[i]);
                    jLen += 1;
                  }
                }
              }
              function getCharData(_char, style, font) {
                var i = 0;
                var len = this.chars.length;
                while (i < len) {
                  if (this.chars[i].ch === _char && this.chars[i].style === style && this.chars[i].fFamily === font) {
                    return this.chars[i];
                  }
                  i += 1;
                }
                if ((typeof _char === 'string' && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn // eslint-disable-line no-console
                && !this._warned) {
                  this._warned = true;
                  console.warn('Missing character from exported characters list: ', _char, style, font); // eslint-disable-line no-console
                }
                return emptyChar;
              }
              function measureText(_char2, fontName, size) {
                var fontData = this.getFontByName(fontName); // Using the char instead of char.charCodeAt(0)
                // to avoid collisions between equal chars

                var index = _char2;
                if (!fontData.cache[index]) {
                  var tHelper = fontData.helper;
                  if (_char2 === ' ') {
                    var doubleSize = tHelper.measureText('|' + _char2 + '|');
                    var singleSize = tHelper.measureText('||');
                    fontData.cache[index] = (doubleSize - singleSize) / 100;
                  } else {
                    fontData.cache[index] = tHelper.measureText(_char2) / 100;
                  }
                }
                return fontData.cache[index] * size;
              }
              function getFontByName(name) {
                var i = 0;
                var len = this.fonts.length;
                while (i < len) {
                  if (this.fonts[i].fName === name) {
                    return this.fonts[i];
                  }
                  i += 1;
                }
                return this.fonts[0];
              }
              function getCodePoint(string) {
                var codePoint = 0;
                var first = string.charCodeAt(0);
                if (first >= 0xD800 && first <= 0xDBFF) {
                  var second = string.charCodeAt(1);
                  if (second >= 0xDC00 && second <= 0xDFFF) {
                    codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
                  }
                }
                return codePoint;
              } // Skin tone modifiers

              function isModifier(firstCharCode, secondCharCode) {
                var sum = firstCharCode.toString(16) + secondCharCode.toString(16);
                return surrogateModifiers.indexOf(sum) !== -1;
              }
              function isZeroWidthJoiner(charCode) {
                return charCode === ZERO_WIDTH_JOINER_CODE_POINT;
              } // This codepoint may change the appearance of the preceding character.
              // If that is a symbol, dingbat or emoji, U+FE0F forces it to be rendered
              // as a colorful image as compared to a monochrome text variant.

              function isVariationSelector(charCode) {
                return charCode === VARIATION_SELECTOR_16_CODE_POINT;
              } // The regional indicator symbols are a set of 26 alphabetic Unicode
              /// characters (A–Z) intended to be used to encode ISO 3166-1 alpha-2
              // two-letter country codes in a way that allows optional special treatment.

              function isRegionalCode(string) {
                var codePoint = getCodePoint(string);
                if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {
                  return true;
                }
                return false;
              } // Some Emoji implementations represent combinations of
              // two “regional indicator” letters as a single flag symbol.

              function isFlagEmoji(string) {
                return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));
              }
              function isCombinedCharacter(_char3) {
                return combinedCharacters.indexOf(_char3) !== -1;
              } // Regional flags start with a BLACK_FLAG_CODE_POINT
              // folowed by 5 chars in the TAG range
              // and end with a CANCEL_TAG_CODE_POINT

              function isRegionalFlag(text, index) {
                var codePoint = getCodePoint(text.substr(index, 2));
                if (codePoint !== BLACK_FLAG_CODE_POINT) {
                  return false;
                }
                var count = 0;
                index += 2;
                while (count < 5) {
                  codePoint = getCodePoint(text.substr(index, 2));
                  if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {
                    return false;
                  }
                  count += 1;
                  index += 2;
                }
                return getCodePoint(text.substr(index, 2)) === CANCEL_TAG_CODE_POINT;
              }
              function setIsLoaded() {
                this.isLoaded = true;
              }
              var Font = function Font() {
                this.fonts = [];
                this.chars = null;
                this.typekitLoaded = 0;
                this.isLoaded = false;
                this._warned = false;
                this.initTime = Date.now();
                this.setIsLoadedBinded = this.setIsLoaded.bind(this);
                this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
              };
              Font.isModifier = isModifier;
              Font.isZeroWidthJoiner = isZeroWidthJoiner;
              Font.isFlagEmoji = isFlagEmoji;
              Font.isRegionalCode = isRegionalCode;
              Font.isCombinedCharacter = isCombinedCharacter;
              Font.isRegionalFlag = isRegionalFlag;
              Font.isVariationSelector = isVariationSelector;
              Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;
              var fontPrototype = {
                addChars: addChars,
                addFonts: addFonts,
                getCharData: getCharData,
                getFontByName: getFontByName,
                measureText: measureText,
                checkLoadedFonts: checkLoadedFonts,
                setIsLoaded: setIsLoaded
              };
              Font.prototype = fontPrototype;
              return Font;
            }();
            function SlotManager(animationData) {
              this.animationData = animationData;
            }
            SlotManager.prototype.getProp = function (data) {
              if (this.animationData.slots && this.animationData.slots[data.sid]) {
                return Object.assign(data, this.animationData.slots[data.sid].p);
              }
              return data;
            };
            function slotFactory(animationData) {
              return new SlotManager(animationData);
            }
            function RenderableElement() {}
            RenderableElement.prototype = {
              initRenderable: function initRenderable() {
                // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange
                this.isInRange = false; // layer's display state

                this.hidden = false; // If layer's transparency equals 0, it can be hidden

                this.isTransparent = false; // list of animated components

                this.renderableComponents = [];
              },
              addRenderableComponent: function addRenderableComponent(component) {
                if (this.renderableComponents.indexOf(component) === -1) {
                  this.renderableComponents.push(component);
                }
              },
              removeRenderableComponent: function removeRenderableComponent(component) {
                if (this.renderableComponents.indexOf(component) !== -1) {
                  this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
                }
              },
              prepareRenderableFrame: function prepareRenderableFrame(num) {
                this.checkLayerLimits(num);
              },
              checkTransparency: function checkTransparency() {
                if (this.finalTransform.mProp.o.v <= 0) {
                  if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
                    this.isTransparent = true;
                    this.hide();
                  }
                } else if (this.isTransparent) {
                  this.isTransparent = false;
                  this.show();
                }
              },
              /**
                 * @function
                 * Initializes frame related properties.
                 *
                 * @param {number} num
                 * current frame number in Layer's time
                 *
                 */
              checkLayerLimits: function checkLayerLimits(num) {
                if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
                  if (this.isInRange !== true) {
                    this.globalData._mdf = true;
                    this._mdf = true;
                    this.isInRange = true;
                    this.show();
                  }
                } else if (this.isInRange !== false) {
                  this.globalData._mdf = true;
                  this.isInRange = false;
                  this.hide();
                }
              },
              renderRenderable: function renderRenderable() {
                var i;
                var len = this.renderableComponents.length;
                for (i = 0; i < len; i += 1) {
                  this.renderableComponents[i].renderFrame(this._isFirstFrame);
                }
                /* this.maskManager.renderFrame(this.finalTransform.mat);
                    this.renderableEffectsManager.renderFrame(this._isFirstFrame); */
              },
              sourceRectAtTime: function sourceRectAtTime() {
                return {
                  top: 0,
                  left: 0,
                  width: 100,
                  height: 100
                };
              },
              getLayerSize: function getLayerSize() {
                if (this.data.ty === 5) {
                  return {
                    w: this.data.textData.width,
                    h: this.data.textData.height
                  };
                }
                return {
                  w: this.data.width,
                  h: this.data.height
                };
              }
            };
            var getBlendMode = function () {
              var blendModeEnums = {
                0: 'source-over',
                1: 'multiply',
                2: 'screen',
                3: 'overlay',
                4: 'darken',
                5: 'lighten',
                6: 'color-dodge',
                7: 'color-burn',
                8: 'hard-light',
                9: 'soft-light',
                10: 'difference',
                11: 'exclusion',
                12: 'hue',
                13: 'saturation',
                14: 'color',
                15: 'luminosity'
              };
              return function (mode) {
                return blendModeEnums[mode] || '';
              };
            }();
            function SliderEffect(data, elem, container) {
              this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
            }
            function AngleEffect(data, elem, container) {
              this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
            }
            function ColorEffect(data, elem, container) {
              this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
            }
            function PointEffect(data, elem, container) {
              this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
            }
            function LayerIndexEffect(data, elem, container) {
              this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
            }
            function MaskIndexEffect(data, elem, container) {
              this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
            }
            function CheckboxEffect(data, elem, container) {
              this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
            }
            function NoValueEffect() {
              this.p = {};
            }
            function EffectsManager(data, element) {
              var effects = data.ef || [];
              this.effectElements = [];
              var i;
              var len = effects.length;
              var effectItem;
              for (i = 0; i < len; i += 1) {
                effectItem = new GroupEffect(effects[i], element);
                this.effectElements.push(effectItem);
              }
            }
            function GroupEffect(data, element) {
              this.init(data, element);
            }
            extendPrototype([DynamicPropertyContainer], GroupEffect);
            GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;
            GroupEffect.prototype.init = function (data, element) {
              this.data = data;
              this.effectElements = [];
              this.initDynamicPropertyContainer(element);
              var i;
              var len = this.data.ef.length;
              var eff;
              var effects = this.data.ef;
              for (i = 0; i < len; i += 1) {
                eff = null;
                switch (effects[i].ty) {
                  case 0:
                    eff = new SliderEffect(effects[i], element, this);
                    break;
                  case 1:
                    eff = new AngleEffect(effects[i], element, this);
                    break;
                  case 2:
                    eff = new ColorEffect(effects[i], element, this);
                    break;
                  case 3:
                    eff = new PointEffect(effects[i], element, this);
                    break;
                  case 4:
                  case 7:
                    eff = new CheckboxEffect(effects[i], element, this);
                    break;
                  case 10:
                    eff = new LayerIndexEffect(effects[i], element, this);
                    break;
                  case 11:
                    eff = new MaskIndexEffect(effects[i], element, this);
                    break;
                  case 5:
                    eff = new EffectsManager(effects[i], element);
                    break;
                  // case 6:

                  default:
                    eff = new NoValueEffect(effects[i]);
                    break;
                }
                if (eff) {
                  this.effectElements.push(eff);
                }
              }
            };
            function BaseElement() {}
            BaseElement.prototype = {
              checkMasks: function checkMasks() {
                if (!this.data.hasMask) {
                  return false;
                }
                var i = 0;
                var len = this.data.masksProperties.length;
                while (i < len) {
                  if (this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false) {
                    return true;
                  }
                  i += 1;
                }
                return false;
              },
              initExpressions: function initExpressions() {
                var expressionsInterfaces = getExpressionInterfaces();
                if (!expressionsInterfaces) {
                  return;
                }
                var LayerExpressionInterface = expressionsInterfaces('layer');
                var EffectsExpressionInterface = expressionsInterfaces('effects');
                var ShapeExpressionInterface = expressionsInterfaces('shape');
                var TextExpressionInterface = expressionsInterfaces('text');
                var CompExpressionInterface = expressionsInterfaces('comp');
                this.layerInterface = LayerExpressionInterface(this);
                if (this.data.hasMask && this.maskManager) {
                  this.layerInterface.registerMaskInterface(this.maskManager);
                }
                var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
                this.layerInterface.registerEffectsInterface(effectsInterface);
                if (this.data.ty === 0 || this.data.xt) {
                  this.compInterface = CompExpressionInterface(this);
                } else if (this.data.ty === 4) {
                  this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);
                  this.layerInterface.content = this.layerInterface.shapeInterface;
                } else if (this.data.ty === 5) {
                  this.layerInterface.textInterface = TextExpressionInterface(this);
                  this.layerInterface.text = this.layerInterface.textInterface;
                }
              },
              setBlendMode: function setBlendMode() {
                var blendModeValue = getBlendMode(this.data.bm);
                var elem = this.baseElement || this.layerElement;
                elem.style['mix-blend-mode'] = blendModeValue;
              },
              initBaseData: function initBaseData(data, globalData, comp) {
                this.globalData = globalData;
                this.comp = comp;
                this.data = data;
                this.layerId = createElementID(); // Stretch factor for old animations missing this property.

                if (!this.data.sr) {
                  this.data.sr = 1;
                } // effects manager

                this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
              },
              getType: function getType() {
                return this.type;
              },
              sourceRectAtTime: function sourceRectAtTime() {}
            };

            /**
             * @file
             * Handles element's layer frame update.
             * Checks layer in point and out point
             *
             */
            function FrameElement() {}
            FrameElement.prototype = {
              /**
                 * @function
                 * Initializes frame related properties.
                 *
                 */
              initFrame: function initFrame() {
                // set to true when inpoint is rendered
                this._isFirstFrame = false; // list of animated properties

                this.dynamicProperties = []; // If layer has been modified in current tick this will be true

                this._mdf = false;
              },
              /**
                 * @function
                 * Calculates all dynamic values
                 *
                 * @param {number} num
                 * current frame number in Layer's time
                 * @param {boolean} isVisible
                 * if layers is currently in range
                 *
                 */
              prepareProperties: function prepareProperties(num, isVisible) {
                var i;
                var len = this.dynamicProperties.length;
                for (i = 0; i < len; i += 1) {
                  if (isVisible || this._isParent && this.dynamicProperties[i].propType === 'transform') {
                    this.dynamicProperties[i].getValue();
                    if (this.dynamicProperties[i]._mdf) {
                      this.globalData._mdf = true;
                      this._mdf = true;
                    }
                  }
                }
              },
              addDynamicProperty: function addDynamicProperty(prop) {
                if (this.dynamicProperties.indexOf(prop) === -1) {
                  this.dynamicProperties.push(prop);
                }
              }
            };
            function FootageElement(data, globalData, comp) {
              this.initFrame();
              this.initRenderable();
              this.assetData = globalData.getAssetData(data.refId);
              this.footageData = globalData.imageLoader.getAsset(this.assetData);
              this.initBaseData(data, globalData, comp);
            }
            FootageElement.prototype.prepareFrame = function () {};
            extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);
            FootageElement.prototype.getBaseElement = function () {
              return null;
            };
            FootageElement.prototype.renderFrame = function () {};
            FootageElement.prototype.destroy = function () {};
            FootageElement.prototype.initExpressions = function () {
              var expressionsInterfaces = getExpressionInterfaces();
              if (!expressionsInterfaces) {
                return;
              }
              var FootageInterface = expressionsInterfaces('footage');
              this.layerInterface = FootageInterface(this);
            };
            FootageElement.prototype.getFootageData = function () {
              return this.footageData;
            };
            function AudioElement(data, globalData, comp) {
              this.initFrame();
              this.initRenderable();
              this.assetData = globalData.getAssetData(data.refId);
              this.initBaseData(data, globalData, comp);
              this._isPlaying = false;
              this._canPlay = false;
              var assetPath = this.globalData.getAssetsPath(this.assetData);
              this.audio = this.globalData.audioController.createAudio(assetPath);
              this._currentTime = 0;
              this.globalData.audioController.addAudio(this);
              this._volumeMultiplier = 1;
              this._volume = 1;
              this._previousVolume = null;
              this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
                _placeholder: true
              };
              this.lv = PropertyFactory.getProp(this, data.au && data.au.lv ? data.au.lv : {
                k: [100]
              }, 1, 0.01, this);
            }
            AudioElement.prototype.prepareFrame = function (num) {
              this.prepareRenderableFrame(num, true);
              this.prepareProperties(num, true);
              if (!this.tm._placeholder) {
                var timeRemapped = this.tm.v;
                this._currentTime = timeRemapped;
              } else {
                this._currentTime = num / this.data.sr;
              }
              this._volume = this.lv.v[0];
              var totalVolume = this._volume * this._volumeMultiplier;
              if (this._previousVolume !== totalVolume) {
                this._previousVolume = totalVolume;
                this.audio.volume(totalVolume);
              }
            };
            extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);
            AudioElement.prototype.renderFrame = function () {
              if (this.isInRange && this._canPlay) {
                if (!this._isPlaying) {
                  this.audio.play();
                  this.audio.seek(this._currentTime / this.globalData.frameRate);
                  this._isPlaying = true;
                } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {
                  this.audio.seek(this._currentTime / this.globalData.frameRate);
                }
              }
            };
            AudioElement.prototype.show = function () {// this.audio.play()
            };
            AudioElement.prototype.hide = function () {
              this.audio.pause();
              this._isPlaying = false;
            };
            AudioElement.prototype.pause = function () {
              this.audio.pause();
              this._isPlaying = false;
              this._canPlay = false;
            };
            AudioElement.prototype.resume = function () {
              this._canPlay = true;
            };
            AudioElement.prototype.setRate = function (rateValue) {
              this.audio.rate(rateValue);
            };
            AudioElement.prototype.volume = function (volumeValue) {
              this._volumeMultiplier = volumeValue;
              this._previousVolume = volumeValue * this._volume;
              this.audio.volume(this._previousVolume);
            };
            AudioElement.prototype.getBaseElement = function () {
              return null;
            };
            AudioElement.prototype.destroy = function () {};
            AudioElement.prototype.sourceRectAtTime = function () {};
            AudioElement.prototype.initExpressions = function () {};
            function BaseRenderer() {}
            BaseRenderer.prototype.checkLayers = function (num) {
              var i;
              var len = this.layers.length;
              var data;
              this.completeLayers = true;
              for (i = len - 1; i >= 0; i -= 1) {
                if (!this.elements[i]) {
                  data = this.layers[i];
                  if (data.ip - data.st <= num - this.layers[i].st && data.op - data.st > num - this.layers[i].st) {
                    this.buildItem(i);
                  }
                }
                this.completeLayers = this.elements[i] ? this.completeLayers : false;
              }
              this.checkPendingElements();
            };
            BaseRenderer.prototype.createItem = function (layer) {
              switch (layer.ty) {
                case 2:
                  return this.createImage(layer);
                case 0:
                  return this.createComp(layer);
                case 1:
                  return this.createSolid(layer);
                case 3:
                  return this.createNull(layer);
                case 4:
                  return this.createShape(layer);
                case 5:
                  return this.createText(layer);
                case 6:
                  return this.createAudio(layer);
                case 13:
                  return this.createCamera(layer);
                case 15:
                  return this.createFootage(layer);
                default:
                  return this.createNull(layer);
              }
            };
            BaseRenderer.prototype.createCamera = function () {
              throw new Error('You\'re using a 3d camera. Try the html renderer.');
            };
            BaseRenderer.prototype.createAudio = function (data) {
              return new AudioElement(data, this.globalData, this);
            };
            BaseRenderer.prototype.createFootage = function (data) {
              return new FootageElement(data, this.globalData, this);
            };
            BaseRenderer.prototype.buildAllItems = function () {
              var i;
              var len = this.layers.length;
              for (i = 0; i < len; i += 1) {
                this.buildItem(i);
              }
              this.checkPendingElements();
            };
            BaseRenderer.prototype.includeLayers = function (newLayers) {
              this.completeLayers = false;
              var i;
              var len = newLayers.length;
              var j;
              var jLen = this.layers.length;
              for (i = 0; i < len; i += 1) {
                j = 0;
                while (j < jLen) {
                  if (this.layers[j].id === newLayers[i].id) {
                    this.layers[j] = newLayers[i];
                    break;
                  }
                  j += 1;
                }
              }
            };
            BaseRenderer.prototype.setProjectInterface = function (pInterface) {
              this.globalData.projectInterface = pInterface;
            };
            BaseRenderer.prototype.initItems = function () {
              if (!this.globalData.progressiveLoad) {
                this.buildAllItems();
              }
            };
            BaseRenderer.prototype.buildElementParenting = function (element, parentName, hierarchy) {
              var elements = this.elements;
              var layers = this.layers;
              var i = 0;
              var len = layers.length;
              while (i < len) {
                if (layers[i].ind == parentName) {
                  // eslint-disable-line eqeqeq
                  if (!elements[i] || elements[i] === true) {
                    this.buildItem(i);
                    this.addPendingElement(element);
                  } else {
                    hierarchy.push(elements[i]);
                    elements[i].setAsParent();
                    if (layers[i].parent !== undefined) {
                      this.buildElementParenting(element, layers[i].parent, hierarchy);
                    } else {
                      element.setHierarchy(hierarchy);
                    }
                  }
                }
                i += 1;
              }
            };
            BaseRenderer.prototype.addPendingElement = function (element) {
              this.pendingElements.push(element);
            };
            BaseRenderer.prototype.searchExtraCompositions = function (assets) {
              var i;
              var len = assets.length;
              for (i = 0; i < len; i += 1) {
                if (assets[i].xt) {
                  var comp = this.createComp(assets[i]);
                  comp.initExpressions();
                  this.globalData.projectInterface.registerComposition(comp);
                }
              }
            };
            BaseRenderer.prototype.getElementById = function (ind) {
              var i;
              var len = this.elements.length;
              for (i = 0; i < len; i += 1) {
                if (this.elements[i].data.ind === ind) {
                  return this.elements[i];
                }
              }
              return null;
            };
            BaseRenderer.prototype.getElementByPath = function (path) {
              var pathValue = path.shift();
              var element;
              if (typeof pathValue === 'number') {
                element = this.elements[pathValue];
              } else {
                var i;
                var len = this.elements.length;
                for (i = 0; i < len; i += 1) {
                  if (this.elements[i].data.nm === pathValue) {
                    element = this.elements[i];
                    break;
                  }
                }
              }
              if (path.length === 0) {
                return element;
              }
              return element.getElementByPath(path);
            };
            BaseRenderer.prototype.setupGlobalData = function (animData, fontsContainer) {
              this.globalData.fontManager = new FontManager();
              this.globalData.slotManager = slotFactory(animData);
              this.globalData.fontManager.addChars(animData.chars);
              this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
              this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
              this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
              this.globalData.imageLoader = this.animationItem.imagePreloader;
              this.globalData.audioController = this.animationItem.audioController;
              this.globalData.frameId = 0;
              this.globalData.frameRate = animData.fr;
              this.globalData.nm = animData.nm;
              this.globalData.compSize = {
                w: animData.w,
                h: animData.h
              };
            };
            var effectTypes = {
              TRANSFORM_EFFECT: 'transformEFfect'
            };
            function TransformElement() {}
            TransformElement.prototype = {
              initTransform: function initTransform() {
                var mat = new Matrix();
                this.finalTransform = {
                  mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                    o: 0
                  },
                  _matMdf: false,
                  _localMatMdf: false,
                  _opMdf: false,
                  mat: mat,
                  localMat: mat,
                  localOpacity: 1
                };
                if (this.data.ao) {
                  this.finalTransform.mProp.autoOriented = true;
                } // TODO: check TYPE 11: Guided elements

                if (this.data.ty !== 11) ;
              },
              renderTransform: function renderTransform() {
                this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
                this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
                if (this.hierarchy) {
                  var mat;
                  var finalMat = this.finalTransform.mat;
                  var i = 0;
                  var len = this.hierarchy.length; // Checking if any of the transformation matrices in the hierarchy chain has changed.

                  if (!this.finalTransform._matMdf) {
                    while (i < len) {
                      if (this.hierarchy[i].finalTransform.mProp._mdf) {
                        this.finalTransform._matMdf = true;
                        break;
                      }
                      i += 1;
                    }
                  }
                  if (this.finalTransform._matMdf) {
                    mat = this.finalTransform.mProp.v.props;
                    finalMat.cloneFromProps(mat);
                    for (i = 0; i < len; i += 1) {
                      finalMat.multiply(this.hierarchy[i].finalTransform.mProp.v);
                    }
                  }
                }
                if (this.finalTransform._matMdf) {
                  this.finalTransform._localMatMdf = this.finalTransform._matMdf;
                }
                if (this.finalTransform._opMdf) {
                  this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
                }
              },
              renderLocalTransform: function renderLocalTransform() {
                if (this.localTransforms) {
                  var i = 0;
                  var len = this.localTransforms.length;
                  this.finalTransform._localMatMdf = this.finalTransform._matMdf;
                  if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {
                    while (i < len) {
                      if (this.localTransforms[i]._mdf) {
                        this.finalTransform._localMatMdf = true;
                      }
                      if (this.localTransforms[i]._opMdf && !this.finalTransform._opMdf) {
                        this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
                        this.finalTransform._opMdf = true;
                      }
                      i += 1;
                    }
                  }
                  if (this.finalTransform._localMatMdf) {
                    var localMat = this.finalTransform.localMat;
                    this.localTransforms[0].matrix.clone(localMat);
                    for (i = 1; i < len; i += 1) {
                      var lmat = this.localTransforms[i].matrix;
                      localMat.multiply(lmat);
                    }
                    localMat.multiply(this.finalTransform.mat);
                  }
                  if (this.finalTransform._opMdf) {
                    var localOp = this.finalTransform.localOpacity;
                    for (i = 0; i < len; i += 1) {
                      localOp *= this.localTransforms[i].opacity * 0.01;
                    }
                    this.finalTransform.localOpacity = localOp;
                  }
                }
              },
              searchEffectTransforms: function searchEffectTransforms() {
                if (this.renderableEffectsManager) {
                  var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
                  if (transformEffects.length) {
                    this.localTransforms = [];
                    this.finalTransform.localMat = new Matrix();
                    var i = 0;
                    var len = transformEffects.length;
                    for (i = 0; i < len; i += 1) {
                      this.localTransforms.push(transformEffects[i]);
                    }
                  }
                }
              },
              globalToLocal: function globalToLocal(pt) {
                var transforms = [];
                transforms.push(this.finalTransform);
                var flag = true;
                var comp = this.comp;
                while (flag) {
                  if (comp.finalTransform) {
                    if (comp.data.hasMask) {
                      transforms.splice(0, 0, comp.finalTransform);
                    }
                    comp = comp.comp;
                  } else {
                    flag = false;
                  }
                }
                var i;
                var len = transforms.length;
                var ptNew;
                for (i = 0; i < len; i += 1) {
                  ptNew = transforms[i].mat.applyToPointArray(0, 0, 0); // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);

                  pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
                }
                return pt;
              },
              mHelper: new Matrix()
            };
            function MaskElement(data, element, globalData) {
              this.data = data;
              this.element = element;
              this.globalData = globalData;
              this.storedData = [];
              this.masksProperties = this.data.masksProperties || [];
              this.maskElement = null;
              var defs = this.globalData.defs;
              var i;
              var len = this.masksProperties ? this.masksProperties.length : 0;
              this.viewData = createSizedArray(len);
              this.solidPath = '';
              var path;
              var properties = this.masksProperties;
              var count = 0;
              var currentMasks = [];
              var j;
              var jLen;
              var layerId = createElementID();
              var rect;
              var expansor;
              var feMorph;
              var x;
              var maskType = 'clipPath';
              var maskRef = 'clip-path';
              for (i = 0; i < len; i += 1) {
                if (properties[i].mode !== 'a' && properties[i].mode !== 'n' || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {
                  maskType = 'mask';
                  maskRef = 'mask';
                }
                if ((properties[i].mode === 's' || properties[i].mode === 'i') && count === 0) {
                  rect = createNS('rect');
                  rect.setAttribute('fill', '#ffffff');
                  rect.setAttribute('width', this.element.comp.data.w || 0);
                  rect.setAttribute('height', this.element.comp.data.h || 0);
                  currentMasks.push(rect);
                } else {
                  rect = null;
                }
                path = createNS('path');
                if (properties[i].mode === 'n') {
                  // TODO move this to a factory or to a constructor
                  this.viewData[i] = {
                    op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
                    prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
                    elem: path,
                    lastPath: ''
                  };
                  defs.appendChild(path);
                } else {
                  count += 1;
                  path.setAttribute('fill', properties[i].mode === 's' ? '#000000' : '#ffffff');
                  path.setAttribute('clip-rule', 'nonzero');
                  var filterID;
                  if (properties[i].x.k !== 0) {
                    maskType = 'mask';
                    maskRef = 'mask';
                    x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);
                    filterID = createElementID();
                    expansor = createNS('filter');
                    expansor.setAttribute('id', filterID);
                    feMorph = createNS('feMorphology');
                    feMorph.setAttribute('operator', 'erode');
                    feMorph.setAttribute('in', 'SourceGraphic');
                    feMorph.setAttribute('radius', '0');
                    expansor.appendChild(feMorph);
                    defs.appendChild(expansor);
                    path.setAttribute('stroke', properties[i].mode === 's' ? '#000000' : '#ffffff');
                  } else {
                    feMorph = null;
                    x = null;
                  } // TODO move this to a factory or to a constructor

                  this.storedData[i] = {
                    elem: path,
                    x: x,
                    expan: feMorph,
                    lastPath: '',
                    lastOperator: '',
                    filterId: filterID,
                    lastRadius: 0
                  };
                  if (properties[i].mode === 'i') {
                    jLen = currentMasks.length;
                    var g = createNS('g');
                    for (j = 0; j < jLen; j += 1) {
                      g.appendChild(currentMasks[j]);
                    }
                    var mask = createNS('mask');
                    mask.setAttribute('mask-type', 'alpha');
                    mask.setAttribute('id', layerId + '_' + count);
                    mask.appendChild(path);
                    defs.appendChild(mask);
                    g.setAttribute('mask', 'url(' + getLocationHref() + '#' + layerId + '_' + count + ')');
                    currentMasks.length = 0;
                    currentMasks.push(g);
                  } else {
                    currentMasks.push(path);
                  }
                  if (properties[i].inv && !this.solidPath) {
                    this.solidPath = this.createLayerSolidPath();
                  } // TODO move this to a factory or to a constructor

                  this.viewData[i] = {
                    elem: path,
                    lastPath: '',
                    op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
                    prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
                    invRect: rect
                  };
                  if (!this.viewData[i].prop.k) {
                    this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);
                  }
                }
              }
              this.maskElement = createNS(maskType);
              len = currentMasks.length;
              for (i = 0; i < len; i += 1) {
                this.maskElement.appendChild(currentMasks[i]);
              }
              if (count > 0) {
                this.maskElement.setAttribute('id', layerId);
                this.element.maskedElement.setAttribute(maskRef, 'url(' + getLocationHref() + '#' + layerId + ')');
                defs.appendChild(this.maskElement);
              }
              if (this.viewData.length) {
                this.element.addRenderableComponent(this);
              }
            }
            MaskElement.prototype.getMaskProperty = function (pos) {
              return this.viewData[pos].prop;
            };
            MaskElement.prototype.renderFrame = function (isFirstFrame) {
              var finalMat = this.element.finalTransform.mat;
              var i;
              var len = this.masksProperties.length;
              for (i = 0; i < len; i += 1) {
                if (this.viewData[i].prop._mdf || isFirstFrame) {
                  this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);
                }
                if (this.viewData[i].op._mdf || isFirstFrame) {
                  this.viewData[i].elem.setAttribute('fill-opacity', this.viewData[i].op.v);
                }
                if (this.masksProperties[i].mode !== 'n') {
                  if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
                    this.viewData[i].invRect.setAttribute('transform', finalMat.getInverseMatrix().to2dCSS());
                  }
                  if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {
                    var feMorph = this.storedData[i].expan;
                    if (this.storedData[i].x.v < 0) {
                      if (this.storedData[i].lastOperator !== 'erode') {
                        this.storedData[i].lastOperator = 'erode';
                        this.storedData[i].elem.setAttribute('filter', 'url(' + getLocationHref() + '#' + this.storedData[i].filterId + ')');
                      }
                      feMorph.setAttribute('radius', -this.storedData[i].x.v);
                    } else {
                      if (this.storedData[i].lastOperator !== 'dilate') {
                        this.storedData[i].lastOperator = 'dilate';
                        this.storedData[i].elem.setAttribute('filter', null);
                      }
                      this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v * 2);
                    }
                  }
                }
              }
            };
            MaskElement.prototype.getMaskelement = function () {
              return this.maskElement;
            };
            MaskElement.prototype.createLayerSolidPath = function () {
              var path = 'M0,0 ';
              path += ' h' + this.globalData.compSize.w;
              path += ' v' + this.globalData.compSize.h;
              path += ' h-' + this.globalData.compSize.w;
              path += ' v-' + this.globalData.compSize.h + ' ';
              return path;
            };
            MaskElement.prototype.drawPath = function (pathData, pathNodes, viewData) {
              var pathString = ' M' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
              var i;
              var len;
              len = pathNodes._length;
              for (i = 1; i < len; i += 1) {
                // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
                pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[i][0] + ',' + pathNodes.i[i][1] + ' ' + pathNodes.v[i][0] + ',' + pathNodes.v[i][1];
              } // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];

              if (pathNodes.c && len > 1) {
                pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[0][0] + ',' + pathNodes.i[0][1] + ' ' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
              } // pathNodes.__renderedString = pathString;

              if (viewData.lastPath !== pathString) {
                var pathShapeValue = '';
                if (viewData.elem) {
                  if (pathNodes.c) {
                    pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
                  }
                  viewData.elem.setAttribute('d', pathShapeValue);
                }
                viewData.lastPath = pathString;
              }
            };
            MaskElement.prototype.destroy = function () {
              this.element = null;
              this.globalData = null;
              this.maskElement = null;
              this.data = null;
              this.masksProperties = null;
            };
            var filtersFactory = function () {
              var ob = {};
              ob.createFilter = createFilter;
              ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
              function createFilter(filId, skipCoordinates) {
                var fil = createNS('filter');
                fil.setAttribute('id', filId);
                if (skipCoordinates !== true) {
                  fil.setAttribute('filterUnits', 'objectBoundingBox');
                  fil.setAttribute('x', '0%');
                  fil.setAttribute('y', '0%');
                  fil.setAttribute('width', '100%');
                  fil.setAttribute('height', '100%');
                }
                return fil;
              }
              function createAlphaToLuminanceFilter() {
                var feColorMatrix = createNS('feColorMatrix');
                feColorMatrix.setAttribute('type', 'matrix');
                feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
                feColorMatrix.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');
                return feColorMatrix;
              }
              return ob;
            }();
            var featureSupport = function () {
              var ob = {
                maskType: true,
                svgLumaHidden: true,
                offscreenCanvas: typeof OffscreenCanvas !== 'undefined'
              };
              if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
                ob.maskType = false;
              }
              if (/firefox/i.test(navigator.userAgent)) {
                ob.svgLumaHidden = false;
              }
              return ob;
            }();
            var registeredEffects$1 = {};
            var idPrefix = 'filter_result_';
            function SVGEffects(elem) {
              var i;
              var source = 'SourceGraphic';
              var len = elem.data.ef ? elem.data.ef.length : 0;
              var filId = createElementID();
              var fil = filtersFactory.createFilter(filId, true);
              var count = 0;
              this.filters = [];
              var filterManager;
              for (i = 0; i < len; i += 1) {
                filterManager = null;
                var type = elem.data.ef[i].ty;
                if (registeredEffects$1[type]) {
                  var Effect = registeredEffects$1[type].effect;
                  filterManager = new Effect(fil, elem.effectsManager.effectElements[i], elem, idPrefix + count, source);
                  source = idPrefix + count;
                  if (registeredEffects$1[type].countsAsEffect) {
                    count += 1;
                  }
                }
                if (filterManager) {
                  this.filters.push(filterManager);
                }
              }
              if (count) {
                elem.globalData.defs.appendChild(fil);
                elem.layerElement.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');
              }
              if (this.filters.length) {
                elem.addRenderableComponent(this);
              }
            }
            SVGEffects.prototype.renderFrame = function (_isFirstFrame) {
              var i;
              var len = this.filters.length;
              for (i = 0; i < len; i += 1) {
                this.filters[i].renderFrame(_isFirstFrame);
              }
            };
            SVGEffects.prototype.getEffects = function (type) {
              var i;
              var len = this.filters.length;
              var effects = [];
              for (i = 0; i < len; i += 1) {
                if (this.filters[i].type === type) {
                  effects.push(this.filters[i]);
                }
              }
              return effects;
            };
            function registerEffect$1(id, effect, countsAsEffect) {
              registeredEffects$1[id] = {
                effect: effect,
                countsAsEffect: countsAsEffect
              };
            }
            function SVGBaseElement() {}
            SVGBaseElement.prototype = {
              initRendererElement: function initRendererElement() {
                this.layerElement = createNS('g');
              },
              createContainerElements: function createContainerElements() {
                this.matteElement = createNS('g');
                this.transformedElement = this.layerElement;
                this.maskedElement = this.layerElement;
                this._sizeChanged = false;
                var layerElementParent = null; // If this layer acts as a mask for the following layer

                if (this.data.td) {
                  this.matteMasks = {};
                  var gg = createNS('g');
                  gg.setAttribute('id', this.layerId);
                  gg.appendChild(this.layerElement);
                  layerElementParent = gg;
                  this.globalData.defs.appendChild(gg);
                } else if (this.data.tt) {
                  this.matteElement.appendChild(this.layerElement);
                  layerElementParent = this.matteElement;
                  this.baseElement = this.matteElement;
                } else {
                  this.baseElement = this.layerElement;
                }
                if (this.data.ln) {
                  this.layerElement.setAttribute('id', this.data.ln);
                }
                if (this.data.cl) {
                  this.layerElement.setAttribute('class', this.data.cl);
                } // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped

                if (this.data.ty === 0 && !this.data.hd) {
                  var cp = createNS('clipPath');
                  var pt = createNS('path');
                  pt.setAttribute('d', 'M0,0 L' + this.data.w + ',0 L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');
                  var clipId = createElementID();
                  cp.setAttribute('id', clipId);
                  cp.appendChild(pt);
                  this.globalData.defs.appendChild(cp);
                  if (this.checkMasks()) {
                    var cpGroup = createNS('g');
                    cpGroup.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');
                    cpGroup.appendChild(this.layerElement);
                    this.transformedElement = cpGroup;
                    if (layerElementParent) {
                      layerElementParent.appendChild(this.transformedElement);
                    } else {
                      this.baseElement = this.transformedElement;
                    }
                  } else {
                    this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');
                  }
                }
                if (this.data.bm !== 0) {
                  this.setBlendMode();
                }
              },
              renderElement: function renderElement() {
                if (this.finalTransform._localMatMdf) {
                  this.transformedElement.setAttribute('transform', this.finalTransform.localMat.to2dCSS());
                }
                if (this.finalTransform._opMdf) {
                  this.transformedElement.setAttribute('opacity', this.finalTransform.localOpacity);
                }
              },
              destroyBaseElement: function destroyBaseElement() {
                this.layerElement = null;
                this.matteElement = null;
                this.maskManager.destroy();
              },
              getBaseElement: function getBaseElement() {
                if (this.data.hd) {
                  return null;
                }
                return this.baseElement;
              },
              createRenderableComponents: function createRenderableComponents() {
                this.maskManager = new MaskElement(this.data, this, this.globalData);
                this.renderableEffectsManager = new SVGEffects(this);
                this.searchEffectTransforms();
              },
              getMatte: function getMatte(matteType) {
                // This should not be a common case. But for backward compatibility, we'll create the matte object.
                // It solves animations that have two consecutive layers marked as matte masks.
                // Which is an undefined behavior in AE.
                if (!this.matteMasks) {
                  this.matteMasks = {};
                }
                if (!this.matteMasks[matteType]) {
                  var id = this.layerId + '_' + matteType;
                  var filId;
                  var fil;
                  var useElement;
                  var gg;
                  if (matteType === 1 || matteType === 3) {
                    var masker = createNS('mask');
                    masker.setAttribute('id', id);
                    masker.setAttribute('mask-type', matteType === 3 ? 'luminance' : 'alpha');
                    useElement = createNS('use');
                    useElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + this.layerId);
                    masker.appendChild(useElement);
                    this.globalData.defs.appendChild(masker);
                    if (!featureSupport.maskType && matteType === 1) {
                      masker.setAttribute('mask-type', 'luminance');
                      filId = createElementID();
                      fil = filtersFactory.createFilter(filId);
                      this.globalData.defs.appendChild(fil);
                      fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                      gg = createNS('g');
                      gg.appendChild(useElement);
                      masker.appendChild(gg);
                      gg.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');
                    }
                  } else if (matteType === 2) {
                    var maskGroup = createNS('mask');
                    maskGroup.setAttribute('id', id);
                    maskGroup.setAttribute('mask-type', 'alpha');
                    var maskGrouper = createNS('g');
                    maskGroup.appendChild(maskGrouper);
                    filId = createElementID();
                    fil = filtersFactory.createFilter(filId); /// /

                    var feCTr = createNS('feComponentTransfer');
                    feCTr.setAttribute('in', 'SourceGraphic');
                    fil.appendChild(feCTr);
                    var feFunc = createNS('feFuncA');
                    feFunc.setAttribute('type', 'table');
                    feFunc.setAttribute('tableValues', '1.0 0.0');
                    feCTr.appendChild(feFunc); /// /

                    this.globalData.defs.appendChild(fil);
                    var alphaRect = createNS('rect');
                    alphaRect.setAttribute('width', this.comp.data.w);
                    alphaRect.setAttribute('height', this.comp.data.h);
                    alphaRect.setAttribute('x', '0');
                    alphaRect.setAttribute('y', '0');
                    alphaRect.setAttribute('fill', '#ffffff');
                    alphaRect.setAttribute('opacity', '0');
                    maskGrouper.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');
                    maskGrouper.appendChild(alphaRect);
                    useElement = createNS('use');
                    useElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + this.layerId);
                    maskGrouper.appendChild(useElement);
                    if (!featureSupport.maskType) {
                      maskGroup.setAttribute('mask-type', 'luminance');
                      fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                      gg = createNS('g');
                      maskGrouper.appendChild(alphaRect);
                      gg.appendChild(this.layerElement);
                      maskGrouper.appendChild(gg);
                    }
                    this.globalData.defs.appendChild(maskGroup);
                  }
                  this.matteMasks[matteType] = id;
                }
                return this.matteMasks[matteType];
              },
              setMatte: function setMatte(id) {
                if (!this.matteElement) {
                  return;
                }
                this.matteElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');
              }
            };

            /**
             * @file
             * Handles AE's layer parenting property.
             *
             */
            function HierarchyElement() {}
            HierarchyElement.prototype = {
              /**
                 * @function
                 * Initializes hierarchy properties
                 *
                 */
              initHierarchy: function initHierarchy() {
                // element's parent list
                this.hierarchy = []; // if element is parent of another layer _isParent will be true

                this._isParent = false;
                this.checkParenting();
              },
              /**
                 * @function
                 * Sets layer's hierarchy.
                 * @param {array} hierarch
                 * layer's parent list
                 *
                 */
              setHierarchy: function setHierarchy(hierarchy) {
                this.hierarchy = hierarchy;
              },
              /**
                 * @function
                 * Sets layer as parent.
                 *
                 */
              setAsParent: function setAsParent() {
                this._isParent = true;
              },
              /**
                 * @function
                 * Searches layer's parenting chain
                 *
                 */
              checkParenting: function checkParenting() {
                if (this.data.parent !== undefined) {
                  this.comp.buildElementParenting(this, this.data.parent, []);
                }
              }
            };
            function RenderableDOMElement() {}
            (function () {
              var _prototype = {
                initElement: function initElement(data, globalData, comp) {
                  this.initFrame();
                  this.initBaseData(data, globalData, comp);
                  this.initTransform(data, globalData, comp);
                  this.initHierarchy();
                  this.initRenderable();
                  this.initRendererElement();
                  this.createContainerElements();
                  this.createRenderableComponents();
                  this.createContent();
                  this.hide();
                },
                hide: function hide() {
                  // console.log('HIDE', this);
                  if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                    var elem = this.baseElement || this.layerElement;
                    elem.style.display = 'none';
                    this.hidden = true;
                  }
                },
                show: function show() {
                  // console.log('SHOW', this);
                  if (this.isInRange && !this.isTransparent) {
                    if (!this.data.hd) {
                      var elem = this.baseElement || this.layerElement;
                      elem.style.display = 'block';
                    }
                    this.hidden = false;
                    this._isFirstFrame = true;
                  }
                },
                renderFrame: function renderFrame() {
                  // If it is exported as hidden (data.hd === true) no need to render
                  // If it is not visible no need to render
                  if (this.data.hd || this.hidden) {
                    return;
                  }
                  this.renderTransform();
                  this.renderRenderable();
                  this.renderLocalTransform();
                  this.renderElement();
                  this.renderInnerContent();
                  if (this._isFirstFrame) {
                    this._isFirstFrame = false;
                  }
                },
                renderInnerContent: function renderInnerContent() {},
                prepareFrame: function prepareFrame(num) {
                  this._mdf = false;
                  this.prepareRenderableFrame(num);
                  this.prepareProperties(num, this.isInRange);
                  this.checkTransparency();
                },
                destroy: function destroy() {
                  this.innerElem = null;
                  this.destroyBaseElement();
                }
              };
              extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
            })();
            function IImageElement(data, globalData, comp) {
              this.assetData = globalData.getAssetData(data.refId);
              if (this.assetData && this.assetData.sid) {
                this.assetData = globalData.slotManager.getProp(this.assetData);
              }
              this.initElement(data, globalData, comp);
              this.sourceRect = {
                top: 0,
                left: 0,
                width: this.assetData.w,
                height: this.assetData.h
              };
            }
            extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);
            IImageElement.prototype.createContent = function () {
              var assetPath = this.globalData.getAssetsPath(this.assetData);
              this.innerElem = createNS('image');
              this.innerElem.setAttribute('width', this.assetData.w + 'px');
              this.innerElem.setAttribute('height', this.assetData.h + 'px');
              this.innerElem.setAttribute('preserveAspectRatio', this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
              this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
              this.layerElement.appendChild(this.innerElem);
            };
            IImageElement.prototype.sourceRectAtTime = function () {
              return this.sourceRect;
            };
            function ProcessedElement(element, position) {
              this.elem = element;
              this.pos = position;
            }
            function IShapeElement() {}
            IShapeElement.prototype = {
              addShapeToModifiers: function addShapeToModifiers(data) {
                var i;
                var len = this.shapeModifiers.length;
                for (i = 0; i < len; i += 1) {
                  this.shapeModifiers[i].addShape(data);
                }
              },
              isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data) {
                var i = 0;
                var len = this.shapeModifiers.length;
                while (i < len) {
                  if (this.shapeModifiers[i].isAnimatedWithShape(data)) {
                    return true;
                  }
                }
                return false;
              },
              renderModifiers: function renderModifiers() {
                if (!this.shapeModifiers.length) {
                  return;
                }
                var i;
                var len = this.shapes.length;
                for (i = 0; i < len; i += 1) {
                  this.shapes[i].sh.reset();
                }
                len = this.shapeModifiers.length;
                var shouldBreakProcess;
                for (i = len - 1; i >= 0; i -= 1) {
                  shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame); // workaround to fix cases where a repeater resets the shape so the following processes get called twice
                  // TODO: find a better solution for this

                  if (shouldBreakProcess) {
                    break;
                  }
                }
              },
              searchProcessedElement: function searchProcessedElement(elem) {
                var elements = this.processedElements;
                var i = 0;
                var len = elements.length;
                while (i < len) {
                  if (elements[i].elem === elem) {
                    return elements[i].pos;
                  }
                  i += 1;
                }
                return 0;
              },
              addProcessedElement: function addProcessedElement(elem, pos) {
                var elements = this.processedElements;
                var i = elements.length;
                while (i) {
                  i -= 1;
                  if (elements[i].elem === elem) {
                    elements[i].pos = pos;
                    return;
                  }
                }
                elements.push(new ProcessedElement(elem, pos));
              },
              prepareFrame: function prepareFrame(num) {
                this.prepareRenderableFrame(num);
                this.prepareProperties(num, this.isInRange);
              }
            };
            var lineCapEnum = {
              1: 'butt',
              2: 'round',
              3: 'square'
            };
            var lineJoinEnum = {
              1: 'miter',
              2: 'round',
              3: 'bevel'
            };
            function SVGShapeData(transformers, level, shape) {
              this.caches = [];
              this.styles = [];
              this.transformers = transformers;
              this.lStr = '';
              this.sh = shape;
              this.lvl = level; // TODO find if there are some cases where _isAnimated can be false.
              // For now, since shapes add up with other shapes. They have to be calculated every time.
              // One way of finding out is checking if all styles associated to this shape depend only of this shape

              this._isAnimated = !!shape.k; // TODO: commenting this for now since all shapes are animated

              var i = 0;
              var len = transformers.length;
              while (i < len) {
                if (transformers[i].mProps.dynamicProperties.length) {
                  this._isAnimated = true;
                  break;
                }
                i += 1;
              }
            }
            SVGShapeData.prototype.setAsAnimated = function () {
              this._isAnimated = true;
            };
            function SVGStyleData(data, level) {
              this.data = data;
              this.type = data.ty;
              this.d = '';
              this.lvl = level;
              this._mdf = false;
              this.closed = data.hd === true;
              this.pElem = createNS('path');
              this.msElem = null;
            }
            SVGStyleData.prototype.reset = function () {
              this.d = '';
              this._mdf = false;
            };
            function DashProperty(elem, data, renderer, container) {
              this.elem = elem;
              this.frameId = -1;
              this.dataProps = createSizedArray(data.length);
              this.renderer = renderer;
              this.k = false;
              this.dashStr = '';
              this.dashArray = createTypedArray('float32', data.length ? data.length - 1 : 0);
              this.dashoffset = createTypedArray('float32', 1);
              this.initDynamicPropertyContainer(container);
              var i;
              var len = data.length || 0;
              var prop;
              for (i = 0; i < len; i += 1) {
                prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);
                this.k = prop.k || this.k;
                this.dataProps[i] = {
                  n: data[i].n,
                  p: prop
                };
              }
              if (!this.k) {
                this.getValue(true);
              }
              this._isAnimated = this.k;
            }
            DashProperty.prototype.getValue = function (forceRender) {
              if (this.elem.globalData.frameId === this.frameId && !forceRender) {
                return;
              }
              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();
              this._mdf = this._mdf || forceRender;
              if (this._mdf) {
                var i = 0;
                var len = this.dataProps.length;
                if (this.renderer === 'svg') {
                  this.dashStr = '';
                }
                for (i = 0; i < len; i += 1) {
                  if (this.dataProps[i].n !== 'o') {
                    if (this.renderer === 'svg') {
                      this.dashStr += ' ' + this.dataProps[i].p.v;
                    } else {
                      this.dashArray[i] = this.dataProps[i].p.v;
                    }
                  } else {
                    this.dashoffset[0] = this.dataProps[i].p.v;
                  }
                }
              }
            };
            extendPrototype([DynamicPropertyContainer], DashProperty);
            function SVGStrokeStyleData(elem, data, styleOb) {
              this.initDynamicPropertyContainer(elem);
              this.getValue = this.iterateDynamicProperties;
              this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
              this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
              this.d = new DashProperty(elem, data.d || {}, 'svg', this);
              this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
              this.style = styleOb;
              this._isAnimated = !!this._isAnimated;
            }
            extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
            function SVGFillStyleData(elem, data, styleOb) {
              this.initDynamicPropertyContainer(elem);
              this.getValue = this.iterateDynamicProperties;
              this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
              this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
              this.style = styleOb;
            }
            extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
            function SVGNoStyleData(elem, data, styleOb) {
              this.initDynamicPropertyContainer(elem);
              this.getValue = this.iterateDynamicProperties;
              this.style = styleOb;
            }
            extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
            function GradientProperty(elem, data, container) {
              this.data = data;
              this.c = createTypedArray('uint8c', data.p * 4);
              var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4;
              this.o = createTypedArray('float32', cLength);
              this._cmdf = false;
              this._omdf = false;
              this._collapsable = this.checkCollapsable();
              this._hasOpacity = cLength;
              this.initDynamicPropertyContainer(container);
              this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);
              this.k = this.prop.k;
              this.getValue(true);
            }
            GradientProperty.prototype.comparePoints = function (values, points) {
              var i = 0;
              var len = this.o.length / 2;
              var diff;
              while (i < len) {
                diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);
                if (diff > 0.01) {
                  return false;
                }
                i += 1;
              }
              return true;
            };
            GradientProperty.prototype.checkCollapsable = function () {
              if (this.o.length / 2 !== this.c.length / 4) {
                return false;
              }
              if (this.data.k.k[0].s) {
                var i = 0;
                var len = this.data.k.k.length;
                while (i < len) {
                  if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {
                    return false;
                  }
                  i += 1;
                }
              } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
                return false;
              }
              return true;
            };
            GradientProperty.prototype.getValue = function (forceRender) {
              this.prop.getValue();
              this._mdf = false;
              this._cmdf = false;
              this._omdf = false;
              if (this.prop._mdf || forceRender) {
                var i;
                var len = this.data.p * 4;
                var mult;
                var val;
                for (i = 0; i < len; i += 1) {
                  mult = i % 4 === 0 ? 100 : 255;
                  val = Math.round(this.prop.v[i] * mult);
                  if (this.c[i] !== val) {
                    this.c[i] = val;
                    this._cmdf = !forceRender;
                  }
                }
                if (this.o.length) {
                  len = this.prop.v.length;
                  for (i = this.data.p * 4; i < len; i += 1) {
                    mult = i % 2 === 0 ? 100 : 1;
                    val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];
                    if (this.o[i - this.data.p * 4] !== val) {
                      this.o[i - this.data.p * 4] = val;
                      this._omdf = !forceRender;
                    }
                  }
                }
                this._mdf = !forceRender;
              }
            };
            extendPrototype([DynamicPropertyContainer], GradientProperty);
            function SVGGradientFillStyleData(elem, data, styleOb) {
              this.initDynamicPropertyContainer(elem);
              this.getValue = this.iterateDynamicProperties;
              this.initGradientData(elem, data, styleOb);
            }
            SVGGradientFillStyleData.prototype.initGradientData = function (elem, data, styleOb) {
              this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
              this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);
              this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);
              this.h = PropertyFactory.getProp(elem, data.h || {
                k: 0
              }, 0, 0.01, this);
              this.a = PropertyFactory.getProp(elem, data.a || {
                k: 0
              }, 0, degToRads, this);
              this.g = new GradientProperty(elem, data.g, this);
              this.style = styleOb;
              this.stops = [];
              this.setGradientData(styleOb.pElem, data);
              this.setGradientOpacity(data, styleOb);
              this._isAnimated = !!this._isAnimated;
            };
            SVGGradientFillStyleData.prototype.setGradientData = function (pathElement, data) {
              var gradientId = createElementID();
              var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
              gfill.setAttribute('id', gradientId);
              gfill.setAttribute('spreadMethod', 'pad');
              gfill.setAttribute('gradientUnits', 'userSpaceOnUse');
              var stops = [];
              var stop;
              var j;
              var jLen;
              jLen = data.g.p * 4;
              for (j = 0; j < jLen; j += 4) {
                stop = createNS('stop');
                gfill.appendChild(stop);
                stops.push(stop);
              }
              pathElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + gradientId + ')');
              this.gf = gfill;
              this.cst = stops;
            };
            SVGGradientFillStyleData.prototype.setGradientOpacity = function (data, styleOb) {
              if (this.g._hasOpacity && !this.g._collapsable) {
                var stop;
                var j;
                var jLen;
                var mask = createNS('mask');
                var maskElement = createNS('path');
                mask.appendChild(maskElement);
                var opacityId = createElementID();
                var maskId = createElementID();
                mask.setAttribute('id', maskId);
                var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
                opFill.setAttribute('id', opacityId);
                opFill.setAttribute('spreadMethod', 'pad');
                opFill.setAttribute('gradientUnits', 'userSpaceOnUse');
                jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
                var stops = this.stops;
                for (j = data.g.p * 4; j < jLen; j += 2) {
                  stop = createNS('stop');
                  stop.setAttribute('stop-color', 'rgb(255,255,255)');
                  opFill.appendChild(stop);
                  stops.push(stop);
                }
                maskElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + opacityId + ')');
                if (data.ty === 'gs') {
                  maskElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
                  maskElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);
                  if (data.lj === 1) {
                    maskElement.setAttribute('stroke-miterlimit', data.ml);
                  }
                }
                this.of = opFill;
                this.ms = mask;
                this.ost = stops;
                this.maskId = maskId;
                styleOb.msElem = maskElement;
              }
            };
            extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
            function SVGGradientStrokeStyleData(elem, data, styleOb) {
              this.initDynamicPropertyContainer(elem);
              this.getValue = this.iterateDynamicProperties;
              this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
              this.d = new DashProperty(elem, data.d || {}, 'svg', this);
              this.initGradientData(elem, data, styleOb);
              this._isAnimated = !!this._isAnimated;
            }
            extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
            function ShapeGroupData() {
              this.it = [];
              this.prevViewData = [];
              this.gr = createNS('g');
            }
            function SVGTransformData(mProps, op, container) {
              this.transform = {
                mProps: mProps,
                op: op,
                container: container
              };
              this.elements = [];
              this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
            }
            var buildShapeString = function buildShapeString(pathNodes, length, closed, mat) {
              if (length === 0) {
                return '';
              }
              var _o = pathNodes.o;
              var _i = pathNodes.i;
              var _v = pathNodes.v;
              var i;
              var shapeString = ' M' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
              for (i = 1; i < length; i += 1) {
                shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[i][0], _i[i][1]) + ' ' + mat.applyToPointStringified(_v[i][0], _v[i][1]);
              }
              if (closed && length) {
                shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[0][0], _i[0][1]) + ' ' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
                shapeString += 'z';
              }
              return shapeString;
            };
            var SVGElementsRenderer = function () {
              var _identityMatrix = new Matrix();
              var _matrixHelper = new Matrix();
              var ob = {
                createRenderFunction: createRenderFunction
              };
              function createRenderFunction(data) {
                switch (data.ty) {
                  case 'fl':
                    return renderFill;
                  case 'gf':
                    return renderGradient;
                  case 'gs':
                    return renderGradientStroke;
                  case 'st':
                    return renderStroke;
                  case 'sh':
                  case 'el':
                  case 'rc':
                  case 'sr':
                    return renderPath;
                  case 'tr':
                    return renderContentTransform;
                  case 'no':
                    return renderNoop;
                  default:
                    return null;
                }
              }
              function renderContentTransform(styleData, itemData, isFirstFrame) {
                if (isFirstFrame || itemData.transform.op._mdf) {
                  itemData.transform.container.setAttribute('opacity', itemData.transform.op.v);
                }
                if (isFirstFrame || itemData.transform.mProps._mdf) {
                  itemData.transform.container.setAttribute('transform', itemData.transform.mProps.v.to2dCSS());
                }
              }
              function renderNoop() {}
              function renderPath(styleData, itemData, isFirstFrame) {
                var j;
                var jLen;
                var pathStringTransformed;
                var redraw;
                var pathNodes;
                var l;
                var lLen = itemData.styles.length;
                var lvl = itemData.lvl;
                var paths;
                var mat;
                var iterations;
                var k;
                for (l = 0; l < lLen; l += 1) {
                  redraw = itemData.sh._mdf || isFirstFrame;
                  if (itemData.styles[l].lvl < lvl) {
                    mat = _matrixHelper.reset();
                    iterations = lvl - itemData.styles[l].lvl;
                    k = itemData.transformers.length - 1;
                    while (!redraw && iterations > 0) {
                      redraw = itemData.transformers[k].mProps._mdf || redraw;
                      iterations -= 1;
                      k -= 1;
                    }
                    if (redraw) {
                      iterations = lvl - itemData.styles[l].lvl;
                      k = itemData.transformers.length - 1;
                      while (iterations > 0) {
                        mat.multiply(itemData.transformers[k].mProps.v);
                        iterations -= 1;
                        k -= 1;
                      }
                    }
                  } else {
                    mat = _identityMatrix;
                  }
                  paths = itemData.sh.paths;
                  jLen = paths._length;
                  if (redraw) {
                    pathStringTransformed = '';
                    for (j = 0; j < jLen; j += 1) {
                      pathNodes = paths.shapes[j];
                      if (pathNodes && pathNodes._length) {
                        pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
                      }
                    }
                    itemData.caches[l] = pathStringTransformed;
                  } else {
                    pathStringTransformed = itemData.caches[l];
                  }
                  itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;
                  itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
                }
              }
              function renderFill(styleData, itemData, isFirstFrame) {
                var styleElem = itemData.style;
                if (itemData.c._mdf || isFirstFrame) {
                  styleElem.pElem.setAttribute('fill', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
                }
                if (itemData.o._mdf || isFirstFrame) {
                  styleElem.pElem.setAttribute('fill-opacity', itemData.o.v);
                }
              }
              function renderGradientStroke(styleData, itemData, isFirstFrame) {
                renderGradient(styleData, itemData, isFirstFrame);
                renderStroke(styleData, itemData, isFirstFrame);
              }
              function renderGradient(styleData, itemData, isFirstFrame) {
                var gfill = itemData.gf;
                var hasOpacity = itemData.g._hasOpacity;
                var pt1 = itemData.s.v;
                var pt2 = itemData.e.v;
                if (itemData.o._mdf || isFirstFrame) {
                  var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';
                  itemData.style.pElem.setAttribute(attr, itemData.o.v);
                }
                if (itemData.s._mdf || isFirstFrame) {
                  var attr1 = styleData.t === 1 ? 'x1' : 'cx';
                  var attr2 = attr1 === 'x1' ? 'y1' : 'cy';
                  gfill.setAttribute(attr1, pt1[0]);
                  gfill.setAttribute(attr2, pt1[1]);
                  if (hasOpacity && !itemData.g._collapsable) {
                    itemData.of.setAttribute(attr1, pt1[0]);
                    itemData.of.setAttribute(attr2, pt1[1]);
                  }
                }
                var stops;
                var i;
                var len;
                var stop;
                if (itemData.g._cmdf || isFirstFrame) {
                  stops = itemData.cst;
                  var cValues = itemData.g.c;
                  len = stops.length;
                  for (i = 0; i < len; i += 1) {
                    stop = stops[i];
                    stop.setAttribute('offset', cValues[i * 4] + '%');
                    stop.setAttribute('stop-color', 'rgb(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ')');
                  }
                }
                if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
                  var oValues = itemData.g.o;
                  if (itemData.g._collapsable) {
                    stops = itemData.cst;
                  } else {
                    stops = itemData.ost;
                  }
                  len = stops.length;
                  for (i = 0; i < len; i += 1) {
                    stop = stops[i];
                    if (!itemData.g._collapsable) {
                      stop.setAttribute('offset', oValues[i * 2] + '%');
                    }
                    stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);
                  }
                }
                if (styleData.t === 1) {
                  if (itemData.e._mdf || isFirstFrame) {
                    gfill.setAttribute('x2', pt2[0]);
                    gfill.setAttribute('y2', pt2[1]);
                    if (hasOpacity && !itemData.g._collapsable) {
                      itemData.of.setAttribute('x2', pt2[0]);
                      itemData.of.setAttribute('y2', pt2[1]);
                    }
                  }
                } else {
                  var rad;
                  if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
                    rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                    gfill.setAttribute('r', rad);
                    if (hasOpacity && !itemData.g._collapsable) {
                      itemData.of.setAttribute('r', rad);
                    }
                  }
                  if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
                    if (!rad) {
                      rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                    }
                    var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
                    var percent = itemData.h.v;
                    if (percent >= 1) {
                      percent = 0.99;
                    } else if (percent <= -1) {
                      percent = -0.99;
                    }
                    var dist = rad * percent;
                    var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
                    var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
                    gfill.setAttribute('fx', x);
                    gfill.setAttribute('fy', y);
                    if (hasOpacity && !itemData.g._collapsable) {
                      itemData.of.setAttribute('fx', x);
                      itemData.of.setAttribute('fy', y);
                    }
                  } // gfill.setAttribute('fy','200');
                }
              }
              function renderStroke(styleData, itemData, isFirstFrame) {
                var styleElem = itemData.style;
                var d = itemData.d;
                if (d && (d._mdf || isFirstFrame) && d.dashStr) {
                  styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);
                  styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);
                }
                if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
                  styleElem.pElem.setAttribute('stroke', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
                }
                if (itemData.o._mdf || isFirstFrame) {
                  styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);
                }
                if (itemData.w._mdf || isFirstFrame) {
                  styleElem.pElem.setAttribute('stroke-width', itemData.w.v);
                  if (styleElem.msElem) {
                    styleElem.msElem.setAttribute('stroke-width', itemData.w.v);
                  }
                }
              }
              return ob;
            }();
            function SVGShapeElement(data, globalData, comp) {
              // List of drawable elements
              this.shapes = []; // Full shape data

              this.shapesData = data.shapes; // List of styles that will be applied to shapes

              this.stylesList = []; // List of modifiers that will be applied to shapes

              this.shapeModifiers = []; // List of items in shape tree

              this.itemsData = []; // List of items in previous shape tree

              this.processedElements = []; // List of animated components

              this.animatedContents = [];
              this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
              // List of elements that have been created

              this.prevViewData = []; // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
            }
            extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);
            SVGShapeElement.prototype.initSecondaryElement = function () {};
            SVGShapeElement.prototype.identityMatrix = new Matrix();
            SVGShapeElement.prototype.buildExpressionInterface = function () {};
            SVGShapeElement.prototype.createContent = function () {
              this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
              this.filterUniqueShapes();
            };
            /*
            This method searches for multiple shapes that affect a single element and one of them is animated
            */

            SVGShapeElement.prototype.filterUniqueShapes = function () {
              var i;
              var len = this.shapes.length;
              var shape;
              var j;
              var jLen = this.stylesList.length;
              var style;
              var tempShapes = [];
              var areAnimated = false;
              for (j = 0; j < jLen; j += 1) {
                style = this.stylesList[j];
                areAnimated = false;
                tempShapes.length = 0;
                for (i = 0; i < len; i += 1) {
                  shape = this.shapes[i];
                  if (shape.styles.indexOf(style) !== -1) {
                    tempShapes.push(shape);
                    areAnimated = shape._isAnimated || areAnimated;
                  }
                }
                if (tempShapes.length > 1 && areAnimated) {
                  this.setShapesAsAnimated(tempShapes);
                }
              }
            };
            SVGShapeElement.prototype.setShapesAsAnimated = function (shapes) {
              var i;
              var len = shapes.length;
              for (i = 0; i < len; i += 1) {
                shapes[i].setAsAnimated();
              }
            };
            SVGShapeElement.prototype.createStyleElement = function (data, level) {
              // TODO: prevent drawing of hidden styles
              var elementData;
              var styleOb = new SVGStyleData(data, level);
              var pathElement = styleOb.pElem;
              if (data.ty === 'st') {
                elementData = new SVGStrokeStyleData(this, data, styleOb);
              } else if (data.ty === 'fl') {
                elementData = new SVGFillStyleData(this, data, styleOb);
              } else if (data.ty === 'gf' || data.ty === 'gs') {
                var GradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
                elementData = new GradientConstructor(this, data, styleOb);
                this.globalData.defs.appendChild(elementData.gf);
                if (elementData.maskId) {
                  this.globalData.defs.appendChild(elementData.ms);
                  this.globalData.defs.appendChild(elementData.of);
                  pathElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + elementData.maskId + ')');
                }
              } else if (data.ty === 'no') {
                elementData = new SVGNoStyleData(this, data, styleOb);
              }
              if (data.ty === 'st' || data.ty === 'gs') {
                pathElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
                pathElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);
                pathElement.setAttribute('fill-opacity', '0');
                if (data.lj === 1) {
                  pathElement.setAttribute('stroke-miterlimit', data.ml);
                }
              }
              if (data.r === 2) {
                pathElement.setAttribute('fill-rule', 'evenodd');
              }
              if (data.ln) {
                pathElement.setAttribute('id', data.ln);
              }
              if (data.cl) {
                pathElement.setAttribute('class', data.cl);
              }
              if (data.bm) {
                pathElement.style['mix-blend-mode'] = getBlendMode(data.bm);
              }
              this.stylesList.push(styleOb);
              this.addToAnimatedContents(data, elementData);
              return elementData;
            };
            SVGShapeElement.prototype.createGroupElement = function (data) {
              var elementData = new ShapeGroupData();
              if (data.ln) {
                elementData.gr.setAttribute('id', data.ln);
              }
              if (data.cl) {
                elementData.gr.setAttribute('class', data.cl);
              }
              if (data.bm) {
                elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm);
              }
              return elementData;
            };
            SVGShapeElement.prototype.createTransformElement = function (data, container) {
              var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);
              var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
              this.addToAnimatedContents(data, elementData);
              return elementData;
            };
            SVGShapeElement.prototype.createShapeElement = function (data, ownTransformers, level) {
              var ty = 4;
              if (data.ty === 'rc') {
                ty = 5;
              } else if (data.ty === 'el') {
                ty = 6;
              } else if (data.ty === 'sr') {
                ty = 7;
              }
              var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);
              var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
              this.shapes.push(elementData);
              this.addShapeToModifiers(elementData);
              this.addToAnimatedContents(data, elementData);
              return elementData;
            };
            SVGShapeElement.prototype.addToAnimatedContents = function (data, element) {
              var i = 0;
              var len = this.animatedContents.length;
              while (i < len) {
                if (this.animatedContents[i].element === element) {
                  return;
                }
                i += 1;
              }
              this.animatedContents.push({
                fn: SVGElementsRenderer.createRenderFunction(data),
                element: element,
                data: data
              });
            };
            SVGShapeElement.prototype.setElementStyles = function (elementData) {
              var arr = elementData.styles;
              var j;
              var jLen = this.stylesList.length;
              for (j = 0; j < jLen; j += 1) {
                if (!this.stylesList[j].closed) {
                  arr.push(this.stylesList[j]);
                }
              }
            };
            SVGShapeElement.prototype.reloadShapes = function () {
              this._isFirstFrame = true;
              var i;
              var len = this.itemsData.length;
              for (i = 0; i < len; i += 1) {
                this.prevViewData[i] = this.itemsData[i];
              }
              this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
              this.filterUniqueShapes();
              len = this.dynamicProperties.length;
              for (i = 0; i < len; i += 1) {
                this.dynamicProperties[i].getValue();
              }
              this.renderModifiers();
            };
            SVGShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, container, level, transformers, render) {
              var ownTransformers = [].concat(transformers);
              var i;
              var len = arr.length - 1;
              var j;
              var jLen;
              var ownStyles = [];
              var ownModifiers = [];
              var currentTransform;
              var modifier;
              var processedPos;
              for (i = len; i >= 0; i -= 1) {
                processedPos = this.searchProcessedElement(arr[i]);
                if (!processedPos) {
                  arr[i]._render = render;
                } else {
                  itemsData[i] = prevViewData[processedPos - 1];
                }
                if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs' || arr[i].ty === 'no') {
                  if (!processedPos) {
                    itemsData[i] = this.createStyleElement(arr[i], level);
                  } else {
                    itemsData[i].style.closed = false;
                  }
                  if (arr[i]._render) {
                    if (itemsData[i].style.pElem.parentNode !== container) {
                      container.appendChild(itemsData[i].style.pElem);
                    }
                  }
                  ownStyles.push(itemsData[i].style);
                } else if (arr[i].ty === 'gr') {
                  if (!processedPos) {
                    itemsData[i] = this.createGroupElement(arr[i]);
                  } else {
                    jLen = itemsData[i].it.length;
                    for (j = 0; j < jLen; j += 1) {
                      itemsData[i].prevViewData[j] = itemsData[i].it[j];
                    }
                  }
                  this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);
                  if (arr[i]._render) {
                    if (itemsData[i].gr.parentNode !== container) {
                      container.appendChild(itemsData[i].gr);
                    }
                  }
                } else if (arr[i].ty === 'tr') {
                  if (!processedPos) {
                    itemsData[i] = this.createTransformElement(arr[i], container);
                  }
                  currentTransform = itemsData[i].transform;
                  ownTransformers.push(currentTransform);
                } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
                  if (!processedPos) {
                    itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
                  }
                  this.setElementStyles(itemsData[i]);
                } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'ms' || arr[i].ty === 'pb' || arr[i].ty === 'zz' || arr[i].ty === 'op') {
                  if (!processedPos) {
                    modifier = ShapeModifiers.getModifier(arr[i].ty);
                    modifier.init(this, arr[i]);
                    itemsData[i] = modifier;
                    this.shapeModifiers.push(modifier);
                  } else {
                    modifier = itemsData[i];
                    modifier.closed = false;
                  }
                  ownModifiers.push(modifier);
                } else if (arr[i].ty === 'rp') {
                  if (!processedPos) {
                    modifier = ShapeModifiers.getModifier(arr[i].ty);
                    itemsData[i] = modifier;
                    modifier.init(this, arr, i, itemsData);
                    this.shapeModifiers.push(modifier);
                    render = false;
                  } else {
                    modifier = itemsData[i];
                    modifier.closed = true;
                  }
                  ownModifiers.push(modifier);
                }
                this.addProcessedElement(arr[i], i + 1);
              }
              len = ownStyles.length;
              for (i = 0; i < len; i += 1) {
                ownStyles[i].closed = true;
              }
              len = ownModifiers.length;
              for (i = 0; i < len; i += 1) {
                ownModifiers[i].closed = true;
              }
            };
            SVGShapeElement.prototype.renderInnerContent = function () {
              this.renderModifiers();
              var i;
              var len = this.stylesList.length;
              for (i = 0; i < len; i += 1) {
                this.stylesList[i].reset();
              }
              this.renderShape();
              for (i = 0; i < len; i += 1) {
                if (this.stylesList[i]._mdf || this._isFirstFrame) {
                  if (this.stylesList[i].msElem) {
                    this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d); // Adding M0 0 fixes same mask bug on all browsers

                    this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;
                  }
                  this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');
                }
              }
            };
            SVGShapeElement.prototype.renderShape = function () {
              var i;
              var len = this.animatedContents.length;
              var animatedContent;
              for (i = 0; i < len; i += 1) {
                animatedContent = this.animatedContents[i];
                if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
                  animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
                }
              }
            };
            SVGShapeElement.prototype.destroy = function () {
              this.destroyBaseElement();
              this.shapesData = null;
              this.itemsData = null;
            };
            function LetterProps(o, sw, sc, fc, m, p) {
              this.o = o;
              this.sw = sw;
              this.sc = sc;
              this.fc = fc;
              this.m = m;
              this.p = p;
              this._mdf = {
                o: true,
                sw: !!sw,
                sc: !!sc,
                fc: !!fc,
                m: true,
                p: true
              };
            }
            LetterProps.prototype.update = function (o, sw, sc, fc, m, p) {
              this._mdf.o = false;
              this._mdf.sw = false;
              this._mdf.sc = false;
              this._mdf.fc = false;
              this._mdf.m = false;
              this._mdf.p = false;
              var updated = false;
              if (this.o !== o) {
                this.o = o;
                this._mdf.o = true;
                updated = true;
              }
              if (this.sw !== sw) {
                this.sw = sw;
                this._mdf.sw = true;
                updated = true;
              }
              if (this.sc !== sc) {
                this.sc = sc;
                this._mdf.sc = true;
                updated = true;
              }
              if (this.fc !== fc) {
                this.fc = fc;
                this._mdf.fc = true;
                updated = true;
              }
              if (this.m !== m) {
                this.m = m;
                this._mdf.m = true;
                updated = true;
              }
              if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
                this.p = p;
                this._mdf.p = true;
                updated = true;
              }
              return updated;
            };
            function TextProperty(elem, data) {
              this._frameId = initialDefaultFrame;
              this.pv = '';
              this.v = '';
              this.kf = false;
              this._isFirstFrame = true;
              this._mdf = false;
              if (data.d && data.d.sid) {
                data.d = elem.globalData.slotManager.getProp(data.d);
              }
              this.data = data;
              this.elem = elem;
              this.comp = this.elem.comp;
              this.keysIndex = 0;
              this.canResize = false;
              this.minimumFontSize = 1;
              this.effectsSequence = [];
              this.currentData = {
                ascent: 0,
                boxWidth: this.defaultBoxWidth,
                f: '',
                fStyle: '',
                fWeight: '',
                fc: '',
                j: '',
                justifyOffset: '',
                l: [],
                lh: 0,
                lineWidths: [],
                ls: '',
                of: '',
                s: '',
                sc: '',
                sw: 0,
                t: 0,
                tr: 0,
                sz: 0,
                ps: null,
                fillColorAnim: false,
                strokeColorAnim: false,
                strokeWidthAnim: false,
                yOffset: 0,
                finalSize: 0,
                finalText: [],
                finalLineHeight: 0,
                __complete: false
              };
              this.copyData(this.currentData, this.data.d.k[0].s);
              if (!this.searchProperty()) {
                this.completeTextData(this.currentData);
              }
            }
            TextProperty.prototype.defaultBoxWidth = [0, 0];
            TextProperty.prototype.copyData = function (obj, data) {
              for (var s in data) {
                if (Object.prototype.hasOwnProperty.call(data, s)) {
                  obj[s] = data[s];
                }
              }
              return obj;
            };
            TextProperty.prototype.setCurrentData = function (data) {
              if (!data.__complete) {
                this.completeTextData(data);
              }
              this.currentData = data;
              this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
              this._mdf = true;
            };
            TextProperty.prototype.searchProperty = function () {
              return this.searchKeyframes();
            };
            TextProperty.prototype.searchKeyframes = function () {
              this.kf = this.data.d.k.length > 1;
              if (this.kf) {
                this.addEffect(this.getKeyframeValue.bind(this));
              }
              return this.kf;
            };
            TextProperty.prototype.addEffect = function (effectFunction) {
              this.effectsSequence.push(effectFunction);
              this.elem.addDynamicProperty(this);
            };
            TextProperty.prototype.getValue = function (_finalValue) {
              if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
                return;
              }
              this.currentData.t = this.data.d.k[this.keysIndex].s.t;
              var currentValue = this.currentData;
              var currentIndex = this.keysIndex;
              if (this.lock) {
                this.setCurrentData(this.currentData);
                return;
              }
              this.lock = true;
              this._mdf = false;
              var i;
              var len = this.effectsSequence.length;
              var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
              for (i = 0; i < len; i += 1) {
                // Checking if index changed to prevent creating a new object every time the expression updates.
                if (currentIndex !== this.keysIndex) {
                  finalValue = this.effectsSequence[i](finalValue, finalValue.t);
                } else {
                  finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
                }
              }
              if (currentValue !== finalValue) {
                this.setCurrentData(finalValue);
              }
              this.v = this.currentData;
              this.pv = this.v;
              this.lock = false;
              this.frameId = this.elem.globalData.frameId;
            };
            TextProperty.prototype.getKeyframeValue = function () {
              var textKeys = this.data.d.k;
              var frameNum = this.elem.comp.renderedFrame;
              var i = 0;
              var len = textKeys.length;
              while (i <= len - 1) {
                if (i === len - 1 || textKeys[i + 1].t > frameNum) {
                  break;
                }
                i += 1;
              }
              if (this.keysIndex !== i) {
                this.keysIndex = i;
              }
              return this.data.d.k[this.keysIndex].s;
            };
            TextProperty.prototype.buildFinalText = function (text) {
              var charactersArray = [];
              var i = 0;
              var len = text.length;
              var charCode;
              var secondCharCode;
              var shouldCombine = false;
              var shouldCombineNext = false;
              var currentChars = '';
              while (i < len) {
                shouldCombine = shouldCombineNext;
                shouldCombineNext = false;
                charCode = text.charCodeAt(i);
                currentChars = text.charAt(i);
                if (FontManager.isCombinedCharacter(charCode)) {
                  shouldCombine = true; // It's a potential surrogate pair (this is the High surrogate)
                } else if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                  if (FontManager.isRegionalFlag(text, i)) {
                    currentChars = text.substr(i, 14);
                  } else {
                    secondCharCode = text.charCodeAt(i + 1); // It's a surrogate pair (this is the Low surrogate)

                    if (secondCharCode >= 0xDC00 && secondCharCode <= 0xDFFF) {
                      if (FontManager.isModifier(charCode, secondCharCode)) {
                        currentChars = text.substr(i, 2);
                        shouldCombine = true;
                      } else if (FontManager.isFlagEmoji(text.substr(i, 4))) {
                        currentChars = text.substr(i, 4);
                      } else {
                        currentChars = text.substr(i, 2);
                      }
                    }
                  }
                } else if (charCode > 0xDBFF) {
                  secondCharCode = text.charCodeAt(i + 1);
                  if (FontManager.isVariationSelector(charCode)) {
                    shouldCombine = true;
                  }
                } else if (FontManager.isZeroWidthJoiner(charCode)) {
                  shouldCombine = true;
                  shouldCombineNext = true;
                }
                if (shouldCombine) {
                  charactersArray[charactersArray.length - 1] += currentChars;
                  shouldCombine = false;
                } else {
                  charactersArray.push(currentChars);
                }
                i += currentChars.length;
              }
              return charactersArray;
            };
            TextProperty.prototype.completeTextData = function (documentData) {
              documentData.__complete = true;
              var fontManager = this.elem.globalData.fontManager;
              var data = this.data;
              var letters = [];
              var i;
              var len;
              var newLineFlag;
              var index = 0;
              var val;
              var anchorGrouping = data.m.g;
              var currentSize = 0;
              var currentPos = 0;
              var currentLine = 0;
              var lineWidths = [];
              var lineWidth = 0;
              var maxLineWidth = 0;
              var j;
              var jLen;
              var fontData = fontManager.getFontByName(documentData.f);
              var charData;
              var cLength = 0;
              var fontProps = getFontProperties(fontData);
              documentData.fWeight = fontProps.weight;
              documentData.fStyle = fontProps.style;
              documentData.finalSize = documentData.s;
              documentData.finalText = this.buildFinalText(documentData.t);
              len = documentData.finalText.length;
              documentData.finalLineHeight = documentData.lh;
              var trackingOffset = documentData.tr / 1000 * documentData.finalSize;
              var charCode;
              if (documentData.sz) {
                var flag = true;
                var boxWidth = documentData.sz[0];
                var boxHeight = documentData.sz[1];
                var currentHeight;
                var finalText;
                while (flag) {
                  finalText = this.buildFinalText(documentData.t);
                  currentHeight = 0;
                  lineWidth = 0;
                  len = finalText.length;
                  trackingOffset = documentData.tr / 1000 * documentData.finalSize;
                  var lastSpaceIndex = -1;
                  for (i = 0; i < len; i += 1) {
                    charCode = finalText[i].charCodeAt(0);
                    newLineFlag = false;
                    if (finalText[i] === ' ') {
                      lastSpaceIndex = i;
                    } else if (charCode === 13 || charCode === 3) {
                      lineWidth = 0;
                      newLineFlag = true;
                      currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                    }
                    if (fontManager.chars) {
                      charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
                      cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
                    } else {
                      // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
                      cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
                    }
                    if (lineWidth + cLength > boxWidth && finalText[i] !== ' ') {
                      if (lastSpaceIndex === -1) {
                        len += 1;
                      } else {
                        i = lastSpaceIndex;
                      }
                      currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                      finalText.splice(i, lastSpaceIndex === i ? 1 : 0, '\r'); // finalText = finalText.substr(0,i) + "\r" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);

                      lastSpaceIndex = -1;
                      lineWidth = 0;
                    } else {
                      lineWidth += cLength;
                      lineWidth += trackingOffset;
                    }
                  }
                  currentHeight += fontData.ascent * documentData.finalSize / 100;
                  if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
                    documentData.finalSize -= 1;
                    documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
                  } else {
                    documentData.finalText = finalText;
                    len = documentData.finalText.length;
                    flag = false;
                  }
                }
              }
              lineWidth = -trackingOffset;
              cLength = 0;
              var uncollapsedSpaces = 0;
              var currentChar;
              for (i = 0; i < len; i += 1) {
                newLineFlag = false;
                currentChar = documentData.finalText[i];
                charCode = currentChar.charCodeAt(0);
                if (charCode === 13 || charCode === 3) {
                  uncollapsedSpaces = 0;
                  lineWidths.push(lineWidth);
                  maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
                  lineWidth = -2 * trackingOffset;
                  val = '';
                  newLineFlag = true;
                  currentLine += 1;
                } else {
                  val = currentChar;
                }
                if (fontManager.chars) {
                  charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
                  cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
                } else {
                  // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);
                  // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
                  cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
                } //

                if (currentChar === ' ') {
                  uncollapsedSpaces += cLength + trackingOffset;
                } else {
                  lineWidth += cLength + trackingOffset + uncollapsedSpaces;
                  uncollapsedSpaces = 0;
                }
                letters.push({
                  l: cLength,
                  an: cLength,
                  add: currentSize,
                  n: newLineFlag,
                  anIndexes: [],
                  val: val,
                  line: currentLine,
                  animatorJustifyOffset: 0
                });
                if (anchorGrouping == 2) {
                  // eslint-disable-line eqeqeq
                  currentSize += cLength;
                  if (val === '' || val === ' ' || i === len - 1) {
                    if (val === '' || val === ' ') {
                      currentSize -= cLength;
                    }
                    while (currentPos <= i) {
                      letters[currentPos].an = currentSize;
                      letters[currentPos].ind = index;
                      letters[currentPos].extra = cLength;
                      currentPos += 1;
                    }
                    index += 1;
                    currentSize = 0;
                  }
                } else if (anchorGrouping == 3) {
                  // eslint-disable-line eqeqeq
                  currentSize += cLength;
                  if (val === '' || i === len - 1) {
                    if (val === '') {
                      currentSize -= cLength;
                    }
                    while (currentPos <= i) {
                      letters[currentPos].an = currentSize;
                      letters[currentPos].ind = index;
                      letters[currentPos].extra = cLength;
                      currentPos += 1;
                    }
                    currentSize = 0;
                    index += 1;
                  }
                } else {
                  letters[index].ind = index;
                  letters[index].extra = 0;
                  index += 1;
                }
              }
              documentData.l = letters;
              maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
              lineWidths.push(lineWidth);
              if (documentData.sz) {
                documentData.boxWidth = documentData.sz[0];
                documentData.justifyOffset = 0;
              } else {
                documentData.boxWidth = maxLineWidth;
                switch (documentData.j) {
                  case 1:
                    documentData.justifyOffset = -documentData.boxWidth;
                    break;
                  case 2:
                    documentData.justifyOffset = -documentData.boxWidth / 2;
                    break;
                  default:
                    documentData.justifyOffset = 0;
                }
              }
              documentData.lineWidths = lineWidths;
              var animators = data.a;
              var animatorData;
              var letterData;
              jLen = animators.length;
              var based;
              var ind;
              var indexes = [];
              for (j = 0; j < jLen; j += 1) {
                animatorData = animators[j];
                if (animatorData.a.sc) {
                  documentData.strokeColorAnim = true;
                }
                if (animatorData.a.sw) {
                  documentData.strokeWidthAnim = true;
                }
                if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
                  documentData.fillColorAnim = true;
                }
                ind = 0;
                based = animatorData.s.b;
                for (i = 0; i < len; i += 1) {
                  letterData = letters[i];
                  letterData.anIndexes[j] = ind;
                  if (based == 1 && letterData.val !== '' || based == 2 && letterData.val !== '' && letterData.val !== ' ' || based == 3 && (letterData.n || letterData.val == ' ' || i == len - 1) || based == 4 && (letterData.n || i == len - 1)) {
                    // eslint-disable-line eqeqeq
                    if (animatorData.s.rn === 1) {
                      indexes.push(ind);
                    }
                    ind += 1;
                  }
                }
                data.a[j].s.totalChars = ind;
                var currentInd = -1;
                var newInd;
                if (animatorData.s.rn === 1) {
                  for (i = 0; i < len; i += 1) {
                    letterData = letters[i];
                    if (currentInd != letterData.anIndexes[j]) {
                      // eslint-disable-line eqeqeq
                      currentInd = letterData.anIndexes[j];
                      newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
                    }
                    letterData.anIndexes[j] = newInd;
                  }
                }
              }
              documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
              documentData.ls = documentData.ls || 0;
              documentData.ascent = fontData.ascent * documentData.finalSize / 100;
            };
            TextProperty.prototype.updateDocumentData = function (newData, index) {
              index = index === undefined ? this.keysIndex : index;
              var dData = this.copyData({}, this.data.d.k[index].s);
              dData = this.copyData(dData, newData);
              this.data.d.k[index].s = dData;
              this.recalculate(index);
              this.setCurrentData(dData);
              this.elem.addDynamicProperty(this);
            };
            TextProperty.prototype.recalculate = function (index) {
              var dData = this.data.d.k[index].s;
              dData.__complete = false;
              this.keysIndex = 0;
              this._isFirstFrame = true;
              this.getValue(dData);
            };
            TextProperty.prototype.canResizeFont = function (_canResize) {
              this.canResize = _canResize;
              this.recalculate(this.keysIndex);
              this.elem.addDynamicProperty(this);
            };
            TextProperty.prototype.setMinimumFontSize = function (_fontValue) {
              this.minimumFontSize = Math.floor(_fontValue) || 1;
              this.recalculate(this.keysIndex);
              this.elem.addDynamicProperty(this);
            };
            var TextSelectorProp = function () {
              var max = Math.max;
              var min = Math.min;
              var floor = Math.floor;
              function TextSelectorPropFactory(elem, data) {
                this._currentTextLength = -1;
                this.k = false;
                this.data = data;
                this.elem = elem;
                this.comp = elem.comp;
                this.finalS = 0;
                this.finalE = 0;
                this.initDynamicPropertyContainer(elem);
                this.s = PropertyFactory.getProp(elem, data.s || {
                  k: 0
                }, 0, 0, this);
                if ('e' in data) {
                  this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);
                } else {
                  this.e = {
                    v: 100
                  };
                }
                this.o = PropertyFactory.getProp(elem, data.o || {
                  k: 0
                }, 0, 0, this);
                this.xe = PropertyFactory.getProp(elem, data.xe || {
                  k: 0
                }, 0, 0, this);
                this.ne = PropertyFactory.getProp(elem, data.ne || {
                  k: 0
                }, 0, 0, this);
                this.sm = PropertyFactory.getProp(elem, data.sm || {
                  k: 100
                }, 0, 0, this);
                this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);
                if (!this.dynamicProperties.length) {
                  this.getValue();
                }
              }
              TextSelectorPropFactory.prototype = {
                getMult: function getMult(ind) {
                  if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
                    this.getValue();
                  }
                  var x1 = 0;
                  var y1 = 0;
                  var x2 = 1;
                  var y2 = 1;
                  if (this.ne.v > 0) {
                    x1 = this.ne.v / 100.0;
                  } else {
                    y1 = -this.ne.v / 100.0;
                  }
                  if (this.xe.v > 0) {
                    x2 = 1.0 - this.xe.v / 100.0;
                  } else {
                    y2 = 1.0 + this.xe.v / 100.0;
                  }
                  var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;
                  var mult = 0;
                  var s = this.finalS;
                  var e = this.finalE;
                  var type = this.data.sh;
                  if (type === 2) {
                    if (e === s) {
                      mult = ind >= e ? 1 : 0;
                    } else {
                      mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
                    }
                    mult = easer(mult);
                  } else if (type === 3) {
                    if (e === s) {
                      mult = ind >= e ? 0 : 1;
                    } else {
                      mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
                    }
                    mult = easer(mult);
                  } else if (type === 4) {
                    if (e === s) {
                      mult = 0;
                    } else {
                      mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
                      if (mult < 0.5) {
                        mult *= 2;
                      } else {
                        mult = 1 - 2 * (mult - 0.5);
                      }
                    }
                    mult = easer(mult);
                  } else if (type === 5) {
                    if (e === s) {
                      mult = 0;
                    } else {
                      var tot = e - s;
                      /* ind += 0.5;
                                mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */

                      ind = min(max(0, ind + 0.5 - s), e - s);
                      var x = -tot / 2 + ind;
                      var a = tot / 2;
                      mult = Math.sqrt(1 - x * x / (a * a));
                    }
                    mult = easer(mult);
                  } else if (type === 6) {
                    if (e === s) {
                      mult = 0;
                    } else {
                      ind = min(max(0, ind + 0.5 - s), e - s);
                      mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2; // eslint-disable-line
                    }
                    mult = easer(mult);
                  } else {
                    if (ind >= floor(s)) {
                      if (ind - s < 0) {
                        mult = max(0, min(min(e, 1) - (s - ind), 1));
                      } else {
                        mult = max(0, min(e - ind, 1));
                      }
                    }
                    mult = easer(mult);
                  } // Smoothness implementation.
                  // The smoothness represents a reduced range of the original [0; 1] range.
                  // if smoothness is 25%, the new range will be [0.375; 0.625]
                  // Steps are:
                  // - find the lower value of the new range (threshold)
                  // - if multiplier is smaller than that value, floor it to 0
                  // - if it is larger,
                  //     - subtract the threshold
                  //     - divide it by the smoothness (this will return the range to [0; 1])
                  // Note: If it doesn't work on some scenarios, consider applying it before the easer.

                  if (this.sm.v !== 100) {
                    var smoothness = this.sm.v * 0.01;
                    if (smoothness === 0) {
                      smoothness = 0.00000001;
                    }
                    var threshold = 0.5 - smoothness * 0.5;
                    if (mult < threshold) {
                      mult = 0;
                    } else {
                      mult = (mult - threshold) / smoothness;
                      if (mult > 1) {
                        mult = 1;
                      }
                    }
                  }
                  return mult * this.a.v;
                },
                getValue: function getValue(newCharsFlag) {
                  this.iterateDynamicProperties();
                  this._mdf = newCharsFlag || this._mdf;
                  this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
                  if (newCharsFlag && this.data.r === 2) {
                    this.e.v = this._currentTextLength;
                  }
                  var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
                  var o = this.o.v / divisor;
                  var s = this.s.v / divisor + o;
                  var e = this.e.v / divisor + o;
                  if (s > e) {
                    var _s = s;
                    s = e;
                    e = _s;
                  }
                  this.finalS = s;
                  this.finalE = e;
                }
              };
              extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);
              function getTextSelectorProp(elem, data, arr) {
                return new TextSelectorPropFactory(elem, data);
              }
              return {
                getTextSelectorProp: getTextSelectorProp
              };
            }();
            function TextAnimatorDataProperty(elem, animatorProps, container) {
              var defaultData = {
                propType: false
              };
              var getProp = PropertyFactory.getProp;
              var textAnimatorAnimatables = animatorProps.a;
              this.a = {
                r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
                rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
                ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
                sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
                sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
                s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
                a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
                o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
                p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
                sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
                sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
                fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
                fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
                fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
                fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
                t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData
              };
              this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);
              this.s.t = animatorProps.s.t;
            }
            function TextAnimatorProperty(textData, renderType, elem) {
              this._isFirstFrame = true;
              this._hasMaskedPath = false;
              this._frameId = -1;
              this._textData = textData;
              this._renderType = renderType;
              this._elem = elem;
              this._animatorsData = createSizedArray(this._textData.a.length);
              this._pathData = {};
              this._moreOptions = {
                alignment: {}
              };
              this.renderedLetters = [];
              this.lettersChangedFlag = false;
              this.initDynamicPropertyContainer(elem);
            }
            TextAnimatorProperty.prototype.searchProperties = function () {
              var i;
              var len = this._textData.a.length;
              var animatorProps;
              var getProp = PropertyFactory.getProp;
              for (i = 0; i < len; i += 1) {
                animatorProps = this._textData.a[i];
                this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
              }
              if (this._textData.p && 'm' in this._textData.p) {
                this._pathData = {
                  a: getProp(this._elem, this._textData.p.a, 0, 0, this),
                  f: getProp(this._elem, this._textData.p.f, 0, 0, this),
                  l: getProp(this._elem, this._textData.p.l, 0, 0, this),
                  r: getProp(this._elem, this._textData.p.r, 0, 0, this),
                  p: getProp(this._elem, this._textData.p.p, 0, 0, this),
                  m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
                };
                this._hasMaskedPath = true;
              } else {
                this._hasMaskedPath = false;
              }
              this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
            };
            TextAnimatorProperty.prototype.getMeasures = function (documentData, lettersChangedFlag) {
              this.lettersChangedFlag = lettersChangedFlag;
              if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
                return;
              }
              this._isFirstFrame = false;
              var alignment = this._moreOptions.alignment.v;
              var animators = this._animatorsData;
              var textData = this._textData;
              var matrixHelper = this.mHelper;
              var renderType = this._renderType;
              var renderedLettersCount = this.renderedLetters.length;
              var xPos;
              var yPos;
              var i;
              var len;
              var letters = documentData.l;
              var pathInfo;
              var currentLength;
              var currentPoint;
              var segmentLength;
              var flag;
              var pointInd;
              var segmentInd;
              var prevPoint;
              var points;
              var segments;
              var partialLength;
              var totalLength;
              var perc;
              var tanAngle;
              var mask;
              if (this._hasMaskedPath) {
                mask = this._pathData.m;
                if (!this._pathData.n || this._pathData._mdf) {
                  var paths = mask.v;
                  if (this._pathData.r.v) {
                    paths = paths.reverse();
                  } // TODO: release bezier data cached from previous pathInfo: this._pathData.pi

                  pathInfo = {
                    tLength: 0,
                    segments: []
                  };
                  len = paths._length - 1;
                  var bezierData;
                  totalLength = 0;
                  for (i = 0; i < len; i += 1) {
                    bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);
                    pathInfo.tLength += bezierData.segmentLength;
                    pathInfo.segments.push(bezierData);
                    totalLength += bezierData.segmentLength;
                  }
                  i = len;
                  if (mask.v.c) {
                    bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
                    pathInfo.tLength += bezierData.segmentLength;
                    pathInfo.segments.push(bezierData);
                    totalLength += bezierData.segmentLength;
                  }
                  this._pathData.pi = pathInfo;
                }
                pathInfo = this._pathData.pi;
                currentLength = this._pathData.f.v;
                segmentInd = 0;
                pointInd = 1;
                segmentLength = 0;
                flag = true;
                segments = pathInfo.segments;
                if (currentLength < 0 && mask.v.c) {
                  if (pathInfo.tLength < Math.abs(currentLength)) {
                    currentLength = -Math.abs(currentLength) % pathInfo.tLength;
                  }
                  segmentInd = segments.length - 1;
                  points = segments[segmentInd].points;
                  pointInd = points.length - 1;
                  while (currentLength < 0) {
                    currentLength += points[pointInd].partialLength;
                    pointInd -= 1;
                    if (pointInd < 0) {
                      segmentInd -= 1;
                      points = segments[segmentInd].points;
                      pointInd = points.length - 1;
                    }
                  }
                }
                points = segments[segmentInd].points;
                prevPoint = points[pointInd - 1];
                currentPoint = points[pointInd];
                partialLength = currentPoint.partialLength;
              }
              len = letters.length;
              xPos = 0;
              yPos = 0;
              var yOff = documentData.finalSize * 1.2 * 0.714;
              var firstLine = true;
              var animatorProps;
              var animatorSelector;
              var j;
              var jLen;
              var letterValue;
              jLen = animators.length;
              var mult;
              var ind = -1;
              var offf;
              var xPathPos;
              var yPathPos;
              var initPathPos = currentLength;
              var initSegmentInd = segmentInd;
              var initPointInd = pointInd;
              var currentLine = -1;
              var elemOpacity;
              var sc;
              var sw;
              var fc;
              var k;
              var letterSw;
              var letterSc;
              var letterFc;
              var letterM = '';
              var letterP = this.defaultPropsArray;
              var letterO; //

              if (documentData.j === 2 || documentData.j === 1) {
                var animatorJustifyOffset = 0;
                var animatorFirstCharOffset = 0;
                var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
                var lastIndex = 0;
                var isNewLine = true;
                for (i = 0; i < len; i += 1) {
                  if (letters[i].n) {
                    if (animatorJustifyOffset) {
                      animatorJustifyOffset += animatorFirstCharOffset;
                    }
                    while (lastIndex < i) {
                      letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                      lastIndex += 1;
                    }
                    animatorJustifyOffset = 0;
                    isNewLine = true;
                  } else {
                    for (j = 0; j < jLen; j += 1) {
                      animatorProps = animators[j].a;
                      if (animatorProps.t.propType) {
                        if (isNewLine && documentData.j === 2) {
                          animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                        }
                        animatorSelector = animators[j].s;
                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                        if (mult.length) {
                          animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
                        } else {
                          animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
                        }
                      }
                    }
                    isNewLine = false;
                  }
                }
                if (animatorJustifyOffset) {
                  animatorJustifyOffset += animatorFirstCharOffset;
                }
                while (lastIndex < i) {
                  letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                  lastIndex += 1;
                }
              } //

              for (i = 0; i < len; i += 1) {
                matrixHelper.reset();
                elemOpacity = 1;
                if (letters[i].n) {
                  xPos = 0;
                  yPos += documentData.yOffset;
                  yPos += firstLine ? 1 : 0;
                  currentLength = initPathPos;
                  firstLine = false;
                  if (this._hasMaskedPath) {
                    segmentInd = initSegmentInd;
                    pointInd = initPointInd;
                    points = segments[segmentInd].points;
                    prevPoint = points[pointInd - 1];
                    currentPoint = points[pointInd];
                    partialLength = currentPoint.partialLength;
                    segmentLength = 0;
                  }
                  letterM = '';
                  letterFc = '';
                  letterSw = '';
                  letterO = '';
                  letterP = this.defaultPropsArray;
                } else {
                  if (this._hasMaskedPath) {
                    if (currentLine !== letters[i].line) {
                      switch (documentData.j) {
                        case 1:
                          currentLength += totalLength - documentData.lineWidths[letters[i].line];
                          break;
                        case 2:
                          currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;
                          break;
                      }
                      currentLine = letters[i].line;
                    }
                    if (ind !== letters[i].ind) {
                      if (letters[ind]) {
                        currentLength += letters[ind].extra;
                      }
                      currentLength += letters[i].an / 2;
                      ind = letters[i].ind;
                    }
                    currentLength += alignment[0] * letters[i].an * 0.005;
                    var animatorOffset = 0;
                    for (j = 0; j < jLen; j += 1) {
                      animatorProps = animators[j].a;
                      if (animatorProps.p.propType) {
                        animatorSelector = animators[j].s;
                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                        if (mult.length) {
                          animatorOffset += animatorProps.p.v[0] * mult[0];
                        } else {
                          animatorOffset += animatorProps.p.v[0] * mult;
                        }
                      }
                      if (animatorProps.a.propType) {
                        animatorSelector = animators[j].s;
                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                        if (mult.length) {
                          animatorOffset += animatorProps.a.v[0] * mult[0];
                        } else {
                          animatorOffset += animatorProps.a.v[0] * mult;
                        }
                      }
                    }
                    flag = true; // Force alignment only works with a single line for now

                    if (this._pathData.a.v) {
                      currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);
                      currentLength += this._pathData.f.v;
                    }
                    while (flag) {
                      if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                        perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                        xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                        yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                        matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -(alignment[1] * yOff) * 0.01);
                        flag = false;
                      } else if (points) {
                        segmentLength += currentPoint.partialLength;
                        pointInd += 1;
                        if (pointInd >= points.length) {
                          pointInd = 0;
                          segmentInd += 1;
                          if (!segments[segmentInd]) {
                            if (mask.v.c) {
                              pointInd = 0;
                              segmentInd = 0;
                              points = segments[segmentInd].points;
                            } else {
                              segmentLength -= currentPoint.partialLength;
                              points = null;
                            }
                          } else {
                            points = segments[segmentInd].points;
                          }
                        }
                        if (points) {
                          prevPoint = currentPoint;
                          currentPoint = points[pointInd];
                          partialLength = currentPoint.partialLength;
                        }
                      }
                    }
                    offf = letters[i].an / 2 - letters[i].add;
                    matrixHelper.translate(-offf, 0, 0);
                  } else {
                    offf = letters[i].an / 2 - letters[i].add;
                    matrixHelper.translate(-offf, 0, 0); // Grouping alignment

                    matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -alignment[1] * yOff * 0.01, 0);
                  }
                  for (j = 0; j < jLen; j += 1) {
                    animatorProps = animators[j].a;
                    if (animatorProps.t.propType) {
                      animatorSelector = animators[j].s;
                      mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars); // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean "isNewLine"

                      if (xPos !== 0 || documentData.j !== 0) {
                        if (this._hasMaskedPath) {
                          if (mult.length) {
                            currentLength += animatorProps.t.v * mult[0];
                          } else {
                            currentLength += animatorProps.t.v * mult;
                          }
                        } else if (mult.length) {
                          xPos += animatorProps.t.v * mult[0];
                        } else {
                          xPos += animatorProps.t.v * mult;
                        }
                      }
                    }
                  }
                  if (documentData.strokeWidthAnim) {
                    sw = documentData.sw || 0;
                  }
                  if (documentData.strokeColorAnim) {
                    if (documentData.sc) {
                      sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
                    } else {
                      sc = [0, 0, 0];
                    }
                  }
                  if (documentData.fillColorAnim && documentData.fc) {
                    fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
                  }
                  for (j = 0; j < jLen; j += 1) {
                    animatorProps = animators[j].a;
                    if (animatorProps.a.propType) {
                      animatorSelector = animators[j].s;
                      mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                      if (mult.length) {
                        matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
                      } else {
                        matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
                      }
                    }
                  }
                  for (j = 0; j < jLen; j += 1) {
                    animatorProps = animators[j].a;
                    if (animatorProps.s.propType) {
                      animatorSelector = animators[j].s;
                      mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                      if (mult.length) {
                        matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
                      } else {
                        matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
                      }
                    }
                  }
                  for (j = 0; j < jLen; j += 1) {
                    animatorProps = animators[j].a;
                    animatorSelector = animators[j].s;
                    mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                    if (animatorProps.sk.propType) {
                      if (mult.length) {
                        matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
                      } else {
                        matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
                      }
                    }
                    if (animatorProps.r.propType) {
                      if (mult.length) {
                        matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
                      } else {
                        matrixHelper.rotateZ(-animatorProps.r.v * mult);
                      }
                    }
                    if (animatorProps.ry.propType) {
                      if (mult.length) {
                        matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
                      } else {
                        matrixHelper.rotateY(animatorProps.ry.v * mult);
                      }
                    }
                    if (animatorProps.rx.propType) {
                      if (mult.length) {
                        matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
                      } else {
                        matrixHelper.rotateX(animatorProps.rx.v * mult);
                      }
                    }
                    if (animatorProps.o.propType) {
                      if (mult.length) {
                        elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
                      } else {
                        elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
                      }
                    }
                    if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
                      if (mult.length) {
                        sw += animatorProps.sw.v * mult[0];
                      } else {
                        sw += animatorProps.sw.v * mult;
                      }
                    }
                    if (documentData.strokeColorAnim && animatorProps.sc.propType) {
                      for (k = 0; k < 3; k += 1) {
                        if (mult.length) {
                          sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];
                        } else {
                          sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
                        }
                      }
                    }
                    if (documentData.fillColorAnim && documentData.fc) {
                      if (animatorProps.fc.propType) {
                        for (k = 0; k < 3; k += 1) {
                          if (mult.length) {
                            fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];
                          } else {
                            fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
                          }
                        }
                      }
                      if (animatorProps.fh.propType) {
                        if (mult.length) {
                          fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
                        } else {
                          fc = addHueToRGB(fc, animatorProps.fh.v * mult);
                        }
                      }
                      if (animatorProps.fs.propType) {
                        if (mult.length) {
                          fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
                        } else {
                          fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
                        }
                      }
                      if (animatorProps.fb.propType) {
                        if (mult.length) {
                          fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
                        } else {
                          fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
                        }
                      }
                    }
                  }
                  for (j = 0; j < jLen; j += 1) {
                    animatorProps = animators[j].a;
                    if (animatorProps.p.propType) {
                      animatorSelector = animators[j].s;
                      mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                      if (this._hasMaskedPath) {
                        if (mult.length) {
                          matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
                        } else {
                          matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                        }
                      } else if (mult.length) {
                        matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
                      } else {
                        matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                      }
                    }
                  }
                  if (documentData.strokeWidthAnim) {
                    letterSw = sw < 0 ? 0 : sw;
                  }
                  if (documentData.strokeColorAnim) {
                    letterSc = 'rgb(' + Math.round(sc[0] * 255) + ',' + Math.round(sc[1] * 255) + ',' + Math.round(sc[2] * 255) + ')';
                  }
                  if (documentData.fillColorAnim && documentData.fc) {
                    letterFc = 'rgb(' + Math.round(fc[0] * 255) + ',' + Math.round(fc[1] * 255) + ',' + Math.round(fc[2] * 255) + ')';
                  }
                  if (this._hasMaskedPath) {
                    matrixHelper.translate(0, -documentData.ls);
                    matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);
                    if (this._pathData.p.v) {
                      tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
                      var rot = Math.atan(tanAngle) * 180 / Math.PI;
                      if (currentPoint.point[0] < prevPoint.point[0]) {
                        rot += 180;
                      }
                      matrixHelper.rotate(-rot * Math.PI / 180);
                    }
                    matrixHelper.translate(xPathPos, yPathPos, 0);
                    currentLength -= alignment[0] * letters[i].an * 0.005;
                    if (letters[i + 1] && ind !== letters[i + 1].ind) {
                      currentLength += letters[i].an / 2;
                      currentLength += documentData.tr * 0.001 * documentData.finalSize;
                    }
                  } else {
                    matrixHelper.translate(xPos, yPos, 0);
                    if (documentData.ps) {
                      // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
                      matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
                    }
                    switch (documentData.j) {
                      case 1:
                        matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);
                        break;
                      case 2:
                        matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);
                        break;
                    }
                    matrixHelper.translate(0, -documentData.ls);
                    matrixHelper.translate(offf, 0, 0);
                    matrixHelper.translate(alignment[0] * letters[i].an * 0.005, alignment[1] * yOff * 0.01, 0);
                    xPos += letters[i].l + documentData.tr * 0.001 * documentData.finalSize;
                  }
                  if (renderType === 'html') {
                    letterM = matrixHelper.toCSS();
                  } else if (renderType === 'svg') {
                    letterM = matrixHelper.to2dCSS();
                  } else {
                    letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
                  }
                  letterO = elemOpacity;
                }
                if (renderedLettersCount <= i) {
                  letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
                  this.renderedLetters.push(letterValue);
                  renderedLettersCount += 1;
                  this.lettersChangedFlag = true;
                } else {
                  letterValue = this.renderedLetters[i];
                  this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
                }
              }
            };
            TextAnimatorProperty.prototype.getValue = function () {
              if (this._elem.globalData.frameId === this._frameId) {
                return;
              }
              this._frameId = this._elem.globalData.frameId;
              this.iterateDynamicProperties();
            };
            TextAnimatorProperty.prototype.mHelper = new Matrix();
            TextAnimatorProperty.prototype.defaultPropsArray = [];
            extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
            function ITextElement() {}
            ITextElement.prototype.initElement = function (data, globalData, comp) {
              this.lettersChangedFlag = true;
              this.initFrame();
              this.initBaseData(data, globalData, comp);
              this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
              this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
              this.initTransform(data, globalData, comp);
              this.initHierarchy();
              this.initRenderable();
              this.initRendererElement();
              this.createContainerElements();
              this.createRenderableComponents();
              this.createContent();
              this.hide();
              this.textAnimator.searchProperties(this.dynamicProperties);
            };
            ITextElement.prototype.prepareFrame = function (num) {
              this._mdf = false;
              this.prepareRenderableFrame(num);
              this.prepareProperties(num, this.isInRange);
            };
            ITextElement.prototype.createPathShape = function (matrixHelper, shapes) {
              var j;
              var jLen = shapes.length;
              var pathNodes;
              var shapeStr = '';
              for (j = 0; j < jLen; j += 1) {
                if (shapes[j].ty === 'sh') {
                  pathNodes = shapes[j].ks.k;
                  shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
                }
              }
              return shapeStr;
            };
            ITextElement.prototype.updateDocumentData = function (newData, index) {
              this.textProperty.updateDocumentData(newData, index);
            };
            ITextElement.prototype.canResizeFont = function (_canResize) {
              this.textProperty.canResizeFont(_canResize);
            };
            ITextElement.prototype.setMinimumFontSize = function (_fontSize) {
              this.textProperty.setMinimumFontSize(_fontSize);
            };
            ITextElement.prototype.applyTextPropertiesToMatrix = function (documentData, matrixHelper, lineNumber, xPos, yPos) {
              if (documentData.ps) {
                matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
              }
              matrixHelper.translate(0, -documentData.ls, 0);
              switch (documentData.j) {
                case 1:
                  matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
                  break;
                case 2:
                  matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
                  break;
              }
              matrixHelper.translate(xPos, yPos, 0);
            };
            ITextElement.prototype.buildColor = function (colorData) {
              return 'rgb(' + Math.round(colorData[0] * 255) + ',' + Math.round(colorData[1] * 255) + ',' + Math.round(colorData[2] * 255) + ')';
            };
            ITextElement.prototype.emptyProp = new LetterProps();
            ITextElement.prototype.destroy = function () {};
            ITextElement.prototype.validateText = function () {
              if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
                this.buildNewText();
                this.textProperty._isFirstFrame = false;
                this.textProperty._mdf = false;
              }
            };
            var emptyShapeData = {
              shapes: []
            };
            function SVGTextLottieElement(data, globalData, comp) {
              this.textSpans = [];
              this.renderType = 'svg';
              this.initElement(data, globalData, comp);
            }
            extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);
            SVGTextLottieElement.prototype.createContent = function () {
              if (this.data.singleShape && !this.globalData.fontManager.chars) {
                this.textContainer = createNS('text');
              }
            };
            SVGTextLottieElement.prototype.buildTextContents = function (textArray) {
              var i = 0;
              var len = textArray.length;
              var textContents = [];
              var currentTextContent = '';
              while (i < len) {
                if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
                  textContents.push(currentTextContent);
                  currentTextContent = '';
                } else {
                  currentTextContent += textArray[i];
                }
                i += 1;
              }
              textContents.push(currentTextContent);
              return textContents;
            };
            SVGTextLottieElement.prototype.buildShapeData = function (data, scale) {
              // data should probably be cloned to apply scale separately to each instance of a text on different layers
              // but since text internal content gets only rendered once and then it's never rerendered,
              // it's probably safe not to clone data and reuse always the same instance even if the object is mutated.
              // Avoiding cloning is preferred since cloning each character shape data is expensive
              if (data.shapes && data.shapes.length) {
                var shape = data.shapes[0];
                if (shape.it) {
                  var shapeItem = shape.it[shape.it.length - 1];
                  if (shapeItem.s) {
                    shapeItem.s.k[0] = scale;
                    shapeItem.s.k[1] = scale;
                  }
                }
              }
              return data;
            };
            SVGTextLottieElement.prototype.buildNewText = function () {
              this.addDynamicProperty(this);
              var i;
              var len;
              var documentData = this.textProperty.currentData;
              this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
              if (documentData.fc) {
                this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));
              } else {
                this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');
              }
              if (documentData.sc) {
                this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));
                this.layerElement.setAttribute('stroke-width', documentData.sw);
              }
              this.layerElement.setAttribute('font-size', documentData.finalSize);
              var fontData = this.globalData.fontManager.getFontByName(documentData.f);
              if (fontData.fClass) {
                this.layerElement.setAttribute('class', fontData.fClass);
              } else {
                this.layerElement.setAttribute('font-family', fontData.fFamily);
                var fWeight = documentData.fWeight;
                var fStyle = documentData.fStyle;
                this.layerElement.setAttribute('font-style', fStyle);
                this.layerElement.setAttribute('font-weight', fWeight);
              }
              this.layerElement.setAttribute('aria-label', documentData.t);
              var letters = documentData.l || [];
              var usesGlyphs = !!this.globalData.fontManager.chars;
              len = letters.length;
              var tSpan;
              var matrixHelper = this.mHelper;
              var shapeStr = '';
              var singleShape = this.data.singleShape;
              var xPos = 0;
              var yPos = 0;
              var firstLine = true;
              var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
              if (singleShape && !usesGlyphs && !documentData.sz) {
                var tElement = this.textContainer;
                var justify = 'start';
                switch (documentData.j) {
                  case 1:
                    justify = 'end';
                    break;
                  case 2:
                    justify = 'middle';
                    break;
                  default:
                    justify = 'start';
                    break;
                }
                tElement.setAttribute('text-anchor', justify);
                tElement.setAttribute('letter-spacing', trackingOffset);
                var textContent = this.buildTextContents(documentData.finalText);
                len = textContent.length;
                yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
                for (i = 0; i < len; i += 1) {
                  tSpan = this.textSpans[i].span || createNS('tspan');
                  tSpan.textContent = textContent[i];
                  tSpan.setAttribute('x', 0);
                  tSpan.setAttribute('y', yPos);
                  tSpan.style.display = 'inherit';
                  tElement.appendChild(tSpan);
                  if (!this.textSpans[i]) {
                    this.textSpans[i] = {
                      span: null,
                      glyph: null
                    };
                  }
                  this.textSpans[i].span = tSpan;
                  yPos += documentData.finalLineHeight;
                }
                this.layerElement.appendChild(tElement);
              } else {
                var cachedSpansLength = this.textSpans.length;
                var charData;
                for (i = 0; i < len; i += 1) {
                  if (!this.textSpans[i]) {
                    this.textSpans[i] = {
                      span: null,
                      childSpan: null,
                      glyph: null
                    };
                  }
                  if (!usesGlyphs || !singleShape || i === 0) {
                    tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? 'g' : 'text');
                    if (cachedSpansLength <= i) {
                      tSpan.setAttribute('stroke-linecap', 'butt');
                      tSpan.setAttribute('stroke-linejoin', 'round');
                      tSpan.setAttribute('stroke-miterlimit', '4');
                      this.textSpans[i].span = tSpan;
                      if (usesGlyphs) {
                        var childSpan = createNS('g');
                        tSpan.appendChild(childSpan);
                        this.textSpans[i].childSpan = childSpan;
                      }
                      this.textSpans[i].span = tSpan;
                      this.layerElement.appendChild(tSpan);
                    }
                    tSpan.style.display = 'inherit';
                  }
                  matrixHelper.reset();
                  if (singleShape) {
                    if (letters[i].n) {
                      xPos = -trackingOffset;
                      yPos += documentData.yOffset;
                      yPos += firstLine ? 1 : 0;
                      firstLine = false;
                    }
                    this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
                    xPos += letters[i].l || 0; // xPos += letters[i].val === ' ' ? 0 : trackingOffset;

                    xPos += trackingOffset;
                  }
                  if (usesGlyphs) {
                    charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
                    var glyphElement; // t === 1 means the character has been replaced with an animated shaped

                    if (charData.t === 1) {
                      glyphElement = new SVGCompElement(charData.data, this.globalData, this);
                    } else {
                      var data = emptyShapeData;
                      if (charData.data && charData.data.shapes) {
                        data = this.buildShapeData(charData.data, documentData.finalSize);
                      }
                      glyphElement = new SVGShapeElement(data, this.globalData, this);
                    }
                    if (this.textSpans[i].glyph) {
                      var glyph = this.textSpans[i].glyph;
                      this.textSpans[i].childSpan.removeChild(glyph.layerElement);
                      glyph.destroy();
                    }
                    this.textSpans[i].glyph = glyphElement;
                    glyphElement._debug = true;
                    glyphElement.prepareFrame(0);
                    glyphElement.renderFrame();
                    this.textSpans[i].childSpan.appendChild(glyphElement.layerElement); // when using animated shapes, the layer will be scaled instead of replacing the internal scale
                    // this might have issues with strokes and might need a different solution

                    if (charData.t === 1) {
                      this.textSpans[i].childSpan.setAttribute('transform', 'scale(' + documentData.finalSize / 100 + ',' + documentData.finalSize / 100 + ')');
                    }
                  } else {
                    if (singleShape) {
                      tSpan.setAttribute('transform', 'translate(' + matrixHelper.props[12] + ',' + matrixHelper.props[13] + ')');
                    }
                    tSpan.textContent = letters[i].val;
                    tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
                  } //
                }
                if (singleShape && tSpan) {
                  tSpan.setAttribute('d', shapeStr);
                }
              }
              while (i < this.textSpans.length) {
                this.textSpans[i].span.style.display = 'none';
                i += 1;
              }
              this._sizeChanged = true;
            };
            SVGTextLottieElement.prototype.sourceRectAtTime = function () {
              this.prepareFrame(this.comp.renderedFrame - this.data.st);
              this.renderInnerContent();
              if (this._sizeChanged) {
                this._sizeChanged = false;
                var textBox = this.layerElement.getBBox();
                this.bbox = {
                  top: textBox.y,
                  left: textBox.x,
                  width: textBox.width,
                  height: textBox.height
                };
              }
              return this.bbox;
            };
            SVGTextLottieElement.prototype.getValue = function () {
              var i;
              var len = this.textSpans.length;
              var glyphElement;
              this.renderedFrame = this.comp.renderedFrame;
              for (i = 0; i < len; i += 1) {
                glyphElement = this.textSpans[i].glyph;
                if (glyphElement) {
                  glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);
                  if (glyphElement._mdf) {
                    this._mdf = true;
                  }
                }
              }
            };
            SVGTextLottieElement.prototype.renderInnerContent = function () {
              this.validateText();
              if (!this.data.singleShape || this._mdf) {
                this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
                if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
                  this._sizeChanged = true;
                  var i;
                  var len;
                  var renderedLetters = this.textAnimator.renderedLetters;
                  var letters = this.textProperty.currentData.l;
                  len = letters.length;
                  var renderedLetter;
                  var textSpan;
                  var glyphElement;
                  for (i = 0; i < len; i += 1) {
                    if (!letters[i].n) {
                      renderedLetter = renderedLetters[i];
                      textSpan = this.textSpans[i].span;
                      glyphElement = this.textSpans[i].glyph;
                      if (glyphElement) {
                        glyphElement.renderFrame();
                      }
                      if (renderedLetter._mdf.m) {
                        textSpan.setAttribute('transform', renderedLetter.m);
                      }
                      if (renderedLetter._mdf.o) {
                        textSpan.setAttribute('opacity', renderedLetter.o);
                      }
                      if (renderedLetter._mdf.sw) {
                        textSpan.setAttribute('stroke-width', renderedLetter.sw);
                      }
                      if (renderedLetter._mdf.sc) {
                        textSpan.setAttribute('stroke', renderedLetter.sc);
                      }
                      if (renderedLetter._mdf.fc) {
                        textSpan.setAttribute('fill', renderedLetter.fc);
                      }
                    }
                  }
                }
              }
            };
            function ISolidElement(data, globalData, comp) {
              this.initElement(data, globalData, comp);
            }
            extendPrototype([IImageElement], ISolidElement);
            ISolidElement.prototype.createContent = function () {
              var rect = createNS('rect'); /// /rect.style.width = this.data.sw;
              /// /rect.style.height = this.data.sh;
              /// /rect.style.fill = this.data.sc;

              rect.setAttribute('width', this.data.sw);
              rect.setAttribute('height', this.data.sh);
              rect.setAttribute('fill', this.data.sc);
              this.layerElement.appendChild(rect);
            };
            function NullElement(data, globalData, comp) {
              this.initFrame();
              this.initBaseData(data, globalData, comp);
              this.initFrame();
              this.initTransform(data, globalData, comp);
              this.initHierarchy();
            }
            NullElement.prototype.prepareFrame = function (num) {
              this.prepareProperties(num, true);
            };
            NullElement.prototype.renderFrame = function () {};
            NullElement.prototype.getBaseElement = function () {
              return null;
            };
            NullElement.prototype.destroy = function () {};
            NullElement.prototype.sourceRectAtTime = function () {};
            NullElement.prototype.hide = function () {};
            extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
            function SVGRendererBase() {}
            extendPrototype([BaseRenderer], SVGRendererBase);
            SVGRendererBase.prototype.createNull = function (data) {
              return new NullElement(data, this.globalData, this);
            };
            SVGRendererBase.prototype.createShape = function (data) {
              return new SVGShapeElement(data, this.globalData, this);
            };
            SVGRendererBase.prototype.createText = function (data) {
              return new SVGTextLottieElement(data, this.globalData, this);
            };
            SVGRendererBase.prototype.createImage = function (data) {
              return new IImageElement(data, this.globalData, this);
            };
            SVGRendererBase.prototype.createSolid = function (data) {
              return new ISolidElement(data, this.globalData, this);
            };
            SVGRendererBase.prototype.configAnimation = function (animData) {
              this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
              this.svgElement.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
              if (this.renderConfig.viewBoxSize) {
                this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize);
              } else {
                this.svgElement.setAttribute('viewBox', '0 0 ' + animData.w + ' ' + animData.h);
              }
              if (!this.renderConfig.viewBoxOnly) {
                this.svgElement.setAttribute('width', animData.w);
                this.svgElement.setAttribute('height', animData.h);
                this.svgElement.style.width = '100%';
                this.svgElement.style.height = '100%';
                this.svgElement.style.transform = 'translate3d(0,0,0)';
                this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
              }
              if (this.renderConfig.width) {
                this.svgElement.setAttribute('width', this.renderConfig.width);
              }
              if (this.renderConfig.height) {
                this.svgElement.setAttribute('height', this.renderConfig.height);
              }
              if (this.renderConfig.className) {
                this.svgElement.setAttribute('class', this.renderConfig.className);
              }
              if (this.renderConfig.id) {
                this.svgElement.setAttribute('id', this.renderConfig.id);
              }
              if (this.renderConfig.focusable !== undefined) {
                this.svgElement.setAttribute('focusable', this.renderConfig.focusable);
              }
              this.svgElement.setAttribute('preserveAspectRatio', this.renderConfig.preserveAspectRatio); // this.layerElement.style.transform = 'translate3d(0,0,0)';
              // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";

              this.animationItem.wrapper.appendChild(this.svgElement); // Mask animation

              var defs = this.globalData.defs;
              this.setupGlobalData(animData, defs);
              this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
              this.data = animData;
              var maskElement = createNS('clipPath');
              var rect = createNS('rect');
              rect.setAttribute('width', animData.w);
              rect.setAttribute('height', animData.h);
              rect.setAttribute('x', 0);
              rect.setAttribute('y', 0);
              var maskId = createElementID();
              maskElement.setAttribute('id', maskId);
              maskElement.appendChild(rect);
              this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + maskId + ')');
              defs.appendChild(maskElement);
              this.layers = animData.layers;
              this.elements = createSizedArray(animData.layers.length);
            };
            SVGRendererBase.prototype.destroy = function () {
              if (this.animationItem.wrapper) {
                this.animationItem.wrapper.innerText = '';
              }
              this.layerElement = null;
              this.globalData.defs = null;
              var i;
              var len = this.layers ? this.layers.length : 0;
              for (i = 0; i < len; i += 1) {
                if (this.elements[i] && this.elements[i].destroy) {
                  this.elements[i].destroy();
                }
              }
              this.elements.length = 0;
              this.destroyed = true;
              this.animationItem = null;
            };
            SVGRendererBase.prototype.updateContainerSize = function () {};
            SVGRendererBase.prototype.findIndexByInd = function (ind) {
              var i = 0;
              var len = this.layers.length;
              for (i = 0; i < len; i += 1) {
                if (this.layers[i].ind === ind) {
                  return i;
                }
              }
              return -1;
            };
            SVGRendererBase.prototype.buildItem = function (pos) {
              var elements = this.elements;
              if (elements[pos] || this.layers[pos].ty === 99) {
                return;
              }
              elements[pos] = true;
              var element = this.createItem(this.layers[pos]);
              elements[pos] = element;
              if (getExpressionsPlugin()) {
                if (this.layers[pos].ty === 0) {
                  this.globalData.projectInterface.registerComposition(element);
                }
                element.initExpressions();
              }
              this.appendElementInPos(element, pos);
              if (this.layers[pos].tt) {
                var elementIndex = 'tp' in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;
                if (elementIndex === -1) {
                  return;
                }
                if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {
                  this.buildItem(elementIndex);
                  this.addPendingElement(element);
                } else {
                  var matteElement = elements[elementIndex];
                  var matteMask = matteElement.getMatte(this.layers[pos].tt);
                  element.setMatte(matteMask);
                }
              }
            };
            SVGRendererBase.prototype.checkPendingElements = function () {
              while (this.pendingElements.length) {
                var element = this.pendingElements.pop();
                element.checkParenting();
                if (element.data.tt) {
                  var i = 0;
                  var len = this.elements.length;
                  while (i < len) {
                    if (this.elements[i] === element) {
                      var elementIndex = 'tp' in element.data ? this.findIndexByInd(element.data.tp) : i - 1;
                      var matteElement = this.elements[elementIndex];
                      var matteMask = matteElement.getMatte(this.layers[i].tt);
                      element.setMatte(matteMask);
                      break;
                    }
                    i += 1;
                  }
                }
              }
            };
            SVGRendererBase.prototype.renderFrame = function (num) {
              if (this.renderedFrame === num || this.destroyed) {
                return;
              }
              if (num === null) {
                num = this.renderedFrame;
              } else {
                this.renderedFrame = num;
              } // console.log('-------');
              // console.log('FRAME ',num);

              this.globalData.frameNum = num;
              this.globalData.frameId += 1;
              this.globalData.projectInterface.currentFrame = num;
              this.globalData._mdf = false;
              var i;
              var len = this.layers.length;
              if (!this.completeLayers) {
                this.checkLayers(num);
              }
              for (i = len - 1; i >= 0; i -= 1) {
                if (this.completeLayers || this.elements[i]) {
                  this.elements[i].prepareFrame(num - this.layers[i].st);
                }
              }
              if (this.globalData._mdf) {
                for (i = 0; i < len; i += 1) {
                  if (this.completeLayers || this.elements[i]) {
                    this.elements[i].renderFrame();
                  }
                }
              }
            };
            SVGRendererBase.prototype.appendElementInPos = function (element, pos) {
              var newElement = element.getBaseElement();
              if (!newElement) {
                return;
              }
              var i = 0;
              var nextElement;
              while (i < pos) {
                if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {
                  nextElement = this.elements[i].getBaseElement();
                }
                i += 1;
              }
              if (nextElement) {
                this.layerElement.insertBefore(newElement, nextElement);
              } else {
                this.layerElement.appendChild(newElement);
              }
            };
            SVGRendererBase.prototype.hide = function () {
              this.layerElement.style.display = 'none';
            };
            SVGRendererBase.prototype.show = function () {
              this.layerElement.style.display = 'block';
            };
            function ICompElement() {}
            extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);
            ICompElement.prototype.initElement = function (data, globalData, comp) {
              this.initFrame();
              this.initBaseData(data, globalData, comp);
              this.initTransform(data, globalData, comp);
              this.initRenderable();
              this.initHierarchy();
              this.initRendererElement();
              this.createContainerElements();
              this.createRenderableComponents();
              if (this.data.xt || !globalData.progressiveLoad) {
                this.buildAllItems();
              }
              this.hide();
            };
            /* ICompElement.prototype.hide = function(){
                if(!this.hidden){
                    this.hideElement();
                    var i,len = this.elements.length;
                    for( i = 0; i < len; i+=1 ){
                        if(this.elements[i]){
                            this.elements[i].hide();
                        }
                    }
                }
            }; */

            ICompElement.prototype.prepareFrame = function (num) {
              this._mdf = false;
              this.prepareRenderableFrame(num);
              this.prepareProperties(num, this.isInRange);
              if (!this.isInRange && !this.data.xt) {
                return;
              }
              if (!this.tm._placeholder) {
                var timeRemapped = this.tm.v;
                if (timeRemapped === this.data.op) {
                  timeRemapped = this.data.op - 1;
                }
                this.renderedFrame = timeRemapped;
              } else {
                this.renderedFrame = num / this.data.sr;
              }
              var i;
              var len = this.elements.length;
              if (!this.completeLayers) {
                this.checkLayers(this.renderedFrame);
              } // This iteration needs to be backwards because of how expressions connect between each other

              for (i = len - 1; i >= 0; i -= 1) {
                if (this.completeLayers || this.elements[i]) {
                  this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
                  if (this.elements[i]._mdf) {
                    this._mdf = true;
                  }
                }
              }
            };
            ICompElement.prototype.renderInnerContent = function () {
              var i;
              var len = this.layers.length;
              for (i = 0; i < len; i += 1) {
                if (this.completeLayers || this.elements[i]) {
                  this.elements[i].renderFrame();
                }
              }
            };
            ICompElement.prototype.setElements = function (elems) {
              this.elements = elems;
            };
            ICompElement.prototype.getElements = function () {
              return this.elements;
            };
            ICompElement.prototype.destroyElements = function () {
              var i;
              var len = this.layers.length;
              for (i = 0; i < len; i += 1) {
                if (this.elements[i]) {
                  this.elements[i].destroy();
                }
              }
            };
            ICompElement.prototype.destroy = function () {
              this.destroyElements();
              this.destroyBaseElement();
            };
            function SVGCompElement(data, globalData, comp) {
              this.layers = data.layers;
              this.supports3d = true;
              this.completeLayers = false;
              this.pendingElements = [];
              this.elements = this.layers ? createSizedArray(this.layers.length) : [];
              this.initElement(data, globalData, comp);
              this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
                _placeholder: true
              };
            }
            extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement);
            SVGCompElement.prototype.createComp = function (data) {
              return new SVGCompElement(data, this.globalData, this);
            };
            function SVGRenderer(animationItem, config) {
              this.animationItem = animationItem;
              this.layers = null;
              this.renderedFrame = -1;
              this.svgElement = createNS('svg');
              var ariaLabel = '';
              if (config && config.title) {
                var titleElement = createNS('title');
                var titleId = createElementID();
                titleElement.setAttribute('id', titleId);
                titleElement.textContent = config.title;
                this.svgElement.appendChild(titleElement);
                ariaLabel += titleId;
              }
              if (config && config.description) {
                var descElement = createNS('desc');
                var descId = createElementID();
                descElement.setAttribute('id', descId);
                descElement.textContent = config.description;
                this.svgElement.appendChild(descElement);
                ariaLabel += ' ' + descId;
              }
              if (ariaLabel) {
                this.svgElement.setAttribute('aria-labelledby', ariaLabel);
              }
              var defs = createNS('defs');
              this.svgElement.appendChild(defs);
              var maskElement = createNS('g');
              this.svgElement.appendChild(maskElement);
              this.layerElement = maskElement;
              this.renderConfig = {
                preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',
                imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
                contentVisibility: config && config.contentVisibility || 'visible',
                progressiveLoad: config && config.progressiveLoad || false,
                hideOnTransparent: !(config && config.hideOnTransparent === false),
                viewBoxOnly: config && config.viewBoxOnly || false,
                viewBoxSize: config && config.viewBoxSize || false,
                className: config && config.className || '',
                id: config && config.id || '',
                focusable: config && config.focusable,
                filterSize: {
                  width: config && config.filterSize && config.filterSize.width || '100%',
                  height: config && config.filterSize && config.filterSize.height || '100%',
                  x: config && config.filterSize && config.filterSize.x || '0%',
                  y: config && config.filterSize && config.filterSize.y || '0%'
                },
                width: config && config.width,
                height: config && config.height,
                runExpressions: !config || config.runExpressions === undefined || config.runExpressions
              };
              this.globalData = {
                _mdf: false,
                frameNum: -1,
                defs: defs,
                renderConfig: this.renderConfig
              };
              this.elements = [];
              this.pendingElements = [];
              this.destroyed = false;
              this.rendererType = 'svg';
            }
            extendPrototype([SVGRendererBase], SVGRenderer);
            SVGRenderer.prototype.createComp = function (data) {
              return new SVGCompElement(data, this.globalData, this);
            };
            function ShapeTransformManager() {
              this.sequences = {};
              this.sequenceList = [];
              this.transform_key_count = 0;
            }
            ShapeTransformManager.prototype = {
              addTransformSequence: function addTransformSequence(transforms) {
                var i;
                var len = transforms.length;
                var key = '_';
                for (i = 0; i < len; i += 1) {
                  key += transforms[i].transform.key + '_';
                }
                var sequence = this.sequences[key];
                if (!sequence) {
                  sequence = {
                    transforms: [].concat(transforms),
                    finalTransform: new Matrix(),
                    _mdf: false
                  };
                  this.sequences[key] = sequence;
                  this.sequenceList.push(sequence);
                }
                return sequence;
              },
              processSequence: function processSequence(sequence, isFirstFrame) {
                var i = 0;
                var len = sequence.transforms.length;
                var _mdf = isFirstFrame;
                while (i < len && !isFirstFrame) {
                  if (sequence.transforms[i].transform.mProps._mdf) {
                    _mdf = true;
                    break;
                  }
                  i += 1;
                }
                if (_mdf) {
                  sequence.finalTransform.reset();
                  for (i = len - 1; i >= 0; i -= 1) {
                    sequence.finalTransform.multiply(sequence.transforms[i].transform.mProps.v);
                  }
                }
                sequence._mdf = _mdf;
              },
              processSequences: function processSequences(isFirstFrame) {
                var i;
                var len = this.sequenceList.length;
                for (i = 0; i < len; i += 1) {
                  this.processSequence(this.sequenceList[i], isFirstFrame);
                }
              },
              getNewKey: function getNewKey() {
                this.transform_key_count += 1;
                return '_' + this.transform_key_count;
              }
            };
            var lumaLoader = function lumaLoader() {
              var id = '__lottie_element_luma_buffer';
              var lumaBuffer = null;
              var lumaBufferCtx = null;
              var svg = null; // This alternate solution has a slight delay before the filter is applied, resulting in a flicker on the first frame.
              // Keeping this here for reference, and in the future, if offscreen canvas supports url filters, this can be used.
              // For now, neither of them work for offscreen canvas, so canvas workers can't support the luma track matte mask.
              // Naming it solution 2 to mark the extra comment lines.

              /*
              var svgString = [
                '<svg xmlns="http://www.w3.org/2000/svg">',
                '<filter id="' + id + '">',
                '<feColorMatrix type="matrix" color-interpolation-filters="sRGB" values="',
                '0.3, 0.3, 0.3, 0, 0, ',
                '0.3, 0.3, 0.3, 0, 0, ',
                '0.3, 0.3, 0.3, 0, 0, ',
                '0.3, 0.3, 0.3, 0, 0',
                '"/>',
                '</filter>',
                '</svg>',
              ].join('');
              var blob = new Blob([svgString], { type: 'image/svg+xml' });
              var url = URL.createObjectURL(blob);
              */

              function createLumaSvgFilter() {
                var _svg = createNS('svg');
                var fil = createNS('filter');
                var matrix = createNS('feColorMatrix');
                fil.setAttribute('id', id);
                matrix.setAttribute('type', 'matrix');
                matrix.setAttribute('color-interpolation-filters', 'sRGB');
                matrix.setAttribute('values', '0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0');
                fil.appendChild(matrix);
                _svg.appendChild(fil);
                _svg.setAttribute('id', id + '_svg');
                if (featureSupport.svgLumaHidden) {
                  _svg.style.display = 'none';
                }
                return _svg;
              }
              function loadLuma() {
                if (!lumaBuffer) {
                  svg = createLumaSvgFilter();
                  document.body.appendChild(svg);
                  lumaBuffer = createTag('canvas');
                  lumaBufferCtx = lumaBuffer.getContext('2d'); // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2

                  lumaBufferCtx.filter = 'url(#' + id + ')';
                  lumaBufferCtx.fillStyle = 'rgba(0,0,0,0)';
                  lumaBufferCtx.fillRect(0, 0, 1, 1);
                }
              }
              function getLuma(canvas) {
                if (!lumaBuffer) {
                  loadLuma();
                }
                lumaBuffer.width = canvas.width;
                lumaBuffer.height = canvas.height; // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2

                lumaBufferCtx.filter = 'url(#' + id + ')';
                return lumaBuffer;
              }
              return {
                load: loadLuma,
                get: getLuma
              };
            };
            function createCanvas(width, height) {
              if (featureSupport.offscreenCanvas) {
                return new OffscreenCanvas(width, height);
              }
              var canvas = createTag('canvas');
              canvas.width = width;
              canvas.height = height;
              return canvas;
            }
            var assetLoader = function () {
              return {
                loadLumaCanvas: lumaLoader.load,
                getLumaCanvas: lumaLoader.get,
                createCanvas: createCanvas
              };
            }();
            var registeredEffects = {};
            function CVEffects(elem) {
              var i;
              var len = elem.data.ef ? elem.data.ef.length : 0;
              this.filters = [];
              var filterManager;
              for (i = 0; i < len; i += 1) {
                filterManager = null;
                var type = elem.data.ef[i].ty;
                if (registeredEffects[type]) {
                  var Effect = registeredEffects[type].effect;
                  filterManager = new Effect(elem.effectsManager.effectElements[i], elem);
                }
                if (filterManager) {
                  this.filters.push(filterManager);
                }
              }
              if (this.filters.length) {
                elem.addRenderableComponent(this);
              }
            }
            CVEffects.prototype.renderFrame = function (_isFirstFrame) {
              var i;
              var len = this.filters.length;
              for (i = 0; i < len; i += 1) {
                this.filters[i].renderFrame(_isFirstFrame);
              }
            };
            CVEffects.prototype.getEffects = function (type) {
              var i;
              var len = this.filters.length;
              var effects = [];
              for (i = 0; i < len; i += 1) {
                if (this.filters[i].type === type) {
                  effects.push(this.filters[i]);
                }
              }
              return effects;
            };
            function registerEffect(id, effect) {
              registeredEffects[id] = {
                effect: effect
              };
            }
            function CVMaskElement(data, element) {
              this.data = data;
              this.element = element;
              this.masksProperties = this.data.masksProperties || [];
              this.viewData = createSizedArray(this.masksProperties.length);
              var i;
              var len = this.masksProperties.length;
              var hasMasks = false;
              for (i = 0; i < len; i += 1) {
                if (this.masksProperties[i].mode !== 'n') {
                  hasMasks = true;
                }
                this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
              }
              this.hasMasks = hasMasks;
              if (hasMasks) {
                this.element.addRenderableComponent(this);
              }
            }
            CVMaskElement.prototype.renderFrame = function () {
              if (!this.hasMasks) {
                return;
              }
              var transform = this.element.finalTransform.mat;
              var ctx = this.element.canvasContext;
              var i;
              var len = this.masksProperties.length;
              var pt;
              var pts;
              var data;
              ctx.beginPath();
              for (i = 0; i < len; i += 1) {
                if (this.masksProperties[i].mode !== 'n') {
                  if (this.masksProperties[i].inv) {
                    ctx.moveTo(0, 0);
                    ctx.lineTo(this.element.globalData.compSize.w, 0);
                    ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
                    ctx.lineTo(0, this.element.globalData.compSize.h);
                    ctx.lineTo(0, 0);
                  }
                  data = this.viewData[i].v;
                  pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);
                  ctx.moveTo(pt[0], pt[1]);
                  var j;
                  var jLen = data._length;
                  for (j = 1; j < jLen; j += 1) {
                    pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);
                    ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
                  }
                  pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);
                  ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
                }
              }
              this.element.globalData.renderer.save(true);
              ctx.clip();
            };
            CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;
            CVMaskElement.prototype.destroy = function () {
              this.element = null;
            };
            function CVBaseElement() {}
            var operationsMap = {
              1: 'source-in',
              2: 'source-out',
              3: 'source-in',
              4: 'source-out'
            };
            CVBaseElement.prototype = {
              createElements: function createElements() {},
              initRendererElement: function initRendererElement() {},
              createContainerElements: function createContainerElements() {
                // If the layer is masked we will use two buffers to store each different states of the drawing
                // This solution is not ideal for several reason. But unfortunately, because of the recursive
                // nature of the render tree, it's the only simple way to make sure one inner mask doesn't override an outer mask.
                // TODO: try to reduce the size of these buffers to the size of the composition contaning the layer
                // It might be challenging because the layer most likely is transformed in some way
                if (this.data.tt >= 1) {
                  this.buffers = [];
                  var canvasContext = this.globalData.canvasContext;
                  var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
                  this.buffers.push(bufferCanvas);
                  var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
                  this.buffers.push(bufferCanvas2);
                  if (this.data.tt >= 3 && !document._isProxy) {
                    assetLoader.loadLumaCanvas();
                  }
                }
                this.canvasContext = this.globalData.canvasContext;
                this.transformCanvas = this.globalData.transformCanvas;
                this.renderableEffectsManager = new CVEffects(this);
                this.searchEffectTransforms();
              },
              createContent: function createContent() {},
              setBlendMode: function setBlendMode() {
                var globalData = this.globalData;
                if (globalData.blendMode !== this.data.bm) {
                  globalData.blendMode = this.data.bm;
                  var blendModeValue = getBlendMode(this.data.bm);
                  globalData.canvasContext.globalCompositeOperation = blendModeValue;
                }
              },
              createRenderableComponents: function createRenderableComponents() {
                this.maskManager = new CVMaskElement(this.data, this);
                this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
              },
              hideElement: function hideElement() {
                if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                  this.hidden = true;
                }
              },
              showElement: function showElement() {
                if (this.isInRange && !this.isTransparent) {
                  this.hidden = false;
                  this._isFirstFrame = true;
                  this.maskManager._isFirstFrame = true;
                }
              },
              clearCanvas: function clearCanvas(canvasContext) {
                canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);
              },
              prepareLayer: function prepareLayer() {
                if (this.data.tt >= 1) {
                  var buffer = this.buffers[0];
                  var bufferCtx = buffer.getContext('2d');
                  this.clearCanvas(bufferCtx); // on the first buffer we store the current state of the global drawing

                  bufferCtx.drawImage(this.canvasContext.canvas, 0, 0); // The next four lines are to clear the canvas
                  // TODO: Check if there is a way to clear the canvas without resetting the transform

                  this.currentTransform = this.canvasContext.getTransform();
                  this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
                  this.clearCanvas(this.canvasContext);
                  this.canvasContext.setTransform(this.currentTransform);
                }
              },
              exitLayer: function exitLayer() {
                if (this.data.tt >= 1) {
                  var buffer = this.buffers[1]; // On the second buffer we store the current state of the global drawing
                  // that only contains the content of this layer
                  // (if it is a composition, it also includes the nested layers)

                  var bufferCtx = buffer.getContext('2d');
                  this.clearCanvas(bufferCtx);
                  bufferCtx.drawImage(this.canvasContext.canvas, 0, 0); // We clear the canvas again

                  this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
                  this.clearCanvas(this.canvasContext);
                  this.canvasContext.setTransform(this.currentTransform); // We draw the mask

                  var mask = this.comp.getElementById('tp' in this.data ? this.data.tp : this.data.ind - 1);
                  mask.renderFrame(true); // We draw the second buffer (that contains the content of this layer)

                  this.canvasContext.setTransform(1, 0, 0, 1, 0, 0); // If the mask is a Luma matte, we need to do two extra painting operations
                  // the _isProxy check is to avoid drawing a fake canvas in workers that will throw an error

                  if (this.data.tt >= 3 && !document._isProxy) {
                    // We copy the painted mask to a buffer that has a color matrix filter applied to it
                    // that applies the rgb values to the alpha channel
                    var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);
                    var lumaBufferCtx = lumaBuffer.getContext('2d');
                    lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
                    this.clearCanvas(this.canvasContext); // we repaint the context with the mask applied to it

                    this.canvasContext.drawImage(lumaBuffer, 0, 0);
                  }
                  this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];
                  this.canvasContext.drawImage(buffer, 0, 0); // We finally draw the first buffer (that contains the content of the global drawing)
                  // We use destination-over to draw the global drawing below the current layer

                  this.canvasContext.globalCompositeOperation = 'destination-over';
                  this.canvasContext.drawImage(this.buffers[0], 0, 0);
                  this.canvasContext.setTransform(this.currentTransform); // We reset the globalCompositeOperation to source-over, the standard type of operation

                  this.canvasContext.globalCompositeOperation = 'source-over';
                }
              },
              renderFrame: function renderFrame(forceRender) {
                if (this.hidden || this.data.hd) {
                  return;
                }
                if (this.data.td === 1 && !forceRender) {
                  return;
                }
                this.renderTransform();
                this.renderRenderable();
                this.renderLocalTransform();
                this.setBlendMode();
                var forceRealStack = this.data.ty === 0;
                this.prepareLayer();
                this.globalData.renderer.save(forceRealStack);
                this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);
                this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);
                this.renderInnerContent();
                this.globalData.renderer.restore(forceRealStack);
                this.exitLayer();
                if (this.maskManager.hasMasks) {
                  this.globalData.renderer.restore(true);
                }
                if (this._isFirstFrame) {
                  this._isFirstFrame = false;
                }
              },
              destroy: function destroy() {
                this.canvasContext = null;
                this.data = null;
                this.globalData = null;
                this.maskManager.destroy();
              },
              mHelper: new Matrix()
            };
            CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
            CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
            function CVShapeData(element, data, styles, transformsManager) {
              this.styledShapes = [];
              this.tr = [0, 0, 0, 0, 0, 0];
              var ty = 4;
              if (data.ty === 'rc') {
                ty = 5;
              } else if (data.ty === 'el') {
                ty = 6;
              } else if (data.ty === 'sr') {
                ty = 7;
              }
              this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);
              var i;
              var len = styles.length;
              var styledShape;
              for (i = 0; i < len; i += 1) {
                if (!styles[i].closed) {
                  styledShape = {
                    transforms: transformsManager.addTransformSequence(styles[i].transforms),
                    trNodes: []
                  };
                  this.styledShapes.push(styledShape);
                  styles[i].elements.push(styledShape);
                }
              }
            }
            CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
            function CVShapeElement(data, globalData, comp) {
              this.shapes = [];
              this.shapesData = data.shapes;
              this.stylesList = [];
              this.itemsData = [];
              this.prevViewData = [];
              this.shapeModifiers = [];
              this.processedElements = [];
              this.transformsManager = new ShapeTransformManager();
              this.initElement(data, globalData, comp);
            }
            extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);
            CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
            CVShapeElement.prototype.transformHelper = {
              opacity: 1,
              _opMdf: false
            };
            CVShapeElement.prototype.dashResetter = [];
            CVShapeElement.prototype.createContent = function () {
              this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
            };
            CVShapeElement.prototype.createStyleElement = function (data, transforms) {
              var styleElem = {
                data: data,
                type: data.ty,
                preTransforms: this.transformsManager.addTransformSequence(transforms),
                transforms: [],
                elements: [],
                closed: data.hd === true
              };
              var elementData = {};
              if (data.ty === 'fl' || data.ty === 'st') {
                elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);
                if (!elementData.c.k) {
                  styleElem.co = 'rgb(' + bmFloor(elementData.c.v[0]) + ',' + bmFloor(elementData.c.v[1]) + ',' + bmFloor(elementData.c.v[2]) + ')';
                }
              } else if (data.ty === 'gf' || data.ty === 'gs') {
                elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);
                elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);
                elementData.h = PropertyFactory.getProp(this, data.h || {
                  k: 0
                }, 0, 0.01, this);
                elementData.a = PropertyFactory.getProp(this, data.a || {
                  k: 0
                }, 0, degToRads, this);
                elementData.g = new GradientProperty(this, data.g, this);
              }
              elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);
              if (data.ty === 'st' || data.ty === 'gs') {
                styleElem.lc = lineCapEnum[data.lc || 2];
                styleElem.lj = lineJoinEnum[data.lj || 2];
                if (data.lj == 1) {
                  // eslint-disable-line eqeqeq
                  styleElem.ml = data.ml;
                }
                elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);
                if (!elementData.w.k) {
                  styleElem.wi = elementData.w.v;
                }
                if (data.d) {
                  var d = new DashProperty(this, data.d, 'canvas', this);
                  elementData.d = d;
                  if (!elementData.d.k) {
                    styleElem.da = elementData.d.dashArray;
                    styleElem["do"] = elementData.d.dashoffset[0];
                  }
                }
              } else {
                styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';
              }
              this.stylesList.push(styleElem);
              elementData.style = styleElem;
              return elementData;
            };
            CVShapeElement.prototype.createGroupElement = function () {
              var elementData = {
                it: [],
                prevViewData: []
              };
              return elementData;
            };
            CVShapeElement.prototype.createTransformElement = function (data) {
              var elementData = {
                transform: {
                  opacity: 1,
                  _opMdf: false,
                  key: this.transformsManager.getNewKey(),
                  op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),
                  mProps: TransformPropertyFactory.getTransformProperty(this, data, this)
                }
              };
              return elementData;
            };
            CVShapeElement.prototype.createShapeElement = function (data) {
              var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);
              this.shapes.push(elementData);
              this.addShapeToModifiers(elementData);
              return elementData;
            };
            CVShapeElement.prototype.reloadShapes = function () {
              this._isFirstFrame = true;
              var i;
              var len = this.itemsData.length;
              for (i = 0; i < len; i += 1) {
                this.prevViewData[i] = this.itemsData[i];
              }
              this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
              len = this.dynamicProperties.length;
              for (i = 0; i < len; i += 1) {
                this.dynamicProperties[i].getValue();
              }
              this.renderModifiers();
              this.transformsManager.processSequences(this._isFirstFrame);
            };
            CVShapeElement.prototype.addTransformToStyleList = function (transform) {
              var i;
              var len = this.stylesList.length;
              for (i = 0; i < len; i += 1) {
                if (!this.stylesList[i].closed) {
                  this.stylesList[i].transforms.push(transform);
                }
              }
            };
            CVShapeElement.prototype.removeTransformFromStyleList = function () {
              var i;
              var len = this.stylesList.length;
              for (i = 0; i < len; i += 1) {
                if (!this.stylesList[i].closed) {
                  this.stylesList[i].transforms.pop();
                }
              }
            };
            CVShapeElement.prototype.closeStyles = function (styles) {
              var i;
              var len = styles.length;
              for (i = 0; i < len; i += 1) {
                styles[i].closed = true;
              }
            };
            CVShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, shouldRender, transforms) {
              var i;
              var len = arr.length - 1;
              var j;
              var jLen;
              var ownStyles = [];
              var ownModifiers = [];
              var processedPos;
              var modifier;
              var currentTransform;
              var ownTransforms = [].concat(transforms);
              for (i = len; i >= 0; i -= 1) {
                processedPos = this.searchProcessedElement(arr[i]);
                if (!processedPos) {
                  arr[i]._shouldRender = shouldRender;
                } else {
                  itemsData[i] = prevViewData[processedPos - 1];
                }
                if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {
                  if (!processedPos) {
                    itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
                  } else {
                    itemsData[i].style.closed = false;
                  }
                  ownStyles.push(itemsData[i].style);
                } else if (arr[i].ty === 'gr') {
                  if (!processedPos) {
                    itemsData[i] = this.createGroupElement(arr[i]);
                  } else {
                    jLen = itemsData[i].it.length;
                    for (j = 0; j < jLen; j += 1) {
                      itemsData[i].prevViewData[j] = itemsData[i].it[j];
                    }
                  }
                  this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);
                } else if (arr[i].ty === 'tr') {
                  if (!processedPos) {
                    currentTransform = this.createTransformElement(arr[i]);
                    itemsData[i] = currentTransform;
                  }
                  ownTransforms.push(itemsData[i]);
                  this.addTransformToStyleList(itemsData[i]);
                } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
                  if (!processedPos) {
                    itemsData[i] = this.createShapeElement(arr[i]);
                  }
                } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'pb' || arr[i].ty === 'zz' || arr[i].ty === 'op') {
                  if (!processedPos) {
                    modifier = ShapeModifiers.getModifier(arr[i].ty);
                    modifier.init(this, arr[i]);
                    itemsData[i] = modifier;
                    this.shapeModifiers.push(modifier);
                  } else {
                    modifier = itemsData[i];
                    modifier.closed = false;
                  }
                  ownModifiers.push(modifier);
                } else if (arr[i].ty === 'rp') {
                  if (!processedPos) {
                    modifier = ShapeModifiers.getModifier(arr[i].ty);
                    itemsData[i] = modifier;
                    modifier.init(this, arr, i, itemsData);
                    this.shapeModifiers.push(modifier);
                    shouldRender = false;
                  } else {
                    modifier = itemsData[i];
                    modifier.closed = true;
                  }
                  ownModifiers.push(modifier);
                }
                this.addProcessedElement(arr[i], i + 1);
              }
              this.removeTransformFromStyleList();
              this.closeStyles(ownStyles);
              len = ownModifiers.length;
              for (i = 0; i < len; i += 1) {
                ownModifiers[i].closed = true;
              }
            };
            CVShapeElement.prototype.renderInnerContent = function () {
              this.transformHelper.opacity = 1;
              this.transformHelper._opMdf = false;
              this.renderModifiers();
              this.transformsManager.processSequences(this._isFirstFrame);
              this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
            };
            CVShapeElement.prototype.renderShapeTransform = function (parentTransform, groupTransform) {
              if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
                groupTransform.opacity = parentTransform.opacity;
                groupTransform.opacity *= groupTransform.op.v;
                groupTransform._opMdf = true;
              }
            };
            CVShapeElement.prototype.drawLayer = function () {
              var i;
              var len = this.stylesList.length;
              var j;
              var jLen;
              var k;
              var kLen;
              var elems;
              var nodes;
              var renderer = this.globalData.renderer;
              var ctx = this.globalData.canvasContext;
              var type;
              var currentStyle;
              for (i = 0; i < len; i += 1) {
                currentStyle = this.stylesList[i];
                type = currentStyle.type; // Skipping style when
                // Stroke width equals 0
                // style should not be rendered (extra unused repeaters)
                // current opacity equals 0
                // global opacity equals 0

                if (!((type === 'st' || type === 'gs') && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
                  renderer.save();
                  elems = currentStyle.elements;
                  if (type === 'st' || type === 'gs') {
                    renderer.ctxStrokeStyle(type === 'st' ? currentStyle.co : currentStyle.grd); // ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;

                    renderer.ctxLineWidth(currentStyle.wi); // ctx.lineWidth = currentStyle.wi;

                    renderer.ctxLineCap(currentStyle.lc); // ctx.lineCap = currentStyle.lc;

                    renderer.ctxLineJoin(currentStyle.lj); // ctx.lineJoin = currentStyle.lj;

                    renderer.ctxMiterLimit(currentStyle.ml || 0); // ctx.miterLimit = currentStyle.ml || 0;
                  } else {
                    renderer.ctxFillStyle(type === 'fl' ? currentStyle.co : currentStyle.grd); // ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;
                  }
                  renderer.ctxOpacity(currentStyle.coOp);
                  if (type !== 'st' && type !== 'gs') {
                    ctx.beginPath();
                  }
                  renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
                  jLen = elems.length;
                  for (j = 0; j < jLen; j += 1) {
                    if (type === 'st' || type === 'gs') {
                      ctx.beginPath();
                      if (currentStyle.da) {
                        ctx.setLineDash(currentStyle.da);
                        ctx.lineDashOffset = currentStyle["do"];
                      }
                    }
                    nodes = elems[j].trNodes;
                    kLen = nodes.length;
                    for (k = 0; k < kLen; k += 1) {
                      if (nodes[k].t === 'm') {
                        ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);
                      } else if (nodes[k].t === 'c') {
                        ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);
                      } else {
                        ctx.closePath();
                      }
                    }
                    if (type === 'st' || type === 'gs') {
                      // ctx.stroke();
                      renderer.ctxStroke();
                      if (currentStyle.da) {
                        ctx.setLineDash(this.dashResetter);
                      }
                    }
                  }
                  if (type !== 'st' && type !== 'gs') {
                    // ctx.fill(currentStyle.r);
                    this.globalData.renderer.ctxFill(currentStyle.r);
                  }
                  renderer.restore();
                }
              }
            };
            CVShapeElement.prototype.renderShape = function (parentTransform, items, data, isMain) {
              var i;
              var len = items.length - 1;
              var groupTransform;
              groupTransform = parentTransform;
              for (i = len; i >= 0; i -= 1) {
                if (items[i].ty === 'tr') {
                  groupTransform = data[i].transform;
                  this.renderShapeTransform(parentTransform, groupTransform);
                } else if (items[i].ty === 'sh' || items[i].ty === 'el' || items[i].ty === 'rc' || items[i].ty === 'sr') {
                  this.renderPath(items[i], data[i]);
                } else if (items[i].ty === 'fl') {
                  this.renderFill(items[i], data[i], groupTransform);
                } else if (items[i].ty === 'st') {
                  this.renderStroke(items[i], data[i], groupTransform);
                } else if (items[i].ty === 'gf' || items[i].ty === 'gs') {
                  this.renderGradientFill(items[i], data[i], groupTransform);
                } else if (items[i].ty === 'gr') {
                  this.renderShape(groupTransform, items[i].it, data[i].it);
                } else if (items[i].ty === 'tm') ;
              }
              if (isMain) {
                this.drawLayer();
              }
            };
            CVShapeElement.prototype.renderStyledShape = function (styledShape, shape) {
              if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
                var shapeNodes = styledShape.trNodes;
                var paths = shape.paths;
                var i;
                var len;
                var j;
                var jLen = paths._length;
                shapeNodes.length = 0;
                var groupTransformMat = styledShape.transforms.finalTransform;
                for (j = 0; j < jLen; j += 1) {
                  var pathNodes = paths.shapes[j];
                  if (pathNodes && pathNodes.v) {
                    len = pathNodes._length;
                    for (i = 1; i < len; i += 1) {
                      if (i === 1) {
                        shapeNodes.push({
                          t: 'm',
                          p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                        });
                      }
                      shapeNodes.push({
                        t: 'c',
                        pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])
                      });
                    }
                    if (len === 1) {
                      shapeNodes.push({
                        t: 'm',
                        p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                      });
                    }
                    if (pathNodes.c && len) {
                      shapeNodes.push({
                        t: 'c',
                        pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])
                      });
                      shapeNodes.push({
                        t: 'z'
                      });
                    }
                  }
                }
                styledShape.trNodes = shapeNodes;
              }
            };
            CVShapeElement.prototype.renderPath = function (pathData, itemData) {
              if (pathData.hd !== true && pathData._shouldRender) {
                var i;
                var len = itemData.styledShapes.length;
                for (i = 0; i < len; i += 1) {
                  this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
                }
              }
            };
            CVShapeElement.prototype.renderFill = function (styleData, itemData, groupTransform) {
              var styleElem = itemData.style;
              if (itemData.c._mdf || this._isFirstFrame) {
                styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';
              }
              if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
                styleElem.coOp = itemData.o.v * groupTransform.opacity;
              }
            };
            CVShapeElement.prototype.renderGradientFill = function (styleData, itemData, groupTransform) {
              var styleElem = itemData.style;
              var grd;
              if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {
                var ctx = this.globalData.canvasContext;
                var pt1 = itemData.s.v;
                var pt2 = itemData.e.v;
                if (styleData.t === 1) {
                  grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
                } else {
                  var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                  var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
                  var percent = itemData.h.v;
                  if (percent >= 1) {
                    percent = 0.99;
                  } else if (percent <= -1) {
                    percent = -0.99;
                  }
                  var dist = rad * percent;
                  var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
                  var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
                  grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
                }
                var i;
                var len = styleData.g.p;
                var cValues = itemData.g.c;
                var opacity = 1;
                for (i = 0; i < len; i += 1) {
                  if (itemData.g._hasOpacity && itemData.g._collapsable) {
                    opacity = itemData.g.o[i * 2 + 1];
                  }
                  grd.addColorStop(cValues[i * 4] / 100, 'rgba(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ',' + opacity + ')');
                }
                styleElem.grd = grd;
              }
              styleElem.coOp = itemData.o.v * groupTransform.opacity;
            };
            CVShapeElement.prototype.renderStroke = function (styleData, itemData, groupTransform) {
              var styleElem = itemData.style;
              var d = itemData.d;
              if (d && (d._mdf || this._isFirstFrame)) {
                styleElem.da = d.dashArray;
                styleElem["do"] = d.dashoffset[0];
              }
              if (itemData.c._mdf || this._isFirstFrame) {
                styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';
              }
              if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
                styleElem.coOp = itemData.o.v * groupTransform.opacity;
              }
              if (itemData.w._mdf || this._isFirstFrame) {
                styleElem.wi = itemData.w.v;
              }
            };
            CVShapeElement.prototype.destroy = function () {
              this.shapesData = null;
              this.globalData = null;
              this.canvasContext = null;
              this.stylesList.length = 0;
              this.itemsData.length = 0;
            };
            function CVTextElement(data, globalData, comp) {
              this.textSpans = [];
              this.yOffset = 0;
              this.fillColorAnim = false;
              this.strokeColorAnim = false;
              this.strokeWidthAnim = false;
              this.stroke = false;
              this.fill = false;
              this.justifyOffset = 0;
              this.currentRender = null;
              this.renderType = 'canvas';
              this.values = {
                fill: 'rgba(0,0,0,0)',
                stroke: 'rgba(0,0,0,0)',
                sWidth: 0,
                fValue: ''
              };
              this.initElement(data, globalData, comp);
            }
            extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);
            CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');
            CVTextElement.prototype.buildNewText = function () {
              var documentData = this.textProperty.currentData;
              this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
              var hasFill = false;
              if (documentData.fc) {
                hasFill = true;
                this.values.fill = this.buildColor(documentData.fc);
              } else {
                this.values.fill = 'rgba(0,0,0,0)';
              }
              this.fill = hasFill;
              var hasStroke = false;
              if (documentData.sc) {
                hasStroke = true;
                this.values.stroke = this.buildColor(documentData.sc);
                this.values.sWidth = documentData.sw;
              }
              var fontData = this.globalData.fontManager.getFontByName(documentData.f);
              var i;
              var len;
              var letters = documentData.l;
              var matrixHelper = this.mHelper;
              this.stroke = hasStroke;
              this.values.fValue = documentData.finalSize + 'px ' + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
              len = documentData.finalText.length; // this.tHelper.font = this.values.fValue;

              var charData;
              var shapeData;
              var k;
              var kLen;
              var shapes;
              var j;
              var jLen;
              var pathNodes;
              var commands;
              var pathArr;
              var singleShape = this.data.singleShape;
              var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
              var xPos = 0;
              var yPos = 0;
              var firstLine = true;
              var cnt = 0;
              for (i = 0; i < len; i += 1) {
                charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
                shapeData = charData && charData.data || {};
                matrixHelper.reset();
                if (singleShape && letters[i].n) {
                  xPos = -trackingOffset;
                  yPos += documentData.yOffset;
                  yPos += firstLine ? 1 : 0;
                  firstLine = false;
                }
                shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
                jLen = shapes.length;
                matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
                if (singleShape) {
                  this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
                }
                commands = createSizedArray(jLen - 1);
                var commandsCounter = 0;
                for (j = 0; j < jLen; j += 1) {
                  if (shapes[j].ty === 'sh') {
                    kLen = shapes[j].ks.k.i.length;
                    pathNodes = shapes[j].ks.k;
                    pathArr = [];
                    for (k = 1; k < kLen; k += 1) {
                      if (k === 1) {
                        pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
                      }
                      pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
                    }
                    pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
                    commands[commandsCounter] = pathArr;
                    commandsCounter += 1;
                  }
                }
                if (singleShape) {
                  xPos += letters[i].l;
                  xPos += trackingOffset;
                }
                if (this.textSpans[cnt]) {
                  this.textSpans[cnt].elem = commands;
                } else {
                  this.textSpans[cnt] = {
                    elem: commands
                  };
                }
                cnt += 1;
              }
            };
            CVTextElement.prototype.renderInnerContent = function () {
              this.validateText();
              var ctx = this.canvasContext;
              ctx.font = this.values.fValue;
              this.globalData.renderer.ctxLineCap('butt'); // ctx.lineCap = 'butt';

              this.globalData.renderer.ctxLineJoin('miter'); // ctx.lineJoin = 'miter';

              this.globalData.renderer.ctxMiterLimit(4); // ctx.miterLimit = 4;

              if (!this.data.singleShape) {
                this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
              }
              var i;
              var len;
              var j;
              var jLen;
              var k;
              var kLen;
              var renderedLetters = this.textAnimator.renderedLetters;
              var letters = this.textProperty.currentData.l;
              len = letters.length;
              var renderedLetter;
              var lastFill = null;
              var lastStroke = null;
              var lastStrokeW = null;
              var commands;
              var pathArr;
              var renderer = this.globalData.renderer;
              for (i = 0; i < len; i += 1) {
                if (!letters[i].n) {
                  renderedLetter = renderedLetters[i];
                  if (renderedLetter) {
                    renderer.save();
                    renderer.ctxTransform(renderedLetter.p);
                    renderer.ctxOpacity(renderedLetter.o);
                  }
                  if (this.fill) {
                    if (renderedLetter && renderedLetter.fc) {
                      if (lastFill !== renderedLetter.fc) {
                        renderer.ctxFillStyle(renderedLetter.fc);
                        lastFill = renderedLetter.fc; // ctx.fillStyle = renderedLetter.fc;
                      }
                    } else if (lastFill !== this.values.fill) {
                      lastFill = this.values.fill;
                      renderer.ctxFillStyle(this.values.fill); // ctx.fillStyle = this.values.fill;
                    }
                    commands = this.textSpans[i].elem;
                    jLen = commands.length;
                    this.globalData.canvasContext.beginPath();
                    for (j = 0; j < jLen; j += 1) {
                      pathArr = commands[j];
                      kLen = pathArr.length;
                      this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                      for (k = 2; k < kLen; k += 6) {
                        this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                      }
                    }
                    this.globalData.canvasContext.closePath();
                    renderer.ctxFill(); // this.globalData.canvasContext.fill();
                    /// ctx.fillText(this.textSpans[i].val,0,0);
                  }
                  if (this.stroke) {
                    if (renderedLetter && renderedLetter.sw) {
                      if (lastStrokeW !== renderedLetter.sw) {
                        lastStrokeW = renderedLetter.sw;
                        renderer.ctxLineWidth(renderedLetter.sw); // ctx.lineWidth = renderedLetter.sw;
                      }
                    } else if (lastStrokeW !== this.values.sWidth) {
                      lastStrokeW = this.values.sWidth;
                      renderer.ctxLineWidth(this.values.sWidth); // ctx.lineWidth = this.values.sWidth;
                    }
                    if (renderedLetter && renderedLetter.sc) {
                      if (lastStroke !== renderedLetter.sc) {
                        lastStroke = renderedLetter.sc;
                        renderer.ctxStrokeStyle(renderedLetter.sc); // ctx.strokeStyle = renderedLetter.sc;
                      }
                    } else if (lastStroke !== this.values.stroke) {
                      lastStroke = this.values.stroke;
                      renderer.ctxStrokeStyle(this.values.stroke); // ctx.strokeStyle = this.values.stroke;
                    }
                    commands = this.textSpans[i].elem;
                    jLen = commands.length;
                    this.globalData.canvasContext.beginPath();
                    for (j = 0; j < jLen; j += 1) {
                      pathArr = commands[j];
                      kLen = pathArr.length;
                      this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                      for (k = 2; k < kLen; k += 6) {
                        this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                      }
                    }
                    this.globalData.canvasContext.closePath();
                    renderer.ctxStroke(); // this.globalData.canvasContext.stroke();
                    /// ctx.strokeText(letters[i].val,0,0);
                  }
                  if (renderedLetter) {
                    this.globalData.renderer.restore();
                  }
                }
              }
            };
            function CVImageElement(data, globalData, comp) {
              this.assetData = globalData.getAssetData(data.refId);
              this.img = globalData.imageLoader.getAsset(this.assetData);
              this.initElement(data, globalData, comp);
            }
            extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);
            CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
            CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
            CVImageElement.prototype.createContent = function () {
              if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
                var canvas = createTag('canvas');
                canvas.width = this.assetData.w;
                canvas.height = this.assetData.h;
                var ctx = canvas.getContext('2d');
                var imgW = this.img.width;
                var imgH = this.img.height;
                var imgRel = imgW / imgH;
                var canvasRel = this.assetData.w / this.assetData.h;
                var widthCrop;
                var heightCrop;
                var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
                if (imgRel > canvasRel && par === 'xMidYMid slice' || imgRel < canvasRel && par !== 'xMidYMid slice') {
                  heightCrop = imgH;
                  widthCrop = heightCrop * canvasRel;
                } else {
                  widthCrop = imgW;
                  heightCrop = widthCrop / canvasRel;
                }
                ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
                this.img = canvas;
              }
            };
            CVImageElement.prototype.renderInnerContent = function () {
              this.canvasContext.drawImage(this.img, 0, 0);
            };
            CVImageElement.prototype.destroy = function () {
              this.img = null;
            };
            function CVSolidElement(data, globalData, comp) {
              this.initElement(data, globalData, comp);
            }
            extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);
            CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
            CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
            CVSolidElement.prototype.renderInnerContent = function () {
              // var ctx = this.canvasContext;
              this.globalData.renderer.ctxFillStyle(this.data.sc); // ctx.fillStyle = this.data.sc;

              this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh); // ctx.fillRect(0, 0, this.data.sw, this.data.sh);
              //
            };
            function CanvasRendererBase() {}
            extendPrototype([BaseRenderer], CanvasRendererBase);
            CanvasRendererBase.prototype.createShape = function (data) {
              return new CVShapeElement(data, this.globalData, this);
            };
            CanvasRendererBase.prototype.createText = function (data) {
              return new CVTextElement(data, this.globalData, this);
            };
            CanvasRendererBase.prototype.createImage = function (data) {
              return new CVImageElement(data, this.globalData, this);
            };
            CanvasRendererBase.prototype.createSolid = function (data) {
              return new CVSolidElement(data, this.globalData, this);
            };
            CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
            CanvasRendererBase.prototype.ctxTransform = function (props) {
              if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
                return;
              }
              this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
            };
            CanvasRendererBase.prototype.ctxOpacity = function (op) {
              this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
            };
            CanvasRendererBase.prototype.ctxFillStyle = function (value) {
              this.canvasContext.fillStyle = value;
            };
            CanvasRendererBase.prototype.ctxStrokeStyle = function (value) {
              this.canvasContext.strokeStyle = value;
            };
            CanvasRendererBase.prototype.ctxLineWidth = function (value) {
              this.canvasContext.lineWidth = value;
            };
            CanvasRendererBase.prototype.ctxLineCap = function (value) {
              this.canvasContext.lineCap = value;
            };
            CanvasRendererBase.prototype.ctxLineJoin = function (value) {
              this.canvasContext.lineJoin = value;
            };
            CanvasRendererBase.prototype.ctxMiterLimit = function (value) {
              this.canvasContext.miterLimit = value;
            };
            CanvasRendererBase.prototype.ctxFill = function (rule) {
              this.canvasContext.fill(rule);
            };
            CanvasRendererBase.prototype.ctxFillRect = function (x, y, w, h) {
              this.canvasContext.fillRect(x, y, w, h);
            };
            CanvasRendererBase.prototype.ctxStroke = function () {
              this.canvasContext.stroke();
            };
            CanvasRendererBase.prototype.reset = function () {
              if (!this.renderConfig.clearCanvas) {
                this.canvasContext.restore();
                return;
              }
              this.contextData.reset();
            };
            CanvasRendererBase.prototype.save = function () {
              this.canvasContext.save();
            };
            CanvasRendererBase.prototype.restore = function (actionFlag) {
              if (!this.renderConfig.clearCanvas) {
                this.canvasContext.restore();
                return;
              }
              if (actionFlag) {
                this.globalData.blendMode = 'source-over';
              }
              this.contextData.restore(actionFlag);
            };
            CanvasRendererBase.prototype.configAnimation = function (animData) {
              if (this.animationItem.wrapper) {
                this.animationItem.container = createTag('canvas');
                var containerStyle = this.animationItem.container.style;
                containerStyle.width = '100%';
                containerStyle.height = '100%';
                var origin = '0px 0px 0px';
                containerStyle.transformOrigin = origin;
                containerStyle.mozTransformOrigin = origin;
                containerStyle.webkitTransformOrigin = origin;
                containerStyle['-webkit-transform'] = origin;
                containerStyle.contentVisibility = this.renderConfig.contentVisibility;
                this.animationItem.wrapper.appendChild(this.animationItem.container);
                this.canvasContext = this.animationItem.container.getContext('2d');
                if (this.renderConfig.className) {
                  this.animationItem.container.setAttribute('class', this.renderConfig.className);
                }
                if (this.renderConfig.id) {
                  this.animationItem.container.setAttribute('id', this.renderConfig.id);
                }
              } else {
                this.canvasContext = this.renderConfig.context;
              }
              this.contextData.setContext(this.canvasContext);
              this.data = animData;
              this.layers = animData.layers;
              this.transformCanvas = {
                w: animData.w,
                h: animData.h,
                sx: 0,
                sy: 0,
                tx: 0,
                ty: 0
              };
              this.setupGlobalData(animData, document.body);
              this.globalData.canvasContext = this.canvasContext;
              this.globalData.renderer = this;
              this.globalData.isDashed = false;
              this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
              this.globalData.transformCanvas = this.transformCanvas;
              this.elements = createSizedArray(animData.layers.length);
              this.updateContainerSize();
            };
            CanvasRendererBase.prototype.updateContainerSize = function (width, height) {
              this.reset();
              var elementWidth;
              var elementHeight;
              if (width) {
                elementWidth = width;
                elementHeight = height;
                this.canvasContext.canvas.width = elementWidth;
                this.canvasContext.canvas.height = elementHeight;
              } else {
                if (this.animationItem.wrapper && this.animationItem.container) {
                  elementWidth = this.animationItem.wrapper.offsetWidth;
                  elementHeight = this.animationItem.wrapper.offsetHeight;
                } else {
                  elementWidth = this.canvasContext.canvas.width;
                  elementHeight = this.canvasContext.canvas.height;
                }
                this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;
                this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;
              }
              var elementRel;
              var animationRel;
              if (this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1) {
                var par = this.renderConfig.preserveAspectRatio.split(' ');
                var fillType = par[1] || 'meet';
                var pos = par[0] || 'xMidYMid';
                var xPos = pos.substr(0, 4);
                var yPos = pos.substr(4);
                elementRel = elementWidth / elementHeight;
                animationRel = this.transformCanvas.w / this.transformCanvas.h;
                if (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice') {
                  this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
                  this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
                } else {
                  this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
                  this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
                }
                if (xPos === 'xMid' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {
                  this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;
                } else if (xPos === 'xMax' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {
                  this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
                } else {
                  this.transformCanvas.tx = 0;
                }
                if (yPos === 'YMid' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {
                  this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;
                } else if (yPos === 'YMax' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {
                  this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;
                } else {
                  this.transformCanvas.ty = 0;
                }
              } else if (this.renderConfig.preserveAspectRatio === 'none') {
                this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
                this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
                this.transformCanvas.tx = 0;
                this.transformCanvas.ty = 0;
              } else {
                this.transformCanvas.sx = this.renderConfig.dpr;
                this.transformCanvas.sy = this.renderConfig.dpr;
                this.transformCanvas.tx = 0;
                this.transformCanvas.ty = 0;
              }
              this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
              /* var i, len = this.elements.length;
                for(i=0;i<len;i+=1){
                    if(this.elements[i] && this.elements[i].data.ty === 0){
                        this.elements[i].resize(this.globalData.transformCanvas);
                    }
                } */

              this.ctxTransform(this.transformCanvas.props);
              this.canvasContext.beginPath();
              this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
              this.canvasContext.closePath();
              this.canvasContext.clip();
              this.renderFrame(this.renderedFrame, true);
            };
            CanvasRendererBase.prototype.destroy = function () {
              if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
                this.animationItem.wrapper.innerText = '';
              }
              var i;
              var len = this.layers ? this.layers.length : 0;
              for (i = len - 1; i >= 0; i -= 1) {
                if (this.elements[i] && this.elements[i].destroy) {
                  this.elements[i].destroy();
                }
              }
              this.elements.length = 0;
              this.globalData.canvasContext = null;
              this.animationItem.container = null;
              this.destroyed = true;
            };
            CanvasRendererBase.prototype.renderFrame = function (num, forceRender) {
              if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {
                return;
              }
              this.renderedFrame = num;
              this.globalData.frameNum = num - this.animationItem._isFirstFrame;
              this.globalData.frameId += 1;
              this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
              this.globalData.projectInterface.currentFrame = num; // console.log('--------');
              // console.log('NEW: ',num);

              var i;
              var len = this.layers.length;
              if (!this.completeLayers) {
                this.checkLayers(num);
              }
              for (i = len - 1; i >= 0; i -= 1) {
                if (this.completeLayers || this.elements[i]) {
                  this.elements[i].prepareFrame(num - this.layers[i].st);
                }
              }
              if (this.globalData._mdf) {
                if (this.renderConfig.clearCanvas === true) {
                  this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
                } else {
                  this.save();
                }
                for (i = len - 1; i >= 0; i -= 1) {
                  if (this.completeLayers || this.elements[i]) {
                    this.elements[i].renderFrame();
                  }
                }
                if (this.renderConfig.clearCanvas !== true) {
                  this.restore();
                }
              }
            };
            CanvasRendererBase.prototype.buildItem = function (pos) {
              var elements = this.elements;
              if (elements[pos] || this.layers[pos].ty === 99) {
                return;
              }
              var element = this.createItem(this.layers[pos], this, this.globalData);
              elements[pos] = element;
              element.initExpressions();
              /* if(this.layers[pos].ty === 0){
                    element.resize(this.globalData.transformCanvas);
                } */
            };
            CanvasRendererBase.prototype.checkPendingElements = function () {
              while (this.pendingElements.length) {
                var element = this.pendingElements.pop();
                element.checkParenting();
              }
            };
            CanvasRendererBase.prototype.hide = function () {
              this.animationItem.container.style.display = 'none';
            };
            CanvasRendererBase.prototype.show = function () {
              this.animationItem.container.style.display = 'block';
            };
            function CanvasContext() {
              this.opacity = -1;
              this.transform = createTypedArray('float32', 16);
              this.fillStyle = '';
              this.strokeStyle = '';
              this.lineWidth = '';
              this.lineCap = '';
              this.lineJoin = '';
              this.miterLimit = '';
              this.id = Math.random();
            }
            function CVContextData() {
              this.stack = [];
              this.cArrPos = 0;
              this.cTr = new Matrix();
              var i;
              var len = 15;
              for (i = 0; i < len; i += 1) {
                var canvasContext = new CanvasContext();
                this.stack[i] = canvasContext;
              }
              this._length = len;
              this.nativeContext = null;
              this.transformMat = new Matrix();
              this.currentOpacity = 1; //

              this.currentFillStyle = '';
              this.appliedFillStyle = ''; //

              this.currentStrokeStyle = '';
              this.appliedStrokeStyle = ''; //

              this.currentLineWidth = '';
              this.appliedLineWidth = ''; //

              this.currentLineCap = '';
              this.appliedLineCap = ''; //

              this.currentLineJoin = '';
              this.appliedLineJoin = ''; //

              this.appliedMiterLimit = '';
              this.currentMiterLimit = '';
            }
            CVContextData.prototype.duplicate = function () {
              var newLength = this._length * 2;
              var i = 0;
              for (i = this._length; i < newLength; i += 1) {
                this.stack[i] = new CanvasContext();
              }
              this._length = newLength;
            };
            CVContextData.prototype.reset = function () {
              this.cArrPos = 0;
              this.cTr.reset();
              this.stack[this.cArrPos].opacity = 1;
            };
            CVContextData.prototype.restore = function (forceRestore) {
              this.cArrPos -= 1;
              var currentContext = this.stack[this.cArrPos];
              var transform = currentContext.transform;
              var i;
              var arr = this.cTr.props;
              for (i = 0; i < 16; i += 1) {
                arr[i] = transform[i];
              }
              if (forceRestore) {
                this.nativeContext.restore();
                var prevStack = this.stack[this.cArrPos + 1];
                this.appliedFillStyle = prevStack.fillStyle;
                this.appliedStrokeStyle = prevStack.strokeStyle;
                this.appliedLineWidth = prevStack.lineWidth;
                this.appliedLineCap = prevStack.lineCap;
                this.appliedLineJoin = prevStack.lineJoin;
                this.appliedMiterLimit = prevStack.miterLimit;
              }
              this.nativeContext.setTransform(transform[0], transform[1], transform[4], transform[5], transform[12], transform[13]);
              if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {
                this.nativeContext.globalAlpha = currentContext.opacity;
                this.currentOpacity = currentContext.opacity;
              }
              this.currentFillStyle = currentContext.fillStyle;
              this.currentStrokeStyle = currentContext.strokeStyle;
              this.currentLineWidth = currentContext.lineWidth;
              this.currentLineCap = currentContext.lineCap;
              this.currentLineJoin = currentContext.lineJoin;
              this.currentMiterLimit = currentContext.miterLimit;
            };
            CVContextData.prototype.save = function (saveOnNativeFlag) {
              if (saveOnNativeFlag) {
                this.nativeContext.save();
              }
              var props = this.cTr.props;
              if (this._length <= this.cArrPos) {
                this.duplicate();
              }
              var currentStack = this.stack[this.cArrPos];
              var i;
              for (i = 0; i < 16; i += 1) {
                currentStack.transform[i] = props[i];
              }
              this.cArrPos += 1;
              var newStack = this.stack[this.cArrPos];
              newStack.opacity = currentStack.opacity;
              newStack.fillStyle = currentStack.fillStyle;
              newStack.strokeStyle = currentStack.strokeStyle;
              newStack.lineWidth = currentStack.lineWidth;
              newStack.lineCap = currentStack.lineCap;
              newStack.lineJoin = currentStack.lineJoin;
              newStack.miterLimit = currentStack.miterLimit;
            };
            CVContextData.prototype.setOpacity = function (value) {
              this.stack[this.cArrPos].opacity = value;
            };
            CVContextData.prototype.setContext = function (value) {
              this.nativeContext = value;
            };
            CVContextData.prototype.fillStyle = function (value) {
              if (this.stack[this.cArrPos].fillStyle !== value) {
                this.currentFillStyle = value;
                this.stack[this.cArrPos].fillStyle = value;
              }
            };
            CVContextData.prototype.strokeStyle = function (value) {
              if (this.stack[this.cArrPos].strokeStyle !== value) {
                this.currentStrokeStyle = value;
                this.stack[this.cArrPos].strokeStyle = value;
              }
            };
            CVContextData.prototype.lineWidth = function (value) {
              if (this.stack[this.cArrPos].lineWidth !== value) {
                this.currentLineWidth = value;
                this.stack[this.cArrPos].lineWidth = value;
              }
            };
            CVContextData.prototype.lineCap = function (value) {
              if (this.stack[this.cArrPos].lineCap !== value) {
                this.currentLineCap = value;
                this.stack[this.cArrPos].lineCap = value;
              }
            };
            CVContextData.prototype.lineJoin = function (value) {
              if (this.stack[this.cArrPos].lineJoin !== value) {
                this.currentLineJoin = value;
                this.stack[this.cArrPos].lineJoin = value;
              }
            };
            CVContextData.prototype.miterLimit = function (value) {
              if (this.stack[this.cArrPos].miterLimit !== value) {
                this.currentMiterLimit = value;
                this.stack[this.cArrPos].miterLimit = value;
              }
            };
            CVContextData.prototype.transform = function (props) {
              this.transformMat.cloneFromProps(props); // Taking the last transform value from the stored stack of transforms

              var currentTransform = this.cTr; // Applying the last transform value after the new transform to respect the order of transformations

              this.transformMat.multiply(currentTransform); // Storing the new transformed value in the stored transform

              currentTransform.cloneFromProps(this.transformMat.props);
              var trProps = currentTransform.props; // Applying the new transform to the canvas

              this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
            };
            CVContextData.prototype.opacity = function (op) {
              var currentOpacity = this.stack[this.cArrPos].opacity;
              currentOpacity *= op < 0 ? 0 : op;
              if (this.stack[this.cArrPos].opacity !== currentOpacity) {
                if (this.currentOpacity !== op) {
                  this.nativeContext.globalAlpha = op;
                  this.currentOpacity = op;
                }
                this.stack[this.cArrPos].opacity = currentOpacity;
              }
            };
            CVContextData.prototype.fill = function (rule) {
              if (this.appliedFillStyle !== this.currentFillStyle) {
                this.appliedFillStyle = this.currentFillStyle;
                this.nativeContext.fillStyle = this.appliedFillStyle;
              }
              this.nativeContext.fill(rule);
            };
            CVContextData.prototype.fillRect = function (x, y, w, h) {
              if (this.appliedFillStyle !== this.currentFillStyle) {
                this.appliedFillStyle = this.currentFillStyle;
                this.nativeContext.fillStyle = this.appliedFillStyle;
              }
              this.nativeContext.fillRect(x, y, w, h);
            };
            CVContextData.prototype.stroke = function () {
              if (this.appliedStrokeStyle !== this.currentStrokeStyle) {
                this.appliedStrokeStyle = this.currentStrokeStyle;
                this.nativeContext.strokeStyle = this.appliedStrokeStyle;
              }
              if (this.appliedLineWidth !== this.currentLineWidth) {
                this.appliedLineWidth = this.currentLineWidth;
                this.nativeContext.lineWidth = this.appliedLineWidth;
              }
              if (this.appliedLineCap !== this.currentLineCap) {
                this.appliedLineCap = this.currentLineCap;
                this.nativeContext.lineCap = this.appliedLineCap;
              }
              if (this.appliedLineJoin !== this.currentLineJoin) {
                this.appliedLineJoin = this.currentLineJoin;
                this.nativeContext.lineJoin = this.appliedLineJoin;
              }
              if (this.appliedMiterLimit !== this.currentMiterLimit) {
                this.appliedMiterLimit = this.currentMiterLimit;
                this.nativeContext.miterLimit = this.appliedMiterLimit;
              }
              this.nativeContext.stroke();
            };
            function CVCompElement(data, globalData, comp) {
              this.completeLayers = false;
              this.layers = data.layers;
              this.pendingElements = [];
              this.elements = createSizedArray(this.layers.length);
              this.initElement(data, globalData, comp);
              this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
                _placeholder: true
              };
            }
            extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement);
            CVCompElement.prototype.renderInnerContent = function () {
              var ctx = this.canvasContext;
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(this.data.w, 0);
              ctx.lineTo(this.data.w, this.data.h);
              ctx.lineTo(0, this.data.h);
              ctx.lineTo(0, 0);
              ctx.clip();
              var i;
              var len = this.layers.length;
              for (i = len - 1; i >= 0; i -= 1) {
                if (this.completeLayers || this.elements[i]) {
                  this.elements[i].renderFrame();
                }
              }
            };
            CVCompElement.prototype.destroy = function () {
              var i;
              var len = this.layers.length;
              for (i = len - 1; i >= 0; i -= 1) {
                if (this.elements[i]) {
                  this.elements[i].destroy();
                }
              }
              this.layers = null;
              this.elements = null;
            };
            CVCompElement.prototype.createComp = function (data) {
              return new CVCompElement(data, this.globalData, this);
            };
            function CanvasRenderer(animationItem, config) {
              this.animationItem = animationItem;
              this.renderConfig = {
                clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,
                context: config && config.context || null,
                progressiveLoad: config && config.progressiveLoad || false,
                preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',
                imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
                contentVisibility: config && config.contentVisibility || 'visible',
                className: config && config.className || '',
                id: config && config.id || '',
                runExpressions: !config || config.runExpressions === undefined || config.runExpressions
              };
              this.renderConfig.dpr = config && config.dpr || 1;
              if (this.animationItem.wrapper) {
                this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;
              }
              this.renderedFrame = -1;
              this.globalData = {
                frameNum: -1,
                _mdf: false,
                renderConfig: this.renderConfig,
                currentGlobalAlpha: -1
              };
              this.contextData = new CVContextData();
              this.elements = [];
              this.pendingElements = [];
              this.transformMat = new Matrix();
              this.completeLayers = false;
              this.rendererType = 'canvas';
              if (this.renderConfig.clearCanvas) {
                this.ctxTransform = this.contextData.transform.bind(this.contextData);
                this.ctxOpacity = this.contextData.opacity.bind(this.contextData);
                this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);
                this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);
                this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);
                this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);
                this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);
                this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);
                this.ctxFill = this.contextData.fill.bind(this.contextData);
                this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);
                this.ctxStroke = this.contextData.stroke.bind(this.contextData);
                this.save = this.contextData.save.bind(this.contextData);
              }
            }
            extendPrototype([CanvasRendererBase], CanvasRenderer);
            CanvasRenderer.prototype.createComp = function (data) {
              return new CVCompElement(data, this.globalData, this);
            };
            function HBaseElement() {}
            HBaseElement.prototype = {
              checkBlendMode: function checkBlendMode() {},
              initRendererElement: function initRendererElement() {
                this.baseElement = createTag(this.data.tg || 'div');
                if (this.data.hasMask) {
                  this.svgElement = createNS('svg');
                  this.layerElement = createNS('g');
                  this.maskedElement = this.layerElement;
                  this.svgElement.appendChild(this.layerElement);
                  this.baseElement.appendChild(this.svgElement);
                } else {
                  this.layerElement = this.baseElement;
                }
                styleDiv(this.baseElement);
              },
              createContainerElements: function createContainerElements() {
                this.renderableEffectsManager = new CVEffects(this);
                this.transformedElement = this.baseElement;
                this.maskedElement = this.layerElement;
                if (this.data.ln) {
                  this.layerElement.setAttribute('id', this.data.ln);
                }
                if (this.data.cl) {
                  this.layerElement.setAttribute('class', this.data.cl);
                }
                if (this.data.bm !== 0) {
                  this.setBlendMode();
                }
              },
              renderElement: function renderElement() {
                var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
                if (this.finalTransform._matMdf) {
                  var matrixValue = this.finalTransform.mat.toCSS();
                  transformedElementStyle.transform = matrixValue;
                  transformedElementStyle.webkitTransform = matrixValue;
                }
                if (this.finalTransform._opMdf) {
                  transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
                }
              },
              renderFrame: function renderFrame() {
                // If it is exported as hidden (data.hd === true) no need to render
                // If it is not visible no need to render
                if (this.data.hd || this.hidden) {
                  return;
                }
                this.renderTransform();
                this.renderRenderable();
                this.renderElement();
                this.renderInnerContent();
                if (this._isFirstFrame) {
                  this._isFirstFrame = false;
                }
              },
              destroy: function destroy() {
                this.layerElement = null;
                this.transformedElement = null;
                if (this.matteElement) {
                  this.matteElement = null;
                }
                if (this.maskManager) {
                  this.maskManager.destroy();
                  this.maskManager = null;
                }
              },
              createRenderableComponents: function createRenderableComponents() {
                this.maskManager = new MaskElement(this.data, this, this.globalData);
              },
              addEffects: function addEffects() {},
              setMatte: function setMatte() {}
            };
            HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
            HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
            HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
            function HSolidElement(data, globalData, comp) {
              this.initElement(data, globalData, comp);
            }
            extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);
            HSolidElement.prototype.createContent = function () {
              var rect;
              if (this.data.hasMask) {
                rect = createNS('rect');
                rect.setAttribute('width', this.data.sw);
                rect.setAttribute('height', this.data.sh);
                rect.setAttribute('fill', this.data.sc);
                this.svgElement.setAttribute('width', this.data.sw);
                this.svgElement.setAttribute('height', this.data.sh);
              } else {
                rect = createTag('div');
                rect.style.width = this.data.sw + 'px';
                rect.style.height = this.data.sh + 'px';
                rect.style.backgroundColor = this.data.sc;
              }
              this.layerElement.appendChild(rect);
            };
            function HShapeElement(data, globalData, comp) {
              // List of drawable elements
              this.shapes = []; // Full shape data

              this.shapesData = data.shapes; // List of styles that will be applied to shapes

              this.stylesList = []; // List of modifiers that will be applied to shapes

              this.shapeModifiers = []; // List of items in shape tree

              this.itemsData = []; // List of items in previous shape tree

              this.processedElements = []; // List of animated components

              this.animatedContents = [];
              this.shapesContainer = createNS('g');
              this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
              // List of elements that have been created

              this.prevViewData = [];
              this.currentBBox = {
                x: 999999,
                y: -999999,
                h: 0,
                w: 0
              };
            }
            extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
            HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;
            HShapeElement.prototype.createContent = function () {
              var cont;
              this.baseElement.style.fontSize = 0;
              if (this.data.hasMask) {
                this.layerElement.appendChild(this.shapesContainer);
                cont = this.svgElement;
              } else {
                cont = createNS('svg');
                var size = this.comp.data ? this.comp.data : this.globalData.compSize;
                cont.setAttribute('width', size.w);
                cont.setAttribute('height', size.h);
                cont.appendChild(this.shapesContainer);
                this.layerElement.appendChild(cont);
              }
              this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
              this.filterUniqueShapes();
              this.shapeCont = cont;
            };
            HShapeElement.prototype.getTransformedPoint = function (transformers, point) {
              var i;
              var len = transformers.length;
              for (i = 0; i < len; i += 1) {
                point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
              }
              return point;
            };
            HShapeElement.prototype.calculateShapeBoundingBox = function (item, boundingBox) {
              var shape = item.sh.v;
              var transformers = item.transformers;
              var i;
              var len = shape._length;
              var vPoint;
              var oPoint;
              var nextIPoint;
              var nextVPoint;
              if (len <= 1) {
                return;
              }
              for (i = 0; i < len - 1; i += 1) {
                vPoint = this.getTransformedPoint(transformers, shape.v[i]);
                oPoint = this.getTransformedPoint(transformers, shape.o[i]);
                nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
                nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
                this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
              }
              if (shape.c) {
                vPoint = this.getTransformedPoint(transformers, shape.v[i]);
                oPoint = this.getTransformedPoint(transformers, shape.o[i]);
                nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
                nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
                this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
              }
            };
            HShapeElement.prototype.checkBounds = function (vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
              this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
              var bounds = this.shapeBoundingBox;
              boundingBox.x = bmMin(bounds.left, boundingBox.x);
              boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
              boundingBox.y = bmMin(bounds.top, boundingBox.y);
              boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
            };
            HShapeElement.prototype.shapeBoundingBox = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            };
            HShapeElement.prototype.tempBoundingBox = {
              x: 0,
              xMax: 0,
              y: 0,
              yMax: 0,
              width: 0,
              height: 0
            };
            HShapeElement.prototype.getBoundsOfCurve = function (p0, p1, p2, p3) {
              var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];
              for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {
                // eslint-disable-line no-plusplus
                b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                c = 3 * p1[i] - 3 * p0[i];
                b |= 0; // eslint-disable-line no-bitwise

                a |= 0; // eslint-disable-line no-bitwise

                c |= 0; // eslint-disable-line no-bitwise

                if (a === 0 && b === 0) ;else if (a === 0) {
                  t = -c / b;
                  if (t > 0 && t < 1) {
                    bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));
                  }
                } else {
                  b2ac = b * b - 4 * c * a;
                  if (b2ac >= 0) {
                    t1 = (-b + bmSqrt(b2ac)) / (2 * a);
                    if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));
                    t2 = (-b - bmSqrt(b2ac)) / (2 * a);
                    if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));
                  }
                }
              }
              this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
              this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
              this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
              this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
            };
            HShapeElement.prototype.calculateF = function (t, p0, p1, p2, p3, i) {
              return bmPow(1 - t, 3) * p0[i] + 3 * bmPow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bmPow(t, 2) * p2[i] + bmPow(t, 3) * p3[i];
            };
            HShapeElement.prototype.calculateBoundingBox = function (itemsData, boundingBox) {
              var i;
              var len = itemsData.length;
              for (i = 0; i < len; i += 1) {
                if (itemsData[i] && itemsData[i].sh) {
                  this.calculateShapeBoundingBox(itemsData[i], boundingBox);
                } else if (itemsData[i] && itemsData[i].it) {
                  this.calculateBoundingBox(itemsData[i].it, boundingBox);
                } else if (itemsData[i] && itemsData[i].style && itemsData[i].w) {
                  this.expandStrokeBoundingBox(itemsData[i].w, boundingBox);
                }
              }
            };
            HShapeElement.prototype.expandStrokeBoundingBox = function (widthProperty, boundingBox) {
              var width = 0;
              if (widthProperty.keyframes) {
                for (var i = 0; i < widthProperty.keyframes.length; i += 1) {
                  var kfw = widthProperty.keyframes[i].s;
                  if (kfw > width) {
                    width = kfw;
                  }
                }
                width *= widthProperty.mult;
              } else {
                width = widthProperty.v * widthProperty.mult;
              }
              boundingBox.x -= width;
              boundingBox.xMax += width;
              boundingBox.y -= width;
              boundingBox.yMax += width;
            };
            HShapeElement.prototype.currentBoxContains = function (box) {
              return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
            };
            HShapeElement.prototype.renderInnerContent = function () {
              this._renderShapeFrame();
              if (!this.hidden && (this._isFirstFrame || this._mdf)) {
                var tempBoundingBox = this.tempBoundingBox;
                var max = 999999;
                tempBoundingBox.x = max;
                tempBoundingBox.xMax = -max;
                tempBoundingBox.y = max;
                tempBoundingBox.yMax = -max;
                this.calculateBoundingBox(this.itemsData, tempBoundingBox);
                tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
                tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y; // var tempBoundingBox = this.shapeCont.getBBox();

                if (this.currentBoxContains(tempBoundingBox)) {
                  return;
                }
                var changed = false;
                if (this.currentBBox.w !== tempBoundingBox.width) {
                  this.currentBBox.w = tempBoundingBox.width;
                  this.shapeCont.setAttribute('width', tempBoundingBox.width);
                  changed = true;
                }
                if (this.currentBBox.h !== tempBoundingBox.height) {
                  this.currentBBox.h = tempBoundingBox.height;
                  this.shapeCont.setAttribute('height', tempBoundingBox.height);
                  changed = true;
                }
                if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
                  this.currentBBox.w = tempBoundingBox.width;
                  this.currentBBox.h = tempBoundingBox.height;
                  this.currentBBox.x = tempBoundingBox.x;
                  this.currentBBox.y = tempBoundingBox.y;
                  this.shapeCont.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
                  var shapeStyle = this.shapeCont.style;
                  var shapeTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
                  shapeStyle.transform = shapeTransform;
                  shapeStyle.webkitTransform = shapeTransform;
                }
              }
            };
            function HTextElement(data, globalData, comp) {
              this.textSpans = [];
              this.textPaths = [];
              this.currentBBox = {
                x: 999999,
                y: -999999,
                h: 0,
                w: 0
              };
              this.renderType = 'svg';
              this.isMasked = false;
              this.initElement(data, globalData, comp);
            }
            extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);
            HTextElement.prototype.createContent = function () {
              this.isMasked = this.checkMasks();
              if (this.isMasked) {
                this.renderType = 'svg';
                this.compW = this.comp.data.w;
                this.compH = this.comp.data.h;
                this.svgElement.setAttribute('width', this.compW);
                this.svgElement.setAttribute('height', this.compH);
                var g = createNS('g');
                this.maskedElement.appendChild(g);
                this.innerElem = g;
              } else {
                this.renderType = 'html';
                this.innerElem = this.layerElement;
              }
              this.checkParenting();
            };
            HTextElement.prototype.buildNewText = function () {
              var documentData = this.textProperty.currentData;
              this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
              var innerElemStyle = this.innerElem.style;
              var textColor = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';
              innerElemStyle.fill = textColor;
              innerElemStyle.color = textColor;
              if (documentData.sc) {
                innerElemStyle.stroke = this.buildColor(documentData.sc);
                innerElemStyle.strokeWidth = documentData.sw + 'px';
              }
              var fontData = this.globalData.fontManager.getFontByName(documentData.f);
              if (!this.globalData.fontManager.chars) {
                innerElemStyle.fontSize = documentData.finalSize + 'px';
                innerElemStyle.lineHeight = documentData.finalSize + 'px';
                if (fontData.fClass) {
                  this.innerElem.className = fontData.fClass;
                } else {
                  innerElemStyle.fontFamily = fontData.fFamily;
                  var fWeight = documentData.fWeight;
                  var fStyle = documentData.fStyle;
                  innerElemStyle.fontStyle = fStyle;
                  innerElemStyle.fontWeight = fWeight;
                }
              }
              var i;
              var len;
              var letters = documentData.l;
              len = letters.length;
              var tSpan;
              var tParent;
              var tCont;
              var matrixHelper = this.mHelper;
              var shapes;
              var shapeStr = '';
              var cnt = 0;
              for (i = 0; i < len; i += 1) {
                if (this.globalData.fontManager.chars) {
                  if (!this.textPaths[cnt]) {
                    tSpan = createNS('path');
                    tSpan.setAttribute('stroke-linecap', lineCapEnum[1]);
                    tSpan.setAttribute('stroke-linejoin', lineJoinEnum[2]);
                    tSpan.setAttribute('stroke-miterlimit', '4');
                  } else {
                    tSpan = this.textPaths[cnt];
                  }
                  if (!this.isMasked) {
                    if (this.textSpans[cnt]) {
                      tParent = this.textSpans[cnt];
                      tCont = tParent.children[0];
                    } else {
                      tParent = createTag('div');
                      tParent.style.lineHeight = 0;
                      tCont = createNS('svg');
                      tCont.appendChild(tSpan);
                      styleDiv(tParent);
                    }
                  }
                } else if (!this.isMasked) {
                  if (this.textSpans[cnt]) {
                    tParent = this.textSpans[cnt];
                    tSpan = this.textPaths[cnt];
                  } else {
                    tParent = createTag('span');
                    styleDiv(tParent);
                    tSpan = createTag('span');
                    styleDiv(tSpan);
                    tParent.appendChild(tSpan);
                  }
                } else {
                  tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');
                } // tSpan.setAttribute('visibility', 'hidden');

                if (this.globalData.fontManager.chars) {
                  var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
                  var shapeData;
                  if (charData) {
                    shapeData = charData.data;
                  } else {
                    shapeData = null;
                  }
                  matrixHelper.reset();
                  if (shapeData && shapeData.shapes && shapeData.shapes.length) {
                    shapes = shapeData.shapes[0].it;
                    matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
                    shapeStr = this.createPathShape(matrixHelper, shapes);
                    tSpan.setAttribute('d', shapeStr);
                  }
                  if (!this.isMasked) {
                    this.innerElem.appendChild(tParent);
                    if (shapeData && shapeData.shapes) {
                      // document.body.appendChild is needed to get exact measure of shape
                      document.body.appendChild(tCont);
                      var boundingBox = tCont.getBBox();
                      tCont.setAttribute('width', boundingBox.width + 2);
                      tCont.setAttribute('height', boundingBox.height + 2);
                      tCont.setAttribute('viewBox', boundingBox.x - 1 + ' ' + (boundingBox.y - 1) + ' ' + (boundingBox.width + 2) + ' ' + (boundingBox.height + 2));
                      var tContStyle = tCont.style;
                      var tContTranslation = 'translate(' + (boundingBox.x - 1) + 'px,' + (boundingBox.y - 1) + 'px)';
                      tContStyle.transform = tContTranslation;
                      tContStyle.webkitTransform = tContTranslation;
                      letters[i].yOffset = boundingBox.y - 1;
                    } else {
                      tCont.setAttribute('width', 1);
                      tCont.setAttribute('height', 1);
                    }
                    tParent.appendChild(tCont);
                  } else {
                    this.innerElem.appendChild(tSpan);
                  }
                } else {
                  tSpan.textContent = letters[i].val;
                  tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
                  if (!this.isMasked) {
                    this.innerElem.appendChild(tParent); //

                    var tStyle = tSpan.style;
                    var tSpanTranslation = 'translate3d(0,' + -documentData.finalSize / 1.2 + 'px,0)';
                    tStyle.transform = tSpanTranslation;
                    tStyle.webkitTransform = tSpanTranslation;
                  } else {
                    this.innerElem.appendChild(tSpan);
                  }
                } //

                if (!this.isMasked) {
                  this.textSpans[cnt] = tParent;
                } else {
                  this.textSpans[cnt] = tSpan;
                }
                this.textSpans[cnt].style.display = 'block';
                this.textPaths[cnt] = tSpan;
                cnt += 1;
              }
              while (cnt < this.textSpans.length) {
                this.textSpans[cnt].style.display = 'none';
                cnt += 1;
              }
            };
            HTextElement.prototype.renderInnerContent = function () {
              this.validateText();
              var svgStyle;
              if (this.data.singleShape) {
                if (!this._isFirstFrame && !this.lettersChangedFlag) {
                  return;
                }
                if (this.isMasked && this.finalTransform._matMdf) {
                  // Todo Benchmark if using this is better than getBBox
                  this.svgElement.setAttribute('viewBox', -this.finalTransform.mProp.p.v[0] + ' ' + -this.finalTransform.mProp.p.v[1] + ' ' + this.compW + ' ' + this.compH);
                  svgStyle = this.svgElement.style;
                  var translation = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';
                  svgStyle.transform = translation;
                  svgStyle.webkitTransform = translation;
                }
              }
              this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
              if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
                return;
              }
              var i;
              var len;
              var count = 0;
              var renderedLetters = this.textAnimator.renderedLetters;
              var letters = this.textProperty.currentData.l;
              len = letters.length;
              var renderedLetter;
              var textSpan;
              var textPath;
              for (i = 0; i < len; i += 1) {
                if (letters[i].n) {
                  count += 1;
                } else {
                  textSpan = this.textSpans[i];
                  textPath = this.textPaths[i];
                  renderedLetter = renderedLetters[count];
                  count += 1;
                  if (renderedLetter._mdf.m) {
                    if (!this.isMasked) {
                      textSpan.style.webkitTransform = renderedLetter.m;
                      textSpan.style.transform = renderedLetter.m;
                    } else {
                      textSpan.setAttribute('transform', renderedLetter.m);
                    }
                  } /// /textSpan.setAttribute('opacity',renderedLetter.o);

                  textSpan.style.opacity = renderedLetter.o;
                  if (renderedLetter.sw && renderedLetter._mdf.sw) {
                    textPath.setAttribute('stroke-width', renderedLetter.sw);
                  }
                  if (renderedLetter.sc && renderedLetter._mdf.sc) {
                    textPath.setAttribute('stroke', renderedLetter.sc);
                  }
                  if (renderedLetter.fc && renderedLetter._mdf.fc) {
                    textPath.setAttribute('fill', renderedLetter.fc);
                    textPath.style.color = renderedLetter.fc;
                  }
                }
              }
              if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
                var boundingBox = this.innerElem.getBBox();
                if (this.currentBBox.w !== boundingBox.width) {
                  this.currentBBox.w = boundingBox.width;
                  this.svgElement.setAttribute('width', boundingBox.width);
                }
                if (this.currentBBox.h !== boundingBox.height) {
                  this.currentBBox.h = boundingBox.height;
                  this.svgElement.setAttribute('height', boundingBox.height);
                }
                var margin = 1;
                if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {
                  this.currentBBox.w = boundingBox.width + margin * 2;
                  this.currentBBox.h = boundingBox.height + margin * 2;
                  this.currentBBox.x = boundingBox.x - margin;
                  this.currentBBox.y = boundingBox.y - margin;
                  this.svgElement.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
                  svgStyle = this.svgElement.style;
                  var svgTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
                  svgStyle.transform = svgTransform;
                  svgStyle.webkitTransform = svgTransform;
                }
              }
            };
            function HCameraElement(data, globalData, comp) {
              this.initFrame();
              this.initBaseData(data, globalData, comp);
              this.initHierarchy();
              var getProp = PropertyFactory.getProp;
              this.pe = getProp(this, data.pe, 0, 0, this);
              if (data.ks.p.s) {
                this.px = getProp(this, data.ks.p.x, 1, 0, this);
                this.py = getProp(this, data.ks.p.y, 1, 0, this);
                this.pz = getProp(this, data.ks.p.z, 1, 0, this);
              } else {
                this.p = getProp(this, data.ks.p, 1, 0, this);
              }
              if (data.ks.a) {
                this.a = getProp(this, data.ks.a, 1, 0, this);
              }
              if (data.ks.or.k.length && data.ks.or.k[0].to) {
                var i;
                var len = data.ks.or.k.length;
                for (i = 0; i < len; i += 1) {
                  data.ks.or.k[i].to = null;
                  data.ks.or.k[i].ti = null;
                }
              }
              this.or = getProp(this, data.ks.or, 1, degToRads, this);
              this.or.sh = true;
              this.rx = getProp(this, data.ks.rx, 0, degToRads, this);
              this.ry = getProp(this, data.ks.ry, 0, degToRads, this);
              this.rz = getProp(this, data.ks.rz, 0, degToRads, this);
              this.mat = new Matrix();
              this._prevMat = new Matrix();
              this._isFirstFrame = true; // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.

              this.finalTransform = {
                mProp: this
              };
            }
            extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);
            HCameraElement.prototype.setup = function () {
              var i;
              var len = this.comp.threeDElements.length;
              var comp;
              var perspectiveStyle;
              var containerStyle;
              for (i = 0; i < len; i += 1) {
                // [perspectiveElem,container]
                comp = this.comp.threeDElements[i];
                if (comp.type === '3d') {
                  perspectiveStyle = comp.perspectiveElem.style;
                  containerStyle = comp.container.style;
                  var perspective = this.pe.v + 'px';
                  var origin = '0px 0px 0px';
                  var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
                  perspectiveStyle.perspective = perspective;
                  perspectiveStyle.webkitPerspective = perspective;
                  containerStyle.transformOrigin = origin;
                  containerStyle.mozTransformOrigin = origin;
                  containerStyle.webkitTransformOrigin = origin;
                  perspectiveStyle.transform = matrix;
                  perspectiveStyle.webkitTransform = matrix;
                }
              }
            };
            HCameraElement.prototype.createElements = function () {};
            HCameraElement.prototype.hide = function () {};
            HCameraElement.prototype.renderFrame = function () {
              var _mdf = this._isFirstFrame;
              var i;
              var len;
              if (this.hierarchy) {
                len = this.hierarchy.length;
                for (i = 0; i < len; i += 1) {
                  _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
                }
              }
              if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
                this.mat.reset();
                if (this.hierarchy) {
                  len = this.hierarchy.length - 1;
                  for (i = len; i >= 0; i -= 1) {
                    var mTransf = this.hierarchy[i].finalTransform.mProp;
                    this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
                    this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
                    this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
                    this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
                    this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
                  }
                }
                if (this.p) {
                  this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
                } else {
                  this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
                }
                if (this.a) {
                  var diffVector;
                  if (this.p) {
                    diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
                  } else {
                    diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
                  }
                  var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2)); // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));

                  var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
                  var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
                  var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
                  var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
                  this.mat.rotateY(mRotationY).rotateX(-mRotationX);
                }
                this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
                this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
                this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
                this.mat.translate(0, 0, this.pe.v);
                var hasMatrixChanged = !this._prevMat.equals(this.mat);
                if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
                  len = this.comp.threeDElements.length;
                  var comp;
                  var perspectiveStyle;
                  var containerStyle;
                  for (i = 0; i < len; i += 1) {
                    comp = this.comp.threeDElements[i];
                    if (comp.type === '3d') {
                      if (hasMatrixChanged) {
                        var matValue = this.mat.toCSS();
                        containerStyle = comp.container.style;
                        containerStyle.transform = matValue;
                        containerStyle.webkitTransform = matValue;
                      }
                      if (this.pe._mdf) {
                        perspectiveStyle = comp.perspectiveElem.style;
                        perspectiveStyle.perspective = this.pe.v + 'px';
                        perspectiveStyle.webkitPerspective = this.pe.v + 'px';
                      }
                    }
                  }
                  this.mat.clone(this._prevMat);
                }
              }
              this._isFirstFrame = false;
            };
            HCameraElement.prototype.prepareFrame = function (num) {
              this.prepareProperties(num, true);
            };
            HCameraElement.prototype.destroy = function () {};
            HCameraElement.prototype.getBaseElement = function () {
              return null;
            };
            function HImageElement(data, globalData, comp) {
              this.assetData = globalData.getAssetData(data.refId);
              this.initElement(data, globalData, comp);
            }
            extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);
            HImageElement.prototype.createContent = function () {
              var assetPath = this.globalData.getAssetsPath(this.assetData);
              var img = new Image();
              if (this.data.hasMask) {
                this.imageElem = createNS('image');
                this.imageElem.setAttribute('width', this.assetData.w + 'px');
                this.imageElem.setAttribute('height', this.assetData.h + 'px');
                this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
                this.layerElement.appendChild(this.imageElem);
                this.baseElement.setAttribute('width', this.assetData.w);
                this.baseElement.setAttribute('height', this.assetData.h);
              } else {
                this.layerElement.appendChild(img);
              }
              img.crossOrigin = 'anonymous';
              img.src = assetPath;
              if (this.data.ln) {
                this.baseElement.setAttribute('id', this.data.ln);
              }
            };
            function HybridRendererBase(animationItem, config) {
              this.animationItem = animationItem;
              this.layers = null;
              this.renderedFrame = -1;
              this.renderConfig = {
                className: config && config.className || '',
                imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
                hideOnTransparent: !(config && config.hideOnTransparent === false),
                filterSize: {
                  width: config && config.filterSize && config.filterSize.width || '400%',
                  height: config && config.filterSize && config.filterSize.height || '400%',
                  x: config && config.filterSize && config.filterSize.x || '-100%',
                  y: config && config.filterSize && config.filterSize.y || '-100%'
                }
              };
              this.globalData = {
                _mdf: false,
                frameNum: -1,
                renderConfig: this.renderConfig
              };
              this.pendingElements = [];
              this.elements = [];
              this.threeDElements = [];
              this.destroyed = false;
              this.camera = null;
              this.supports3d = true;
              this.rendererType = 'html';
            }
            extendPrototype([BaseRenderer], HybridRendererBase);
            HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;
            HybridRendererBase.prototype.checkPendingElements = function () {
              while (this.pendingElements.length) {
                var element = this.pendingElements.pop();
                element.checkParenting();
              }
            };
            HybridRendererBase.prototype.appendElementInPos = function (element, pos) {
              var newDOMElement = element.getBaseElement();
              if (!newDOMElement) {
                return;
              }
              var layer = this.layers[pos];
              if (!layer.ddd || !this.supports3d) {
                if (this.threeDElements) {
                  this.addTo3dContainer(newDOMElement, pos);
                } else {
                  var i = 0;
                  var nextDOMElement;
                  var nextLayer;
                  var tmpDOMElement;
                  while (i < pos) {
                    if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {
                      nextLayer = this.elements[i];
                      tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
                      nextDOMElement = tmpDOMElement || nextDOMElement;
                    }
                    i += 1;
                  }
                  if (nextDOMElement) {
                    if (!layer.ddd || !this.supports3d) {
                      this.layerElement.insertBefore(newDOMElement, nextDOMElement);
                    }
                  } else if (!layer.ddd || !this.supports3d) {
                    this.layerElement.appendChild(newDOMElement);
                  }
                }
              } else {
                this.addTo3dContainer(newDOMElement, pos);
              }
            };
            HybridRendererBase.prototype.createShape = function (data) {
              if (!this.supports3d) {
                return new SVGShapeElement(data, this.globalData, this);
              }
              return new HShapeElement(data, this.globalData, this);
            };
            HybridRendererBase.prototype.createText = function (data) {
              if (!this.supports3d) {
                return new SVGTextLottieElement(data, this.globalData, this);
              }
              return new HTextElement(data, this.globalData, this);
            };
            HybridRendererBase.prototype.createCamera = function (data) {
              this.camera = new HCameraElement(data, this.globalData, this);
              return this.camera;
            };
            HybridRendererBase.prototype.createImage = function (data) {
              if (!this.supports3d) {
                return new IImageElement(data, this.globalData, this);
              }
              return new HImageElement(data, this.globalData, this);
            };
            HybridRendererBase.prototype.createSolid = function (data) {
              if (!this.supports3d) {
                return new ISolidElement(data, this.globalData, this);
              }
              return new HSolidElement(data, this.globalData, this);
            };
            HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
            HybridRendererBase.prototype.getThreeDContainerByPos = function (pos) {
              var i = 0;
              var len = this.threeDElements.length;
              while (i < len) {
                if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {
                  return this.threeDElements[i].perspectiveElem;
                }
                i += 1;
              }
              return null;
            };
            HybridRendererBase.prototype.createThreeDContainer = function (pos, type) {
              var perspectiveElem = createTag('div');
              var style;
              var containerStyle;
              styleDiv(perspectiveElem);
              var container = createTag('div');
              styleDiv(container);
              if (type === '3d') {
                style = perspectiveElem.style;
                style.width = this.globalData.compSize.w + 'px';
                style.height = this.globalData.compSize.h + 'px';
                var center = '50% 50%';
                style.webkitTransformOrigin = center;
                style.mozTransformOrigin = center;
                style.transformOrigin = center;
                containerStyle = container.style;
                var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
                containerStyle.transform = matrix;
                containerStyle.webkitTransform = matrix;
              }
              perspectiveElem.appendChild(container); // this.resizerElem.appendChild(perspectiveElem);

              var threeDContainerData = {
                container: container,
                perspectiveElem: perspectiveElem,
                startPos: pos,
                endPos: pos,
                type: type
              };
              this.threeDElements.push(threeDContainerData);
              return threeDContainerData;
            };
            HybridRendererBase.prototype.build3dContainers = function () {
              var i;
              var len = this.layers.length;
              var lastThreeDContainerData;
              var currentContainer = '';
              for (i = 0; i < len; i += 1) {
                if (this.layers[i].ddd && this.layers[i].ty !== 3) {
                  if (currentContainer !== '3d') {
                    currentContainer = '3d';
                    lastThreeDContainerData = this.createThreeDContainer(i, '3d');
                  }
                  lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
                } else {
                  if (currentContainer !== '2d') {
                    currentContainer = '2d';
                    lastThreeDContainerData = this.createThreeDContainer(i, '2d');
                  }
                  lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
                }
              }
              len = this.threeDElements.length;
              for (i = len - 1; i >= 0; i -= 1) {
                this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
              }
            };
            HybridRendererBase.prototype.addTo3dContainer = function (elem, pos) {
              var i = 0;
              var len = this.threeDElements.length;
              while (i < len) {
                if (pos <= this.threeDElements[i].endPos) {
                  var j = this.threeDElements[i].startPos;
                  var nextElement;
                  while (j < pos) {
                    if (this.elements[j] && this.elements[j].getBaseElement) {
                      nextElement = this.elements[j].getBaseElement();
                    }
                    j += 1;
                  }
                  if (nextElement) {
                    this.threeDElements[i].container.insertBefore(elem, nextElement);
                  } else {
                    this.threeDElements[i].container.appendChild(elem);
                  }
                  break;
                }
                i += 1;
              }
            };
            HybridRendererBase.prototype.configAnimation = function (animData) {
              var resizerElem = createTag('div');
              var wrapper = this.animationItem.wrapper;
              var style = resizerElem.style;
              style.width = animData.w + 'px';
              style.height = animData.h + 'px';
              this.resizerElem = resizerElem;
              styleDiv(resizerElem);
              style.transformStyle = 'flat';
              style.mozTransformStyle = 'flat';
              style.webkitTransformStyle = 'flat';
              if (this.renderConfig.className) {
                resizerElem.setAttribute('class', this.renderConfig.className);
              }
              wrapper.appendChild(resizerElem);
              style.overflow = 'hidden';
              var svg = createNS('svg');
              svg.setAttribute('width', '1');
              svg.setAttribute('height', '1');
              styleDiv(svg);
              this.resizerElem.appendChild(svg);
              var defs = createNS('defs');
              svg.appendChild(defs);
              this.data = animData; // Mask animation

              this.setupGlobalData(animData, svg);
              this.globalData.defs = defs;
              this.layers = animData.layers;
              this.layerElement = this.resizerElem;
              this.build3dContainers();
              this.updateContainerSize();
            };
            HybridRendererBase.prototype.destroy = function () {
              if (this.animationItem.wrapper) {
                this.animationItem.wrapper.innerText = '';
              }
              this.animationItem.container = null;
              this.globalData.defs = null;
              var i;
              var len = this.layers ? this.layers.length : 0;
              for (i = 0; i < len; i += 1) {
                if (this.elements[i] && this.elements[i].destroy) {
                  this.elements[i].destroy();
                }
              }
              this.elements.length = 0;
              this.destroyed = true;
              this.animationItem = null;
            };
            HybridRendererBase.prototype.updateContainerSize = function () {
              var elementWidth = this.animationItem.wrapper.offsetWidth;
              var elementHeight = this.animationItem.wrapper.offsetHeight;
              var elementRel = elementWidth / elementHeight;
              var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
              var sx;
              var sy;
              var tx;
              var ty;
              if (animationRel > elementRel) {
                sx = elementWidth / this.globalData.compSize.w;
                sy = elementWidth / this.globalData.compSize.w;
                tx = 0;
                ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;
              } else {
                sx = elementHeight / this.globalData.compSize.h;
                sy = elementHeight / this.globalData.compSize.h;
                tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
                ty = 0;
              }
              var style = this.resizerElem.style;
              style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,' + sy + ',0,0,0,0,1,0,' + tx + ',' + ty + ',0,1)';
              style.transform = style.webkitTransform;
            };
            HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;
            HybridRendererBase.prototype.hide = function () {
              this.resizerElem.style.display = 'none';
            };
            HybridRendererBase.prototype.show = function () {
              this.resizerElem.style.display = 'block';
            };
            HybridRendererBase.prototype.initItems = function () {
              this.buildAllItems();
              if (this.camera) {
                this.camera.setup();
              } else {
                var cWidth = this.globalData.compSize.w;
                var cHeight = this.globalData.compSize.h;
                var i;
                var len = this.threeDElements.length;
                for (i = 0; i < len; i += 1) {
                  var style = this.threeDElements[i].perspectiveElem.style;
                  style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + 'px';
                  style.perspective = style.webkitPerspective;
                }
              }
            };
            HybridRendererBase.prototype.searchExtraCompositions = function (assets) {
              var i;
              var len = assets.length;
              var floatingContainer = createTag('div');
              for (i = 0; i < len; i += 1) {
                if (assets[i].xt) {
                  var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);
                  comp.initExpressions();
                  this.globalData.projectInterface.registerComposition(comp);
                }
              }
            };
            function HCompElement(data, globalData, comp) {
              this.layers = data.layers;
              this.supports3d = !data.hasMask;
              this.completeLayers = false;
              this.pendingElements = [];
              this.elements = this.layers ? createSizedArray(this.layers.length) : [];
              this.initElement(data, globalData, comp);
              this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
                _placeholder: true
              };
            }
            extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement);
            HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;
            HCompElement.prototype.createContainerElements = function () {
              this._createBaseContainerElements(); // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';

              if (this.data.hasMask) {
                this.svgElement.setAttribute('width', this.data.w);
                this.svgElement.setAttribute('height', this.data.h);
                this.transformedElement = this.baseElement;
              } else {
                this.transformedElement = this.layerElement;
              }
            };
            HCompElement.prototype.addTo3dContainer = function (elem, pos) {
              var j = 0;
              var nextElement;
              while (j < pos) {
                if (this.elements[j] && this.elements[j].getBaseElement) {
                  nextElement = this.elements[j].getBaseElement();
                }
                j += 1;
              }
              if (nextElement) {
                this.layerElement.insertBefore(elem, nextElement);
              } else {
                this.layerElement.appendChild(elem);
              }
            };
            HCompElement.prototype.createComp = function (data) {
              if (!this.supports3d) {
                return new SVGCompElement(data, this.globalData, this);
              }
              return new HCompElement(data, this.globalData, this);
            };
            function HybridRenderer(animationItem, config) {
              this.animationItem = animationItem;
              this.layers = null;
              this.renderedFrame = -1;
              this.renderConfig = {
                className: config && config.className || '',
                imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
                hideOnTransparent: !(config && config.hideOnTransparent === false),
                filterSize: {
                  width: config && config.filterSize && config.filterSize.width || '400%',
                  height: config && config.filterSize && config.filterSize.height || '400%',
                  x: config && config.filterSize && config.filterSize.x || '-100%',
                  y: config && config.filterSize && config.filterSize.y || '-100%'
                },
                runExpressions: !config || config.runExpressions === undefined || config.runExpressions
              };
              this.globalData = {
                _mdf: false,
                frameNum: -1,
                renderConfig: this.renderConfig
              };
              this.pendingElements = [];
              this.elements = [];
              this.threeDElements = [];
              this.destroyed = false;
              this.camera = null;
              this.supports3d = true;
              this.rendererType = 'html';
            }
            extendPrototype([HybridRendererBase], HybridRenderer);
            HybridRenderer.prototype.createComp = function (data) {
              if (!this.supports3d) {
                return new SVGCompElement(data, this.globalData, this);
              }
              return new HCompElement(data, this.globalData, this);
            };
            var CompExpressionInterface = function () {
              return function (comp) {
                function _thisLayerFunction(name) {
                  var i = 0;
                  var len = comp.layers.length;
                  while (i < len) {
                    if (comp.layers[i].nm === name || comp.layers[i].ind === name) {
                      return comp.elements[i].layerInterface;
                    }
                    i += 1;
                  }
                  return null; // return {active:false};
                }
                Object.defineProperty(_thisLayerFunction, '_name', {
                  value: comp.data.nm
                });
                _thisLayerFunction.layer = _thisLayerFunction;
                _thisLayerFunction.pixelAspect = 1;
                _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;
                _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;
                _thisLayerFunction.pixelAspect = 1;
                _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;
                _thisLayerFunction.displayStartTime = 0;
                _thisLayerFunction.numLayers = comp.layers.length;
                return _thisLayerFunction;
              };
            }();
            function _typeof$2(obj) {
              "@babel/helpers - typeof";

              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof$2 = function _typeof(obj) {
                  return typeof obj;
                };
              } else {
                _typeof$2 = function _typeof(obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
              }
              return _typeof$2(obj);
            }

            /* eslint-disable */

            /*
             Copyright 2014 David Bau.
               Permission is hereby granted, free of charge, to any person obtaining
             a copy of this software and associated documentation files (the
             "Software"), to deal in the Software without restriction, including
             without limitation the rights to use, copy, modify, merge, publish,
             distribute, sublicense, and/or sell copies of the Software, and to
             permit persons to whom the Software is furnished to do so, subject to
             the following conditions:
               The above copyright notice and this permission notice shall be
             included in all copies or substantial portions of the Software.
               THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
             EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
             MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
             IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
             CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
             TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
             SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
               */
            function seedRandom(pool, math) {
              //
              // The following constants are related to IEEE 754 limits.
              //
              var global = this,
                width = 256,
                // each RC4 output is 0 <= x < 256
                chunks = 6,
                // at least six RC4 outputs for each double
                digits = 52,
                // there are 52 significant digits in a double
                rngname = 'random',
                // rngname: name for Math.random and Math.seedrandom
                startdenom = math.pow(width, chunks),
                significance = math.pow(2, digits),
                overflow = significance * 2,
                mask = width - 1,
                nodecrypto; // node.js crypto module, initialized at the bottom.
              //
              // seedrandom()
              // This is the seedrandom function described above.
              //

              function seedrandom(seed, options, callback) {
                var key = [];
                options = options === true ? {
                  entropy: true
                } : options || {}; // Flatten the seed string or build one from local entropy if needed.

                var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key); // Use the seed to initialize an ARC4 generator.

                var arc4 = new ARC4(key); // This function returns a random double in [0, 1) that contains
                // randomness in every bit of the mantissa of the IEEE 754 value.

                var prng = function prng() {
                  var n = arc4.g(chunks),
                    // Start with a numerator n < 2 ^ 48
                    d = startdenom,
                    //   and denominator d = 2 ^ 48.
                    x = 0; //   and no 'extra last byte'.

                  while (n < significance) {
                    // Fill up all significant digits by
                    n = (n + x) * width; //   shifting numerator and

                    d *= width; //   denominator and generating a

                    x = arc4.g(1); //   new least-significant-byte.
                  }
                  while (n >= overflow) {
                    // To avoid rounding up, before adding
                    n /= 2; //   last byte, shift everything

                    d /= 2; //   right using integer math until

                    x >>>= 1; //   we have exactly the desired bits.
                  }
                  return (n + x) / d; // Form the number within [0, 1).
                };
                prng.int32 = function () {
                  return arc4.g(4) | 0;
                };
                prng.quick = function () {
                  return arc4.g(4) / 0x100000000;
                };
                prng["double"] = prng; // Mix the randomness into accumulated entropy.

                mixkey(tostring(arc4.S), pool); // Calling convention: what to return as a function of prng, seed, is_math.

                return (options.pass || callback || function (prng, seed, is_math_call, state) {
                  if (state) {
                    // Load the arc4 state from the given state if it has an S array.
                    if (state.S) {
                      copy(state, arc4);
                    } // Only provide the .state method if requested via options.state.

                    prng.state = function () {
                      return copy(arc4, {});
                    };
                  } // If called as a method of Math (Math.seedrandom()), mutate
                  // Math.random because that is how seedrandom.js has worked since v1.0.

                  if (is_math_call) {
                    math[rngname] = prng;
                    return seed;
                  } // Otherwise, it is a newer calling convention, so return the
                  // prng directly.
                  else return prng;
                })(prng, shortseed, 'global' in options ? options.global : this == math, options.state);
              }
              math['seed' + rngname] = seedrandom; //
              // ARC4
              //
              // An ARC4 implementation.  The constructor takes a key in the form of
              // an array of at most (width) integers that should be 0 <= x < (width).
              //
              // The g(count) method returns a pseudorandom integer that concatenates
              // the next (count) outputs from ARC4.  Its return value is a number x
              // that is in the range 0 <= x < (width ^ count).
              //

              function ARC4(key) {
                var t,
                  keylen = key.length,
                  me = this,
                  i = 0,
                  j = me.i = me.j = 0,
                  s = me.S = []; // The empty key [] is treated as [0].

                if (!keylen) {
                  key = [keylen++];
                } // Set up S using the standard key scheduling algorithm.

                while (i < width) {
                  s[i] = i++;
                }
                for (i = 0; i < width; i++) {
                  s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
                  s[j] = t;
                } // The "g" method returns the next (count) outputs as one number.

                me.g = function (count) {
                  // Using instance members instead of closure state nearly doubles speed.
                  var t,
                    r = 0,
                    i = me.i,
                    j = me.j,
                    s = me.S;
                  while (count--) {
                    t = s[i = mask & i + 1];
                    r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];
                  }
                  me.i = i;
                  me.j = j;
                  return r; // For robust unpredictability, the function call below automatically
                  // discards an initial batch of values.  This is called RC4-drop[256].
                  // See http://google.com/search?q=rsa+fluhrer+response&btnI
                };
              } //
              // copy()
              // Copies internal state of ARC4 to or from a plain object.
              //

              function copy(f, t) {
                t.i = f.i;
                t.j = f.j;
                t.S = f.S.slice();
                return t;
              } //
              // flatten()
              // Converts an object tree to nested arrays of strings.
              //

              function flatten(obj, depth) {
                var result = [],
                  typ = _typeof$2(obj),
                  prop;
                if (depth && typ == 'object') {
                  for (prop in obj) {
                    try {
                      result.push(flatten(obj[prop], depth - 1));
                    } catch (e) {}
                  }
                }
                return result.length ? result : typ == 'string' ? obj : obj + '\0';
              } //
              // mixkey()
              // Mixes a string seed into a key that is an array of integers, and
              // returns a shortened string seed that is equivalent to the result key.
              //

              function mixkey(seed, key) {
                var stringseed = seed + '',
                  smear,
                  j = 0;
                while (j < stringseed.length) {
                  key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
                }
                return tostring(key);
              } //
              // autoseed()
              // Returns an object for autoseeding, using window.crypto and Node crypto
              // module if available.
              //

              function autoseed() {
                try {
                  if (nodecrypto) ;
                  var out = new Uint8Array(width);
                  (global.crypto || global.msCrypto).getRandomValues(out);
                  return tostring(out);
                } catch (e) {
                  var browser = global.navigator,
                    plugins = browser && browser.plugins;
                  return [+new Date(), global, plugins, global.screen, tostring(pool)];
                }
              } //
              // tostring()
              // Converts an array of charcodes to a string
              //

              function tostring(a) {
                return String.fromCharCode.apply(0, a);
              } //
              // When seedrandom.js is loaded, we immediately mix a few bits
              // from the built-in RNG into the entropy pool.  Because we do
              // not want to interfere with deterministic PRNG state later,
              // seedrandom will not call math.random on its own again after
              // initialization.
              //

              mixkey(math.random(), pool); //
              // Nodejs and AMD support: export the implementation as a module using
              // either convention.
              //
              // End anonymous scope, and pass initial values.
            }
            function initialize$2(BMMath) {
              seedRandom([], BMMath);
            }
            var propTypes = {
              SHAPE: 'shape'
            };
            function _typeof$1(obj) {
              "@babel/helpers - typeof";

              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof$1 = function _typeof(obj) {
                  return typeof obj;
                };
              } else {
                _typeof$1 = function _typeof(obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
              }
              return _typeof$1(obj);
            }
            var ExpressionManager = function () {
              var ob = {};
              var Math = BMMath;
              var window = null;
              var document = null;
              var XMLHttpRequest = null;
              var fetch = null;
              var frames = null;
              var _lottieGlobal = {};
              initialize$2(BMMath);
              function resetFrame() {
                _lottieGlobal = {};
              }
              function $bm_isInstanceOfArray(arr) {
                return arr.constructor === Array || arr.constructor === Float32Array;
              }
              function isNumerable(tOfV, v) {
                return tOfV === 'number' || v instanceof Number || tOfV === 'boolean' || tOfV === 'string';
              }
              function $bm_neg(a) {
                var tOfA = _typeof$1(a);
                if (tOfA === 'number' || a instanceof Number || tOfA === 'boolean') {
                  return -a;
                }
                if ($bm_isInstanceOfArray(a)) {
                  var i;
                  var lenA = a.length;
                  var retArr = [];
                  for (i = 0; i < lenA; i += 1) {
                    retArr[i] = -a[i];
                  }
                  return retArr;
                }
                if (a.propType) {
                  return a.v;
                }
                return -a;
              }
              var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get;
              var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get;
              var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get;
              function sum(a, b) {
                var tOfA = _typeof$1(a);
                var tOfB = _typeof$1(b);
                if (isNumerable(tOfA, a) && isNumerable(tOfB, b) || tOfA === 'string' || tOfB === 'string') {
                  return a + b;
                }
                if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                  a = a.slice(0);
                  a[0] += b;
                  return a;
                }
                if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                  b = b.slice(0);
                  b[0] = a + b[0];
                  return b;
                }
                if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
                  var i = 0;
                  var lenA = a.length;
                  var lenB = b.length;
                  var retArr = [];
                  while (i < lenA || i < lenB) {
                    if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
                      retArr[i] = a[i] + b[i];
                    } else {
                      retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
                    }
                    i += 1;
                  }
                  return retArr;
                }
                return 0;
              }
              var add = sum;
              function sub(a, b) {
                var tOfA = _typeof$1(a);
                var tOfB = _typeof$1(b);
                if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
                  if (tOfA === 'string') {
                    a = parseInt(a, 10);
                  }
                  if (tOfB === 'string') {
                    b = parseInt(b, 10);
                  }
                  return a - b;
                }
                if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                  a = a.slice(0);
                  a[0] -= b;
                  return a;
                }
                if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                  b = b.slice(0);
                  b[0] = a - b[0];
                  return b;
                }
                if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
                  var i = 0;
                  var lenA = a.length;
                  var lenB = b.length;
                  var retArr = [];
                  while (i < lenA || i < lenB) {
                    if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
                      retArr[i] = a[i] - b[i];
                    } else {
                      retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
                    }
                    i += 1;
                  }
                  return retArr;
                }
                return 0;
              }
              function mul(a, b) {
                var tOfA = _typeof$1(a);
                var tOfB = _typeof$1(b);
                var arr;
                if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
                  return a * b;
                }
                var i;
                var len;
                if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                  len = a.length;
                  arr = createTypedArray('float32', len);
                  for (i = 0; i < len; i += 1) {
                    arr[i] = a[i] * b;
                  }
                  return arr;
                }
                if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                  len = b.length;
                  arr = createTypedArray('float32', len);
                  for (i = 0; i < len; i += 1) {
                    arr[i] = a * b[i];
                  }
                  return arr;
                }
                return 0;
              }
              function div(a, b) {
                var tOfA = _typeof$1(a);
                var tOfB = _typeof$1(b);
                var arr;
                if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
                  return a / b;
                }
                var i;
                var len;
                if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                  len = a.length;
                  arr = createTypedArray('float32', len);
                  for (i = 0; i < len; i += 1) {
                    arr[i] = a[i] / b;
                  }
                  return arr;
                }
                if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                  len = b.length;
                  arr = createTypedArray('float32', len);
                  for (i = 0; i < len; i += 1) {
                    arr[i] = a / b[i];
                  }
                  return arr;
                }
                return 0;
              }
              function mod(a, b) {
                if (typeof a === 'string') {
                  a = parseInt(a, 10);
                }
                if (typeof b === 'string') {
                  b = parseInt(b, 10);
                }
                return a % b;
              }
              var $bm_sum = sum;
              var $bm_sub = sub;
              var $bm_mul = mul;
              var $bm_div = div;
              var $bm_mod = mod;
              function clamp(num, min, max) {
                if (min > max) {
                  var mm = max;
                  max = min;
                  min = mm;
                }
                return Math.min(Math.max(num, min), max);
              }
              function radiansToDegrees(val) {
                return val / degToRads;
              }
              var radians_to_degrees = radiansToDegrees;
              function degreesToRadians(val) {
                return val * degToRads;
              }
              var degrees_to_radians = radiansToDegrees;
              var helperLengthArray = [0, 0, 0, 0, 0, 0];
              function length(arr1, arr2) {
                if (typeof arr1 === 'number' || arr1 instanceof Number) {
                  arr2 = arr2 || 0;
                  return Math.abs(arr1 - arr2);
                }
                if (!arr2) {
                  arr2 = helperLengthArray;
                }
                var i;
                var len = Math.min(arr1.length, arr2.length);
                var addedLength = 0;
                for (i = 0; i < len; i += 1) {
                  addedLength += Math.pow(arr2[i] - arr1[i], 2);
                }
                return Math.sqrt(addedLength);
              }
              function normalize(vec) {
                return div(vec, length(vec));
              }
              function rgbToHsl(val) {
                var r = val[0];
                var g = val[1];
                var b = val[2];
                var max = Math.max(r, g, b);
                var min = Math.min(r, g, b);
                var h;
                var s;
                var l = (max + min) / 2;
                if (max === min) {
                  h = 0; // achromatic

                  s = 0; // achromatic
                } else {
                  var d = max - min;
                  s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                  switch (max) {
                    case r:
                      h = (g - b) / d + (g < b ? 6 : 0);
                      break;
                    case g:
                      h = (b - r) / d + 2;
                      break;
                    case b:
                      h = (r - g) / d + 4;
                      break;
                  }
                  h /= 6;
                }
                return [h, s, l, val[3]];
              }
              function hue2rgb(p, q, t) {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
              }
              function hslToRgb(val) {
                var h = val[0];
                var s = val[1];
                var l = val[2];
                var r;
                var g;
                var b;
                if (s === 0) {
                  r = l; // achromatic

                  b = l; // achromatic

                  g = l; // achromatic
                } else {
                  var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                  var p = 2 * l - q;
                  r = hue2rgb(p, q, h + 1 / 3);
                  g = hue2rgb(p, q, h);
                  b = hue2rgb(p, q, h - 1 / 3);
                }
                return [r, g, b, val[3]];
              }
              function linear(t, tMin, tMax, value1, value2) {
                if (value1 === undefined || value2 === undefined) {
                  value1 = tMin;
                  value2 = tMax;
                  tMin = 0;
                  tMax = 1;
                }
                if (tMax < tMin) {
                  var _tMin = tMax;
                  tMax = tMin;
                  tMin = _tMin;
                }
                if (t <= tMin) {
                  return value1;
                }
                if (t >= tMax) {
                  return value2;
                }
                var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);
                if (!value1.length) {
                  return value1 + (value2 - value1) * perc;
                }
                var i;
                var len = value1.length;
                var arr = createTypedArray('float32', len);
                for (i = 0; i < len; i += 1) {
                  arr[i] = value1[i] + (value2[i] - value1[i]) * perc;
                }
                return arr;
              }
              function random(min, max) {
                if (max === undefined) {
                  if (min === undefined) {
                    min = 0;
                    max = 1;
                  } else {
                    max = min;
                    min = undefined;
                  }
                }
                if (max.length) {
                  var i;
                  var len = max.length;
                  if (!min) {
                    min = createTypedArray('float32', len);
                  }
                  var arr = createTypedArray('float32', len);
                  var rnd = BMMath.random();
                  for (i = 0; i < len; i += 1) {
                    arr[i] = min[i] + rnd * (max[i] - min[i]);
                  }
                  return arr;
                }
                if (min === undefined) {
                  min = 0;
                }
                var rndm = BMMath.random();
                return min + rndm * (max - min);
              }
              function createPath(points, inTangents, outTangents, closed) {
                var i;
                var len = points.length;
                var path = shapePool.newElement();
                path.setPathData(!!closed, len);
                var arrPlaceholder = [0, 0];
                var inVertexPoint;
                var outVertexPoint;
                for (i = 0; i < len; i += 1) {
                  inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;
                  outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder;
                  path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);
                }
                return path;
              }
              function initiateExpression(elem, data, property) {
                // Bail out if we don't want expressions
                function noOp(_value) {
                  return _value;
                }
                if (!elem.globalData.renderConfig.runExpressions) {
                  return noOp;
                }
                var val = data.x;
                var needsVelocity = /velocity(?![\w\d])/.test(val);
                var _needsRandom = val.indexOf('random') !== -1;
                var elemType = elem.data.ty;
                var transform;
                var $bm_transform;
                var content;
                var effect;
                var thisProperty = property;
                thisProperty.valueAtTime = thisProperty.getValueAtTime;
                Object.defineProperty(thisProperty, 'value', {
                  get: function get() {
                    return thisProperty.v;
                  }
                });
                elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
                elem.comp.displayStartTime = 0;
                var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
                var outPoint = elem.data.op / elem.comp.globalData.frameRate;
                var width = elem.data.sw ? elem.data.sw : 0;
                var height = elem.data.sh ? elem.data.sh : 0;
                var name = elem.data.nm;
                var loopIn;
                var loop_in;
                var loopOut;
                var loop_out;
                var smooth;
                var toWorld;
                var fromWorld;
                var fromComp;
                var toComp;
                var fromCompToSurface;
                var position;
                var rotation;
                var anchorPoint;
                var scale;
                var thisLayer;
                var thisComp;
                var mask;
                var valueAtTime;
                var velocityAtTime;
                var scoped_bm_rt; // val = val.replace(/(\\?"|')((http)(s)?(:\/))?\/.*?(\\?"|')/g, "\"\""); // deter potential network calls

                var expression_function = eval('[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}]')[0]; // eslint-disable-line no-eval

                var numKeys = property.kf ? data.k.length : 0;
                var active = !this.data || this.data.hd !== true;
                var wiggle = function wiggle(freq, amp) {
                  var iWiggle;
                  var j;
                  var lenWiggle = this.pv.length ? this.pv.length : 1;
                  var addedAmps = createTypedArray('float32', lenWiggle);
                  freq = 5;
                  var iterations = Math.floor(time * freq);
                  iWiggle = 0;
                  j = 0;
                  while (iWiggle < iterations) {
                    // var rnd = BMMath.random();
                    for (j = 0; j < lenWiggle; j += 1) {
                      addedAmps[j] += -amp + amp * 2 * BMMath.random(); // addedAmps[j] += -amp + amp*2*rnd;
                    }
                    iWiggle += 1;
                  } // var rnd2 = BMMath.random();

                  var periods = time * freq;
                  var perc = periods - Math.floor(periods);
                  var arr = createTypedArray('float32', lenWiggle);
                  if (lenWiggle > 1) {
                    for (j = 0; j < lenWiggle; j += 1) {
                      arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc; // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
                      // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
                    }
                    return arr;
                  }
                  return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
                }.bind(this);
                if (thisProperty.loopIn) {
                  loopIn = thisProperty.loopIn.bind(thisProperty);
                  loop_in = loopIn;
                }
                if (thisProperty.loopOut) {
                  loopOut = thisProperty.loopOut.bind(thisProperty);
                  loop_out = loopOut;
                }
                if (thisProperty.smooth) {
                  smooth = thisProperty.smooth.bind(thisProperty);
                }
                function loopInDuration(type, duration) {
                  return loopIn(type, duration, true);
                }
                function loopOutDuration(type, duration) {
                  return loopOut(type, duration, true);
                }
                if (this.getValueAtTime) {
                  valueAtTime = this.getValueAtTime.bind(this);
                }
                if (this.getVelocityAtTime) {
                  velocityAtTime = this.getVelocityAtTime.bind(this);
                }
                var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
                function lookAt(elem1, elem2) {
                  var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
                  var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
                  var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
                  return [yaw, pitch, 0];
                }
                function easeOut(t, tMin, tMax, val1, val2) {
                  return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
                }
                function easeIn(t, tMin, tMax, val1, val2) {
                  return applyEase(easeInBez, t, tMin, tMax, val1, val2);
                }
                function ease(t, tMin, tMax, val1, val2) {
                  return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
                }
                function applyEase(fn, t, tMin, tMax, val1, val2) {
                  if (val1 === undefined) {
                    val1 = tMin;
                    val2 = tMax;
                  } else {
                    t = (t - tMin) / (tMax - tMin);
                  }
                  if (t > 1) {
                    t = 1;
                  } else if (t < 0) {
                    t = 0;
                  }
                  var mult = fn(t);
                  if ($bm_isInstanceOfArray(val1)) {
                    var iKey;
                    var lenKey = val1.length;
                    var arr = createTypedArray('float32', lenKey);
                    for (iKey = 0; iKey < lenKey; iKey += 1) {
                      arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
                    }
                    return arr;
                  }
                  return (val2 - val1) * mult + val1;
                }
                function nearestKey(time) {
                  var iKey;
                  var lenKey = data.k.length;
                  var index;
                  var keyTime;
                  if (!data.k.length || typeof data.k[0] === 'number') {
                    index = 0;
                    keyTime = 0;
                  } else {
                    index = -1;
                    time *= elem.comp.globalData.frameRate;
                    if (time < data.k[0].t) {
                      index = 1;
                      keyTime = data.k[0].t;
                    } else {
                      for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
                        if (time === data.k[iKey].t) {
                          index = iKey + 1;
                          keyTime = data.k[iKey].t;
                          break;
                        } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {
                          if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {
                            index = iKey + 2;
                            keyTime = data.k[iKey + 1].t;
                          } else {
                            index = iKey + 1;
                            keyTime = data.k[iKey].t;
                          }
                          break;
                        }
                      }
                      if (index === -1) {
                        index = iKey + 1;
                        keyTime = data.k[iKey].t;
                      }
                    }
                  }
                  var obKey = {};
                  obKey.index = index;
                  obKey.time = keyTime / elem.comp.globalData.frameRate;
                  return obKey;
                }
                function key(ind) {
                  var obKey;
                  var iKey;
                  var lenKey;
                  if (!data.k.length || typeof data.k[0] === 'number') {
                    throw new Error('The property has no keyframe at index ' + ind);
                  }
                  ind -= 1;
                  obKey = {
                    time: data.k[ind].t / elem.comp.globalData.frameRate,
                    value: []
                  };
                  var arr = Object.prototype.hasOwnProperty.call(data.k[ind], 's') ? data.k[ind].s : data.k[ind - 1].e;
                  lenKey = arr.length;
                  for (iKey = 0; iKey < lenKey; iKey += 1) {
                    obKey[iKey] = arr[iKey];
                    obKey.value[iKey] = arr[iKey];
                  }
                  return obKey;
                }
                function framesToTime(fr, fps) {
                  if (!fps) {
                    fps = elem.comp.globalData.frameRate;
                  }
                  return fr / fps;
                }
                function timeToFrames(t, fps) {
                  if (!t && t !== 0) {
                    t = time;
                  }
                  if (!fps) {
                    fps = elem.comp.globalData.frameRate;
                  }
                  return t * fps;
                }
                function seedRandom(seed) {
                  BMMath.seedrandom(randSeed + seed);
                }
                function sourceRectAtTime() {
                  return elem.sourceRectAtTime();
                }
                function substring(init, end) {
                  if (typeof value === 'string') {
                    if (end === undefined) {
                      return value.substring(init);
                    }
                    return value.substring(init, end);
                  }
                  return '';
                }
                function substr(init, end) {
                  if (typeof value === 'string') {
                    if (end === undefined) {
                      return value.substr(init);
                    }
                    return value.substr(init, end);
                  }
                  return '';
                }
                function posterizeTime(framesPerSecond) {
                  time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
                  value = valueAtTime(time);
                }
                var time;
                var velocity;
                var value;
                var text;
                var textIndex;
                var textTotal;
                var selectorValue;
                var index = elem.data.ind;
                var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
                var parent;
                var randSeed = Math.floor(Math.random() * 1000000);
                var globalData = elem.globalData;
                function executeExpression(_value) {
                  // globalData.pushExpression();
                  value = _value;
                  if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {
                    return value;
                  }
                  if (this.propType === 'textSelector') {
                    textIndex = this.textIndex;
                    textTotal = this.textTotal;
                    selectorValue = this.selectorValue;
                  }
                  if (!thisLayer) {
                    text = elem.layerInterface.text;
                    thisLayer = elem.layerInterface;
                    thisComp = elem.comp.compInterface;
                    toWorld = thisLayer.toWorld.bind(thisLayer);
                    fromWorld = thisLayer.fromWorld.bind(thisLayer);
                    fromComp = thisLayer.fromComp.bind(thisLayer);
                    toComp = thisLayer.toComp.bind(thisLayer);
                    mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
                    fromCompToSurface = fromComp;
                  }
                  if (!transform) {
                    transform = elem.layerInterface('ADBE Transform Group');
                    $bm_transform = transform;
                    if (transform) {
                      anchorPoint = transform.anchorPoint;
                      /* position = transform.position;
                                rotation = transform.rotation;
                                scale = transform.scale; */
                    }
                  }
                  if (elemType === 4 && !content) {
                    content = thisLayer('ADBE Root Vectors Group');
                  }
                  if (!effect) {
                    effect = thisLayer(4);
                  }
                  hasParent = !!(elem.hierarchy && elem.hierarchy.length);
                  if (hasParent && !parent) {
                    parent = elem.hierarchy[0].layerInterface;
                  }
                  time = this.comp.renderedFrame / this.comp.globalData.frameRate;
                  if (_needsRandom) {
                    seedRandom(randSeed + time);
                  }
                  if (needsVelocity) {
                    velocity = velocityAtTime(time);
                  }
                  expression_function();
                  this.frameExpressionId = elem.globalData.frameId; // TODO: Check if it's possible to return on ShapeInterface the .v value
                  // Changed this to a ternary operation because Rollup failed compiling it correctly

                  scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;
                  return scoped_bm_rt;
                } // Bundlers will see these as dead code and unless we reference them

                executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData];
                return executeExpression;
              }
              ob.initiateExpression = initiateExpression;
              ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal];
              ob.resetFrame = resetFrame;
              return ob;
            }();
            var Expressions = function () {
              var ob = {};
              ob.initExpressions = initExpressions;
              ob.resetFrame = ExpressionManager.resetFrame;
              function initExpressions(animation) {
                var stackCount = 0;
                var registers = [];
                function pushExpression() {
                  stackCount += 1;
                }
                function popExpression() {
                  stackCount -= 1;
                  if (stackCount === 0) {
                    releaseInstances();
                  }
                }
                function registerExpressionProperty(expression) {
                  if (registers.indexOf(expression) === -1) {
                    registers.push(expression);
                  }
                }
                function releaseInstances() {
                  var i;
                  var len = registers.length;
                  for (i = 0; i < len; i += 1) {
                    registers[i].release();
                  }
                  registers.length = 0;
                }
                animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
                animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
                animation.renderer.globalData.pushExpression = pushExpression;
                animation.renderer.globalData.popExpression = popExpression;
                animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
              }
              return ob;
            }();
            var MaskManagerInterface = function () {
              function MaskInterface(mask, data) {
                this._mask = mask;
                this._data = data;
              }
              Object.defineProperty(MaskInterface.prototype, 'maskPath', {
                get: function get() {
                  if (this._mask.prop.k) {
                    this._mask.prop.getValue();
                  }
                  return this._mask.prop;
                }
              });
              Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {
                get: function get() {
                  if (this._mask.op.k) {
                    this._mask.op.getValue();
                  }
                  return this._mask.op.v * 100;
                }
              });
              var MaskManager = function MaskManager(maskManager) {
                var _masksInterfaces = createSizedArray(maskManager.viewData.length);
                var i;
                var len = maskManager.viewData.length;
                for (i = 0; i < len; i += 1) {
                  _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
                }
                var maskFunction = function maskFunction(name) {
                  i = 0;
                  while (i < len) {
                    if (maskManager.masksProperties[i].nm === name) {
                      return _masksInterfaces[i];
                    }
                    i += 1;
                  }
                  return null;
                };
                return maskFunction;
              };
              return MaskManager;
            }();
            var ExpressionPropertyInterface = function () {
              var defaultUnidimensionalValue = {
                pv: 0,
                v: 0,
                mult: 1
              };
              var defaultMultidimensionalValue = {
                pv: [0, 0, 0],
                v: [0, 0, 0],
                mult: 1
              };
              function completeProperty(expressionValue, property, type) {
                Object.defineProperty(expressionValue, 'velocity', {
                  get: function get() {
                    return property.getVelocityAtTime(property.comp.currentFrame);
                  }
                });
                expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;
                expressionValue.key = function (pos) {
                  if (!expressionValue.numKeys) {
                    return 0;
                  }
                  var value = '';
                  if ('s' in property.keyframes[pos - 1]) {
                    value = property.keyframes[pos - 1].s;
                  } else if ('e' in property.keyframes[pos - 2]) {
                    value = property.keyframes[pos - 2].e;
                  } else {
                    value = property.keyframes[pos - 2].s;
                  }
                  var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value); // eslint-disable-line no-new-wrappers

                  valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;
                  valueProp.value = type === 'unidimensional' ? value[0] : value;
                  return valueProp;
                };
                expressionValue.valueAtTime = property.getValueAtTime;
                expressionValue.speedAtTime = property.getSpeedAtTime;
                expressionValue.velocityAtTime = property.getVelocityAtTime;
                expressionValue.propertyGroup = property.propertyGroup;
              }
              function UnidimensionalPropertyInterface(property) {
                if (!property || !('pv' in property)) {
                  property = defaultUnidimensionalValue;
                }
                var mult = 1 / property.mult;
                var val = property.pv * mult;
                var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers

                expressionValue.value = val;
                completeProperty(expressionValue, property, 'unidimensional');
                return function () {
                  if (property.k) {
                    property.getValue();
                  }
                  val = property.v * mult;
                  if (expressionValue.value !== val) {
                    expressionValue = new Number(val); // eslint-disable-line no-new-wrappers

                    expressionValue.value = val;
                    completeProperty(expressionValue, property, 'unidimensional');
                  }
                  return expressionValue;
                };
              }
              function MultidimensionalPropertyInterface(property) {
                if (!property || !('pv' in property)) {
                  property = defaultMultidimensionalValue;
                }
                var mult = 1 / property.mult;
                var len = property.data && property.data.l || property.pv.length;
                var expressionValue = createTypedArray('float32', len);
                var arrValue = createTypedArray('float32', len);
                expressionValue.value = arrValue;
                completeProperty(expressionValue, property, 'multidimensional');
                return function () {
                  if (property.k) {
                    property.getValue();
                  }
                  for (var i = 0; i < len; i += 1) {
                    arrValue[i] = property.v[i] * mult;
                    expressionValue[i] = arrValue[i];
                  }
                  return expressionValue;
                };
              } // TODO: try to avoid using this getter

              function defaultGetter() {
                return defaultUnidimensionalValue;
              }
              return function (property) {
                if (!property) {
                  return defaultGetter;
                }
                if (property.propType === 'unidimensional') {
                  return UnidimensionalPropertyInterface(property);
                }
                return MultidimensionalPropertyInterface(property);
              };
            }();
            var TransformExpressionInterface = function () {
              return function (transform) {
                function _thisFunction(name) {
                  switch (name) {
                    case 'scale':
                    case 'Scale':
                    case 'ADBE Scale':
                    case 6:
                      return _thisFunction.scale;
                    case 'rotation':
                    case 'Rotation':
                    case 'ADBE Rotation':
                    case 'ADBE Rotate Z':
                    case 10:
                      return _thisFunction.rotation;
                    case 'ADBE Rotate X':
                      return _thisFunction.xRotation;
                    case 'ADBE Rotate Y':
                      return _thisFunction.yRotation;
                    case 'position':
                    case 'Position':
                    case 'ADBE Position':
                    case 2:
                      return _thisFunction.position;
                    case 'ADBE Position_0':
                      return _thisFunction.xPosition;
                    case 'ADBE Position_1':
                      return _thisFunction.yPosition;
                    case 'ADBE Position_2':
                      return _thisFunction.zPosition;
                    case 'anchorPoint':
                    case 'AnchorPoint':
                    case 'Anchor Point':
                    case 'ADBE AnchorPoint':
                    case 1:
                      return _thisFunction.anchorPoint;
                    case 'opacity':
                    case 'Opacity':
                    case 11:
                      return _thisFunction.opacity;
                    default:
                      return null;
                  }
                }
                Object.defineProperty(_thisFunction, 'rotation', {
                  get: ExpressionPropertyInterface(transform.r || transform.rz)
                });
                Object.defineProperty(_thisFunction, 'zRotation', {
                  get: ExpressionPropertyInterface(transform.rz || transform.r)
                });
                Object.defineProperty(_thisFunction, 'xRotation', {
                  get: ExpressionPropertyInterface(transform.rx)
                });
                Object.defineProperty(_thisFunction, 'yRotation', {
                  get: ExpressionPropertyInterface(transform.ry)
                });
                Object.defineProperty(_thisFunction, 'scale', {
                  get: ExpressionPropertyInterface(transform.s)
                });
                var _px;
                var _py;
                var _pz;
                var _transformFactory;
                if (transform.p) {
                  _transformFactory = ExpressionPropertyInterface(transform.p);
                } else {
                  _px = ExpressionPropertyInterface(transform.px);
                  _py = ExpressionPropertyInterface(transform.py);
                  if (transform.pz) {
                    _pz = ExpressionPropertyInterface(transform.pz);
                  }
                }
                Object.defineProperty(_thisFunction, 'position', {
                  get: function get() {
                    if (transform.p) {
                      return _transformFactory();
                    }
                    return [_px(), _py(), _pz ? _pz() : 0];
                  }
                });
                Object.defineProperty(_thisFunction, 'xPosition', {
                  get: ExpressionPropertyInterface(transform.px)
                });
                Object.defineProperty(_thisFunction, 'yPosition', {
                  get: ExpressionPropertyInterface(transform.py)
                });
                Object.defineProperty(_thisFunction, 'zPosition', {
                  get: ExpressionPropertyInterface(transform.pz)
                });
                Object.defineProperty(_thisFunction, 'anchorPoint', {
                  get: ExpressionPropertyInterface(transform.a)
                });
                Object.defineProperty(_thisFunction, 'opacity', {
                  get: ExpressionPropertyInterface(transform.o)
                });
                Object.defineProperty(_thisFunction, 'skew', {
                  get: ExpressionPropertyInterface(transform.sk)
                });
                Object.defineProperty(_thisFunction, 'skewAxis', {
                  get: ExpressionPropertyInterface(transform.sa)
                });
                Object.defineProperty(_thisFunction, 'orientation', {
                  get: ExpressionPropertyInterface(transform.or)
                });
                return _thisFunction;
              };
            }();
            var LayerExpressionInterface = function () {
              function getMatrix(time) {
                var toWorldMat = new Matrix();
                if (time !== undefined) {
                  var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);
                  propMatrix.clone(toWorldMat);
                } else {
                  var transformMat = this._elem.finalTransform.mProp;
                  transformMat.applyToMatrix(toWorldMat);
                }
                return toWorldMat;
              }
              function toWorldVec(arr, time) {
                var toWorldMat = this.getMatrix(time);
                toWorldMat.props[12] = 0;
                toWorldMat.props[13] = 0;
                toWorldMat.props[14] = 0;
                return this.applyPoint(toWorldMat, arr);
              }
              function toWorld(arr, time) {
                var toWorldMat = this.getMatrix(time);
                return this.applyPoint(toWorldMat, arr);
              }
              function fromWorldVec(arr, time) {
                var toWorldMat = this.getMatrix(time);
                toWorldMat.props[12] = 0;
                toWorldMat.props[13] = 0;
                toWorldMat.props[14] = 0;
                return this.invertPoint(toWorldMat, arr);
              }
              function fromWorld(arr, time) {
                var toWorldMat = this.getMatrix(time);
                return this.invertPoint(toWorldMat, arr);
              }
              function applyPoint(matrix, arr) {
                if (this._elem.hierarchy && this._elem.hierarchy.length) {
                  var i;
                  var len = this._elem.hierarchy.length;
                  for (i = 0; i < len; i += 1) {
                    this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
                  }
                }
                return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
              }
              function invertPoint(matrix, arr) {
                if (this._elem.hierarchy && this._elem.hierarchy.length) {
                  var i;
                  var len = this._elem.hierarchy.length;
                  for (i = 0; i < len; i += 1) {
                    this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
                  }
                }
                return matrix.inversePoint(arr);
              }
              function fromComp(arr) {
                var toWorldMat = new Matrix();
                toWorldMat.reset();
                this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
                if (this._elem.hierarchy && this._elem.hierarchy.length) {
                  var i;
                  var len = this._elem.hierarchy.length;
                  for (i = 0; i < len; i += 1) {
                    this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
                  }
                  return toWorldMat.inversePoint(arr);
                }
                return toWorldMat.inversePoint(arr);
              }
              function sampleImage() {
                return [1, 1, 1, 1];
              }
              return function (elem) {
                var transformInterface;
                function _registerMaskInterface(maskManager) {
                  _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
                }
                function _registerEffectsInterface(effects) {
                  _thisLayerFunction.effect = effects;
                }
                function _thisLayerFunction(name) {
                  switch (name) {
                    case 'ADBE Root Vectors Group':
                    case 'Contents':
                    case 2:
                      return _thisLayerFunction.shapeInterface;
                    case 1:
                    case 6:
                    case 'Transform':
                    case 'transform':
                    case 'ADBE Transform Group':
                      return transformInterface;
                    case 4:
                    case 'ADBE Effect Parade':
                    case 'effects':
                    case 'Effects':
                      return _thisLayerFunction.effect;
                    case 'ADBE Text Properties':
                      return _thisLayerFunction.textInterface;
                    default:
                      return null;
                  }
                }
                _thisLayerFunction.getMatrix = getMatrix;
                _thisLayerFunction.invertPoint = invertPoint;
                _thisLayerFunction.applyPoint = applyPoint;
                _thisLayerFunction.toWorld = toWorld;
                _thisLayerFunction.toWorldVec = toWorldVec;
                _thisLayerFunction.fromWorld = fromWorld;
                _thisLayerFunction.fromWorldVec = fromWorldVec;
                _thisLayerFunction.toComp = toWorld;
                _thisLayerFunction.fromComp = fromComp;
                _thisLayerFunction.sampleImage = sampleImage;
                _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
                _thisLayerFunction._elem = elem;
                transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);
                var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');
                Object.defineProperties(_thisLayerFunction, {
                  hasParent: {
                    get: function get() {
                      return elem.hierarchy.length;
                    }
                  },
                  parent: {
                    get: function get() {
                      return elem.hierarchy[0].layerInterface;
                    }
                  },
                  rotation: getDescriptor(transformInterface, 'rotation'),
                  scale: getDescriptor(transformInterface, 'scale'),
                  position: getDescriptor(transformInterface, 'position'),
                  opacity: getDescriptor(transformInterface, 'opacity'),
                  anchorPoint: anchorPointDescriptor,
                  anchor_point: anchorPointDescriptor,
                  transform: {
                    get: function get() {
                      return transformInterface;
                    }
                  },
                  active: {
                    get: function get() {
                      return elem.isInRange;
                    }
                  }
                });
                _thisLayerFunction.startTime = elem.data.st;
                _thisLayerFunction.index = elem.data.ind;
                _thisLayerFunction.source = elem.data.refId;
                _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;
                _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
                _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;
                _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;
                _thisLayerFunction._name = elem.data.nm;
                _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
                _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
                return _thisLayerFunction;
              };
            }();
            var propertyGroupFactory = function () {
              return function (interfaceFunction, parentPropertyGroup) {
                return function (val) {
                  val = val === undefined ? 1 : val;
                  if (val <= 0) {
                    return interfaceFunction;
                  }
                  return parentPropertyGroup(val - 1);
                };
              };
            }();
            var PropertyInterface = function () {
              return function (propertyName, propertyGroup) {
                var interfaceFunction = {
                  _name: propertyName
                };
                function _propertyGroup(val) {
                  val = val === undefined ? 1 : val;
                  if (val <= 0) {
                    return interfaceFunction;
                  }
                  return propertyGroup(val - 1);
                }
                return _propertyGroup;
              };
            }();
            var EffectsExpressionInterface = function () {
              var ob = {
                createEffectsInterface: createEffectsInterface
              };
              function createEffectsInterface(elem, propertyGroup) {
                if (elem.effectsManager) {
                  var effectElements = [];
                  var effectsData = elem.data.ef;
                  var i;
                  var len = elem.effectsManager.effectElements.length;
                  for (i = 0; i < len; i += 1) {
                    effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));
                  }
                  var effects = elem.data.ef || [];
                  var groupInterface = function groupInterface(name) {
                    i = 0;
                    len = effects.length;
                    while (i < len) {
                      if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
                        return effectElements[i];
                      }
                      i += 1;
                    }
                    return null;
                  };
                  Object.defineProperty(groupInterface, 'numProperties', {
                    get: function get() {
                      return effects.length;
                    }
                  });
                  return groupInterface;
                }
                return null;
              }
              function createGroupInterface(data, elements, propertyGroup, elem) {
                function groupInterface(name) {
                  var effects = data.ef;
                  var i = 0;
                  var len = effects.length;
                  while (i < len) {
                    if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
                      if (effects[i].ty === 5) {
                        return effectElements[i];
                      }
                      return effectElements[i]();
                    }
                    i += 1;
                  }
                  throw new Error();
                }
                var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);
                var effectElements = [];
                var i;
                var len = data.ef.length;
                for (i = 0; i < len; i += 1) {
                  if (data.ef[i].ty === 5) {
                    effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));
                  } else {
                    effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));
                  }
                }
                if (data.mn === 'ADBE Color Control') {
                  Object.defineProperty(groupInterface, 'color', {
                    get: function get() {
                      return effectElements[0]();
                    }
                  });
                }
                Object.defineProperties(groupInterface, {
                  numProperties: {
                    get: function get() {
                      return data.np;
                    }
                  },
                  _name: {
                    value: data.nm
                  },
                  propertyGroup: {
                    value: _propertyGroup
                  }
                });
                groupInterface.enabled = data.en !== 0;
                groupInterface.active = groupInterface.enabled;
                return groupInterface;
              }
              function createValueInterface(element, type, elem, propertyGroup) {
                var expressionProperty = ExpressionPropertyInterface(element.p);
                function interfaceFunction() {
                  if (type === 10) {
                    return elem.comp.compInterface(element.p.v);
                  }
                  return expressionProperty();
                }
                if (element.p.setGroupProperty) {
                  element.p.setGroupProperty(PropertyInterface('', propertyGroup));
                }
                return interfaceFunction;
              }
              return ob;
            }();
            var ShapePathInterface = function () {
              return function pathInterfaceFactory(shape, view, propertyGroup) {
                var prop = view.sh;
                function interfaceFunction(val) {
                  if (val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2) {
                    return interfaceFunction.path;
                  }
                  return null;
                }
                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                prop.setGroupProperty(PropertyInterface('Path', _propertyGroup));
                Object.defineProperties(interfaceFunction, {
                  path: {
                    get: function get() {
                      if (prop.k) {
                        prop.getValue();
                      }
                      return prop;
                    }
                  },
                  shape: {
                    get: function get() {
                      if (prop.k) {
                        prop.getValue();
                      }
                      return prop;
                    }
                  },
                  _name: {
                    value: shape.nm
                  },
                  ix: {
                    value: shape.ix
                  },
                  propertyIndex: {
                    value: shape.ix
                  },
                  mn: {
                    value: shape.mn
                  },
                  propertyGroup: {
                    value: propertyGroup
                  }
                });
                return interfaceFunction;
              };
            }();
            var ShapeExpressionInterface = function () {
              function iterateElements(shapes, view, propertyGroup) {
                var arr = [];
                var i;
                var len = shapes ? shapes.length : 0;
                for (i = 0; i < len; i += 1) {
                  if (shapes[i].ty === 'gr') {
                    arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));
                  } else if (shapes[i].ty === 'fl') {
                    arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));
                  } else if (shapes[i].ty === 'st') {
                    arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));
                  } else if (shapes[i].ty === 'tm') {
                    arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));
                  } else if (shapes[i].ty === 'tr') ;else if (shapes[i].ty === 'el') {
                    arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));
                  } else if (shapes[i].ty === 'sr') {
                    arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));
                  } else if (shapes[i].ty === 'sh') {
                    arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));
                  } else if (shapes[i].ty === 'rc') {
                    arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));
                  } else if (shapes[i].ty === 'rd') {
                    arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));
                  } else if (shapes[i].ty === 'rp') {
                    arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));
                  } else if (shapes[i].ty === 'gf') {
                    arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));
                  } else {
                    arr.push(defaultInterfaceFactory(shapes[i], view[i]));
                  }
                }
                return arr;
              }
              function contentsInterfaceFactory(shape, view, propertyGroup) {
                var interfaces;
                var interfaceFunction = function _interfaceFunction(value) {
                  var i = 0;
                  var len = interfaces.length;
                  while (i < len) {
                    if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {
                      return interfaces[i];
                    }
                    i += 1;
                  }
                  if (typeof value === 'number') {
                    return interfaces[value - 1];
                  }
                  return null;
                };
                interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
                interfaceFunction.numProperties = interfaces.length;
                var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
                interfaceFunction.transform = transformInterface;
                interfaceFunction.propertyIndex = shape.cix;
                interfaceFunction._name = shape.nm;
                return interfaceFunction;
              }
              function groupInterfaceFactory(shape, view, propertyGroup) {
                var interfaceFunction = function _interfaceFunction(value) {
                  switch (value) {
                    case 'ADBE Vectors Group':
                    case 'Contents':
                    case 2:
                      return interfaceFunction.content;
                    // Not necessary for now. Keeping them here in case a new case appears
                    // case 'ADBE Vector Transform Group':
                    // case 3:

                    default:
                      return interfaceFunction.transform;
                  }
                };
                interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
                var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
                interfaceFunction.content = content;
                interfaceFunction.transform = transformInterface;
                Object.defineProperty(interfaceFunction, '_name', {
                  get: function get() {
                    return shape.nm;
                  }
                }); // interfaceFunction.content = interfaceFunction;

                interfaceFunction.numProperties = shape.np;
                interfaceFunction.propertyIndex = shape.ix;
                interfaceFunction.nm = shape.nm;
                interfaceFunction.mn = shape.mn;
                return interfaceFunction;
              }
              function fillInterfaceFactory(shape, view, propertyGroup) {
                function interfaceFunction(val) {
                  if (val === 'Color' || val === 'color') {
                    return interfaceFunction.color;
                  }
                  if (val === 'Opacity' || val === 'opacity') {
                    return interfaceFunction.opacity;
                  }
                  return null;
                }
                Object.defineProperties(interfaceFunction, {
                  color: {
                    get: ExpressionPropertyInterface(view.c)
                  },
                  opacity: {
                    get: ExpressionPropertyInterface(view.o)
                  },
                  _name: {
                    value: shape.nm
                  },
                  mn: {
                    value: shape.mn
                  }
                });
                view.c.setGroupProperty(PropertyInterface('Color', propertyGroup));
                view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
                return interfaceFunction;
              }
              function gradientFillInterfaceFactory(shape, view, propertyGroup) {
                function interfaceFunction(val) {
                  if (val === 'Start Point' || val === 'start point') {
                    return interfaceFunction.startPoint;
                  }
                  if (val === 'End Point' || val === 'end point') {
                    return interfaceFunction.endPoint;
                  }
                  if (val === 'Opacity' || val === 'opacity') {
                    return interfaceFunction.opacity;
                  }
                  return null;
                }
                Object.defineProperties(interfaceFunction, {
                  startPoint: {
                    get: ExpressionPropertyInterface(view.s)
                  },
                  endPoint: {
                    get: ExpressionPropertyInterface(view.e)
                  },
                  opacity: {
                    get: ExpressionPropertyInterface(view.o)
                  },
                  type: {
                    get: function get() {
                      return 'a';
                    }
                  },
                  _name: {
                    value: shape.nm
                  },
                  mn: {
                    value: shape.mn
                  }
                });
                view.s.setGroupProperty(PropertyInterface('Start Point', propertyGroup));
                view.e.setGroupProperty(PropertyInterface('End Point', propertyGroup));
                view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
                return interfaceFunction;
              }
              function defaultInterfaceFactory() {
                function interfaceFunction() {
                  return null;
                }
                return interfaceFunction;
              }
              function strokeInterfaceFactory(shape, view, propertyGroup) {
                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
                function addPropertyToDashOb(i) {
                  Object.defineProperty(dashOb, shape.d[i].nm, {
                    get: ExpressionPropertyInterface(view.d.dataProps[i].p)
                  });
                }
                var i;
                var len = shape.d ? shape.d.length : 0;
                var dashOb = {};
                for (i = 0; i < len; i += 1) {
                  addPropertyToDashOb(i);
                  view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
                }
                function interfaceFunction(val) {
                  if (val === 'Color' || val === 'color') {
                    return interfaceFunction.color;
                  }
                  if (val === 'Opacity' || val === 'opacity') {
                    return interfaceFunction.opacity;
                  }
                  if (val === 'Stroke Width' || val === 'stroke width') {
                    return interfaceFunction.strokeWidth;
                  }
                  return null;
                }
                Object.defineProperties(interfaceFunction, {
                  color: {
                    get: ExpressionPropertyInterface(view.c)
                  },
                  opacity: {
                    get: ExpressionPropertyInterface(view.o)
                  },
                  strokeWidth: {
                    get: ExpressionPropertyInterface(view.w)
                  },
                  dash: {
                    get: function get() {
                      return dashOb;
                    }
                  },
                  _name: {
                    value: shape.nm
                  },
                  mn: {
                    value: shape.mn
                  }
                });
                view.c.setGroupProperty(PropertyInterface('Color', _propertyGroup));
                view.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
                view.w.setGroupProperty(PropertyInterface('Stroke Width', _propertyGroup));
                return interfaceFunction;
              }
              function trimInterfaceFactory(shape, view, propertyGroup) {
                function interfaceFunction(val) {
                  if (val === shape.e.ix || val === 'End' || val === 'end') {
                    return interfaceFunction.end;
                  }
                  if (val === shape.s.ix) {
                    return interfaceFunction.start;
                  }
                  if (val === shape.o.ix) {
                    return interfaceFunction.offset;
                  }
                  return null;
                }
                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                interfaceFunction.propertyIndex = shape.ix;
                view.s.setGroupProperty(PropertyInterface('Start', _propertyGroup));
                view.e.setGroupProperty(PropertyInterface('End', _propertyGroup));
                view.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
                interfaceFunction.propertyIndex = shape.ix;
                interfaceFunction.propertyGroup = propertyGroup;
                Object.defineProperties(interfaceFunction, {
                  start: {
                    get: ExpressionPropertyInterface(view.s)
                  },
                  end: {
                    get: ExpressionPropertyInterface(view.e)
                  },
                  offset: {
                    get: ExpressionPropertyInterface(view.o)
                  },
                  _name: {
                    value: shape.nm
                  }
                });
                interfaceFunction.mn = shape.mn;
                return interfaceFunction;
              }
              function transformInterfaceFactory(shape, view, propertyGroup) {
                function interfaceFunction(value) {
                  if (shape.a.ix === value || value === 'Anchor Point') {
                    return interfaceFunction.anchorPoint;
                  }
                  if (shape.o.ix === value || value === 'Opacity') {
                    return interfaceFunction.opacity;
                  }
                  if (shape.p.ix === value || value === 'Position') {
                    return interfaceFunction.position;
                  }
                  if (shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation') {
                    return interfaceFunction.rotation;
                  }
                  if (shape.s.ix === value || value === 'Scale') {
                    return interfaceFunction.scale;
                  }
                  if (shape.sk && shape.sk.ix === value || value === 'Skew') {
                    return interfaceFunction.skew;
                  }
                  if (shape.sa && shape.sa.ix === value || value === 'Skew Axis') {
                    return interfaceFunction.skewAxis;
                  }
                  return null;
                }
                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
                view.transform.mProps.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
                view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', _propertyGroup));
                view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', _propertyGroup));
                view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
                if (view.transform.mProps.sk) {
                  view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', _propertyGroup));
                  view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', _propertyGroup));
                }
                view.transform.op.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
                Object.defineProperties(interfaceFunction, {
                  opacity: {
                    get: ExpressionPropertyInterface(view.transform.mProps.o)
                  },
                  position: {
                    get: ExpressionPropertyInterface(view.transform.mProps.p)
                  },
                  anchorPoint: {
                    get: ExpressionPropertyInterface(view.transform.mProps.a)
                  },
                  scale: {
                    get: ExpressionPropertyInterface(view.transform.mProps.s)
                  },
                  rotation: {
                    get: ExpressionPropertyInterface(view.transform.mProps.r)
                  },
                  skew: {
                    get: ExpressionPropertyInterface(view.transform.mProps.sk)
                  },
                  skewAxis: {
                    get: ExpressionPropertyInterface(view.transform.mProps.sa)
                  },
                  _name: {
                    value: shape.nm
                  }
                });
                interfaceFunction.ty = 'tr';
                interfaceFunction.mn = shape.mn;
                interfaceFunction.propertyGroup = propertyGroup;
                return interfaceFunction;
              }
              function ellipseInterfaceFactory(shape, view, propertyGroup) {
                function interfaceFunction(value) {
                  if (shape.p.ix === value) {
                    return interfaceFunction.position;
                  }
                  if (shape.s.ix === value) {
                    return interfaceFunction.size;
                  }
                  return null;
                }
                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                interfaceFunction.propertyIndex = shape.ix;
                var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
                prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
                prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
                Object.defineProperties(interfaceFunction, {
                  size: {
                    get: ExpressionPropertyInterface(prop.s)
                  },
                  position: {
                    get: ExpressionPropertyInterface(prop.p)
                  },
                  _name: {
                    value: shape.nm
                  }
                });
                interfaceFunction.mn = shape.mn;
                return interfaceFunction;
              }
              function starInterfaceFactory(shape, view, propertyGroup) {
                function interfaceFunction(value) {
                  if (shape.p.ix === value) {
                    return interfaceFunction.position;
                  }
                  if (shape.r.ix === value) {
                    return interfaceFunction.rotation;
                  }
                  if (shape.pt.ix === value) {
                    return interfaceFunction.points;
                  }
                  if (shape.or.ix === value || value === 'ADBE Vector Star Outer Radius') {
                    return interfaceFunction.outerRadius;
                  }
                  if (shape.os.ix === value) {
                    return interfaceFunction.outerRoundness;
                  }
                  if (shape.ir && (shape.ir.ix === value || value === 'ADBE Vector Star Inner Radius')) {
                    return interfaceFunction.innerRadius;
                  }
                  if (shape.is && shape.is.ix === value) {
                    return interfaceFunction.innerRoundness;
                  }
                  return null;
                }
                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
                interfaceFunction.propertyIndex = shape.ix;
                prop.or.setGroupProperty(PropertyInterface('Outer Radius', _propertyGroup));
                prop.os.setGroupProperty(PropertyInterface('Outer Roundness', _propertyGroup));
                prop.pt.setGroupProperty(PropertyInterface('Points', _propertyGroup));
                prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
                prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
                if (shape.ir) {
                  prop.ir.setGroupProperty(PropertyInterface('Inner Radius', _propertyGroup));
                  prop.is.setGroupProperty(PropertyInterface('Inner Roundness', _propertyGroup));
                }
                Object.defineProperties(interfaceFunction, {
                  position: {
                    get: ExpressionPropertyInterface(prop.p)
                  },
                  rotation: {
                    get: ExpressionPropertyInterface(prop.r)
                  },
                  points: {
                    get: ExpressionPropertyInterface(prop.pt)
                  },
                  outerRadius: {
                    get: ExpressionPropertyInterface(prop.or)
                  },
                  outerRoundness: {
                    get: ExpressionPropertyInterface(prop.os)
                  },
                  innerRadius: {
                    get: ExpressionPropertyInterface(prop.ir)
                  },
                  innerRoundness: {
                    get: ExpressionPropertyInterface(prop.is)
                  },
                  _name: {
                    value: shape.nm
                  }
                });
                interfaceFunction.mn = shape.mn;
                return interfaceFunction;
              }
              function rectInterfaceFactory(shape, view, propertyGroup) {
                function interfaceFunction(value) {
                  if (shape.p.ix === value) {
                    return interfaceFunction.position;
                  }
                  if (shape.r.ix === value) {
                    return interfaceFunction.roundness;
                  }
                  if (shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size') {
                    return interfaceFunction.size;
                  }
                  return null;
                }
                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
                interfaceFunction.propertyIndex = shape.ix;
                prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
                prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
                prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
                Object.defineProperties(interfaceFunction, {
                  position: {
                    get: ExpressionPropertyInterface(prop.p)
                  },
                  roundness: {
                    get: ExpressionPropertyInterface(prop.r)
                  },
                  size: {
                    get: ExpressionPropertyInterface(prop.s)
                  },
                  _name: {
                    value: shape.nm
                  }
                });
                interfaceFunction.mn = shape.mn;
                return interfaceFunction;
              }
              function roundedInterfaceFactory(shape, view, propertyGroup) {
                function interfaceFunction(value) {
                  if (shape.r.ix === value || value === 'Round Corners 1') {
                    return interfaceFunction.radius;
                  }
                  return null;
                }
                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                var prop = view;
                interfaceFunction.propertyIndex = shape.ix;
                prop.rd.setGroupProperty(PropertyInterface('Radius', _propertyGroup));
                Object.defineProperties(interfaceFunction, {
                  radius: {
                    get: ExpressionPropertyInterface(prop.rd)
                  },
                  _name: {
                    value: shape.nm
                  }
                });
                interfaceFunction.mn = shape.mn;
                return interfaceFunction;
              }
              function repeaterInterfaceFactory(shape, view, propertyGroup) {
                function interfaceFunction(value) {
                  if (shape.c.ix === value || value === 'Copies') {
                    return interfaceFunction.copies;
                  }
                  if (shape.o.ix === value || value === 'Offset') {
                    return interfaceFunction.offset;
                  }
                  return null;
                }
                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                var prop = view;
                interfaceFunction.propertyIndex = shape.ix;
                prop.c.setGroupProperty(PropertyInterface('Copies', _propertyGroup));
                prop.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
                Object.defineProperties(interfaceFunction, {
                  copies: {
                    get: ExpressionPropertyInterface(prop.c)
                  },
                  offset: {
                    get: ExpressionPropertyInterface(prop.o)
                  },
                  _name: {
                    value: shape.nm
                  }
                });
                interfaceFunction.mn = shape.mn;
                return interfaceFunction;
              }
              return function (shapes, view, propertyGroup) {
                var interfaces;
                function _interfaceFunction(value) {
                  if (typeof value === 'number') {
                    value = value === undefined ? 1 : value;
                    if (value === 0) {
                      return propertyGroup;
                    }
                    return interfaces[value - 1];
                  }
                  var i = 0;
                  var len = interfaces.length;
                  while (i < len) {
                    if (interfaces[i]._name === value) {
                      return interfaces[i];
                    }
                    i += 1;
                  }
                  return null;
                }
                function parentGroupWrapper() {
                  return propertyGroup;
                }
                _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
                interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
                _interfaceFunction.numProperties = interfaces.length;
                _interfaceFunction._name = 'Contents';
                return _interfaceFunction;
              };
            }();
            var TextExpressionInterface = function () {
              return function (elem) {
                var _sourceText;
                function _thisLayerFunction(name) {
                  switch (name) {
                    case 'ADBE Text Document':
                      return _thisLayerFunction.sourceText;
                    default:
                      return null;
                  }
                }
                Object.defineProperty(_thisLayerFunction, 'sourceText', {
                  get: function get() {
                    elem.textProperty.getValue();
                    var stringValue = elem.textProperty.currentData.t;
                    if (!_sourceText || stringValue !== _sourceText.value) {
                      _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers
                      // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive

                      _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers

                      Object.defineProperty(_sourceText, 'style', {
                        get: function get() {
                          return {
                            fillColor: elem.textProperty.currentData.fc
                          };
                        }
                      });
                    }
                    return _sourceText;
                  }
                });
                return _thisLayerFunction;
              };
            }();
            function _typeof(obj) {
              "@babel/helpers - typeof";

              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof(obj) {
                  return typeof obj;
                };
              } else {
                _typeof = function _typeof(obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
              }
              return _typeof(obj);
            }
            var FootageInterface = function () {
              var outlineInterfaceFactory = function outlineInterfaceFactory(elem) {
                var currentPropertyName = '';
                var currentProperty = elem.getFootageData();
                function init() {
                  currentPropertyName = '';
                  currentProperty = elem.getFootageData();
                  return searchProperty;
                }
                function searchProperty(value) {
                  if (currentProperty[value]) {
                    currentPropertyName = value;
                    currentProperty = currentProperty[value];
                    if (_typeof(currentProperty) === 'object') {
                      return searchProperty;
                    }
                    return currentProperty;
                  }
                  var propertyNameIndex = value.indexOf(currentPropertyName);
                  if (propertyNameIndex !== -1) {
                    var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);
                    currentProperty = currentProperty[index];
                    if (_typeof(currentProperty) === 'object') {
                      return searchProperty;
                    }
                    return currentProperty;
                  }
                  return '';
                }
                return init;
              };
              var dataInterfaceFactory = function dataInterfaceFactory(elem) {
                function interfaceFunction(value) {
                  if (value === 'Outline') {
                    return interfaceFunction.outlineInterface();
                  }
                  return null;
                }
                interfaceFunction._name = 'Outline';
                interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);
                return interfaceFunction;
              };
              return function (elem) {
                function _interfaceFunction(value) {
                  if (value === 'Data') {
                    return _interfaceFunction.dataInterface;
                  }
                  return null;
                }
                _interfaceFunction._name = 'Data';
                _interfaceFunction.dataInterface = dataInterfaceFactory(elem);
                return _interfaceFunction;
              };
            }();
            var interfaces = {
              layer: LayerExpressionInterface,
              effects: EffectsExpressionInterface,
              comp: CompExpressionInterface,
              shape: ShapeExpressionInterface,
              text: TextExpressionInterface,
              footage: FootageInterface
            };
            function getInterface(type) {
              return interfaces[type] || null;
            }
            var expressionHelpers = function () {
              function searchExpressions(elem, data, prop) {
                if (data.x) {
                  prop.k = true;
                  prop.x = true;
                  prop.initiateExpression = ExpressionManager.initiateExpression;
                  prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));
                }
              }
              function getValueAtTime(frameNum) {
                frameNum *= this.elem.globalData.frameRate;
                frameNum -= this.offsetTime;
                if (frameNum !== this._cachingAtTime.lastFrame) {
                  this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
                  this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
                  this._cachingAtTime.lastFrame = frameNum;
                }
                return this._cachingAtTime.value;
              }
              function getSpeedAtTime(frameNum) {
                var delta = -0.01;
                var v1 = this.getValueAtTime(frameNum);
                var v2 = this.getValueAtTime(frameNum + delta);
                var speed = 0;
                if (v1.length) {
                  var i;
                  for (i = 0; i < v1.length; i += 1) {
                    speed += Math.pow(v2[i] - v1[i], 2);
                  }
                  speed = Math.sqrt(speed) * 100;
                } else {
                  speed = 0;
                }
                return speed;
              }
              function getVelocityAtTime(frameNum) {
                if (this.vel !== undefined) {
                  return this.vel;
                }
                var delta = -0.001; // frameNum += this.elem.data.st;

                var v1 = this.getValueAtTime(frameNum);
                var v2 = this.getValueAtTime(frameNum + delta);
                var velocity;
                if (v1.length) {
                  velocity = createTypedArray('float32', v1.length);
                  var i;
                  for (i = 0; i < v1.length; i += 1) {
                    // removing frameRate
                    // if needed, don't add it here
                    // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
                    velocity[i] = (v2[i] - v1[i]) / delta;
                  }
                } else {
                  velocity = (v2 - v1) / delta;
                }
                return velocity;
              }
              function getStaticValueAtTime() {
                return this.pv;
              }
              function setGroupProperty(propertyGroup) {
                this.propertyGroup = propertyGroup;
              }
              return {
                searchExpressions: searchExpressions,
                getSpeedAtTime: getSpeedAtTime,
                getVelocityAtTime: getVelocityAtTime,
                getValueAtTime: getValueAtTime,
                getStaticValueAtTime: getStaticValueAtTime,
                setGroupProperty: setGroupProperty
              };
            }();
            function addPropertyDecorator() {
              function loopOut(type, duration, durationFlag) {
                if (!this.k || !this.keyframes) {
                  return this.pv;
                }
                type = type ? type.toLowerCase() : '';
                var currentFrame = this.comp.renderedFrame;
                var keyframes = this.keyframes;
                var lastKeyFrame = keyframes[keyframes.length - 1].t;
                if (currentFrame <= lastKeyFrame) {
                  return this.pv;
                }
                var cycleDuration;
                var firstKeyFrame;
                if (!durationFlag) {
                  if (!duration || duration > keyframes.length - 1) {
                    duration = keyframes.length - 1;
                  }
                  firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
                  cycleDuration = lastKeyFrame - firstKeyFrame;
                } else {
                  if (!duration) {
                    cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
                  } else {
                    cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
                  }
                  firstKeyFrame = lastKeyFrame - cycleDuration;
                }
                var i;
                var len;
                var ret;
                if (type === 'pingpong') {
                  var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
                  if (iterations % 2 !== 0) {
                    return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
                  }
                } else if (type === 'offset') {
                  var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
                  var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
                  var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line

                  var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
                  if (this.pv.length) {
                    ret = new Array(initV.length);
                    len = ret.length;
                    for (i = 0; i < len; i += 1) {
                      ret[i] = (endV[i] - initV[i]) * repeats + current[i];
                    }
                    return ret;
                  }
                  return (endV - initV) * repeats + current;
                } else if (type === 'continue') {
                  var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
                  var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);
                  if (this.pv.length) {
                    ret = new Array(lastValue.length);
                    len = ret.length;
                    for (i = 0; i < len; i += 1) {
                      ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005; // eslint-disable-line
                    }
                    return ret;
                  }
                  return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 0.001);
                }
                return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
              }
              function loopIn(type, duration, durationFlag) {
                if (!this.k) {
                  return this.pv;
                }
                type = type ? type.toLowerCase() : '';
                var currentFrame = this.comp.renderedFrame;
                var keyframes = this.keyframes;
                var firstKeyFrame = keyframes[0].t;
                if (currentFrame >= firstKeyFrame) {
                  return this.pv;
                }
                var cycleDuration;
                var lastKeyFrame;
                if (!durationFlag) {
                  if (!duration || duration > keyframes.length - 1) {
                    duration = keyframes.length - 1;
                  }
                  lastKeyFrame = keyframes[duration].t;
                  cycleDuration = lastKeyFrame - firstKeyFrame;
                } else {
                  if (!duration) {
                    cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
                  } else {
                    cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
                  }
                  lastKeyFrame = firstKeyFrame + cycleDuration;
                }
                var i;
                var len;
                var ret;
                if (type === 'pingpong') {
                  var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
                  if (iterations % 2 === 0) {
                    return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
                  }
                } else if (type === 'offset') {
                  var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
                  var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
                  var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
                  var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
                  if (this.pv.length) {
                    ret = new Array(initV.length);
                    len = ret.length;
                    for (i = 0; i < len; i += 1) {
                      ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
                    }
                    return ret;
                  }
                  return current - (endV - initV) * repeats;
                } else if (type === 'continue') {
                  var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
                  var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);
                  if (this.pv.length) {
                    ret = new Array(firstValue.length);
                    len = ret.length;
                    for (i = 0; i < len; i += 1) {
                      ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / 0.001;
                    }
                    return ret;
                  }
                  return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 0.001;
                }
                return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line
              }
              function smooth(width, samples) {
                if (!this.k) {
                  return this.pv;
                }
                width = (width || 0.4) * 0.5;
                samples = Math.floor(samples || 5);
                if (samples <= 1) {
                  return this.pv;
                }
                var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
                var initFrame = currentTime - width;
                var endFrame = currentTime + width;
                var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
                var i = 0;
                var j = 0;
                var value;
                if (this.pv.length) {
                  value = createTypedArray('float32', this.pv.length);
                } else {
                  value = 0;
                }
                var sampleValue;
                while (i < samples) {
                  sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);
                  if (this.pv.length) {
                    for (j = 0; j < this.pv.length; j += 1) {
                      value[j] += sampleValue[j];
                    }
                  } else {
                    value += sampleValue;
                  }
                  i += 1;
                }
                if (this.pv.length) {
                  for (j = 0; j < this.pv.length; j += 1) {
                    value[j] /= samples;
                  }
                } else {
                  value /= samples;
                }
                return value;
              }
              function getTransformValueAtTime(time) {
                if (!this._transformCachingAtTime) {
                  this._transformCachingAtTime = {
                    v: new Matrix()
                  };
                } /// /

                var matrix = this._transformCachingAtTime.v;
                matrix.cloneFromProps(this.pre.props);
                if (this.appliedTransformations < 1) {
                  var anchor = this.a.getValueAtTime(time);
                  matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);
                }
                if (this.appliedTransformations < 2) {
                  var scale = this.s.getValueAtTime(time);
                  matrix.scale(scale[0] * this.s.mult, scale[1] * this.s.mult, scale[2] * this.s.mult);
                }
                if (this.sk && this.appliedTransformations < 3) {
                  var skew = this.sk.getValueAtTime(time);
                  var skewAxis = this.sa.getValueAtTime(time);
                  matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
                }
                if (this.r && this.appliedTransformations < 4) {
                  var rotation = this.r.getValueAtTime(time);
                  matrix.rotate(-rotation * this.r.mult);
                } else if (!this.r && this.appliedTransformations < 4) {
                  var rotationZ = this.rz.getValueAtTime(time);
                  var rotationY = this.ry.getValueAtTime(time);
                  var rotationX = this.rx.getValueAtTime(time);
                  var orientation = this.or.getValueAtTime(time);
                  matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);
                }
                if (this.data.p && this.data.p.s) {
                  var positionX = this.px.getValueAtTime(time);
                  var positionY = this.py.getValueAtTime(time);
                  if (this.data.p.z) {
                    var positionZ = this.pz.getValueAtTime(time);
                    matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);
                  } else {
                    matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
                  }
                } else {
                  var position = this.p.getValueAtTime(time);
                  matrix.translate(position[0] * this.p.mult, position[1] * this.p.mult, -position[2] * this.p.mult);
                }
                return matrix; /// /
              }
              function getTransformStaticValueAtTime() {
                return this.v.clone(new Matrix());
              }
              var getTransformProperty = TransformPropertyFactory.getTransformProperty;
              TransformPropertyFactory.getTransformProperty = function (elem, data, container) {
                var prop = getTransformProperty(elem, data, container);
                if (prop.dynamicProperties.length) {
                  prop.getValueAtTime = getTransformValueAtTime.bind(prop);
                } else {
                  prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
                }
                prop.setGroupProperty = expressionHelpers.setGroupProperty;
                return prop;
              };
              var propertyGetProp = PropertyFactory.getProp;
              PropertyFactory.getProp = function (elem, data, type, mult, container) {
                var prop = propertyGetProp(elem, data, type, mult, container); // prop.getVelocityAtTime = getVelocityAtTime;
                // prop.loopOut = loopOut;
                // prop.loopIn = loopIn;

                if (prop.kf) {
                  prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
                } else {
                  prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
                }
                prop.setGroupProperty = expressionHelpers.setGroupProperty;
                prop.loopOut = loopOut;
                prop.loopIn = loopIn;
                prop.smooth = smooth;
                prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
                prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
                prop.numKeys = data.a === 1 ? data.k.length : 0;
                prop.propertyIndex = data.ix;
                var value = 0;
                if (type !== 0) {
                  value = createTypedArray('float32', data.a === 1 ? data.k[0].s.length : data.k.length);
                }
                prop._cachingAtTime = {
                  lastFrame: initialDefaultFrame,
                  lastIndex: 0,
                  value: value
                };
                expressionHelpers.searchExpressions(elem, data, prop);
                if (prop.k) {
                  container.addDynamicProperty(prop);
                }
                return prop;
              };
              function getShapeValueAtTime(frameNum) {
                // For now this caching object is created only when needed instead of creating it when the shape is initialized.
                if (!this._cachingAtTime) {
                  this._cachingAtTime = {
                    shapeValue: shapePool.clone(this.pv),
                    lastIndex: 0,
                    lastTime: initialDefaultFrame
                  };
                }
                frameNum *= this.elem.globalData.frameRate;
                frameNum -= this.offsetTime;
                if (frameNum !== this._cachingAtTime.lastTime) {
                  this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
                  this._cachingAtTime.lastTime = frameNum;
                  this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
                }
                return this._cachingAtTime.shapeValue;
              }
              var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
              var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();
              function ShapeExpressions() {}
              ShapeExpressions.prototype = {
                vertices: function vertices(prop, time) {
                  if (this.k) {
                    this.getValue();
                  }
                  var shapePath = this.v;
                  if (time !== undefined) {
                    shapePath = this.getValueAtTime(time, 0);
                  }
                  var i;
                  var len = shapePath._length;
                  var vertices = shapePath[prop];
                  var points = shapePath.v;
                  var arr = createSizedArray(len);
                  for (i = 0; i < len; i += 1) {
                    if (prop === 'i' || prop === 'o') {
                      arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];
                    } else {
                      arr[i] = [vertices[i][0], vertices[i][1]];
                    }
                  }
                  return arr;
                },
                points: function points(time) {
                  return this.vertices('v', time);
                },
                inTangents: function inTangents(time) {
                  return this.vertices('i', time);
                },
                outTangents: function outTangents(time) {
                  return this.vertices('o', time);
                },
                isClosed: function isClosed() {
                  return this.v.c;
                },
                pointOnPath: function pointOnPath(perc, time) {
                  var shapePath = this.v;
                  if (time !== undefined) {
                    shapePath = this.getValueAtTime(time, 0);
                  }
                  if (!this._segmentsLength) {
                    this._segmentsLength = bez.getSegmentsLength(shapePath);
                  }
                  var segmentsLength = this._segmentsLength;
                  var lengths = segmentsLength.lengths;
                  var lengthPos = segmentsLength.totalLength * perc;
                  var i = 0;
                  var len = lengths.length;
                  var accumulatedLength = 0;
                  var pt;
                  while (i < len) {
                    if (accumulatedLength + lengths[i].addedLength > lengthPos) {
                      var initIndex = i;
                      var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;
                      var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
                      pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
                      break;
                    } else {
                      accumulatedLength += lengths[i].addedLength;
                    }
                    i += 1;
                  }
                  if (!pt) {
                    pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
                  }
                  return pt;
                },
                vectorOnPath: function vectorOnPath(perc, time, vectorType) {
                  // perc doesn't use triple equality because it can be a Number object as well as a primitive.
                  if (perc == 1) {
                    // eslint-disable-line eqeqeq
                    perc = this.v.c;
                  } else if (perc == 0) {
                    // eslint-disable-line eqeqeq
                    perc = 0.999;
                  }
                  var pt1 = this.pointOnPath(perc, time);
                  var pt2 = this.pointOnPath(perc + 0.001, time);
                  var xLength = pt2[0] - pt1[0];
                  var yLength = pt2[1] - pt1[1];
                  var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
                  if (magnitude === 0) {
                    return [0, 0];
                  }
                  var unitVector = vectorType === 'tangent' ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
                  return unitVector;
                },
                tangentOnPath: function tangentOnPath(perc, time) {
                  return this.vectorOnPath(perc, time, 'tangent');
                },
                normalOnPath: function normalOnPath(perc, time) {
                  return this.vectorOnPath(perc, time, 'normal');
                },
                setGroupProperty: expressionHelpers.setGroupProperty,
                getValueAtTime: expressionHelpers.getStaticValueAtTime
              };
              extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
              extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
              KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
              KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
              var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
              ShapePropertyFactory.getShapeProp = function (elem, data, type, arr, trims) {
                var prop = propertyGetShapeProp(elem, data, type, arr, trims);
                prop.propertyIndex = data.ix;
                prop.lock = false;
                if (type === 3) {
                  expressionHelpers.searchExpressions(elem, data.pt, prop);
                } else if (type === 4) {
                  expressionHelpers.searchExpressions(elem, data.ks, prop);
                }
                if (prop.k) {
                  elem.addDynamicProperty(prop);
                }
                return prop;
              };
            }
            function initialize$1() {
              addPropertyDecorator();
            }
            function addDecorator() {
              function searchExpressions() {
                if (this.data.d.x) {
                  this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
                  this.addEffect(this.getExpressionValue.bind(this));
                  return true;
                }
                return null;
              }
              TextProperty.prototype.getExpressionValue = function (currentValue, text) {
                var newValue = this.calculateExpression(text);
                if (currentValue.t !== newValue) {
                  var newData = {};
                  this.copyData(newData, currentValue);
                  newData.t = newValue.toString();
                  newData.__complete = false;
                  return newData;
                }
                return currentValue;
              };
              TextProperty.prototype.searchProperty = function () {
                var isKeyframed = this.searchKeyframes();
                var hasExpressions = this.searchExpressions();
                this.kf = isKeyframed || hasExpressions;
                return this.kf;
              };
              TextProperty.prototype.searchExpressions = searchExpressions;
            }
            function initialize() {
              addDecorator();
            }
            function SVGComposableEffect() {}
            SVGComposableEffect.prototype = {
              createMergeNode: function createMergeNode(resultId, ins) {
                var feMerge = createNS('feMerge');
                feMerge.setAttribute('result', resultId);
                var feMergeNode;
                var i;
                for (i = 0; i < ins.length; i += 1) {
                  feMergeNode = createNS('feMergeNode');
                  feMergeNode.setAttribute('in', ins[i]);
                  feMerge.appendChild(feMergeNode);
                  feMerge.appendChild(feMergeNode);
                }
                return feMerge;
              }
            };
            var linearFilterValue = '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0';
            function SVGTintFilter(filter, filterManager, elem, id, source) {
              this.filterManager = filterManager;
              var feColorMatrix = createNS('feColorMatrix');
              feColorMatrix.setAttribute('type', 'matrix');
              feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
              feColorMatrix.setAttribute('values', linearFilterValue + ' 1 0');
              this.linearFilter = feColorMatrix;
              feColorMatrix.setAttribute('result', id + '_tint_1');
              filter.appendChild(feColorMatrix);
              feColorMatrix = createNS('feColorMatrix');
              feColorMatrix.setAttribute('type', 'matrix');
              feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
              feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
              feColorMatrix.setAttribute('result', id + '_tint_2');
              filter.appendChild(feColorMatrix);
              this.matrixFilter = feColorMatrix;
              var feMerge = this.createMergeNode(id, [source, id + '_tint_1', id + '_tint_2']);
              filter.appendChild(feMerge);
            }
            extendPrototype([SVGComposableEffect], SVGTintFilter);
            SVGTintFilter.prototype.renderFrame = function (forceRender) {
              if (forceRender || this.filterManager._mdf) {
                var colorBlack = this.filterManager.effectElements[0].p.v;
                var colorWhite = this.filterManager.effectElements[1].p.v;
                var opacity = this.filterManager.effectElements[2].p.v / 100;
                this.linearFilter.setAttribute('values', linearFilterValue + ' ' + opacity + ' 0');
                this.matrixFilter.setAttribute('values', colorWhite[0] - colorBlack[0] + ' 0 0 0 ' + colorBlack[0] + ' ' + (colorWhite[1] - colorBlack[1]) + ' 0 0 0 ' + colorBlack[1] + ' ' + (colorWhite[2] - colorBlack[2]) + ' 0 0 0 ' + colorBlack[2] + ' 0 0 0 1 0');
              }
            };
            function SVGFillFilter(filter, filterManager, elem, id) {
              this.filterManager = filterManager;
              var feColorMatrix = createNS('feColorMatrix');
              feColorMatrix.setAttribute('type', 'matrix');
              feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
              feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
              feColorMatrix.setAttribute('result', id);
              filter.appendChild(feColorMatrix);
              this.matrixFilter = feColorMatrix;
            }
            SVGFillFilter.prototype.renderFrame = function (forceRender) {
              if (forceRender || this.filterManager._mdf) {
                var color = this.filterManager.effectElements[2].p.v;
                var opacity = this.filterManager.effectElements[6].p.v;
                this.matrixFilter.setAttribute('values', '0 0 0 0 ' + color[0] + ' 0 0 0 0 ' + color[1] + ' 0 0 0 0 ' + color[2] + ' 0 0 0 ' + opacity + ' 0');
              }
            };
            function SVGStrokeEffect(fil, filterManager, elem) {
              this.initialized = false;
              this.filterManager = filterManager;
              this.elem = elem;
              this.paths = [];
            }
            SVGStrokeEffect.prototype.initialize = function () {
              var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
              var path;
              var groupPath;
              var i;
              var len;
              if (this.filterManager.effectElements[1].p.v === 1) {
                len = this.elem.maskManager.masksProperties.length;
                i = 0;
              } else {
                i = this.filterManager.effectElements[0].p.v - 1;
                len = i + 1;
              }
              groupPath = createNS('g');
              groupPath.setAttribute('fill', 'none');
              groupPath.setAttribute('stroke-linecap', 'round');
              groupPath.setAttribute('stroke-dashoffset', 1);
              for (i; i < len; i += 1) {
                path = createNS('path');
                groupPath.appendChild(path);
                this.paths.push({
                  p: path,
                  m: i
                });
              }
              if (this.filterManager.effectElements[10].p.v === 3) {
                var mask = createNS('mask');
                var id = createElementID();
                mask.setAttribute('id', id);
                mask.setAttribute('mask-type', 'alpha');
                mask.appendChild(groupPath);
                this.elem.globalData.defs.appendChild(mask);
                var g = createNS('g');
                g.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');
                while (elemChildren[0]) {
                  g.appendChild(elemChildren[0]);
                }
                this.elem.layerElement.appendChild(g);
                this.masker = mask;
                groupPath.setAttribute('stroke', '#fff');
              } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
                if (this.filterManager.effectElements[10].p.v === 2) {
                  elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
                  while (elemChildren.length) {
                    this.elem.layerElement.removeChild(elemChildren[0]);
                  }
                }
                this.elem.layerElement.appendChild(groupPath);
                this.elem.layerElement.removeAttribute('mask');
                groupPath.setAttribute('stroke', '#fff');
              }
              this.initialized = true;
              this.pathMasker = groupPath;
            };
            SVGStrokeEffect.prototype.renderFrame = function (forceRender) {
              if (!this.initialized) {
                this.initialize();
              }
              var i;
              var len = this.paths.length;
              var mask;
              var path;
              for (i = 0; i < len; i += 1) {
                if (this.paths[i].m !== -1) {
                  mask = this.elem.maskManager.viewData[this.paths[i].m];
                  path = this.paths[i].p;
                  if (forceRender || this.filterManager._mdf || mask.prop._mdf) {
                    path.setAttribute('d', mask.lastPath);
                  }
                  if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {
                    var dasharrayValue;
                    if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                      var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                      var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                      var l = path.getTotalLength();
                      dasharrayValue = '0 0 0 ' + l * s + ' ';
                      var lineLength = l * (e - s);
                      var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                      var units = Math.floor(lineLength / segment);
                      var j;
                      for (j = 0; j < units; j += 1) {
                        dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + ' ';
                      }
                      dasharrayValue += '0 ' + l * 10 + ' 0 0';
                    } else {
                      dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                    }
                    path.setAttribute('stroke-dasharray', dasharrayValue);
                  }
                }
              }
              if (forceRender || this.filterManager.effectElements[4].p._mdf) {
                this.pathMasker.setAttribute('stroke-width', this.filterManager.effectElements[4].p.v * 2);
              }
              if (forceRender || this.filterManager.effectElements[6].p._mdf) {
                this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v);
              }
              if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
                if (forceRender || this.filterManager.effectElements[3].p._mdf) {
                  var color = this.filterManager.effectElements[3].p.v;
                  this.pathMasker.setAttribute('stroke', 'rgb(' + bmFloor(color[0] * 255) + ',' + bmFloor(color[1] * 255) + ',' + bmFloor(color[2] * 255) + ')');
                }
              }
            };
            function SVGTritoneFilter(filter, filterManager, elem, id) {
              this.filterManager = filterManager;
              var feColorMatrix = createNS('feColorMatrix');
              feColorMatrix.setAttribute('type', 'matrix');
              feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
              feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
              filter.appendChild(feColorMatrix);
              var feComponentTransfer = createNS('feComponentTransfer');
              feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
              feComponentTransfer.setAttribute('result', id);
              this.matrixFilter = feComponentTransfer;
              var feFuncR = createNS('feFuncR');
              feFuncR.setAttribute('type', 'table');
              feComponentTransfer.appendChild(feFuncR);
              this.feFuncR = feFuncR;
              var feFuncG = createNS('feFuncG');
              feFuncG.setAttribute('type', 'table');
              feComponentTransfer.appendChild(feFuncG);
              this.feFuncG = feFuncG;
              var feFuncB = createNS('feFuncB');
              feFuncB.setAttribute('type', 'table');
              feComponentTransfer.appendChild(feFuncB);
              this.feFuncB = feFuncB;
              filter.appendChild(feComponentTransfer);
            }
            SVGTritoneFilter.prototype.renderFrame = function (forceRender) {
              if (forceRender || this.filterManager._mdf) {
                var color1 = this.filterManager.effectElements[0].p.v;
                var color2 = this.filterManager.effectElements[1].p.v;
                var color3 = this.filterManager.effectElements[2].p.v;
                var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];
                var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];
                var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];
                this.feFuncR.setAttribute('tableValues', tableR);
                this.feFuncG.setAttribute('tableValues', tableG);
                this.feFuncB.setAttribute('tableValues', tableB);
              }
            };
            function SVGProLevelsFilter(filter, filterManager, elem, id) {
              this.filterManager = filterManager;
              var effectElements = this.filterManager.effectElements;
              var feComponentTransfer = createNS('feComponentTransfer'); // Red

              if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
                this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);
              } // Green

              if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
                this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);
              } // Blue

              if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
                this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);
              } // Alpha

              if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
                this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);
              } // RGB

              if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
                feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
                filter.appendChild(feComponentTransfer);
              }
              if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
                feComponentTransfer = createNS('feComponentTransfer');
                feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
                feComponentTransfer.setAttribute('result', id);
                filter.appendChild(feComponentTransfer);
                this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);
                this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);
                this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);
              }
            }
            SVGProLevelsFilter.prototype.createFeFunc = function (type, feComponentTransfer) {
              var feFunc = createNS(type);
              feFunc.setAttribute('type', 'table');
              feComponentTransfer.appendChild(feFunc);
              return feFunc;
            };
            SVGProLevelsFilter.prototype.getTableValue = function (inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
              var cnt = 0;
              var segments = 256;
              var perc;
              var min = Math.min(inputBlack, inputWhite);
              var max = Math.max(inputBlack, inputWhite);
              var table = Array.call(null, {
                length: segments
              });
              var colorValue;
              var pos = 0;
              var outputDelta = outputWhite - outputBlack;
              var inputDelta = inputWhite - inputBlack;
              while (cnt <= 256) {
                perc = cnt / 256;
                if (perc <= min) {
                  colorValue = inputDelta < 0 ? outputWhite : outputBlack;
                } else if (perc >= max) {
                  colorValue = inputDelta < 0 ? outputBlack : outputWhite;
                } else {
                  colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
                }
                table[pos] = colorValue;
                pos += 1;
                cnt += 256 / (segments - 1);
              }
              return table.join(' ');
            };
            SVGProLevelsFilter.prototype.renderFrame = function (forceRender) {
              if (forceRender || this.filterManager._mdf) {
                var val;
                var effectElements = this.filterManager.effectElements;
                if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
                  val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
                  this.feFuncRComposed.setAttribute('tableValues', val);
                  this.feFuncGComposed.setAttribute('tableValues', val);
                  this.feFuncBComposed.setAttribute('tableValues', val);
                }
                if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
                  val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
                  this.feFuncR.setAttribute('tableValues', val);
                }
                if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
                  val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
                  this.feFuncG.setAttribute('tableValues', val);
                }
                if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
                  val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
                  this.feFuncB.setAttribute('tableValues', val);
                }
                if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
                  val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
                  this.feFuncA.setAttribute('tableValues', val);
                }
              }
            };
            function SVGDropShadowEffect(filter, filterManager, elem, id, source) {
              var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;
              var filterSize = filterManager.data.fs || globalFilterSize;
              filter.setAttribute('x', filterSize.x || globalFilterSize.x);
              filter.setAttribute('y', filterSize.y || globalFilterSize.y);
              filter.setAttribute('width', filterSize.width || globalFilterSize.width);
              filter.setAttribute('height', filterSize.height || globalFilterSize.height);
              this.filterManager = filterManager;
              var feGaussianBlur = createNS('feGaussianBlur');
              feGaussianBlur.setAttribute('in', 'SourceAlpha');
              feGaussianBlur.setAttribute('result', id + '_drop_shadow_1');
              feGaussianBlur.setAttribute('stdDeviation', '0');
              this.feGaussianBlur = feGaussianBlur;
              filter.appendChild(feGaussianBlur);
              var feOffset = createNS('feOffset');
              feOffset.setAttribute('dx', '25');
              feOffset.setAttribute('dy', '0');
              feOffset.setAttribute('in', id + '_drop_shadow_1');
              feOffset.setAttribute('result', id + '_drop_shadow_2');
              this.feOffset = feOffset;
              filter.appendChild(feOffset);
              var feFlood = createNS('feFlood');
              feFlood.setAttribute('flood-color', '#00ff00');
              feFlood.setAttribute('flood-opacity', '1');
              feFlood.setAttribute('result', id + '_drop_shadow_3');
              this.feFlood = feFlood;
              filter.appendChild(feFlood);
              var feComposite = createNS('feComposite');
              feComposite.setAttribute('in', id + '_drop_shadow_3');
              feComposite.setAttribute('in2', id + '_drop_shadow_2');
              feComposite.setAttribute('operator', 'in');
              feComposite.setAttribute('result', id + '_drop_shadow_4');
              filter.appendChild(feComposite);
              var feMerge = this.createMergeNode(id, [id + '_drop_shadow_4', source]);
              filter.appendChild(feMerge); //
            }
            extendPrototype([SVGComposableEffect], SVGDropShadowEffect);
            SVGDropShadowEffect.prototype.renderFrame = function (forceRender) {
              if (forceRender || this.filterManager._mdf) {
                if (forceRender || this.filterManager.effectElements[4].p._mdf) {
                  this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);
                }
                if (forceRender || this.filterManager.effectElements[0].p._mdf) {
                  var col = this.filterManager.effectElements[0].p.v;
                  this.feFlood.setAttribute('flood-color', rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
                }
                if (forceRender || this.filterManager.effectElements[1].p._mdf) {
                  this.feFlood.setAttribute('flood-opacity', this.filterManager.effectElements[1].p.v / 255);
                }
                if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                  var distance = this.filterManager.effectElements[3].p.v;
                  var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
                  var x = distance * Math.cos(angle);
                  var y = distance * Math.sin(angle);
                  this.feOffset.setAttribute('dx', x);
                  this.feOffset.setAttribute('dy', y);
                }
              }
            };
            var _svgMatteSymbols = [];
            function SVGMatte3Effect(filterElem, filterManager, elem) {
              this.initialized = false;
              this.filterManager = filterManager;
              this.filterElem = filterElem;
              this.elem = elem;
              elem.matteElement = createNS('g');
              elem.matteElement.appendChild(elem.layerElement);
              elem.matteElement.appendChild(elem.transformedElement);
              elem.baseElement = elem.matteElement;
            }
            SVGMatte3Effect.prototype.findSymbol = function (mask) {
              var i = 0;
              var len = _svgMatteSymbols.length;
              while (i < len) {
                if (_svgMatteSymbols[i] === mask) {
                  return _svgMatteSymbols[i];
                }
                i += 1;
              }
              return null;
            };
            SVGMatte3Effect.prototype.replaceInParent = function (mask, symbolId) {
              var parentNode = mask.layerElement.parentNode;
              if (!parentNode) {
                return;
              }
              var children = parentNode.children;
              var i = 0;
              var len = children.length;
              while (i < len) {
                if (children[i] === mask.layerElement) {
                  break;
                }
                i += 1;
              }
              var nextChild;
              if (i <= len - 2) {
                nextChild = children[i + 1];
              }
              var useElem = createNS('use');
              useElem.setAttribute('href', '#' + symbolId);
              if (nextChild) {
                parentNode.insertBefore(useElem, nextChild);
              } else {
                parentNode.appendChild(useElem);
              }
            };
            SVGMatte3Effect.prototype.setElementAsMask = function (elem, mask) {
              if (!this.findSymbol(mask)) {
                var symbolId = createElementID();
                var masker = createNS('mask');
                masker.setAttribute('id', mask.layerId);
                masker.setAttribute('mask-type', 'alpha');
                _svgMatteSymbols.push(mask);
                var defs = elem.globalData.defs;
                defs.appendChild(masker);
                var symbol = createNS('symbol');
                symbol.setAttribute('id', symbolId);
                this.replaceInParent(mask, symbolId);
                symbol.appendChild(mask.layerElement);
                defs.appendChild(symbol);
                var useElem = createNS('use');
                useElem.setAttribute('href', '#' + symbolId);
                masker.appendChild(useElem);
                mask.data.hd = false;
                mask.show();
              }
              elem.setMatte(mask.layerId);
            };
            SVGMatte3Effect.prototype.initialize = function () {
              var ind = this.filterManager.effectElements[0].p.v;
              var elements = this.elem.comp.elements;
              var i = 0;
              var len = elements.length;
              while (i < len) {
                if (elements[i] && elements[i].data.ind === ind) {
                  this.setElementAsMask(this.elem, elements[i]);
                }
                i += 1;
              }
              this.initialized = true;
            };
            SVGMatte3Effect.prototype.renderFrame = function () {
              if (!this.initialized) {
                this.initialize();
              }
            };
            function SVGGaussianBlurEffect(filter, filterManager, elem, id) {
              // Outset the filter region by 100% on all sides to accommodate blur expansion.
              filter.setAttribute('x', '-100%');
              filter.setAttribute('y', '-100%');
              filter.setAttribute('width', '300%');
              filter.setAttribute('height', '300%');
              this.filterManager = filterManager;
              var feGaussianBlur = createNS('feGaussianBlur');
              feGaussianBlur.setAttribute('result', id);
              filter.appendChild(feGaussianBlur);
              this.feGaussianBlur = feGaussianBlur;
            }
            SVGGaussianBlurEffect.prototype.renderFrame = function (forceRender) {
              if (forceRender || this.filterManager._mdf) {
                // Empirical value, matching AE's blur appearance.
                var kBlurrinessToSigma = 0.3;
                var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma; // Dimensions mapping:
                //
                //   1 -> horizontal & vertical
                //   2 -> horizontal only
                //   3 -> vertical only
                //

                var dimensions = this.filterManager.effectElements[1].p.v;
                var sigmaX = dimensions == 3 ? 0 : sigma; // eslint-disable-line eqeqeq

                var sigmaY = dimensions == 2 ? 0 : sigma; // eslint-disable-line eqeqeq

                this.feGaussianBlur.setAttribute('stdDeviation', sigmaX + ' ' + sigmaY); // Repeat edges mapping:
                //
                //   0 -> off -> duplicate
                //   1 -> on  -> wrap

                var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? 'wrap' : 'duplicate'; // eslint-disable-line eqeqeq

                this.feGaussianBlur.setAttribute('edgeMode', edgeMode);
              }
            };
            function TransformEffect() {}
            TransformEffect.prototype.init = function (effectsManager) {
              this.effectsManager = effectsManager;
              this.type = effectTypes.TRANSFORM_EFFECT;
              this.matrix = new Matrix();
              this.opacity = -1;
              this._mdf = false;
              this._opMdf = false;
            };
            TransformEffect.prototype.renderFrame = function (forceFrame) {
              this._opMdf = false;
              this._mdf = false;
              if (forceFrame || this.effectsManager._mdf) {
                var effectElements = this.effectsManager.effectElements;
                var anchor = effectElements[0].p.v;
                var position = effectElements[1].p.v;
                var isUniformScale = effectElements[2].p.v === 1;
                var scaleHeight = effectElements[3].p.v;
                var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;
                var skew = effectElements[5].p.v;
                var skewAxis = effectElements[6].p.v;
                var rotation = effectElements[7].p.v;
                this.matrix.reset();
                this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);
                this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);
                this.matrix.rotate(-rotation * degToRads);
                this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);
                this.matrix.translate(position[0], position[1], 0);
                this._mdf = true;
                if (this.opacity !== effectElements[8].p.v) {
                  this.opacity = effectElements[8].p.v;
                  this._opMdf = true;
                }
              }
            };
            function SVGTransformEffect(_, filterManager) {
              this.init(filterManager);
            }
            extendPrototype([TransformEffect], SVGTransformEffect);
            function CVTransformEffect(effectsManager) {
              this.init(effectsManager);
            }
            extendPrototype([TransformEffect], CVTransformEffect);
            registerRenderer('canvas', CanvasRenderer);
            registerRenderer('html', HybridRenderer);
            registerRenderer('svg', SVGRenderer); // Registering shape modifiers

            ShapeModifiers.registerModifier('tm', TrimModifier);
            ShapeModifiers.registerModifier('pb', PuckerAndBloatModifier);
            ShapeModifiers.registerModifier('rp', RepeaterModifier);
            ShapeModifiers.registerModifier('rd', RoundCornersModifier);
            ShapeModifiers.registerModifier('zz', ZigZagModifier);
            ShapeModifiers.registerModifier('op', OffsetPathModifier); // Registering expression plugin

            setExpressionsPlugin(Expressions);
            setExpressionInterfaces(getInterface);
            initialize$1();
            initialize(); // Registering svg effects

            registerEffect$1(20, SVGTintFilter, true);
            registerEffect$1(21, SVGFillFilter, true);
            registerEffect$1(22, SVGStrokeEffect, false);
            registerEffect$1(23, SVGTritoneFilter, true);
            registerEffect$1(24, SVGProLevelsFilter, true);
            registerEffect$1(25, SVGDropShadowEffect, true);
            registerEffect$1(28, SVGMatte3Effect, false);
            registerEffect$1(29, SVGGaussianBlurEffect, true);
            registerEffect$1(35, SVGTransformEffect, false);
            registerEffect(35, CVTransformEffect);
            return lottie;
          });
        })(lottie, lottie.exports);
        var lottieExports = lottie.exports;
        Object.defineProperty(dist, "__esModule", {
          value: true
        });
        var _extends2 = _extends;
        var _extends3 = _interopRequireDefault$5(_extends2);
        var _getPrototypeOf = getPrototypeOf$1;
        var _getPrototypeOf2 = _interopRequireDefault$5(_getPrototypeOf);
        var _classCallCheck2 = classCallCheck;
        var _classCallCheck3 = _interopRequireDefault$5(_classCallCheck2);
        var _createClass2 = createClass;
        var _createClass3 = _interopRequireDefault$5(_createClass2);
        var _possibleConstructorReturn2 = possibleConstructorReturn;
        var _possibleConstructorReturn3 = _interopRequireDefault$5(_possibleConstructorReturn2);
        var _inherits2 = inherits;
        var _inherits3 = _interopRequireDefault$5(_inherits2);
        var _react = reactExports;
        var _react2 = _interopRequireDefault$5(_react);
        var _propTypes = propTypesExports;
        var _propTypes2 = _interopRequireDefault$5(_propTypes);
        var _lottieWeb = lottieExports;
        var _lottieWeb2 = _interopRequireDefault$5(_lottieWeb);
        function _interopRequireDefault$5(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        var Lottie = function (_React$Component) {
          (0, _inherits3.default)(Lottie, _React$Component);
          function Lottie() {
            var _ref;
            var _temp, _this, _ret;
            (0, _classCallCheck3.default)(this, Lottie);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Lottie.__proto__ || (0, _getPrototypeOf2.default)(Lottie)).call.apply(_ref, [this].concat(args))), _this), _this.handleClickToPause = function () {
              // The pause() method is for handling pausing by passing a prop isPaused
              // This method is for handling the ability to pause by clicking on the animation
              if (_this.anim.isPaused) {
                _this.anim.play();
              } else {
                _this.anim.pause();
              }
            }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
          }
          (0, _createClass3.default)(Lottie, [{
            key: 'componentDidMount',
            value: function componentDidMount() {
              var _props = this.props,
                options = _props.options,
                eventListeners = _props.eventListeners;
              var loop = options.loop,
                autoplay = options.autoplay,
                animationData = options.animationData,
                rendererSettings = options.rendererSettings,
                segments = options.segments;
              this.options = {
                container: this.el,
                renderer: 'svg',
                loop: loop !== false,
                autoplay: autoplay !== false,
                segments: segments !== false,
                animationData: animationData,
                rendererSettings: rendererSettings
              };
              this.options = (0, _extends3.default)({}, this.options, options);
              this.anim = _lottieWeb2.default.loadAnimation(this.options);
              this.registerEvents(eventListeners);
            }
          }, {
            key: 'componentWillUpdate',
            value: function componentWillUpdate(nextProps /* , nextState */) {
              /* Recreate the animation handle if the data is changed */
              if (this.options.animationData !== nextProps.options.animationData) {
                this.deRegisterEvents(this.props.eventListeners);
                this.destroy();
                this.options = (0, _extends3.default)({}, this.options, nextProps.options);
                this.anim = _lottieWeb2.default.loadAnimation(this.options);
                this.registerEvents(nextProps.eventListeners);
              }
            }
          }, {
            key: 'componentDidUpdate',
            value: function componentDidUpdate() {
              if (this.props.isStopped) {
                this.stop();
              } else if (this.props.segments) {
                this.playSegments();
              } else {
                this.play();
              }
              this.pause();
              this.setSpeed();
              this.setDirection();
            }
          }, {
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
              this.deRegisterEvents(this.props.eventListeners);
              this.destroy();
              this.options.animationData = null;
              this.anim = null;
            }
          }, {
            key: 'setSpeed',
            value: function setSpeed() {
              this.anim.setSpeed(this.props.speed);
            }
          }, {
            key: 'setDirection',
            value: function setDirection() {
              this.anim.setDirection(this.props.direction);
            }
          }, {
            key: 'play',
            value: function play() {
              this.anim.play();
            }
          }, {
            key: 'playSegments',
            value: function playSegments() {
              this.anim.playSegments(this.props.segments);
            }
          }, {
            key: 'stop',
            value: function stop() {
              this.anim.stop();
            }
          }, {
            key: 'pause',
            value: function pause() {
              if (this.props.isPaused && !this.anim.isPaused) {
                this.anim.pause();
              } else if (!this.props.isPaused && this.anim.isPaused) {
                this.anim.pause();
              }
            }
          }, {
            key: 'destroy',
            value: function destroy() {
              this.anim.destroy();
            }
          }, {
            key: 'registerEvents',
            value: function registerEvents(eventListeners) {
              var _this2 = this;
              eventListeners.forEach(function (eventListener) {
                _this2.anim.addEventListener(eventListener.eventName, eventListener.callback);
              });
            }
          }, {
            key: 'deRegisterEvents',
            value: function deRegisterEvents(eventListeners) {
              var _this3 = this;
              eventListeners.forEach(function (eventListener) {
                _this3.anim.removeEventListener(eventListener.eventName, eventListener.callback);
              });
            }
          }, {
            key: 'render',
            value: function render() {
              var _this4 = this;
              var _props2 = this.props,
                width = _props2.width,
                height = _props2.height,
                ariaRole = _props2.ariaRole,
                ariaLabel = _props2.ariaLabel,
                isClickToPauseDisabled = _props2.isClickToPauseDisabled,
                title = _props2.title;
              var getSize = function getSize(initial) {
                var size = void 0;
                if (typeof initial === 'number') {
                  size = initial + 'px';
                } else {
                  size = initial || '100%';
                }
                return size;
              };
              var lottieStyles = (0, _extends3.default)({
                width: getSize(width),
                height: getSize(height),
                overflow: 'hidden',
                margin: '0 auto',
                outline: 'none'
              }, this.props.style);
              var onClickHandler = isClickToPauseDisabled ? function () {
                return null;
              } : this.handleClickToPause;
              return (
                // Bug with eslint rules https://github.com/airbnb/javascript/issues/1374
                // eslint-disable-next-line jsx-a11y/no-static-element-interactions
                _react2.default.createElement('div', {
                  ref: function ref(c) {
                    _this4.el = c;
                  },
                  style: lottieStyles,
                  onClick: onClickHandler,
                  title: title,
                  role: ariaRole,
                  'aria-label': ariaLabel,
                  tabIndex: '0'
                })
              );
            }
          }]);
          return Lottie;
        }(_react2.default.Component);
        var _default = dist.default = Lottie;
        Lottie.propTypes = {
          eventListeners: _propTypes2.default.arrayOf(_propTypes2.default.object),
          options: _propTypes2.default.object.isRequired,
          height: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
          width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
          isStopped: _propTypes2.default.bool,
          isPaused: _propTypes2.default.bool,
          speed: _propTypes2.default.number,
          segments: _propTypes2.default.arrayOf(_propTypes2.default.number),
          direction: _propTypes2.default.number,
          ariaRole: _propTypes2.default.string,
          ariaLabel: _propTypes2.default.string,
          isClickToPauseDisabled: _propTypes2.default.bool,
          title: _propTypes2.default.string,
          style: _propTypes2.default.string
        };
        Lottie.defaultProps = {
          eventListeners: [],
          isStopped: false,
          isPaused: false,
          speed: 1,
          ariaRole: 'button',
          ariaLabel: 'animation',
          isClickToPauseDisabled: false,
          title: ''
        };
        const loading = "_loading_c5al4_1";
        const loadingWrapper = "_loadingWrapper_c5al4_14";
        const styles$9 = {
          loading: loading,
          loadingWrapper: loadingWrapper
        };
        function LoadingIndicator() {
          const defaultOptions = {
            loop: true,
            autoplay: true,
            path: "/loadingLottie.json",
            rendererSettings: {
              preserveAspectRatio: "xMidYMid slice"
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles$9.loading,
            children: /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$9.loadingWrapper,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(_default, {
                options: defaultOptions
              })
            })
          });
        }
        function StatefulLoadingIndicator() {
          const isLoading = useSelector(state => {
            return state.editState.loading;
          });
          return isLoading ? /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}) : /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
        }
        const ROLES = exports("h", {
          SUPER_ADMIN: "super_admin",
          SURVEY_ADMIN: "survey_admin",
          SURVEYOR: "surveyor",
          ANALYST: "analyst"
        });
        const isSurveyAdmin = exports("i", () => {
          const roles = TokenService.getUser().roles;
          return roles.indexOf(ROLES.SUPER_ADMIN) != -1 || roles.indexOf(ROLES.SURVEY_ADMIN) != -1;
        });
        const isSuperAdmin = () => {
          const roles = TokenService.getUser().roles;
          return roles.indexOf(ROLES.SUPER_ADMIN) != -1;
        };
        const isAnalyst = user => {
          const roles = user.roles;
          return roles.indexOf(ROLES.SUPER_ADMIN) != -1 || roles.indexOf(ROLES.ANALYST) != -1 || roles.indexOf(ROLES.SURVEY_ADMIN) != -1;
        };
        var Groups = {};
        var _interopRequireDefault$4 = interopRequireDefaultExports;
        Object.defineProperty(Groups, "__esModule", {
          value: true
        });
        var default_1$4 = Groups.default = void 0;
        var _createSvgIcon$4 = _interopRequireDefault$4(requireCreateSvgIcon());
        var _jsxRuntime$4 = jsxRuntimeExports;
        default_1$4 = Groups.default = (0, _createSvgIcon$4.default)(/*#__PURE__*/(0, _jsxRuntime$4.jsx)("path", {
          d: "M12 12.75c1.63 0 3.07.39 4.24.9 1.08.48 1.76 1.56 1.76 2.73V18H6v-1.61c0-1.18.68-2.26 1.76-2.73 1.17-.52 2.61-.91 4.24-.91M4 13c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m1.13 1.1c-.37-.06-.74-.1-1.13-.1-.99 0-1.93.21-2.78.58C.48 14.9 0 15.62 0 16.43V18h4.5v-1.61c0-.83.23-1.61.63-2.29M20 13c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m4 3.43c0-.81-.48-1.53-1.22-1.85-.85-.37-1.79-.58-2.78-.58-.39 0-.76.04-1.13.1.4.68.63 1.46.63 2.29V18H24zM12 6c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3"
        }), 'Groups');
        const header = "_header_zp577_1";
        const imageContainer = "_imageContainer_zp577_13";
        const userInfo = "_userInfo_zp577_16";
        const textCenter = "_textCenter_zp577_20";
        const styles$8 = {
          header: header,
          imageContainer: imageContainer,
          userInfo: userInfo,
          textCenter: textCenter
        };
        const logo = "_logo_21mob_1";
        const styles$7 = {
          logo: logo
        };
        const Logo = () => {
          const nav = useNavigate();
          return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
            className: styles$7.logo,
            onClick: () => nav("/"),
            children: /* @__PURE__ */jsxRuntimeExports.jsx("img", {
              src: "/qlarr.png",
              style: {
                height: "40px"
              }
            })
          });
        };
        const LanguageSelector = () => {
          const _useTranslation = useTranslation(),
            i18n = _useTranslation.i18n;
          const handleChange = event => {
            CookiesService.setValue(event.target.value, "lang");
            i18n.changeLanguage(event.target.value);
            setDocumentLang(event.target.value);
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Select, {
            onChange: handleChange,
            value: i18n.language,
            IconComponent: KeyboardArrowDown,
            sx: {
              ".MuiOutlinedInput-input": {
                padding: "5.5px 15px",
                position: "relative",
                color: "#181735",
                fontSize: ".875rem",
                fontWeight: "600",
                "&::after": {
                  content: '""',
                  height: "30px",
                  borderRight: "2px solid #ececfd",
                  margin: "0px 15px"
                }
              },
              "& .MuiOutlinedInput-notchedOutline": {
                borderRadius: "10px",
                border: "1px solid #ececfd"
              },
              "& .MuiSvgIcon-root": {
                color: "#181735",
                right: "15px"
              }
            },
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
              value: "en",
              title: "English",
              children: "EN"
            }), /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
              value: "de",
              title: "Deutsch",
              children: "DE"
            }), /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
              value: "ar",
              title: "العربية",
              children: "AR"
            })]
          });
        };
        const Header = () => {
          const authService = useService("auth");
          const _useTranslation2 = useTranslation("manage"),
            t = _useTranslation2.t;
          const nav = useNavigate();
          const dispatch = useDispatch();
          const location = useLocation();
          const isRtl = getDirFromSession();
          const logout = () => {
            setAnchorEl(null);
            dispatch(setLoading(true));
            authService.logout().then(() => {
              nav(routes.login);
            }).catch(e => {
              nav(routes.login);
            }).finally(() => {
              dispatch(setLoading(false));
            });
          };
          const _React$useState = React.useState(null),
            _React$useState2 = _slicedToArray(_React$useState, 2),
            anchorEl = _React$useState2[0],
            setAnchorEl = _React$useState2[1];
          const open = Boolean(anchorEl);
          const showSurveyTitle = reactExports.useMemo(() => {
            return showTitle(location);
          }, [location]);
          const surveyName = useSelector(state => {
            var _state$editState;
            return showSurveyTitle ? ((_state$editState = state.editState) === null || _state$editState === void 0 || (_state$editState = _state$editState.survey) === null || _state$editState === void 0 ? void 0 : _state$editState.name) || "" : "";
          });
          const handleClick = event => {
            setAnchorEl(event.currentTarget);
          };
          const handleClose = () => {
            setAnchorEl(null);
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            className: styles$8.header,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Box, {
              className: styles$8.imageContainer,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Logo, {})
            }), showSurveyTitle && /* @__PURE__ */jsxRuntimeExports.jsx(Typography, {
              className: styles$8.textCenter,
              variant: "h3",
              children: surveyName
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              style: {
                left: isRtl == "rtl" && "3.5rem",
                right: isRtl == "ltr" && "3.5rem"
              },
              className: styles$8.userInfo,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(LanguageSelector, {}), TokenService.isAuthenticated() && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                  sx: {
                    display: "inline-flex",
                    alignItems: "center",
                    border: "1px solid #ececfd",
                    borderRadius: "10px",
                    cursor: "pointer",
                    padding: ".125rem 1rem",
                    backgroundColor: open ? "#e3f2fd" : "#fff"
                  },
                  onClick: handleClick,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(Person, {
                    sx: {
                      color: "#16205b",
                      width: 32,
                      height: 32
                    }
                  }), open ? /* @__PURE__ */jsxRuntimeExports.jsx(KeyboardArrowUp, {
                    sx: {
                      transition: "transform 0.3s ease",
                      color: "#181735",
                      width: 24,
                      height: 24
                    }
                  }) : /* @__PURE__ */jsxRuntimeExports.jsx(KeyboardArrowDown, {
                    sx: {
                      transition: "transform 0.3s ease",
                      color: "#181735",
                      width: 24,
                      height: 24
                    }
                  })]
                }), /* @__PURE__ */jsxRuntimeExports.jsxs(Menu, {
                  anchorEl,
                  id: "account-menu",
                  open,
                  onClick: handleClose,
                  onClose: handleClose,
                  PaperProps: {
                    elevation: 0,
                    sx: {
                      width: "200px",
                      overflow: "visible",
                      filter: "drop-shadow(0px 4px 6px rgba(0,0,0,0.1))",
                      mt: 1.5,
                      borderRadius: "5px",
                      backgroundColor: "#ffffff",
                      color: "#333333",
                      "& .MuiMenuItem-root": {
                        "&:hover": {
                          backgroundColor: "#f5f5f5"
                        },
                        "& .MuiListItemIcon-root": {
                          minWidth: "40px"
                        }
                      },
                      transition: "transform 0.2s ease"
                    }
                  },
                  transformOrigin: {
                    horizontal: "right",
                    vertical: "top"
                  },
                  anchorOrigin: {
                    horizontal: "right",
                    vertical: "bottom"
                  },
                  children: [/* @__PURE__ */jsxRuntimeExports.jsxs(MenuItem, {
                    onClick: event => {
                      event.preventDefault();
                      handleClose();
                      setTimeout(() => {
                        nav(routes.profile);
                      }, 0);
                    },
                    sx: {
                      display: "flex",
                      justifyContent: "space-between"
                    },
                    children: [t("profile.title"), /* @__PURE__ */jsxRuntimeExports.jsx(Person, {
                      sx: {
                        color: "#16205b",
                        width: 25,
                        height: 25
                      }
                    })]
                  }), /* @__PURE__ */jsxRuntimeExports.jsxs(MenuItem, {
                    disabled: !isSuperAdmin(),
                    onClick: () => {
                      handleClose();
                      nav(routes.manageUsers);
                    },
                    sx: {
                      display: "flex",
                      justifyContent: "space-between"
                    },
                    children: [t("profile.manage_users"), /* @__PURE__ */jsxRuntimeExports.jsx(default_1$4, {
                      sx: {
                        color: "#16205b",
                        width: 25,
                        height: 25
                      }
                    })]
                  }), /* @__PURE__ */jsxRuntimeExports.jsxs(MenuItem, {
                    onClick: () => {
                      handleClose();
                      logout();
                    },
                    sx: {
                      display: "flex",
                      justifyContent: "space-between"
                    },
                    children: [t("profile.logout"), /* @__PURE__ */jsxRuntimeExports.jsx(LogoutOutlined, {
                      sx: {
                        color: "#16205b",
                        width: 25,
                        height: 25
                      }
                    })]
                  })]
                })]
              })]
            })]
          });
        };
        const showTitle = location => {
          try {
            return Object.values(MANAGE_SURVEY_LANDING_PAGES).indexOf(location.pathname.split("/")[1]) > -1;
          } catch (e) {
            console.error(e);
            return false;
          }
        };
        function ErrorWrapper() {
          const dispatch = useDispatch();
          const error = useSelector(state => {
            return state.editState.error;
          });
          const setErrorSeen = () => {
            dispatch(onEditErrorSeen());
          };
          const handleRetry = () => {
            window.location.href = window.location.href;
          };
          return error && !error.seen && /* @__PURE__ */jsxRuntimeExports.jsx(ErrorLayout, {
            onRetry: handleRetry,
            setErrorSeen,
            error
          });
        }

        // ----------------------------------------------------------------------

        function shadows(mode) {
          const color = grey[500];
          const transparent1 = alpha(color, 0.2);
          const transparent2 = alpha(color, 0.14);
          const transparent3 = alpha(color, 0.12);
          return ['none', `0px 2px 1px -1px ${transparent1},0px 1px 1px 0px ${transparent2},0px 1px 3px 0px ${transparent3}`, `0px 3px 1px -2px ${transparent1},0px 2px 2px 0px ${transparent2},0px 1px 5px 0px ${transparent3}`, `0px 3px 3px -2px ${transparent1},0px 3px 4px 0px ${transparent2},0px 1px 8px 0px ${transparent3}`, `0px 2px 4px -1px ${transparent1},0px 4px 5px 0px ${transparent2},0px 1px 10px 0px ${transparent3}`, `0px 3px 5px -1px ${transparent1},0px 5px 8px 0px ${transparent2},0px 1px 14px 0px ${transparent3}`, `0px 3px 5px -1px ${transparent1},0px 6px 10px 0px ${transparent2},0px 1px 18px 0px ${transparent3}`, `0px 4px 5px -2px ${transparent1},0px 7px 10px 1px ${transparent2},0px 2px 16px 1px ${transparent3}`, `0px 5px 5px -3px ${transparent1},0px 8px 10px 1px ${transparent2},0px 3px 14px 2px ${transparent3}`, `0px 5px 6px -3px ${transparent1},0px 9px 12px 1px ${transparent2},0px 3px 16px 2px ${transparent3}`, `0px 6px 6px -3px ${transparent1},0px 10px 14px 1px ${transparent2},0px 4px 18px 3px ${transparent3}`, `0px 6px 7px -4px ${transparent1},0px 11px 15px 1px ${transparent2},0px 4px 20px 3px ${transparent3}`, `0px 7px 8px -4px ${transparent1},0px 12px 17px 2px ${transparent2},0px 5px 22px 4px ${transparent3}`, `0px 7px 8px -4px ${transparent1},0px 13px 19px 2px ${transparent2},0px 5px 24px 4px ${transparent3}`, `0px 7px 9px -4px ${transparent1},0px 14px 21px 2px ${transparent2},0px 5px 26px 4px ${transparent3}`, `0px 8px 9px -5px ${transparent1},0px 15px 22px 2px ${transparent2},0px 6px 28px 5px ${transparent3}`, `0px 8px 10px -5px ${transparent1},0px 16px 24px 2px ${transparent2},0px 6px 30px 5px ${transparent3}`, `0px 8px 11px -5px ${transparent1},0px 17px 26px 2px ${transparent2},0px 6px 32px 5px ${transparent3}`, `0px 9px 11px -5px ${transparent1},0px 18px 28px 2px ${transparent2},0px 7px 34px 6px ${transparent3}`, `0px 9px 12px -6px ${transparent1},0px 19px 29px 2px ${transparent2},0px 7px 36px 6px ${transparent3}`, `0px 10px 13px -6px ${transparent1},0px 20px 31px 3px ${transparent2},0px 8px 38px 7px ${transparent3}`, `0px 10px 13px -6px ${transparent1},0px 21px 33px 3px ${transparent2},0px 8px 40px 7px ${transparent3}`, `0px 10px 14px -6px ${transparent1},0px 22px 35px 3px ${transparent2},0px 8px 42px 7px ${transparent3}`, `0px 11px 14px -7px ${transparent1},0px 23px 36px 3px ${transparent2},0px 9px 44px 8px ${transparent3}`, `0px 11px 15px -7px ${transparent1},0px 24px 38px 3px ${transparent2},0px 9px 46px 8px ${transparent3}`];
        }

        // ----------------------------------------------------------------------

        function pxToRem(value) {
          return `${value / 16}rem`;
        }
        function responsiveFontSizes({
          sm,
          md,
          lg
        }) {
          return {
            '@media (min-width:600px)': {
              fontSize: pxToRem(sm)
            },
            '@media (min-width:900px)': {
              fontSize: pxToRem(md)
            },
            '@media (min-width:1200px)': {
              fontSize: pxToRem(lg)
            }
          };
        }
        const primaryFont = 'Public Sans, sans-serif';
        const secondaryFont = 'Barlow, sans-serif';

        // ----------------------------------------------------------------------

        const typography$1 = {
          fontFamily: primaryFont,
          fontSecondaryFamily: secondaryFont,
          fontWeightRegular: 400,
          fontWeightMedium: 500,
          fontWeightSemiBold: 600,
          fontWeightBold: 700,
          h1: _objectSpread({
            fontWeight: 700,
            lineHeight: 80 / 64,
            fontSize: pxToRem(40),
            fontFamily: secondaryFont
          }, responsiveFontSizes({
            sm: 52,
            md: 58,
            lg: 64
          })),
          h2: _objectSpread({
            fontWeight: 700,
            lineHeight: 64 / 48,
            fontSize: pxToRem(32),
            fontFamily: secondaryFont
          }, responsiveFontSizes({
            sm: 40,
            md: 44,
            lg: 48
          })),
          h3: _objectSpread({
            fontWeight: 700,
            lineHeight: 1.5,
            fontSize: pxToRem(24),
            fontFamily: secondaryFont
          }, responsiveFontSizes({
            sm: 26,
            md: 30,
            lg: 32
          })),
          h4: _objectSpread({
            fontWeight: 600,
            lineHeight: 1.5,
            fontSize: pxToRem(20),
            fontFamily: secondaryFont
          }, responsiveFontSizes({
            sm: 20,
            md: 24,
            lg: 24
          })),
          h5: _objectSpread({
            fontWeight: 600,
            lineHeight: 1.5,
            fontSize: pxToRem(18),
            fontFamily: secondaryFont
          }, responsiveFontSizes({
            sm: 19,
            md: 20,
            lg: 20
          })),
          h6: _objectSpread({
            fontWeight: 600,
            lineHeight: 28 / 18,
            fontSize: pxToRem(17),
            fontFamily: secondaryFont
          }, responsiveFontSizes({
            sm: 18,
            md: 18,
            lg: 18
          })),
          subtitle1: {
            fontWeight: 600,
            lineHeight: 1.5,
            fontSize: pxToRem(16)
          },
          subtitle2: {
            fontWeight: 600,
            lineHeight: 22 / 14,
            fontSize: pxToRem(14)
          },
          body1: {
            lineHeight: 1.5,
            fontSize: pxToRem(16)
          },
          body2: {
            lineHeight: 22 / 14,
            fontSize: pxToRem(14)
          },
          caption: {
            lineHeight: 1.5,
            fontSize: pxToRem(12)
          },
          overline: {
            fontWeight: 700,
            lineHeight: 1.5,
            fontSize: pxToRem(12),
            textTransform: 'uppercase'
          },
          button: {
            fontWeight: 700,
            lineHeight: 24 / 14,
            fontSize: pxToRem(14),
            textTransform: 'capitalize'
          }
        };
        function RTL({
          children,
          themeDirection
        }) {
          reactExports.useEffect(() => {
            document.dir = themeDirection;
          }, [themeDirection]);
          const cacheRtl = createCache({
            key: "rtl",
            prepend: true,
            // https://github.com/styled-components/stylis-plugin-rtl/issues/35
            stylisPlugins: [stylisRTLPlugin]
          });
          if (themeDirection === "rtl") {
            return /* @__PURE__ */jsxRuntimeExports.jsx(CacheProvider, {
              value: cacheRtl,
              children
            });
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children
          });
        }
        RTL.propTypes = {
          children: PropTypes.node,
          themeDirection: PropTypes.string
        };

        // ----------------------------------------------------------------------

        function customShadows(mode) {
          const color = grey[500];
          const transparent = opacity => alpha(color, opacity);
          return {
            z1: `0 1px 2px 0 ${transparent(0.04)}`,
            z4: `-4px 4px 12px 0 ${transparent(0.08)}`,
            z8: `-8px 8px 24px -4px ${transparent(0.08)}`,
            z12: `-12px 12px 36px -4px ${transparent(0.12)}`,
            z16: `-16px 16px 48px -8px ${transparent(0.16)}`,
            z20: `-20px 20px 60px -8px ${transparent(0.2)}`,
            z24: `-24px 24px 72px -8px ${transparent(0.24)}`,
            //
            primary: `0 8px 16px 0 ${alpha(primary.main, 0.24)}`,
            info: `0 8px 16px 0 ${alpha(info.main, 0.24)}`,
            secondary: `0 8px 16px 0 ${alpha(secondary.main, 0.24)}`,
            success: `0 8px 16px 0 ${alpha(success.main, 0.24)}`,
            warning: `0 8px 16px 0 ${alpha(warning.main, 0.24)}`,
            error: `0 8px 16px 0 ${alpha(error.main, 0.24)}`,
            //
            card: `0 0 2px 0 ${alpha(color, 0.2)}, 0 12px 24px -4px ${alpha(color, 0.12)}`,
            dialog: `-40px 40px 80px -8px ${alpha(color, 0.24)}`,
            dropdown: `0 0 2px 0 ${alpha(color, 0.24)}, -20px 20px 40px -4px ${alpha(color, 0.24)}`
          };
        }
        var lodash_merge = {
          exports: {}
        };

        /**
         * Lodash (Custom Build) <https://lodash.com/>
         * Build: `lodash modularize exports="npm" -o ./`
         * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
         * Released under MIT license <https://lodash.com/license>
         * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
         * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
         */
        lodash_merge.exports;
        (function (module, exports) {
          /** Used as the size to enable large array optimizations. */
          var LARGE_ARRAY_SIZE = 200;

          /** Used to stand-in for `undefined` hash values. */
          var HASH_UNDEFINED = '__lodash_hash_undefined__';

          /** Used to detect hot functions by number of calls within a span of milliseconds. */
          var HOT_COUNT = 800,
            HOT_SPAN = 16;

          /** Used as references for various `Number` constants. */
          var MAX_SAFE_INTEGER = 9007199254740991;

          /** `Object#toString` result references. */
          var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            asyncTag = '[object AsyncFunction]',
            boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            errorTag = '[object Error]',
            funcTag = '[object Function]',
            genTag = '[object GeneratorFunction]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            nullTag = '[object Null]',
            objectTag = '[object Object]',
            proxyTag = '[object Proxy]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            undefinedTag = '[object Undefined]',
            weakMapTag = '[object WeakMap]';
          var arrayBufferTag = '[object ArrayBuffer]',
            dataViewTag = '[object DataView]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]';

          /**
           * Used to match `RegExp`
           * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
           */
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

          /** Used to detect host constructors (Safari). */
          var reIsHostCtor = /^\[object .+?Constructor\]$/;

          /** Used to detect unsigned integer values. */
          var reIsUint = /^(?:0|[1-9]\d*)$/;

          /** Used to identify `toStringTag` values of typed arrays. */
          var typedArrayTags = {};
          typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
          typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

          /** Detect free variable `global` from Node.js. */
          var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

          /** Detect free variable `self`. */
          var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

          /** Used as a reference to the global object. */
          var root = freeGlobal || freeSelf || Function('return this')();

          /** Detect free variable `exports`. */
          var freeExports = exports && !exports.nodeType && exports;

          /** Detect free variable `module`. */
          var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

          /** Detect the popular CommonJS extension `module.exports`. */
          var moduleExports = freeModule && freeModule.exports === freeExports;

          /** Detect free variable `process` from Node.js. */
          var freeProcess = moduleExports && freeGlobal.process;

          /** Used to access faster Node.js helpers. */
          var nodeUtil = function () {
            try {
              // Use `util.types` for Node.js 10+.
              var types = freeModule && freeModule.require && freeModule.require('util').types;
              if (types) {
                return types;
              }

              // Legacy `process.binding('util')` for Node.js < 10.
              return freeProcess && freeProcess.binding && freeProcess.binding('util');
            } catch (e) {}
          }();

          /* Node.js helper references. */
          var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

          /**
           * A faster alternative to `Function#apply`, this function invokes `func`
           * with the `this` binding of `thisArg` and the arguments of `args`.
           *
           * @private
           * @param {Function} func The function to invoke.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {Array} args The arguments to invoke `func` with.
           * @returns {*} Returns the result of `func`.
           */
          function apply(func, thisArg, args) {
            switch (args.length) {
              case 0:
                return func.call(thisArg);
              case 1:
                return func.call(thisArg, args[0]);
              case 2:
                return func.call(thisArg, args[0], args[1]);
              case 3:
                return func.call(thisArg, args[0], args[1], args[2]);
            }
            return func.apply(thisArg, args);
          }

          /**
           * The base implementation of `_.times` without support for iteratee shorthands
           * or max array length checks.
           *
           * @private
           * @param {number} n The number of times to invoke `iteratee`.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns the array of results.
           */
          function baseTimes(n, iteratee) {
            var index = -1,
              result = Array(n);
            while (++index < n) {
              result[index] = iteratee(index);
            }
            return result;
          }

          /**
           * The base implementation of `_.unary` without support for storing metadata.
           *
           * @private
           * @param {Function} func The function to cap arguments for.
           * @returns {Function} Returns the new capped function.
           */
          function baseUnary(func) {
            return function (value) {
              return func(value);
            };
          }

          /**
           * Gets the value at `key` of `object`.
           *
           * @private
           * @param {Object} [object] The object to query.
           * @param {string} key The key of the property to get.
           * @returns {*} Returns the property value.
           */
          function getValue(object, key) {
            return object == null ? undefined : object[key];
          }

          /**
           * Creates a unary function that invokes `func` with its argument transformed.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {Function} transform The argument transform.
           * @returns {Function} Returns the new function.
           */
          function overArg(func, transform) {
            return function (arg) {
              return func(transform(arg));
            };
          }

          /** Used for built-in method references. */
          var arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype;

          /** Used to detect overreaching core-js shims. */
          var coreJsData = root['__core-js_shared__'];

          /** Used to resolve the decompiled source of functions. */
          var funcToString = funcProto.toString;

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty;

          /** Used to detect methods masquerading as native. */
          var maskSrcKey = function () {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
            return uid ? 'Symbol(src)_1.' + uid : '';
          }();

          /**
           * Used to resolve the
           * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
           * of values.
           */
          var nativeObjectToString = objectProto.toString;

          /** Used to infer the `Object` constructor. */
          var objectCtorString = funcToString.call(Object);

          /** Used to detect if a method is native. */
          var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

          /** Built-in value references. */
          var Buffer = moduleExports ? root.Buffer : undefined,
            Symbol = root.Symbol,
            Uint8Array = root.Uint8Array;
          Buffer ? Buffer.allocUnsafe : undefined;
          var getPrototype = overArg(Object.getPrototypeOf, Object),
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice,
            symToStringTag = Symbol ? Symbol.toStringTag : undefined;
          var defineProperty = function () {
            try {
              var func = getNative(Object, 'defineProperty');
              func({}, '', {});
              return func;
            } catch (e) {}
          }();

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
            nativeMax = Math.max,
            nativeNow = Date.now;

          /* Built-in method references that are verified to be native. */
          var Map = getNative(root, 'Map'),
            nativeCreate = getNative(Object, 'create');

          /**
           * The base implementation of `_.create` without support for assigning
           * properties to the created object.
           *
           * @private
           * @param {Object} proto The object to inherit from.
           * @returns {Object} Returns the new object.
           */
          var baseCreate = function () {
            function object() {}
            return function (proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result = new object();
              object.prototype = undefined;
              return result;
            };
          }();

          /**
           * Creates a hash object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function Hash(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the hash.
           *
           * @private
           * @name clear
           * @memberOf Hash
           */
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }

          /**
           * Removes `key` and its value from the hash.
           *
           * @private
           * @name delete
           * @memberOf Hash
           * @param {Object} hash The hash to modify.
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
          }

          /**
           * Gets the hash value for `key`.
           *
           * @private
           * @name get
           * @memberOf Hash
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined;
          }

          /**
           * Checks if a hash value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Hash
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
          }

          /**
           * Sets the hash `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Hash
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the hash instance.
           */
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this;
          }

          // Add methods to `Hash`.
          Hash.prototype.clear = hashClear;
          Hash.prototype['delete'] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;

          /**
           * Creates an list cache object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function ListCache(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the list cache.
           *
           * @private
           * @name clear
           * @memberOf ListCache
           */
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }

          /**
           * Removes `key` and its value from the list cache.
           *
           * @private
           * @name delete
           * @memberOf ListCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function listCacheDelete(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }

          /**
           * Gets the list cache value for `key`.
           *
           * @private
           * @name get
           * @memberOf ListCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function listCacheGet(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1];
          }

          /**
           * Checks if a list cache value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf ListCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }

          /**
           * Sets the list cache `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf ListCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the list cache instance.
           */
          function listCacheSet(key, value) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }

          // Add methods to `ListCache`.
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype['delete'] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;

          /**
           * Creates a map cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function MapCache(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the map.
           *
           * @private
           * @name clear
           * @memberOf MapCache
           */
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              'hash': new Hash(),
              'map': new (Map || ListCache)(),
              'string': new Hash()
            };
          }

          /**
           * Removes `key` and its value from the map.
           *
           * @private
           * @name delete
           * @memberOf MapCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function mapCacheDelete(key) {
            var result = getMapData(this, key)['delete'](key);
            this.size -= result ? 1 : 0;
            return result;
          }

          /**
           * Gets the map value for `key`.
           *
           * @private
           * @name get
           * @memberOf MapCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }

          /**
           * Checks if a map value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf MapCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }

          /**
           * Sets the map `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf MapCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the map cache instance.
           */
          function mapCacheSet(key, value) {
            var data = getMapData(this, key),
              size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
          }

          // Add methods to `MapCache`.
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype['delete'] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;

          /**
           * Creates a stack cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }

          /**
           * Removes all key-value entries from the stack.
           *
           * @private
           * @name clear
           * @memberOf Stack
           */
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }

          /**
           * Removes `key` and its value from the stack.
           *
           * @private
           * @name delete
           * @memberOf Stack
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function stackDelete(key) {
            var data = this.__data__,
              result = data['delete'](key);
            this.size = data.size;
            return result;
          }

          /**
           * Gets the stack value for `key`.
           *
           * @private
           * @name get
           * @memberOf Stack
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function stackGet(key) {
            return this.__data__.get(key);
          }

          /**
           * Checks if a stack value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Stack
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function stackHas(key) {
            return this.__data__.has(key);
          }

          /**
           * Sets the stack `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Stack
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the stack cache instance.
           */
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }

          // Add methods to `Stack`.
          Stack.prototype.clear = stackClear;
          Stack.prototype['delete'] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;

          /**
           * Creates an array of the enumerable property names of the array-like `value`.
           *
           * @private
           * @param {*} value The value to query.
           * @param {boolean} inherited Specify returning inherited property names.
           * @returns {Array} Returns the array of property names.
           */
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value),
              isArg = !isArr && isArguments(value),
              isBuff = !isArr && !isArg && isBuffer(value),
              isType = !isArr && !isArg && !isBuff && isTypedArray(value),
              skipIndexes = isArr || isArg || isBuff || isType,
              result = skipIndexes ? baseTimes(value.length, String) : [],
              length = result.length;
            for (var key in value) {
              if (!(skipIndexes && (
              // Safari 9 has enumerable `arguments.length` in strict mode.
              key == 'length' ||
              // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == 'offset' || key == 'parent') ||
              // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
              // Skip index properties.
              isIndex(key, length)))) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * This function is like `assignValue` except that it doesn't assign
           * `undefined` values.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function assignMergeValue(object, key, value) {
            if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }

          /**
           * Assigns `value` to `key` of `object` if the existing value is not equivalent
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }

          /**
           * Gets the index at which the `key` is found in `array` of key-value pairs.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {*} key The key to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           */
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }

          /**
           * The base implementation of `assignValue` and `assignMergeValue` without
           * value checks.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function baseAssignValue(object, key, value) {
            if (key == '__proto__' && defineProperty) {
              defineProperty(object, key, {
                'configurable': true,
                'enumerable': true,
                'value': value,
                'writable': true
              });
            } else {
              object[key] = value;
            }
          }

          /**
           * The base implementation of `baseForOwn` which iterates over `object`
           * properties returned by `keysFunc` and invokes `iteratee` for each property.
           * Iteratee functions may exit iteration early by explicitly returning `false`.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @returns {Object} Returns `object`.
           */
          var baseFor = createBaseFor();

          /**
           * The base implementation of `getTag` without fallbacks for buggy environments.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the `toStringTag`.
           */
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
          }

          /**
           * The base implementation of `_.isArguments`.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an `arguments` object,
           */
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }

          /**
           * The base implementation of `_.isNative` without bad shim checks.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function,
           *  else `false`.
           */
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }

          /**
           * The base implementation of `_.isTypedArray` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
           */
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }

          /**
           * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object),
              result = [];
            for (var key in object) {
              if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * The base implementation of `_.merge` without support for multiple sources.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {number} srcIndex The index of `source`.
           * @param {Function} [customizer] The function to customize merged values.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           */
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function (srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;
                if (newValue === undefined) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }

          /**
           * A specialized version of `baseMerge` for arrays and objects which performs
           * deep merges and tracks traversed objects enabling objects with circular
           * references to be merged.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {string} key The key of the value to merge.
           * @param {number} srcIndex The index of `source`.
           * @param {Function} mergeFunc The function to merge values.
           * @param {Function} [customizer] The function to customize assigned values.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           */
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key),
              srcValue = safeGet(source, key),
              stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
            var isCommon = newValue === undefined;
            if (isCommon) {
              var isArr = isArray(srcValue),
                isBuff = !isArr && isBuffer(srcValue),
                isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              // Recursively merge objects and arrays (susceptible to call stack limits).
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack['delete'](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }

          /**
           * The base implementation of `_.rest` which doesn't validate or coerce arguments.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @returns {Function} Returns the new function.
           */
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + '');
          }

          /**
           * The base implementation of `setToString` without support for hot loop shorting.
           *
           * @private
           * @param {Function} func The function to modify.
           * @param {Function} string The `toString` result.
           * @returns {Function} Returns `func`.
           */
          var baseSetToString = !defineProperty ? identity : function (func, string) {
            return defineProperty(func, 'toString', {
              'configurable': true,
              'enumerable': false,
              'value': constant(string),
              'writable': true
            });
          };

          /**
           * Creates a clone of  `buffer`.
           *
           * @private
           * @param {Buffer} buffer The buffer to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Buffer} Returns the cloned buffer.
           */
          function cloneBuffer(buffer, isDeep) {
            {
              return buffer.slice();
            }
          }

          /**
           * Creates a clone of `arrayBuffer`.
           *
           * @private
           * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
           * @returns {ArrayBuffer} Returns the cloned array buffer.
           */
          function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
            return result;
          }

          /**
           * Creates a clone of `typedArray`.
           *
           * @private
           * @param {Object} typedArray The typed array to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the cloned typed array.
           */
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = cloneArrayBuffer(typedArray.buffer);
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }

          /**
           * Copies the values of `source` to `array`.
           *
           * @private
           * @param {Array} source The array to copy values from.
           * @param {Array} [array=[]] The array to copy values to.
           * @returns {Array} Returns `array`.
           */
          function copyArray(source, array) {
            var index = -1,
              length = source.length;
            array || (array = Array(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }

          /**
           * Copies properties of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy properties from.
           * @param {Array} props The property identifiers to copy.
           * @param {Object} [object={}] The object to copy properties to.
           * @param {Function} [customizer] The function to customize copied values.
           * @returns {Object} Returns `object`.
           */
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1,
              length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = undefined;
              if (newValue === undefined) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }

          /**
           * Creates a function like `_.assign`.
           *
           * @private
           * @param {Function} assigner The function to assign values.
           * @returns {Function} Returns the new assigner function.
           */
          function createAssigner(assigner) {
            return baseRest(function (object, sources) {
              var index = -1,
                length = sources.length,
                customizer = length > 1 ? sources[length - 1] : undefined,
                guard = length > 2 ? sources[2] : undefined;
              customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined : customizer;
                length = 1;
              }
              object = Object(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }

          /**
           * Creates a base function for methods like `_.forIn` and `_.forOwn`.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new base function.
           */
          function createBaseFor(fromRight) {
            return function (object, iteratee, keysFunc) {
              var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length;
              while (length--) {
                var key = props[++index];
                if (iteratee(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }

          /**
           * Gets the data for `map`.
           *
           * @private
           * @param {Object} map The map to query.
           * @param {string} key The reference key.
           * @returns {*} Returns the map data.
           */
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
          }

          /**
           * Gets the native function at `key` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the method to get.
           * @returns {*} Returns the function if it's native, else `undefined`.
           */
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
          }

          /**
           * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the raw `toStringTag`.
           */
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag),
              tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined;
              var unmasked = true;
            } catch (e) {}
            var result = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result;
          }

          /**
           * Initializes an object clone.
           *
           * @private
           * @param {Object} object The object to clone.
           * @returns {Object} Returns the initialized clone.
           */
          function initCloneObject(object) {
            return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }

          /**
           * Checks if `value` is a valid array-like index.
           *
           * @private
           * @param {*} value The value to check.
           * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
           * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
           */
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
          }

          /**
           * Checks if the given arguments are from an iteratee call.
           *
           * @private
           * @param {*} value The potential iteratee value argument.
           * @param {*} index The potential iteratee index or key argument.
           * @param {*} object The potential iteratee object argument.
           * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
           *  else `false`.
           */
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
              return eq(object[index], value);
            }
            return false;
          }

          /**
           * Checks if `value` is suitable for use as unique object key.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
           */
          function isKeyable(value) {
            var type = typeof value;
            return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
          }

          /**
           * Checks if `func` has its source masked.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` is masked, else `false`.
           */
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }

          /**
           * Checks if `value` is likely a prototype object.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
           */
          function isPrototype(value) {
            var Ctor = value && value.constructor,
              proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
            return value === proto;
          }

          /**
           * This function is like
           * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
           * except that it includes inherited enumerable properties.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function nativeKeysIn(object) {
            var result = [];
            if (object != null) {
              for (var key in Object(object)) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * Converts `value` to a string using `Object.prototype.toString`.
           *
           * @private
           * @param {*} value The value to convert.
           * @returns {string} Returns the converted string.
           */
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }

          /**
           * A specialized version of `baseRest` which transforms the rest array.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @param {Function} transform The rest array transform.
           * @returns {Function} Returns the new function.
           */
          function overRest(func, start, transform) {
            start = nativeMax(start === undefined ? func.length - 1 : start, 0);
            return function () {
              var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform(array);
              return apply(func, this, otherArgs);
            };
          }

          /**
           * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the property to get.
           * @returns {*} Returns the property value.
           */
          function safeGet(object, key) {
            if (key === 'constructor' && typeof object[key] === 'function') {
              return;
            }
            if (key == '__proto__') {
              return;
            }
            return object[key];
          }

          /**
           * Sets the `toString` method of `func` to return `string`.
           *
           * @private
           * @param {Function} func The function to modify.
           * @param {Function} string The `toString` result.
           * @returns {Function} Returns `func`.
           */
          var setToString = shortOut(baseSetToString);

          /**
           * Creates a function that'll short out and invoke `identity` instead
           * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
           * milliseconds.
           *
           * @private
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new shortable function.
           */
          function shortOut(func) {
            var count = 0,
              lastCalled = 0;
            return function () {
              var stamp = nativeNow(),
                remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined, arguments);
            };
          }

          /**
           * Converts `func` to its source code.
           *
           * @private
           * @param {Function} func The function to convert.
           * @returns {string} Returns the source code.
           */
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {}
              try {
                return func + '';
              } catch (e) {}
            }
            return '';
          }

          /**
           * Performs a
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * comparison between two values to determine if they are equivalent.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'a': 1 };
           * var other = { 'a': 1 };
           *
           * _.eq(object, object);
           * // => true
           *
           * _.eq(object, other);
           * // => false
           *
           * _.eq('a', 'a');
           * // => true
           *
           * _.eq('a', Object('a'));
           * // => false
           *
           * _.eq(NaN, NaN);
           * // => true
           */
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }

          /**
           * Checks if `value` is likely an `arguments` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an `arguments` object,
           *  else `false`.
           * @example
           *
           * _.isArguments(function() { return arguments; }());
           * // => true
           *
           * _.isArguments([1, 2, 3]);
           * // => false
           */
          var isArguments = baseIsArguments(function () {
            return arguments;
          }()) ? baseIsArguments : function (value) {
            return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
          };

          /**
           * Checks if `value` is classified as an `Array` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array, else `false`.
           * @example
           *
           * _.isArray([1, 2, 3]);
           * // => true
           *
           * _.isArray(document.body.children);
           * // => false
           *
           * _.isArray('abc');
           * // => false
           *
           * _.isArray(_.noop);
           * // => false
           */
          var isArray = Array.isArray;

          /**
           * Checks if `value` is array-like. A value is considered array-like if it's
           * not a function and has a `value.length` that's an integer greater than or
           * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
           * @example
           *
           * _.isArrayLike([1, 2, 3]);
           * // => true
           *
           * _.isArrayLike(document.body.children);
           * // => true
           *
           * _.isArrayLike('abc');
           * // => true
           *
           * _.isArrayLike(_.noop);
           * // => false
           */
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }

          /**
           * This method is like `_.isArrayLike` except that it also checks if `value`
           * is an object.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array-like object,
           *  else `false`.
           * @example
           *
           * _.isArrayLikeObject([1, 2, 3]);
           * // => true
           *
           * _.isArrayLikeObject(document.body.children);
           * // => true
           *
           * _.isArrayLikeObject('abc');
           * // => false
           *
           * _.isArrayLikeObject(_.noop);
           * // => false
           */
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }

          /**
           * Checks if `value` is a buffer.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
           * @example
           *
           * _.isBuffer(new Buffer(2));
           * // => true
           *
           * _.isBuffer(new Uint8Array(2));
           * // => false
           */
          var isBuffer = nativeIsBuffer || stubFalse;

          /**
           * Checks if `value` is classified as a `Function` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a function, else `false`.
           * @example
           *
           * _.isFunction(_);
           * // => true
           *
           * _.isFunction(/abc/);
           * // => false
           */
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 9 which returns 'object' for typed arrays and other constructors.
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }

          /**
           * Checks if `value` is a valid array-like length.
           *
           * **Note:** This method is loosely based on
           * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
           * @example
           *
           * _.isLength(3);
           * // => true
           *
           * _.isLength(Number.MIN_VALUE);
           * // => false
           *
           * _.isLength(Infinity);
           * // => false
           *
           * _.isLength('3');
           * // => false
           */
          function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }

          /**
           * Checks if `value` is the
           * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
           * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an object, else `false`.
           * @example
           *
           * _.isObject({});
           * // => true
           *
           * _.isObject([1, 2, 3]);
           * // => true
           *
           * _.isObject(_.noop);
           * // => true
           *
           * _.isObject(null);
           * // => false
           */
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == 'object' || type == 'function');
          }

          /**
           * Checks if `value` is object-like. A value is object-like if it's not `null`
           * and has a `typeof` result of "object".
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
           * @example
           *
           * _.isObjectLike({});
           * // => true
           *
           * _.isObjectLike([1, 2, 3]);
           * // => true
           *
           * _.isObjectLike(_.noop);
           * // => false
           *
           * _.isObjectLike(null);
           * // => false
           */
          function isObjectLike(value) {
            return value != null && typeof value == 'object';
          }

          /**
           * Checks if `value` is a plain object, that is, an object created by the
           * `Object` constructor or one with a `[[Prototype]]` of `null`.
           *
           * @static
           * @memberOf _
           * @since 0.8.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * _.isPlainObject(new Foo);
           * // => false
           *
           * _.isPlainObject([1, 2, 3]);
           * // => false
           *
           * _.isPlainObject({ 'x': 0, 'y': 0 });
           * // => true
           *
           * _.isPlainObject(Object.create(null));
           * // => true
           */
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
            return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }

          /**
           * Checks if `value` is classified as a typed array.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
           * @example
           *
           * _.isTypedArray(new Uint8Array);
           * // => true
           *
           * _.isTypedArray([]);
           * // => false
           */
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

          /**
           * Converts `value` to a plain object flattening inherited enumerable string
           * keyed properties of `value` to own properties of the plain object.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {Object} Returns the converted plain object.
           * @example
           *
           * function Foo() {
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.assign({ 'a': 1 }, new Foo);
           * // => { 'a': 1, 'b': 2 }
           *
           * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
           * // => { 'a': 1, 'b': 2, 'c': 3 }
           */
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }

          /**
           * Creates an array of the own and inherited enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keysIn(new Foo);
           * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
           */
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeysIn(object);
          }

          /**
           * This method is like `_.assign` except that it recursively merges own and
           * inherited enumerable string keyed properties of source objects into the
           * destination object. Source properties that resolve to `undefined` are
           * skipped if a destination value exists. Array and plain object properties
           * are merged recursively. Other objects and value types are overridden by
           * assignment. Source objects are applied from left to right. Subsequent
           * sources overwrite property assignments of previous sources.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 0.5.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = {
           *   'a': [{ 'b': 2 }, { 'd': 4 }]
           * };
           *
           * var other = {
           *   'a': [{ 'c': 3 }, { 'e': 5 }]
           * };
           *
           * _.merge(object, other);
           * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
           */
          var merge = createAssigner(function (object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });

          /**
           * Creates a function that returns `value`.
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Util
           * @param {*} value The value to return from the new function.
           * @returns {Function} Returns the new constant function.
           * @example
           *
           * var objects = _.times(2, _.constant({ 'a': 1 }));
           *
           * console.log(objects);
           * // => [{ 'a': 1 }, { 'a': 1 }]
           *
           * console.log(objects[0] === objects[1]);
           * // => true
           */
          function constant(value) {
            return function () {
              return value;
            };
          }

          /**
           * This method returns the first argument it receives.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {*} value Any value.
           * @returns {*} Returns `value`.
           * @example
           *
           * var object = { 'a': 1 };
           *
           * console.log(_.identity(object) === object);
           * // => true
           */
          function identity(value) {
            return value;
          }

          /**
           * This method returns `false`.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {boolean} Returns `false`.
           * @example
           *
           * _.times(2, _.stubFalse);
           * // => [false, false]
           */
          function stubFalse() {
            return false;
          }
          module.exports = merge;
        })(lodash_merge, lodash_merge.exports);
        var lodash_mergeExports = lodash_merge.exports;
        const merge = exports("U", /*@__PURE__*/getDefaultExportFromCjs(lodash_mergeExports));

        // ----------------------------------------------------------------------

        const COLORS$8 = ['primary', 'secondary', 'info', 'success', 'warning', 'error'];

        // ----------------------------------------------------------------------

        function fab(theme) {
          const lightMode = theme.palette.mode === 'light';
          const rootStyles = ownerState => {
            const defaultColor = ownerState.color === 'default';
            const inheritColor = ownerState.color === 'inherit';
            const circularVariant = ownerState.variant === 'circular';
            const extendedVariant = ownerState.variant === 'extended';
            const outlinedVariant = ownerState.variant === 'outlined';
            const outlinedExtendedVariant = ownerState.variant === 'outlinedExtended';
            const softVariant = ownerState.variant === 'soft';
            const softExtendedVariant = ownerState.variant === 'softExtended';
            const defaultStyle = _objectSpread(_objectSpread(_objectSpread({
              '&:hover, &:active': {
                boxShadow: 'none'
              }
            }, (circularVariant || extendedVariant) && _objectSpread(_objectSpread({}, (defaultColor || inheritColor) && {
              boxShadow: theme.customShadows.z8
            }), inheritColor && {
              backgroundColor: theme.palette.text.primary,
              color: lightMode ? theme.palette.common.white : theme.palette.grey[800],
              '&:hover': {
                backgroundColor: lightMode ? theme.palette.grey[700] : theme.palette.grey[400]
              }
            })), (outlinedVariant || outlinedExtendedVariant) && _objectSpread(_objectSpread(_objectSpread({
              boxShadow: 'none',
              backgroundColor: 'transparent'
            }, (defaultColor || inheritColor) && {
              border: `solid 1px ${alpha(theme.palette.grey[500], 0.32)}`
            }), defaultColor && _objectSpread({}, !lightMode && {
              color: theme.palette.text.secondary
            })), {}, {
              '&:hover': {
                borderColor: 'currentColor',
                boxShadow: '0 0 0 0.5px currentColor',
                backgroundColor: theme.palette.action.hover
              }
            })), (softVariant || softExtendedVariant) && _objectSpread(_objectSpread({
              boxShadow: 'none'
            }, defaultColor && {
              color: theme.palette.grey[800],
              backgroundColor: theme.palette.grey[300],
              '&:hover': {
                backgroundColor: theme.palette.grey[400]
              }
            }), inheritColor && {
              backgroundColor: alpha(theme.palette.grey[500], 0.08),
              '&:hover': {
                backgroundColor: alpha(theme.palette.grey[500], 0.24)
              }
            }));
            const colorStyle = COLORS$8.map(color => _objectSpread({}, ownerState.color === color && _objectSpread(_objectSpread(_objectSpread({}, (circularVariant || extendedVariant) && {
              boxShadow: theme.customShadows[color],
              '&:hover': {
                backgroundColor: theme.palette[color].dark
              }
            }), (outlinedVariant || outlinedExtendedVariant) && {
              color: theme.palette[color].main,
              border: `solid 1px ${alpha(theme.palette[color].main, 0.48)}`,
              '&:hover': {
                backgroundColor: alpha(theme.palette[color].main, 0.08)
              }
            }), (softVariant || softExtendedVariant) && {
              color: theme.palette[color][lightMode ? 'dark' : 'light'],
              backgroundColor: alpha(theme.palette[color].main, 0.16),
              '&:hover': {
                backgroundColor: alpha(theme.palette[color].main, 0.32)
              }
            })));
            const disabledState = {
              [`&.${fabClasses.disabled}`]: _objectSpread({}, (outlinedVariant || outlinedExtendedVariant) && {
                backgroundColor: 'transparent',
                border: `solid 1px ${theme.palette.action.disabledBackground}`
              })
            };
            const size = _objectSpread({}, (extendedVariant || outlinedExtendedVariant || softExtendedVariant) && _objectSpread(_objectSpread(_objectSpread({
              width: 'auto',
              '& svg': {
                marginRight: theme.spacing(1)
              }
            }, ownerState.size === 'small' && {
              height: 34,
              minHeight: 34,
              borderRadius: 17,
              padding: theme.spacing(0, 1)
            }), ownerState.size === 'medium' && {
              height: 40,
              minHeight: 40,
              borderRadius: 20,
              padding: theme.spacing(0, 2)
            }), ownerState.size === 'large' && {
              height: 48,
              minHeight: 48,
              borderRadius: 24,
              padding: theme.spacing(0, 2)
            }));
            return [defaultStyle, ...colorStyle, disabledState, size];
          };
          return {
            MuiFab: {
              styleOverrides: {
                root: ({
                  ownerState
                }) => rootStyles(ownerState)
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        const paper$1 = ({
          theme,
          bgcolor,
          dropdown
        }) => _objectSpread(_objectSpread(_objectSpread({}, bgBlur(_objectSpread({
          blur: 20,
          opacity: 0.9,
          color: theme.palette.background.paper
        }, !!bgcolor && {
          color: bgcolor
        }))), {}, {
          backgroundImage: 'url(/assets/cyan-blur.png), url(/assets/red-blur.png)',
          backgroundRepeat: 'no-repeat, no-repeat',
          backgroundPosition: 'top right, left bottom',
          backgroundSize: '50%, 50%'
        }, theme.direction === 'rtl' && {
          backgroundPosition: 'top left, right bottom'
        }), dropdown && {
          padding: theme.spacing(0.5),
          boxShadow: theme.customShadows.dropdown,
          borderRadius: theme.shape.borderRadius * 1.25
        });

        // ----------------------------------------------------------------------

        const menuItem = theme => _objectSpread(_objectSpread({}, theme.typography.body2), {}, {
          padding: theme.spacing(0.75, 1),
          borderRadius: theme.shape.borderRadius * 0.75,
          '&:not(:last-of-type)': {
            marginBottom: 4
          },
          [`&.${menuItemClasses.selected}`]: {
            fontWeight: theme.typography.fontWeightSemiBold,
            backgroundColor: theme.palette.action.selected,
            '&:hover': {
              backgroundColor: theme.palette.action.hover
            }
          },
          [`& .${checkboxClasses.root}`]: {
            padding: theme.spacing(0.5),
            marginLeft: theme.spacing(-0.5),
            marginRight: theme.spacing(0.5)
          },
          [`&.${autocompleteClasses.option}[aria-selected="true"]`]: {
            backgroundColor: theme.palette.action.selected,
            '&:hover': {
              backgroundColor: theme.palette.action.hover
            }
          },
          [`&+.${dividerClasses.root}`]: {
            margin: theme.spacing(0.5, 0)
          }
        });

        // ----------------------------------------------------------------------

        function bgBlur(props) {
          const color = (props === null || props === void 0 ? void 0 : props.color) || '#000000';
          const blur = (props === null || props === void 0 ? void 0 : props.blur) || 6;
          const opacity = (props === null || props === void 0 ? void 0 : props.opacity) || 0.8;
          const imgUrl = props === null || props === void 0 ? void 0 : props.imgUrl;
          if (imgUrl) {
            return {
              position: 'relative',
              backgroundImage: `url(${imgUrl})`,
              '&:before': {
                position: 'absolute',
                top: 0,
                left: 0,
                zIndex: 9,
                content: '""',
                width: '100%',
                height: '100%',
                backdropFilter: `blur(${blur}px)`,
                WebkitBackdropFilter: `blur(${blur}px)`,
                backgroundColor: alpha(color, opacity)
              }
            };
          }
          return {
            backdropFilter: `blur(${blur}px)`,
            WebkitBackdropFilter: `blur(${blur}px)`,
            backgroundColor: alpha(color, opacity)
          };
        }

        // ----------------------------------------------------------------------

        function menu(theme) {
          return {
            MuiMenuItem: {
              styleOverrides: {
                root: _objectSpread({}, menuItem(theme))
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        const COLORS$7 = ['primary', 'secondary', 'info', 'success', 'warning', 'error'];

        // ----------------------------------------------------------------------

        function chip(theme) {
          const lightMode = theme.palette.mode === 'light';
          const rootStyles = ownerState => {
            const defaultColor = ownerState.color === 'default';
            const filledVariant = ownerState.variant === 'filled';
            const outlinedVariant = ownerState.variant === 'outlined';
            const softVariant = ownerState.variant === 'soft';
            const defaultStyle = _objectSpread({
              [`& .${chipClasses.deleteIcon}`]: {
                opacity: 0.48,
                color: 'currentColor',
                '&:hover': {
                  opacity: 1,
                  color: 'currentColor'
                }
              }
            }, defaultColor && _objectSpread(_objectSpread(_objectSpread({
              [`& .${chipClasses.avatar}`]: {
                color: theme.palette.text.primary
              }
            }, filledVariant && {
              color: lightMode ? theme.palette.common.white : theme.palette.grey[800],
              backgroundColor: theme.palette.text.primary,
              '&:hover': {
                backgroundColor: lightMode ? theme.palette.grey[700] : theme.palette.grey[100]
              },
              [`& .${chipClasses.icon}`]: {
                color: lightMode ? theme.palette.common.white : theme.palette.grey[800]
              }
            }), outlinedVariant && {
              border: `solid 1px ${alpha(theme.palette.grey[500], 0.32)}`
            }), softVariant && {
              color: theme.palette.text.primary,
              backgroundColor: alpha(theme.palette.grey[500], 0.16),
              '&:hover': {
                backgroundColor: alpha(theme.palette.grey[500], 0.32)
              }
            }));
            const colorStyle = COLORS$7.map(color => _objectSpread({}, ownerState.color === color && _objectSpread({
              [`& .${chipClasses.avatar}`]: {
                color: theme.palette[color].lighter,
                backgroundColor: theme.palette[color].dark
              }
            }, softVariant && {
              color: theme.palette[color][lightMode ? 'dark' : 'light'],
              backgroundColor: alpha(theme.palette[color].main, 0.16),
              '&:hover': {
                backgroundColor: alpha(theme.palette[color].main, 0.32)
              }
            })));
            const disabledState = {
              [`&.${chipClasses.disabled}`]: _objectSpread(_objectSpread(_objectSpread({
                opacity: 1,
                color: theme.palette.action.disabled,
                [`& .${chipClasses.icon}`]: {
                  color: theme.palette.action.disabled
                },
                [`& .${chipClasses.avatar}`]: {
                  color: theme.palette.action.disabled,
                  backgroundColor: theme.palette.action.disabledBackground
                }
              }, filledVariant && {
                backgroundColor: theme.palette.action.disabledBackground
              }), outlinedVariant && {
                borderColor: theme.palette.action.disabledBackground
              }), softVariant && {
                backgroundColor: theme.palette.action.disabledBackground
              })
            };
            return [defaultStyle, ...colorStyle, disabledState, {
              fontWeight: 500,
              borderRadius: theme.shape.borderRadius
            }];
          };
          return {
            MuiChip: {
              styleOverrides: {
                root: ({
                  ownerState
                }) => rootStyles(ownerState)
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function card(theme) {
          return {
            MuiCard: {
              styleOverrides: {
                root: {
                  position: 'relative',
                  boxShadow: theme.customShadows.card,
                  borderRadius: theme.shape.borderRadius * 2,
                  zIndex: 0 // Fix Safari overflow: hidden with border radius
                }
              }
            },
            MuiCardHeader: {
              styleOverrides: {
                root: {
                  padding: theme.spacing(3, 3, 0)
                }
              }
            },
            MuiCardContent: {
              styleOverrides: {
                root: {
                  padding: theme.spacing(3)
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function tabs(theme) {
          return {
            MuiTabs: {
              styleOverrides: {
                indicator: {
                  backgroundColor: theme.palette.text.primary
                },
                scrollButtons: {
                  width: 48,
                  borderRadius: '50%'
                }
              }
            },
            MuiTab: {
              styleOverrides: {
                root: {
                  padding: 0,
                  opacity: 1,
                  minWidth: 48,
                  minHeight: 48,
                  fontWeight: theme.typography.fontWeightSemiBold,
                  '&:not(:last-of-type)': {
                    marginRight: theme.spacing(3),
                    [theme.breakpoints.up('sm')]: {
                      marginRight: theme.spacing(5)
                    }
                  },
                  [`&:not(.${tabClasses.selected})`]: {
                    color: theme.palette.text.secondary
                  }
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function list(theme) {
          return {
            MuiListItemIcon: {
              styleOverrides: {
                root: {
                  color: 'inherit',
                  minWidth: 'auto',
                  marginRight: theme.spacing(2)
                }
              }
            },
            MuiListItemAvatar: {
              styleOverrides: {
                root: {
                  minWidth: 'auto',
                  marginRight: theme.spacing(2)
                }
              }
            },
            MuiListItemText: {
              styleOverrides: {
                root: {
                  margin: 0
                },
                multiline: {
                  margin: 0
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function radio(theme) {
          return {
            // CHECKBOX, RADIO, SWITCH
            MuiFormControlLabel: {
              styleOverrides: {
                label: _objectSpread({}, theme.typography.body2)
              }
            },
            MuiRadio: {
              styleOverrides: {
                root: ({
                  ownerState
                }) => {
                  const color = ownerState.color;
                  return _objectSpread(_objectSpread({
                    padding: theme.spacing(1)
                  }, color === 'default' && {
                    [`&.${radioClasses.checked}`]: {
                      color: theme.palette.text.primary
                    }
                  }), {}, {
                    [`&.${radioClasses.disabled}`]: {
                      color: theme.palette.action.disabled
                    }
                  });
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function badge(theme) {
          return {
            MuiBadge: {
              styleOverrides: {
                dot: {
                  borderRadius: '50%'
                },
                root: ({
                  ownerState
                }) => {
                  const alway = ownerState.variant === 'alway';
                  const online = ownerState.variant === 'online';
                  const busy = ownerState.variant === 'busy';
                  const offline = ownerState.variant === 'offline';
                  const invisible = ownerState.variant === 'invisible';
                  const baseStyles = {
                    [`&.${badgeClasses.invisible}`]: {
                      transform: 'unset'
                    },
                    width: 10,
                    zIndex: 9,
                    padding: 0,
                    height: 10,
                    minWidth: 'auto',
                    '&:before, &:after': {
                      content: "''",
                      borderRadius: 1,
                      backgroundColor: theme.palette.common.white
                    }
                  };
                  return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, online && {
                    [`& .${badgeClasses.badge}`]: _objectSpread(_objectSpread({}, baseStyles), {}, {
                      backgroundColor: theme.palette.success.main
                    })
                  }), busy && {
                    [`& .${badgeClasses.badge}`]: _objectSpread(_objectSpread({}, baseStyles), {}, {
                      backgroundColor: theme.palette.error.main,
                      '&:before': {
                        width: 6,
                        height: 2
                      }
                    })
                  }), offline && {
                    [`& .${badgeClasses.badge}`]: _objectSpread(_objectSpread({}, baseStyles), {}, {
                      backgroundColor: theme.palette.text.disabled,
                      '&:before': {
                        width: 6,
                        height: 6,
                        borderRadius: '50%'
                      }
                    })
                  }), alway && {
                    [`& .${badgeClasses.badge}`]: _objectSpread(_objectSpread({}, baseStyles), {}, {
                      backgroundColor: theme.palette.warning.main,
                      '&:before': {
                        width: 2,
                        height: 4,
                        transform: 'translateX(1px) translateY(-1px)'
                      },
                      '&:after': {
                        width: 2,
                        height: 4,
                        transform: 'translateY(1px) rotate(125deg)'
                      }
                    })
                  }), invisible && {
                    [`& .${badgeClasses.badge}`]: {
                      display: 'none'
                    }
                  });
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function table(theme) {
          return {
            MuiTableContainer: {
              styleOverrides: {
                root: {
                  position: 'relative'
                }
              }
            },
            MuiTableRow: {
              styleOverrides: {
                root: {
                  [`&.${tableRowClasses.selected}`]: {
                    backgroundColor: alpha(theme.palette.primary.dark, 0.04),
                    '&:hover': {
                      backgroundColor: alpha(theme.palette.primary.dark, 0.08)
                    }
                  },
                  '&:last-of-type': {
                    [`& .${tableCellClasses.root}`]: {
                      borderColor: 'transparent'
                    }
                  }
                }
              }
            },
            MuiTableCell: {
              styleOverrides: {
                root: {
                  borderBottomStyle: 'dashed'
                },
                head: {
                  fontSize: 14,
                  color: theme.palette.text.secondary,
                  fontWeight: theme.typography.fontWeightSemiBold,
                  backgroundColor: theme.palette.background.neutral
                },
                stickyHeader: {
                  backgroundColor: theme.palette.background.paper,
                  backgroundImage: `linear-gradient(to bottom, ${theme.palette.background.neutral} 0%, ${theme.palette.background.neutral} 100%)`
                },
                paddingCheckbox: {
                  paddingLeft: theme.spacing(1)
                }
              }
            },
            MuiTablePagination: {
              styleOverrides: {
                root: {
                  width: '100%'
                },
                toolbar: {
                  height: 64
                },
                actions: {
                  marginRight: 8
                },
                select: {
                  paddingLeft: 8,
                  '&:focus': {
                    borderRadius: theme.shape.borderRadius
                  }
                },
                selectIcon: {
                  right: 4,
                  width: 16,
                  height: 16,
                  top: 'calc(50% - 8px)'
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        const COLORS$6 = ['info', 'success', 'warning', 'error'];

        // ----------------------------------------------------------------------

        function alert(theme) {
          const lightMode = theme.palette.mode === 'light';
          const rootStyles = ownerState => {
            const standardVariant = ownerState.variant === 'standard';
            const filledVariant = ownerState.variant === 'filled';
            const outlinedVariant = ownerState.variant === 'outlined';
            const colorStyle = COLORS$6.map(color => _objectSpread({}, ownerState.severity === color && _objectSpread(_objectSpread(_objectSpread({}, standardVariant && {
              color: theme.palette[color][lightMode ? 'darker' : 'lighter'],
              backgroundColor: theme.palette[color][lightMode ? 'lighter' : 'darker'],
              [`& .${alertClasses.icon}`]: {
                color: theme.palette[color][lightMode ? 'main' : 'light']
              }
            }), filledVariant && {
              color: theme.palette[color].contrastText,
              backgroundColor: theme.palette[color].main
            }), outlinedVariant && {
              backgroundColor: alpha(theme.palette[color].main, 0.08),
              color: theme.palette[color][lightMode ? 'dark' : 'light'],
              border: `solid 1px ${alpha(theme.palette[color].main, 0.16)}`,
              [`& .${alertClasses.icon}`]: {
                color: theme.palette[color].main
              }
            })));
            return [...colorStyle];
          };
          return {
            MuiAlert: {
              styleOverrides: {
                root: ({
                  ownerState
                }) => rootStyles(ownerState),
                icon: {
                  opacity: 1
                }
              }
            },
            MuiAlertTitle: {
              styleOverrides: {
                root: {
                  marginBottom: theme.spacing(0.5),
                  fontWeight: theme.typography.fontWeightSemiBold
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function paper(theme) {
          return {
            MuiPaper: {
              styleOverrides: {
                root: {
                  backgroundImage: 'none'
                },
                outlined: {
                  borderColor: alpha(theme.palette.grey[500], 0.16)
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function select(theme) {
          return {
            MuiSelect: {
              styleOverrides: {
                icon: {
                  right: 10,
                  width: 18,
                  height: 18,
                  top: 'calc(50% - 9px)'
                }
              }
            },
            MuiNativeSelect: {
              styleOverrides: {
                icon: {
                  right: 10,
                  width: 18,
                  height: 18,
                  top: 'calc(50% - 9px)'
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function slider(theme) {
          const lightMode = theme.palette.mode === 'light';
          return {
            MuiSlider: {
              styleOverrides: {
                root: {
                  [`&.${sliderClasses.disabled}`]: {
                    color: theme.palette.action.disabled
                  }
                },
                rail: {
                  opacity: 0.32
                },
                markLabel: {
                  fontSize: 13,
                  color: theme.palette.text.disabled
                },
                valueLabel: {
                  borderRadius: 8,
                  backgroundColor: theme.palette.grey[lightMode ? 800 : 700]
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        const COLORS$5 = ['default', 'primary', 'secondary', 'info', 'success', 'warning', 'error'];
        const colorByName = name => {
          const charAt = name.charAt(0).toLowerCase();
          if (['a', 'c', 'f'].includes(charAt)) return 'primary';
          if (['e', 'd', 'h'].includes(charAt)) return 'secondary';
          if (['i', 'k', 'l'].includes(charAt)) return 'info';
          if (['m', 'n', 'p'].includes(charAt)) return 'success';
          if (['q', 's', 't'].includes(charAt)) return 'warning';
          if (['v', 'x', 'y'].includes(charAt)) return 'error';
          return 'default';
        };

        // ----------------------------------------------------------------------

        function avatar(theme) {
          return {
            MuiAvatar: {
              variants: COLORS$5.map(color => color === 'default' ? {
                props: {
                  color: 'default'
                },
                style: {
                  color: theme.palette.text.secondary,
                  backgroundColor: alpha(theme.palette.grey[500], 0.24)
                }
              } : {
                props: {
                  color
                },
                style: {
                  color: theme.palette[color].contrastText,
                  backgroundColor: theme.palette[color].main
                }
              }),
              styleOverrides: {
                rounded: {
                  borderRadius: theme.shape.borderRadius * 1.5
                },
                colorDefault: ({
                  ownerState
                }) => {
                  const color = colorByName(`${ownerState.alt}`);
                  return _objectSpread({}, !!ownerState.alt && _objectSpread({}, color !== 'default' ? {
                    color: theme.palette[color].contrastText,
                    backgroundColor: theme.palette[color].main
                  } : {
                    color: theme.palette.text.secondary,
                    backgroundColor: alpha(theme.palette.grey[500], 0.24)
                  }));
                }
              }
            },
            MuiAvatarGroup: {
              styleOverrides: {
                root: ({
                  ownerState
                }) => _objectSpread({
                  justifyContent: 'flex-end'
                }, ownerState.variant === 'compact' && {
                  width: 40,
                  height: 40,
                  position: 'relative',
                  [`& .${avatarGroupClasses.avatar}`]: {
                    margin: 0,
                    width: 28,
                    height: 28,
                    position: 'absolute',
                    '&:first-of-type': {
                      left: 0,
                      bottom: 0,
                      zIndex: 9
                    },
                    '&:last-of-type': {
                      top: 0,
                      right: 0
                    }
                  }
                }),
                avatar: {
                  fontSize: 16,
                  fontWeight: theme.typography.fontWeightSemiBold,
                  '&:first-of-type': {
                    fontSize: 12,
                    color: theme.palette.primary.dark,
                    backgroundColor: theme.palette.primary.lighter
                  }
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function drawer(theme) {
          const lightMode = theme.palette.mode === 'light';
          return {
            MuiDrawer: {
              styleOverrides: {
                root: ({
                  ownerState
                }) => _objectSpread({}, ownerState.variant === 'temporary' && {
                  [`& .${drawerClasses.paper}`]: _objectSpread(_objectSpread(_objectSpread({}, paper$1({
                    theme
                  })), ownerState.anchor === 'left' && {
                    boxShadow: `40px 40px 80px -8px ${alpha(lightMode ? theme.palette.grey[500] : theme.palette.common.black, 0.24)}`
                  }), ownerState.anchor === 'right' && {
                    boxShadow: `-40px 40px 80px -8px ${alpha(lightMode ? theme.palette.grey[500] : theme.palette.common.black, 0.24)}`
                  })
                })
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function appBar(theme) {
          return {
            MuiAppBar: {
              styleOverrides: {
                root: {
                  boxShadow: 'none'
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function dialog(theme) {
          return {
            MuiDialog: {
              styleOverrides: {
                paper: ({
                  ownerState
                }) => _objectSpread({
                  boxShadow: theme.customShadows.dialog,
                  borderRadius: theme.shape.borderRadius * 2
                }, !ownerState.fullScreen && {
                  margin: theme.spacing(2)
                }),
                paperFullScreen: {
                  borderRadius: 0
                }
              }
            },
            MuiDialogTitle: {
              styleOverrides: {
                root: {
                  padding: theme.spacing(3)
                }
              }
            },
            MuiDialogContent: {
              styleOverrides: {
                root: {
                  padding: theme.spacing(0, 3)
                },
                dividers: {
                  borderTop: 0,
                  borderBottomStyle: 'dashed',
                  paddingBottom: theme.spacing(3)
                }
              }
            },
            MuiDialogActions: {
              styleOverrides: {
                root: {
                  padding: theme.spacing(3),
                  '& > :not(:first-of-type)': {
                    marginLeft: theme.spacing(1.5)
                  }
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function rating(theme) {
          return {
            MuiRating: {
              styleOverrides: {
                root: {
                  [`&.${ratingClasses.disabled}`]: {
                    opacity: 0.48
                  }
                },
                iconEmpty: {
                  color: alpha(theme.palette.grey[500], 0.48)
                },
                sizeSmall: {
                  [`& .${svgIconClasses.root}`]: {
                    width: 20,
                    height: 20
                  }
                },
                sizeMedium: {
                  [`& .${svgIconClasses.root}`]: {
                    width: 24,
                    height: 24
                  }
                },
                sizeLarge: {
                  [`& .${svgIconClasses.root}`]: {
                    width: 28,
                    height: 28
                  }
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        const COLORS$4 = ['primary', 'secondary', 'info', 'success', 'warning', 'error'];

        // ----------------------------------------------------------------------

        function button(theme) {
          const lightMode = theme.palette.mode === 'light';
          const rootStyles = ownerState => {
            const inheritColor = ownerState.color === 'inherit';
            const containedVariant = ownerState.variant === 'contained';
            const outlinedVariant = ownerState.variant === 'outlined';
            const textVariant = ownerState.variant === 'text';
            const softVariant = ownerState.variant === 'soft';
            const smallSize = ownerState.size === 'small';
            const mediumSize = ownerState.size === 'medium';
            const largeSize = ownerState.size === 'large';
            const defaultStyle = _objectSpread(_objectSpread({}, inheritColor && _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, containedVariant && {
              color: lightMode ? theme.palette.common.white : theme.palette.grey[800],
              backgroundColor: lightMode ? theme.palette.grey[800] : theme.palette.common.white,
              '&:hover': {
                backgroundColor: lightMode ? theme.palette.grey[700] : theme.palette.grey[400]
              }
            }), outlinedVariant && {
              borderColor: alpha(theme.palette.grey[500], 0.32),
              '&:hover': {
                backgroundColor: theme.palette.action.hover
              }
            }), textVariant && {
              '&:hover': {
                backgroundColor: theme.palette.action.hover
              }
            }), softVariant && {
              color: theme.palette.text.primary,
              backgroundColor: alpha(theme.palette.grey[500], 0.08),
              '&:hover': {
                backgroundColor: alpha(theme.palette.grey[500], 0.24)
              }
            })), outlinedVariant && {
              '&:hover': {
                borderColor: 'currentColor',
                boxShadow: '0 0 0 0.5px currentColor'
              }
            });
            const colorStyle = COLORS$4.map(color => _objectSpread({}, ownerState.color === color && _objectSpread(_objectSpread({}, containedVariant && {
              '&:hover': {
                boxShadow: theme.customShadows[color]
              }
            }), softVariant && {
              color: theme.palette[color][lightMode ? 'dark' : 'light'],
              backgroundColor: alpha(theme.palette[color].main, 0.16),
              '&:hover': {
                backgroundColor: alpha(theme.palette[color].main, 0.32)
              }
            })));
            const disabledState = {
              [`&.${buttonClasses.disabled}`]: _objectSpread({}, softVariant && {
                backgroundColor: theme.palette.action.disabledBackground
              })
            };
            const size = _objectSpread(_objectSpread(_objectSpread({}, smallSize && _objectSpread({
              height: 30,
              fontSize: 13,
              paddingLeft: 8,
              paddingRight: 8
            }, textVariant && {
              paddingLeft: 4,
              paddingRight: 4
            })), mediumSize && _objectSpread({
              paddingLeft: 12,
              paddingRight: 12
            }, textVariant && {
              paddingLeft: 8,
              paddingRight: 8
            })), largeSize && _objectSpread({
              height: 48,
              fontSize: 15,
              paddingLeft: 16,
              paddingRight: 16
            }, textVariant && {
              paddingLeft: 10,
              paddingRight: 10
            }));
            return [defaultStyle, ...colorStyle, disabledState, size];
          };
          return {
            MuiButton: {
              styleOverrides: {
                root: ({
                  ownerState
                }) => rootStyles(ownerState)
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function popover(theme) {
          return {
            MuiPopover: {
              styleOverrides: {
                paper: _objectSpread(_objectSpread({}, paper$1({
                  theme,
                  dropdown: true
                })), {}, {
                  [`& .${listClasses.root}`]: {
                    paddingTop: 0,
                    paddingBottom: 0
                  }
                })
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function switches(theme) {
          const lightMode = theme.palette.mode === 'light';
          const rootStyles = ownerState => {
            const color = ownerState.color;
            return {
              width: 58,
              height: 38,
              padding: '9px 13px 9px 12px',
              [`& .${switchClasses.thumb}`]: {
                width: 14,
                height: 14,
                boxShadow: 'none',
                color: theme.palette.common.white
              },
              [`& .${switchClasses.track}`]: {
                opacity: 1,
                borderRadius: 14,
                backgroundColor: alpha(theme.palette.grey[500], 0.48)
              },
              [`& .${switchClasses.switchBase}`]: {
                left: 3,
                padding: 12,
                [`&.${switchClasses.checked}`]: {
                  transform: 'translateX(13px)',
                  [`& .${switchClasses.thumb}`]: _objectSpread({}, color === 'default' && !lightMode && {
                    color: theme.palette.grey[800]
                  }),
                  [`&+.${switchClasses.track}`]: _objectSpread({
                    opacity: 1
                  }, color === 'default' && {
                    backgroundColor: theme.palette.text.primary
                  })
                },
                [`&.${switchClasses.disabled}`]: {
                  [`& .${switchClasses.thumb}`]: {
                    opacity: lightMode ? 1 : 0.48
                  },
                  [`&+.${switchClasses.track}`]: {
                    opacity: 0.48
                  }
                }
              },
              // Small
              [`&.${switchClasses.sizeSmall}`]: {
                padding: '4px 8px 4px 7px',
                width: 40,
                height: 24,
                [`& .${switchClasses.thumb}`]: {
                  width: 10,
                  height: 10
                },
                [`& .${switchClasses.switchBase}`]: {
                  padding: 7,
                  [`&.${switchClasses.checked}`]: {
                    transform: 'translateX(9px)'
                  }
                }
              }
            };
          };
          return {
            MuiSwitch: {
              styleOverrides: {
                root: ({
                  ownerState
                }) => rootStyles(ownerState)
              }
            }
          };
        }
        const matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;
        const stringToIcon = (value, validate, allowSimpleName, provider = "") => {
          const colonSeparated = value.split(":");
          if (value.slice(0, 1) === "@") {
            if (colonSeparated.length < 2 || colonSeparated.length > 3) {
              return null;
            }
            provider = colonSeparated.shift().slice(1);
          }
          if (colonSeparated.length > 3 || !colonSeparated.length) {
            return null;
          }
          if (colonSeparated.length > 1) {
            const name2 = colonSeparated.pop();
            const prefix = colonSeparated.pop();
            const result = {
              // Allow provider without '@': "provider:prefix:name"
              provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
              prefix,
              name: name2
            };
            return validate && !validateIconName(result) ? null : result;
          }
          const name = colonSeparated[0];
          const dashSeparated = name.split("-");
          if (dashSeparated.length > 1) {
            const result = {
              provider,
              prefix: dashSeparated.shift(),
              name: dashSeparated.join("-")
            };
            return validate && !validateIconName(result) ? null : result;
          }
          if (allowSimpleName && provider === "") {
            const result = {
              provider,
              prefix: "",
              name
            };
            return validate && !validateIconName(result, allowSimpleName) ? null : result;
          }
          return null;
        };
        const validateIconName = (icon, allowSimpleName) => {
          if (!icon) {
            return false;
          }
          return !!((icon.provider === "" || icon.provider.match(matchIconName)) && (allowSimpleName && icon.prefix === "" || icon.prefix.match(matchIconName)) && icon.name.match(matchIconName));
        };
        const defaultIconDimensions = Object.freeze({
          left: 0,
          top: 0,
          width: 16,
          height: 16
        });
        const defaultIconTransformations = Object.freeze({
          rotate: 0,
          vFlip: false,
          hFlip: false
        });
        const defaultIconProps = Object.freeze(_objectSpread(_objectSpread({}, defaultIconDimensions), defaultIconTransformations));
        const defaultExtendedIconProps = Object.freeze(_objectSpread(_objectSpread({}, defaultIconProps), {}, {
          body: "",
          hidden: false
        }));
        function mergeIconTransformations(obj1, obj2) {
          const result = {};
          if (!obj1.hFlip !== !obj2.hFlip) {
            result.hFlip = true;
          }
          if (!obj1.vFlip !== !obj2.vFlip) {
            result.vFlip = true;
          }
          const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
          if (rotate) {
            result.rotate = rotate;
          }
          return result;
        }
        function mergeIconData(parent, child) {
          const result = mergeIconTransformations(parent, child);
          for (const key in defaultExtendedIconProps) {
            if (key in defaultIconTransformations) {
              if (key in parent && !(key in result)) {
                result[key] = defaultIconTransformations[key];
              }
            } else if (key in child) {
              result[key] = child[key];
            } else if (key in parent) {
              result[key] = parent[key];
            }
          }
          return result;
        }
        function getIconsTree(data, names) {
          const icons = data.icons;
          const aliases = data.aliases || /* @__PURE__ */Object.create(null);
          const resolved = /* @__PURE__ */Object.create(null);
          function resolve(name) {
            if (icons[name]) {
              return resolved[name] = [];
            }
            if (!(name in resolved)) {
              resolved[name] = null;
              const parent = aliases[name] && aliases[name].parent;
              const value = parent && resolve(parent);
              if (value) {
                resolved[name] = [parent].concat(value);
              }
            }
            return resolved[name];
          }
          Object.keys(icons).concat(Object.keys(aliases)).forEach(resolve);
          return resolved;
        }
        function internalGetIconData(data, name, tree) {
          const icons = data.icons;
          const aliases = data.aliases || /* @__PURE__ */Object.create(null);
          let currentProps = {};
          function parse(name2) {
            currentProps = mergeIconData(icons[name2] || aliases[name2], currentProps);
          }
          parse(name);
          tree.forEach(parse);
          return mergeIconData(data, currentProps);
        }
        function parseIconSet(data, callback) {
          const names = [];
          if (typeof data !== "object" || typeof data.icons !== "object") {
            return names;
          }
          if (data.not_found instanceof Array) {
            data.not_found.forEach(name => {
              callback(name, null);
              names.push(name);
            });
          }
          const tree = getIconsTree(data);
          for (const name in tree) {
            const item = tree[name];
            if (item) {
              callback(name, internalGetIconData(data, name, item));
              names.push(name);
            }
          }
          return names;
        }
        const optionalPropertyDefaults = _objectSpread({
          provider: "",
          aliases: {},
          not_found: {}
        }, defaultIconDimensions);
        function checkOptionalProps(item, defaults) {
          for (const prop in defaults) {
            if (prop in item && typeof item[prop] !== typeof defaults[prop]) {
              return false;
            }
          }
          return true;
        }
        function quicklyValidateIconSet(obj) {
          if (typeof obj !== "object" || obj === null) {
            return null;
          }
          const data = obj;
          if (typeof data.prefix !== "string" || !obj.icons || typeof obj.icons !== "object") {
            return null;
          }
          if (!checkOptionalProps(obj, optionalPropertyDefaults)) {
            return null;
          }
          const icons = data.icons;
          for (const name in icons) {
            const icon = icons[name];
            if (!name.match(matchIconName) || typeof icon.body !== "string" || !checkOptionalProps(icon, defaultExtendedIconProps)) {
              return null;
            }
          }
          const aliases = data.aliases || /* @__PURE__ */Object.create(null);
          for (const name in aliases) {
            const icon = aliases[name];
            const parent = icon.parent;
            if (!name.match(matchIconName) || typeof parent !== "string" || !icons[parent] && !aliases[parent] || !checkOptionalProps(icon, defaultExtendedIconProps)) {
              return null;
            }
          }
          return data;
        }
        const dataStorage = /* @__PURE__ */Object.create(null);
        function newStorage(provider, prefix) {
          return {
            provider,
            prefix,
            icons: /* @__PURE__ */Object.create(null),
            missing: /* @__PURE__ */new Set()
          };
        }
        function getStorage(provider, prefix) {
          const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */Object.create(null));
          return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));
        }
        function addIconSet(storage, data) {
          if (!quicklyValidateIconSet(data)) {
            return [];
          }
          return parseIconSet(data, (name, icon) => {
            if (icon) {
              storage.icons[name] = icon;
            } else {
              storage.missing.add(name);
            }
          });
        }
        function addIconToStorage(storage, name, icon) {
          try {
            if (typeof icon.body === "string") {
              storage.icons[name] = _objectSpread({}, icon);
              return true;
            }
          } catch (err) {}
          return false;
        }
        let simpleNames = false;
        function allowSimpleNames(allow) {
          if (typeof allow === "boolean") {
            simpleNames = allow;
          }
          return simpleNames;
        }
        function getIconData(name) {
          const icon = typeof name === "string" ? stringToIcon(name, true, simpleNames) : name;
          if (icon) {
            const storage = getStorage(icon.provider, icon.prefix);
            const iconName = icon.name;
            return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);
          }
        }
        function addIcon(name, data) {
          const icon = stringToIcon(name, true, simpleNames);
          if (!icon) {
            return false;
          }
          const storage = getStorage(icon.provider, icon.prefix);
          return addIconToStorage(storage, icon.name, data);
        }
        function addCollection(data, provider) {
          if (typeof data !== "object") {
            return false;
          }
          if (typeof provider !== "string") {
            provider = data.provider || "";
          }
          if (simpleNames && !provider && !data.prefix) {
            let added = false;
            if (quicklyValidateIconSet(data)) {
              data.prefix = "";
              parseIconSet(data, (name, icon) => {
                if (icon && addIcon(name, icon)) {
                  added = true;
                }
              });
            }
            return added;
          }
          const prefix = data.prefix;
          if (!validateIconName({
            provider,
            prefix,
            name: "a"
          })) {
            return false;
          }
          const storage = getStorage(provider, prefix);
          return !!addIconSet(storage, data);
        }
        const defaultIconSizeCustomisations = Object.freeze({
          width: null,
          height: null
        });
        const defaultIconCustomisations = Object.freeze(_objectSpread(_objectSpread({}, defaultIconSizeCustomisations), defaultIconTransformations));
        const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
        const unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
        function calculateSize(size, ratio, precision) {
          if (ratio === 1) {
            return size;
          }
          precision = precision || 100;
          if (typeof size === "number") {
            return Math.ceil(size * ratio * precision) / precision;
          }
          if (typeof size !== "string") {
            return size;
          }
          const oldParts = size.split(unitsSplit);
          if (oldParts === null || !oldParts.length) {
            return size;
          }
          const newParts = [];
          let code = oldParts.shift();
          let isNumber = unitsTest.test(code);
          while (true) {
            if (isNumber) {
              const num = parseFloat(code);
              if (isNaN(num)) {
                newParts.push(code);
              } else {
                newParts.push(Math.ceil(num * ratio * precision) / precision);
              }
            } else {
              newParts.push(code);
            }
            code = oldParts.shift();
            if (code === void 0) {
              return newParts.join("");
            }
            isNumber = !isNumber;
          }
        }
        const isUnsetKeyword = value => value === "unset" || value === "undefined" || value === "none";
        function iconToSVG(icon, customisations) {
          const fullIcon = _objectSpread(_objectSpread({}, defaultIconProps), icon);
          const fullCustomisations = _objectSpread(_objectSpread({}, defaultIconCustomisations), customisations);
          const box = {
            left: fullIcon.left,
            top: fullIcon.top,
            width: fullIcon.width,
            height: fullIcon.height
          };
          let body = fullIcon.body;
          [fullIcon, fullCustomisations].forEach(props => {
            const transformations = [];
            const hFlip = props.hFlip;
            const vFlip = props.vFlip;
            let rotation = props.rotate;
            if (hFlip) {
              if (vFlip) {
                rotation += 2;
              } else {
                transformations.push("translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")");
                transformations.push("scale(-1 1)");
                box.top = box.left = 0;
              }
            } else if (vFlip) {
              transformations.push("translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")");
              transformations.push("scale(1 -1)");
              box.top = box.left = 0;
            }
            let tempValue;
            if (rotation < 0) {
              rotation -= Math.floor(rotation / 4) * 4;
            }
            rotation = rotation % 4;
            switch (rotation) {
              case 1:
                tempValue = box.height / 2 + box.top;
                transformations.unshift("rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")");
                break;
              case 2:
                transformations.unshift("rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")");
                break;
              case 3:
                tempValue = box.width / 2 + box.left;
                transformations.unshift("rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")");
                break;
            }
            if (rotation % 2 === 1) {
              if (box.left !== box.top) {
                tempValue = box.left;
                box.left = box.top;
                box.top = tempValue;
              }
              if (box.width !== box.height) {
                tempValue = box.width;
                box.width = box.height;
                box.height = tempValue;
              }
            }
            if (transformations.length) {
              body = '<g transform="' + transformations.join(" ") + '">' + body + "</g>";
            }
          });
          const customisationsWidth = fullCustomisations.width;
          const customisationsHeight = fullCustomisations.height;
          const boxWidth = box.width;
          const boxHeight = box.height;
          let width;
          let height;
          if (customisationsWidth === null) {
            height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
            width = calculateSize(height, boxWidth / boxHeight);
          } else {
            width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
            height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
          }
          const attributes = {};
          const setAttr = (prop, value) => {
            if (!isUnsetKeyword(value)) {
              attributes[prop] = value.toString();
            }
          };
          setAttr("width", width);
          setAttr("height", height);
          attributes.viewBox = box.left.toString() + " " + box.top.toString() + " " + boxWidth.toString() + " " + boxHeight.toString();
          return {
            attributes,
            body
          };
        }
        const regex = /\sid="(\S+)"/g;
        const randomPrefix = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
        let counter = 0;
        function replaceIDs(body, prefix = randomPrefix) {
          const ids = [];
          let match;
          while (match = regex.exec(body)) {
            ids.push(match[1]);
          }
          if (!ids.length) {
            return body;
          }
          const suffix = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
          ids.forEach(id => {
            const newID = typeof prefix === "function" ? prefix(id) : prefix + (counter++).toString();
            const escapedID = id.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            body = body.replace(
            // Allowed characters before id: [#;"]
            // Allowed characters after id: [)"], .[a-z]
            new RegExp('([#;"])(' + escapedID + ')([")]|\\.[a-z])', "g"), "$1" + newID + suffix + "$3");
          });
          body = body.replace(new RegExp(suffix, "g"), "");
          return body;
        }
        const storage = /* @__PURE__ */Object.create(null);
        function setAPIModule(provider, item) {
          storage[provider] = item;
        }
        function getAPIModule(provider) {
          return storage[provider] || storage[""];
        }
        function createAPIConfig(source) {
          let resources;
          if (typeof source.resources === "string") {
            resources = [source.resources];
          } else {
            resources = source.resources;
            if (!(resources instanceof Array) || !resources.length) {
              return null;
            }
          }
          const result = {
            // API hosts
            resources,
            // Root path
            path: source.path || "/",
            // URL length limit
            maxURL: source.maxURL || 500,
            // Timeout before next host is used.
            rotate: source.rotate || 750,
            // Timeout before failing query.
            timeout: source.timeout || 5e3,
            // Randomise default API end point.
            random: source.random === true,
            // Start index
            index: source.index || 0,
            // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
            dataAfterTimeout: source.dataAfterTimeout !== false
          };
          return result;
        }
        const configStorage = /* @__PURE__ */Object.create(null);
        const fallBackAPISources = ["https://api.simplesvg.com", "https://api.unisvg.com"];
        const fallBackAPI = [];
        while (fallBackAPISources.length > 0) {
          if (fallBackAPISources.length === 1) {
            fallBackAPI.push(fallBackAPISources.shift());
          } else {
            if (Math.random() > 0.5) {
              fallBackAPI.push(fallBackAPISources.shift());
            } else {
              fallBackAPI.push(fallBackAPISources.pop());
            }
          }
        }
        configStorage[""] = createAPIConfig({
          resources: ["https://api.iconify.design"].concat(fallBackAPI)
        });
        function addAPIProvider(provider, customConfig) {
          const config = createAPIConfig(customConfig);
          if (config === null) {
            return false;
          }
          configStorage[provider] = config;
          return true;
        }
        function getAPIConfig(provider) {
          return configStorage[provider];
        }
        const detectFetch = () => {
          let callback;
          try {
            callback = fetch;
            if (typeof callback === "function") {
              return callback;
            }
          } catch (err) {}
        };
        let fetchModule = detectFetch();
        function calculateMaxLength(provider, prefix) {
          const config = getAPIConfig(provider);
          if (!config) {
            return 0;
          }
          let result;
          if (!config.maxURL) {
            result = 0;
          } else {
            let maxHostLength = 0;
            config.resources.forEach(item => {
              const host = item;
              maxHostLength = Math.max(maxHostLength, host.length);
            });
            const url = prefix + ".json?icons=";
            result = config.maxURL - maxHostLength - config.path.length - url.length;
          }
          return result;
        }
        function shouldAbort(status) {
          return status === 404;
        }
        const prepare = (provider, prefix, icons) => {
          const results = [];
          const maxLength = calculateMaxLength(provider, prefix);
          const type = "icons";
          let item = {
            type,
            provider,
            prefix,
            icons: []
          };
          let length = 0;
          icons.forEach((name, index) => {
            length += name.length + 1;
            if (length >= maxLength && index > 0) {
              results.push(item);
              item = {
                type,
                provider,
                prefix,
                icons: []
              };
              length = name.length;
            }
            item.icons.push(name);
          });
          results.push(item);
          return results;
        };
        function getPath(provider) {
          if (typeof provider === "string") {
            const config = getAPIConfig(provider);
            if (config) {
              return config.path;
            }
          }
          return "/";
        }
        const send = (host, params, callback) => {
          if (!fetchModule) {
            callback("abort", 424);
            return;
          }
          let path = getPath(params.provider);
          switch (params.type) {
            case "icons":
              {
                const prefix = params.prefix;
                const icons = params.icons;
                const iconsList = icons.join(",");
                const urlParams = new URLSearchParams({
                  icons: iconsList
                });
                path += prefix + ".json?" + urlParams.toString();
                break;
              }
            case "custom":
              {
                const uri = params.uri;
                path += uri.slice(0, 1) === "/" ? uri.slice(1) : uri;
                break;
              }
            default:
              callback("abort", 400);
              return;
          }
          let defaultError = 503;
          fetchModule(host + path).then(response => {
            const status = response.status;
            if (status !== 200) {
              setTimeout(() => {
                callback(shouldAbort(status) ? "abort" : "next", status);
              });
              return;
            }
            defaultError = 501;
            return response.json();
          }).then(data => {
            if (typeof data !== "object" || data === null) {
              setTimeout(() => {
                if (data === 404) {
                  callback("abort", data);
                } else {
                  callback("next", defaultError);
                }
              });
              return;
            }
            setTimeout(() => {
              callback("success", data);
            });
          }).catch(() => {
            callback("next", defaultError);
          });
        };
        const fetchAPIModule = {
          prepare,
          send
        };
        function sortIcons(icons) {
          const result = {
            loaded: [],
            missing: [],
            pending: []
          };
          const storage = /* @__PURE__ */Object.create(null);
          icons.sort((a, b) => {
            if (a.provider !== b.provider) {
              return a.provider.localeCompare(b.provider);
            }
            if (a.prefix !== b.prefix) {
              return a.prefix.localeCompare(b.prefix);
            }
            return a.name.localeCompare(b.name);
          });
          let lastIcon = {
            provider: "",
            prefix: "",
            name: ""
          };
          icons.forEach(icon => {
            if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {
              return;
            }
            lastIcon = icon;
            const provider = icon.provider;
            const prefix = icon.prefix;
            const name = icon.name;
            const providerStorage = storage[provider] || (storage[provider] = /* @__PURE__ */Object.create(null));
            const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));
            let list;
            if (name in localStorage.icons) {
              list = result.loaded;
            } else if (prefix === "" || localStorage.missing.has(name)) {
              list = result.missing;
            } else {
              list = result.pending;
            }
            const item = {
              provider,
              prefix,
              name
            };
            list.push(item);
          });
          return result;
        }
        function removeCallback(storages, id) {
          storages.forEach(storage => {
            const items = storage.loaderCallbacks;
            if (items) {
              storage.loaderCallbacks = items.filter(row => row.id !== id);
            }
          });
        }
        function updateCallbacks(storage) {
          if (!storage.pendingCallbacksFlag) {
            storage.pendingCallbacksFlag = true;
            setTimeout(() => {
              storage.pendingCallbacksFlag = false;
              const items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];
              if (!items.length) {
                return;
              }
              let hasPending = false;
              const provider = storage.provider;
              const prefix = storage.prefix;
              items.forEach(item => {
                const icons = item.icons;
                const oldLength = icons.pending.length;
                icons.pending = icons.pending.filter(icon => {
                  if (icon.prefix !== prefix) {
                    return true;
                  }
                  const name = icon.name;
                  if (storage.icons[name]) {
                    icons.loaded.push({
                      provider,
                      prefix,
                      name
                    });
                  } else if (storage.missing.has(name)) {
                    icons.missing.push({
                      provider,
                      prefix,
                      name
                    });
                  } else {
                    hasPending = true;
                    return true;
                  }
                  return false;
                });
                if (icons.pending.length !== oldLength) {
                  if (!hasPending) {
                    removeCallback([storage], item.id);
                  }
                  item.callback(icons.loaded.slice(0), icons.missing.slice(0), icons.pending.slice(0), item.abort);
                }
              });
            });
          }
        }
        let idCounter = 0;
        function storeCallback(callback, icons, pendingSources) {
          const id = idCounter++;
          const abort = removeCallback.bind(null, pendingSources, id);
          if (!icons.pending.length) {
            return abort;
          }
          const item = {
            id,
            icons,
            callback,
            abort
          };
          pendingSources.forEach(storage => {
            (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);
          });
          return abort;
        }
        function listToIcons(list, validate = true, simpleNames = false) {
          const result = [];
          list.forEach(item => {
            const icon = typeof item === "string" ? stringToIcon(item, validate, simpleNames) : item;
            if (icon) {
              result.push(icon);
            }
          });
          return result;
        }

        // src/config.ts
        var defaultConfig = {
          resources: [],
          index: 0,
          timeout: 2e3,
          rotate: 750,
          random: false,
          dataAfterTimeout: false
        };

        // src/query.ts
        function sendQuery(config, payload, query, done) {
          const resourcesCount = config.resources.length;
          const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;
          let resources;
          if (config.random) {
            let list = config.resources.slice(0);
            resources = [];
            while (list.length > 1) {
              const nextIndex = Math.floor(Math.random() * list.length);
              resources.push(list[nextIndex]);
              list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));
            }
            resources = resources.concat(list);
          } else {
            resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));
          }
          const startTime = Date.now();
          let status = "pending";
          let queriesSent = 0;
          let lastError;
          let timer = null;
          let queue = [];
          let doneCallbacks = [];
          if (typeof done === "function") {
            doneCallbacks.push(done);
          }
          function resetTimer() {
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }
          }
          function abort() {
            if (status === "pending") {
              status = "aborted";
            }
            resetTimer();
            queue.forEach(item => {
              if (item.status === "pending") {
                item.status = "aborted";
              }
            });
            queue = [];
          }
          function subscribe(callback, overwrite) {
            if (overwrite) {
              doneCallbacks = [];
            }
            if (typeof callback === "function") {
              doneCallbacks.push(callback);
            }
          }
          function getQueryStatus() {
            return {
              startTime,
              payload,
              status,
              queriesSent,
              queriesPending: queue.length,
              subscribe,
              abort
            };
          }
          function failQuery() {
            status = "failed";
            doneCallbacks.forEach(callback => {
              callback(void 0, lastError);
            });
          }
          function clearQueue() {
            queue.forEach(item => {
              if (item.status === "pending") {
                item.status = "aborted";
              }
            });
            queue = [];
          }
          function moduleResponse(item, response, data) {
            const isError = response !== "success";
            queue = queue.filter(queued => queued !== item);
            switch (status) {
              case "pending":
                break;
              case "failed":
                if (isError || !config.dataAfterTimeout) {
                  return;
                }
                break;
              default:
                return;
            }
            if (response === "abort") {
              lastError = data;
              failQuery();
              return;
            }
            if (isError) {
              lastError = data;
              if (!queue.length) {
                if (!resources.length) {
                  failQuery();
                } else {
                  execNext();
                }
              }
              return;
            }
            resetTimer();
            clearQueue();
            if (!config.random) {
              const index = config.resources.indexOf(item.resource);
              if (index !== -1 && index !== config.index) {
                config.index = index;
              }
            }
            status = "completed";
            doneCallbacks.forEach(callback => {
              callback(data);
            });
          }
          function execNext() {
            if (status !== "pending") {
              return;
            }
            resetTimer();
            const resource = resources.shift();
            if (resource === void 0) {
              if (queue.length) {
                timer = setTimeout(() => {
                  resetTimer();
                  if (status === "pending") {
                    clearQueue();
                    failQuery();
                  }
                }, config.timeout);
                return;
              }
              failQuery();
              return;
            }
            const item = {
              status: "pending",
              resource,
              callback: (status2, data) => {
                moduleResponse(item, status2, data);
              }
            };
            queue.push(item);
            queriesSent++;
            timer = setTimeout(execNext, config.rotate);
            query(resource, payload, item.callback);
          }
          setTimeout(execNext);
          return getQueryStatus;
        }

        // src/index.ts
        function initRedundancy(cfg) {
          const config = _objectSpread(_objectSpread({}, defaultConfig), cfg);
          let queries = [];
          function cleanup() {
            queries = queries.filter(item => item().status === "pending");
          }
          function query(payload, queryCallback, doneCallback) {
            const query2 = sendQuery(config, payload, queryCallback, (data, error) => {
              cleanup();
              if (doneCallback) {
                doneCallback(data, error);
              }
            });
            queries.push(query2);
            return query2;
          }
          function find(callback) {
            return queries.find(value => {
              return callback(value);
            }) || null;
          }
          const instance = {
            query,
            find,
            setIndex: index => {
              config.index = index;
            },
            getIndex: () => config.index,
            cleanup
          };
          return instance;
        }
        function emptyCallback$1() {}
        const redundancyCache = /* @__PURE__ */Object.create(null);
        function getRedundancyCache(provider) {
          if (!redundancyCache[provider]) {
            const config = getAPIConfig(provider);
            if (!config) {
              return;
            }
            const redundancy = initRedundancy(config);
            const cachedReundancy = {
              config,
              redundancy
            };
            redundancyCache[provider] = cachedReundancy;
          }
          return redundancyCache[provider];
        }
        function sendAPIQuery(target, query, callback) {
          let redundancy;
          let send;
          if (typeof target === "string") {
            const api = getAPIModule(target);
            if (!api) {
              callback(void 0, 424);
              return emptyCallback$1;
            }
            send = api.send;
            const cached = getRedundancyCache(target);
            if (cached) {
              redundancy = cached.redundancy;
            }
          } else {
            const config = createAPIConfig(target);
            if (config) {
              redundancy = initRedundancy(config);
              const moduleKey = target.resources ? target.resources[0] : "";
              const api = getAPIModule(moduleKey);
              if (api) {
                send = api.send;
              }
            }
          }
          if (!redundancy || !send) {
            callback(void 0, 424);
            return emptyCallback$1;
          }
          return redundancy.query(query, send, callback)().abort;
        }
        const browserCacheVersion = "iconify2";
        const browserCachePrefix = "iconify";
        const browserCacheCountKey = browserCachePrefix + "-count";
        const browserCacheVersionKey = browserCachePrefix + "-version";
        const browserStorageHour = 36e5;
        const browserStorageCacheExpiration = 168;
        function getStoredItem(func, key) {
          try {
            return func.getItem(key);
          } catch (err) {}
        }
        function setStoredItem(func, key, value) {
          try {
            func.setItem(key, value);
            return true;
          } catch (err) {}
        }
        function removeStoredItem(func, key) {
          try {
            func.removeItem(key);
          } catch (err) {}
        }
        function setBrowserStorageItemsCount(storage, value) {
          return setStoredItem(storage, browserCacheCountKey, value.toString());
        }
        function getBrowserStorageItemsCount(storage) {
          return parseInt(getStoredItem(storage, browserCacheCountKey)) || 0;
        }
        const browserStorageConfig = {
          local: true,
          session: true
        };
        const browserStorageEmptyItems = {
          local: /* @__PURE__ */new Set(),
          session: /* @__PURE__ */new Set()
        };
        let browserStorageStatus = false;
        function setBrowserStorageStatus(status) {
          browserStorageStatus = status;
        }
        let _window = typeof window === "undefined" ? {} : window;
        function getBrowserStorage(key) {
          const attr = key + "Storage";
          try {
            if (_window && _window[attr] && typeof _window[attr].length === "number") {
              return _window[attr];
            }
          } catch (err) {}
          browserStorageConfig[key] = false;
        }
        function iterateBrowserStorage(key, callback) {
          const func = getBrowserStorage(key);
          if (!func) {
            return;
          }
          const version = getStoredItem(func, browserCacheVersionKey);
          if (version !== browserCacheVersion) {
            if (version) {
              const total2 = getBrowserStorageItemsCount(func);
              for (let i = 0; i < total2; i++) {
                removeStoredItem(func, browserCachePrefix + i.toString());
              }
            }
            setStoredItem(func, browserCacheVersionKey, browserCacheVersion);
            setBrowserStorageItemsCount(func, 0);
            return;
          }
          const minTime = Math.floor(Date.now() / browserStorageHour) - browserStorageCacheExpiration;
          const parseItem = index => {
            const name = browserCachePrefix + index.toString();
            const item = getStoredItem(func, name);
            if (typeof item !== "string") {
              return;
            }
            try {
              const data = JSON.parse(item);
              if (typeof data === "object" && typeof data.cached === "number" && data.cached > minTime && typeof data.provider === "string" && typeof data.data === "object" && typeof data.data.prefix === "string" &&
              // Valid item: run callback
              callback(data, index)) {
                return true;
              }
            } catch (err) {}
            removeStoredItem(func, name);
          };
          let total = getBrowserStorageItemsCount(func);
          for (let i = total - 1; i >= 0; i--) {
            if (!parseItem(i)) {
              if (i === total - 1) {
                total--;
                setBrowserStorageItemsCount(func, total);
              } else {
                browserStorageEmptyItems[key].add(i);
              }
            }
          }
        }
        function initBrowserStorage() {
          if (browserStorageStatus) {
            return;
          }
          setBrowserStorageStatus(true);
          for (const key in browserStorageConfig) {
            iterateBrowserStorage(key, item => {
              const iconSet = item.data;
              const provider = item.provider;
              const prefix = iconSet.prefix;
              const storage = getStorage(provider, prefix);
              if (!addIconSet(storage, iconSet).length) {
                return false;
              }
              const lastModified = iconSet.lastModified || -1;
              storage.lastModifiedCached = storage.lastModifiedCached ? Math.min(storage.lastModifiedCached, lastModified) : lastModified;
              return true;
            });
          }
        }
        function updateLastModified(storage, lastModified) {
          const lastValue = storage.lastModifiedCached;
          if (
          // Matches or newer
          lastValue && lastValue >= lastModified) {
            return lastValue === lastModified;
          }
          storage.lastModifiedCached = lastModified;
          if (lastValue) {
            for (const key in browserStorageConfig) {
              iterateBrowserStorage(key, item => {
                const iconSet = item.data;
                return item.provider !== storage.provider || iconSet.prefix !== storage.prefix || iconSet.lastModified === lastModified;
              });
            }
          }
          return true;
        }
        function storeInBrowserStorage(storage, data) {
          if (!browserStorageStatus) {
            initBrowserStorage();
          }
          function store(key) {
            let func;
            if (!browserStorageConfig[key] || !(func = getBrowserStorage(key))) {
              return;
            }
            const set = browserStorageEmptyItems[key];
            let index;
            if (set.size) {
              set.delete(index = Array.from(set).shift());
            } else {
              index = getBrowserStorageItemsCount(func);
              if (!setBrowserStorageItemsCount(func, index + 1)) {
                return;
              }
            }
            const item = {
              cached: Math.floor(Date.now() / browserStorageHour),
              provider: storage.provider,
              data
            };
            return setStoredItem(func, browserCachePrefix + index.toString(), JSON.stringify(item));
          }
          if (data.lastModified && !updateLastModified(storage, data.lastModified)) {
            return;
          }
          if (!Object.keys(data.icons).length) {
            return;
          }
          if (data.not_found) {
            data = Object.assign({}, data);
            delete data.not_found;
          }
          if (!store("local")) {
            store("session");
          }
        }
        function emptyCallback() {}
        function loadedNewIcons(storage) {
          if (!storage.iconsLoaderFlag) {
            storage.iconsLoaderFlag = true;
            setTimeout(() => {
              storage.iconsLoaderFlag = false;
              updateCallbacks(storage);
            });
          }
        }
        function loadNewIcons(storage, icons) {
          if (!storage.iconsToLoad) {
            storage.iconsToLoad = icons;
          } else {
            storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();
          }
          if (!storage.iconsQueueFlag) {
            storage.iconsQueueFlag = true;
            setTimeout(() => {
              storage.iconsQueueFlag = false;
              const provider = storage.provider,
                prefix = storage.prefix;
              const icons2 = storage.iconsToLoad;
              delete storage.iconsToLoad;
              let api;
              if (!icons2 || !(api = getAPIModule(provider))) {
                return;
              }
              const params = api.prepare(provider, prefix, icons2);
              params.forEach(item => {
                sendAPIQuery(provider, item, data => {
                  if (typeof data !== "object") {
                    item.icons.forEach(name => {
                      storage.missing.add(name);
                    });
                  } else {
                    try {
                      const parsed = addIconSet(storage, data);
                      if (!parsed.length) {
                        return;
                      }
                      const pending = storage.pendingIcons;
                      if (pending) {
                        parsed.forEach(name => {
                          pending.delete(name);
                        });
                      }
                      storeInBrowserStorage(storage, data);
                    } catch (err) {
                      console.error(err);
                    }
                  }
                  loadedNewIcons(storage);
                });
              });
            });
          }
        }
        const loadIcons = (icons, callback) => {
          const cleanedIcons = listToIcons(icons, true, allowSimpleNames());
          const sortedIcons = sortIcons(cleanedIcons);
          if (!sortedIcons.pending.length) {
            let callCallback = true;
            if (callback) {
              setTimeout(() => {
                if (callCallback) {
                  callback(sortedIcons.loaded, sortedIcons.missing, sortedIcons.pending, emptyCallback);
                }
              });
            }
            return () => {
              callCallback = false;
            };
          }
          const newIcons = /* @__PURE__ */Object.create(null);
          const sources = [];
          let lastProvider, lastPrefix;
          sortedIcons.pending.forEach(icon => {
            const provider = icon.provider,
              prefix = icon.prefix;
            if (prefix === lastPrefix && provider === lastProvider) {
              return;
            }
            lastProvider = provider;
            lastPrefix = prefix;
            sources.push(getStorage(provider, prefix));
            const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */Object.create(null));
            if (!providerNewIcons[prefix]) {
              providerNewIcons[prefix] = [];
            }
          });
          sortedIcons.pending.forEach(icon => {
            const provider = icon.provider,
              prefix = icon.prefix,
              name = icon.name;
            const storage = getStorage(provider, prefix);
            const pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */new Set());
            if (!pendingQueue.has(name)) {
              pendingQueue.add(name);
              newIcons[provider][prefix].push(name);
            }
          });
          sources.forEach(storage => {
            const provider = storage.provider,
              prefix = storage.prefix;
            if (newIcons[provider][prefix].length) {
              loadNewIcons(storage, newIcons[provider][prefix]);
            }
          });
          return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;
        };
        function mergeCustomisations(defaults, item) {
          const result = _objectSpread({}, defaults);
          for (const key in item) {
            const value = item[key];
            const valueType = typeof value;
            if (key in defaultIconSizeCustomisations) {
              if (value === null || value && (valueType === "string" || valueType === "number")) {
                result[key] = value;
              }
            } else if (valueType === typeof result[key]) {
              result[key] = key === "rotate" ? value % 4 : value;
            }
          }
          return result;
        }
        const separator = /[\s,]+/;
        function flipFromString(custom, flip) {
          flip.split(separator).forEach(str => {
            const value = str.trim();
            switch (value) {
              case "horizontal":
                custom.hFlip = true;
                break;
              case "vertical":
                custom.vFlip = true;
                break;
            }
          });
        }
        function rotateFromString(value, defaultValue = 0) {
          const units = value.replace(/^-?[0-9.]*/, "");
          function cleanup(value2) {
            while (value2 < 0) {
              value2 += 4;
            }
            return value2 % 4;
          }
          if (units === "") {
            const num = parseInt(value);
            return isNaN(num) ? 0 : cleanup(num);
          } else if (units !== value) {
            let split = 0;
            switch (units) {
              case "%":
                split = 25;
                break;
              case "deg":
                split = 90;
            }
            if (split) {
              let num = parseFloat(value.slice(0, value.length - units.length));
              if (isNaN(num)) {
                return 0;
              }
              num = num / split;
              return num % 1 === 0 ? cleanup(num) : 0;
            }
          }
          return defaultValue;
        }
        function iconToHTML(body, attributes) {
          let renderAttribsHTML = body.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
          for (const attr in attributes) {
            renderAttribsHTML += " " + attr + '="' + attributes[attr] + '"';
          }
          return '<svg xmlns="http://www.w3.org/2000/svg"' + renderAttribsHTML + ">" + body + "</svg>";
        }
        function encodeSVGforURL(svg) {
          return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
        }
        function svgToData(svg) {
          return "data:image/svg+xml," + encodeSVGforURL(svg);
        }
        function svgToURL(svg) {
          return 'url("' + svgToData(svg) + '")';
        }
        let policy;
        function createPolicy() {
          try {
            policy = window.trustedTypes.createPolicy("iconify", {
              // eslint-disable-next-line @typescript-eslint/no-unsafe-return
              createHTML: s => s
            });
          } catch (err) {
            policy = null;
          }
        }
        function cleanUpInnerHTML(html) {
          if (policy === void 0) {
            createPolicy();
          }
          return policy ? policy.createHTML(html) : html;
        }
        const defaultExtendedIconCustomisations = _objectSpread(_objectSpread({}, defaultIconCustomisations), {}, {
          inline: false
        });

        /**
         * Default SVG attributes
         */
        const svgDefaults = {
          'xmlns': 'http://www.w3.org/2000/svg',
          'xmlnsXlink': 'http://www.w3.org/1999/xlink',
          'aria-hidden': true,
          'role': 'img'
        };
        /**
         * Style modes
         */
        const commonProps = {
          display: 'inline-block'
        };
        const monotoneProps = {
          backgroundColor: 'currentColor'
        };
        const coloredProps = {
          backgroundColor: 'transparent'
        };
        // Dynamically add common props to variables above
        const propsToAdd = {
          Image: 'var(--svg)',
          Repeat: 'no-repeat',
          Size: '100% 100%'
        };
        const propsToAddTo = {
          WebkitMask: monotoneProps,
          mask: monotoneProps,
          background: coloredProps
        };
        for (const prefix in propsToAddTo) {
          const list = propsToAddTo[prefix];
          for (const prop in propsToAdd) {
            list[prefix + prop] = propsToAdd[prop];
          }
        }
        /**
         * Default values for customisations for inline icon
         */
        const inlineDefaults = _objectSpread(_objectSpread({}, defaultExtendedIconCustomisations), {}, {
          inline: true
        });
        /**
         * Fix size: add 'px' to numbers
         */
        function fixSize(value) {
          return value + (value.match(/^[-0-9.]+$/) ? 'px' : '');
        }
        /**
         * Render icon
         */
        const render = (
        // Icon must be validated before calling this function
        icon,
        // Partial properties
        props,
        // True if icon should have vertical-align added
        inline,
        // Optional reference for SVG/SPAN, extracted by React.forwardRef()
        ref) => {
          // Get default properties
          const defaultProps = inline ? inlineDefaults : defaultExtendedIconCustomisations;
          // Get all customisations
          const customisations = mergeCustomisations(defaultProps, props);
          // Check mode
          const mode = props.mode || 'svg';
          // Create style
          const style = {};
          const customStyle = props.style || {};
          // Create SVG component properties
          const componentProps = _objectSpread(_objectSpread({}, mode === 'svg' ? svgDefaults : {}), {}, {
            ref
          });
          // Get element properties
          for (let key in props) {
            const value = props[key];
            if (value === void 0) {
              continue;
            }
            switch (key) {
              // Properties to ignore
              case 'icon':
              case 'style':
              case 'children':
              case 'onLoad':
              case 'mode':
              case '_ref':
              case '_inline':
                break;
              // Boolean attributes
              case 'inline':
              case 'hFlip':
              case 'vFlip':
                customisations[key] = value === true || value === 'true' || value === 1;
                break;
              // Flip as string: 'horizontal,vertical'
              case 'flip':
                if (typeof value === 'string') {
                  flipFromString(customisations, value);
                }
                break;
              // Color: copy to style
              case 'color':
                style.color = value;
                break;
              // Rotation as string
              case 'rotate':
                if (typeof value === 'string') {
                  customisations[key] = rotateFromString(value);
                } else if (typeof value === 'number') {
                  customisations[key] = value;
                }
                break;
              // Remove aria-hidden
              case 'ariaHidden':
              case 'aria-hidden':
                if (value !== true && value !== 'true') {
                  delete componentProps['aria-hidden'];
                }
                break;
              // Copy missing property if it does not exist in customisations
              default:
                if (defaultProps[key] === void 0) {
                  componentProps[key] = value;
                }
            }
          }
          // Generate icon
          const item = iconToSVG(icon, customisations);
          const renderAttribs = item.attributes;
          // Inline display
          if (customisations.inline) {
            style.verticalAlign = '-0.125em';
          }
          if (mode === 'svg') {
            // Add style
            componentProps.style = _objectSpread(_objectSpread({}, style), customStyle);
            // Add icon stuff
            Object.assign(componentProps, renderAttribs);
            // Counter for ids based on "id" property to render icons consistently on server and client
            let localCounter = 0;
            let id = props.id;
            if (typeof id === 'string') {
              // Convert '-' to '_' to avoid errors in animations
              id = id.replace(/-/g, '_');
            }
            // Add icon stuff
            componentProps.dangerouslySetInnerHTML = {
              __html: cleanUpInnerHTML(replaceIDs(item.body, id ? () => id + 'ID' + localCounter++ : 'iconifyReact'))
            };
            return React.createElement('svg', componentProps);
          }
          // Render <span> with style
          const body = icon.body,
            width = icon.width,
            height = icon.height;
          const useMask = mode === 'mask' || (mode === 'bg' ? false : body.indexOf('currentColor') !== -1);
          // Generate SVG
          const html = iconToHTML(body, _objectSpread(_objectSpread({}, renderAttribs), {}, {
            width: width + '',
            height: height + ''
          }));
          // Generate style
          componentProps.style = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, style), {}, {
            '--svg': svgToURL(html),
            'width': fixSize(renderAttribs.width),
            'height': fixSize(renderAttribs.height)
          }, commonProps), useMask ? monotoneProps : coloredProps), customStyle);
          return React.createElement('span', componentProps);
        };
        /**
         * Initialise stuff
         */
        // Enable short names
        allowSimpleNames(true);
        // Set API module
        setAPIModule('', fetchAPIModule);
        /**
         * Browser stuff
         */
        if (typeof document !== 'undefined' && typeof window !== 'undefined') {
          // Set cache and load existing cache
          initBrowserStorage();
          const _window = window;
          // Load icons from global "IconifyPreload"
          if (_window.IconifyPreload !== void 0) {
            const preload = _window.IconifyPreload;
            const err = 'Invalid IconifyPreload syntax.';
            if (typeof preload === 'object' && preload !== null) {
              (preload instanceof Array ? preload : [preload]).forEach(item => {
                try {
                  if (
                  // Check if item is an object and not null/array
                  typeof item !== 'object' || item === null || item instanceof Array ||
                  // Check for 'icons' and 'prefix'
                  typeof item.icons !== 'object' || typeof item.prefix !== 'string' ||
                  // Add icon set
                  !addCollection(item)) {
                    console.error(err);
                  }
                } catch (e) {
                  console.error(err);
                }
              });
            }
          }
          // Set API from global "IconifyProviders"
          if (_window.IconifyProviders !== void 0) {
            const providers = _window.IconifyProviders;
            if (typeof providers === 'object' && providers !== null) {
              for (let key in providers) {
                const err = 'IconifyProviders[' + key + '] is invalid.';
                try {
                  const value = providers[key];
                  if (typeof value !== 'object' || !value || value.resources === void 0) {
                    continue;
                  }
                  if (!addAPIProvider(key, value)) {
                    console.error(err);
                  }
                } catch (e) {
                  console.error(err);
                }
              }
            }
          }
        }
        class IconComponent extends React.Component {
          constructor(props) {
            super(props);
            this.state = {
              // Render placeholder before component is mounted
              icon: null
            };
          }
          /**
           * Abort loading icon
           */
          _abortLoading() {
            if (this._loading) {
              this._loading.abort();
              this._loading = null;
            }
          }
          /**
           * Update state
           */
          _setData(icon) {
            if (this.state.icon !== icon) {
              this.setState({
                icon
              });
            }
          }
          /**
           * Check if icon should be loaded
           */
          _checkIcon(changed) {
            const state = this.state;
            const icon = this.props.icon;
            // Icon is an object
            if (typeof icon === 'object' && icon !== null && typeof icon.body === 'string') {
              // Stop loading
              this._icon = '';
              this._abortLoading();
              if (changed || state.icon === null) {
                // Set data if it was changed
                this._setData({
                  data: icon
                });
              }
              return;
            }
            // Invalid icon?
            let iconName;
            if (typeof icon !== 'string' || (iconName = stringToIcon(icon, false, true)) === null) {
              this._abortLoading();
              this._setData(null);
              return;
            }
            // Load icon
            const data = getIconData(iconName);
            if (!data) {
              // Icon data is not available
              if (!this._loading || this._loading.name !== icon) {
                // New icon to load
                this._abortLoading();
                this._icon = '';
                this._setData(null);
                if (data !== null) {
                  // Icon was not loaded
                  this._loading = {
                    name: icon,
                    abort: loadIcons([iconName], this._checkIcon.bind(this, false))
                  };
                }
              }
              return;
            }
            // Icon data is available
            if (this._icon !== icon || state.icon === null) {
              // New icon or icon has been loaded
              this._abortLoading();
              this._icon = icon;
              // Add classes
              const classes = ['iconify'];
              if (iconName.prefix !== '') {
                classes.push('iconify--' + iconName.prefix);
              }
              if (iconName.provider !== '') {
                classes.push('iconify--' + iconName.provider);
              }
              // Set data
              this._setData({
                data,
                classes
              });
              if (this.props.onLoad) {
                this.props.onLoad(icon);
              }
            }
          }
          /**
           * Component mounted
           */
          componentDidMount() {
            this._checkIcon(false);
          }
          /**
           * Component updated
           */
          componentDidUpdate(oldProps) {
            if (oldProps.icon !== this.props.icon) {
              this._checkIcon(true);
            }
          }
          /**
           * Abort loading
           */
          componentWillUnmount() {
            this._abortLoading();
          }
          /**
           * Render
           */
          render() {
            const props = this.props;
            const icon = this.state.icon;
            if (icon === null) {
              // Render placeholder
              return props.children ? props.children : React.createElement('span', {});
            }
            // Add classes
            let newProps = props;
            if (icon.classes) {
              newProps = _objectSpread(_objectSpread({}, props), {}, {
                className: (typeof props.className === 'string' ? props.className + ' ' : '') + icon.classes.join(' ')
              });
            }
            // Render icon
            return render(_objectSpread(_objectSpread({}, defaultIconProps), icon.data), newProps, props._inline, props._ref);
          }
        }
        /**
         * Block icon
         *
         * @param props - Component properties
         */
        const Icon = React.forwardRef(function Icon(props, ref) {
          const newProps = _objectSpread(_objectSpread({}, props), {}, {
            _ref: ref,
            _inline: false
          });
          return React.createElement(IconComponent, newProps);
        });
        /**
         * Inline icon (has negative verticalAlign that makes it behave like icon font)
         *
         * @param props - Component properties
         */
        React.forwardRef(function InlineIcon(props, ref) {
          const newProps = _objectSpread(_objectSpread({}, props), {}, {
            _ref: ref,
            _inline: true
          });
          return React.createElement(IconComponent, newProps);
        });
        const Iconify = exports("I", reactExports.forwardRef((_ref9, ref) => {
          let icon = _ref9.icon,
            _ref9$width = _ref9.width,
            width = _ref9$width === void 0 ? 20 : _ref9$width,
            sx = _ref9.sx,
            other = _objectWithoutProperties(_ref9, _excluded4);
          return /* @__PURE__ */jsxRuntimeExports.jsx(Box, _objectSpread({
            ref,
            component: Icon,
            className: "component-iconify",
            icon,
            sx: _objectSpread({
              width,
              height: width
            }, sx)
          }, other));
        }));
        Iconify.propTypes = {
          icon: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),
          sx: PropTypes.object,
          width: PropTypes.number
        };
        const ArrowDownIcon = props => /* @__PURE__ */jsxRuntimeExports.jsx(SvgIcon, _objectSpread(_objectSpread({}, props), {}, {
          children: /* @__PURE__ */jsxRuntimeExports.jsx("path", {
            d: "M12,16 C11.7663478,16.0004565 11.5399121,15.9190812 11.36,15.77 L5.36,10.77 C4.93474074,10.4165378 4.87653776,9.78525926 5.23,9.36 C5.58346224,8.93474074 6.21474074,8.87653776 6.64,9.23 L12,13.71 L17.36,9.39 C17.5665934,9.2222295 17.8315409,9.14373108 18.0961825,9.17188444 C18.3608241,9.2000378 18.6033268,9.33252029 18.77,9.54 C18.9551341,9.74785947 19.0452548,10.0234772 19.0186853,10.3005589 C18.9921158,10.5776405 18.8512608,10.8311099 18.63,11 L12.63,15.83 C12.444916,15.955516 12.2231011,16.0153708 12,16 Z"
          })
        }));
        const CheckboxIcon = props => /* @__PURE__ */jsxRuntimeExports.jsx(SvgIcon, _objectSpread(_objectSpread({}, props), {}, {
          children: /* @__PURE__ */jsxRuntimeExports.jsx("path", {
            d: "M17.9 2.318A5 5 0 0 1 22.895 7.1l.005.217v10a5 5 0 0 1-4.783 4.995l-.217.005h-10a5 5 0 0 1-4.995-4.783l-.005-.217v-10a5 5 0 0 1 4.783-4.996l.217-.004h10Zm-.5 1.5h-9a4 4 0 0 0-4 4v9a4 4 0 0 0 4 4h9a4 4 0 0 0 4-4v-9a4 4 0 0 0-4-4Z"
          })
        }));
        const CheckboxCheckedIcon = props => /* @__PURE__ */jsxRuntimeExports.jsx(SvgIcon, _objectSpread(_objectSpread({}, props), {}, {
          children: /* @__PURE__ */jsxRuntimeExports.jsx("path", {
            d: "M17 2a5 5 0 0 1 5 5v10a5 5 0 0 1-5 5H7a5 5 0 0 1-5-5V7a5 5 0 0 1 5-5Zm-1.625 7.255-4.13 4.13-1.75-1.75a.881.881 0 0 0-1.24 0c-.34.34-.34.89 0 1.24l2.38 2.37c.17.17.39.25.61.25.23 0 .45-.08.62-.25l4.75-4.75c.34-.34.34-.89 0-1.24a.881.881 0 0 0-1.24 0Z"
          })
        }));
        const CheckboxIndeterminateIcon = props => /* @__PURE__ */jsxRuntimeExports.jsx(SvgIcon, _objectSpread(_objectSpread({}, props), {}, {
          children: /* @__PURE__ */jsxRuntimeExports.jsx("path", {
            d: "M17,2 C19.7614,2 22,4.23858 22,7 L22,7 L22,17 C22,19.7614 19.7614,22 17,22 L17,22 L7,22 C4.23858,22 2,19.7614 2,17 L2,17 L2,7 C2,4.23858 4.23858,2 7,2 L7,2 Z M15,11 L9,11 C8.44772,11 8,11.4477 8,12 C8,12.5523 8.44772,13 9,13 L15,13 C15.5523,13 16,12.5523 16,12 C16,11.4477 15.5523,11 15,11 Z"
          })
        }));
        const RadioIcon = props => /* @__PURE__ */jsxRuntimeExports.jsx(SvgIcon, _objectSpread(_objectSpread({}, props), {}, {
          children: /* @__PURE__ */jsxRuntimeExports.jsx("path", {
            d: "M12 2A10 10 0 1 1 2 12C2 6.477 6.477 2 12 2Zm0 1.5a8.5 8.5 0 1 0 0 17 8.5 8.5 0 0 0 0-17Z"
          })
        }));
        const RadioCheckedIcon = props => /* @__PURE__ */jsxRuntimeExports.jsx(SvgIcon, _objectSpread(_objectSpread({}, props), {}, {
          children: /* @__PURE__ */jsxRuntimeExports.jsx("path", {
            d: "M12 2A10 10 0 1 1 2 12C2 6.477 6.477 2 12 2Zm0 1.5a8.5 8.5 0 1 0 0 17 8.5 8.5 0 0 0 0-17ZM12 7a5 5 0 1 1 0 10 5 5 0 0 1 0-10Z"
          })
        }));
        const RatingIcon = props => /* @__PURE__ */jsxRuntimeExports.jsx(SvgIcon, _objectSpread(_objectSpread({}, props), {}, {
          children: /* @__PURE__ */jsxRuntimeExports.jsx("path", {
            d: "M17.56,21 C17.4000767,21.0006435 17.2423316,20.9629218 17.1,20.89 L12,18.22 L6.9,20.89 C6.56213339,21.067663 6.15259539,21.0374771 5.8444287,20.8121966 C5.53626201,20.5869161 5.38323252,20.2058459 5.45,19.83 L6.45,14.2 L2.33,10.2 C2.06805623,9.93860108 1.9718844,9.55391377 2.08,9.2 C2.19824414,8.83742187 2.51242293,8.57366684 2.89,8.52 L8.59,7.69 L11.1,2.56 C11.2670864,2.21500967 11.6166774,1.99588989 12,1.99588989 C12.3833226,1.99588989 12.7329136,2.21500967 12.9,2.56 L15.44,7.68 L21.14,8.51 C21.5175771,8.56366684 21.8317559,8.82742187 21.95,9.19 C22.0581156,9.54391377 21.9619438,9.92860108 21.7,10.19 L17.58,14.19 L18.58,19.82 C18.652893,20.2027971 18.4967826,20.5930731 18.18,20.82 C17.9989179,20.9468967 17.7808835,21.010197 17.56,21 L17.56,21 Z"
          })
        }));
        const TreeViewCollapseIcon = props => /* @__PURE__ */jsxRuntimeExports.jsx(SvgIcon, _objectSpread(_objectSpread({}, props), {}, {
          children: /* @__PURE__ */jsxRuntimeExports.jsx("path", {
            d: "M18,3 C19.6568542,3 21,4.34314575 21,6 L21,6 L21,18 C21,19.6568542 19.6568542,21 18,21 L18,21 L6,21 C4.34314575,21 3,19.6568542 3,18 L3,18 L3,6 C3,4.34314575 4.34314575,3 6,3 L6,3 Z M18,5 L6,5 C5.44771525,5 5,5.44771525 5,6 L5,6 L5,18 C5,18.5522847 5.44771525,19 6,19 L6,19 L18,19 C18.5522847,19 19,18.5522847 19,18 L19,18 L19,6 C19,5.44771525 18.5522847,5 18,5 L18,5 Z M12,8 C12.5522847,8 13,8.44771525 13,9 L13,9 L13,11 L15,11 C15.5522847,11 16,11.4477153 16,12 C16,12.5522847 15.5522847,13 15,13 L15,13 L13,13 L13,15 C13,15.5522847 12.5522847,16 12,16 C11.4477153,16 11,15.5522847 11,15 L11,15 L11,13 L9,13 C8.44771525,13 8,12.5522847 8,12 C8,11.4477153 8.44771525,11 9,11 L9,11 L11,11 L11,9 C11,8.44771525 11.4477153,8 12,8 Z"
          })
        }));
        const TreeViewExpandIcon = props => /* @__PURE__ */jsxRuntimeExports.jsx(SvgIcon, _objectSpread(_objectSpread({}, props), {}, {
          children: /* @__PURE__ */jsxRuntimeExports.jsx("path", {
            d: "M18,3 C19.6568542,3 21,4.34314575 21,6 L21,6 L21,18 C21,19.6568542 19.6568542,21 18,21 L18,21 L6,21 C4.34314575,21 3,19.6568542 3,18 L3,18 L3,6 C3,4.34314575 4.34314575,3 6,3 L6,3 Z M18,5 L6,5 C5.44771525,5 5,5.44771525 5,6 L5,6 L5,18 C5,18.5522847 5.44771525,19 6,19 L6,19 L18,19 C18.5522847,19 19,18.5522847 19,18 L19,18 L19,6 C19,5.44771525 18.5522847,5 18,5 L18,5 Z M15,11 C15.5522847,11 16,11.4477153 16,12 C16,12.5522847 15.5522847,13 15,13 L15,13 L9,13 C8.44771525,13 8,12.5522847 8,12 C8,11.4477153 8.44771525,11 9,11 L9,11 Z"
          })
        }));
        const TreeViewEndIcon = props => /* @__PURE__ */jsxRuntimeExports.jsx(SvgIcon, _objectSpread(_objectSpread({}, props), {}, {
          children: /* @__PURE__ */jsxRuntimeExports.jsx("path", {
            d: "M18,3 C19.6568542,3 21,4.34314575 21,6 L21,6 L21,18 C21,19.6568542 19.6568542,21 18,21 L18,21 L6,21 C4.34314575,21 3,19.6568542 3,18 L3,18 L3,6 C3,4.34314575 4.34314575,3 6,3 L6,3 Z M18,5 L6,5 C5.44771525,5 5,5.44771525 5,6 L5,6 L5,18 C5,18.5522847 5.44771525,19 6,19 L6,19 L18,19 C18.5522847,19 19,18.5522847 19,18 L19,18 L19,6 C19,5.44771525 18.5522847,5 18,5 L18,5 Z M14,8.99420168 C14.2666375,8.99420168 14.5222334,9.10068735 14.71,9.29 C14.8993127,9.4777666 15.0057983,9.73336246 15.0057983,10 C15.0057983,10.2666375 14.8993127,10.5222334 14.71,10.71 L14.71,10.71 L13.41,12 L14.71,13.29 C14.8993127,13.4777666 15.0057983,13.7333625 15.0057983,14 C15.0057983,14.2666375 14.8993127,14.5222334 14.71,14.71 C14.5222334,14.8993127 14.2666375,15.0057983 14,15.0057983 C13.7333625,15.0057983 13.4777666,14.8993127 13.29,14.71 L13.29,14.71 L12,13.41 L10.71,14.71 C10.5222334,14.8993127 10.2666375,15.0057983 10,15.0057983 C9.73336246,15.0057983 9.4777666,14.8993127 9.29,14.71 C9.10068735,14.5222334 8.99420168,14.2666375 8.99420168,14 C8.99420168,13.7333625 9.10068735,13.4777666 9.29,13.29 L9.29,13.29 L10.59,12 L9.29,10.71 C8.89787783,10.3178778 8.89787783,9.68212217 9.29,9.29 C9.68212217,8.89787783 10.3178778,8.89787783 10.71,9.29 L10.71,9.29 L12,10.59 L13.29,9.29 C13.4777666,9.10068735 13.7333625,8.99420168 14,8.99420168 Z"
          })
        }));
        function defaultProps(theme) {
          return {
            MuiAlert: {
              defaultProps: {
                iconMapping: {
                  error: /* @__PURE__ */jsxRuntimeExports.jsx(Iconify, {
                    icon: "solar:danger-linear",
                    width: 24
                  }),
                  info: /* @__PURE__ */jsxRuntimeExports.jsx(Iconify, {
                    icon: "carbon:information",
                    width: 24
                  }),
                  success: /* @__PURE__ */jsxRuntimeExports.jsx(Iconify, {
                    icon: "carbon:checkmark-outline",
                    width: 24
                  }),
                  warning: /* @__PURE__ */jsxRuntimeExports.jsx(Iconify, {
                    icon: "carbon:warning-alt",
                    width: 24
                  })
                }
              }
            },
            MuiStack: {
              defaultProps: {
                useFlexGap: true
              }
            },
            MuiAppBar: {
              defaultProps: {
                color: "transparent"
              }
            },
            MuiAvatarGroup: {
              defaultProps: {
                max: 4
              }
            },
            MuiButtonGroup: {
              defaultProps: {
                disableElevation: true
              }
            },
            MuiButton: {
              defaultProps: {
                color: "inherit",
                disableElevation: true
              }
            },
            MuiCardHeader: {
              defaultProps: {
                titleTypographyProps: {
                  variant: "h6"
                },
                subheaderTypographyProps: {
                  variant: "body2",
                  marginTop: theme.spacing(0.5)
                }
              }
            },
            MuiChip: {
              defaultProps: {
                deleteIcon: /* @__PURE__ */jsxRuntimeExports.jsx(Iconify, {
                  icon: "solar:close-circle-bold"
                })
              }
            },
            MuiDialogActions: {
              defaultProps: {
                disableSpacing: true
              }
            },
            MuiFab: {
              defaultProps: {
                color: "primary"
              }
            },
            MuiLink: {
              defaultProps: {
                underline: "hover"
              }
            },
            MuiListItemText: {
              defaultProps: {
                primaryTypographyProps: {
                  typography: "subtitle2"
                },
                secondaryTypographyProps: {
                  component: "span"
                }
              }
            },
            MuiPaper: {
              defaultProps: {
                elevation: 0
              }
            },
            MuiSkeleton: {
              defaultProps: {
                animation: "wave",
                variant: "rounded"
              }
            },
            MuiFilledInput: {
              defaultProps: {
                disableUnderline: true
              }
            },
            MuiFormHelperText: {
              defaultProps: {
                component: "div"
              }
            },
            MuiTab: {
              defaultProps: {
                disableRipple: true,
                iconPosition: "start"
              }
            },
            MuiTabs: {
              defaultProps: {
                textColor: "inherit",
                variant: "scrollable",
                allowScrollButtonsMobile: true
              }
            },
            MuiTablePagination: {
              defaultProps: {
                backIconButtonProps: {
                  size: "small"
                },
                nextIconButtonProps: {
                  size: "small"
                }
              }
            },
            MuiSlider: {
              defaultProps: {
                size: "small"
              }
            },
            MuiAutocomplete: {
              defaultProps: {
                popupIcon: /* @__PURE__ */jsxRuntimeExports.jsx(ArrowDownIcon, {})
              }
            },
            MuiSelect: {
              defaultProps: {
                IconComponent: ArrowDownIcon
              }
            },
            MuiNativeSelect: {
              defaultProps: {
                IconComponent: ArrowDownIcon
              }
            },
            MuiCheckbox: {
              defaultProps: {
                size: "small",
                icon: /* @__PURE__ */jsxRuntimeExports.jsx(CheckboxIcon, {}),
                checkedIcon: /* @__PURE__ */jsxRuntimeExports.jsx(CheckboxCheckedIcon, {}),
                indeterminateIcon: /* @__PURE__ */jsxRuntimeExports.jsx(CheckboxIndeterminateIcon, {})
              }
            },
            MuiRadio: {
              defaultProps: {
                size: "small",
                icon: /* @__PURE__ */jsxRuntimeExports.jsx(RadioIcon, {}),
                checkedIcon: /* @__PURE__ */jsxRuntimeExports.jsx(RadioCheckedIcon, {})
              }
            },
            MuiRating: {
              defaultProps: {
                emptyIcon: /* @__PURE__ */jsxRuntimeExports.jsx(RatingIcon, {}),
                icon: /* @__PURE__ */jsxRuntimeExports.jsx(RatingIcon, {})
              }
            },
            MuiTreeView: {
              defaultProps: {
                defaultCollapseIcon: /* @__PURE__ */jsxRuntimeExports.jsx(TreeViewCollapseIcon, {}),
                defaultExpandIcon: /* @__PURE__ */jsxRuntimeExports.jsx(TreeViewExpandIcon, {}),
                defaultEndIcon: /* @__PURE__ */jsxRuntimeExports.jsx(TreeViewEndIcon, {})
              }
            },
            // Zone
            MuiFormControl: {
              defaultProps: {
                variant: "filled"
              }
            },
            MuiTextField: {
              defaultProps: {
                variant: "filled"
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function tooltip(theme) {
          const lightMode = theme.palette.mode === 'light';
          return {
            MuiTooltip: {
              styleOverrides: {
                tooltip: {
                  backgroundColor: theme.palette.grey[lightMode ? 800 : 700]
                },
                arrow: {
                  color: theme.palette.grey[lightMode ? 800 : 700]
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function stepper(theme) {
          return {
            MuiStepConnector: {
              styleOverrides: {
                line: {
                  borderColor: theme.palette.divider
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function svgIcon(theme) {
          return {
            MuiSvgIcon: {
              styleOverrides: {
                fontSizeLarge: {
                  width: 32,
                  height: 32,
                  fontSize: 'inherit'
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function timeline(theme) {
          return {
            MuiTimelineDot: {
              styleOverrides: {
                root: {
                  boxShadow: 'none'
                }
              }
            },
            MuiTimelineConnector: {
              styleOverrides: {
                root: {
                  backgroundColor: theme.palette.divider
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function backdrop(theme) {
          return {
            MuiBackdrop: {
              styleOverrides: {
                root: {
                  backgroundColor: alpha(theme.palette.grey[900], 0.8)
                },
                invisible: {
                  background: 'transparent'
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function skeleton(theme) {
          return {
            MuiSkeleton: {
              styleOverrides: {
                root: {
                  backgroundColor: theme.palette.background.neutral
                },
                rounded: {
                  borderRadius: theme.shape.borderRadius * 2
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        const COLORS$3 = ['primary', 'secondary', 'info', 'success', 'warning', 'error'];

        // ----------------------------------------------------------------------

        function progress(theme) {
          const rootStyles = ownerState => {
            const bufferVariant = ownerState.variant === 'buffer';
            const defaultStyle = _objectSpread({
              borderRadius: 4,
              [`& .${linearProgressClasses.bar}`]: {
                borderRadius: 4
              }
            }, bufferVariant && {
              backgroundColor: 'transparent'
            });
            const colorStyle = COLORS$3.map(color => _objectSpread({}, ownerState.color === color && {
              backgroundColor: alpha(theme.palette[color].main, 0.24)
            }));
            return [defaultStyle, ...colorStyle];
          };
          return {
            MuiLinearProgress: {
              styleOverrides: {
                root: ({
                  ownerState
                }) => rootStyles(ownerState)
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function checkbox(theme) {
          return {
            MuiCheckbox: {
              styleOverrides: {
                root: ({
                  ownerState
                }) => {
                  const color = ownerState.color;
                  return _objectSpread(_objectSpread({
                    padding: theme.spacing(1)
                  }, color === 'default' && {
                    [`&.${checkboxClasses.checked}`]: {
                      color: theme.palette.text.primary
                    }
                  }), {}, {
                    [`&.${checkboxClasses.disabled}`]: {
                      color: theme.palette.action.disabled
                    }
                  });
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function dataGrid(theme) {
          const paperStyles = paper$1({
            theme,
            dropdown: true
          });
          return {
            MuiDataGrid: {
              styleOverrides: {
                root: {
                  '--unstable_DataGrid-radius': 0,
                  '--unstable_DataGrid-headWeight': theme.typography.fontWeightSemiBold,
                  borderWidth: 0
                },
                withBorderColor: {
                  borderColor: theme.palette.divider
                },
                // Column
                columnHeaders: {
                  borderBottom: 0
                },
                columnHeader: {
                  fontSize: 14,
                  color: theme.palette.text.secondary,
                  backgroundColor: theme.palette.background.neutral,
                  '&--sorted': {
                    color: theme.palette.text.primary
                  }
                },
                columnSeparator: {
                  color: theme.palette.divider
                },
                // Row, Cell
                cell: {
                  borderBottom: `1px dashed`,
                  '&--editing': {
                    boxShadow: 'none !important',
                    backgroundColor: `${alpha(theme.palette.primary.main, 0.08)} !important`
                  }
                },
                // Toolbar
                toolbarContainer: {
                  gap: theme.spacing(2),
                  padding: theme.spacing(2)
                },
                toolbarQuickFilter: {
                  padding: 0,
                  width: '100%',
                  [theme.breakpoints.up('md')]: {
                    width: 'unset'
                  }
                },
                // Paper
                paper: _objectSpread(_objectSpread({}, paperStyles), {}, {
                  padding: 0
                }),
                menu: {
                  [`& .${paperClasses.root}`]: _objectSpread(_objectSpread({}, paperStyles), {}, {
                    minWidth: 140
                  }),
                  [`& .${listClasses.root}`]: {
                    padding: 0,
                    [`& .${listItemIconClasses.root}`]: {
                      minWidth: 0,
                      marginRight: theme.spacing(2)
                    }
                  }
                },
                // Icons
                menuIcon: {
                  [`& .${iconButtonClasses.root}`]: {
                    margin: theme.spacing(0, 1),
                    padding: theme.spacing(0.25)
                  }
                },
                iconButtonContainer: {
                  [`& .${iconButtonClasses.root}`]: {
                    padding: theme.spacing(0.25),
                    marginLeft: theme.spacing(1)
                  }
                },
                // Footer
                footerContainer: {
                  minHeight: 'auto',
                  borderTop: `1px dashed`
                },
                selectedRowCount: {
                  display: 'none',
                  whiteSpace: 'nowrap'
                },
                overlay: {
                  [`& .${circularProgressClasses.root}`]: {
                    color: theme.palette.text.primary
                  }
                },
                // Columns Panel
                panelHeader: {
                  padding: theme.spacing(2, 2, 0, 2)
                },
                panelContent: {
                  padding: theme.spacing(1)
                },
                columnsPanelRow: {
                  margin: theme.spacing(0.5, 0)
                },
                panelFooter: {
                  display: 'none',
                  gap: theme.spacing(1),
                  padding: theme.spacing(2),
                  justifyContent: 'flex-end',
                  borderTop: `dashed 1px ${theme.palette.divider}`,
                  [`& .${buttonClasses.root}`]: {
                    padding: theme.spacing(0.5, 1.5),
                    '&:first-of-type': {
                      border: `solid 1px ${alpha(theme.palette.grey[500], 0.24)}`
                    },
                    '&:last-of-type': {
                      color: theme.palette.background.paper,
                      backgroundColor: theme.palette.text.primary
                    }
                  }
                },
                filterForm: {
                  alignItems: 'center',
                  gap: theme.spacing(1.5),
                  padding: theme.spacing(1)
                },
                filterFormValueInput: {
                  [`& .${formControlClasses.root}`]: {
                    width: '100%'
                  },
                  [`& .${inputLabelClasses.root}`]: {
                    transform: 'translate(14px, -9px) scale(0.75)'
                  }
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function treeView(theme) {
          return {
            MuiTreeItem: {
              styleOverrides: {
                label: _objectSpread({}, theme.typography.body2),
                iconContainer: {
                  width: 'auto'
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function textField(theme) {
          const color = {
            focused: theme.palette.text.primary,
            active: theme.palette.text.secondary,
            placeholder: theme.palette.text.disabled
          };
          const font = {
            label: theme.typography.body1,
            value: theme.typography.body2
          };
          return {
            // HELPER
            MuiFormHelperText: {
              styleOverrides: {
                root: {
                  marginTop: theme.spacing(1)
                }
              }
            },
            // LABEL
            MuiFormLabel: {
              styleOverrides: {
                root: _objectSpread(_objectSpread({}, font.value), {}, {
                  color: color.placeholder,
                  [`&.${inputLabelClasses.shrink}`]: _objectSpread(_objectSpread({}, font.label), {}, {
                    fontWeight: 600,
                    color: color.active,
                    [`&.${inputLabelClasses.focused}`]: {
                      color: color.focused
                    },
                    [`&.${inputLabelClasses.error}`]: {
                      color: theme.palette.error.main
                    },
                    [`&.${inputLabelClasses.disabled}`]: {
                      color: theme.palette.text.disabled
                    },
                    [`&.${inputLabelClasses.filled}`]: {
                      transform: 'translate(12px, 6px) scale(0.75)'
                    }
                  })
                })
              }
            },
            // BASE
            MuiInputBase: {
              styleOverrides: {
                root: {
                  [`&.${inputBaseClasses.disabled}`]: {
                    '& svg': {
                      color: theme.palette.text.disabled
                    }
                  }
                },
                input: _objectSpread(_objectSpread({}, font.value), {}, {
                  '&::placeholder': {
                    opacity: 1,
                    color: color.placeholder
                  }
                })
              }
            },
            // STANDARD
            MuiInput: {
              styleOverrides: {
                underline: {
                  '&:before': {
                    borderBottomColor: alpha(theme.palette.grey[500], 0.32)
                  },
                  '&:after': {
                    borderBottomColor: color.focused
                  }
                }
              }
            },
            // OUTLINED
            MuiOutlinedInput: {
              styleOverrides: {
                root: {
                  [`&.${outlinedInputClasses.focused}`]: {
                    [`& .${outlinedInputClasses.notchedOutline}`]: {
                      borderColor: color.focused
                    }
                  },
                  [`&.${outlinedInputClasses.error}`]: {
                    [`& .${outlinedInputClasses.notchedOutline}`]: {
                      borderColor: theme.palette.error.main
                    }
                  },
                  [`&.${outlinedInputClasses.disabled}`]: {
                    [`& .${outlinedInputClasses.notchedOutline}`]: {
                      borderColor: theme.palette.action.disabledBackground
                    }
                  }
                },
                notchedOutline: {
                  borderColor: alpha(theme.palette.grey[500], 0.2),
                  transition: theme.transitions.create(['border-color'], {
                    duration: theme.transitions.duration.shortest
                  })
                }
              }
            },
            // FILLED
            MuiFilledInput: {
              styleOverrides: {
                root: {
                  borderRadius: theme.shape.borderRadius,
                  backgroundColor: alpha(theme.palette.grey[500], 0.08),
                  '&:hover': {
                    backgroundColor: alpha(theme.palette.grey[500], 0.16)
                  },
                  [`&.${filledInputClasses.focused}`]: {
                    backgroundColor: alpha(theme.palette.grey[500], 0.16)
                  },
                  [`&.${filledInputClasses.error}`]: {
                    backgroundColor: alpha(theme.palette.error.main, 0.08),
                    [`&.${filledInputClasses.focused}`]: {
                      backgroundColor: alpha(theme.palette.error.main, 0.16)
                    }
                  },
                  [`&.${filledInputClasses.disabled}`]: {
                    backgroundColor: theme.palette.action.disabledBackground
                  }
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function accordion(theme) {
          return {
            MuiAccordion: {
              styleOverrides: {
                root: {
                  backgroundColor: 'transparent',
                  [`&.${accordionClasses.expanded}`]: {
                    boxShadow: theme.customShadows.z8,
                    borderRadius: theme.shape.borderRadius,
                    backgroundColor: theme.palette.background.paper
                  },
                  [`&.${accordionClasses.disabled}`]: {
                    backgroundColor: 'transparent'
                  }
                }
              }
            },
            MuiAccordionSummary: {
              styleOverrides: {
                root: {
                  paddingLeft: theme.spacing(2),
                  paddingRight: theme.spacing(1),
                  [`&.${accordionSummaryClasses.disabled}`]: {
                    opacity: 1,
                    color: theme.palette.action.disabled,
                    [`& .${typographyClasses.root}`]: {
                      color: 'inherit'
                    }
                  }
                },
                expandIconWrapper: {
                  color: 'inherit'
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function typography(theme) {
          return {
            MuiTypography: {
              styleOverrides: {
                paragraph: {
                  marginBottom: theme.spacing(2)
                },
                gutterBottom: {
                  marginBottom: theme.spacing(1)
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        const COLORS$2 = ['primary', 'secondary', 'info', 'success', 'warning', 'error'];

        // ----------------------------------------------------------------------

        function pagination(theme) {
          const lightMode = theme.palette.mode === 'light';
          const rootStyles = ownerState => {
            const defaultColor = ownerState.color === 'standard';
            const filledVariant = ownerState.variant === 'text';
            const outlinedVariant = ownerState.variant === 'outlined';
            const softVariant = ownerState.variant === 'soft';
            const defaultStyle = {
              [`& .${paginationItemClasses.root}`]: _objectSpread(_objectSpread({}, outlinedVariant && {
                borderColor: alpha(theme.palette.grey[500], 0.24)
              }), {}, {
                [`&.${paginationItemClasses.selected}`]: _objectSpread(_objectSpread({
                  fontWeight: theme.typography.fontWeightSemiBold
                }, outlinedVariant && {
                  borderColor: 'currentColor'
                }), defaultColor && _objectSpread({
                  backgroundColor: alpha(theme.palette.grey[500], 0.08)
                }, filledVariant && {
                  color: lightMode ? theme.palette.common.white : theme.palette.grey[800],
                  backgroundColor: theme.palette.text.primary,
                  '&:hover': {
                    backgroundColor: lightMode ? theme.palette.grey[700] : theme.palette.grey[100]
                  }
                }))
              })
            };
            const colorStyle = COLORS$2.map(color => _objectSpread({}, ownerState.color === color && {
              [`& .${paginationItemClasses.root}`]: {
                [`&.${paginationItemClasses.selected}`]: _objectSpread({}, ownerState.color === color && _objectSpread({}, softVariant && {
                  color: theme.palette[color][lightMode ? 'dark' : 'light'],
                  backgroundColor: alpha(theme.palette[color].main, 0.08),
                  '&:hover': {
                    backgroundColor: alpha(theme.palette[color].main, 0.16)
                  }
                }))
              }
            }));
            return [defaultStyle, ...colorStyle];
          };
          return {
            MuiPagination: {
              styleOverrides: {
                root: ({
                  ownerState
                }) => rootStyles(ownerState)
              }
            }
          };
        }
        const dateList = ["DatePicker", "DateTimePicker", "StaticDatePicker", "DesktopDatePicker", "DesktopDateTimePicker",
        //
        "MobileDatePicker", "MobileDateTimePicker"];
        const timeList = ["TimePicker", "MobileTimePicker", "StaticTimePicker", "DesktopTimePicker"];
        const switchIcon = () => /* @__PURE__ */jsxRuntimeExports.jsx(Iconify, {
          icon: "eva:chevron-down-fill",
          width: 24
        });
        const leftIcon = () => /* @__PURE__ */jsxRuntimeExports.jsx(Iconify, {
          icon: "eva:arrow-ios-back-fill",
          width: 24
        });
        const rightIcon = () => /* @__PURE__ */jsxRuntimeExports.jsx(Iconify, {
          icon: "eva:arrow-ios-forward-fill",
          width: 24
        });
        const calendarIcon = () => /* @__PURE__ */jsxRuntimeExports.jsx(Iconify, {
          icon: "solar:calendar-minimalistic-linear",
          width: 24
        });
        const clockIcon = () => /* @__PURE__ */jsxRuntimeExports.jsx(Iconify, {
          icon: "solar:clock-circle-outline",
          width: 24
        });
        const desktopTypes = dateList.reduce((result, currentValue) => {
          result[`Mui${currentValue}`] = {
            defaultProps: {
              slots: {
                openPickerIcon: calendarIcon,
                leftArrowIcon: leftIcon,
                rightArrowIcon: rightIcon,
                switchViewIcon: switchIcon
              }
            }
          };
          return result;
        }, {});
        const timeTypes = timeList.reduce((result, currentValue) => {
          result[`Mui${currentValue}`] = {
            defaultProps: {
              slots: {
                openPickerIcon: clockIcon,
                rightArrowIcon: rightIcon,
                switchViewIcon: switchIcon
              }
            }
          };
          return result;
        }, {});
        function datePicker(theme) {
          return _objectSpread(_objectSpread({
            MuiPickersLayout: {
              styleOverrides: {
                root: {
                  "& .MuiPickersLayout-actionBar": {
                    [`& .${buttonClasses.root}:last-of-type`]: {
                      backgroundColor: theme.palette.text.primary,
                      color: theme.palette.mode === "light" ? theme.palette.common.white : theme.palette.grey[800]
                    }
                  }
                }
              }
            }
          }, desktopTypes), timeTypes);
        }

        // ----------------------------------------------------------------------

        function breadcrumbs(theme) {
          return {
            MuiBreadcrumbs: {
              styleOverrides: {
                separator: {
                  marginLeft: theme.spacing(2),
                  marginRight: theme.spacing(2)
                },
                li: {
                  display: 'inline-flex',
                  margin: theme.spacing(0.25, 0),
                  '& > *': _objectSpread({}, theme.typography.body2)
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function cssBaseline(theme) {
          return {
            MuiCssBaseline: {
              styleOverrides: {
                '*': {
                  boxSizing: 'border-box'
                },
                html: {
                  margin: 0,
                  padding: 0,
                  width: '100%',
                  height: '100%',
                  WebkitOverflowScrolling: 'touch'
                },
                body: {
                  margin: 0,
                  padding: 0,
                  width: '100%',
                  height: '100%'
                },
                '#root, #__next': {
                  width: '100%',
                  height: '100%'
                },
                input: {
                  '&[type=number]': {
                    MozAppearance: 'textfield',
                    '&::-webkit-outer-spin-button': {
                      margin: 0,
                      WebkitAppearance: 'none'
                    },
                    '&::-webkit-inner-spin-button': {
                      margin: 0,
                      WebkitAppearance: 'none'
                    }
                  }
                },
                img: {
                  maxWidth: '100%',
                  display: 'inline-block',
                  verticalAlign: 'bottom'
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        const COLORS$1 = ['primary', 'secondary', 'info', 'success', 'warning', 'error'];

        // ----------------------------------------------------------------------

        function buttonGroup(theme) {
          const rootStyles = ownerState => {
            const inheritColor = ownerState.color === 'inherit';
            const containedVariant = ownerState.variant === 'contained';
            const outlinedVariant = ownerState.variant === 'outlined';
            const textVariant = ownerState.variant === 'text';
            const softVariant = ownerState.variant === 'soft';
            const horizontalOrientation = ownerState.orientation === 'horizontal';
            const verticalOrientation = ownerState.orientation === 'vertical';
            const defaultStyle = {
              [`& .${buttonGroupClasses.grouped}`]: {
                '&:not(:last-of-type)': _objectSpread({}, !outlinedVariant && _objectSpread(_objectSpread(_objectSpread({
                  borderStyle: 'solid'
                }, inheritColor && {
                  borderColor: alpha(theme.palette.grey[500], 0.32)
                }), horizontalOrientation && {
                  borderWidth: '0px 1px 0px 0px'
                }), verticalOrientation && {
                  borderWidth: '0px 0px 1px 0px'
                }))
              }
            };
            const colorStyle = COLORS$1.map(color => ({
              [`& .${buttonGroupClasses.grouped}`]: {
                '&:not(:last-of-type)': _objectSpread({}, !outlinedVariant && _objectSpread({}, ownerState.color === color && _objectSpread(_objectSpread(_objectSpread({}, containedVariant && {
                  borderColor: alpha(theme.palette[color].dark, 0.48)
                }), textVariant && {
                  borderColor: alpha(theme.palette[color].main, 0.48)
                }), softVariant && {
                  borderColor: alpha(theme.palette[color].dark, 0.24)
                })))
              }
            }));
            const disabledState = {
              [`& .${buttonGroupClasses.grouped}`]: {
                [`&.${buttonGroupClasses.disabled}`]: {
                  '&:not(:last-of-type)': {
                    borderColor: theme.palette.action.disabledBackground
                  }
                }
              }
            };
            return [defaultStyle, ...colorStyle, disabledState];
          };
          return {
            MuiButtonGroup: {
              styleOverrides: {
                root: ({
                  ownerState
                }) => rootStyles(ownerState)
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function autocomplete(theme) {
          return {
            MuiAutocomplete: {
              styleOverrides: {
                root: {
                  [`& span.${autocompleteClasses.tag}`]: _objectSpread(_objectSpread({}, theme.typography.subtitle2), {}, {
                    height: 24,
                    minWidth: 24,
                    lineHeight: '24px',
                    textAlign: 'center',
                    padding: theme.spacing(0, 0.75),
                    color: theme.palette.text.secondary,
                    borderRadius: theme.shape.borderRadius,
                    backgroundColor: alpha(theme.palette.grey[500], 0.16)
                  })
                },
                paper: _objectSpread({}, paper$1({
                  theme,
                  dropdown: true
                })),
                listbox: {
                  padding: 0,
                  [`& .${autocompleteClasses.option}`]: _objectSpread({}, menuItem(theme))
                },
                endAdornment: {
                  [`& .${svgIconClasses.root}`]: {
                    width: 18,
                    height: 18
                  }
                }
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        const COLORS = ['primary', 'secondary', 'info', 'success', 'warning', 'error'];

        // ----------------------------------------------------------------------

        function toggleButton(theme) {
          const rootStyles = ownerState => {
            const defaultStyle = {
              [`&.${toggleButtonClasses.selected}`]: {
                borderColor: 'currentColor',
                boxShadow: '0 0 0 0.5px currentColor'
              }
            };
            const colorStyle = COLORS.map(color => _objectSpread({}, ownerState.color === color && {
              '&:hover': {
                borderColor: alpha(theme.palette[color].main, 0.48),
                backgroundColor: alpha(theme.palette[color].main, theme.palette.action.hoverOpacity)
              }
            }));
            const disabledState = {
              [`&.${toggleButtonClasses.disabled}`]: {
                [`&.${toggleButtonClasses.selected}`]: {
                  color: theme.palette.action.disabled,
                  backgroundColor: theme.palette.action.selected,
                  borderColor: theme.palette.action.disabledBackground
                }
              }
            };
            return [defaultStyle, ...colorStyle, disabledState];
          };
          return {
            MuiToggleButton: {
              styleOverrides: {
                root: ({
                  ownerState
                }) => rootStyles(ownerState)
              }
            },
            MuiToggleButtonGroup: {
              styleOverrides: {
                root: {
                  borderRadius: theme.shape.borderRadius,
                  backgroundColor: theme.palette.background.paper,
                  border: `solid 1px ${alpha(theme.palette.grey[500], 0.08)}`
                },
                grouped: {
                  margin: 4,
                  [`&.${toggleButtonClasses.selected}`]: {
                    boxShadow: 'none'
                  },
                  '&:not(:first-of-type), &:not(:last-of-type)': {
                    borderRadius: theme.shape.borderRadius,
                    borderColor: 'transparent'
                  }
                }
              }
            }
          };
        }
        function getLoadingButtonUtilityClass(slot) {
          return generateUtilityClass('MuiLoadingButton', slot);
        }
        const loadingButtonClasses = exports("l", generateUtilityClasses('MuiLoadingButton', ['root', 'loading', 'loadingIndicator', 'loadingIndicatorCenter', 'loadingIndicatorStart', 'loadingIndicatorEnd', 'endIconLoadingEnd', 'startIconLoadingStart']));

        // ----------------------------------------------------------------------

        function loadingButton(theme) {
          return {
            MuiLoadingButton: {
              styleOverrides: {
                root: ({
                  ownerState
                }) => _objectSpread({}, ownerState.variant === 'soft' && _objectSpread({
                  [`& .${loadingButtonClasses.loadingIndicatorStart}`]: {
                    left: 10
                  },
                  [`& .${loadingButtonClasses.loadingIndicatorEnd}`]: {
                    right: 14
                  }
                }, ownerState.size === 'small' && {
                  [`& .${loadingButtonClasses.loadingIndicatorStart}`]: {
                    left: 10
                  },
                  [`& .${loadingButtonClasses.loadingIndicatorEnd}`]: {
                    right: 10
                  }
                }))
              }
            }
          };
        }

        // ----------------------------------------------------------------------

        function componentsOverrides(theme) {
          const components = merge(defaultProps(theme),
          //
          fab(theme), tabs(theme), chip(theme), card(theme), menu(theme), list(theme), badge(theme), table(theme), paper(theme), alert(theme), radio(theme), select(), button(theme), rating(theme), dialog(theme), appBar(), avatar(theme), slider(theme), drawer(theme), stepper(theme), tooltip(theme), popover(theme), svgIcon(), switches(theme), checkbox(theme), dataGrid(theme), skeleton(theme), timeline(theme), treeView(theme), backdrop(theme), progress(theme), textField(theme), accordion(theme), typography(theme), pagination(theme), datePicker(theme), buttonGroup(theme), breadcrumbs(theme), cssBaseline(), autocomplete(theme), toggleButton(theme), loadingButton());
          return components;
        }

        // ----------------------------------------------------------------------

        function createPresets(preset) {
          const _getPrimary = getPrimary(preset),
            primaryColor = _getPrimary.primary,
            secondaryColor = _getPrimary.secondary;
          const theme = {
            palette: {
              primary: primaryColor,
              secondary: secondaryColor
            },
            customShadows: {
              primary: `0 8px 16px 0 ${alpha(`${primaryColor.main}`, 0.24)}`,
              secondary: `0 8px 16px 0 ${alpha(`${secondaryColor.main}`, 0.24)}`
            }
          };
          return _objectSpread({}, theme);
        }
        [{
          name: "default",
          value: [primary.main, secondary.main]
        }];
        function getPrimary(preset) {
          return {
            default: {
              primary,
              secondary
            }
          }[preset];
        }
        function ThemeProvider({
          children
        }) {
          const themeMode = "light";
          const lang = CookiesService.getValue("lang");
          const presets = createPresets("default");
          const direction = reactExports.useMemo(() => rtlLanguage.includes(lang) ? "rtl" : "ltr", [lang]);
          const theme = createTheme$1({
            palette: _objectSpread(_objectSpread({}, palette(themeMode)), presets.palette),
            customShadows: _objectSpread(_objectSpread({}, customShadows()), presets.customShadows),
            direction: "ltr",
            shadows: shadows(),
            shape: {
              borderRadius: 8
            },
            typography: typography$1
          });
          theme.components = componentsOverrides(theme);
          return /* @__PURE__ */jsxRuntimeExports.jsx(ThemeProvider$1, {
            theme,
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(RTL, {
              themeDirection: direction,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(CssBaseline, {}), children]
            })
          });
        }
        ThemeProvider.propTypes = {
          children: PropTypes.node
        };
        function UnsupportedView() {
          const _useTranslation3 = useTranslation("manage"),
            t = _useTranslation3.t;
          return /* @__PURE__ */jsxRuntimeExports.jsx(CompactLayout, {
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Typography, {
                variant: "h4",
                paragraph: true,
                children: t("mobile_view")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Typography, {
                sx: {
                  color: "text.secondary"
                },
                children: t("mobile_view_working")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Image$1, {
                alt: "maintenance",
                src: "/illustration_maintenance.svg",
                sx: {
                  mx: "auto",
                  maxWidth: 320,
                  my: {
                    xs: 5,
                    sm: 8
                  }
                }
              })]
            })
          });
        }
        const ManagePageWrapper = ({
          showHeader = true,
          children
        }) => {
          const lang = CookiesService.getValue("lang");
          const _useTranslation4 = useTranslation("manage"),
            i18n = _useTranslation4.i18n;
          const _reactExports$useStat9 = reactExports.useState(() => {
              const minWidth = 768;
              const minHeight = 600;
              return window.innerWidth >= minWidth && window.innerHeight >= minHeight;
            }),
            _reactExports$useStat10 = _slicedToArray(_reactExports$useStat9, 2),
            isSupportedScreenSize = _reactExports$useStat10[0],
            setIsSupportedScreenSize = _reactExports$useStat10[1];
          reactExports.useEffect(() => {
            document.body.style.overflow = "hidden";
            setLangFromSession(i18n);
          }, [lang]);
          const cacheRtlMemo = reactExports.useMemo(() => cacheRtl(lang), [lang]);
          reactExports.useEffect(() => {
            const checkScreenSize = () => {
              const minWidth = 768;
              const minHeight = 600;
              if (window.innerWidth < minWidth || window.innerHeight < minHeight) {
                setIsSupportedScreenSize(false);
              } else {
                setIsSupportedScreenSize(true);
              }
            };
            window.addEventListener("resize", checkScreenSize);
            return () => {
              window.removeEventListener("resize", checkScreenSize);
            };
          }, []);
          if (!isSupportedScreenSize) {
            return /* @__PURE__ */jsxRuntimeExports.jsx(UnsupportedView, {});
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(CacheProvider, {
            value: cacheRtlMemo,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(Provider, {
              store: manageStore,
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(ThemeProvider, {
                children: [showHeader && /* @__PURE__ */jsxRuntimeExports.jsx(Header, {}), /* @__PURE__ */jsxRuntimeExports.jsx(ErrorWrapper, {}), /* @__PURE__ */jsxRuntimeExports.jsx(StatefulLoadingIndicator, {}), children]
              })
            })
          });
        };
        const savingProgress = "_savingProgress_tmvkb_1";
        const snackBar = "_snackBar_tmvkb_7";
        const styles$6 = {
          savingProgress: savingProgress,
          snackBar: snackBar
        };
        function SavingSurvey() {
          const isSaving = useSelector(state => {
            return state.designState.isSaving || state.editState.isSaving;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx(Snackbar, {
            open: isSaving,
            className: styles$6.snackBar,
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(Alert, {
              severity: "warning",
              children: ["Saving Survey...", " ", /* @__PURE__ */jsxRuntimeExports.jsx(CircularProgress, {
                className: styles$6.savingProgress,
                color: "warning"
              })]
            })
          });
        }
        const wrapper$1 = "_wrapper_1tgcz_2";
        const styles$5 = {
          wrapper: wrapper$1
        };
        const styles$4 = {};
        const BaseLanguage = ({
          baseLanguage,
          onBaseLanguageChanged,
          disabled
        }) => {
          const _useTranslation5 = useTranslation("manage"),
            t = _useTranslation5.t;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
            fullWidth: true,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(InputLabel, {
              id: "label-base-language",
              children: t("label.base_language")
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Select, {
              disabled,
              labelId: "label-base-language",
              value: baseLanguage,
              label: t("label.base_language"),
              onChange: onBaseLanguageChanged,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                value: "en",
                children: LANGUAGE_DEF["en"].name
              }), /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                value: "de",
                children: LANGUAGE_DEF["de"].name
              }), /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                value: "ar",
                children: LANGUAGE_DEF["ar"].name
              })]
            })]
          });
        };
        const AdditionalLanguages = ({
          baseLanguage,
          onAdditionalLanguagesChanged,
          additionalLanguages,
          disabled
        }) => {
          const _useTranslation6 = useTranslation("manage"),
            t = _useTranslation6.t;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
            sx: {
              marginTop: "16px"
            },
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
              id: "additional-languages-label",
              children: t("label.additional_languages")
            }), Object.keys(LANGUAGE_DEF).map(key => {
              const el = LANGUAGE_DEF[key];
              return /* @__PURE__ */jsxRuntimeExports.jsx(FormControlLabel, {
                control: /* @__PURE__ */jsxRuntimeExports.jsx(Checkbox, {
                  disabled: baseLanguage == el.code || disabled,
                  checked: additionalLanguages.indexOf(el.code) > -1,
                  onChange: onAdditionalLanguagesChanged,
                  name: el.code
                }),
                label: el.name
              }, key);
            })]
          });
        };
        var Close = {};
        var _interopRequireDefault$3 = interopRequireDefaultExports;
        Object.defineProperty(Close, "__esModule", {
          value: true
        });
        var default_1$3 = exports("t", Close.default = void 0);
        var _createSvgIcon$3 = _interopRequireDefault$3(requireCreateSvgIcon());
        var _jsxRuntime$3 = jsxRuntimeExports;
        exports("t", default_1$3 = Close.default = (0, _createSvgIcon$3.default)(/*#__PURE__*/(0, _jsxRuntime$3.jsx)("path", {
          d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
        }), 'Close'));
        function ManageTranslations({
          onManageTranslationsClose,
          onStartTranslation
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Dialog, {
            fullWidth: true,
            maxWidth: "sm",
            open: true,
            onClose: onManageTranslationsClose,
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs(DialogTitle, {
              children: ["Translations", " ", /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                "aria-label": "close",
                onClick: onManageTranslationsClose,
                sx: {
                  position: "absolute",
                  right: 8,
                  top: 8,
                  color: theme => theme.palette.grey[500]
                },
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$3, {})
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(DialogContent, {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(ManageLanguages, {
                onTranlsationStarted: () => {
                  onManageTranslationsClose();
                  onStartTranslation();
                },
                onManageTranslationsClose
              })
            })]
          });
        }
        function ManageLanguages() {
          const dispatch = useDispatch();
          const langInfo = useSelector(state => {
            return state.designState.langInfo;
          });
          const lang = langInfo === null || langInfo === void 0 ? void 0 : langInfo.lang;
          const allLang = (langInfo === null || langInfo === void 0 ? void 0 : langInfo.languagesList) || [];
          const additionalLanguages = allLang.filter(e => langInfo.mainLang != e.code);
          const additionalLanguagesCodes = additionalLanguages.map(e => e.code);
          const onBaseLanguageChanged = e => {
            dispatch(onBaseLangChanged(LANGUAGE_DEF[e.target.value]));
          };
          const onAdditionalLanguagesChanged = e => {
            if (e.target.checked) {
              dispatch(onAdditionalLangAdded(LANGUAGE_DEF[e.target.name]));
            } else {
              dispatch(onAdditionalLangRemoved(LANGUAGE_DEF[e.target.name]));
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            sx: {
              paddingTop: "8px"
            },
            className: styles$4.blockItem,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(BaseLanguage, {
              onBaseLanguageChanged,
              baseLanguage: langInfo.mainLang
            }), /* @__PURE__ */jsxRuntimeExports.jsx("br", {}), /* @__PURE__ */jsxRuntimeExports.jsx(AdditionalLanguages, {
              onAdditionalLanguagesChanged,
              additionalLanguages: additionalLanguagesCodes,
              baseLanguage: langInfo.mainLang
            }), allLang.length > 1 && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Typography, {
                sx: {
                  marginTop: "16px",
                  marginBottom: "8px",
                  fontSize: "1em"
                },
                children: "Translate Survey To:"
              }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                fullWidth: true,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(InputLabel, {
                  id: "label-base-language",
                  children: "Language"
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Select, {
                  id: "ChangeLang",
                  value: lang,
                  label: "Design Language",
                  onChange: event => {
                    dispatch(changeLang(event.target.value));
                  },
                  children: allLang.map((lang2, index) => /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                    value: lang2.code,
                    children: lang2.name
                  }, index))
                })]
              })]
            })]
          });
        }
        var TableRows = {};
        var _interopRequireDefault$2 = interopRequireDefaultExports;
        Object.defineProperty(TableRows, "__esModule", {
          value: true
        });
        var default_1$2 = exports("d", TableRows.default = void 0);
        var _createSvgIcon$2 = _interopRequireDefault$2(requireCreateSvgIcon());
        var _jsxRuntime$2 = jsxRuntimeExports;
        exports("d", default_1$2 = TableRows.default = (0, _createSvgIcon$2.default)(/*#__PURE__*/(0, _jsxRuntime$2.jsx)("path", {
          d: "M21 8H3V4h18zm0 2H3v4h18zm0 6H3v4h18z"
        }), 'TableRows'));
        const surveyHeader = "_surveyHeader_6kre5_1";
        const icon$1 = "_icon_6kre5_9";
        const launchContainer = "_launchContainer_6kre5_13";
        const unpublishedChangesDot = "_unpublishedChangesDot_6kre5_16";
        const styles$3 = {
          surveyHeader: surveyHeader,
          icon: icon$1,
          launchContainer: launchContainer,
          unpublishedChangesDot: unpublishedChangesDot
        };
        var Reorder = {};
        var _interopRequireDefault$1 = interopRequireDefaultExports;
        Object.defineProperty(Reorder, "__esModule", {
          value: true
        });
        var default_1$1 = Reorder.default = void 0;
        var _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon());
        var _jsxRuntime$1 = jsxRuntimeExports;
        default_1$1 = Reorder.default = (0, _createSvgIcon$1.default)(/*#__PURE__*/(0, _jsxRuntime$1.jsx)("path", {
          d: "M3 15h18v-2H3zm0 4h18v-2H3zm0-8h18V9H3zm0-6v2h18V5z"
        }), 'Reorder');
        function SideTabs({
          selectedPage,
          onPageChange,
          availablePages,
          surveyId
        }) {
          const tabAvailable = tab => availablePages.indexOf(tab) !== -1;
          const _useTranslation7 = useTranslation("design"),
            t = _useTranslation7.t;
          const dispatch = useDispatch();
          const getTabButtonStyle = selected => ({
            minWidth: "auto",
            margin: "0px !important",
            padding: "12px 0px",
            backgroundColor: selected ? "#2d3cb2" : void 0,
            color: "#fff"
          });
          const setupInfo = useSelector(state => state.designState.setup || {});
          const showTheme = () => {
            dispatch(resetLang());
            dispatch(setup(themeSetup));
          };
          const showTranslation = () => {
            dispatch(setup(languageSetup));
          };
          const reOrder = () => {
            dispatch(resetLang());
            dispatch(setup(reorderSetup));
          };
          const versionDto = useSelector(state => {
            return state.designState.versionDto;
          });
          const published = versionDto === null || versionDto === void 0 ? void 0 : versionDto.published;
          availablePages.indexOf(selectedPage);
          function component() {
            return /* @__PURE__ */jsxRuntimeExports.jsxs(List, {
              children: [tabAvailable(MANAGE_SURVEY_LANDING_PAGES.DESIGN) && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(SideTab, {
                  tooltip: t("design"),
                  style: getTabButtonStyle(selectedPage == MANAGE_SURVEY_LANDING_PAGES.DESIGN && !hasMajorSetup(setupInfo)),
                  link: routes.designSurvey.replace(":surveyId", surveyId),
                  icon: /* @__PURE__ */jsxRuntimeExports.jsx(Edit, {
                    sx: {
                      color: "#fff"
                    }
                  }),
                  onClick: () => {
                    dispatch(resetSetup());
                    onPageChange(MANAGE_SURVEY_LANDING_PAGES.DESIGN);
                  }
                }), /* @__PURE__ */jsxRuntimeExports.jsx(SideTab, {
                  tooltip: t("design"),
                  style: getTabButtonStyle(selectedPage == MANAGE_SURVEY_LANDING_PAGES.DESIGN && setupInfo == languageSetup),
                  link: routes.designSurvey.replace(":surveyId", surveyId) + `?mode=${DESIGN_SURVEY_MODE.LANGUAGES}`,
                  icon: /* @__PURE__ */jsxRuntimeExports.jsx(GTranslate, {
                    sx: {
                      color: "#fff"
                    }
                  }),
                  onClick: () => {
                    onPageChange(MANAGE_SURVEY_LANDING_PAGES.DESIGN);
                    showTranslation();
                  }
                }), /* @__PURE__ */jsxRuntimeExports.jsx(SideTab, {
                  tooltip: t("design"),
                  style: getTabButtonStyle(selectedPage == MANAGE_SURVEY_LANDING_PAGES.DESIGN && setupInfo == themeSetup),
                  link: routes.designSurvey.replace(":surveyId", surveyId) + `?mode=${DESIGN_SURVEY_MODE.THEME}`,
                  icon: /* @__PURE__ */jsxRuntimeExports.jsx(Palette, {
                    sx: {
                      color: "#fff"
                    }
                  }),
                  onClick: () => {
                    onPageChange(MANAGE_SURVEY_LANDING_PAGES.DESIGN);
                    showTheme();
                  }
                }), /* @__PURE__ */jsxRuntimeExports.jsx(SideTab, {
                  tooltip: t("design"),
                  style: getTabButtonStyle(selectedPage == MANAGE_SURVEY_LANDING_PAGES.DESIGN && setupInfo == reorderSetup),
                  link: routes.designSurvey.replace(":surveyId", surveyId) + `?mode=${DESIGN_SURVEY_MODE.REORDER}`,
                  icon: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$1, {
                    sx: {
                      color: "#fff"
                    }
                  }),
                  onClick: () => {
                    onPageChange(MANAGE_SURVEY_LANDING_PAGES.DESIGN);
                    reOrder();
                  }
                })]
              }), tabAvailable(MANAGE_SURVEY_LANDING_PAGES.PREVIEW) && /* @__PURE__ */jsxRuntimeExports.jsx(SideTab, {
                tooltip: t("preview"),
                style: getTabButtonStyle(selectedPage == MANAGE_SURVEY_LANDING_PAGES.PREVIEW),
                link: routes.preview.replace(":surveyId", surveyId),
                icon: /* @__PURE__ */jsxRuntimeExports.jsx(Visibility, {
                  sx: {
                    color: "#fff"
                  }
                }),
                onClick: () => {
                  onPageChange(MANAGE_SURVEY_LANDING_PAGES.PREVIEW);
                }
              }), tabAvailable(MANAGE_SURVEY_LANDING_PAGES.SETTINGS) && /* @__PURE__ */jsxRuntimeExports.jsx(SideTab, {
                tooltip: t("settings"),
                style: getTabButtonStyle(selectedPage == MANAGE_SURVEY_LANDING_PAGES.SETTINGS),
                link: routes.editSurvey.replace(":surveyId", surveyId),
                icon: /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                  className: styles$3.launchContainer,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(Settings, {
                    sx: {
                      color: "#fff"
                    }
                  }), !published && /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                    className: styles$3.unpublishedChangesDot
                  })]
                }),
                onClick: () => {
                  onPageChange(MANAGE_SURVEY_LANDING_PAGES.SETTINGS);
                }
              }), tabAvailable(MANAGE_SURVEY_LANDING_PAGES.RESPONSES) && /* @__PURE__ */jsxRuntimeExports.jsx(SideTab, {
                tooltip: t("responses"),
                style: getTabButtonStyle(selectedPage == MANAGE_SURVEY_LANDING_PAGES.RESPONSES),
                link: routes.editSurvey.replace(":surveyId", surveyId),
                icon: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$2, {
                  sx: {
                    color: "#fff"
                  }
                }),
                onClick: () => {
                  onPageChange(MANAGE_SURVEY_LANDING_PAGES.RESPONSES);
                }
              })]
            });
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles$3.surveyHeader,
            children: component()
          });
        }
        const SideTabs$1 = React.memo(SideTabs);
        function SideTab({
          tooltip,
          style,
          link,
          onClick: _onClick,
          icon
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsx(Tooltip, {
            title: tooltip,
            placement: "right",
            children: /* @__PURE__ */jsxRuntimeExports.jsx(ListItem, {
              disablePadding: true,
              style,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(ListItemButton, {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Link, {
                  to: link,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(ListItemIcon, {
                    onClick: () => _onClick(),
                    children: icon
                  })
                })
              })
            })
          });
        }
        const ResponsesSurvey = React.lazy(() => __vitePreload(() => module.import('./index-legacy-B3_FWyye.js'), false ? __VITE_PRELOAD__ : void 0));
        const EditSurvey = React.lazy(() => __vitePreload(() => module.import('./index-legacy-DXgI2e1V.js'), false ? __VITE_PRELOAD__ : void 0));
        const DesignSurvey = React.lazy(() => __vitePreload(() => module.import('./index-legacy-CWlv7E8p.js'), false ? __VITE_PRELOAD__ : void 0));
        function ManageSurvey({
          landingPage
        }) {
          const surveyService = useService("survey");
          const designService = useService("design");
          const params = useParams();
          const user = TokenService.getUser();
          const _reactExports$useStat11 = reactExports.useState(landingTab(landingPage, user)),
            _reactExports$useStat12 = _slicedToArray(_reactExports$useStat11, 2),
            selectedPage = _reactExports$useStat12[0],
            setSelectedTab = _reactExports$useStat12[1];
          const _reactExports$useStat13 = reactExports.useState(false),
            _reactExports$useStat14 = _slicedToArray(_reactExports$useStat13, 2),
            designAvailable = _reactExports$useStat14[0],
            setDesignAvailable = _reactExports$useStat14[1];
          const dispatch = useDispatch();
          const setState = state => {
            dispatch(designStateReceived(state));
          };
          const processApirror = e => {
            dispatch(setLoading(false));
          };
          reactExports.useEffect(() => {
            dispatch(onAddComponentsVisibilityChange(true));
            dispatch(resetSetup());
            if (!isSurveyAdmin()) {
              return;
            }
            dispatch(setLoading(true));
            GetData(designService, setState, processApirror).then(data => {
              if (data) {
                setDesignAvailable(true);
                dispatch(setLoading(false));
              }
            }).catch(err => {
              dispatch(setLoading(false));
            });
            loadSurvey();
          }, []);
          const loadSurvey = () => {
            surveyService.getSurvey().then(data => {
              if (data) {
                dispatch(surveyReceived(data));
              }
            }).catch(err => {});
          };
          reactExports.useEffect(() => {
            const handlePopState = () => {
              const currentPath = window.location.pathname;
              const currentTab = currentPath.split("/")[1];
              setSelectedTab(currentTab);
              const searchParams = new URLSearchParams(window.location.search);
              const mode = searchParams.get("mode");
              if (mode == DESIGN_SURVEY_MODE.THEME) {
                dispatch(resetLang());
                dispatch(setup(themeSetup));
              } else if (mode == DESIGN_SURVEY_MODE.LANGUAGES) {
                dispatch(setup(languageSetup));
              } else if (mode == DESIGN_SURVEY_MODE.REORDER) {
                dispatch(resetLang());
                dispatch(setup(reorderSetup));
              } else {
                dispatch(resetSetup());
              }
            };
            window.addEventListener("popstate", handlePopState);
            return () => {
              window.removeEventListener("popstate", handlePopState);
            };
          }, []);
          const shouldShowDesign = () => selectedPage == MANAGE_SURVEY_LANDING_PAGES.DESIGN && designAvailable;
          const shouldShowResponses = () => selectedPage == MANAGE_SURVEY_LANDING_PAGES.RESPONSES;
          const shouldShowEditSurvey = () => selectedPage == MANAGE_SURVEY_LANDING_PAGES.SETTINGS;
          const changePage = reactExports.useCallback(tab => {
            setSelectedTab(tab);
          }, []);
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              sx: {
                display: "flex"
              },
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(SideTabs$1, {
                availablePages: availablePages(user),
                selectedPage,
                surveyId: params.surveyId,
                onPageChange: changePage
              }), /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingDots, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                  className: styles$5.wrapper,
                  children: shouldShowResponses() ? /* @__PURE__ */jsxRuntimeExports.jsx(ResponsesSurvey, {}) : shouldShowEditSurvey() ? /* @__PURE__ */jsxRuntimeExports.jsx(EditSurvey, {
                    onPublish: () => loadSurvey()
                  }) : shouldShowDesign() ? /* @__PURE__ */jsxRuntimeExports.jsx(DesignSurvey, {}) : /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {})
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(SavingSurvey, {})]
            }), designAvailable && selectedPage == MANAGE_SURVEY_LANDING_PAGES.LANGUAGE && /* @__PURE__ */jsxRuntimeExports.jsx(ManageTranslations, {
              onManageTranslationsClose: () => {
                setSelectedTab(MANAGE_SURVEY_LANDING_PAGES.DESIGN);
              },
              permissionsLoadingpermissionsLoading: true,
              onStartTranslation: () => {}
            })]
          });
        }
        const ManageSurvey$1 = React.memo(ManageSurvey);
        const availablePages = user => {
          if (isSurveyAdmin()) {
            return [MANAGE_SURVEY_LANDING_PAGES.DESIGN, MANAGE_SURVEY_LANDING_PAGES.PREVIEW, MANAGE_SURVEY_LANDING_PAGES.SETTINGS, MANAGE_SURVEY_LANDING_PAGES.RESPONSES];
          } else if (isAnalyst(user)) {
            return [MANAGE_SURVEY_LANDING_PAGES.PREVIEW, MANAGE_SURVEY_LANDING_PAGES.RESPONSES];
          } else {
            return [MANAGE_SURVEY_LANDING_PAGES.PREVIEW];
          }
        };
        const landingTab = (landingPage, user) => {
          if (isAnalyst(user) && landingPage == MANAGE_SURVEY_LANDING_PAGES.RESPONSES) {
            return MANAGE_SURVEY_LANDING_PAGES.RESPONSES;
          } else if (isSurveyAdmin() && (landingPage == MANAGE_SURVEY_LANDING_PAGES.DESIGN || landingPage == MANAGE_SURVEY_LANDING_PAGES.SETTINGS)) {
            return landingPage;
          } else {
            return "";
          }
        };

        // ----------------------------------------------------------------------

        function useResponsive(query, start, end) {
          const theme = useTheme$1();
          const mediaUp = useMediaQuery(theme.breakpoints.up(start));
          useMediaQuery(theme.breakpoints.down(start));
          useMediaQuery(theme.breakpoints.between(start, end));
          useMediaQuery(theme.breakpoints.only(start));
          {
            return mediaUp;
          }
        }
        const authContainer = "_authContainer_1r79w_1";
        const styles$2 = {
          authContainer: authContainer
        };
        function AuthIllustrationLayout({
          children
        }) {
          const mdUp = useResponsive("up", "md");
          return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
            className: styles$2.authContainer,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(Container, {
              sx: {
                pb: 10,
                minHeight: 1,
                pt: {
                  xs: 12,
                  md: 21
                }
              },
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(Grid2, {
                container: true,
                columnSpacing: {
                  md: 5
                },
                justifyContent: "space-between",
                children: [mdUp && /* @__PURE__ */jsxRuntimeExports.jsx(Grid2, {
                  xs: 12,
                  md: 7,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(Image$1, {
                    visibleByDefault: true,
                    disabledEffect: true,
                    alt: "login",
                    src: "/illustration_login.svg"
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Grid2, {
                  xs: 12,
                  md: 5,
                  lg: 4,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(Stack, {
                    spacing: 4,
                    sx: {
                      p: 4,
                      borderRadius: 2,
                      textAlign: {
                        xs: "center",
                        md: "left"
                      },
                      boxShadow: theme => "22"
                    },
                    children
                  })
                })]
              })
            })
          });
        }
        const container = "_container_f0r9q_1";
        const onlinePreview = "_onlinePreview_f0r9q_11";
        const icon = "_icon_f0r9q_17";
        const offlinePreview = "_offlinePreview_f0r9q_22";
        const wrapperMob = "_wrapperMob_f0r9q_31";
        const phoneBg = "_phoneBg_f0r9q_37";
        const iconButton = "_iconButton_f0r9q_42";
        const styles$1 = {
          container: container,
          onlinePreview: onlinePreview,
          icon: icon,
          offlinePreview: offlinePreview,
          wrapperMob: wrapperMob,
          phoneBg: phoneBg,
          iconButton: iconButton
        };
        var FileCopy = {};
        var _interopRequireDefault = interopRequireDefaultExports;
        Object.defineProperty(FileCopy, "__esModule", {
          value: true
        });
        var default_1 = exports("c", FileCopy.default = void 0);
        var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
        var _jsxRuntime = jsxRuntimeExports;
        exports("c", default_1 = FileCopy.default = (0, _createSvgIcon.default)(/*#__PURE__*/(0, _jsxRuntime.jsx)("path", {
          d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm-1 4 6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2zm-1 7h5.5L14 6.5z"
        }), 'FileCopy'));
        const wrapper = "_wrapper_ar1uh_1";
        const action = "_action_ar1uh_12";
        const errorText = "_errorText_ar1uh_17";
        const styles = {
          wrapper: wrapper,
          action: action,
          errorText: errorText
        };
        var isCheckBoxInput = element => element.type === 'checkbox';
        var isDateObject = value => value instanceof Date;
        var isNullOrUndefined = value => value == null;
        const isObjectType = value => typeof value === 'object';
        var isObject = value => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
        var getEventValue = event => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
        var getNodeParentName = name => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
        var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
        var isPlainObject = tempObject => {
          const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
          return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty('isPrototypeOf');
        };
        var isWeb = typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined' && typeof document !== 'undefined';
        function cloneObject(data) {
          let copy;
          const isArray = Array.isArray(data);
          if (data instanceof Date) {
            copy = new Date(data);
          } else if (data instanceof Set) {
            copy = new Set(data);
          } else if (!(isWeb && (data instanceof Blob || data instanceof FileList)) && (isArray || isObject(data))) {
            copy = isArray ? [] : {};
            if (!isArray && !isPlainObject(data)) {
              copy = data;
            } else {
              for (const key in data) {
                if (data.hasOwnProperty(key)) {
                  copy[key] = cloneObject(data[key]);
                }
              }
            }
          } else {
            return data;
          }
          return copy;
        }
        var compact = value => Array.isArray(value) ? value.filter(Boolean) : [];
        var isUndefined = val => val === undefined;
        var _get = exports("k", (object, path, defaultValue) => {
          if (!path || !isObject(object)) {
            return defaultValue;
          }
          const result = compact(path.split(/[,[\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], object);
          return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;
        });
        var isBoolean = value => typeof value === 'boolean';
        var isKey = value => /^\w*$/.test(value);
        var stringToPath = input => compact(input.replace(/["|']|\]/g, '').split(/\.|\[/));
        var set = exports("s", (object, path, value) => {
          let index = -1;
          const tempPath = isKey(path) ? [path] : stringToPath(path);
          const length = tempPath.length;
          const lastIndex = length - 1;
          while (++index < length) {
            const key = tempPath[index];
            let newValue = value;
            if (index !== lastIndex) {
              const objValue = object[key];
              newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};
            }
            if (key === '__proto__') {
              return;
            }
            object[key] = newValue;
            object = object[key];
          }
          return object;
        });
        const EVENTS = {
          BLUR: 'blur',
          FOCUS_OUT: 'focusout',
          CHANGE: 'change'
        };
        const VALIDATION_MODE = {
          onBlur: 'onBlur',
          onChange: 'onChange',
          onSubmit: 'onSubmit',
          onTouched: 'onTouched',
          all: 'all'
        };
        const INPUT_VALIDATION_RULES = {
          max: 'max',
          min: 'min',
          maxLength: 'maxLength',
          minLength: 'minLength',
          pattern: 'pattern',
          required: 'required',
          validate: 'validate'
        };
        const HookFormContext = React.createContext(null);
        /**
         * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.
         *
         * @remarks
         * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
         *
         * @returns return all useForm methods
         *
         * @example
         * ```tsx
         * function App() {
         *   const methods = useForm();
         *   const onSubmit = data => console.log(data);
         *
         *   return (
         *     <FormProvider {...methods} >
         *       <form onSubmit={methods.handleSubmit(onSubmit)}>
         *         <NestedInput />
         *         <input type="submit" />
         *       </form>
         *     </FormProvider>
         *   );
         * }
         *
         *  function NestedInput() {
         *   const { register } = useFormContext(); // retrieve all hook methods
         *   return <input {...register("test")} />;
         * }
         * ```
         */
        const useFormContext = () => React.useContext(HookFormContext);
        /**
         * A provider component that propagates the `useForm` methods to all children components via [React Context](https://reactjs.org/docs/context.html) API. To be used with {@link useFormContext}.
         *
         * @remarks
         * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
         *
         * @param props - all useForm methods
         *
         * @example
         * ```tsx
         * function App() {
         *   const methods = useForm();
         *   const onSubmit = data => console.log(data);
         *
         *   return (
         *     <FormProvider {...methods} >
         *       <form onSubmit={methods.handleSubmit(onSubmit)}>
         *         <NestedInput />
         *         <input type="submit" />
         *       </form>
         *     </FormProvider>
         *   );
         * }
         *
         *  function NestedInput() {
         *   const { register } = useFormContext(); // retrieve all hook methods
         *   return <input {...register("test")} />;
         * }
         * ```
         */
        const FormProvider$1 = props => {
          const children = props.children,
            data = _objectWithoutProperties(props, _excluded5);
          return React.createElement(HookFormContext.Provider, {
            value: data
          }, children);
        };
        var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
          const result = {
            defaultValues: control._defaultValues
          };
          for (const key in formState) {
            Object.defineProperty(result, key, {
              get: () => {
                const _key = key;
                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
                  control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
                }
                localProxyFormState && (localProxyFormState[_key] = true);
                return formState[_key];
              }
            });
          }
          return result;
        };
        var isEmptyObject = value => isObject(value) && !Object.keys(value).length;
        var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
          updateFormState(formStateData);
          const name = formStateData.name,
            formState = _objectWithoutProperties(formStateData, _excluded6);
          return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find(key => _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));
        };
        var convertToArrayPayload = value => Array.isArray(value) ? value : [value];
        var shouldSubscribeByName = (name, signalName, exact) => !name || !signalName || name === signalName || convertToArrayPayload(name).some(currentName => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
        function useSubscribe(props) {
          const _props = React.useRef(props);
          _props.current = props;
          React.useEffect(() => {
            const subscription = !props.disabled && _props.current.subject && _props.current.subject.subscribe({
              next: _props.current.next
            });
            return () => {
              subscription && subscription.unsubscribe();
            };
          }, [props.disabled]);
        }

        /**
         * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.
         *
         * @remarks
         * [API](https://react-hook-form.com/docs/useformstate) • [Demo](https://codesandbox.io/s/useformstate-75xly)
         *
         * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}
         *
         * @example
         * ```tsx
         * function App() {
         *   const { register, handleSubmit, control } = useForm({
         *     defaultValues: {
         *     firstName: "firstName"
         *   }});
         *   const { dirtyFields } = useFormState({
         *     control
         *   });
         *   const onSubmit = (data) => console.log(data);
         *
         *   return (
         *     <form onSubmit={handleSubmit(onSubmit)}>
         *       <input {...register("firstName")} placeholder="First Name" />
         *       {dirtyFields.firstName && <p>Field is dirty.</p>}
         *       <input type="submit" />
         *     </form>
         *   );
         * }
         * ```
         */
        function useFormState(props) {
          const methods = useFormContext();
          const _ref10 = props || {},
            _ref10$control = _ref10.control,
            control = _ref10$control === void 0 ? methods.control : _ref10$control,
            disabled = _ref10.disabled,
            name = _ref10.name,
            exact = _ref10.exact;
          const _React$useState3 = React.useState(control._formState),
            _React$useState4 = _slicedToArray(_React$useState3, 2),
            formState = _React$useState4[0],
            updateFormState = _React$useState4[1];
          const _mounted = React.useRef(true);
          const _localProxyFormState = React.useRef({
            isDirty: false,
            isLoading: false,
            dirtyFields: false,
            touchedFields: false,
            validatingFields: false,
            isValidating: false,
            isValid: false,
            errors: false
          });
          const _name = React.useRef(name);
          _name.current = name;
          useSubscribe({
            disabled,
            next: value => _mounted.current && shouldSubscribeByName(_name.current, value.name, exact) && shouldRenderFormState(value, _localProxyFormState.current, control._updateFormState) && updateFormState(_objectSpread(_objectSpread({}, control._formState), value)),
            subject: control._subjects.state
          });
          React.useEffect(() => {
            _mounted.current = true;
            _localProxyFormState.current.isValid && control._updateValid(true);
            return () => {
              _mounted.current = false;
            };
          }, [control]);
          return getProxyFormState(formState, control, _localProxyFormState.current, false);
        }
        var isString = value => typeof value === 'string';
        var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
          if (isString(names)) {
            isGlobal && _names.watch.add(names);
            return _get(formValues, names, defaultValue);
          }
          if (Array.isArray(names)) {
            return names.map(fieldName => (isGlobal && _names.watch.add(fieldName), _get(formValues, fieldName)));
          }
          isGlobal && (_names.watchAll = true);
          return formValues;
        };

        /**
         * Custom hook to subscribe to field change and isolate re-rendering at the component level.
         *
         * @remarks
         *
         * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
         *
         * @example
         * ```tsx
         * const { control } = useForm();
         * const values = useWatch({
         *   name: "fieldName"
         *   control,
         * })
         * ```
         */
        function useWatch(props) {
          const methods = useFormContext();
          const _ref11 = props || {},
            _ref11$control = _ref11.control,
            control = _ref11$control === void 0 ? methods.control : _ref11$control,
            name = _ref11.name,
            defaultValue = _ref11.defaultValue,
            disabled = _ref11.disabled,
            exact = _ref11.exact;
          const _name = React.useRef(name);
          _name.current = name;
          useSubscribe({
            disabled,
            subject: control._subjects.values,
            next: formState => {
              if (shouldSubscribeByName(_name.current, formState.name, exact)) {
                updateValue(cloneObject(generateWatchOutput(_name.current, control._names, formState.values || control._formValues, false, defaultValue)));
              }
            }
          });
          const _React$useState5 = React.useState(control._getWatch(name, defaultValue)),
            _React$useState6 = _slicedToArray(_React$useState5, 2),
            value = _React$useState6[0],
            updateValue = _React$useState6[1];
          React.useEffect(() => control._removeUnmounted());
          return value;
        }

        /**
         * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.
         *
         * @remarks
         * [API](https://react-hook-form.com/docs/usecontroller) • [Demo](https://codesandbox.io/s/usecontroller-0o8px)
         *
         * @param props - the path name to the form field value, and validation rules.
         *
         * @returns field properties, field and form state. {@link UseControllerReturn}
         *
         * @example
         * ```tsx
         * function Input(props) {
         *   const { field, fieldState, formState } = useController(props);
         *   return (
         *     <div>
         *       <input {...field} placeholder={props.name} />
         *       <p>{fieldState.isTouched && "Touched"}</p>
         *       <p>{formState.isSubmitted ? "submitted" : ""}</p>
         *     </div>
         *   );
         * }
         * ```
         */
        function useController(props) {
          const methods = useFormContext();
          const name = props.name,
            disabled = props.disabled,
            _props$control = props.control,
            control = _props$control === void 0 ? methods.control : _props$control,
            shouldUnregister = props.shouldUnregister;
          const isArrayField = isNameInFieldArray(control._names.array, name);
          const value = useWatch({
            control,
            name,
            defaultValue: _get(control._formValues, name, _get(control._defaultValues, name, props.defaultValue)),
            exact: true
          });
          const formState = useFormState({
            control,
            name,
            exact: true
          });
          const _registerProps = React.useRef(control.register(name, _objectSpread(_objectSpread({}, props.rules), {}, {
            value
          }, isBoolean(props.disabled) ? {
            disabled: props.disabled
          } : {})));
          React.useEffect(() => {
            const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
            const updateMounted = (name, value) => {
              const field = _get(control._fields, name);
              if (field && field._f) {
                field._f.mount = value;
              }
            };
            updateMounted(name, true);
            if (_shouldUnregisterField) {
              const value = cloneObject(_get(control._options.defaultValues, name));
              set(control._defaultValues, name, value);
              if (isUndefined(_get(control._formValues, name))) {
                set(control._formValues, name, value);
              }
            }
            return () => {
              (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
            };
          }, [name, control, isArrayField, shouldUnregister]);
          React.useEffect(() => {
            if (_get(control._fields, name)) {
              control._updateDisabledField({
                disabled,
                fields: control._fields,
                name,
                value: _get(control._fields, name)._f.value
              });
            }
          }, [disabled, name, control]);
          return {
            field: _objectSpread(_objectSpread({
              name,
              value
            }, isBoolean(disabled) || formState.disabled ? {
              disabled: formState.disabled || disabled
            } : {}), {}, {
              onChange: React.useCallback(event => _registerProps.current.onChange({
                target: {
                  value: getEventValue(event),
                  name: name
                },
                type: EVENTS.CHANGE
              }), [name]),
              onBlur: React.useCallback(() => _registerProps.current.onBlur({
                target: {
                  value: _get(control._formValues, name),
                  name: name
                },
                type: EVENTS.BLUR
              }), [name, control]),
              ref: React.useCallback(elm => {
                const field = _get(control._fields, name);
                if (field && elm) {
                  field._f.ref = {
                    focus: () => elm.focus(),
                    select: () => elm.select(),
                    setCustomValidity: message => elm.setCustomValidity(message),
                    reportValidity: () => elm.reportValidity()
                  };
                }
              }, [control._fields, name])
            }),
            formState,
            fieldState: Object.defineProperties({}, {
              invalid: {
                enumerable: true,
                get: () => !!_get(formState.errors, name)
              },
              isDirty: {
                enumerable: true,
                get: () => !!_get(formState.dirtyFields, name)
              },
              isTouched: {
                enumerable: true,
                get: () => !!_get(formState.touchedFields, name)
              },
              isValidating: {
                enumerable: true,
                get: () => !!_get(formState.validatingFields, name)
              },
              error: {
                enumerable: true,
                get: () => _get(formState.errors, name)
              }
            })
          };
        }

        /**
         * Component based on `useController` hook to work with controlled component.
         *
         * @remarks
         * [API](https://react-hook-form.com/docs/usecontroller/controller) • [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw) • [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)
         *
         * @param props - the path name to the form field value, and validation rules.
         *
         * @returns provide field handler functions, field and form state.
         *
         * @example
         * ```tsx
         * function App() {
         *   const { control } = useForm<FormValues>({
         *     defaultValues: {
         *       test: ""
         *     }
         *   });
         *
         *   return (
         *     <form>
         *       <Controller
         *         control={control}
         *         name="test"
         *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (
         *           <>
         *             <input
         *               onChange={onChange} // send value to hook form
         *               onBlur={onBlur} // notify when input is touched
         *               value={value} // return updated value
         *               ref={ref} // set ref for focus management
         *             />
         *             <p>{formState.isSubmitted ? "submitted" : ""}</p>
         *             <p>{fieldState.isTouched ? "touched" : ""}</p>
         *           </>
         *         )}
         *       />
         *     </form>
         *   );
         * }
         * ```
         */
        const Controller = props => props.render(useController(props));
        var appendErrors = exports("m", (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? _objectSpread(_objectSpread({}, errors[name]), {}, {
          types: _objectSpread(_objectSpread({}, errors[name] && errors[name].types ? errors[name].types : {}), {}, {
            [type]: message || true
          })
        }) : {});
        var getValidationModes = mode => ({
          isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
          isOnBlur: mode === VALIDATION_MODE.onBlur,
          isOnChange: mode === VALIDATION_MODE.onChange,
          isOnAll: mode === VALIDATION_MODE.all,
          isOnTouch: mode === VALIDATION_MODE.onTouched
        });
        var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some(watchName => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
        const iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
          var _iterator3 = _createForOfIteratorHelper(fieldsNames || Object.keys(fields)),
            _step;
          try {
            for (_iterator3.s(); !(_step = _iterator3.n()).done;) {
              const key = _step.value;
              const field = _get(fields, key);
              if (field) {
                const _f = field._f,
                  currentField = _objectWithoutProperties(field, _excluded7);
                if (_f) {
                  if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {
                    return true;
                  } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
                    return true;
                  } else {
                    if (iterateFieldsByAction(currentField, action)) {
                      break;
                    }
                  }
                } else if (isObject(currentField)) {
                  if (iterateFieldsByAction(currentField, action)) {
                    break;
                  }
                }
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          return;
        };
        var updateFieldArrayRootError = (errors, error, name) => {
          const fieldArrayErrors = convertToArrayPayload(_get(errors, name));
          set(fieldArrayErrors, 'root', error[name]);
          set(errors, name, fieldArrayErrors);
          return errors;
        };
        var isFileInput = element => element.type === 'file';
        var isFunction = value => typeof value === 'function';
        var isHTMLElement = value => {
          if (!isWeb) {
            return false;
          }
          const owner = value ? value.ownerDocument : 0;
          return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
        };
        var isMessage = value => isString(value);
        var isRadioInput = element => element.type === 'radio';
        var isRegex = value => value instanceof RegExp;
        const defaultResult = {
          value: false,
          isValid: false
        };
        const validResult = {
          value: true,
          isValid: true
        };
        var getCheckboxValue = options => {
          if (Array.isArray(options)) {
            if (options.length > 1) {
              const values = options.filter(option => option && option.checked && !option.disabled).map(option => option.value);
              return {
                value: values,
                isValid: !!values.length
              };
            }
            return options[0].checked && !options[0].disabled ?
            // @ts-expect-error expected to work in the browser
            options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === '' ? validResult : {
              value: options[0].value,
              isValid: true
            } : validResult : defaultResult;
          }
          return defaultResult;
        };
        const defaultReturn = {
          isValid: false,
          value: null
        };
        var getRadioValue = options => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
          isValid: true,
          value: option.value
        } : previous, defaultReturn) : defaultReturn;
        function getValidateError(result, ref, type = 'validate') {
          if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {
            return {
              type,
              message: isMessage(result) ? result : '',
              ref
            };
          }
        }
        var getValueAndMessage = validationData => isObject(validationData) && !isRegex(validationData) ? validationData : {
          value: validationData,
          message: ''
        };
        var validateField = /*#__PURE__*/function () {
          var _ref12 = _asyncToGenerator(function* (field, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) {
            const _field$_f = field._f,
              ref = _field$_f.ref,
              refs = _field$_f.refs,
              required = _field$_f.required,
              maxLength = _field$_f.maxLength,
              minLength = _field$_f.minLength,
              min = _field$_f.min,
              max = _field$_f.max,
              pattern = _field$_f.pattern,
              validate = _field$_f.validate,
              name = _field$_f.name,
              valueAsNumber = _field$_f.valueAsNumber,
              mount = _field$_f.mount,
              disabled = _field$_f.disabled;
            const inputValue = _get(formValues, name);
            if (!mount || disabled) {
              return {};
            }
            const inputRef = refs ? refs[0] : ref;
            const setCustomValidity = message => {
              if (shouldUseNativeValidation && inputRef.reportValidity) {
                inputRef.setCustomValidity(isBoolean(message) ? '' : message || '');
                inputRef.reportValidity();
              }
            };
            const error = {};
            const isRadio = isRadioInput(ref);
            const isCheckBox = isCheckBoxInput(ref);
            const isRadioOrCheckbox = isRadio || isCheckBox;
            const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === '' || inputValue === '' || Array.isArray(inputValue) && !inputValue.length;
            const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
            const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
              const message = exceedMax ? maxLengthMessage : minLengthMessage;
              error[name] = _objectSpread({
                type: exceedMax ? maxType : minType,
                message,
                ref
              }, appendErrorsCurry(exceedMax ? maxType : minType, message));
            };
            if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
              const _ref13 = isMessage(required) ? {
                  value: !!required,
                  message: required
                } : getValueAndMessage(required),
                value = _ref13.value,
                message = _ref13.message;
              if (value) {
                error[name] = _objectSpread({
                  type: INPUT_VALIDATION_RULES.required,
                  message,
                  ref: inputRef
                }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));
                if (!validateAllFieldCriteria) {
                  setCustomValidity(message);
                  return error;
                }
              }
            }
            if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {
              let exceedMax;
              let exceedMin;
              const maxOutput = getValueAndMessage(max);
              const minOutput = getValueAndMessage(min);
              if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
                const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
                if (!isNullOrUndefined(maxOutput.value)) {
                  exceedMax = valueNumber > maxOutput.value;
                }
                if (!isNullOrUndefined(minOutput.value)) {
                  exceedMin = valueNumber < minOutput.value;
                }
              } else {
                const valueDate = ref.valueAsDate || new Date(inputValue);
                const convertTimeToDate = time => new Date(new Date().toDateString() + ' ' + time);
                const isTime = ref.type == 'time';
                const isWeek = ref.type == 'week';
                if (isString(maxOutput.value) && inputValue) {
                  exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
                }
                if (isString(minOutput.value) && inputValue) {
                  exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
                }
              }
              if (exceedMax || exceedMin) {
                getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
                if (!validateAllFieldCriteria) {
                  setCustomValidity(error[name].message);
                  return error;
                }
              }
            }
            if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
              const maxLengthOutput = getValueAndMessage(maxLength);
              const minLengthOutput = getValueAndMessage(minLength);
              const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
              const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
              if (exceedMax || exceedMin) {
                getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
                if (!validateAllFieldCriteria) {
                  setCustomValidity(error[name].message);
                  return error;
                }
              }
            }
            if (pattern && !isEmpty && isString(inputValue)) {
              const _getValueAndMessage = getValueAndMessage(pattern),
                patternValue = _getValueAndMessage.value,
                message = _getValueAndMessage.message;
              if (isRegex(patternValue) && !inputValue.match(patternValue)) {
                error[name] = _objectSpread({
                  type: INPUT_VALIDATION_RULES.pattern,
                  message,
                  ref
                }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));
                if (!validateAllFieldCriteria) {
                  setCustomValidity(message);
                  return error;
                }
              }
            }
            if (validate) {
              if (isFunction(validate)) {
                const result = yield validate(inputValue, formValues);
                const validateError = getValidateError(result, inputRef);
                if (validateError) {
                  error[name] = _objectSpread(_objectSpread({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));
                  if (!validateAllFieldCriteria) {
                    setCustomValidity(validateError.message);
                    return error;
                  }
                }
              } else if (isObject(validate)) {
                let validationResult = {};
                for (const key in validate) {
                  if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
                    break;
                  }
                  const validateError = getValidateError(yield validate[key](inputValue, formValues), inputRef, key);
                  if (validateError) {
                    validationResult = _objectSpread(_objectSpread({}, validateError), appendErrorsCurry(key, validateError.message));
                    setCustomValidity(validateError.message);
                    if (validateAllFieldCriteria) {
                      error[name] = validationResult;
                    }
                  }
                }
                if (!isEmptyObject(validationResult)) {
                  error[name] = _objectSpread({
                    ref: inputRef
                  }, validationResult);
                  if (!validateAllFieldCriteria) {
                    return error;
                  }
                }
              }
            }
            setCustomValidity(true);
            return error;
          });
          return function validateField(_x, _x2, _x3, _x4, _x5) {
            return _ref12.apply(this, arguments);
          };
        }();
        function baseGet(object, updatePath) {
          const length = updatePath.slice(0, -1).length;
          let index = 0;
          while (index < length) {
            object = isUndefined(object) ? index++ : object[updatePath[index++]];
          }
          return object;
        }
        function isEmptyArray(obj) {
          for (const key in obj) {
            if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {
              return false;
            }
          }
          return true;
        }
        function unset(object, path) {
          const paths = Array.isArray(path) ? path : isKey(path) ? [path] : stringToPath(path);
          const childObject = paths.length === 1 ? object : baseGet(object, paths);
          const index = paths.length - 1;
          const key = paths[index];
          if (childObject) {
            delete childObject[key];
          }
          if (index !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
            unset(object, paths.slice(0, -1));
          }
          return object;
        }
        var createSubject = () => {
          let _observers = [];
          const next = value => {
            var _iterator4 = _createForOfIteratorHelper(_observers),
              _step2;
            try {
              for (_iterator4.s(); !(_step2 = _iterator4.n()).done;) {
                const observer = _step2.value;
                observer.next && observer.next(value);
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          };
          const subscribe = observer => {
            _observers.push(observer);
            return {
              unsubscribe: () => {
                _observers = _observers.filter(o => o !== observer);
              }
            };
          };
          const unsubscribe = () => {
            _observers = [];
          };
          return {
            get observers() {
              return _observers;
            },
            next,
            subscribe,
            unsubscribe
          };
        };
        var isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);
        function deepEqual(object1, object2) {
          if (isPrimitive(object1) || isPrimitive(object2)) {
            return object1 === object2;
          }
          if (isDateObject(object1) && isDateObject(object2)) {
            return object1.getTime() === object2.getTime();
          }
          const keys1 = Object.keys(object1);
          const keys2 = Object.keys(object2);
          if (keys1.length !== keys2.length) {
            return false;
          }
          for (var _i2 = 0, _keys = keys1; _i2 < _keys.length; _i2++) {
            const key = _keys[_i2];
            const val1 = object1[key];
            if (!keys2.includes(key)) {
              return false;
            }
            if (key !== 'ref') {
              const val2 = object2[key];
              if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2) : val1 !== val2) {
                return false;
              }
            }
          }
          return true;
        }
        var isMultipleSelect = element => element.type === `select-multiple`;
        var isRadioOrCheckbox = ref => isRadioInput(ref) || isCheckBoxInput(ref);
        var live = ref => isHTMLElement(ref) && ref.isConnected;
        var objectHasFunction = data => {
          for (const key in data) {
            if (isFunction(data[key])) {
              return true;
            }
          }
          return false;
        };
        function markFieldsDirty(data, fields = {}) {
          const isParentNodeArray = Array.isArray(data);
          if (isObject(data) || isParentNodeArray) {
            for (const key in data) {
              if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
                fields[key] = Array.isArray(data[key]) ? [] : {};
                markFieldsDirty(data[key], fields[key]);
              } else if (!isNullOrUndefined(data[key])) {
                fields[key] = true;
              }
            }
          }
          return fields;
        }
        function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
          const isParentNodeArray = Array.isArray(data);
          if (isObject(data) || isParentNodeArray) {
            for (const key in data) {
              if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
                if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {
                  dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : _objectSpread({}, markFieldsDirty(data[key]));
                } else {
                  getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
                }
              } else {
                dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);
              }
            }
          }
          return dirtyFieldsFromValues;
        }
        var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
        var getFieldValueAs = (value, {
          valueAsNumber,
          valueAsDate,
          setValueAs
        }) => isUndefined(value) ? value : valueAsNumber ? value === '' ? NaN : value ? +value : value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
        function getFieldValue(_f) {
          const ref = _f.ref;
          if (_f.refs ? _f.refs.every(ref => ref.disabled) : ref.disabled) {
            return;
          }
          if (isFileInput(ref)) {
            return ref.files;
          }
          if (isRadioInput(ref)) {
            return getRadioValue(_f.refs).value;
          }
          if (isMultipleSelect(ref)) {
            return [...ref.selectedOptions].map(({
              value
            }) => value);
          }
          if (isCheckBoxInput(ref)) {
            return getCheckboxValue(_f.refs).value;
          }
          return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
        }
        var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
          const fields = {};
          var _iterator5 = _createForOfIteratorHelper(fieldsNames),
            _step3;
          try {
            for (_iterator5.s(); !(_step3 = _iterator5.n()).done;) {
              const name = _step3.value;
              const field = _get(_fields, name);
              field && set(fields, name, field._f);
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
          return {
            criteriaMode,
            names: [...fieldsNames],
            fields,
            shouldUseNativeValidation
          };
        };
        var getRuleValue = rule => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
        const ASYNC_FUNCTION = 'AsyncFunction';
        var hasPromiseValidation = fieldReference => (!fieldReference || !fieldReference.validate) && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject(fieldReference.validate) && Object.values(fieldReference.validate).find(validateFunction => validateFunction.constructor.name === ASYNC_FUNCTION));
        var hasValidation = options => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
        function schemaErrorLookup(errors, _fields, name) {
          const error = _get(errors, name);
          if (error || isKey(name)) {
            return {
              error,
              name
            };
          }
          const names = name.split('.');
          while (names.length) {
            const fieldName = names.join('.');
            const field = _get(_fields, fieldName);
            const foundError = _get(errors, fieldName);
            if (field && !Array.isArray(field) && name !== fieldName) {
              return {
                name
              };
            }
            if (foundError && foundError.type) {
              return {
                name: fieldName,
                error: foundError
              };
            }
            names.pop();
          }
          return {
            name
          };
        }
        var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
          if (mode.isOnAll) {
            return false;
          } else if (!isSubmitted && mode.isOnTouch) {
            return !(isTouched || isBlurEvent);
          } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
            return !isBlurEvent;
          } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
            return isBlurEvent;
          }
          return true;
        };
        var unsetEmptyArray = (ref, name) => !compact(_get(ref, name)).length && unset(ref, name);
        const defaultOptions = {
          mode: VALIDATION_MODE.onSubmit,
          reValidateMode: VALIDATION_MODE.onChange,
          shouldFocusError: true
        };
        function createFormControl(props = {}) {
          let _options = _objectSpread(_objectSpread({}, defaultOptions), props);
          let _formState = {
            submitCount: 0,
            isDirty: false,
            isLoading: isFunction(_options.defaultValues),
            isValidating: false,
            isSubmitted: false,
            isSubmitting: false,
            isSubmitSuccessful: false,
            isValid: false,
            touchedFields: {},
            dirtyFields: {},
            validatingFields: {},
            errors: _options.errors || {},
            disabled: _options.disabled || false
          };
          let _fields = {};
          let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
          let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
          let _state = {
            action: false,
            mount: false,
            watch: false
          };
          let _names = {
            mount: new Set(),
            unMount: new Set(),
            array: new Set(),
            watch: new Set()
          };
          let delayErrorCallback;
          let timer = 0;
          const _proxyFormState = {
            isDirty: false,
            dirtyFields: false,
            validatingFields: false,
            touchedFields: false,
            isValidating: false,
            isValid: false,
            errors: false
          };
          const _subjects = {
            values: createSubject(),
            array: createSubject(),
            state: createSubject()
          };
          const validationModeBeforeSubmit = getValidationModes(_options.mode);
          const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
          const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
          const debounce = callback => wait => {
            clearTimeout(timer);
            timer = setTimeout(callback, wait);
          };
          const _updateValid = /*#__PURE__*/function () {
            var _ref14 = _asyncToGenerator(function* (shouldUpdateValid) {
              if (!props.disabled && (_proxyFormState.isValid || shouldUpdateValid)) {
                const isValid = _options.resolver ? isEmptyObject((yield _executeSchema()).errors) : yield _executeBuiltInValidation(_fields, true);
                if (isValid !== _formState.isValid) {
                  _subjects.state.next({
                    isValid
                  });
                }
              }
            });
            return function _updateValid(_x6) {
              return _ref14.apply(this, arguments);
            };
          }();
          const _updateIsValidating = (names, isValidating) => {
            if (!props.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields)) {
              (names || Array.from(_names.mount)).forEach(name => {
                if (name) {
                  isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);
                }
              });
              _subjects.state.next({
                validatingFields: _formState.validatingFields,
                isValidating: !isEmptyObject(_formState.validatingFields)
              });
            }
          };
          const _updateFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
            if (args && method && !props.disabled) {
              _state.action = true;
              if (shouldUpdateFieldsAndState && Array.isArray(_get(_fields, name))) {
                const fieldValues = method(_get(_fields, name), args.argA, args.argB);
                shouldSetValues && set(_fields, name, fieldValues);
              }
              if (shouldUpdateFieldsAndState && Array.isArray(_get(_formState.errors, name))) {
                const errors = method(_get(_formState.errors, name), args.argA, args.argB);
                shouldSetValues && set(_formState.errors, name, errors);
                unsetEmptyArray(_formState.errors, name);
              }
              if (_proxyFormState.touchedFields && shouldUpdateFieldsAndState && Array.isArray(_get(_formState.touchedFields, name))) {
                const touchedFields = method(_get(_formState.touchedFields, name), args.argA, args.argB);
                shouldSetValues && set(_formState.touchedFields, name, touchedFields);
              }
              if (_proxyFormState.dirtyFields) {
                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
              }
              _subjects.state.next({
                name,
                isDirty: _getDirty(name, values),
                dirtyFields: _formState.dirtyFields,
                errors: _formState.errors,
                isValid: _formState.isValid
              });
            } else {
              set(_formValues, name, values);
            }
          };
          const updateErrors = (name, error) => {
            set(_formState.errors, name, error);
            _subjects.state.next({
              errors: _formState.errors
            });
          };
          const _setErrors = errors => {
            _formState.errors = errors;
            _subjects.state.next({
              errors: _formState.errors,
              isValid: false
            });
          };
          const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
            const field = _get(_fields, name);
            if (field) {
              const defaultValue = _get(_formValues, name, isUndefined(value) ? _get(_defaultValues, name) : value);
              isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
              _state.mount && _updateValid();
            }
          };
          const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
            let shouldUpdateField = false;
            let isPreviousDirty = false;
            const output = {
              name
            };
            if (!props.disabled) {
              const disabledField = !!(_get(_fields, name) && _get(_fields, name)._f && _get(_fields, name)._f.disabled);
              if (!isBlurEvent || shouldDirty) {
                if (_proxyFormState.isDirty) {
                  isPreviousDirty = _formState.isDirty;
                  _formState.isDirty = output.isDirty = _getDirty();
                  shouldUpdateField = isPreviousDirty !== output.isDirty;
                }
                const isCurrentFieldPristine = disabledField || deepEqual(_get(_defaultValues, name), fieldValue);
                isPreviousDirty = !!(!disabledField && _get(_formState.dirtyFields, name));
                isCurrentFieldPristine || disabledField ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);
                output.dirtyFields = _formState.dirtyFields;
                shouldUpdateField = shouldUpdateField || _proxyFormState.dirtyFields && isPreviousDirty !== !isCurrentFieldPristine;
              }
              if (isBlurEvent) {
                const isPreviousFieldTouched = _get(_formState.touchedFields, name);
                if (!isPreviousFieldTouched) {
                  set(_formState.touchedFields, name, isBlurEvent);
                  output.touchedFields = _formState.touchedFields;
                  shouldUpdateField = shouldUpdateField || _proxyFormState.touchedFields && isPreviousFieldTouched !== isBlurEvent;
                }
              }
              shouldUpdateField && shouldRender && _subjects.state.next(output);
            }
            return shouldUpdateField ? output : {};
          };
          const shouldRenderByError = (name, isValid, error, fieldState) => {
            const previousFieldError = _get(_formState.errors, name);
            const shouldUpdateValid = _proxyFormState.isValid && isBoolean(isValid) && _formState.isValid !== isValid;
            if (props.delayError && error) {
              delayErrorCallback = debounce(() => updateErrors(name, error));
              delayErrorCallback(props.delayError);
            } else {
              clearTimeout(timer);
              delayErrorCallback = null;
              error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
            }
            if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
              const updatedFormState = _objectSpread(_objectSpread(_objectSpread({}, fieldState), shouldUpdateValid && isBoolean(isValid) ? {
                isValid
              } : {}), {}, {
                errors: _formState.errors,
                name
              });
              _formState = _objectSpread(_objectSpread({}, _formState), updatedFormState);
              _subjects.state.next(updatedFormState);
            }
          };
          const _executeSchema = /*#__PURE__*/function () {
            var _ref15 = _asyncToGenerator(function* (name) {
              _updateIsValidating(name, true);
              const result = yield _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
              _updateIsValidating(name);
              return result;
            });
            return function _executeSchema(_x7) {
              return _ref15.apply(this, arguments);
            };
          }();
          const executeSchemaAndUpdateState = /*#__PURE__*/function () {
            var _ref16 = _asyncToGenerator(function* (names) {
              const _yield$_executeSchema = yield _executeSchema(names),
                errors = _yield$_executeSchema.errors;
              if (names) {
                var _iterator6 = _createForOfIteratorHelper(names),
                  _step4;
                try {
                  for (_iterator6.s(); !(_step4 = _iterator6.n()).done;) {
                    const name = _step4.value;
                    const error = _get(errors, name);
                    error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
                  }
                } catch (err) {
                  _iterator6.e(err);
                } finally {
                  _iterator6.f();
                }
              } else {
                _formState.errors = errors;
              }
              return errors;
            });
            return function executeSchemaAndUpdateState(_x8) {
              return _ref16.apply(this, arguments);
            };
          }();
          const _executeBuiltInValidation = /*#__PURE__*/function () {
            var _ref17 = _asyncToGenerator(function* (fields, shouldOnlyCheckValid, context = {
              valid: true
            }) {
              for (const name in fields) {
                const field = fields[name];
                if (field) {
                  const _f = field._f,
                    fieldValue = _objectWithoutProperties(field, _excluded8);
                  if (_f) {
                    const isFieldArrayRoot = _names.array.has(_f.name);
                    const isPromiseFunction = field._f && hasPromiseValidation(field._f);
                    if (isPromiseFunction && _proxyFormState.validatingFields) {
                      _updateIsValidating([name], true);
                    }
                    const fieldError = yield validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
                    if (isPromiseFunction && _proxyFormState.validatingFields) {
                      _updateIsValidating([name]);
                    }
                    if (fieldError[_f.name]) {
                      context.valid = false;
                      if (shouldOnlyCheckValid) {
                        break;
                      }
                    }
                    !shouldOnlyCheckValid && (_get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));
                  }
                  !isEmptyObject(fieldValue) && (yield _executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context));
                }
              }
              return context.valid;
            });
            return function executeBuiltInValidation(_x9, _x10) {
              return _ref17.apply(this, arguments);
            };
          }();
          const _removeUnmounted = () => {
            var _iterator7 = _createForOfIteratorHelper(_names.unMount),
              _step5;
            try {
              for (_iterator7.s(); !(_step5 = _iterator7.n()).done;) {
                const name = _step5.value;
                const field = _get(_fields, name);
                field && (field._f.refs ? field._f.refs.every(ref => !live(ref)) : !live(field._f.ref)) && unregister(name);
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
            _names.unMount = new Set();
          };
          const _getDirty = (name, data) => !props.disabled && (name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));
          const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, _objectSpread({}, _state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? {
            [names]: defaultValue
          } : defaultValue), isGlobal, defaultValue);
          const _getFieldArray = name => compact(_get(_state.mount ? _formValues : _defaultValues, name, props.shouldUnregister ? _get(_defaultValues, name, []) : []));
          const setFieldValue = (name, value, options = {}) => {
            const field = _get(_fields, name);
            let fieldValue = value;
            if (field) {
              const fieldReference = field._f;
              if (fieldReference) {
                !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value, fieldReference));
                fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value) ? '' : value;
                if (isMultipleSelect(fieldReference.ref)) {
                  [...fieldReference.ref.options].forEach(optionRef => optionRef.selected = fieldValue.includes(optionRef.value));
                } else if (fieldReference.refs) {
                  if (isCheckBoxInput(fieldReference.ref)) {
                    fieldReference.refs.length > 1 ? fieldReference.refs.forEach(checkboxRef => (!checkboxRef.defaultChecked || !checkboxRef.disabled) && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find(data => data === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);
                  } else {
                    fieldReference.refs.forEach(radioRef => radioRef.checked = radioRef.value === fieldValue);
                  }
                } else if (isFileInput(fieldReference.ref)) {
                  fieldReference.ref.value = '';
                } else {
                  fieldReference.ref.value = fieldValue;
                  if (!fieldReference.ref.type) {
                    _subjects.values.next({
                      name,
                      values: _objectSpread({}, _formValues)
                    });
                  }
                }
              }
            }
            (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
            options.shouldValidate && trigger(name);
          };
          const setValues = (name, value, options) => {
            for (const fieldKey in value) {
              const fieldValue = value[fieldKey];
              const fieldName = `${name}.${fieldKey}`;
              const field = _get(_fields, fieldName);
              (_names.array.has(name) || isObject(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
            }
          };
          const setValue = (name, value, options = {}) => {
            const field = _get(_fields, name);
            const isFieldArray = _names.array.has(name);
            const cloneValue = cloneObject(value);
            set(_formValues, name, cloneValue);
            if (isFieldArray) {
              _subjects.array.next({
                name,
                values: _objectSpread({}, _formValues)
              });
              if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) && options.shouldDirty) {
                _subjects.state.next({
                  name,
                  dirtyFields: getDirtyFields(_defaultValues, _formValues),
                  isDirty: _getDirty(name, cloneValue)
                });
              }
            } else {
              field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);
            }
            isWatched(name, _names) && _subjects.state.next(_objectSpread({}, _formState));
            _subjects.values.next({
              name: _state.mount ? name : undefined,
              values: _objectSpread({}, _formValues)
            });
          };
          const onChange = /*#__PURE__*/function () {
            var _ref18 = _asyncToGenerator(function* (event) {
              _state.mount = true;
              const target = event.target;
              let name = target.name;
              let isFieldValueUpdated = true;
              const field = _get(_fields, name);
              const getCurrentFieldValue = () => target.type ? getFieldValue(field._f) : getEventValue(event);
              const _updateIsFieldValueUpdated = fieldValue => {
                isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual(fieldValue, _get(_formValues, name, fieldValue));
              };
              if (field) {
                let error;
                let isValid;
                const fieldValue = getCurrentFieldValue();
                const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
                const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !_get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, _get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
                const watched = isWatched(name, _names, isBlurEvent);
                set(_formValues, name, fieldValue);
                if (isBlurEvent) {
                  field._f.onBlur && field._f.onBlur(event);
                  delayErrorCallback && delayErrorCallback(0);
                } else if (field._f.onChange) {
                  field._f.onChange(event);
                }
                const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);
                const shouldRender = !isEmptyObject(fieldState) || watched;
                !isBlurEvent && _subjects.values.next({
                  name,
                  type: event.type,
                  values: _objectSpread({}, _formValues)
                });
                if (shouldSkipValidation) {
                  if (_proxyFormState.isValid) {
                    if (props.mode === 'onBlur') {
                      if (isBlurEvent) {
                        _updateValid();
                      }
                    } else {
                      _updateValid();
                    }
                  }
                  return shouldRender && _subjects.state.next(_objectSpread({
                    name
                  }, watched ? {} : fieldState));
                }
                !isBlurEvent && watched && _subjects.state.next(_objectSpread({}, _formState));
                if (_options.resolver) {
                  const _yield$_executeSchema2 = yield _executeSchema([name]),
                    errors = _yield$_executeSchema2.errors;
                  _updateIsFieldValueUpdated(fieldValue);
                  if (isFieldValueUpdated) {
                    const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
                    const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
                    error = errorLookupResult.error;
                    name = errorLookupResult.name;
                    isValid = isEmptyObject(errors);
                  }
                } else {
                  _updateIsValidating([name], true);
                  error = (yield validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
                  _updateIsValidating([name]);
                  _updateIsFieldValueUpdated(fieldValue);
                  if (isFieldValueUpdated) {
                    if (error) {
                      isValid = false;
                    } else if (_proxyFormState.isValid) {
                      isValid = yield _executeBuiltInValidation(_fields, true);
                    }
                  }
                }
                if (isFieldValueUpdated) {
                  field._f.deps && trigger(field._f.deps);
                  shouldRenderByError(name, isValid, error, fieldState);
                }
              }
            });
            return function onChange(_x11) {
              return _ref18.apply(this, arguments);
            };
          }();
          const _focusInput = (ref, key) => {
            if (_get(_formState.errors, key) && ref.focus) {
              ref.focus();
              return 1;
            }
            return;
          };
          const trigger = /*#__PURE__*/function () {
            var _ref19 = _asyncToGenerator(function* (name, options = {}) {
              let isValid;
              let validationResult;
              const fieldNames = convertToArrayPayload(name);
              if (_options.resolver) {
                const errors = yield executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
                isValid = isEmptyObject(errors);
                validationResult = name ? !fieldNames.some(name => _get(errors, name)) : isValid;
              } else if (name) {
                validationResult = (yield Promise.all(fieldNames.map(/*#__PURE__*/function () {
                  var _ref20 = _asyncToGenerator(function* (fieldName) {
                    const field = _get(_fields, fieldName);
                    return yield _executeBuiltInValidation(field && field._f ? {
                      [fieldName]: field
                    } : field);
                  });
                  return function (_x13) {
                    return _ref20.apply(this, arguments);
                  };
                }()))).every(Boolean);
                !(!validationResult && !_formState.isValid) && _updateValid();
              } else {
                validationResult = isValid = yield _executeBuiltInValidation(_fields);
              }
              _subjects.state.next(_objectSpread(_objectSpread(_objectSpread({}, !isString(name) || _proxyFormState.isValid && isValid !== _formState.isValid ? {} : {
                name
              }), _options.resolver || !name ? {
                isValid
              } : {}), {}, {
                errors: _formState.errors
              }));
              options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
              return validationResult;
            });
            return function trigger(_x12) {
              return _ref19.apply(this, arguments);
            };
          }();
          const getValues = fieldNames => {
            const values = _objectSpread({}, _state.mount ? _formValues : _defaultValues);
            return isUndefined(fieldNames) ? values : isString(fieldNames) ? _get(values, fieldNames) : fieldNames.map(name => _get(values, name));
          };
          const getFieldState = (name, formState) => ({
            invalid: !!_get((formState || _formState).errors, name),
            isDirty: !!_get((formState || _formState).dirtyFields, name),
            error: _get((formState || _formState).errors, name),
            isValidating: !!_get(_formState.validatingFields, name),
            isTouched: !!_get((formState || _formState).touchedFields, name)
          });
          const clearErrors = name => {
            name && convertToArrayPayload(name).forEach(inputName => unset(_formState.errors, inputName));
            _subjects.state.next({
              errors: name ? _formState.errors : {}
            });
          };
          const setError = (name, error, options) => {
            const ref = (_get(_fields, name, {
              _f: {}
            })._f || {}).ref;
            const currentError = _get(_formState.errors, name) || {};
            // Don't override existing error messages elsewhere in the object tree.
            const currentRef = currentError.ref,
              message = currentError.message,
              type = currentError.type,
              restOfErrorTree = _objectWithoutProperties(currentError, _excluded9);
            set(_formState.errors, name, _objectSpread(_objectSpread(_objectSpread({}, restOfErrorTree), error), {}, {
              ref
            }));
            _subjects.state.next({
              name,
              errors: _formState.errors,
              isValid: false
            });
            options && options.shouldFocus && ref && ref.focus && ref.focus();
          };
          const watch = (name, defaultValue) => isFunction(name) ? _subjects.values.subscribe({
            next: payload => name(_getWatch(undefined, defaultValue), payload)
          }) : _getWatch(name, defaultValue, true);
          const unregister = (name, options = {}) => {
            var _iterator8 = _createForOfIteratorHelper(name ? convertToArrayPayload(name) : _names.mount),
              _step6;
            try {
              for (_iterator8.s(); !(_step6 = _iterator8.n()).done;) {
                const fieldName = _step6.value;
                _names.mount.delete(fieldName);
                _names.array.delete(fieldName);
                if (!options.keepValue) {
                  unset(_fields, fieldName);
                  unset(_formValues, fieldName);
                }
                !options.keepError && unset(_formState.errors, fieldName);
                !options.keepDirty && unset(_formState.dirtyFields, fieldName);
                !options.keepTouched && unset(_formState.touchedFields, fieldName);
                !options.keepIsValidating && unset(_formState.validatingFields, fieldName);
                !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
              }
            } catch (err) {
              _iterator8.e(err);
            } finally {
              _iterator8.f();
            }
            _subjects.values.next({
              values: _objectSpread({}, _formValues)
            });
            _subjects.state.next(_objectSpread(_objectSpread({}, _formState), !options.keepDirty ? {} : {
              isDirty: _getDirty()
            }));
            !options.keepIsValid && _updateValid();
          };
          const _updateDisabledField = ({
            disabled,
            name,
            field,
            fields,
            value
          }) => {
            if (isBoolean(disabled) && _state.mount || !!disabled) {
              const inputValue = disabled ? undefined : isUndefined(value) ? getFieldValue(field ? field._f : _get(fields, name)._f) : value;
              set(_formValues, name, inputValue);
              updateTouchAndDirty(name, inputValue, false, false, true);
            }
          };
          const register = (name, options = {}) => {
            let field = _get(_fields, name);
            const disabledIsDefined = isBoolean(options.disabled) || isBoolean(props.disabled);
            set(_fields, name, _objectSpread(_objectSpread({}, field || {}), {}, {
              _f: _objectSpread(_objectSpread({}, field && field._f ? field._f : {
                ref: {
                  name
                }
              }), {}, {
                name,
                mount: true
              }, options)
            }));
            _names.mount.add(name);
            if (field) {
              _updateDisabledField({
                field,
                disabled: isBoolean(options.disabled) ? options.disabled : props.disabled,
                name,
                value: options.value
              });
            } else {
              updateValidAndValue(name, true, options.value);
            }
            return _objectSpread(_objectSpread(_objectSpread({}, disabledIsDefined ? {
              disabled: options.disabled || props.disabled
            } : {}), _options.progressive ? {
              required: !!options.required,
              min: getRuleValue(options.min),
              max: getRuleValue(options.max),
              minLength: getRuleValue(options.minLength),
              maxLength: getRuleValue(options.maxLength),
              pattern: getRuleValue(options.pattern)
            } : {}), {}, {
              name,
              onChange,
              onBlur: onChange,
              ref: _ref21 => {
                if (_ref21) {
                  register(name, options);
                  field = _get(_fields, name);
                  const fieldRef = isUndefined(_ref21.value) ? _ref21.querySelectorAll ? _ref21.querySelectorAll('input,select,textarea')[0] || _ref21 : _ref21 : _ref21;
                  const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
                  const refs = field._f.refs || [];
                  if (radioOrCheckbox ? refs.find(option => option === fieldRef) : fieldRef === field._f.ref) {
                    return;
                  }
                  set(_fields, name, {
                    _f: _objectSpread(_objectSpread({}, field._f), radioOrCheckbox ? {
                      refs: [...refs.filter(live), fieldRef, ...(Array.isArray(_get(_defaultValues, name)) ? [{}] : [])],
                      ref: {
                        type: fieldRef.type,
                        name
                      }
                    } : {
                      ref: fieldRef
                    })
                  });
                  updateValidAndValue(name, false, undefined, fieldRef);
                } else {
                  field = _get(_fields, name, {});
                  if (field._f) {
                    field._f.mount = false;
                  }
                  (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
                }
              }
            });
          };
          const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
          const _disableForm = disabled => {
            if (isBoolean(disabled)) {
              _subjects.state.next({
                disabled
              });
              iterateFieldsByAction(_fields, (ref, name) => {
                const currentField = _get(_fields, name);
                if (currentField) {
                  ref.disabled = currentField._f.disabled || disabled;
                  if (Array.isArray(currentField._f.refs)) {
                    currentField._f.refs.forEach(inputRef => {
                      inputRef.disabled = currentField._f.disabled || disabled;
                    });
                  }
                }
              }, 0, false);
            }
          };
          const handleSubmit = (onValid, onInvalid) => (/*#__PURE__*/function () {
            var _ref22 = _asyncToGenerator(function* (e) {
              let onValidError = undefined;
              if (e) {
                e.preventDefault && e.preventDefault();
                e.persist && e.persist();
              }
              let fieldValues = cloneObject(_formValues);
              _subjects.state.next({
                isSubmitting: true
              });
              if (_options.resolver) {
                const _yield$_executeSchema3 = yield _executeSchema(),
                  errors = _yield$_executeSchema3.errors,
                  values = _yield$_executeSchema3.values;
                _formState.errors = errors;
                fieldValues = values;
              } else {
                yield _executeBuiltInValidation(_fields);
              }
              unset(_formState.errors, 'root');
              if (isEmptyObject(_formState.errors)) {
                _subjects.state.next({
                  errors: {}
                });
                try {
                  yield onValid(fieldValues, e);
                } catch (error) {
                  onValidError = error;
                }
              } else {
                if (onInvalid) {
                  yield onInvalid(_objectSpread({}, _formState.errors), e);
                }
                _focusError();
                setTimeout(_focusError);
              }
              _subjects.state.next({
                isSubmitted: true,
                isSubmitting: false,
                isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
                submitCount: _formState.submitCount + 1,
                errors: _formState.errors
              });
              if (onValidError) {
                throw onValidError;
              }
            });
            return function (_x14) {
              return _ref22.apply(this, arguments);
            };
          }());
          const resetField = (name, options = {}) => {
            if (_get(_fields, name)) {
              if (isUndefined(options.defaultValue)) {
                setValue(name, cloneObject(_get(_defaultValues, name)));
              } else {
                setValue(name, options.defaultValue);
                set(_defaultValues, name, cloneObject(options.defaultValue));
              }
              if (!options.keepTouched) {
                unset(_formState.touchedFields, name);
              }
              if (!options.keepDirty) {
                unset(_formState.dirtyFields, name);
                _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(_get(_defaultValues, name))) : _getDirty();
              }
              if (!options.keepError) {
                unset(_formState.errors, name);
                _proxyFormState.isValid && _updateValid();
              }
              _subjects.state.next(_objectSpread({}, _formState));
            }
          };
          const _reset = (formValues, keepStateOptions = {}) => {
            const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
            const cloneUpdatedValues = cloneObject(updatedValues);
            const isEmptyResetValues = isEmptyObject(formValues);
            const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
            if (!keepStateOptions.keepDefaultValues) {
              _defaultValues = updatedValues;
            }
            if (!keepStateOptions.keepValues) {
              if (keepStateOptions.keepDirtyValues) {
                const fieldsToCheck = new Set([..._names.mount, ...Object.keys(getDirtyFields(_defaultValues, _formValues))]);
                for (var _i3 = 0, _Array$from = Array.from(fieldsToCheck); _i3 < _Array$from.length; _i3++) {
                  const fieldName = _Array$from[_i3];
                  _get(_formState.dirtyFields, fieldName) ? set(values, fieldName, _get(_formValues, fieldName)) : setValue(fieldName, _get(values, fieldName));
                }
              } else {
                if (isWeb && isUndefined(formValues)) {
                  var _iterator9 = _createForOfIteratorHelper(_names.mount),
                    _step7;
                  try {
                    for (_iterator9.s(); !(_step7 = _iterator9.n()).done;) {
                      const name = _step7.value;
                      const field = _get(_fields, name);
                      if (field && field._f) {
                        const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
                        if (isHTMLElement(fieldReference)) {
                          const form = fieldReference.closest('form');
                          if (form) {
                            form.reset();
                            break;
                          }
                        }
                      }
                    }
                  } catch (err) {
                    _iterator9.e(err);
                  } finally {
                    _iterator9.f();
                  }
                }
                _fields = {};
              }
              _formValues = props.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);
              _subjects.array.next({
                values: _objectSpread({}, values)
              });
              _subjects.values.next({
                values: _objectSpread({}, values)
              });
            }
            _names = {
              mount: keepStateOptions.keepDirtyValues ? _names.mount : new Set(),
              unMount: new Set(),
              array: new Set(),
              watch: new Set(),
              watchAll: false,
              focus: ''
            };
            _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;
            _state.watch = !!props.shouldUnregister;
            _subjects.state.next({
              submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
              isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),
              isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
              dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},
              touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
              errors: keepStateOptions.keepErrors ? _formState.errors : {},
              isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
              isSubmitting: false
            });
          };
          const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
          const setFocus = (name, options = {}) => {
            const field = _get(_fields, name);
            const fieldReference = field && field._f;
            if (fieldReference) {
              const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
              if (fieldRef.focus) {
                fieldRef.focus();
                options.shouldSelect && fieldRef.select();
              }
            }
          };
          const _updateFormState = updatedFormState => {
            _formState = _objectSpread(_objectSpread({}, _formState), updatedFormState);
          };
          const _resetDefaultValues = () => isFunction(_options.defaultValues) && _options.defaultValues().then(values => {
            reset(values, _options.resetOptions);
            _subjects.state.next({
              isLoading: false
            });
          });
          return {
            control: {
              register,
              unregister,
              getFieldState,
              handleSubmit,
              setError,
              _executeSchema,
              _getWatch,
              _getDirty,
              _updateValid,
              _removeUnmounted,
              _updateFieldArray,
              _updateDisabledField,
              _getFieldArray,
              _reset,
              _resetDefaultValues,
              _updateFormState,
              _disableForm,
              _subjects,
              _proxyFormState,
              _setErrors,
              get _fields() {
                return _fields;
              },
              get _formValues() {
                return _formValues;
              },
              get _state() {
                return _state;
              },
              set _state(value) {
                _state = value;
              },
              get _defaultValues() {
                return _defaultValues;
              },
              get _names() {
                return _names;
              },
              set _names(value) {
                _names = value;
              },
              get _formState() {
                return _formState;
              },
              set _formState(value) {
                _formState = value;
              },
              get _options() {
                return _options;
              },
              set _options(value) {
                _options = _objectSpread(_objectSpread({}, _options), value);
              }
            },
            trigger,
            register,
            handleSubmit,
            watch,
            setValue,
            getValues,
            reset,
            resetField,
            clearErrors,
            unregister,
            setError,
            setFocus,
            getFieldState
          };
        }

        /**
         * Custom hook to manage the entire form.
         *
         * @remarks
         * [API](https://react-hook-form.com/docs/useform) • [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm) • [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)
         *
         * @param props - form configuration and validation parameters.
         *
         * @returns methods - individual functions to manage the form state. {@link UseFormReturn}
         *
         * @example
         * ```tsx
         * function App() {
         *   const { register, handleSubmit, watch, formState: { errors } } = useForm();
         *   const onSubmit = data => console.log(data);
         *
         *   console.log(watch("example"));
         *
         *   return (
         *     <form onSubmit={handleSubmit(onSubmit)}>
         *       <input defaultValue="test" {...register("example")} />
         *       <input {...register("exampleRequired", { required: true })} />
         *       {errors.exampleRequired && <span>This field is required</span>}
         *       <button>Submit</button>
         *     </form>
         *   );
         * }
         * ```
         */
        function useForm(props = {}) {
          const _formControl = React.useRef();
          const _values = React.useRef();
          const _React$useState7 = React.useState({
              isDirty: false,
              isValidating: false,
              isLoading: isFunction(props.defaultValues),
              isSubmitted: false,
              isSubmitting: false,
              isSubmitSuccessful: false,
              isValid: false,
              submitCount: 0,
              dirtyFields: {},
              touchedFields: {},
              validatingFields: {},
              errors: props.errors || {},
              disabled: props.disabled || false,
              defaultValues: isFunction(props.defaultValues) ? undefined : props.defaultValues
            }),
            _React$useState8 = _slicedToArray(_React$useState7, 2),
            formState = _React$useState8[0],
            updateFormState = _React$useState8[1];
          if (!_formControl.current) {
            _formControl.current = _objectSpread(_objectSpread({}, createFormControl(props)), {}, {
              formState
            });
          }
          const control = _formControl.current.control;
          control._options = props;
          useSubscribe({
            subject: control._subjects.state,
            next: value => {
              if (shouldRenderFormState(value, control._proxyFormState, control._updateFormState, true)) {
                updateFormState(_objectSpread({}, control._formState));
              }
            }
          });
          React.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
          React.useEffect(() => {
            if (control._proxyFormState.isDirty) {
              const isDirty = control._getDirty();
              if (isDirty !== formState.isDirty) {
                control._subjects.state.next({
                  isDirty
                });
              }
            }
          }, [control, formState.isDirty]);
          React.useEffect(() => {
            if (props.values && !deepEqual(props.values, _values.current)) {
              control._reset(props.values, control._options.resetOptions);
              _values.current = props.values;
              updateFormState(state => _objectSpread({}, state));
            } else {
              control._resetDefaultValues();
            }
          }, [props.values, control]);
          React.useEffect(() => {
            if (props.errors) {
              control._setErrors(props.errors);
            }
          }, [props.errors, control]);
          React.useEffect(() => {
            if (!control._state.mount) {
              control._updateValid();
              control._state.mount = true;
            }
            if (control._state.watch) {
              control._state.watch = false;
              control._subjects.state.next(_objectSpread({}, control._formState));
            }
            control._removeUnmounted();
          });
          React.useEffect(() => {
            props.shouldUnregister && control._subjects.values.next({
              values: control._getWatch()
            });
          }, [props.shouldUnregister, control]);
          React.useEffect(() => {
            if (_formControl.current) {
              _formControl.current.watch = _formControl.current.watch.bind({});
            }
          }, [formState]);
          _formControl.current.formState = getProxyFormState(formState, control);
          return _formControl.current;
        }
        function RHFSelect(_ref23) {
          let name = _ref23.name,
            native = _ref23.native,
            _ref23$maxHeight = _ref23.maxHeight,
            maxHeight = _ref23$maxHeight === void 0 ? 220 : _ref23$maxHeight,
            helperText = _ref23.helperText,
            children = _ref23.children,
            PaperPropsSx = _ref23.PaperPropsSx,
            label = _ref23.label,
            onChange = _ref23.onChange,
            value = _ref23.value,
            other = _objectWithoutProperties(_ref23, _excluded10);
          const context = useFormContext();
          if (!context) {
            return /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, _objectSpread(_objectSpread({
              fullWidth: true
            }, other), {}, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(InputLabel, {
                children: label
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Select, {
                value,
                sx: {
                  borderRadius: "12px",
                  "& .MuiOutlinedInput-notchedOutline": {
                    border: "1px solid #d7d7d7"
                  },
                  "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
                    border: "1px solid #181735"
                  },
                  "&:hover .MuiOutlinedInput-notchedOutline": {
                    borderColor: "#181735"
                  },
                  "& .MuiOutlinedInput-input": {
                    padding: ".5rem"
                  }
                },
                onChange,
                label,
                children: React.Children.map(children, (child, index) => /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                  value: child.props.value,
                  children: child.props.children
                }, index))
              }), /* @__PURE__ */jsxRuntimeExports.jsx(FormHelperText, {
                children: helperText
              })]
            }));
          }
          const control = context.control;
          return /* @__PURE__ */jsxRuntimeExports.jsx(Controller, {
            name,
            control,
            render: ({
              field,
              fieldState: {
                error
              }
            }) => /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, _objectSpread(_objectSpread({
              fullWidth: true
            }, field), {}, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(InputLabel, {
                children: label
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Select, _objectSpread(_objectSpread(_objectSpread({}, field), {}, {
                sx: {
                  borderRadius: "12px",
                  "& .MuiOutlinedInput-notchedOutline": {
                    border: "1px solid #d7d7d7"
                  },
                  "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
                    border: "1px solid #181735"
                  },
                  "&:hover .MuiOutlinedInput-notchedOutline": {
                    borderColor: "#181735"
                  },
                  "& .MuiOutlinedInput-input": {
                    padding: ".5rem"
                  }
                },
                error: !!error,
                label
              }, other), {}, {
                children: React.Children.map(children, (child, index) => /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                  value: child.props.value,
                  children: child.props.children
                }, index))
              })), /* @__PURE__ */jsxRuntimeExports.jsx(FormHelperText, {
                children: helperText
              })]
            }))
          });
        }
        RHFSelect.propTypes = {
          PaperPropsSx: PropTypes.object,
          children: PropTypes.node,
          helperText: PropTypes.object,
          maxHeight: PropTypes.number,
          name: PropTypes.string,
          native: PropTypes.bool
        };
        function RHFMultiSelect(_ref24) {
          let name = _ref24.name,
            chip = _ref24.chip,
            label = _ref24.label,
            options = _ref24.options,
            checkbox = _ref24.checkbox,
            placeholder = _ref24.placeholder,
            helperText = _ref24.helperText,
            isOptionDisabled = _ref24.isOptionDisabled,
            other = _objectWithoutProperties(_ref24, _excluded11);
          const _useFormContext = useFormContext(),
            control = _useFormContext.control;
          const renderValues = selectedIds => {
            const selectedItems = options.filter(item => selectedIds.includes(item.value));
            if (!selectedItems.length && placeholder) {
              return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                sx: {
                  color: "text.disabled"
                },
                children: placeholder
              });
            }
            if (chip) {
              return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                sx: {
                  display: "flex",
                  flexWrap: "wrap",
                  gap: 0.5
                },
                children: selectedItems.map(item => /* @__PURE__ */jsxRuntimeExports.jsx(Chip, {
                  size: "small",
                  label: item.label
                }, item.value))
              });
            }
            return selectedItems.map(item => item.label).join(", ");
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(Controller, {
            name,
            control,
            render: ({
              field,
              fieldState: {
                error
              }
            }) => /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, _objectSpread(_objectSpread({
              error: !!error
            }, other), {}, {
              children: [label && /* @__PURE__ */jsxRuntimeExports.jsxs(InputLabel, {
                id: name,
                children: [" ", label, " "]
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Select, _objectSpread(_objectSpread({}, field), {}, {
                multiple: true,
                displayEmpty: !!placeholder,
                id: `multiple-${name}`,
                labelId: name,
                label,
                renderValue: renderValues,
                children: options.map(option => {
                  const selected = field.value.includes(option.value);
                  return /* @__PURE__ */jsxRuntimeExports.jsxs(MenuItem, {
                    disabled: isOptionDisabled ? isOptionDisabled(option.value, field.value) : false,
                    value: option.value,
                    children: [checkbox && /* @__PURE__ */jsxRuntimeExports.jsx(Checkbox, {
                      size: "small",
                      disableRipple: true,
                      checked: selected
                    }), option.label]
                  }, option.value);
                })
              })), (!!error || helperText) && /* @__PURE__ */jsxRuntimeExports.jsx(FormHelperText, {
                error: !!error,
                children: error ? error === null || error === void 0 ? void 0 : error.message : helperText
              })]
            }))
          });
        }
        RHFMultiSelect.propTypes = {
          checkbox: PropTypes.bool,
          chip: PropTypes.bool,
          helperText: PropTypes.object,
          label: PropTypes.string,
          name: PropTypes.string,
          options: PropTypes.array,
          placeholder: PropTypes.string
        };
        ({
          helperText: PropTypes.string,
          name: PropTypes.string
        });
        ({
          helperText: PropTypes.string,
          label: PropTypes.string,
          name: PropTypes.string,
          options: PropTypes.array,
          row: PropTypes.bool,
          spacing: PropTypes.number,
          sx: PropTypes.object
        });
        function FormProvider({
          children,
          onSubmit,
          methods
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsx(FormProvider$1, _objectSpread(_objectSpread({}, methods), {}, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx("form", {
              onSubmit,
              children
            })
          }));
        }
        FormProvider.propTypes = {
          children: PropTypes.node,
          methods: PropTypes.object,
          onSubmit: PropTypes.func
        };
        const G = styled$1(TextField)`
  input {
    text-align: center;
  }
`,
          J = {
            TextFieldStyled: G
          },
          Q = n => /* @__PURE__ */jsxRuntimeExports.jsx(J.TextFieldStyled, _objectSpread({}, n)),
          B = {
            left: "ArrowLeft",
            right: "ArrowRight",
            backspace: "Backspace",
            home: "Home",
            end: "End"
          };
        function U(n, l) {
          return n <= 0 ? [] : Array.from({
            length: n
          }, l);
        }
        function X(n, l, f) {
          return n.map((u, x) => l === x ? f : u);
        }
        function P(n) {
          return n.join("");
        }
        function M(n, l) {
          return [...n, l];
        }
        function Z(n, l, f) {
          return n.reduce((u, x, C) => {
            const y = u.characters,
              d = u.restArrayMerged;
            if (C < f) return {
              restArrayMerged: d,
              characters: M(y, x)
            };
            const _d2 = _toArray(d),
              D = _d2[0],
              V = _d2.slice(1);
            return {
              restArrayMerged: V,
              characters: M(y, D || "")
            };
          }, {
            restArrayMerged: l,
            characters: []
          }).characters;
        }
        function v(n) {
          return n.split("");
        }
        function N(n) {
          const l = React.useRef(() => {
            throw new Error("Cannot call an event handler while rendering.");
          });
          return React.useInsertionEffect(() => {
            l.current = n;
          }), React.useCallback((...f) => {
            var _l$current;
            return (_l$current = l.current) === null || _l$current === void 0 ? void 0 : _l$current.call(l, ...f);
          }, []);
        }
        const ee = () => !0,
          oe = React.forwardRef((n, l) => {
            const _n$value = n.value,
              f = _n$value === void 0 ? "" : _n$value,
              _n$length = n.length,
              u = _n$length === void 0 ? 4 : _n$length,
              _n$autoFocus = n.autoFocus,
              x = _n$autoFocus === void 0 ? !1 : _n$autoFocus,
              C = n.onChange,
              y = n.TextFieldsProps,
              d = n.onComplete,
              _n$validateChar = n.validateChar,
              D = _n$validateChar === void 0 ? ee : _n$validateChar,
              V = n.className,
              b = n.onBlur,
              K = _objectWithoutProperties(n, _excluded12),
              j = React.useRef(f),
              k = N(d),
              I = N(e => {
                const t = e.slice(0, u);
                return {
                  isCompleted: t.length === u,
                  finalValue: t
                };
              });
            React.useEffect(() => {
              const _I = I(j.current),
                e = _I.isCompleted,
                t = _I.finalValue;
              e && k(t);
            }, [u, k, I]);
            const p = U(u, (e, t) => ({
                character: f[t] || "",
                inputRef: React.createRef()
              })),
              A = e => p.findIndex(({
                inputRef: t
              }) => t.current === e),
              T = () => p.map(({
                character: e
              }) => e),
              O = (e, t) => {
                const a = X(T(), e, t);
                return P(a);
              },
              $ = e => {
                var _p$e;
                (_p$e = p[e]) === null || _p$e === void 0 || (_p$e = _p$e.inputRef.current) === null || _p$e === void 0 || _p$e.focus();
              },
              c = e => {
                var _p$e2;
                (_p$e2 = p[e]) === null || _p$e2 === void 0 || (_p$e2 = _p$e2.inputRef.current) === null || _p$e2 === void 0 || _p$e2.select();
              },
              R = e => {
                e + 1 !== u && (p[e + 1].character ? c(e + 1) : $(e + 1));
              },
              S = (e, t) => typeof D != "function" ? !0 : D(e, t),
              Y = e => {
                const t = A(e.target);
                if (t === 0 && e.target.value.length > 1) {
                  const _I2 = I(e.target.value),
                    m = _I2.finalValue,
                    F = _I2.isCompleted;
                  C !== null && C !== void 0 && C(m), F && d !== null && d !== void 0 && d(m), c(m.length - 1);
                  return;
                }
                const a = e.target.value[0] || "";
                let o = a;
                o && !S(o, t) && (o = "");
                const s = O(t, o);
                C === null || C === void 0 || C(s);
                const _I3 = I(s),
                  h = _I3.isCompleted,
                  i = _I3.finalValue;
                h && d !== null && d !== void 0 && d(i), o !== "" ? s.length - 1 < t ? c(s.length) : R(t) : a === "" && s.length <= t && c(t - 1);
              },
              _ = e => {
                const t = e.target,
                  a = t.selectionStart,
                  o = t.selectionEnd,
                  s = A(t),
                  h = a === 0 && o === 0;
                if (t.value === e.key) e.preventDefault(), R(s);else if (B.backspace === e.key) {
                  if (!t.value) e.preventDefault(), c(s - 1);else if (h) {
                    e.preventDefault();
                    const i = O(s, "");
                    C !== null && C !== void 0 && C(i), i.length <= s && c(s - 1);
                  }
                } else B.left === e.key ? (e.preventDefault(), c(s - 1)) : B.right === e.key ? (e.preventDefault(), c(s + 1)) : B.home === e.key ? (e.preventDefault(), c(0)) : B.end === e.key && (e.preventDefault(), c(p.length - 1));
              },
              H = e => {
                const t = e.clipboardData.getData("text/plain"),
                  a = e.target,
                  o = p.findIndex(({
                    character: r,
                    inputRef: w
                  }) => r === "" || w.current === a),
                  s = T(),
                  h = Z(s, v(t), o).map((r, w) => S(r, w) ? r : ""),
                  i = P(h);
                C === null || C === void 0 || C(i);
                const _I4 = I(i),
                  m = _I4.isCompleted,
                  F = _I4.finalValue;
                m ? (d !== null && d !== void 0 && d(F), c(u - 1)) : c(i.length);
              },
              L = e => {
                if (!p.some(({
                  inputRef: a
                }) => a.current === e.relatedTarget)) {
                  const _I5 = I(f),
                    a = _I5.isCompleted,
                    o = _I5.finalValue;
                  b === null || b === void 0 || b(o, a);
                }
              };
            return /* @__PURE__ */jsxRuntimeExports.jsx(Box, _objectSpread(_objectSpread({
              display: "flex",
              gap: "20px",
              alignItems: "center",
              ref: l,
              className: `MuiOtpInput-Box ${V || ""}`
            }, K), {}, {
              children: p.map(({
                character: e,
                inputRef: t
              }, a) => {
                const _ref25 = typeof y == "function" ? y(a) || {} : y || {},
                  o = _ref25.onPaste,
                  s = _ref25.onFocus,
                  h = _ref25.onKeyDown,
                  i = _ref25.className,
                  m = _ref25.onBlur,
                  F = _objectWithoutProperties(_ref25, _excluded13);
                return /* @__PURE__ */jsxRuntimeExports.jsx(Q, _objectSpread({
                  autoFocus: x ? a === 0 : !1,
                  autoComplete: "one-time-code",
                  value: e,
                  inputRef: t,
                  className: `MuiOtpInput-TextField MuiOtpInput-TextField-${a + 1} ${i || ""}`,
                  onPaste: r => {
                    r.preventDefault(), H(r), o === null || o === void 0 ? void 0 : o(r);
                  },
                  onFocus: r => {
                    r.preventDefault(), r.target.select(), s === null || s === void 0 ? void 0 : s(r);
                  },
                  onChange: Y,
                  onKeyDown: r => {
                    _(r), h === null || h === void 0 ? void 0 : h(r);
                  },
                  onBlur: r => {
                    m !== null && m !== void 0 && m(r), L(r);
                  }
                }, F), a);
              })
            }));
          });
        function RHFCode(_ref26) {
          let name = _ref26.name,
            other = _objectWithoutProperties(_ref26, _excluded14);
          const _useFormContext2 = useFormContext(),
            control = _useFormContext2.control;
          return /* @__PURE__ */jsxRuntimeExports.jsx(Controller, {
            name,
            control,
            render: ({
              field,
              fieldState: {
                error
              }
            }) => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(oe, _objectSpread(_objectSpread({}, field), {}, {
                autoFocus: true,
                gap: 1.5,
                length: 6,
                TextFieldsProps: {
                  error: !!error,
                  placeholder: "-"
                }
              }, other)), error && /* @__PURE__ */jsxRuntimeExports.jsx(FormHelperText, {
                sx: {
                  px: 2
                },
                error: true,
                children: error.message
              })]
            })
          });
        }
        RHFCode.propTypes = {
          name: PropTypes.string
        };
        ({
          helperText: PropTypes.string,
          name: PropTypes.string
        });
        function RHFSwitch(_ref27) {
          let name = _ref27.name,
            helperText = _ref27.helperText,
            other = _objectWithoutProperties(_ref27, _excluded15);
          const context = useFormContext();
          if (!context) {
            return /* @__PURE__ */jsxRuntimeExports.jsx(FormControlLabel, _objectSpread({
              control: /* @__PURE__ */jsxRuntimeExports.jsx(Switch, _objectSpread(_objectSpread({}, other), {}, {
                name,
                checked: other.checked
              }))
            }, other));
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(Controller, {
            name,
            control,
            render: ({
              field,
              fieldState: {
                error
              }
            }) => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormControlLabel, _objectSpread({
                control: /* @__PURE__ */jsxRuntimeExports.jsx(Switch, _objectSpread(_objectSpread({}, field), {}, {
                  checked: field.value
                }))
              }, other)), (!!error || helperText) && /* @__PURE__ */jsxRuntimeExports.jsx(FormHelperText, {
                error: !!error,
                children: error ? error === null || error === void 0 ? void 0 : error.message : helperText
              })]
            })
          });
        }
        RHFSwitch.propTypes = {
          helperText: PropTypes.string,
          name: PropTypes.string
        };
        function RHFTextField(_ref28) {
          let name = _ref28.name,
            helperText = _ref28.helperText,
            type = _ref28.type,
            other = _objectWithoutProperties(_ref28, _excluded16);
          const context = useFormContext();
          if (!context) {
            return /* @__PURE__ */jsxRuntimeExports.jsx(TextField, _objectSpread({
              fullWidth: true,
              type,
              helperText
            }, other));
          }
          const control = context.control;
          return /* @__PURE__ */jsxRuntimeExports.jsx(Controller, {
            name,
            control,
            render: ({
              field,
              fieldState: {
                error
              }
            }) => /* @__PURE__ */jsxRuntimeExports.jsx(TextField, _objectSpread(_objectSpread({}, field), {}, {
              fullWidth: true,
              type,
              value: type === "number" && field.value === 0 ? "" : field.value,
              onChange: event => {
                if (type === "number") {
                  field.onChange(Number(event.target.value));
                } else {
                  field.onChange(event.target.value);
                }
              },
              error: !!error,
              helperText: error ? error === null || error === void 0 ? void 0 : error.message : helperText
            }, other))
          });
        }
        RHFTextField.propTypes = {
          helperText: PropTypes.string,
          name: PropTypes.string,
          type: PropTypes.string
        };
        ({
          helperText: PropTypes.string,
          label: PropTypes.string,
          name: PropTypes.string,
          options: PropTypes.array,
          row: PropTypes.bool,
          spacing: PropTypes.number
        });
        ({
          name: PropTypes.string,
          type: PropTypes.string,
          label: PropTypes.string,
          helperText: PropTypes.node,
          hiddenLabel: PropTypes.bool,
          placeholder: PropTypes.string
        });
        const SurveyClone = exports("f", ({
          open,
          onClose: _onClose,
          survey
        }) => {
          const surveyService = useService("survey");
          const _useTranslation8 = useTranslation("manage"),
            t = _useTranslation8.t;
          const _reactExports$useStat15 = reactExports.useState(""),
            _reactExports$useStat16 = _slicedToArray(_reactExports$useStat15, 2),
            newSurveyName = _reactExports$useStat16[0],
            setNewSurveyName = _reactExports$useStat16[1];
          const _reactExports$useStat17 = reactExports.useState(""),
            _reactExports$useStat18 = _slicedToArray(_reactExports$useStat17, 2),
            newSurveyNameError = _reactExports$useStat18[0],
            setNewSurveyNameError = _reactExports$useStat18[1];
          const dispatch = useDispatch();
          const onSurveyNameChanged = e => {
            setNewSurveyName(e.target.value);
            setNewSurveyNameError("");
          };
          const validate = () => {
            setNewSurveyNameError("");
            if (newSurveyName.length == 0) {
              setNewSurveyNameError(t("survey_required"));
              return false;
            }
            return true;
          };
          const cloneSurvey = () => {
            if (!validate()) {
              return;
            }
            dispatch(setLoading(true));
            const data = {
              name: newSurveyName
            };
            if (survey.example) {
              surveyService.cloneGuestSurvey(survey.id, data).then(() => {
                _onClose(true);
                setNewSurveyName("");
              }).catch(processedError => {
                if (processedError.name == PROCESSED_ERRORS.DUPLICATE_SURVEY_NAME.name) {
                  setNewSurveyNameError(t(`processed_errors.${processedError.name}`));
                }
              }).finally(() => {
                dispatch(setLoading(false));
              });
            } else {
              surveyService.cloneSurvey(survey.id, data).then(() => {
                _onClose(true);
                setNewSurveyName("");
              }).catch(processedError => {
                if (processedError.name == PROCESSED_ERRORS.DUPLICATE_SURVEY_NAME.name) {
                  setNewSurveyNameError(t(`processed_errors.${processedError.name}`));
                }
              }).finally(() => {
                dispatch(setLoading(false));
              });
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx(Modal, {
              sx: {
                ".MuiBackdrop-root": {
                  backgroundColor: "rgba(0, 0, 0, 0.3)"
                }
              },
              open,
              onClose: () => _onClose(false),
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                className: styles.wrapper,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Typography, {
                  fontWeight: 600,
                  variant: "h5",
                  children: t("edit_survey.clone_survey")
                }), /* @__PURE__ */jsxRuntimeExports.jsx(RHFTextField, {
                  error: newSurveyNameError.length > 0,
                  sx: {
                    minWidth: "400px",
                    mt: 2
                  },
                  required: true,
                  value: newSurveyName,
                  label: t("label.new_survey_name"),
                  onChange: onSurveyNameChanged,
                  helperText: newSurveyNameError
                }), /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                  className: styles.action,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                    size: "medium",
                    color: "inherit",
                    variant: "contained",
                    onClick: () => _onClose(false),
                    children: t("action_btn.cancel")
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                    size: "medium",
                    color: "inherit",
                    variant: "contained",
                    type: "submit",
                    onClick: cloneSurvey,
                    sx: {
                      ml: 1
                    },
                    children: t("action_btn.save")
                  })]
                })]
              })
            })
          });
        });
        function PreviewSurvey({
          guest = false
        }) {
          const _useSearchParams = useSearchParams(),
            _useSearchParams2 = _slicedToArray(_useSearchParams, 1),
            searchParams = _useSearchParams2[0];
          const _reactExports$useStat19 = reactExports.useState(searchParams.get("mode") || "online"),
            _reactExports$useStat20 = _slicedToArray(_reactExports$useStat19, 2),
            previewMode = _reactExports$useStat20[0],
            setPreviewMode = _reactExports$useStat20[1];
          const surveyId = getparam(useParams(), "surveyId");
          const surveyModel = {
            id: surveyId,
            example: true
          };
          reactExports.useEffect(() => {
            const handlePopState = () => {
              const searchParams2 = new URLSearchParams(window.location.search);
              const mode = searchParams2.get("mode") || "online";
              setPreviewMode(mode);
            };
            window.addEventListener("popstate", handlePopState);
            return () => {
              window.removeEventListener("popstate", handlePopState);
            };
          }, []);
          const withEmbeddedParam = (surveyId2, previewMode2) => {
            return (guest ? routes.iframePreviewGuestSurvey : routes.iframePreviewSurvey).replace(":surveyId", surveyId2) + "?mode=" + previewMode2;
          };
          const handleChange = (event, newValue) => {
            setPreviewMode(newValue);
          };
          const _reactExports$useStat21 = reactExports.useState(false),
            _reactExports$useStat22 = _slicedToArray(_reactExports$useStat21, 2),
            openCloneModal = _reactExports$useStat22[0],
            setOpenCloneModal = _reactExports$useStat22[1];
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(SurveyClone, {
              open: openCloneModal,
              onClose: cloned => {
                setOpenCloneModal(false);
                if (cloned) {
                  fetchSurveys();
                }
              },
              survey: surveyModel
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              display: "flex",
              position: "relative",
              width: "100%",
              justifyContent: "center",
              children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Tabs, {
                value: previewMode,
                onChange: handleChange,
                "aria-label": "Preview mode tabs",
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Tab, {
                  component: Link,
                  to: `${(guest ? routes.guestPreview : routes.preview).replace(":surveyId", surveyId)}?mode=${PREVIEW_MODE.ONLINE}`,
                  value: PREVIEW_MODE.ONLINE,
                  label: /* @__PURE__ */jsxRuntimeExports.jsx(SurveyIcon, {
                    name: "pc"
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Tab, {
                  component: Link,
                  to: `${(guest ? routes.guestPreview : routes.preview).replace(":surveyId", surveyId)}?mode=${PREVIEW_MODE.ONLINE_PHONE}`,
                  value: PREVIEW_MODE.ONLINE_PHONE,
                  label: /* @__PURE__ */jsxRuntimeExports.jsx(SurveyIcon, {
                    name: "phone"
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Tab, {
                  component: Link,
                  to: `${(guest ? routes.guestPreview : routes.preview).replace(":surveyId", surveyId)}?mode=${PREVIEW_MODE.OFFLINE}`,
                  value: PREVIEW_MODE.OFFLINE,
                  label: /* @__PURE__ */jsxRuntimeExports.jsx(SurveyIcon, {
                    name: "offline"
                  })
                })]
              }), guest && isSurveyAdmin() && /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                className: styles$1.iconButton,
                "aria-label": "stop",
                size: "large",
                onClick: () => setOpenCloneModal(true),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1, {
                  color: "primary"
                })
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$1.container,
              style: {
                backgroundColor: BG_COLOR
              },
              children: previewMode == "online" ? /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                style: {
                  height: "calc(100vh - 48px)"
                },
                children: /* @__PURE__ */jsxRuntimeExports.jsx("iframe", {
                  src: withEmbeddedParam(surveyId, previewMode),
                  className: styles$1.onlinePreview,
                  style: {
                    width: "100%",
                    height: "100%"
                  }
                })
              }) : previewMode == "online-phone" ? /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                children: /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                  className: styles$1.wrapperMob,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx("img", {
                    src: "/phone-android.png",
                    className: styles$1.phoneBg
                  }), /* @__PURE__ */jsxRuntimeExports.jsx("iframe", {
                    src: withEmbeddedParam(surveyId, previewMode),
                    className: styles$1.offlinePreview
                  })]
                })
              }) : /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                className: styles$1.wrapperMob,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx("img", {
                  src: "/phone-android.png",
                  className: styles$1.phoneBg
                }), /* @__PURE__ */jsxRuntimeExports.jsx("iframe", {
                  src: withEmbeddedParam(surveyId, previewMode),
                  className: styles$1.offlinePreview
                })]
              })
            })]
          });
        }
        const PreviewSurvey$1 = React.memo(PreviewSurvey);
        const Page404 = reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-CKF68ll1.js'), false ? __VITE_PRELOAD__ : void 0));
        const ForgotPasswordView = reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-Cyygz7p9.js'), false ? __VITE_PRELOAD__ : void 0));
        const ResetPasswordView = reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-QFjgDviD.js'), false ? __VITE_PRELOAD__ : void 0));
        const Dashboard = reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-Dc7_J1Xl.js'), false ? __VITE_PRELOAD__ : void 0));
        const LoginView = reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-yGdPKIVx.js'), false ? __VITE_PRELOAD__ : void 0));
        const ManageUsers = reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-DnOpdAwx.js'), false ? __VITE_PRELOAD__ : void 0));
        const ProfileView = reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-CAObAXBZ.js'), false ? __VITE_PRELOAD__ : void 0));
        const CreateSurvey = reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-DpFtkHUE.js'), false ? __VITE_PRELOAD__ : void 0));
        const RunSurvey = reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-VaWa31-C.js').then(n => n.i), false ? __VITE_PRELOAD__ : void 0));
        function Web() {
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Routes, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.runSurvey,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Provider, {
                  store: runStore,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(RunSurveyWrapper, {})
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.resumeSurvey,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Provider, {
                  store: runStore,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(RunSurveyWrapper, {
                    resume: true
                  })
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.iframePreviewSurvey,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Provider, {
                  store: runStore,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(PreviewSurveyWrapper, {})
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.iframePreviewGuestSurvey,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Provider, {
                  store: runStore,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(PreviewGuestSurveyWrapper, {})
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.designSurvey,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ManagePageWrapper, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(PrivateDesignSurvey, {
                    landingPage: MANAGE_SURVEY_LANDING_PAGES.DESIGN
                  })
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.preview,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ManagePageWrapper, {
                  showHeader: false,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(PrivatePreviewSurvey, {})
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.guestPreview,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ManagePageWrapper, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(PreviewSurvey$1, {
                    guest: true
                  })
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.editSurvey,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ManagePageWrapper, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(PrivateDesignSurvey, {
                    landingPage: MANAGE_SURVEY_LANDING_PAGES.SETTINGS
                  })
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.responses,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ManagePageWrapper, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(PrivateDesignSurvey, {
                    landingPage: MANAGE_SURVEY_LANDING_PAGES.RESPONSES
                  })
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.language,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ManagePageWrapper, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(PrivateDesignSurvey, {
                    landingPage: MANAGE_SURVEY_LANDING_PAGES.LANGUAGE
                  })
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.theme,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ManagePageWrapper, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(PrivateDesignSurvey, {
                    landingPage: MANAGE_SURVEY_LANDING_PAGES.THEME
                  })
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.manageUsers,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(PrivateManageUsers, {
                  roles: [ROLES.SUPER_ADMIN],
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(ManagePageWrapper, {
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(ManageUsers, {})
                  })
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.profile,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(PrivateComponent, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(ManagePageWrapper, {
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(ProfileView, {})
                  })
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.createSurvey,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(PrivateManageUsers, {
                  roles: [ROLES.SUPER_ADMIN, ROLES.SUPER_ADMIN],
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(ManagePageWrapper, {
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(CreateSurvey, {})
                  })
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.page404,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Page404, {})
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.dashboard,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(PrivateComponent, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(ManagePageWrapper, {
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(Dashboard, {})
                  })
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.login,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ManagePageWrapper, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(AuthIllustrationLayout, {
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(LoginView, {})
                  })
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.forgotPassword,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ManagePageWrapper, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(AuthIllustrationLayout, {
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(ForgotPasswordView, {})
                  })
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.resetPassword,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ManagePageWrapper, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(ResetPasswordView, {})
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
              path: routes.confirmNewUser,
              element: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ManagePageWrapper, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(ResetPasswordView, {
                    confirmNewUser: true
                  })
                })
              })
            })]
          });
        }
        const PrivateDesignSurvey = ({
          landingPage
        }) => {
          const params = useParams();
          sessionStorage.setItem("surveyId", params.surveyId);
          sessionStorage.setItem("isGuest", "0");
          const location = useLocation();
          return TokenService.isAuthenticated() ? /* @__PURE__ */jsxRuntimeExports.jsx(ManageSurvey$1, {
            landingPage
          }) : /* @__PURE__ */jsxRuntimeExports.jsx(Navigate, {
            to: "/login",
            replace: true,
            state: {
              from: location
            }
          });
        };
        const PrivatePreviewSurvey = () => {
          const params = useParams();
          sessionStorage.setItem("surveyId", params.surveyId);
          sessionStorage.setItem("isGuest", "0");
          const location = useLocation();
          return TokenService.isAuthenticated() ? /* @__PURE__ */jsxRuntimeExports.jsx(PreviewSurvey$1, {}) : /* @__PURE__ */jsxRuntimeExports.jsx(Navigate, {
            to: "/login",
            replace: true,
            state: {
              from: location
            }
          });
        };
        const PrivateComponent = ({
          children
        }) => {
          const location = useLocation();
          return TokenService.isAuthenticated() ? children : /* @__PURE__ */jsxRuntimeExports.jsx(Navigate, {
            to: "/login",
            replace: true,
            state: {
              from: location
            }
          });
        };
        const PrivateManageUsers = ({
          roles,
          children
        }) => {
          const location = useLocation();
          const user = TokenService.getUser();
          let hasCorrectRole = false;
          user.roles.forEach(el => {
            if (roles.indexOf(el) > -1) {
              hasCorrectRole = true;
            }
          });
          if (!hasCorrectRole) {
            return /* @__PURE__ */jsxRuntimeExports.jsx(Navigate, {
              to: "/",
              replace: true
            });
          }
          return TokenService.isAuthenticated() ? children : /* @__PURE__ */jsxRuntimeExports.jsx(Navigate, {
            to: "/login",
            replace: true,
            state: {
              from: location
            }
          });
        };
        const RunSurveyWrapper = ({
          resume = false
        }) => {
          const surveyId = getparam(useParams(), "surveyId");
          const responseId = getparam(useParams(), "responseId");
          sessionStorage.setItem("surveyId", surveyId);
          sessionStorage.setItem("isGuest", "0");
          return /* @__PURE__ */jsxRuntimeExports.jsx(RunSurvey, {
            responseId,
            resume
          });
        };
        const PreviewSurveyWrapper = () => {
          const surveyId = getparam(useParams(), "surveyId");
          sessionStorage.setItem("surveyId", surveyId);
          sessionStorage.setItem("isGuest", "0");
          const location = useLocation();
          const searchParams = new URLSearchParams(location.search);
          const mode = searchParams.get("mode") || "online";
          return /* @__PURE__ */jsxRuntimeExports.jsx(RunSurvey, {
            preview: true,
            mode
          });
        };
        const PreviewGuestSurveyWrapper = () => {
          const surveyId = getparam(useParams(), "surveyId");
          sessionStorage.setItem("surveyId", surveyId);
          sessionStorage.setItem("isGuest", "1");
          const location = useLocation();
          const searchParams = new URLSearchParams(location.search);
          const mode = searchParams.get("mode") || "online";
          return /* @__PURE__ */jsxRuntimeExports.jsx(RunSurvey, {
            preview: true,
            guest: true,
            mode
          });
        };
        const Web$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          default: Web
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        exports("X", Web$1);
      }
    };
  });
})();
//# sourceMappingURL=Web-legacy-fPm5GX2O.js.map

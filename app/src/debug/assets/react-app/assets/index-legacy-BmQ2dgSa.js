;
(function () {
  const _excluded5 = ["children"],
    _excluded6 = ["behavior", "align"],
    _excluded7 = ["done", "behavior", "align", "calculateViewLocation"],
    _excluded8 = ["listState", "topItemsIndexes"],
    _excluded9 = ["style", "children"],
    _excluded10 = ["style", "children"];
  function _toArray2(r) { return _arrayWithHoles2(r) || _iterableToArray2(r) || _unsupportedIterableToArray2(r) || _nonIterableRest2(); }
  function _iterableToArray2(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
  function _objectDestructuringEmpty(t) { if (null == t) throw new TypeError("Cannot destructure " + t); }
  function _createForOfIteratorHelper2(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray2(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n2 = 0, F = function F() {}; return { s: F, n: function n() { return _n2 >= r.length ? { done: !0 } : { done: !1, value: r[_n2++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
  function _objectWithoutProperties2(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose2(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
  function _objectWithoutPropertiesLoose2(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }
  function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
  function _asyncToGenerator2(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
  function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty2(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  function _defineProperty2(e, r, t) { return (r = _toPropertyKey2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
  function _toPropertyKey2(t) { var i = _toPrimitive2(t, "string"); return "symbol" == typeof i ? i : i + ""; }
  function _toPrimitive2(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
  function _slicedToArray2(r, e) { return _arrayWithHoles2(r) || _iterableToArrayLimit2(r, e) || _unsupportedIterableToArray2(r, e) || _nonIterableRest2(); }
  function _nonIterableRest2() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _unsupportedIterableToArray2(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray2(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray2(r, a) : void 0; } }
  function _arrayLikeToArray2(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
  function _iterableToArrayLimit2(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
  function _arrayWithHoles2(r) { if (Array.isArray(r)) return r; }
  System.register(['./index-legacy-VHGc_nGn.js', './use-service-legacy-uNDfwPef.js', './common-legacy-JH1w4dyZ.js', './Web-legacy-fzNrSyYZ.js', './isTouchDevice-legacy-Ch1rHmnJ.js', './Image-legacy-65ZyvYOU.js', './TextField-legacy-CDzaE-C1.js', './TableRow-legacy-ClORoloW.js', './TableHead-legacy-wGIlEGlg.js', './TableCell-legacy-CqnzAtHi.js', './Radio-legacy-dg8Bfgp8.js', './useDrop-legacy-BTGolgYQ.js', './index-legacy-Dtc24V4J.js', './DateTimePicker-legacy-X5AwAxHu.js', './Tabs-legacy-DPncV328.js', './index-legacy-YuyNrEK9.js', './index-legacy-JdUn7nhf.js', './Close-legacy-DueKC2rz.js', './FormControlLabel-legacy-DpQMzcK5.js', './Checkbox-legacy-CWdBtU_X.js', './DatePicker-legacy-CEXOUu38.js', './Delete-legacy-C-Yly2w_.js', './Card-legacy-D9YP2dW9.js', './survey-legacy-CmPJYFAs.js', './use-boolean-legacy-BSkT80lk.js', './radioClasses-legacy-C6EYZIXu.js', './tableRowClasses-legacy-D6iguAwE.js', './SwitchBase-legacy-CGnhZDR0.js', './RadioGroupContext-legacy-i7ufngjp.js', './InputAdornment-legacy-DXbKBg9u.js'], function (exports, module) {
    'use strict';

    var _objectWithoutPropertiesLoose, getDefaultExportFromCjs, reactExports, I18nContext, getDefaults, _defineProperty$4, _typeof$3, getI18n, _extends$h, generateUtilityClass, generateUtilityClasses, capitalize$1, jsxRuntimeExports, clsx, alpha_1, clamp, lighten_1, darken_1, emphasize_1, interopRequireDefaultExports, Box, commonjsGlobal, reactDomExports, React, useTheme$1, LoadingDots, ReactDOM, _arrayLikeToArray$h, _iterableToArray, _unsupportedIterableToArray$h, _toArray, _inherits$b, _createClass$9, _classCallCheck$b, _getPrototypeOf$1, _possibleConstructorReturn$b, createTheme, CacheProvider, I18nextProvider, warnOnce, warn$1, useId, useControlled, useEventCallback, setRef, styled, useDefaultProps, composeClasses, inputClasses, inputBaseClasses, outlinedInputClasses, filledInputClasses, IconButton, Paper, ArrowDropDownIcon, useForkRef, ButtonGroupContext, ButtonGroupButtonContext, Typography, rootShouldForwardProp, ButtonBase, listItemTextClasses, ListContext, getListItemTextUtilityClass, useIsFocusVisible, useEnhancedEffect, ownerDocument, extractEventHandlers, isHostComponent, slotShouldForwardProp, useRtl, useSlotProps, useTheme, Transition, reflow, getTransitionProps, useTimeout, isMuiElement, useDragDropManager, useCollector, createSvgIcon, requireCreateSvgIcon, useTranslation, useDispatch, useSelector, isGroup, isQuestion, setup, setupOptions, surveySetup$1, stripTags, manageStore, isNotEmptyHtml, changeContent, rtlLanguage, SurveyIcon, TextareaAutosize, inDesign, Button, useDrag, removeAnswer, onDrag, useService, changeResources, getContrastColor, contentEditable, axios, DESIGN_SURVEY_MODE, hasMajorSetup, deleteQuestion, cloneQuestion, nextId, addNewAnswer, questionIconByType, isDisplay, deleteGroup, changeAttribute, changeValidationValue, FormControl, Select, MenuItem, _slicedToArray$1, PropTypes, connect$1, Provider, createStore, Menu, ThemeProvider, truncateWithEllipsis, changeRelevance, removeSkipDestination, editSkipDestination, editSkipToEnd, instructionByCode, updatePriorityByType, updatePriority, updateRandomByType, updateRandom, Stack$7, defaultSurveyTheme, setupToggleExpand, resetSetup, NewComponentsPanel, isSessionRtl, cacheRtl, defualtTheme, Backdrop, setDesignModeToLang, setDesignModeToTheme, setDesignModeToReorder, buildResourceUrl, autocompleteClasses, ClearIcon, Chip, getAutocompleteUtilityClass, buttonGroupClasses, getButtonGroupUtilityClass, fabClasses, getFabUtilityClass, sliderClasses, getSliderUtilityClass, Tooltip, default_1$o, CustomTooltip, DialogTitle, Switch, CircularProgress, ListItemIcon, merge$5, KeyboardArrowDown, ManageLanguages, createSelector, ErrorOutlineOutlined, DndProvider, isTouchDevice, TouchBackend, HTML5Backend, usePreviousProps, default_1$p, DeleteModal, default_1$r, TextField, FormLabel, InputLabel, TableContainer, Table, TableRow, TableBody, TableHead, TableCell, Radio, useDrop, ReactPlayer, Grid$1, DialogActions, DateTimePicker, LocalizationProvider, Popper, Dialog, DialogContent, DynamicSvg, Collapse, HelpOutline, classNames, Accordion, AccordionSummary, default_1$s, AccordionDetails, CardMedia, Close, FormControlLabel, Checkbox, DatePicker, TimePicker, default_1$q, Card, NAVIGATION_MODE, useBoolean;
    return {
      setters: [module => {
        _objectWithoutPropertiesLoose = module.b;
        getDefaultExportFromCjs = module.w;
        reactExports = module.r;
        I18nContext = module.J;
        getDefaults = module.M;
        _defineProperty$4 = module.O;
        _typeof$3 = module.an;
        getI18n = module.P;
        _extends$h = module._;
        generateUtilityClass = module.g;
        generateUtilityClasses = module.f;
        capitalize$1 = module.h;
        jsxRuntimeExports = module.j;
        clsx = module.d;
        alpha_1 = module.k;
        clamp = module.a1;
        lighten_1 = module.l;
        darken_1 = module.i;
        emphasize_1 = module.o;
        interopRequireDefaultExports = module.q;
        Box = module.B;
        commonjsGlobal = module.p;
        reactDomExports = module.ai;
        React = module.R;
        useTheme$1 = module.y;
        LoadingDots = module.A;
        ReactDOM = module.ag;
        _arrayLikeToArray$h = module.ao;
        _iterableToArray = module.ap;
        _unsupportedIterableToArray$h = module.H;
        _toArray = module.aq;
        _inherits$b = module.ar;
        _createClass$9 = module.as;
        _classCallCheck$b = module.at;
        _getPrototypeOf$1 = module.au;
        _possibleConstructorReturn$b = module.av;
        createTheme = module.x;
        CacheProvider = module.C;
        I18nextProvider = module.aw;
      }, module => {
        warnOnce = module.bZ;
        warn$1 = module.b_;
        useId = module.C;
        useControlled = module.A;
        useEventCallback = module.k;
        setRef = module.b$;
        styled = module.f;
        useDefaultProps = module.j;
        composeClasses = module.c;
        inputClasses = module.c0;
        inputBaseClasses = module.al;
        outlinedInputClasses = module.am;
        filledInputClasses = module.an;
        IconButton = module.I;
        Paper = module.h;
        ArrowDropDownIcon = module.c1;
        useForkRef = module.b;
        ButtonGroupContext = module.bR;
        ButtonGroupButtonContext = module.c2;
        Typography = module.T;
        rootShouldForwardProp = module.l;
        ButtonBase = module.B;
        listItemTextClasses = module.c3;
        ListContext = module.L;
        getListItemTextUtilityClass = module.c4;
        useIsFocusVisible = module.D;
        useEnhancedEffect = module.n;
        ownerDocument = module.o;
        extractEventHandlers = module.v;
        isHostComponent = module.p;
        slotShouldForwardProp = module.c5;
        useRtl = module.z;
        useSlotProps = module.x;
        useTheme = module.w;
        Transition = module.be;
        reflow = module.bf;
        getTransitionProps = module.bg;
        useTimeout = module.t;
        isMuiElement = module.i;
        useDragDropManager = module.bM;
        useCollector = module.c6;
        createSvgIcon = module.e;
        requireCreateSvgIcon = module.K;
        useTranslation = module.M;
        useDispatch = module.U;
        useSelector = module.H;
        isGroup = module.c7;
        isQuestion = module.c8;
        setup = module.c9;
        setupOptions = module.ca;
        surveySetup$1 = module.cb;
        stripTags = module.bi;
        manageStore = module.aw;
        isNotEmptyHtml = module.cc;
        changeContent = module.cd;
        rtlLanguage = module.ap;
        SurveyIcon = module.aP;
        TextareaAutosize = module.ce;
        inDesign = module.cf;
        Button = module.aD;
        useDrag = module.b8;
        removeAnswer = module.cg;
        onDrag = module.ch;
        useService = module.R;
        changeResources = module.ci;
        getContrastColor = module.ba;
        contentEditable = module.cj;
        axios = module.ck;
        DESIGN_SURVEY_MODE = module.cl;
        hasMajorSetup = module.cm;
        deleteQuestion = module.cn;
        cloneQuestion = module.co;
        nextId = module.cp;
        addNewAnswer = module.cq;
        questionIconByType = module.bl;
        isDisplay = module.cr;
        deleteGroup = module.cs;
        changeAttribute = module.ct;
        changeValidationValue = module.cu;
        FormControl = module.ax;
        Select = module.S;
        MenuItem = module.N;
        _slicedToArray$1 = module.cv;
        PropTypes = module.a2;
        connect$1 = module.cw;
        Provider = module.P;
        createStore = module.bA;
        Menu = module.W;
        ThemeProvider = module.ar;
        truncateWithEllipsis = module.bc;
        changeRelevance = module.cx;
        removeSkipDestination = module.cy;
        editSkipDestination = module.cz;
        editSkipToEnd = module.cA;
        instructionByCode = module.cB;
        updatePriorityByType = module.cC;
        updatePriority = module.cD;
        updateRandomByType = module.cE;
        updateRandom = module.cF;
        Stack$7 = module.aL;
        defaultSurveyTheme = module.cG;
        setupToggleExpand = module.cH;
        resetSetup = module.aF;
        NewComponentsPanel = module.cI;
        isSessionRtl = module.cJ;
        cacheRtl = module.av;
        defualtTheme = module.bt;
        Backdrop = module.aW;
        setDesignModeToLang = module.cK;
        setDesignModeToTheme = module.cL;
        setDesignModeToReorder = module.cM;
      }, module => {
        buildResourceUrl = module.b;
      }, module => {
        autocompleteClasses = module.G;
        ClearIcon = module.H;
        Chip = module.J;
        getAutocompleteUtilityClass = module.L;
        buttonGroupClasses = module.M;
        getButtonGroupUtilityClass = module.N;
        fabClasses = module.O;
        getFabUtilityClass = module.P;
        sliderClasses = module.Q;
        getSliderUtilityClass = module.T;
        Tooltip = module.U;
        default_1$o = module.v;
        CustomTooltip = module.C;
        DialogTitle = module.D;
        Switch = module.V;
        CircularProgress = module.m;
        ListItemIcon = module.W;
        merge$5 = module.X;
        KeyboardArrowDown = module.K;
        ManageLanguages = module.Y;
      }, module => {
        createSelector = module.c;
        ErrorOutlineOutlined = module.E;
        DndProvider = module.D;
        isTouchDevice = module.i;
        TouchBackend = module.T;
        HTML5Backend = module.H;
      }, module => {
        usePreviousProps = module.u;
        default_1$p = module.a;
        DeleteModal = module.D;
        default_1$r = module.d;
      }, module => {
        TextField = module.T;
        FormLabel = module.F;
        InputLabel = module.I;
      }, module => {
        TableContainer = module.T;
        Table = module.a;
        TableRow = module.b;
        TableBody = module.c;
      }, module => {
        TableHead = module.T;
      }, module => {
        TableCell = module.T;
      }, module => {
        Radio = module.R;
      }, module => {
        useDrop = module.u;
      }, module => {
        ReactPlayer = module.R;
      }, module => {
        Grid$1 = module.G;
        DialogActions = module.q;
        DateTimePicker = module.D;
        LocalizationProvider = module.L;
      }, module => {
        Popper = module.P;
        Dialog = module.a;
        DialogContent = module.b;
      }, module => {
        DynamicSvg = module.D;
      }, module => {
        Collapse = module.C;
        HelpOutline = module.H;
        classNames = module.c;
        Accordion = module.A;
        AccordionSummary = module.a;
        default_1$s = module.d;
        AccordionDetails = module.b;
      }, module => {
        CardMedia = module.C;
        Close = module.a;
      }, module => {
        FormControlLabel = module.F;
      }, module => {
        Checkbox = module.C;
      }, module => {
        DatePicker = module.D;
        TimePicker = module.T;
      }, module => {
        default_1$q = module.d;
      }, module => {
        Card = module.C;
      }, module => {
        NAVIGATION_MODE = module.N;
      }, module => {
        useBoolean = module.u;
      }, null, null, null, null, null],
      execute: function execute() {
        var __vite_style__ = document.createElement('style');
        __vite_style__.textContent = "._noPadding_1ii70_1 {\n  padding: 0;\n}\n\n._addRow_1ii70_5 {\n  margin-top: 16px;\n}\n\n._addColumn_1ii70_9 {\n  text-align: right;\n}\n\n._addIcon_1ii70_13 {\n  width: 64px;\n  height: 64px;\n}\n\n._addIcon_1ii70_13 > svg {\n  width: 100%;\n  height: 100%;\n}\n\n._svgContainer_1ii70_23 {\n  text-align: center;\n}\n\n._svgContainer_1ii70_23 > svg {\n  width: 100%;\n  height: 100%;\n}\n._addButton_1ii70_31._addButton_1ii70_31 {\n  text-transform: none;\n  color: #16205b;\n  font-weight: bolder;\n  background-color: #e0e2ef;\n  border-radius: 9999px;\n  padding: 0.5rem 1rem;\n}\n._mainContainer_as1f9_1 {\n  display: flex;\n}\n\n._updateButtons_as1f9_5 {\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin-bottom: 20px;\n  margin-top: 20px;\n}\n\n._save_as1f9_14 {\n  margin-left: 10px;\n}\n\n._header_as1f9_18 {\n  max-width: 800px;\n}\n\n._groupEmptyHint_1pku9_2 {\n  text-align: center;\n  font-size: 32px;\n  padding: 16px;\n  color: gray;\n  margin: 16px;\n  border: 2px dashed gray;\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, 0);\n  transition: background-color 200ms;\n}\n\n._groupEmptyHintHover_1pku9_14 {\n  background-color: rgba(0, 0, 0, 0.1);\n}\n\n._footer_1pku9_18 {\n  height: 100px;\n}\n\n._contentPanel_1pku9_22 {\n  position: relative;\n  overflow-y: auto;\n  flex: 1 1 auto;\n  width: 100%;\n  height: calc(100vh - 64px);\n}\n\n._cardImage_1pku9_30 {\n  max-height: 22.5vw;\n  height: 160px;\n  width: 100%;\n  margin: auto;\n  background-size: cover;\n  background-position: center;\n}\n._customScrollBar_1pku9_38::-webkit-scrollbar {\n  width: 10px;\n}\n\n._virtuosoStyle_1pku9_42 {\n  width: 100%;\n  height: 100%;\n}\n\n._cardMediaContent_1pku9_47 {\n  max-width: 800px;\n  min-width: 350px;\n  margin-right: 16px;\n  margin-left: 16px;\n  margin: auto;\n}\n\n._buttonContainer_1pku9_55 {\n  display: flex;\n  align-items: center;\n  gap: 0px;\n  position: absolute;\n  top: 0;\n  right: 22.5rem;\n  z-index: 1;\n}\n._button_1pku9_55._button_1pku9_55 {\n  text-transform: none;\n  padding: 0.2rem 1rem;\n  background-color: white;\n  border-top-left-radius: 0px;\n  border-top-right-radius: 0px;\n  border-bottom-left-radius: 0px;\n  border-bottom-right-radius: 0px;\n  color: #16205b;\n}\n\n\n._button_1pku9_55._button_1pku9_55:hover {\n  background-color: #16205b;\n  color: white;\n}\n._errorDisplay_1joy4_1 {\n  margin-bottom: 15px;\n  border: 1px solid orange;\n  background-color: rgba(255, 166, 0, 0.13);\n  border-radius: 4px;\n  margin: 8px;\n  padding: 8px;\n}\n\n._clickable_1joy4_10 {\n  cursor: pointer;\n}\n._textDescriptionContent_o9cn8_1 {\n  display: flex;\n  align-items: center;\n  margin-top: 12px;\n}\n\n._moveBox_o9cn8_7 {\n  width: 100%;\n  display: flex;\n  justify-content: center;\n}\n\n._groupQuestion_o9cn8_13 {\n  position: relative;\n  padding: 1.5rem 1rem 1rem 1rem;\n  word-wrap: break-word;\n  page-break-inside: avoid;\n  transition: all 200ms cubic-bezier(0, 0, 0.2, 1);\n  cursor: default;\n}\n\n._titleContainer_o9cn8_22 {\n  display: flex;\n  align-items: center;\n  gap: .5rem;\n  word-break: break-all;\n}\n\n._titleQuestion_o9cn8_29 {\n  display: flex;\n  align-items: center;\n}\n\n._titleQuestion_o9cn8_29 h3 {\n  width: auto;\n}\n\n\n._iconBox_o9cn8_39 {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  color: #16205b;\n  font-weight: bold;\n}\n\n@keyframes _fadeInMoveRight_o9cn8_1 {\n  0% {\n    opacity: 0;\n    transform: translateX(10px);\n  }\n\n  100% {\n    opacity: 1;\n    transform: translateX(0);\n  }\n}\n\n._actionToolbarVisible_o9cn8_59 {\n  width: 100%;\n  animation: _fadeInMoveRight_o9cn8_1 0.75s ease-out forwards;\n}\n\n._contentContainer_o9cn8_64._contentContainer_o9cn8_64 {\n  position: absolute;\n  top: -5px;\n  right: 0px;\n  width: 100%;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}._fullWidth_1dvff_1 {\n  width: 100%;\n  cursor: text;\n}\n\n._toolbarClass_1dvff_6 div ._rdw-editor-toolbar_1dvff_6 {\n  border: 0 !important;\n  margin: 0 !important;\n  padding: 0 !important;\n}\n\n._noPadding_1dvff_12 > :last-child {\n  margin-bottom: 0;\n}\n\n._noPadding_1dvff_12 > :first-child {\n  margin-top: 0;\n}\n\np {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n._placeholder_1dvff_25 {\n  color: #aaa;\n}\n\n._placeholder_1dvff_25 > :first-child {\n  margin-top: 0;\n}\n\n._placeholder_1dvff_25 > :last-child {\n  margin-bottom: 0;\n}\n.ql-editor {\n  padding: 0 !important;\n}\n\n.ql-container {\n  font-size: inherit !important;\n  font-family: inherit !important;\n}\n\n.ql-snow {\n  padding: 0 !important;\n  border: 0 !important;\n}\n\n.quill {\n  display: flex;\n  flex-direction: column-reverse;\n}\n\n.rtl .ql-editor {\n  direction: rtl !important;\n  text-align: right !important;\n}\n\n.rtl {\n  direction: rtl !important;\n  text-align: right !important;\n}\n/*!\n * Quill Editor v1.3.7\n * https://quilljs.com/\n * Copyright (c) 2014, Jason Chen\n * Copyright (c) 2013, salesforce.com\n */\n.ql-container {\n  box-sizing: border-box;\n  font-family: Helvetica, Arial, sans-serif;\n  font-size: 13px;\n  height: 100%;\n  margin: 0px;\n  position: relative;\n}\n.ql-container.ql-disabled .ql-tooltip {\n  visibility: hidden;\n}\n.ql-container.ql-disabled .ql-editor ul[data-checked] > li::before {\n  pointer-events: none;\n}\n.ql-clipboard {\n  left: -100000px;\n  height: 1px;\n  overflow-y: hidden;\n  position: absolute;\n  top: 50%;\n}\n.ql-clipboard p {\n  margin: 0;\n  padding: 0;\n}\n.ql-editor {\n  box-sizing: border-box;\n  line-height: 1.42;\n  height: 100%;\n  outline: none;\n  overflow-y: auto;\n  padding: 12px 15px;\n  tab-size: 4;\n  -moz-tab-size: 4;\n  text-align: left;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n}\n.ql-editor > * {\n  cursor: text;\n}\n.ql-editor p,\n.ql-editor ol,\n.ql-editor ul,\n.ql-editor pre,\n.ql-editor blockquote,\n.ql-editor h1,\n.ql-editor h2,\n.ql-editor h3,\n.ql-editor h4,\n.ql-editor h5,\n.ql-editor h6 {\n  margin: 0;\n  padding: 0;\n  counter-reset: list-1 list-2 list-3 list-4 list-5 list-6 list-7 list-8 list-9;\n}\n.ql-editor ol,\n.ql-editor ul {\n  padding-left: 1.5em;\n}\n.ql-editor ol > li,\n.ql-editor ul > li {\n  list-style-type: none;\n}\n.ql-editor ul > li::before {\n  content: '\\2022';\n}\n.ql-editor ul[data-checked=true],\n.ql-editor ul[data-checked=false] {\n  pointer-events: none;\n}\n.ql-editor ul[data-checked=true] > li *,\n.ql-editor ul[data-checked=false] > li * {\n  pointer-events: all;\n}\n.ql-editor ul[data-checked=true] > li::before,\n.ql-editor ul[data-checked=false] > li::before {\n  color: #777;\n  cursor: pointer;\n  pointer-events: all;\n}\n.ql-editor ul[data-checked=true] > li::before {\n  content: '\\2611';\n}\n.ql-editor ul[data-checked=false] > li::before {\n  content: '\\2610';\n}\n.ql-editor li::before {\n  display: inline-block;\n  white-space: nowrap;\n  width: 1.2em;\n}\n.ql-editor li:not(.ql-direction-rtl)::before {\n  margin-left: -1.5em;\n  margin-right: 0.3em;\n  text-align: right;\n}\n.ql-editor li.ql-direction-rtl::before {\n  margin-left: 0.3em;\n  margin-right: -1.5em;\n}\n.ql-editor ol li:not(.ql-direction-rtl),\n.ql-editor ul li:not(.ql-direction-rtl) {\n  padding-left: 1.5em;\n}\n.ql-editor ol li.ql-direction-rtl,\n.ql-editor ul li.ql-direction-rtl {\n  padding-right: 1.5em;\n}\n.ql-editor ol li {\n  counter-reset: list-1 list-2 list-3 list-4 list-5 list-6 list-7 list-8 list-9;\n  counter-increment: list-0;\n}\n.ql-editor ol li:before {\n  content: counter(list-0, decimal) '. ';\n}\n.ql-editor ol li.ql-indent-1 {\n  counter-increment: list-1;\n}\n.ql-editor ol li.ql-indent-1:before {\n  content: counter(list-1, lower-alpha) '. ';\n}\n.ql-editor ol li.ql-indent-1 {\n  counter-reset: list-2 list-3 list-4 list-5 list-6 list-7 list-8 list-9;\n}\n.ql-editor ol li.ql-indent-2 {\n  counter-increment: list-2;\n}\n.ql-editor ol li.ql-indent-2:before {\n  content: counter(list-2, lower-roman) '. ';\n}\n.ql-editor ol li.ql-indent-2 {\n  counter-reset: list-3 list-4 list-5 list-6 list-7 list-8 list-9;\n}\n.ql-editor ol li.ql-indent-3 {\n  counter-increment: list-3;\n}\n.ql-editor ol li.ql-indent-3:before {\n  content: counter(list-3, decimal) '. ';\n}\n.ql-editor ol li.ql-indent-3 {\n  counter-reset: list-4 list-5 list-6 list-7 list-8 list-9;\n}\n.ql-editor ol li.ql-indent-4 {\n  counter-increment: list-4;\n}\n.ql-editor ol li.ql-indent-4:before {\n  content: counter(list-4, lower-alpha) '. ';\n}\n.ql-editor ol li.ql-indent-4 {\n  counter-reset: list-5 list-6 list-7 list-8 list-9;\n}\n.ql-editor ol li.ql-indent-5 {\n  counter-increment: list-5;\n}\n.ql-editor ol li.ql-indent-5:before {\n  content: counter(list-5, lower-roman) '. ';\n}\n.ql-editor ol li.ql-indent-5 {\n  counter-reset: list-6 list-7 list-8 list-9;\n}\n.ql-editor ol li.ql-indent-6 {\n  counter-increment: list-6;\n}\n.ql-editor ol li.ql-indent-6:before {\n  content: counter(list-6, decimal) '. ';\n}\n.ql-editor ol li.ql-indent-6 {\n  counter-reset: list-7 list-8 list-9;\n}\n.ql-editor ol li.ql-indent-7 {\n  counter-increment: list-7;\n}\n.ql-editor ol li.ql-indent-7:before {\n  content: counter(list-7, lower-alpha) '. ';\n}\n.ql-editor ol li.ql-indent-7 {\n  counter-reset: list-8 list-9;\n}\n.ql-editor ol li.ql-indent-8 {\n  counter-increment: list-8;\n}\n.ql-editor ol li.ql-indent-8:before {\n  content: counter(list-8, lower-roman) '. ';\n}\n.ql-editor ol li.ql-indent-8 {\n  counter-reset: list-9;\n}\n.ql-editor ol li.ql-indent-9 {\n  counter-increment: list-9;\n}\n.ql-editor ol li.ql-indent-9:before {\n  content: counter(list-9, decimal) '. ';\n}\n.ql-editor .ql-indent-1:not(.ql-direction-rtl) {\n  padding-left: 3em;\n}\n.ql-editor li.ql-indent-1:not(.ql-direction-rtl) {\n  padding-left: 4.5em;\n}\n.ql-editor .ql-indent-1.ql-direction-rtl.ql-align-right {\n  padding-right: 3em;\n}\n.ql-editor li.ql-indent-1.ql-direction-rtl.ql-align-right {\n  padding-right: 4.5em;\n}\n.ql-editor .ql-indent-2:not(.ql-direction-rtl) {\n  padding-left: 6em;\n}\n.ql-editor li.ql-indent-2:not(.ql-direction-rtl) {\n  padding-left: 7.5em;\n}\n.ql-editor .ql-indent-2.ql-direction-rtl.ql-align-right {\n  padding-right: 6em;\n}\n.ql-editor li.ql-indent-2.ql-direction-rtl.ql-align-right {\n  padding-right: 7.5em;\n}\n.ql-editor .ql-indent-3:not(.ql-direction-rtl) {\n  padding-left: 9em;\n}\n.ql-editor li.ql-indent-3:not(.ql-direction-rtl) {\n  padding-left: 10.5em;\n}\n.ql-editor .ql-indent-3.ql-direction-rtl.ql-align-right {\n  padding-right: 9em;\n}\n.ql-editor li.ql-indent-3.ql-direction-rtl.ql-align-right {\n  padding-right: 10.5em;\n}\n.ql-editor .ql-indent-4:not(.ql-direction-rtl) {\n  padding-left: 12em;\n}\n.ql-editor li.ql-indent-4:not(.ql-direction-rtl) {\n  padding-left: 13.5em;\n}\n.ql-editor .ql-indent-4.ql-direction-rtl.ql-align-right {\n  padding-right: 12em;\n}\n.ql-editor li.ql-indent-4.ql-direction-rtl.ql-align-right {\n  padding-right: 13.5em;\n}\n.ql-editor .ql-indent-5:not(.ql-direction-rtl) {\n  padding-left: 15em;\n}\n.ql-editor li.ql-indent-5:not(.ql-direction-rtl) {\n  padding-left: 16.5em;\n}\n.ql-editor .ql-indent-5.ql-direction-rtl.ql-align-right {\n  padding-right: 15em;\n}\n.ql-editor li.ql-indent-5.ql-direction-rtl.ql-align-right {\n  padding-right: 16.5em;\n}\n.ql-editor .ql-indent-6:not(.ql-direction-rtl) {\n  padding-left: 18em;\n}\n.ql-editor li.ql-indent-6:not(.ql-direction-rtl) {\n  padding-left: 19.5em;\n}\n.ql-editor .ql-indent-6.ql-direction-rtl.ql-align-right {\n  padding-right: 18em;\n}\n.ql-editor li.ql-indent-6.ql-direction-rtl.ql-align-right {\n  padding-right: 19.5em;\n}\n.ql-editor .ql-indent-7:not(.ql-direction-rtl) {\n  padding-left: 21em;\n}\n.ql-editor li.ql-indent-7:not(.ql-direction-rtl) {\n  padding-left: 22.5em;\n}\n.ql-editor .ql-indent-7.ql-direction-rtl.ql-align-right {\n  padding-right: 21em;\n}\n.ql-editor li.ql-indent-7.ql-direction-rtl.ql-align-right {\n  padding-right: 22.5em;\n}\n.ql-editor .ql-indent-8:not(.ql-direction-rtl) {\n  padding-left: 24em;\n}\n.ql-editor li.ql-indent-8:not(.ql-direction-rtl) {\n  padding-left: 25.5em;\n}\n.ql-editor .ql-indent-8.ql-direction-rtl.ql-align-right {\n  padding-right: 24em;\n}\n.ql-editor li.ql-indent-8.ql-direction-rtl.ql-align-right {\n  padding-right: 25.5em;\n}\n.ql-editor .ql-indent-9:not(.ql-direction-rtl) {\n  padding-left: 27em;\n}\n.ql-editor li.ql-indent-9:not(.ql-direction-rtl) {\n  padding-left: 28.5em;\n}\n.ql-editor .ql-indent-9.ql-direction-rtl.ql-align-right {\n  padding-right: 27em;\n}\n.ql-editor li.ql-indent-9.ql-direction-rtl.ql-align-right {\n  padding-right: 28.5em;\n}\n.ql-editor .ql-video {\n  display: block;\n  max-width: 100%;\n}\n.ql-editor .ql-video.ql-align-center {\n  margin: 0 auto;\n}\n.ql-editor .ql-video.ql-align-right {\n  margin: 0 0 0 auto;\n}\n.ql-editor .ql-bg-black {\n  background-color: #000;\n}\n.ql-editor .ql-bg-red {\n  background-color: #e60000;\n}\n.ql-editor .ql-bg-orange {\n  background-color: #f90;\n}\n.ql-editor .ql-bg-yellow {\n  background-color: #ff0;\n}\n.ql-editor .ql-bg-green {\n  background-color: #008a00;\n}\n.ql-editor .ql-bg-blue {\n  background-color: #06c;\n}\n.ql-editor .ql-bg-purple {\n  background-color: #93f;\n}\n.ql-editor .ql-color-white {\n  color: #fff;\n}\n.ql-editor .ql-color-red {\n  color: #e60000;\n}\n.ql-editor .ql-color-orange {\n  color: #f90;\n}\n.ql-editor .ql-color-yellow {\n  color: #ff0;\n}\n.ql-editor .ql-color-green {\n  color: #008a00;\n}\n.ql-editor .ql-color-blue {\n  color: #06c;\n}\n.ql-editor .ql-color-purple {\n  color: #93f;\n}\n.ql-editor .ql-font-serif {\n  font-family: Georgia, Times New Roman, serif;\n}\n.ql-editor .ql-font-monospace {\n  font-family: Monaco, Courier New, monospace;\n}\n.ql-editor .ql-size-small {\n  font-size: 0.75em;\n}\n.ql-editor .ql-size-large {\n  font-size: 1.5em;\n}\n.ql-editor .ql-size-huge {\n  font-size: 2.5em;\n}\n.ql-editor .ql-direction-rtl {\n  direction: rtl;\n  text-align: inherit;\n}\n.ql-editor .ql-align-center {\n  text-align: center;\n}\n.ql-editor .ql-align-justify {\n  text-align: justify;\n}\n.ql-editor .ql-align-right {\n  text-align: right;\n}\n.ql-editor.ql-blank::before {\n  color: rgba(0,0,0,0.6);\n  content: attr(data-placeholder);\n  font-style: italic;\n  left: 15px;\n  pointer-events: none;\n  position: absolute;\n  right: 15px;\n}\n.ql-snow.ql-toolbar:after,\n.ql-snow .ql-toolbar:after {\n  clear: both;\n  content: '';\n  display: table;\n}\n.ql-snow.ql-toolbar button,\n.ql-snow .ql-toolbar button {\n  background: none;\n  border: none;\n  cursor: pointer;\n  display: inline-block;\n  float: left;\n  height: 24px;\n  padding: 3px 5px;\n  width: 28px;\n}\n.ql-snow.ql-toolbar button svg,\n.ql-snow .ql-toolbar button svg {\n  float: left;\n  height: 100%;\n}\n.ql-snow.ql-toolbar button:active:hover,\n.ql-snow .ql-toolbar button:active:hover {\n  outline: none;\n}\n.ql-snow.ql-toolbar input.ql-image[type=file],\n.ql-snow .ql-toolbar input.ql-image[type=file] {\n  display: none;\n}\n.ql-snow.ql-toolbar button:hover,\n.ql-snow .ql-toolbar button:hover,\n.ql-snow.ql-toolbar button:focus,\n.ql-snow .ql-toolbar button:focus,\n.ql-snow.ql-toolbar button.ql-active,\n.ql-snow .ql-toolbar button.ql-active,\n.ql-snow.ql-toolbar .ql-picker-label:hover,\n.ql-snow .ql-toolbar .ql-picker-label:hover,\n.ql-snow.ql-toolbar .ql-picker-label.ql-active,\n.ql-snow .ql-toolbar .ql-picker-label.ql-active,\n.ql-snow.ql-toolbar .ql-picker-item:hover,\n.ql-snow .ql-toolbar .ql-picker-item:hover,\n.ql-snow.ql-toolbar .ql-picker-item.ql-selected,\n.ql-snow .ql-toolbar .ql-picker-item.ql-selected {\n  color: #06c;\n}\n.ql-snow.ql-toolbar button:hover .ql-fill,\n.ql-snow .ql-toolbar button:hover .ql-fill,\n.ql-snow.ql-toolbar button:focus .ql-fill,\n.ql-snow .ql-toolbar button:focus .ql-fill,\n.ql-snow.ql-toolbar button.ql-active .ql-fill,\n.ql-snow .ql-toolbar button.ql-active .ql-fill,\n.ql-snow.ql-toolbar .ql-picker-label:hover .ql-fill,\n.ql-snow .ql-toolbar .ql-picker-label:hover .ql-fill,\n.ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-fill,\n.ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-fill,\n.ql-snow.ql-toolbar .ql-picker-item:hover .ql-fill,\n.ql-snow .ql-toolbar .ql-picker-item:hover .ql-fill,\n.ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-fill,\n.ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-fill,\n.ql-snow.ql-toolbar button:hover .ql-stroke.ql-fill,\n.ql-snow .ql-toolbar button:hover .ql-stroke.ql-fill,\n.ql-snow.ql-toolbar button:focus .ql-stroke.ql-fill,\n.ql-snow .ql-toolbar button:focus .ql-stroke.ql-fill,\n.ql-snow.ql-toolbar button.ql-active .ql-stroke.ql-fill,\n.ql-snow .ql-toolbar button.ql-active .ql-stroke.ql-fill,\n.ql-snow.ql-toolbar .ql-picker-label:hover .ql-stroke.ql-fill,\n.ql-snow .ql-toolbar .ql-picker-label:hover .ql-stroke.ql-fill,\n.ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-stroke.ql-fill,\n.ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-stroke.ql-fill,\n.ql-snow.ql-toolbar .ql-picker-item:hover .ql-stroke.ql-fill,\n.ql-snow .ql-toolbar .ql-picker-item:hover .ql-stroke.ql-fill,\n.ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-stroke.ql-fill,\n.ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-stroke.ql-fill {\n  fill: #06c;\n}\n.ql-snow.ql-toolbar button:hover .ql-stroke,\n.ql-snow .ql-toolbar button:hover .ql-stroke,\n.ql-snow.ql-toolbar button:focus .ql-stroke,\n.ql-snow .ql-toolbar button:focus .ql-stroke,\n.ql-snow.ql-toolbar button.ql-active .ql-stroke,\n.ql-snow .ql-toolbar button.ql-active .ql-stroke,\n.ql-snow.ql-toolbar .ql-picker-label:hover .ql-stroke,\n.ql-snow .ql-toolbar .ql-picker-label:hover .ql-stroke,\n.ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-stroke,\n.ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-stroke,\n.ql-snow.ql-toolbar .ql-picker-item:hover .ql-stroke,\n.ql-snow .ql-toolbar .ql-picker-item:hover .ql-stroke,\n.ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-stroke,\n.ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-stroke,\n.ql-snow.ql-toolbar button:hover .ql-stroke-miter,\n.ql-snow .ql-toolbar button:hover .ql-stroke-miter,\n.ql-snow.ql-toolbar button:focus .ql-stroke-miter,\n.ql-snow .ql-toolbar button:focus .ql-stroke-miter,\n.ql-snow.ql-toolbar button.ql-active .ql-stroke-miter,\n.ql-snow .ql-toolbar button.ql-active .ql-stroke-miter,\n.ql-snow.ql-toolbar .ql-picker-label:hover .ql-stroke-miter,\n.ql-snow .ql-toolbar .ql-picker-label:hover .ql-stroke-miter,\n.ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-stroke-miter,\n.ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-stroke-miter,\n.ql-snow.ql-toolbar .ql-picker-item:hover .ql-stroke-miter,\n.ql-snow .ql-toolbar .ql-picker-item:hover .ql-stroke-miter,\n.ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-stroke-miter,\n.ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-stroke-miter {\n  stroke: #06c;\n}\n@media (pointer: coarse) {\n  .ql-snow.ql-toolbar button:hover:not(.ql-active),\n  .ql-snow .ql-toolbar button:hover:not(.ql-active) {\n    color: #444;\n  }\n  .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-fill,\n  .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-fill,\n  .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-stroke.ql-fill,\n  .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-stroke.ql-fill {\n    fill: #444;\n  }\n  .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-stroke,\n  .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-stroke,\n  .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-stroke-miter,\n  .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-stroke-miter {\n    stroke: #444;\n  }\n}\n.ql-snow {\n  box-sizing: border-box;\n}\n.ql-snow * {\n  box-sizing: border-box;\n}\n.ql-snow .ql-hidden {\n  display: none;\n}\n.ql-snow .ql-out-bottom,\n.ql-snow .ql-out-top {\n  visibility: hidden;\n}\n.ql-snow .ql-tooltip {\n  position: absolute;\n  transform: translateY(10px);\n}\n.ql-snow .ql-tooltip a {\n  cursor: pointer;\n  text-decoration: none;\n}\n.ql-snow .ql-tooltip.ql-flip {\n  transform: translateY(-10px);\n}\n.ql-snow .ql-formats {\n  display: inline-block;\n  vertical-align: middle;\n}\n.ql-snow .ql-formats:after {\n  clear: both;\n  content: '';\n  display: table;\n}\n.ql-snow .ql-stroke {\n  fill: none;\n  stroke: #444;\n  stroke-linecap: round;\n  stroke-linejoin: round;\n  stroke-width: 2;\n}\n.ql-snow .ql-stroke-miter {\n  fill: none;\n  stroke: #444;\n  stroke-miterlimit: 10;\n  stroke-width: 2;\n}\n.ql-snow .ql-fill,\n.ql-snow .ql-stroke.ql-fill {\n  fill: #444;\n}\n.ql-snow .ql-empty {\n  fill: none;\n}\n.ql-snow .ql-even {\n  fill-rule: evenodd;\n}\n.ql-snow .ql-thin,\n.ql-snow .ql-stroke.ql-thin {\n  stroke-width: 1;\n}\n.ql-snow .ql-transparent {\n  opacity: 0.4;\n}\n.ql-snow .ql-direction svg:last-child {\n  display: none;\n}\n.ql-snow .ql-direction.ql-active svg:last-child {\n  display: inline;\n}\n.ql-snow .ql-direction.ql-active svg:first-child {\n  display: none;\n}\n.ql-snow .ql-editor h1 {\n  font-size: 2em;\n}\n.ql-snow .ql-editor h2 {\n  font-size: 1.5em;\n}\n.ql-snow .ql-editor h3 {\n  font-size: 1.17em;\n}\n.ql-snow .ql-editor h4 {\n  font-size: 1em;\n}\n.ql-snow .ql-editor h5 {\n  font-size: 0.83em;\n}\n.ql-snow .ql-editor h6 {\n  font-size: 0.67em;\n}\n.ql-snow .ql-editor a {\n  text-decoration: underline;\n}\n.ql-snow .ql-editor blockquote {\n  border-left: 4px solid #ccc;\n  margin-bottom: 5px;\n  margin-top: 5px;\n  padding-left: 16px;\n}\n.ql-snow .ql-editor code,\n.ql-snow .ql-editor pre {\n  background-color: #f0f0f0;\n  border-radius: 3px;\n}\n.ql-snow .ql-editor pre {\n  white-space: pre-wrap;\n  margin-bottom: 5px;\n  margin-top: 5px;\n  padding: 5px 10px;\n}\n.ql-snow .ql-editor code {\n  font-size: 85%;\n  padding: 2px 4px;\n}\n.ql-snow .ql-editor pre.ql-syntax {\n  background-color: #23241f;\n  color: #f8f8f2;\n  overflow: visible;\n}\n.ql-snow .ql-editor img {\n  max-width: 100%;\n}\n.ql-snow .ql-picker {\n  color: #444;\n  display: inline-block;\n  float: left;\n  font-size: 14px;\n  font-weight: 500;\n  height: 24px;\n  position: relative;\n  vertical-align: middle;\n}\n.ql-snow .ql-picker-label {\n  cursor: pointer;\n  display: inline-block;\n  height: 100%;\n  padding-left: 8px;\n  padding-right: 2px;\n  position: relative;\n  width: 100%;\n}\n.ql-snow .ql-picker-label::before {\n  display: inline-block;\n  line-height: 22px;\n}\n.ql-snow .ql-picker-options {\n  background-color: #fff;\n  display: none;\n  min-width: 100%;\n  padding: 4px 8px;\n  position: absolute;\n  white-space: nowrap;\n}\n.ql-snow .ql-picker-options .ql-picker-item {\n  cursor: pointer;\n  display: block;\n  padding-bottom: 5px;\n  padding-top: 5px;\n}\n.ql-snow .ql-picker.ql-expanded .ql-picker-label {\n  color: #ccc;\n  z-index: 2;\n}\n.ql-snow .ql-picker.ql-expanded .ql-picker-label .ql-fill {\n  fill: #ccc;\n}\n.ql-snow .ql-picker.ql-expanded .ql-picker-label .ql-stroke {\n  stroke: #ccc;\n}\n.ql-snow .ql-picker.ql-expanded .ql-picker-options {\n  display: block;\n  margin-top: -1px;\n  top: 100%;\n  z-index: 1;\n}\n.ql-snow .ql-color-picker,\n.ql-snow .ql-icon-picker {\n  width: 28px;\n}\n.ql-snow .ql-color-picker .ql-picker-label,\n.ql-snow .ql-icon-picker .ql-picker-label {\n  padding: 2px 4px;\n}\n.ql-snow .ql-color-picker .ql-picker-label svg,\n.ql-snow .ql-icon-picker .ql-picker-label svg {\n  right: 4px;\n}\n.ql-snow .ql-icon-picker .ql-picker-options {\n  padding: 4px 0px;\n}\n.ql-snow .ql-icon-picker .ql-picker-item {\n  height: 24px;\n  width: 24px;\n  padding: 2px 4px;\n}\n.ql-snow .ql-color-picker .ql-picker-options {\n  padding: 3px 5px;\n  width: 152px;\n}\n.ql-snow .ql-color-picker .ql-picker-item {\n  border: 1px solid transparent;\n  float: left;\n  height: 16px;\n  margin: 2px;\n  padding: 0px;\n  width: 16px;\n}\n.ql-snow .ql-picker:not(.ql-color-picker):not(.ql-icon-picker) svg {\n  position: absolute;\n  margin-top: -9px;\n  right: 0;\n  top: 50%;\n  width: 18px;\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label[data-label]:not([data-label=''])::before,\n.ql-snow .ql-picker.ql-font .ql-picker-label[data-label]:not([data-label=''])::before,\n.ql-snow .ql-picker.ql-size .ql-picker-label[data-label]:not([data-label=''])::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-label]:not([data-label=''])::before,\n.ql-snow .ql-picker.ql-font .ql-picker-item[data-label]:not([data-label=''])::before,\n.ql-snow .ql-picker.ql-size .ql-picker-item[data-label]:not([data-label=''])::before {\n  content: attr(data-label);\n}\n.ql-snow .ql-picker.ql-header {\n  width: 98px;\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item::before {\n  content: 'Normal';\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label[data-value=\"1\"]::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"1\"]::before {\n  content: 'Heading 1';\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label[data-value=\"2\"]::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"2\"]::before {\n  content: 'Heading 2';\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label[data-value=\"3\"]::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"3\"]::before {\n  content: 'Heading 3';\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label[data-value=\"4\"]::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"4\"]::before {\n  content: 'Heading 4';\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label[data-value=\"5\"]::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"5\"]::before {\n  content: 'Heading 5';\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label[data-value=\"6\"]::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"6\"]::before {\n  content: 'Heading 6';\n}\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"1\"]::before {\n  font-size: 2em;\n}\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"2\"]::before {\n  font-size: 1.5em;\n}\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"3\"]::before {\n  font-size: 1.17em;\n}\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"4\"]::before {\n  font-size: 1em;\n}\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"5\"]::before {\n  font-size: 0.83em;\n}\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"6\"]::before {\n  font-size: 0.67em;\n}\n.ql-snow .ql-picker.ql-font {\n  width: 108px;\n}\n.ql-snow .ql-picker.ql-font .ql-picker-label::before,\n.ql-snow .ql-picker.ql-font .ql-picker-item::before {\n  content: 'Sans Serif';\n}\n.ql-snow .ql-picker.ql-font .ql-picker-label[data-value=serif]::before,\n.ql-snow .ql-picker.ql-font .ql-picker-item[data-value=serif]::before {\n  content: 'Serif';\n}\n.ql-snow .ql-picker.ql-font .ql-picker-label[data-value=monospace]::before,\n.ql-snow .ql-picker.ql-font .ql-picker-item[data-value=monospace]::before {\n  content: 'Monospace';\n}\n.ql-snow .ql-picker.ql-font .ql-picker-item[data-value=serif]::before {\n  font-family: Georgia, Times New Roman, serif;\n}\n.ql-snow .ql-picker.ql-font .ql-picker-item[data-value=monospace]::before {\n  font-family: Monaco, Courier New, monospace;\n}\n.ql-snow .ql-picker.ql-size {\n  width: 98px;\n}\n.ql-snow .ql-picker.ql-size .ql-picker-label::before,\n.ql-snow .ql-picker.ql-size .ql-picker-item::before {\n  content: 'Normal';\n}\n.ql-snow .ql-picker.ql-size .ql-picker-label[data-value=small]::before,\n.ql-snow .ql-picker.ql-size .ql-picker-item[data-value=small]::before {\n  content: 'Small';\n}\n.ql-snow .ql-picker.ql-size .ql-picker-label[data-value=large]::before,\n.ql-snow .ql-picker.ql-size .ql-picker-item[data-value=large]::before {\n  content: 'Large';\n}\n.ql-snow .ql-picker.ql-size .ql-picker-label[data-value=huge]::before,\n.ql-snow .ql-picker.ql-size .ql-picker-item[data-value=huge]::before {\n  content: 'Huge';\n}\n.ql-snow .ql-picker.ql-size .ql-picker-item[data-value=small]::before {\n  font-size: 10px;\n}\n.ql-snow .ql-picker.ql-size .ql-picker-item[data-value=large]::before {\n  font-size: 18px;\n}\n.ql-snow .ql-picker.ql-size .ql-picker-item[data-value=huge]::before {\n  font-size: 32px;\n}\n.ql-snow .ql-color-picker.ql-background .ql-picker-item {\n  background-color: #fff;\n}\n.ql-snow .ql-color-picker.ql-color .ql-picker-item {\n  background-color: #000;\n}\n.ql-toolbar.ql-snow {\n  border: 1px solid #ccc;\n  box-sizing: border-box;\n  font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;\n  padding: 8px;\n}\n.ql-toolbar.ql-snow .ql-formats {\n  margin-right: 15px;\n}\n.ql-toolbar.ql-snow .ql-picker-label {\n  border: 1px solid transparent;\n}\n.ql-toolbar.ql-snow .ql-picker-options {\n  border: 1px solid transparent;\n  box-shadow: rgba(0,0,0,0.2) 0 2px 8px;\n}\n.ql-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-label {\n  border-color: #ccc;\n}\n.ql-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-options {\n  border-color: #ccc;\n}\n.ql-toolbar.ql-snow .ql-color-picker .ql-picker-item.ql-selected,\n.ql-toolbar.ql-snow .ql-color-picker .ql-picker-item:hover {\n  border-color: #000;\n}\n.ql-toolbar.ql-snow + .ql-container.ql-snow {\n  border-top: 0px;\n}\n.ql-snow .ql-tooltip {\n  background-color: #fff;\n  border: 1px solid #ccc;\n  box-shadow: 0px 0px 5px #ddd;\n  color: #444;\n  padding: 5px 12px;\n  white-space: nowrap;\n}\n.ql-snow .ql-tooltip::before {\n  content: \"Visit URL:\";\n  line-height: 26px;\n  margin-right: 8px;\n}\n.ql-snow .ql-tooltip input[type=text] {\n  display: none;\n  border: 1px solid #ccc;\n  font-size: 13px;\n  height: 26px;\n  margin: 0px;\n  padding: 3px 5px;\n  width: 170px;\n}\n.ql-snow .ql-tooltip a.ql-preview {\n  display: inline-block;\n  max-width: 200px;\n  overflow-x: hidden;\n  text-overflow: ellipsis;\n  vertical-align: top;\n}\n.ql-snow .ql-tooltip a.ql-action::after {\n  border-right: 1px solid #ccc;\n  content: 'Edit';\n  margin-left: 16px;\n  padding-right: 8px;\n}\n.ql-snow .ql-tooltip a.ql-remove::before {\n  content: 'Remove';\n  margin-left: 8px;\n}\n.ql-snow .ql-tooltip a {\n  line-height: 26px;\n}\n.ql-snow .ql-tooltip.ql-editing a.ql-preview,\n.ql-snow .ql-tooltip.ql-editing a.ql-remove {\n  display: none;\n}\n.ql-snow .ql-tooltip.ql-editing input[type=text] {\n  display: inline-block;\n}\n.ql-snow .ql-tooltip.ql-editing a.ql-action::after {\n  border-right: 0px;\n  content: 'Save';\n  padding-right: 0px;\n}\n.ql-snow .ql-tooltip[data-mode=link]::before {\n  content: \"Enter link:\";\n}\n.ql-snow .ql-tooltip[data-mode=formula]::before {\n  content: \"Enter formula:\";\n}\n.ql-snow .ql-tooltip[data-mode=video]::before {\n  content: \"Enter video:\";\n}\n.ql-snow a {\n  color: #06c;\n}\n.ql-container.ql-snow {\n  border: 1px solid #ccc;\n}\n.ql-mention-list-container {\r\n  width: 270px;\r\n  border: 1px solid #f0f0f0;\r\n  border-radius: 4px;\r\n  background-color: #ffffff;\r\n  box-shadow: 0 2px 12px 0 rgba(30, 30, 30, 0.08);\r\n  z-index: 9001;\r\n  overflow: auto;\r\n}\r\n\r\n.ql-mention-loading {\r\n  line-height: 44px;\r\n  padding: 0 20px;\r\n  vertical-align: middle;\r\n  font-size: 16px;\r\n}\r\n\r\n.ql-mention-list {\r\n  list-style: none;\r\n  margin: 0;\r\n  padding: 0;\r\n  overflow: hidden;\r\n}\r\n\r\n.ql-mention-list-item {\r\n  cursor: pointer;\r\n  line-height: 44px;\r\n  font-size: 16px;\r\n  padding: 0 20px;\r\n  vertical-align: middle;\r\n}\r\n\r\n.ql-mention-list-item.disabled {\r\n  cursor: auto;\r\n}\r\n\r\n.ql-mention-list-item.selected {\r\n  background-color: #d3e1eb;\r\n  text-decoration: none;\r\n}\r\n\r\n.mention {\r\n  height: 24px;\r\n  width: 65px;\r\n  border-radius: 6px;\r\n  background-color: #d3e1eb;\r\n  padding: 3px 0;\r\n  margin-right: 2px;\r\n  user-select: all;\r\n}\r\n\r\n.mention > span {\r\n  margin: 0 3px;\r\n}\r\n._actionControl_1xa5v_1 {\n  display: flex;\n  margin-right: 8px;\n  margin-left: 8px;\n  justify-content: flex-end;\n}\n\n._statusIcon_1xa5v_8 {\n  cursor: default;\n}\n\n._questionContainer_1xa5v_12 {\n  padding: 16px;\n}\n\n._actionIcon_1xa5v_16,\n._settingIcon_1xa5v_17 {\n  font-size: 22px;\n}\n\n._settingIcon_1xa5v_17 {\n  transform: rotate(90deg);\n}\n\n._deleteIcon_1xa5v_25 {\n  font-size: 32px;\n}\n._questionItem_wb37f_1 {\n  margin-bottom: 15px;\n  width: 50%;\n}\n\n._questionItem_wb37f_1:last-child {\n  margin-bottom: 0;\n}\n\n@media screen and (max-width: 768px) {\n  ._questionItem_wb37f_1 {\n    width: 100%;\n  }\n}\n._questionItem_1sx0f_1 {\n  margin-bottom: 15px;\n  width: 50%;\n}\n\n._questionItem_1sx0f_1:last-child {\n  margin-bottom: 0;\n}\n\n@media only screen and (max-width: 767px) {\n  ._questionItem_1sx0f_1 {\n    width: 100%;\n  }\n}\n._questionItem_169qj_1 {\n  margin-bottom: 15px;\n  width: 50%;\n}\n\n._questionItem_169qj_1:last-child {\n  margin-bottom: 0;\n}\n\n@media (max-width: 767px) {\n  ._questionItem_169qj_1 {\n    width: 100%;\n  }\n}\n._questionItem_13fbu_1 {\n  margin-bottom: 15px;\n}\n\n._questionItem_13fbu_1:last-child {\n  margin-bottom: 0;\n}\n\n@media (max-width: 767px) {\n  ._questionItem_13fbu_1 {\n    width: 100%;\n  }\n}\n\n._paragraph_13fbu_15 {\n  width: 100%;\n}\n\n._wordCount_13fbu_19 {\n  text-align: end;\n}\n._questionItem_1sx0f_1 {\n  margin-bottom: 15px;\n  width: 50%;\n}\n\n._questionItem_1sx0f_1:last-child {\n  margin-bottom: 0;\n}\n\n@media only screen and (max-width: 767px) {\n  ._questionItem_1sx0f_1 {\n    width: 100%;\n  }\n}\n._questionItem_1sx0f_1 {\n  margin-bottom: 15px;\n  width: 50%;\n}\n\n._questionItem_1sx0f_1:last-child {\n  margin-bottom: 0;\n}\n\n@media only screen and (max-width: 767px) {\n  ._questionItem_1sx0f_1 {\n    width: 100%;\n  }\n}\n._questionItem_wb37f_1 {\n  margin-bottom: 15px;\n  width: 50%;\n}\n\n._questionItem_wb37f_1:last-child {\n  margin-bottom: 0;\n}\n\n@media screen and (max-width: 768px) {\n  ._questionItem_wb37f_1 {\n    width: 100%;\n  }\n}\n._placeholder_4iqf5_1 {\n  width: 100%;\n  height: 100%;\n  display: inline-block;\n  vertical-align: middle;\n  text-align: center;\n}\n\n._buttonContainer_4iqf5_9 {\n  text-align: center;\n  margin-top: 24px;\n}\n._signatureCanvas_1uxb1_1 {\n  border: 1px solid transparent;\n  padding: 8px;\n  border-radius: 4px;\n  text-align: center;\n}\n._placeholder_xjf3c_1 {\n  width: 100%;\n  height: 100%;\n  display: inline-block;\n  vertical-align: middle;\n  text-align: center;\n}\n\n._buttonContainer_xjf3c_9 {\n  text-align: center;\n  margin-top: 24px;\n}\n\n._imageContainer_xjf3c_14 {\n  background-position: center;\n  background-repeat: no-repeat;\n}\n._choicesContainer_k0bnu_1 {\n  display: flex;\n  width: 100%;\n  table-layout: fixed;\n  margin-bottom: 16px;\n  justify-content: space-between;\n}\n\n._choicesContainer_k0bnu_1 ._choice_k0bnu_1 {\n  padding: 8px;\n  width: 100%;\n  margin: 1px;\n  font-weight: bold;\n  font-size: larger;\n  border: 1px solid;\n  text-align: center;\n}\n\n._choiceLabels_k0bnu_19 {\n  margin-top: 16px;\n  display: flex;\n  justify-content: space-between;\n}\n._container_cyg3h_1 {\n  text-align: center;\n}._container_cyg3h_1 {\n  text-align: center;\n}._container_cyg3h_1 {\n  text-align: center;\n}._answerAdd_5tmqk_1 {\n  display: flex;\n  align-items: baseline;\n  padding-left: 18px;\n  justify-content: flex-end;\n  gap: 0.5rem;\n}\n\n._questionItem_5tmqk_9 {\n  display: flex;\n  flex-direction: column;\n  gap: 2rem;\n}\n\n._choicesContainer_5tmqk_15 {\n  display: flex;\n  flex-direction: column;\n  gap: 0.5rem;\n}\n._answerItem_shykq_1 {\n  display: flex;\n  flex-flow: row wrap;\n  align-items: center;\n  /*margin-bottom: 15px;*/\n  transition: all 200ms;\n  height: auto;\n}\n\n._answerIcon_shykq_10 {\n  display: flex;\n}\n\n._answerItem_shykq_1 ._answerIcon_shykq_10:hover {\n  cursor: pointer;\n}\n\n._answerItem_shykq_1 ._answerIconOther_shykq_18 {\n  align-self: center;\n  margin-right: 10px;\n}\n\n._answerItem_shykq_1 ._answerIconOther_shykq_18:hover {\n  cursor: pointer;\n}\n\n._answerItem_shykq_1 ._answerNumberOrder_shykq_27 {\n  width: 30px;\n  text-align: center;\n}\n\n._answerItem_shykq_1 ._answerControl_shykq_32 {\n  margin-left: 7px;\n  width: calc(100% - 88px);\n}\n\n._answerItem_shykq_1 ._answerControlRtl_shykq_37 {\n  margin-right: 7px;\n  width: calc(100% - 88px);\n}\n\n._answerItem_shykq_1 ._answerControlOther_shykq_42 {\n  margin-left: 7px;\n  width: calc(100% - 140px);\n}\n\n._answerItem_shykq_1 ._answerControlOtherRtl_shykq_47 {\n  margin-right: 7px;\n  width: calc(100% - 140px);\n}\n\n._answerItem_shykq_1 ._answerOtherControl_shykq_52 {\n  margin-left: 43px;\n  width: 50%;\n}\n._addAnswerIcon_4rcog_1 {\n  scale: 2;\n}\n\n._questionItem_4rcog_5{\n  overflow: hidden;\n  padding-top: 16px;\n}\n\n._addAnswerButton_4rcog_10 {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  text-align: center;\n  vertical-align: middle;\n}\n._imageIconButton_chgwf_1 {\n  float: right;\n  border-radius: 0 !important;\n  padding: 4px !important;\n  margin: 4px !important;\n}\n\n._imageContainer_chgwf_8 {\n  background-size: cover;\n  background-position: center;\n  background-repeat: no-repeat;\n  position: relative;\n  width: 100%;\n}\n\n._addAnswerIcon_chgwf_16 {\n  scale: 2;\n}\n\n._loadingContainer_chgwf_20 {\n  top: 50%;\n  left: 50%;\n  position: absolute;\n}\n\n._addAnswerButton_chgwf_26 {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  text-align: center;\n  vertical-align: middle;\n}\n\n._buttonContainers_chgwf_34 {\n  width: 100%;\n  top: 0;\n  position: absolute;\n}._imageIconButton_lgrld_1 {\n  float: right;\n  border-radius: 0 !important;\n  padding: 4px !important;\n  margin: 4px !important;\n}\n\n._imageContainer_lgrld_8 {\n  text-align: center;\n}\n\n._addAnswerIcon_lgrld_12 {\n  scale: 2;\n}\n\n._loadingContainer_lgrld_16 {\n  text-align: center;\n  float: right;\n  width: 100%;\n  margin-top: 24px;\n}\n\n._addAnswerButton_lgrld_23 {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  text-align: center;\n  vertical-align: middle;\n}\n\n._svgContainer_lgrld_31>svg {\n  width: 100%;\n  height: 100%;\n}\n\n._buttonContainers_lgrld_36 {\n  width: 100%;\n  display: inline-block;\n}._resultImage_2y7qe_1 {\n  display: contents;\n\n  > svg {\n    margin: 8px;\n    width: 48px;\n    height: 48px;\n  }\n}._textHeader_17ofz_1 {\n  word-break: break-all;\n}\n\n._textDescription_17ofz_5 {\n  display: flex;\n  align-items: flex-start;\n  margin-top: 12px;\n}\n\n._groupCard_17ofz_11 {\n  position: relative;\n  box-shadow: inherit !important;\n  padding-bottom: 24px;\n  cursor: default;\n}\n\n._type_17ofz_18 {\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n  color: rgba(0, 0, 0, 0.33);\n}\n\n._groupType_17ofz_25 {\n  margin-top: 0;\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n  color: rgba(0, 0, 0, 0.33);\n}\n\n._questionsOuterContainer_17ofz_33 {\n  padding: 24px;\n}\n\n._questionsInnerContainer_17ofz_37 {\n  border-radius: 8px;\n  padding-right: 24px;\n  padding-left: 24px;\n}\n\n._groupDesignError_17ofz_43 {\n  border-color: red !important;\n  background-color: #ff000010 !important;\n}\n\n._groupHeader_17ofz_48 {\n  padding: 1.75rem 1rem 1rem 1rem;\n}\n\n._inputGroupTitle_17ofz_52 {\n  width: 100%;\n  line-height: 135%;\n}\n\n._inputGroupDescription_17ofz_57 {\n  width: 100%;\n  margin-top: 4px;\n}\n\n._moveBox_17ofz_62 {\n  display: flex;\n  margin-top: 8px;\n  margin: auto;\n  justify-content: center;\n  width: 50%;\n  cursor: move;\n}\n\n._topLevel_17ofz_71 {\n  display: flex;\n  flex-direction: column;\n  max-width: 800px;;\n  max-width: min(800px, calc(100% - 32px));\n  min-width: 320px;\n  gap: 1rem;\n  padding: .5rem 0.5rem 2rem .5rem;\n  margin: auto;\n  position: relative;\n}\n\n._groupText_17ofz_83 {\n  /* position: absolute; */\n  font-size: 20px;\n  font-weight: bold;\n}\n\n@keyframes _fadeInMoveRight_17ofz_1 {\n  0% {\n    opacity: 0;\n    transform: translateX(10px);\n  }\n\n  100% {\n    opacity: 1;\n    transform: translateX(0);\n  }\n}\n\n._actionToolbarVisible_17ofz_101 {\n  animation: _fadeInMoveRight_17ofz_1 0.75s ease-out forwards;\n}\n\n._contentContainer_17ofz_105._contentContainer_17ofz_105 {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  width: 100%;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  justify-content: end;\n}\n\n._headerContent_17ofz_116 {\n  position: relative;\n}._groupDropArea_1m6hh_1 {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  box-sizing: border-box;\n  height: 6rem;\n  padding: 0;\n  max-width: 800px;\n  min-width: 350px;\n  width: 100%;\n  color: rgba(0, 0, 0, 0.5);\n  margin: auto;\n  color: rgba(0, 0, 0, 0.5);\n  background-color: #f9f9f9;\n  border: 1px dotted #16205b;\n  border-radius: 2px;\n  opacity: 1;\n  transition: padding 200ms, background-color 200ms, height 200ms ease-in-out,\n    opacity 200ms;\n  margin-top: 20px;\n  margin-bottom: 35px;\n}\n\n._groupDragging_1m6hh_24 {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  box-sizing: border-box;\n  height: 50px;\n  padding: 0;\n  max-width: 800px;\n  min-width: 350px;\n  width: 100%;\n  margin: auto;\n  color: rgba(0, 0, 0, 0.5);\n  background-color: #f9f9f9;\n  border: 1px dotted #16205b;\n  border-radius: 2px;\n  opacity: 1;\n  transition: padding 200ms, background-color 200ms, opacity 200ms;\n  margin-top: 20px;\n  margin-bottom: 35px;\n}\n\n._questionDropArea_1m6hh_45 {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  box-sizing: border-box;\n  height: 6rem;\n  max-width: 800px;\n  min-width: 350px;\n  padding: 0;\n  width: 100%;\n  margin: auto;\n  font-size: 2rem;\n  color: rgba(0, 0, 0, 0.5);\n  background-color: rgba(0, 0, 0, 0.1);\n  border: 1px dotted #16205b;\n  border-radius: 2px;\n  opacity: 1;\n  transition: height 200ms, padding 200ms, background-color 200ms, opacity 200ms;\n}\n\n/* .groupDropArea {\n  margin: auto;\n  width: 100%;\n  max-width: 800px;\n  min-width: 350px;\n} */\n\n._groupDropAreaWrapper_1m6hh_72 {\n  padding: 1rem 0;\n  max-width: 800px;\n  width: 100%;\n  min-width: 350px;\n}\n\n._groupDropAreaWrapper_1m6hh_72._hide_1m6hh_79 {\n  padding: 0;\n}\n\n._hidden_1m6hh_83 {\n  height: 1px;\n  margin: auto;\n  max-width: 800px;\n  width: 100%;\n  min-width: 350px;\n  transition: height 200ms, padding 200ms;\n}\n\n._isDragging_1m6hh_92 {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border: 1px dotted #16205b;\n  height: 50px;\n  margin: 0;\n  background-color: #f9f9f9;\n  opacity: 1;\n  transition: height 200ms, padding 200ms, background-color 200ms, opacity 200ms;\n}\n\n._groupHidden_1m6hh_104 {\n  height: 6rem;\n  margin: auto;\n  max-width: 800px;\n  min-width: 350px;\n}\n\n._groupEmptyHint_1m6hh_111 {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  text-align: center;\n  margin-top: 20px;\n  margin-bottom: 35px;\n  height: 50px;\n  margin: auto;\n  max-width: 800px;\n  width: 100%;\n  min-width: 350px;\n  color: gray;\n  border: 1px dotted #16205b;\n  border-radius: 2px;\n  background-color: rgba(0, 0, 0, 0);\n  transition: background-color 200ms;\n}\n\n._groupEmptyHintHover_1m6hh_130 {\n  background-color: rgba(0, 0, 0, 0.1);\n}\n\n._dropText_1m6hh_134 {\n  font-size: 20px;\n}\n._showHint_9iocv_1 {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  margin-top: 20px;\n  width: 100%;\n}\n\n._inputValue_9iocv_9 {\n  max-width: 80%;\n}\n._boxContainer_182us_1 {\n  border: 1px solid;\n  padding: 15px;\n}\n\n._boxContainer_182us_1 h4 {\n  margin: 0;\n}\n\n._boxContainer_182us_1 ._mt10_182us_10 {\n  margin-top: 10px;\n}\n\n._boxContainer_182us_1 ._uppercase_182us_14 {\n  text-transform: uppercase;\n}\n\n._title_182us_18 {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  width: 100%;\n}\n\n._title_182us_18 p {\n  margin: 0;\n  margin-right: 30px;\n}\n._boxContainer_1vhs4_1 {\n  border: 1px solid;\n  padding: 15px;\n\n  h4 {\n    margin: 0;\n  }\n\n  ._mt10_1vhs4_9 {\n    margin-top: 10px;\n  }\n\n  ._uppercase_1vhs4_13 {\n    text-transform: uppercase;\n  }\n}\n\n._title_1vhs4_18 {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  p {\n    margin: 0;\n    margin-right: 30px;\n  }\n}\n\n._titleContent_1vhs4_28 {\n  display: flex;\n  align-items: center;\n}\n\n._standardError_1vhs4_33 {\n  display: flex;\n  align-items: center;\n  margin-bottom: 10px;\n\n  p {\n    margin: 0;\n    margin-right: 30px;\n  }\n}\n\n._errorWrapper_1vhs4_44 {\n  display: flex;\n}\n\n._errorLabelWrapper_1vhs4_48 {\n  margin-right: 10px;\n}\n\n._errorItem_1vhs4_52 {\n  display: flex;\n  align-items: center;\n  margin-bottom: 5px;\n  min-height: 30px;\n}\n._errorItemContainer_1vhs4_58 {\n  width: 100%;\n}\n._valueValidationItems_1hupk_1 {\n  display: flex;\n  align-items: center;\n}\n\n._valueValidationItemsContainer_1hupk_6 {\n  display: flex;\n  align-items: center;\n}\n\n._valueValidationItemsContainer_1hupk_6 ._error_1hupk_11 {\n  color: red;\n}\n._toggleValue_1d9zg_1 {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  width: 100%;\n}\n\n._inputValue_1d9zg_8 {\n  max-width: 80%;\n}\n._selectValue_9m4tq_1 {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  width: 100%;\n}\n._selectDate_1qp3e_1 {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  width: 100%;\n}\n\n._selectDateField_1qp3e_8 {\n  max-width: 50%;\n}\n.query-builder .qb-drag-handler, .query-builder .qb-draggable, .query-builder {\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.query-builder .rule--header:after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.query-builder {\n  overflow: hidden;\n  font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.25;\n  margin: 1rem;\n}\n\n.query-builder {\n  /******************************************************************************/\n  /** DRAG *********************************************************************/\n  /******************************************************************************/\n  /******************************************************************************/\n  /** TREE LINES *********************************************************************/\n  /******************************************************************************/\n  /******************************************************************************/\n  /** GROUP *********************************************************************/\n  /******************************************************************************/\n  /******************************************************************************/\n  /** CASE_GROUP *********************************************************************/\n  /******************************************************************************/\n  /******************************************************************************/\n  /** RULE_GROUP *********************************************************************/\n  /******************************************************************************/\n  /******************************************************************************/\n  /** RULE_GROUP_EXT *********************************************************************/\n  /******************************************************************************/\n  /******************************************************************************/\n  /** RULE **********************************************************************/\n  /******************************************************************************/\n  /******************************************************************************/\n  /** FUNC **********************************************************************/\n  /******************************************************************************/\n  /******************************************************************************/\n  /** Shrink textarea ***********************************************************/\n  /******************************************************************************/\n}\n.query-builder .group {\n  background: rgba(250, 240, 210, 0.5);\n  border: 1px solid #DCC896;\n}\n.query-builder .rule {\n  background-color: white;\n  border: 1px solid transparent;\n  padding: 10px;\n}\n.query-builder .rule-with-error .rule {\n  border-color: #e0a1a1;\n}\n.query-builder .group-with-error > .group {\n  border-color: #e0a1a1;\n}\n.query-builder .rule--body {\n  display: flex;\n  flex-wrap: wrap;\n  text-align: center;\n}\n.query-builder .rule--body--wrapper {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n}\n.query-builder .rule--error {\n  color: red;\n  margin-bottom: -5px;\n  margin-top: 5px;\n}\n.query-builder .rule_group--error {\n  color: red;\n  margin-bottom: -5px;\n  margin-top: 5px;\n  width: 100%;\n}\n.query-builder .group-or-rule {\n  border-radius: 5px;\n  position: relative;\n}\n.query-builder .rule_group {\n  background: rgba(255, 252, 242, 0.5);\n  border: 1px solid #f9f1dd;\n}\n.query-builder .rule_group_ext {\n  background: rgba(255, 252, 242, 0.5);\n  border: 1px solid #f9f1dd;\n}\n.query-builder .locked {\n  border: 1px dashed red;\n}\n.query-builder .qb-placeholder {\n  border: 1px dashed gray;\n}\n.query-builder.qb-dragging {\n  cursor: -webkit-grabbing !important;\n  cursor: grabbing !important;\n}\n.query-builder.qb-dragging button {\n  pointer-events: none;\n}\n.query-builder .qb-draggable {\n  pointer-events: none;\n  position: absolute;\n  opacity: 0.7;\n  z-index: 1000;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n}\n.query-builder .qb-drag-handler {\n  cursor: -webkit-grabbing;\n  cursor: grabbing;\n}\n.query-builder .group--header:not(.no--children):not(.hide--conjs) {\n  position: relative;\n}\n.query-builder .group--header:not(.no--children):not(.hide--conjs)::before {\n  z-index: 0;\n  content: \"\";\n  position: absolute;\n  border-width: 0 0 0 2px;\n  border-color: #ccc;\n  border-style: solid;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n}\n.query-builder .group--header:not(.no--children):not(.hide--conjs).hide--line::before {\n  border-color: rgba(128, 128, 128, 0.1);\n}\n.query-builder .group--header:not(.no--children):not(.hide--conjs)::before {\n  top: 20px;\n  height: calc(100% + 10px - 20px);\n  left: 11px;\n  width: 13px;\n}\n.query-builder .group--children > .group-or-rule-container > .group-or-rule::before {\n  border-width: 0 0 2px 2px;\n}\n.query-builder .group--children > .group-or-rule-container > .group-or-rule::after {\n  border-width: 0 0 0 2px;\n}\n.query-builder .group--children > .group-or-rule-container > .group-or-rule::before, .query-builder .group--children > .group-or-rule-container > .group-or-rule::after {\n  content: \"\";\n  position: absolute;\n  border-color: #ccc;\n  border-style: solid;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n}\n.query-builder .group--children > .group-or-rule-container > .group-or-rule::before {\n  top: -1px;\n  height: calc(50% + 1px + 1px);\n}\n.query-builder .group--children > .group-or-rule-container > .group-or-rule::after {\n  top: calc(50% + 1px);\n  height: calc(50% - 1px + 10px + 2px);\n}\n.query-builder .group--children > .group-or-rule-container > .group-or-rule::before, .query-builder .group--children > .group-or-rule-container > .group-or-rule::after {\n  left: -14px;\n  width: 13px;\n}\n.query-builder .group--children > .group-or-rule-container:last-child > .group-or-rule::before {\n  border-radius: 0 0 0 4px;\n}\n.query-builder .group--children > .group-or-rule-container:last-child > .group-or-rule::after {\n  display: none;\n}\n.query-builder .group--children.hide--conjs > .group-or-rule-container:first-child > .group-or-rule::before {\n  display: none;\n}\n.query-builder .group--children.hide--conjs > .group-or-rule-container:first-child > .group-or-rule::after {\n  border-radius: 4px 0 0 0;\n  border-width: 2px 0 0 2px;\n}\n.query-builder .group--children.hide--conjs > .group-or-rule-container:first-child > .group-or-rule::after {\n  top: calc(50% - 1px);\n  height: calc(50% + 1px + 10px + 2px);\n}\n.query-builder .group--children.hide--line > .group-or-rule-container > .group-or-rule::before, .query-builder .group--children.hide--line > .group-or-rule-container > .group-or-rule::after {\n  border-color: rgba(128, 128, 128, 0.1);\n}\n.query-builder .rule_group--children > .group-or-rule-container:first-child > .group-or-rule::before {\n  display: none;\n}\n.query-builder .rule_group--children > .group-or-rule-container:first-child > .group-or-rule::after {\n  border-radius: 4px 0 0 0;\n  border-width: 2px 0 0 2px;\n}\n.query-builder .rule_group--children > .group-or-rule-container:first-child > .group-or-rule::after {\n  top: calc(50% - 1px);\n  height: calc(50% + 1px + 5px + 2px);\n}\n.query-builder .rule_group--children > .group-or-rule-container > .group-or-rule::before {\n  top: -1px;\n  height: calc(50% + 1px + 1px);\n}\n.query-builder .rule_group--children > .group-or-rule-container > .group-or-rule::after {\n  top: calc(50% + 1px);\n  height: calc(50% - 1px + 5px + 2px);\n}\n.query-builder .rule_group--children > .group-or-rule-container > .group-or-rule::before, .query-builder .rule_group--children > .group-or-rule-container > .group-or-rule::after {\n  left: -11px;\n  width: 10px;\n}\n.query-builder .switch_group > .group--children > .group-or-rule-container > .group-or-rule::before {\n  top: -2px;\n  height: calc(50% + 1px + 2px);\n}\n.query-builder .switch_group > .group--children > .group-or-rule-container > .group-or-rule::after {\n  top: calc(50% + 1px);\n  height: calc(50% - 1px + 10px + 4px);\n}\n.query-builder .switch_group > .group--children > .group-or-rule-container > .group-or-rule::before, .query-builder .switch_group > .group--children > .group-or-rule-container > .group-or-rule::after {\n  left: -15px;\n  width: 13px;\n}\n.query-builder .switch_group > .group--header:not(.no--children):not(.hide--conjs)::before {\n  top: 20px;\n  height: calc(100% + 10px - 20px);\n  left: 11px;\n  width: 13px;\n}\n.query-builder .qb-draggable::before, .query-builder .qb-draggable::after {\n  display: none;\n}\n.query-builder .group--header,\n.query-builder .group--footer {\n  display: flex;\n  align-items: stretch;\n  padding-left: 10px;\n  padding-right: 10px;\n  margin-top: 10px;\n  margin-bottom: 10px;\n}\n.query-builder .group-or-rule-container {\n  margin-top: 10px;\n  margin-bottom: 10px;\n  padding-right: 10px;\n}\n.query-builder .group-or-rule-container:first-child {\n  margin-top: 0px !important;\n}\n.query-builder .group-or-rule-container:last-child {\n  margin-bottom: 0px !important;\n}\n.query-builder .group--drag-handler {\n  margin-right: 8px;\n  margin-top: 3px;\n  position: relative;\n  align-self: center;\n}\n.query-builder .group--conjunctions {\n  flex-shrink: 0;\n  display: flex;\n}\n.query-builder .group--conjunctions .group--drag-handler {\n  margin-left: 10px;\n}\n.query-builder .group--children {\n  padding-left: 24px;\n  margin-top: 10px;\n  margin-bottom: 10px;\n}\n.query-builder .group--children .group--field--count--rule {\n  display: flex;\n  flex-wrap: wrap;\n  flex: 1;\n}\n.query-builder .group--conjunctions.hide--conj {\n  opacity: 0.3;\n}\n.query-builder .group--actions {\n  align-self: center;\n  margin-left: 10px;\n  flex: 1;\n  display: flex;\n}\n.query-builder .group--actions--tl, .query-builder .group--actions--bl {\n  justify-content: flex-start;\n}\n.query-builder .group--actions--tl {\n  margin-left: 20px;\n}\n.query-builder .group--actions--tc, .query-builder .group--actions--bc {\n  justify-content: center;\n}\n.query-builder .group--actions--tr, .query-builder .group--actions--br {\n  justify-content: flex-end;\n}\n.query-builder .case_group {\n  border-width: 2px;\n}\n.query-builder .case_group .case_group--body {\n  display: flex;\n  flex-direction: row;\n  margin-top: 10px;\n  margin-bottom: 10px;\n}\n.query-builder .case_group .case_group--body .case_group--children {\n  flex: auto;\n  margin-top: 0 !important;\n  margin-bottom: 0 !important;\n}\n.query-builder .case_group .case_group--value {\n  margin-top: 0;\n  margin-bottom: 0;\n  margin-left: 10px;\n  margin-right: 10px;\n}\n.query-builder .rule_group {\n  display: flex;\n  flex-wrap: wrap;\n  padding-left: 10px;\n}\n.query-builder .rule_group .group--field {\n  margin-top: 10px;\n  margin-bottom: 10px;\n  align-self: center;\n}\n.query-builder .rule_group .group--actions {\n  margin-left: 10px;\n  align-self: center;\n  flex: 0;\n}\n.query-builder .rule_group .rule_group--children {\n  flex: 1;\n  margin-top: 5px;\n  margin-bottom: 5px;\n  padding-left: 18px;\n}\n.query-builder .rule_group .rule_group--children .group-or-rule-container {\n  margin-bottom: 5px;\n  margin-top: 5px;\n  padding-right: 5px;\n}\n.query-builder .rule_group .rule_group--children.one--child {\n  padding-left: 9px;\n}\n.query-builder .rule_group_ext .group--actions {\n  flex: none;\n}\n.query-builder .group--header.hide--drag.with--conjs > .group--field--count--rule {\n  margin-left: 20px;\n}\n.query-builder .rule {\n  flex: 1;\n  display: flex;\n}\n.query-builder .rule--header {\n  margin-left: auto;\n  display: flex;\n  align-items: center;\n  padding-left: 10px;\n}\n.query-builder .rule--drag-handler {\n  display: flex;\n  align-items: center;\n  margin-right: 8px;\n}\n.query-builder .rule--field, .query-builder .rule--fieldsrc, .query-builder .group--field, .query-builder .rule--operator, .query-builder .rule--value, .query-builder .rule--operator-options, .query-builder .rule--widget, .query-builder .widget--widget, .query-builder .widget--valuesrc, .query-builder .widget--sep, .query-builder .operator--options--sep, .query-builder .rule--before-widget, .query-builder .rule--after-widget {\n  display: inline-block;\n}\n.query-builder .widget--sep, .query-builder .operator--options--sep, .query-builder .rule--func--bracket-before, .query-builder .rule--func--bracket-after, .query-builder .rule--func--arg-sep {\n  vertical-align: bottom;\n  align-self: flex-end;\n  margin-bottom: 8px;\n}\n.query-builder .rule--func--arg-sep {\n  margin-bottom: 3px;\n}\n.query-builder .widget--sep {\n  margin-left: 10px;\n  margin-right: 10px;\n}\n.query-builder .widget--sep.widget--sep-first {\n  margin-right: 10px;\n  margin-left: 0;\n}\n.query-builder .rule--operator {\n  margin-left: 20px;\n  margin-right: 20px;\n}\n.query-builder .operator--options--sep {\n  margin-right: 10px;\n}\n.query-builder .rule--func--arg-sep {\n  margin-left: 3px;\n  margin-right: 6px;\n}\n.query-builder .rule--func--bracket-after {\n  margin-left: 5px;\n  margin-right: 2px;\n}\n.query-builder .rule--func--bracket-before {\n  margin-left: 5px;\n  margin-right: 5px;\n}\n.query-builder .widget--valuesrc {\n  vertical-align: top;\n}\n.query-builder .rule--fieldsrc {\n  vertical-align: top;\n}\n.query-builder .operator--options {\n  display: flex;\n}\n.query-builder .rule--operator-wrapper {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n}\n.query-builder .rule--operator-text-wrapper {\n  flex: 1;\n  display: flex;\n  align-items: center;\n}\n.query-builder div.tooltip-inner {\n  max-width: 500px;\n}\n.query-builder .rule--label {\n  display: block;\n  font-weight: bold;\n}\n.query-builder .rule--func--wrapper, .query-builder .rule--func, .query-builder .rule--func--args, .query-builder .rule--func--arg, .query-builder .rule--func--arg-value, .query-builder .rule--func--bracket-before, .query-builder .rule--func--bracket-after, .query-builder .rule--func--arg-sep, .query-builder .rule--func--arg-label, .query-builder .rule--func--arg-label-sep {\n  display: inline-block;\n}\n.query-builder .rule--func--wrapper {\n  display: flex;\n  flex-wrap: wrap;\n}\n.query-builder .rule--func--args {\n  display: flex;\n  flex-wrap: wrap;\n}\n.query-builder .rule--func--arg {\n  display: flex;\n}\n.query-builder .rule--field-wrapper,\n.query-builder .rule--field--func,\n.query-builder .rule--func--wrapper,\n.query-builder .rule--func--args,\n.query-builder .rule--func--arg,\n.query-builder .rule--func--arg-value,\n.query-builder .rule--func--arg-value > .rule--widget,\n.query-builder .widget--func {\n  display: contents;\n}\n.query-builder .rule--func, .query-builder .widget--widget {\n  margin-bottom: 2px;\n}\n.query-builder .rule--body--wrapper {\n  margin-bottom: -2px;\n}\n.query-builder .rule--body.can--shrink--value .rule--value {\n  flex: 1;\n}\n.query-builder .rule--body.can--shrink--value .rule--value > .rule--widget {\n  width: 100%;\n  display: flex;\n}\n.query-builder .rule--body.can--shrink--value .rule--value > .rule--widget .widget--widget {\n  flex: 1;\n}\n\n/******************************************************************************/\n/** Minimalism ****************************************************************/\n/******************************************************************************/\n.query-builder.qb-lite .group--drag-handler, .query-builder.qb-lite .group--actions {\n  transition: opacity 0.2s;\n}\n.query-builder.qb-lite .group--header:hover .group--header .group--drag-handler, .query-builder.qb-lite .group--header:hover .group--header .group--actions,\n.query-builder.qb-lite .group--header:not(:hover) .group--drag-handler,\n.query-builder.qb-lite .group--header:not(:hover) .group--actions,\n.query-builder.qb-lite .rule_group:not(:hover) .group--drag-handler,\n.query-builder.qb-lite .rule_group:not(:hover) .group--actions {\n  opacity: 0;\n}\n.query-builder.qb-lite .rule--fieldsrc, .query-builder.qb-lite .widget--valuesrc, .query-builder.qb-lite .rule--drag-handler, .query-builder.qb-lite .rule--header {\n  transition: opacity 0.2s;\n}\n.query-builder.qb-lite .rule:hover .rule .rule--fieldsrc, .query-builder.qb-lite .rule:hover .rule .widget--valuesrc, .query-builder.qb-lite .rule:hover .rule .rule--drag-handler, .query-builder.qb-lite .rule:hover .rule .rule--header,\n.query-builder.qb-lite .rule:not(:hover) .rule--fieldsrc,\n.query-builder.qb-lite .rule:not(:hover) .widget--valuesrc,\n.query-builder.qb-lite .rule:not(:hover) .rule--drag-handler,\n.query-builder.qb-lite .rule:not(:hover) .rule--header {\n  opacity: 0;\n}\n.query-builder.qb-lite.qb-dragging .rule--fieldsrc, .query-builder.qb-lite.qb-dragging .widget--valuesrc, .query-builder.qb-lite.qb-dragging .rule--drag-handler, .query-builder.qb-lite.qb-dragging .rule--header, .query-builder.qb-lite.qb-dragging .group--drag-handler, .query-builder.qb-lite.qb-dragging .group--actions {\n  opacity: 0 !important;\n}\n\n.query-builder .MuiIconButton-sizeSmall {\n  padding: 3px;\n}\n\n/* should be outside of .query-builder */\n.customSelectOption {\n  color: lightcoral;\n}\n.group--children.hide--line>.group-or-rule-container>.group-or-rule::before,\n.group--children.hide--line>.group-or-rule-container>.group-or-rule::after {\n  border-color: transparent;\n}\n\n.MuiAutocomplete-fullWidth {\n  width: 320px !important;\n}\n\n.query-builder-container {\n  padding: 0 !important;\n}\n\n.query-builder {\n  margin: 0 !important;\n}\n\n.query-builder .group {\n  background-color: transparent;\n  border: 0px solid #000;\n}\n\n.query-builder .rule--header button {\n  color: #6E6E6E;\n}\n\n.logicField {\n  color: blue;\n}\n\n.logicOp {\n  font-weight: bold;\n}\n\n.logicValue {\n  color: green;\n}\n\n.condition-human-text {\n  width: 100%;\n  white-space: pre-wrap;\n}\n\n.query-builder-result {\n  margin-top: 9px;\n  display: flex;\n}\n\n\n.icon-container {\n  display: flex;\n  align-items: center;\n}._relevance_1j5a5_1 {\n  display: inline-block;\n}\n\n._relevanceError_1j5a5_5 {\n  background-color: #ff000022;\n}\n\n._errorContainer_1j5a5_9 {\n  display: flex;\n}\n._skipItem_1n8m2_1 {\n  margin-top: 24px;\n  margin-bottom: 24px;\n}\n\n._toEnd_1n8m2_6 {\n  display: flex;\n  justify-content: space-between;\n  width: 100%;\n  align-items: center;\n  padding: 4dp;\n}\n._sectionTitle_nmfqz_1 {\n  font-size: 16px;\n  font-weight: bold;\n}\n\n._rightContent_nmfqz_6 {\n  width: 100%;\n  overflow-y: auto;\n  background-color: white;\n  height: calc(100vh - 64px);\n}\n\n._close_nmfqz_13 {\n  text-align: right;\n}\n\n._accordionStyle_nmfqz_17._accordionStyle_nmfqz_17 {\n  box-shadow: none;\n  border-bottom: 1px solid #d7d7d7;\n}\n._errorDisplay_1avr2_1 {\n  margin-bottom: 15px;\n  border: 1px solid orange;\n  background-color: rgba(255, 166, 0, 0.13);\n  border-radius: 4px;\n  margin: 8px;\n  padding: 8px;\n}\n._randomHeader_1pjix_1 {\n  display: flex;\n  justify-content: space-between;\n}\n\n._randomHeader_1pjix_1 ._title_1pjix_6 {\n  margin: 0;\n  line-height: 40px;\n}\n\n._randomHeader_1pjix_1 ._action_1pjix_11 {\n  float: right;\n}\n\n._randomHeader_1pjix_1 ._settingIcon_1pjix_15 {\n  font-size: 20px;\n}\n\n._randomBody_1pjix_19 ._list_1pjix_19 {\n  padding-left: 7px;\n  margin-top: 4px;\n  list-style-type: \"-\";\n}\n\n._randomBody_1pjix_19 ._list_1pjix_19 li {\n  line-height: 24px;\n  margin-bottom: 6px;\n}\n\n._randomBody_1pjix_19 ._list_1pjix_19 li ._weight_1pjix_30 {\n  float: right;\n  padding-top: 2px;\n  min-width: 100px;\n  text-align: right;\n}\n\n._randomBody_1pjix_19 ._list_1pjix_19 li ._weight_1pjix_30 > span {\n  display: inline-block;\n  padding: 0 4px;\n  line-height: 22px;\n  background-color: white;\n  border: 1px solid black;\n  min-width: 20px;\n  text-align: center;\n}\n\n._randomAction_1pjix_47 {\n  margin-top: 15px;\n  text-align: right;\n  padding-right: 4px;\n}\n\n._listItem_1pjix_53 {\n  display: flex;\n  align-items: center;\n}\n\n._listItem_1pjix_53 ._label_1pjix_58 {\n  display: flex;\n  align-items: center;\n  width: 100%;\n}\n\n._listItem_1pjix_53 ._input_1pjix_64 {\n  width: 50px;\n}\n\n._listItemError_1pjix_68 {\n  color: red;\n  display: flex;\n  align-items: center;\n}\n\n._listItemError_1pjix_68 ._label_1pjix_58 {\n  display: flex;\n  align-items: center;\n  width: 100%;\n}\n\n._listItemError_1pjix_68 ._input_1pjix_64 {\n  width: 50px;\n}\n\n._randomItem_1pjix_84 {\n  margin-bottom: 10px;\n  padding: 8px;\n}\n\n._highlighted_1pjix_89 {\n  border: 2px solid;\n  border-radius: 4px;\n}\n._title_5cg20_1 {\n  margin: 0;\n  line-height: 40px;\n}\n\n._randomBody_5cg20_6 ._list_5cg20_6 {\n  padding-left: 0;\n  margin: 0 0 10px;\n  list-style-type: \"-\";\n}\n\n._randomBody_5cg20_6 ._list_5cg20_6 li {\n  padding-left: 0;\n  line-height: 24px;\n  margin-bottom: 6px;\n}\n\n._randomBody_5cg20_6 ._list_5cg20_6 li ._weight_5cg20_18 {\n  float: right;\n  padding-top: 2px;\n  min-width: 100px;\n  text-align: right;\n}\n\n._randomBody_5cg20_6 ._list_5cg20_6 li ._weight_5cg20_18 > span {\n  display: inline-block;\n  padding: 0 4px;\n  line-height: 22px;\n  background-color: white;\n  border: 1px solid black;\n  min-width: 20px;\n  text-align: center;\n}\n\n._label_5cg20_35 {\n  width: 100%;\n}\n\n._randomAction_5cg20_39 {\n  margin-top: 15px;\n  text-align: right;\n  padding-right: 4px;\n}\n\n._listItem_5cg20_45 {\n  display: flex;\n  align-items: center;\n}\n\n._listItem_5cg20_45 ._input_5cg20_50 {\n  width: 50px;\n}\n\n._randomItem_5cg20_54 {\n  margin-top: 10px;\n  margin-bottom: 10px;\n  padding: 8px;\n}\n._selectValue_14l81_1 {\n  margin-bottom: 20px !important;\n}\n._errorDisplay_1vtlj_1 {\n  margin-bottom: 15px;\n  border: 1px solid orange;\n  background-color: rgba(255, 166, 0, 0.13);\n  border-radius: 4px;\n  margin: 8px;\n  padding: 8px;\n}\n\n._addNew_1vtlj_10 {\n  margin-top: 8px;\n}\n._title_1p7e9_1 {\n  margin: 0;\n  line-height: 40px;\n}\n\n._list_1p7e9_6 {\n  padding-left: 7px;\n  margin: 0 0 10px;\n  list-style-type: none;\n}\n\n._list_1p7e9_6 li {\n  line-height: 24px;\n  margin-bottom: 6px;\n  padding-left: 0;\n  margin-left: -12px;\n}\n\n._randomAction_1p7e9_19 {\n  margin-top: 15px;\n  text-align: right;\n  padding-right: 4px;\n}\n\n._listItem_1p7e9_25 {\n  display: flex;\n  align-items: center;\n}\n\n._listItem_1p7e9_25 ._input_1p7e9_30 {\n  width: 50px;\n}\n\n._randomItem_1p7e9_34 {\n  margin-top: 10px;\n  margin-bottom: 10px;\n  padding: 8px;\n}\n._randomHeader_10d2m_1 {\n  display: flex;\n  justify-content: space-between;\n}\n\n._randomHeader_10d2m_1 ._title_10d2m_6 {\n  margin: 0;\n  line-height: 40px;\n}\n\n._randomHeader_10d2m_1 ._action_10d2m_11 {\n  float: right;\n}\n\n._randomHeader_10d2m_1 ._settingIcon_10d2m_15 {\n  font-size: 20px;\n}\n\n._list_10d2m_19 {\n  padding-left: 7px;\n  margin: 0 0 10px;\n  list-style-type: \"-\";\n}\n\n._list_10d2m_19 li {\n  line-height: 24px;\n  margin-bottom: 6px;\n}\n\n._randomAction_10d2m_30 {\n  margin-top: 15px;\n  text-align: right;\n  padding-right: 4px;\n}\n\n._listItem_10d2m_36 {\n  display: flex;\n  align-items: center;\n}\n\n._listItem_10d2m_36 ._label_10d2m_41 {\n  display: flex;\n  align-items: center;\n  width: 100%;\n}\n\n._listItem_10d2m_36 ._input_10d2m_47 {\n  width: 50px;\n}\n\n._listItemError_10d2m_51 {\n  color: red;\n  display: flex;\n  align-items: center;\n}\n\n._listItemError_10d2m_51 ._label_10d2m_41 {\n  display: flex;\n  align-items: center;\n  width: 100%;\n}\n\n._randomItem_10d2m_63 {\n  margin-bottom: 10px;\n  padding: 8px;\n}\n\n._highlighted_10d2m_68 {\n  border: 2px solid;\n  border-radius: 4px;\n}\n._theming_1v217_1 {\n  padding: 0.25rem 1rem;\n  display: flex;\n  flex-direction: column;\n  gap: 1rem;\n}\n\n._theming_1v217_1 hr {\n  margin: 25px 0 0;\n}\n\n._chooseImage_1v217_12._chooseImage_1v217_12 {\n  padding: 0.2rem 10px;\n  border-radius: 8px;\n  text-transform: none;\n  color: #16205b;\n  font-weight: 500;\n  align-items: center;\n  border: 1px solid #16205b;\n}\n._resetButton_1v217_21._resetButton_1v217_21 {\n  padding: 0px;\n}\n._fontText_1v217_24 {\n  font-size: 14px;\n}\n._selectDropdown_1v217_27._selectDropdown_1v217_27 {\n  color: #16205b;\n  font-weight: 600;\n  border-radius: 11px;\n}\n\n._colorBox_1v217_33._colorBox_1v217_33 {\n  padding: 0.875rem;\n  border-radius: 8px;\n  width: 3rem;\n  border: 1px solid #16205b;\n}\n\n._colorPickerContainer_1v217_40 {\n  position: absolute;\n  z-index: 2;\n  right: 0;\n  top: 30px;\n  user-select: none;\n  display: flex;\n  flex-direction: column;\n  background-color: white;\n  border-radius: 8px;\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);\n}\n._themingItem_11qn9_1 h6 {\n  margin-top: 15px;\n  margin-bottom: 10px;\n}\n\n._themingItem_11qn9_1 ._themingItemBody_11qn9_6 {\n  display: flex;\n}\n\n._themingItem_11qn9_1 ._themingItemBody_11qn9_6 div:nth-child(1) {\n  flex-grow: 1;\n}\n._selectDropdown_11qn9_13._selectDropdown_11qn9_13 {\n  color: #16205b;\n  font-weight: 600;\n  border-radius: 15px;\n}\n/*$vite$:1*/";
        document.head.appendChild(__vite_style__);
        const BasicFuncs = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          get LINEAR_REGRESSION() {
            return LINEAR_REGRESSION;
          },
          get LOWER() {
            return LOWER;
          },
          get NOW() {
            return NOW;
          },
          get RELATIVE_DATETIME() {
            return RELATIVE_DATETIME;
          },
          get UPPER() {
            return UPPER;
          }
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function _objectWithoutProperties$2(e, t) {
          if (null == e) return {};
          var o,
            r,
            i = _objectWithoutPropertiesLoose(e, t);
          if (Object.getOwnPropertySymbols) {
            var s = Object.getOwnPropertySymbols(e);
            for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
          }
          return i;
        }

        /**
         * This file automatically generated from `pre-publish.js`.
         * Do not manually edit.
         */

        var voidElements = {
          "area": true,
          "base": true,
          "br": true,
          "col": true,
          "embed": true,
          "hr": true,
          "img": true,
          "input": true,
          "link": true,
          "meta": true,
          "param": true,
          "source": true,
          "track": true,
          "wbr": true
        };
        const e = /*@__PURE__*/getDefaultExportFromCjs(voidElements);
        var t = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
        function n(n) {
          var r = {
              type: "tag",
              name: "",
              voidElement: !1,
              attrs: {},
              children: []
            },
            i = n.match(/<\/?([^\s]+?)[/\s>]/);
          if (i && (r.name = i[1], (e[i[1]] || "/" === n.charAt(n.length - 2)) && (r.voidElement = !0), r.name.startsWith("!--"))) {
            var s = n.indexOf("--\x3e");
            return {
              type: "comment",
              comment: -1 !== s ? n.slice(4, s) : ""
            };
          }
          for (var a = new RegExp(t), c = null; null !== (c = a.exec(n));) if (c[0].trim()) if (c[1]) {
            var o = c[1].trim(),
              l = [o, ""];
            o.indexOf("=") > -1 && (l = o.split("=")), r.attrs[l[0]] = l[1], a.lastIndex--;
          } else c[2] && (r.attrs[c[2]] = c[3].trim().substring(1, c[3].length - 1));
          return r;
        }
        var r = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g,
          i = /^\s*$/,
          s = Object.create(null);
        function a(e, t) {
          switch (t.type) {
            case "text":
              return e + t.content;
            case "tag":
              return e += "<" + t.name + (t.attrs ? function (e) {
                var t = [];
                for (var n in e) t.push(n + '="' + e[n] + '"');
                return t.length ? " " + t.join(" ") : "";
              }(t.attrs) : "") + (t.voidElement ? "/>" : ">"), t.voidElement ? e : e + t.children.reduce(a, "") + "</" + t.name + ">";
            case "comment":
              return e + "\x3c!--" + t.comment + "--\x3e";
          }
        }
        var c = {
          parse: function parse(e, t) {
            t || (t = {}), t.components || (t.components = s);
            var a,
              c = [],
              o = [],
              l = -1,
              m = !1;
            if (0 !== e.indexOf("<")) {
              var u = e.indexOf("<");
              c.push({
                type: "text",
                content: -1 === u ? e : e.substring(0, u)
              });
            }
            return e.replace(r, function (r, s) {
              if (m) {
                if (r !== "</" + a.name + ">") return;
                m = !1;
              }
              var u,
                f = "/" !== r.charAt(1),
                h = r.startsWith("\x3c!--"),
                p = s + r.length,
                d = e.charAt(p);
              if (h) {
                var v = n(r);
                return l < 0 ? (c.push(v), c) : ((u = o[l]).children.push(v), c);
              }
              if (f && (l++, "tag" === (a = n(r)).type && t.components[a.name] && (a.type = "component", m = !0), a.voidElement || m || !d || "<" === d || a.children.push({
                type: "text",
                content: e.slice(p, e.indexOf("<", p))
              }), 0 === l && c.push(a), (u = o[l - 1]) && u.children.push(a), o[l] = a), (!f || a.voidElement) && (l > -1 && (a.voidElement || a.name === r.slice(2, -1)) && (l--, a = -1 === l ? c : o[l]), !m && "<" !== d && d)) {
                u = -1 === l ? c : o[l].children;
                var x = e.indexOf("<", p),
                  g = e.slice(p, -1 === x ? void 0 : x);
                i.test(g) && (g = " "), (x > -1 && l + u.length >= 0 || " " !== g) && u.push({
                  type: "text",
                  content: g
                });
              }
            }), c;
          },
          stringify: function stringify(e) {
            return e.reduce(function (e, t) {
              return e + a("", t);
            }, "");
          }
        };
        var _excluded$l = ["format"],
          _excluded2$3 = ["children", "count", "parent", "i18nKey", "context", "tOptions", "values", "defaults", "components", "ns", "i18n", "t", "shouldUnescape"];
        function ownKeys$G(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) {
              symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            }
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$E(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys$G(Object(source), true).forEach(function (key) {
                _defineProperty$4(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys$G(Object(source)).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function hasChildren$1(node, checkLength) {
          if (!node) return false;
          var base = node.props ? node.props.children : node.children;
          if (checkLength) return base.length > 0;
          return !!base;
        }
        function getChildren(node) {
          if (!node) return [];
          return node.props ? node.props.children : node.children;
        }
        function hasValidReactChildren(children) {
          if (Object.prototype.toString.call(children) !== '[object Array]') return false;
          return children.every(function (child) {
            return reactExports.isValidElement(child);
          });
        }
        function getAsArray(data) {
          return Array.isArray(data) ? data : [data];
        }
        function mergeProps(source, target) {
          var newTarget = _objectSpread$E({}, target);
          newTarget.props = Object.assign(source.props, target.props);
          return newTarget;
        }
        function nodesToString(children, i18nOptions) {
          if (!children) return '';
          var stringNode = '';
          var childrenArray = getAsArray(children);
          var keepArray = i18nOptions.transSupportBasicHtmlNodes && i18nOptions.transKeepBasicHtmlNodesFor ? i18nOptions.transKeepBasicHtmlNodesFor : [];
          childrenArray.forEach(function (child, childIndex) {
            if (typeof child === 'string') {
              stringNode += "".concat(child);
            } else if (reactExports.isValidElement(child)) {
              var childPropsCount = Object.keys(child.props).length;
              var shouldKeepChild = keepArray.indexOf(child.type) > -1;
              var childChildren = child.props.children;
              if (!childChildren && shouldKeepChild && childPropsCount === 0) {
                stringNode += "<".concat(child.type, "/>");
              } else if (!childChildren && (!shouldKeepChild || childPropsCount !== 0)) {
                stringNode += "<".concat(childIndex, "></").concat(childIndex, ">");
              } else if (child.props.i18nIsDynamicList) {
                stringNode += "<".concat(childIndex, "></").concat(childIndex, ">");
              } else if (shouldKeepChild && childPropsCount === 1 && typeof childChildren === 'string') {
                stringNode += "<".concat(child.type, ">").concat(childChildren, "</").concat(child.type, ">");
              } else {
                var content = nodesToString(childChildren, i18nOptions);
                stringNode += "<".concat(childIndex, ">").concat(content, "</").concat(childIndex, ">");
              }
            } else if (child === null) {
              warn$1("Trans: the passed in value is invalid - seems you passed in a null child.");
            } else if (_typeof$3(child) === 'object') {
              var format = child.format,
                clone = _objectWithoutProperties$2(child, _excluded$l);
              var keys = Object.keys(clone);
              if (keys.length === 1) {
                var value = format ? "".concat(keys[0], ", ").concat(format) : keys[0];
                stringNode += "{{".concat(value, "}}");
              } else {
                warn$1("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", child);
              }
            } else {
              warn$1("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", child);
            }
          });
          return stringNode;
        }
        function renderNodes(children, targetString, i18n, i18nOptions, combinedTOpts, shouldUnescape) {
          if (targetString === '') return [];
          var keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];
          var emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.join('|')).test(targetString);
          if (!children && !emptyChildrenButNeedsHandling) return [targetString];
          var data = {};
          function getData(childs) {
            var childrenArray = getAsArray(childs);
            childrenArray.forEach(function (child) {
              if (typeof child === 'string') return;
              if (hasChildren$1(child)) getData(getChildren(child));else if (_typeof$3(child) === 'object' && !reactExports.isValidElement(child)) Object.assign(data, child);
            });
          }
          getData(children);
          var ast = c.parse("<0>".concat(targetString, "</0>"));
          var opts = _objectSpread$E(_objectSpread$E({}, data), combinedTOpts);
          function renderInner(child, node, rootReactNode) {
            var childs = getChildren(child);
            var mappedChildren = mapAST(childs, node.children, rootReactNode);
            return hasValidReactChildren(childs) && mappedChildren.length === 0 ? childs : mappedChildren;
          }
          function pushTranslatedJSX(child, inner, mem, i, isVoid) {
            if (child.dummy) child.children = inner;
            mem.push(reactExports.cloneElement(child, _objectSpread$E(_objectSpread$E({}, child.props), {}, {
              key: i
            }), isVoid ? undefined : inner));
          }
          function mapAST(reactNode, astNode, rootReactNode) {
            var reactNodes = getAsArray(reactNode);
            var astNodes = getAsArray(astNode);
            return astNodes.reduce(function (mem, node, i) {
              var translationContent = node.children && node.children[0] && node.children[0].content && i18n.services.interpolator.interpolate(node.children[0].content, opts, i18n.language);
              if (node.type === 'tag') {
                var tmp = reactNodes[parseInt(node.name, 10)];
                if (!tmp && rootReactNode.length === 1 && rootReactNode[0][node.name]) tmp = rootReactNode[0][node.name];
                if (!tmp) tmp = {};
                var child = Object.keys(node.attrs).length !== 0 ? mergeProps({
                  props: node.attrs
                }, tmp) : tmp;
                var isElement = reactExports.isValidElement(child);
                var isValidTranslationWithChildren = isElement && hasChildren$1(node, true) && !node.voidElement;
                var isEmptyTransWithHTML = emptyChildrenButNeedsHandling && _typeof$3(child) === 'object' && child.dummy && !isElement;
                var isKnownComponent = _typeof$3(children) === 'object' && children !== null && Object.hasOwnProperty.call(children, node.name);
                if (typeof child === 'string') {
                  var value = i18n.services.interpolator.interpolate(child, opts, i18n.language);
                  mem.push(value);
                } else if (hasChildren$1(child) || isValidTranslationWithChildren) {
                  var inner = renderInner(child, node, rootReactNode);
                  pushTranslatedJSX(child, inner, mem, i);
                } else if (isEmptyTransWithHTML) {
                  var _inner = mapAST(reactNodes, node.children, rootReactNode);
                  mem.push(reactExports.cloneElement(child, _objectSpread$E(_objectSpread$E({}, child.props), {}, {
                    key: i
                  }), _inner));
                } else if (Number.isNaN(parseFloat(node.name))) {
                  if (isKnownComponent) {
                    var _inner2 = renderInner(child, node, rootReactNode);
                    pushTranslatedJSX(child, _inner2, mem, i, node.voidElement);
                  } else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) {
                    if (node.voidElement) {
                      mem.push(reactExports.createElement(node.name, {
                        key: "".concat(node.name, "-").concat(i)
                      }));
                    } else {
                      var _inner3 = mapAST(reactNodes, node.children, rootReactNode);
                      mem.push(reactExports.createElement(node.name, {
                        key: "".concat(node.name, "-").concat(i)
                      }, _inner3));
                    }
                  } else if (node.voidElement) {
                    mem.push("<".concat(node.name, " />"));
                  } else {
                    var _inner4 = mapAST(reactNodes, node.children, rootReactNode);
                    mem.push("<".concat(node.name, ">").concat(_inner4, "</").concat(node.name, ">"));
                  }
                } else if (_typeof$3(child) === 'object' && !isElement) {
                  var content = node.children[0] ? translationContent : null;
                  if (content) mem.push(content);
                } else if (node.children.length === 1 && translationContent) {
                  mem.push(reactExports.cloneElement(child, _objectSpread$E(_objectSpread$E({}, child.props), {}, {
                    key: i
                  }), translationContent));
                } else {
                  mem.push(reactExports.cloneElement(child, _objectSpread$E(_objectSpread$E({}, child.props), {}, {
                    key: i
                  })));
                }
              } else if (node.type === 'text') {
                var wrapTextNodes = i18nOptions.transWrapTextNodes;
                var _content = shouldUnescape ? i18nOptions.unescape(i18n.services.interpolator.interpolate(node.content, opts, i18n.language)) : i18n.services.interpolator.interpolate(node.content, opts, i18n.language);
                if (wrapTextNodes) {
                  mem.push(reactExports.createElement(wrapTextNodes, {
                    key: "".concat(node.name, "-").concat(i)
                  }, _content));
                } else {
                  mem.push(_content);
                }
              }
              return mem;
            }, []);
          }
          var result = mapAST([{
            dummy: true,
            children: children || []
          }], ast, getAsArray(children || []));
          return getChildren(result[0]);
        }
        function Trans(_ref) {
          var children = _ref.children,
            count = _ref.count,
            parent = _ref.parent,
            i18nKey = _ref.i18nKey,
            context = _ref.context,
            _ref$tOptions = _ref.tOptions,
            tOptions = _ref$tOptions === void 0 ? {} : _ref$tOptions,
            values = _ref.values,
            defaults = _ref.defaults,
            components = _ref.components,
            ns = _ref.ns,
            i18nFromProps = _ref.i18n,
            tFromProps = _ref.t,
            shouldUnescape = _ref.shouldUnescape,
            additionalProps = _objectWithoutProperties$2(_ref, _excluded2$3);
          var _ref2 = reactExports.useContext(I18nContext) || {},
            i18nFromContext = _ref2.i18n,
            defaultNSFromContext = _ref2.defaultNS;
          var i18n = i18nFromProps || i18nFromContext || getI18n();
          if (!i18n) {
            warnOnce('You will need to pass in an i18next instance by using i18nextReactModule');
            return children;
          }
          var t = tFromProps || i18n.t.bind(i18n) || function (k) {
            return k;
          };
          if (context) tOptions.context = context;
          var reactI18nextOptions = _objectSpread$E(_objectSpread$E({}, getDefaults()), i18n.options && i18n.options.react);
          var namespaces = ns || t.ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
          namespaces = typeof namespaces === 'string' ? [namespaces] : namespaces || ['translation'];
          var defaultValue = defaults || nodesToString(children, reactI18nextOptions) || reactI18nextOptions.transEmptyNodeValue || i18nKey;
          var hashTransKey = reactI18nextOptions.hashTransKey;
          var key = i18nKey || (hashTransKey ? hashTransKey(defaultValue) : defaultValue);
          var interpolationOverride = values ? tOptions.interpolation : {
            interpolation: _objectSpread$E(_objectSpread$E({}, tOptions.interpolation), {}, {
              prefix: '#$?',
              suffix: '?$#'
            })
          };
          var combinedTOpts = _objectSpread$E(_objectSpread$E(_objectSpread$E(_objectSpread$E({}, tOptions), {}, {
            count: count
          }, values), interpolationOverride), {}, {
            defaultValue: defaultValue,
            ns: namespaces
          });
          var translation = key ? t(key, combinedTOpts) : defaultValue;
          var content = renderNodes(components || children, translation, i18n, reactI18nextOptions, combinedTOpts, shouldUnescape);
          var useAsParent = parent !== undefined ? parent : reactI18nextOptions.defaultTransParent;
          return useAsParent ? reactExports.createElement(useAsParent, additionalProps, content) : content;
        }

        /**
         * Gets only the valid children of a component,
         * and ignores any nullish or falsy child.
         *
         * @param children the children
         */
        function getValidReactChildren(children) {
          return reactExports.Children.toArray(children).filter(child => /*#__PURE__*/reactExports.isValidElement(child));
        }
        const visuallyHidden = {
          border: 0,
          clip: 'rect(0 0 0 0)',
          height: '1px',
          margin: '-1px',
          overflow: 'hidden',
          padding: 0,
          position: 'absolute',
          whiteSpace: 'nowrap',
          width: '1px'
        };
        function stripDiacritics(string) {
          return typeof string.normalize !== "undefined" ? string.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : string;
        }
        function createFilterOptions(config = {}) {
          const _config$ignoreAccents = config.ignoreAccents,
            ignoreAccents = _config$ignoreAccents === void 0 ? true : _config$ignoreAccents,
            _config$ignoreCase = config.ignoreCase,
            ignoreCase = _config$ignoreCase === void 0 ? true : _config$ignoreCase,
            limit = config.limit,
            _config$matchFrom = config.matchFrom,
            matchFrom = _config$matchFrom === void 0 ? "any" : _config$matchFrom,
            stringify = config.stringify,
            _config$trim = config.trim,
            trim = _config$trim === void 0 ? false : _config$trim;
          return (options, {
            inputValue,
            getOptionLabel
          }) => {
            let input = trim ? inputValue.trim() : inputValue;
            if (ignoreCase) {
              input = input.toLowerCase();
            }
            if (ignoreAccents) {
              input = stripDiacritics(input);
            }
            const filteredOptions = !input ? options : options.filter(option => {
              let candidate = (stringify || getOptionLabel)(option);
              if (ignoreCase) {
                candidate = candidate.toLowerCase();
              }
              if (ignoreAccents) {
                candidate = stripDiacritics(candidate);
              }
              return matchFrom === "start" ? candidate.indexOf(input) === 0 : candidate.indexOf(input) > -1;
            });
            return typeof limit === "number" ? filteredOptions.slice(0, limit) : filteredOptions;
          };
        }
        function findIndex(array, comp) {
          for (let i = 0; i < array.length; i += 1) {
            if (comp(array[i])) {
              return i;
            }
          }
          return -1;
        }
        const defaultFilterOptions = createFilterOptions();
        const pageSize = 5;
        const defaultIsActiveElementInListbox = listboxRef => {
          var _listboxRef$current$p;
          return listboxRef.current !== null && ((_listboxRef$current$p = listboxRef.current.parentElement) == null ? void 0 : _listboxRef$current$p.contains(document.activeElement));
        };
        function useAutocomplete(props) {
          const _props$unstable_isAct = props.unstable_isActiveElementInListbox,
            unstable_isActiveElementInListbox = _props$unstable_isAct === void 0 ? defaultIsActiveElementInListbox : _props$unstable_isAct,
            _props$unstable_class = props.unstable_classNamePrefix,
            unstable_classNamePrefix = _props$unstable_class === void 0 ? "Mui" : _props$unstable_class,
            _props$autoComplete = props.autoComplete,
            autoComplete = _props$autoComplete === void 0 ? false : _props$autoComplete,
            _props$autoHighlight = props.autoHighlight,
            autoHighlight = _props$autoHighlight === void 0 ? false : _props$autoHighlight,
            _props$autoSelect = props.autoSelect,
            autoSelect = _props$autoSelect === void 0 ? false : _props$autoSelect,
            _props$blurOnSelect = props.blurOnSelect,
            blurOnSelect = _props$blurOnSelect === void 0 ? false : _props$blurOnSelect,
            _props$clearOnBlur = props.clearOnBlur,
            clearOnBlur = _props$clearOnBlur === void 0 ? !props.freeSolo : _props$clearOnBlur,
            _props$clearOnEscape = props.clearOnEscape,
            clearOnEscape = _props$clearOnEscape === void 0 ? false : _props$clearOnEscape,
            _props$componentName = props.componentName,
            componentName = _props$componentName === void 0 ? "useAutocomplete" : _props$componentName,
            _props$defaultValue = props.defaultValue,
            defaultValue = _props$defaultValue === void 0 ? props.multiple ? [] : null : _props$defaultValue,
            _props$disableClearab = props.disableClearable,
            disableClearable = _props$disableClearab === void 0 ? false : _props$disableClearab,
            _props$disableCloseOn = props.disableCloseOnSelect,
            disableCloseOnSelect = _props$disableCloseOn === void 0 ? false : _props$disableCloseOn,
            disabledProp = props.disabled,
            _props$disabledItemsF = props.disabledItemsFocusable,
            disabledItemsFocusable = _props$disabledItemsF === void 0 ? false : _props$disabledItemsF,
            _props$disableListWra = props.disableListWrap,
            disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra,
            _props$filterOptions = props.filterOptions,
            filterOptions = _props$filterOptions === void 0 ? defaultFilterOptions : _props$filterOptions,
            _props$filterSelected = props.filterSelectedOptions,
            filterSelectedOptions = _props$filterSelected === void 0 ? false : _props$filterSelected,
            _props$freeSolo = props.freeSolo,
            freeSolo = _props$freeSolo === void 0 ? false : _props$freeSolo,
            getOptionDisabled = props.getOptionDisabled,
            getOptionKey = props.getOptionKey,
            _props$getOptionLabel = props.getOptionLabel,
            getOptionLabelProp = _props$getOptionLabel === void 0 ? option => {
              var _option$label;
              return (_option$label = option.label) != null ? _option$label : option;
            } : _props$getOptionLabel,
            groupBy = props.groupBy,
            _props$handleHomeEndK = props.handleHomeEndKeys,
            handleHomeEndKeys = _props$handleHomeEndK === void 0 ? !props.freeSolo : _props$handleHomeEndK,
            idProp = props.id,
            _props$includeInputIn = props.includeInputInList,
            includeInputInList = _props$includeInputIn === void 0 ? false : _props$includeInputIn,
            inputValueProp = props.inputValue,
            _props$isOptionEqualT = props.isOptionEqualToValue,
            isOptionEqualToValue = _props$isOptionEqualT === void 0 ? (option, value2) => option === value2 : _props$isOptionEqualT,
            _props$multiple = props.multiple,
            multiple = _props$multiple === void 0 ? false : _props$multiple,
            onChange = props.onChange,
            onClose = props.onClose,
            onHighlightChange = props.onHighlightChange,
            onInputChange = props.onInputChange,
            onOpen = props.onOpen,
            openProp = props.open,
            _props$openOnFocus = props.openOnFocus,
            openOnFocus = _props$openOnFocus === void 0 ? false : _props$openOnFocus,
            options = props.options,
            _props$readOnly = props.readOnly,
            readOnly = _props$readOnly === void 0 ? false : _props$readOnly,
            _props$selectOnFocus = props.selectOnFocus,
            selectOnFocus = _props$selectOnFocus === void 0 ? !props.freeSolo : _props$selectOnFocus,
            valueProp = props.value;
          const id = useId(idProp);
          let getOptionLabel = getOptionLabelProp;
          getOptionLabel = option => {
            const optionLabel = getOptionLabelProp(option);
            if (typeof optionLabel !== "string") {
              return String(optionLabel);
            }
            return optionLabel;
          };
          const ignoreFocus = reactExports.useRef(false);
          const firstFocus = reactExports.useRef(true);
          const inputRef = reactExports.useRef(null);
          const listboxRef = reactExports.useRef(null);
          const _reactExports$useStat = reactExports.useState(null),
            _reactExports$useStat2 = _slicedToArray2(_reactExports$useStat, 2),
            anchorEl = _reactExports$useStat2[0],
            setAnchorEl = _reactExports$useStat2[1];
          const _reactExports$useStat3 = reactExports.useState(-1),
            _reactExports$useStat4 = _slicedToArray2(_reactExports$useStat3, 2),
            focusedTag = _reactExports$useStat4[0],
            setFocusedTag = _reactExports$useStat4[1];
          const defaultHighlighted = autoHighlight ? 0 : -1;
          const highlightedIndexRef = reactExports.useRef(defaultHighlighted);
          const _useControlled = useControlled({
              controlled: valueProp,
              default: defaultValue,
              name: componentName
            }),
            _useControlled2 = _slicedToArray2(_useControlled, 2),
            value = _useControlled2[0],
            setValueState = _useControlled2[1];
          const _useControlled3 = useControlled({
              controlled: inputValueProp,
              default: "",
              name: componentName,
              state: "inputValue"
            }),
            _useControlled4 = _slicedToArray2(_useControlled3, 2),
            inputValue = _useControlled4[0],
            setInputValueState = _useControlled4[1];
          const _reactExports$useStat5 = reactExports.useState(false),
            _reactExports$useStat6 = _slicedToArray2(_reactExports$useStat5, 2),
            focused = _reactExports$useStat6[0],
            setFocused = _reactExports$useStat6[1];
          const resetInputValue = reactExports.useCallback((event, newValue) => {
            const isOptionSelected = multiple ? value.length < newValue.length : newValue !== null;
            if (!isOptionSelected && !clearOnBlur) {
              return;
            }
            let newInputValue;
            if (multiple) {
              newInputValue = "";
            } else if (newValue == null) {
              newInputValue = "";
            } else {
              const optionLabel = getOptionLabel(newValue);
              newInputValue = typeof optionLabel === "string" ? optionLabel : "";
            }
            if (inputValue === newInputValue) {
              return;
            }
            setInputValueState(newInputValue);
            if (onInputChange) {
              onInputChange(event, newInputValue, "reset");
            }
          }, [getOptionLabel, inputValue, multiple, onInputChange, setInputValueState, clearOnBlur, value]);
          const _useControlled5 = useControlled({
              controlled: openProp,
              default: false,
              name: componentName,
              state: "open"
            }),
            _useControlled6 = _slicedToArray2(_useControlled5, 2),
            open = _useControlled6[0],
            setOpenState = _useControlled6[1];
          const _reactExports$useStat7 = reactExports.useState(true),
            _reactExports$useStat8 = _slicedToArray2(_reactExports$useStat7, 2),
            inputPristine = _reactExports$useStat8[0],
            setInputPristine = _reactExports$useStat8[1];
          const inputValueIsSelectedValue = !multiple && value != null && inputValue === getOptionLabel(value);
          const popupOpen = open && !readOnly;
          const filteredOptions = popupOpen ? filterOptions(options.filter(option => {
            if (filterSelectedOptions && (multiple ? value : [value]).some(value2 => value2 !== null && isOptionEqualToValue(option, value2))) {
              return false;
            }
            return true;
          }),
          // we use the empty string to manipulate `filterOptions` to not filter any options
          // i.e. the filter predicate always returns true
          {
            inputValue: inputValueIsSelectedValue && inputPristine ? "" : inputValue,
            getOptionLabel
          }) : [];
          const previousProps = usePreviousProps({
            filteredOptions,
            value,
            inputValue
          });
          reactExports.useEffect(() => {
            const valueChange = value !== previousProps.value;
            if (focused && !valueChange) {
              return;
            }
            if (freeSolo && !valueChange) {
              return;
            }
            resetInputValue(null, value);
          }, [value, resetInputValue, focused, previousProps.value, freeSolo]);
          const listboxAvailable = open && filteredOptions.length > 0 && !readOnly;
          const focusTag = useEventCallback(tagToFocus => {
            if (tagToFocus === -1) {
              inputRef.current.focus();
            } else {
              anchorEl.querySelector(`[data-tag-index="${tagToFocus}"]`).focus();
            }
          });
          reactExports.useEffect(() => {
            if (multiple && focusedTag > value.length - 1) {
              setFocusedTag(-1);
              focusTag(-1);
            }
          }, [value, multiple, focusedTag, focusTag]);
          function validOptionIndex(index, direction) {
            if (!listboxRef.current || index < 0 || index >= filteredOptions.length) {
              return -1;
            }
            let nextFocus = index;
            while (true) {
              const option = listboxRef.current.querySelector(`[data-option-index="${nextFocus}"]`);
              const nextFocusDisabled = disabledItemsFocusable ? false : !option || option.disabled || option.getAttribute("aria-disabled") === "true";
              if (option && option.hasAttribute("tabindex") && !nextFocusDisabled) {
                return nextFocus;
              }
              if (direction === "next") {
                nextFocus = (nextFocus + 1) % filteredOptions.length;
              } else {
                nextFocus = (nextFocus - 1 + filteredOptions.length) % filteredOptions.length;
              }
              if (nextFocus === index) {
                return -1;
              }
            }
          }
          const setHighlightedIndex = useEventCallback(({
            event,
            index,
            reason = "auto"
          }) => {
            highlightedIndexRef.current = index;
            if (index === -1) {
              inputRef.current.removeAttribute("aria-activedescendant");
            } else {
              inputRef.current.setAttribute("aria-activedescendant", `${id}-option-${index}`);
            }
            if (onHighlightChange) {
              onHighlightChange(event, index === -1 ? null : filteredOptions[index], reason);
            }
            if (!listboxRef.current) {
              return;
            }
            const prev = listboxRef.current.querySelector(`[role="option"].${unstable_classNamePrefix}-focused`);
            if (prev) {
              prev.classList.remove(`${unstable_classNamePrefix}-focused`);
              prev.classList.remove(`${unstable_classNamePrefix}-focusVisible`);
            }
            let listboxNode = listboxRef.current;
            if (listboxRef.current.getAttribute("role") !== "listbox") {
              listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]');
            }
            if (!listboxNode) {
              return;
            }
            if (index === -1) {
              listboxNode.scrollTop = 0;
              return;
            }
            const option = listboxRef.current.querySelector(`[data-option-index="${index}"]`);
            if (!option) {
              return;
            }
            option.classList.add(`${unstable_classNamePrefix}-focused`);
            if (reason === "keyboard") {
              option.classList.add(`${unstable_classNamePrefix}-focusVisible`);
            }
            if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== "mouse" && reason !== "touch") {
              const element = option;
              const scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
              const elementBottom = element.offsetTop + element.offsetHeight;
              if (elementBottom > scrollBottom) {
                listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
              } else if (element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0) < listboxNode.scrollTop) {
                listboxNode.scrollTop = element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0);
              }
            }
          });
          const changeHighlightedIndex = useEventCallback(({
            event,
            diff,
            direction = "next",
            reason = "auto"
          }) => {
            if (!popupOpen) {
              return;
            }
            const getNextIndex = () => {
              const maxIndex = filteredOptions.length - 1;
              if (diff === "reset") {
                return defaultHighlighted;
              }
              if (diff === "start") {
                return 0;
              }
              if (diff === "end") {
                return maxIndex;
              }
              const newIndex = highlightedIndexRef.current + diff;
              if (newIndex < 0) {
                if (newIndex === -1 && includeInputInList) {
                  return -1;
                }
                if (disableListWrap && highlightedIndexRef.current !== -1 || Math.abs(diff) > 1) {
                  return 0;
                }
                return maxIndex;
              }
              if (newIndex > maxIndex) {
                if (newIndex === maxIndex + 1 && includeInputInList) {
                  return -1;
                }
                if (disableListWrap || Math.abs(diff) > 1) {
                  return maxIndex;
                }
                return 0;
              }
              return newIndex;
            };
            const nextIndex = validOptionIndex(getNextIndex(), direction);
            setHighlightedIndex({
              index: nextIndex,
              reason,
              event
            });
            if (autoComplete && diff !== "reset") {
              if (nextIndex === -1) {
                inputRef.current.value = inputValue;
              } else {
                const option = getOptionLabel(filteredOptions[nextIndex]);
                inputRef.current.value = option;
                const index = option.toLowerCase().indexOf(inputValue.toLowerCase());
                if (index === 0 && inputValue.length > 0) {
                  inputRef.current.setSelectionRange(inputValue.length, option.length);
                }
              }
            }
          });
          const getPreviousHighlightedOptionIndex = () => {
            const isSameValue = (value1, value2) => {
              const label1 = value1 ? getOptionLabel(value1) : "";
              const label2 = value2 ? getOptionLabel(value2) : "";
              return label1 === label2;
            };
            if (highlightedIndexRef.current !== -1 && previousProps.filteredOptions && previousProps.filteredOptions.length !== filteredOptions.length && previousProps.inputValue === inputValue && (multiple ? value.length === previousProps.value.length && previousProps.value.every((val, i) => getOptionLabel(value[i]) === getOptionLabel(val)) : isSameValue(previousProps.value, value))) {
              const previousHighlightedOption = previousProps.filteredOptions[highlightedIndexRef.current];
              if (previousHighlightedOption) {
                return findIndex(filteredOptions, option => {
                  return getOptionLabel(option) === getOptionLabel(previousHighlightedOption);
                });
              }
            }
            return -1;
          };
          const syncHighlightedIndex = reactExports.useCallback(() => {
            if (!popupOpen) {
              return;
            }
            const previousHighlightedOptionIndex = getPreviousHighlightedOptionIndex();
            if (previousHighlightedOptionIndex !== -1) {
              highlightedIndexRef.current = previousHighlightedOptionIndex;
              return;
            }
            const valueItem = multiple ? value[0] : value;
            if (filteredOptions.length === 0 || valueItem == null) {
              changeHighlightedIndex({
                diff: "reset"
              });
              return;
            }
            if (!listboxRef.current) {
              return;
            }
            if (valueItem != null) {
              const currentOption = filteredOptions[highlightedIndexRef.current];
              if (multiple && currentOption && findIndex(value, val => isOptionEqualToValue(currentOption, val)) !== -1) {
                return;
              }
              const itemIndex = findIndex(filteredOptions, optionItem => isOptionEqualToValue(optionItem, valueItem));
              if (itemIndex === -1) {
                changeHighlightedIndex({
                  diff: "reset"
                });
              } else {
                setHighlightedIndex({
                  index: itemIndex
                });
              }
              return;
            }
            if (highlightedIndexRef.current >= filteredOptions.length - 1) {
              setHighlightedIndex({
                index: filteredOptions.length - 1
              });
              return;
            }
            setHighlightedIndex({
              index: highlightedIndexRef.current
            });
          }, [
          // Only sync the highlighted index when the option switch between empty and not
          filteredOptions.length,
          // Don't sync the highlighted index with the value when multiple
          // eslint-disable-next-line react-hooks/exhaustive-deps
          multiple ? false : value, filterSelectedOptions, changeHighlightedIndex, setHighlightedIndex, popupOpen, inputValue, multiple]);
          const handleListboxRef = useEventCallback(node => {
            setRef(listboxRef, node);
            if (!node) {
              return;
            }
            syncHighlightedIndex();
          });
          reactExports.useEffect(() => {
            syncHighlightedIndex();
          }, [syncHighlightedIndex]);
          const handleOpen = event => {
            if (open) {
              return;
            }
            setOpenState(true);
            setInputPristine(true);
            if (onOpen) {
              onOpen(event);
            }
          };
          const handleClose = (event, reason) => {
            if (!open) {
              return;
            }
            setOpenState(false);
            if (onClose) {
              onClose(event, reason);
            }
          };
          const handleValue = (event, newValue, reason, details) => {
            if (multiple) {
              if (value.length === newValue.length && value.every((val, i) => val === newValue[i])) {
                return;
              }
            } else if (value === newValue) {
              return;
            }
            if (onChange) {
              onChange(event, newValue, reason, details);
            }
            setValueState(newValue);
          };
          const isTouch = reactExports.useRef(false);
          const selectNewValue = (event, option, reasonProp = "selectOption", origin = "options") => {
            let reason = reasonProp;
            let newValue = option;
            if (multiple) {
              newValue = Array.isArray(value) ? value.slice() : [];
              const itemIndex = findIndex(newValue, valueItem => isOptionEqualToValue(option, valueItem));
              if (itemIndex === -1) {
                newValue.push(option);
              } else if (origin !== "freeSolo") {
                newValue.splice(itemIndex, 1);
                reason = "removeOption";
              }
            }
            resetInputValue(event, newValue);
            handleValue(event, newValue, reason, {
              option
            });
            if (!disableCloseOnSelect && (!event || !event.ctrlKey && !event.metaKey)) {
              handleClose(event, reason);
            }
            if (blurOnSelect === true || blurOnSelect === "touch" && isTouch.current || blurOnSelect === "mouse" && !isTouch.current) {
              inputRef.current.blur();
            }
          };
          function validTagIndex(index, direction) {
            if (index === -1) {
              return -1;
            }
            let nextFocus = index;
            while (true) {
              if (direction === "next" && nextFocus === value.length || direction === "previous" && nextFocus === -1) {
                return -1;
              }
              const option = anchorEl.querySelector(`[data-tag-index="${nextFocus}"]`);
              if (!option || !option.hasAttribute("tabindex") || option.disabled || option.getAttribute("aria-disabled") === "true") {
                nextFocus += direction === "next" ? 1 : -1;
              } else {
                return nextFocus;
              }
            }
          }
          const handleFocusTag = (event, direction) => {
            if (!multiple) {
              return;
            }
            if (inputValue === "") {
              handleClose(event, "toggleInput");
            }
            let nextTag = focusedTag;
            if (focusedTag === -1) {
              if (inputValue === "" && direction === "previous") {
                nextTag = value.length - 1;
              }
            } else {
              nextTag += direction === "next" ? 1 : -1;
              if (nextTag < 0) {
                nextTag = 0;
              }
              if (nextTag === value.length) {
                nextTag = -1;
              }
            }
            nextTag = validTagIndex(nextTag, direction);
            setFocusedTag(nextTag);
            focusTag(nextTag);
          };
          const handleClear = event => {
            ignoreFocus.current = true;
            setInputValueState("");
            if (onInputChange) {
              onInputChange(event, "", "clear");
            }
            handleValue(event, multiple ? [] : null, "clear");
          };
          const handleKeyDown = other => event => {
            if (other.onKeyDown) {
              other.onKeyDown(event);
            }
            if (event.defaultMuiPrevented) {
              return;
            }
            if (focusedTag !== -1 && ["ArrowLeft", "ArrowRight"].indexOf(event.key) === -1) {
              setFocusedTag(-1);
              focusTag(-1);
            }
            if (event.which !== 229) {
              switch (event.key) {
                case "Home":
                  if (popupOpen && handleHomeEndKeys) {
                    event.preventDefault();
                    changeHighlightedIndex({
                      diff: "start",
                      direction: "next",
                      reason: "keyboard",
                      event
                    });
                  }
                  break;
                case "End":
                  if (popupOpen && handleHomeEndKeys) {
                    event.preventDefault();
                    changeHighlightedIndex({
                      diff: "end",
                      direction: "previous",
                      reason: "keyboard",
                      event
                    });
                  }
                  break;
                case "PageUp":
                  event.preventDefault();
                  changeHighlightedIndex({
                    diff: -pageSize,
                    direction: "previous",
                    reason: "keyboard",
                    event
                  });
                  handleOpen(event);
                  break;
                case "PageDown":
                  event.preventDefault();
                  changeHighlightedIndex({
                    diff: pageSize,
                    direction: "next",
                    reason: "keyboard",
                    event
                  });
                  handleOpen(event);
                  break;
                case "ArrowDown":
                  event.preventDefault();
                  changeHighlightedIndex({
                    diff: 1,
                    direction: "next",
                    reason: "keyboard",
                    event
                  });
                  handleOpen(event);
                  break;
                case "ArrowUp":
                  event.preventDefault();
                  changeHighlightedIndex({
                    diff: -1,
                    direction: "previous",
                    reason: "keyboard",
                    event
                  });
                  handleOpen(event);
                  break;
                case "ArrowLeft":
                  handleFocusTag(event, "previous");
                  break;
                case "ArrowRight":
                  handleFocusTag(event, "next");
                  break;
                case "Enter":
                  if (highlightedIndexRef.current !== -1 && popupOpen) {
                    const option = filteredOptions[highlightedIndexRef.current];
                    const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
                    event.preventDefault();
                    if (disabled) {
                      return;
                    }
                    selectNewValue(event, option, "selectOption");
                    if (autoComplete) {
                      inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
                    }
                  } else if (freeSolo && inputValue !== "" && inputValueIsSelectedValue === false) {
                    if (multiple) {
                      event.preventDefault();
                    }
                    selectNewValue(event, inputValue, "createOption", "freeSolo");
                  }
                  break;
                case "Escape":
                  if (popupOpen) {
                    event.preventDefault();
                    event.stopPropagation();
                    handleClose(event, "escape");
                  } else if (clearOnEscape && (inputValue !== "" || multiple && value.length > 0)) {
                    event.preventDefault();
                    event.stopPropagation();
                    handleClear(event);
                  }
                  break;
                case "Backspace":
                  if (multiple && !readOnly && inputValue === "" && value.length > 0) {
                    const index = focusedTag === -1 ? value.length - 1 : focusedTag;
                    const newValue = value.slice();
                    newValue.splice(index, 1);
                    handleValue(event, newValue, "removeOption", {
                      option: value[index]
                    });
                  }
                  break;
                case "Delete":
                  if (multiple && !readOnly && inputValue === "" && value.length > 0 && focusedTag !== -1) {
                    const index = focusedTag;
                    const newValue = value.slice();
                    newValue.splice(index, 1);
                    handleValue(event, newValue, "removeOption", {
                      option: value[index]
                    });
                  }
                  break;
              }
            }
          };
          const handleFocus = event => {
            setFocused(true);
            if (openOnFocus && !ignoreFocus.current) {
              handleOpen(event);
            }
          };
          const handleBlur = event => {
            if (unstable_isActiveElementInListbox(listboxRef)) {
              inputRef.current.focus();
              return;
            }
            setFocused(false);
            firstFocus.current = true;
            ignoreFocus.current = false;
            if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
              selectNewValue(event, filteredOptions[highlightedIndexRef.current], "blur");
            } else if (autoSelect && freeSolo && inputValue !== "") {
              selectNewValue(event, inputValue, "blur", "freeSolo");
            } else if (clearOnBlur) {
              resetInputValue(event, value);
            }
            handleClose(event, "blur");
          };
          const handleInputChange = event => {
            const newValue = event.target.value;
            if (inputValue !== newValue) {
              setInputValueState(newValue);
              setInputPristine(false);
              if (onInputChange) {
                onInputChange(event, newValue, "input");
              }
            }
            if (newValue === "") {
              if (!disableClearable && !multiple) {
                handleValue(event, null, "clear");
              }
            } else {
              handleOpen(event);
            }
          };
          const handleOptionMouseMove = event => {
            const index = Number(event.currentTarget.getAttribute("data-option-index"));
            if (highlightedIndexRef.current !== index) {
              setHighlightedIndex({
                event,
                index,
                reason: "mouse"
              });
            }
          };
          const handleOptionTouchStart = event => {
            setHighlightedIndex({
              event,
              index: Number(event.currentTarget.getAttribute("data-option-index")),
              reason: "touch"
            });
            isTouch.current = true;
          };
          const handleOptionClick = event => {
            const index = Number(event.currentTarget.getAttribute("data-option-index"));
            selectNewValue(event, filteredOptions[index], "selectOption");
            isTouch.current = false;
          };
          const handleTagDelete = index => event => {
            const newValue = value.slice();
            newValue.splice(index, 1);
            handleValue(event, newValue, "removeOption", {
              option: value[index]
            });
          };
          const handlePopupIndicator = event => {
            if (open) {
              handleClose(event, "toggleInput");
            } else {
              handleOpen(event);
            }
          };
          const handleMouseDown = event => {
            if (!event.currentTarget.contains(event.target)) {
              return;
            }
            if (event.target.getAttribute("id") !== id) {
              event.preventDefault();
            }
          };
          const handleClick = event => {
            if (!event.currentTarget.contains(event.target)) {
              return;
            }
            inputRef.current.focus();
            if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
              inputRef.current.select();
            }
            firstFocus.current = false;
          };
          const handleInputMouseDown = event => {
            if (!disabledProp && (inputValue === "" || !open)) {
              handlePopupIndicator(event);
            }
          };
          let dirty = freeSolo && inputValue.length > 0;
          dirty = dirty || (multiple ? value.length > 0 : value !== null);
          let groupedOptions = filteredOptions;
          if (groupBy) {
            groupedOptions = filteredOptions.reduce((acc, option, index) => {
              const group = groupBy(option);
              if (acc.length > 0 && acc[acc.length - 1].group === group) {
                acc[acc.length - 1].options.push(option);
              } else {
                acc.push({
                  key: index,
                  index,
                  group,
                  options: [option]
                });
              }
              return acc;
            }, []);
          }
          if (disabledProp && focused) {
            handleBlur();
          }
          return {
            getRootProps: (other = {}) => _extends$h({
              "aria-owns": listboxAvailable ? `${id}-listbox` : null
            }, other, {
              onKeyDown: handleKeyDown(other),
              onMouseDown: handleMouseDown,
              onClick: handleClick
            }),
            getInputLabelProps: () => ({
              id: `${id}-label`,
              htmlFor: id
            }),
            getInputProps: () => ({
              id,
              value: inputValue,
              onBlur: handleBlur,
              onFocus: handleFocus,
              onChange: handleInputChange,
              onMouseDown: handleInputMouseDown,
              // if open then this is handled imperatively so don't let react override
              // only have an opinion about this when closed
              "aria-activedescendant": popupOpen ? "" : null,
              "aria-autocomplete": autoComplete ? "both" : "list",
              "aria-controls": listboxAvailable ? `${id}-listbox` : void 0,
              "aria-expanded": listboxAvailable,
              // Disable browser's suggestion that might overlap with the popup.
              // Handle autocomplete but not autofill.
              autoComplete: "off",
              ref: inputRef,
              autoCapitalize: "none",
              spellCheck: "false",
              role: "combobox",
              disabled: disabledProp
            }),
            getClearProps: () => ({
              tabIndex: -1,
              type: "button",
              onClick: handleClear
            }),
            getPopupIndicatorProps: () => ({
              tabIndex: -1,
              type: "button",
              onClick: handlePopupIndicator
            }),
            getTagProps: ({
              index
            }) => _extends$h({
              key: index,
              "data-tag-index": index,
              tabIndex: -1
            }, !readOnly && {
              onDelete: handleTagDelete(index)
            }),
            getListboxProps: () => ({
              role: "listbox",
              id: `${id}-listbox`,
              "aria-labelledby": `${id}-label`,
              ref: handleListboxRef,
              onMouseDown: event => {
                event.preventDefault();
              }
            }),
            getOptionProps: ({
              index,
              option
            }) => {
              var _getOptionKey;
              const selected = (multiple ? value : [value]).some(value2 => value2 != null && isOptionEqualToValue(option, value2));
              const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
              return {
                key: (_getOptionKey = getOptionKey == null ? void 0 : getOptionKey(option)) != null ? _getOptionKey : getOptionLabel(option),
                tabIndex: -1,
                role: "option",
                id: `${id}-option-${index}`,
                onMouseMove: handleOptionMouseMove,
                onClick: handleOptionClick,
                onTouchStart: handleOptionTouchStart,
                "data-option-index": index,
                "aria-disabled": disabled,
                "aria-selected": selected
              };
            },
            id,
            inputValue,
            value,
            dirty,
            expanded: popupOpen && anchorEl,
            popupOpen,
            focused: focused || focusedTag !== -1,
            anchorEl,
            setAnchorEl,
            focusedTag,
            groupedOptions
          };
        }
        function getListSubheaderUtilityClass(slot) {
          return generateUtilityClass('MuiListSubheader', slot);
        }
        generateUtilityClasses('MuiListSubheader', ['root', 'colorPrimary', 'colorInherit', 'gutters', 'inset', 'sticky']);
        const _excluded$k = ["className", "color", "component", "disableGutters", "disableSticky", "inset"];
        const useUtilityClasses$9 = ownerState => {
          const classes = ownerState.classes,
            color = ownerState.color,
            disableGutters = ownerState.disableGutters,
            inset = ownerState.inset,
            disableSticky = ownerState.disableSticky;
          const slots = {
            root: ["root", color !== "default" && `color${capitalize$1(color)}`, !disableGutters && "gutters", inset && "inset", !disableSticky && "sticky"]
          };
          return composeClasses(slots, getListSubheaderUtilityClass, classes);
        };
        const ListSubheaderRoot = styled("li", {
          name: "MuiListSubheader",
          slot: "Root",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.root, ownerState.color !== "default" && styles[`color${capitalize$1(ownerState.color)}`], !ownerState.disableGutters && styles.gutters, ownerState.inset && styles.inset, !ownerState.disableSticky && styles.sticky];
          }
        })(({
          theme,
          ownerState
        }) => _extends$h({
          boxSizing: "border-box",
          lineHeight: "48px",
          listStyle: "none",
          color: (theme.vars || theme).palette.text.secondary,
          fontFamily: theme.typography.fontFamily,
          fontWeight: theme.typography.fontWeightMedium,
          fontSize: theme.typography.pxToRem(14)
        }, ownerState.color === "primary" && {
          color: (theme.vars || theme).palette.primary.main
        }, ownerState.color === "inherit" && {
          color: "inherit"
        }, !ownerState.disableGutters && {
          paddingLeft: 16,
          paddingRight: 16
        }, ownerState.inset && {
          paddingLeft: 72
        }, !ownerState.disableSticky && {
          position: "sticky",
          top: 0,
          zIndex: 1,
          backgroundColor: (theme.vars || theme).palette.background.paper
        }));
        const ListSubheader = /* @__PURE__ */reactExports.forwardRef(function ListSubheader2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiListSubheader"
          });
          const className = props.className,
            _props$color = props.color,
            color = _props$color === void 0 ? "default" : _props$color,
            _props$component = props.component,
            component = _props$component === void 0 ? "li" : _props$component,
            _props$disableGutters = props.disableGutters,
            disableGutters = _props$disableGutters === void 0 ? false : _props$disableGutters,
            _props$disableSticky = props.disableSticky,
            disableSticky = _props$disableSticky === void 0 ? false : _props$disableSticky,
            _props$inset = props.inset,
            inset = _props$inset === void 0 ? false : _props$inset,
            other = _objectWithoutPropertiesLoose(props, _excluded$k);
          const ownerState = _extends$h({}, props, {
            color,
            component,
            disableGutters,
            disableSticky,
            inset
          });
          const classes = useUtilityClasses$9(ownerState);
          return /* @__PURE__ */jsxRuntimeExports.jsx(ListSubheaderRoot, _extends$h({
            as: component,
            className: clsx(classes.root, className),
            ref,
            ownerState
          }, other));
        });
        ListSubheader.muiSkipListHighlight = true;
        var _ClearIcon, _ArrowDropDownIcon;
        const _excluded$j = ["autoComplete", "autoHighlight", "autoSelect", "blurOnSelect", "ChipProps", "className", "clearIcon", "clearOnBlur", "clearOnEscape", "clearText", "closeText", "componentsProps", "defaultValue", "disableClearable", "disableCloseOnSelect", "disabled", "disabledItemsFocusable", "disableListWrap", "disablePortal", "filterOptions", "filterSelectedOptions", "forcePopupIcon", "freeSolo", "fullWidth", "getLimitTagsText", "getOptionDisabled", "getOptionKey", "getOptionLabel", "isOptionEqualToValue", "groupBy", "handleHomeEndKeys", "id", "includeInputInList", "inputValue", "limitTags", "ListboxComponent", "ListboxProps", "loading", "loadingText", "multiple", "noOptionsText", "onChange", "onClose", "onHighlightChange", "onInputChange", "onOpen", "open", "openOnFocus", "openText", "options", "PaperComponent", "PopperComponent", "popupIcon", "readOnly", "renderGroup", "renderInput", "renderOption", "renderTags", "selectOnFocus", "size", "slotProps", "value"],
          _excluded2$2 = ["ref"],
          _excluded3$1 = ["key"],
          _excluded4 = ["key"];
        const useUtilityClasses$8 = ownerState => {
          const classes = ownerState.classes,
            disablePortal = ownerState.disablePortal,
            expanded = ownerState.expanded,
            focused = ownerState.focused,
            fullWidth = ownerState.fullWidth,
            hasClearIcon = ownerState.hasClearIcon,
            hasPopupIcon = ownerState.hasPopupIcon,
            inputFocused = ownerState.inputFocused,
            popupOpen = ownerState.popupOpen,
            size = ownerState.size;
          const slots = {
            root: ["root", expanded && "expanded", focused && "focused", fullWidth && "fullWidth", hasClearIcon && "hasClearIcon", hasPopupIcon && "hasPopupIcon"],
            inputRoot: ["inputRoot"],
            input: ["input", inputFocused && "inputFocused"],
            tag: ["tag", `tagSize${capitalize$1(size)}`],
            endAdornment: ["endAdornment"],
            clearIndicator: ["clearIndicator"],
            popupIndicator: ["popupIndicator", popupOpen && "popupIndicatorOpen"],
            popper: ["popper", disablePortal && "popperDisablePortal"],
            paper: ["paper"],
            listbox: ["listbox"],
            loading: ["loading"],
            noOptions: ["noOptions"],
            option: ["option"],
            groupLabel: ["groupLabel"],
            groupUl: ["groupUl"]
          };
          return composeClasses(slots, getAutocompleteUtilityClass, classes);
        };
        const AutocompleteRoot = styled("div", {
          name: "MuiAutocomplete",
          slot: "Root",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            const fullWidth = ownerState.fullWidth,
              hasClearIcon = ownerState.hasClearIcon,
              hasPopupIcon = ownerState.hasPopupIcon,
              inputFocused = ownerState.inputFocused,
              size = ownerState.size;
            return [{
              [`& .${autocompleteClasses.tag}`]: styles.tag
            }, {
              [`& .${autocompleteClasses.tag}`]: styles[`tagSize${capitalize$1(size)}`]
            }, {
              [`& .${autocompleteClasses.inputRoot}`]: styles.inputRoot
            }, {
              [`& .${autocompleteClasses.input}`]: styles.input
            }, {
              [`& .${autocompleteClasses.input}`]: inputFocused && styles.inputFocused
            }, styles.root, fullWidth && styles.fullWidth, hasPopupIcon && styles.hasPopupIcon, hasClearIcon && styles.hasClearIcon];
          }
        })({
          [`&.${autocompleteClasses.focused} .${autocompleteClasses.clearIndicator}`]: {
            visibility: "visible"
          },
          /* Avoid double tap issue on iOS */
          "@media (pointer: fine)": {
            [`&:hover .${autocompleteClasses.clearIndicator}`]: {
              visibility: "visible"
            }
          },
          [`& .${autocompleteClasses.tag}`]: {
            margin: 3,
            maxWidth: "calc(100% - 6px)"
          },
          [`& .${autocompleteClasses.inputRoot}`]: {
            [`.${autocompleteClasses.hasPopupIcon}&, .${autocompleteClasses.hasClearIcon}&`]: {
              paddingRight: 26 + 4
            },
            [`.${autocompleteClasses.hasPopupIcon}.${autocompleteClasses.hasClearIcon}&`]: {
              paddingRight: 52 + 4
            },
            [`& .${autocompleteClasses.input}`]: {
              width: 0,
              minWidth: 30
            }
          },
          [`& .${inputClasses.root}`]: {
            paddingBottom: 1,
            "& .MuiInput-input": {
              padding: "4px 4px 4px 0px"
            }
          },
          [`& .${inputClasses.root}.${inputBaseClasses.sizeSmall}`]: {
            [`& .${inputClasses.input}`]: {
              padding: "2px 4px 3px 0"
            }
          },
          [`& .${outlinedInputClasses.root}`]: {
            padding: 9,
            [`.${autocompleteClasses.hasPopupIcon}&, .${autocompleteClasses.hasClearIcon}&`]: {
              paddingRight: 26 + 4 + 9
            },
            [`.${autocompleteClasses.hasPopupIcon}.${autocompleteClasses.hasClearIcon}&`]: {
              paddingRight: 52 + 4 + 9
            },
            [`& .${autocompleteClasses.input}`]: {
              padding: "7.5px 4px 7.5px 5px"
            },
            [`& .${autocompleteClasses.endAdornment}`]: {
              right: 9
            }
          },
          [`& .${outlinedInputClasses.root}.${inputBaseClasses.sizeSmall}`]: {
            // Don't specify paddingRight, as it overrides the default value set when there is only
            // one of the popup or clear icon as the specificity is equal so the latter one wins
            paddingTop: 6,
            paddingBottom: 6,
            paddingLeft: 6,
            [`& .${autocompleteClasses.input}`]: {
              padding: "2.5px 4px 2.5px 8px"
            }
          },
          [`& .${filledInputClasses.root}`]: {
            paddingTop: 19,
            paddingLeft: 8,
            [`.${autocompleteClasses.hasPopupIcon}&, .${autocompleteClasses.hasClearIcon}&`]: {
              paddingRight: 26 + 4 + 9
            },
            [`.${autocompleteClasses.hasPopupIcon}.${autocompleteClasses.hasClearIcon}&`]: {
              paddingRight: 52 + 4 + 9
            },
            [`& .${filledInputClasses.input}`]: {
              padding: "7px 4px"
            },
            [`& .${autocompleteClasses.endAdornment}`]: {
              right: 9
            }
          },
          [`& .${filledInputClasses.root}.${inputBaseClasses.sizeSmall}`]: {
            paddingBottom: 1,
            [`& .${filledInputClasses.input}`]: {
              padding: "2.5px 4px"
            }
          },
          [`& .${inputBaseClasses.hiddenLabel}`]: {
            paddingTop: 8
          },
          [`& .${filledInputClasses.root}.${inputBaseClasses.hiddenLabel}`]: {
            paddingTop: 0,
            paddingBottom: 0,
            [`& .${autocompleteClasses.input}`]: {
              paddingTop: 16,
              paddingBottom: 17
            }
          },
          [`& .${filledInputClasses.root}.${inputBaseClasses.hiddenLabel}.${inputBaseClasses.sizeSmall}`]: {
            [`& .${autocompleteClasses.input}`]: {
              paddingTop: 8,
              paddingBottom: 9
            }
          },
          [`& .${autocompleteClasses.input}`]: {
            flexGrow: 1,
            textOverflow: "ellipsis",
            opacity: 0
          },
          variants: [{
            props: {
              fullWidth: true
            },
            style: {
              width: "100%"
            }
          }, {
            props: {
              size: "small"
            },
            style: {
              [`& .${autocompleteClasses.tag}`]: {
                margin: 2,
                maxWidth: "calc(100% - 4px)"
              }
            }
          }, {
            props: {
              inputFocused: true
            },
            style: {
              [`& .${autocompleteClasses.input}`]: {
                opacity: 1
              }
            }
          }, {
            props: {
              multiple: true
            },
            style: {
              [`& .${autocompleteClasses.inputRoot}`]: {
                flexWrap: "wrap"
              }
            }
          }]
        });
        const AutocompleteEndAdornment = styled("div", {
          name: "MuiAutocomplete",
          slot: "EndAdornment",
          overridesResolver: (props, styles) => styles.endAdornment
        })({
          // We use a position absolute to support wrapping tags.
          position: "absolute",
          right: 0,
          top: "50%",
          transform: "translate(0, -50%)"
        });
        const AutocompleteClearIndicator = styled(IconButton, {
          name: "MuiAutocomplete",
          slot: "ClearIndicator",
          overridesResolver: (props, styles) => styles.clearIndicator
        })({
          marginRight: -2,
          padding: 4,
          visibility: "hidden"
        });
        const AutocompletePopupIndicator = styled(IconButton, {
          name: "MuiAutocomplete",
          slot: "PopupIndicator",
          overridesResolver: ({
            ownerState
          }, styles) => _extends$h({}, styles.popupIndicator, ownerState.popupOpen && styles.popupIndicatorOpen)
        })({
          padding: 2,
          marginRight: -2,
          variants: [{
            props: {
              popupOpen: true
            },
            style: {
              transform: "rotate(180deg)"
            }
          }]
        });
        const AutocompletePopper = styled(Popper, {
          name: "MuiAutocomplete",
          slot: "Popper",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [{
              [`& .${autocompleteClasses.option}`]: styles.option
            }, styles.popper, ownerState.disablePortal && styles.popperDisablePortal];
          }
        })(({
          theme
        }) => ({
          zIndex: (theme.vars || theme).zIndex.modal,
          variants: [{
            props: {
              disablePortal: true
            },
            style: {
              position: "absolute"
            }
          }]
        }));
        const AutocompletePaper = styled(Paper, {
          name: "MuiAutocomplete",
          slot: "Paper",
          overridesResolver: (props, styles) => styles.paper
        })(({
          theme
        }) => _extends$h({}, theme.typography.body1, {
          overflow: "auto"
        }));
        const AutocompleteLoading = styled("div", {
          name: "MuiAutocomplete",
          slot: "Loading",
          overridesResolver: (props, styles) => styles.loading
        })(({
          theme
        }) => ({
          color: (theme.vars || theme).palette.text.secondary,
          padding: "14px 16px"
        }));
        const AutocompleteNoOptions = styled("div", {
          name: "MuiAutocomplete",
          slot: "NoOptions",
          overridesResolver: (props, styles) => styles.noOptions
        })(({
          theme
        }) => ({
          color: (theme.vars || theme).palette.text.secondary,
          padding: "14px 16px"
        }));
        const AutocompleteListbox = styled("div", {
          name: "MuiAutocomplete",
          slot: "Listbox",
          overridesResolver: (props, styles) => styles.listbox
        })(({
          theme
        }) => ({
          listStyle: "none",
          margin: 0,
          padding: "8px 0",
          maxHeight: "40vh",
          overflow: "auto",
          position: "relative",
          [`& .${autocompleteClasses.option}`]: {
            minHeight: 48,
            display: "flex",
            overflow: "hidden",
            justifyContent: "flex-start",
            alignItems: "center",
            cursor: "pointer",
            paddingTop: 6,
            boxSizing: "border-box",
            outline: "0",
            WebkitTapHighlightColor: "transparent",
            paddingBottom: 6,
            paddingLeft: 16,
            paddingRight: 16,
            [theme.breakpoints.up("sm")]: {
              minHeight: "auto"
            },
            [`&.${autocompleteClasses.focused}`]: {
              backgroundColor: (theme.vars || theme).palette.action.hover,
              // Reset on touch devices, it doesn't add specificity
              "@media (hover: none)": {
                backgroundColor: "transparent"
              }
            },
            '&[aria-disabled="true"]': {
              opacity: (theme.vars || theme).palette.action.disabledOpacity,
              pointerEvents: "none"
            },
            [`&.${autocompleteClasses.focusVisible}`]: {
              backgroundColor: (theme.vars || theme).palette.action.focus
            },
            '&[aria-selected="true"]': {
              backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity),
              [`&.${autocompleteClasses.focused}`]: {
                backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                  backgroundColor: (theme.vars || theme).palette.action.selected
                }
              },
              [`&.${autocompleteClasses.focusVisible}`]: {
                backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
              }
            }
          }
        }));
        const AutocompleteGroupLabel = styled(ListSubheader, {
          name: "MuiAutocomplete",
          slot: "GroupLabel",
          overridesResolver: (props, styles) => styles.groupLabel
        })(({
          theme
        }) => ({
          backgroundColor: (theme.vars || theme).palette.background.paper,
          top: -8
        }));
        const AutocompleteGroupUl = styled("ul", {
          name: "MuiAutocomplete",
          slot: "GroupUl",
          overridesResolver: (props, styles) => styles.groupUl
        })({
          padding: 0,
          [`& .${autocompleteClasses.option}`]: {
            paddingLeft: 24
          }
        });
        const Autocomplete = /* @__PURE__ */reactExports.forwardRef(function Autocomplete2(inProps, ref) {
          var _slotProps$clearIndic, _slotProps$paper, _slotProps$popper, _slotProps$popupIndic;
          const props = useDefaultProps({
            props: inProps,
            name: "MuiAutocomplete"
          });
          const _props$autoComplete2 = props.autoComplete,
            autoComplete = _props$autoComplete2 === void 0 ? false : _props$autoComplete2,
            _props$autoHighlight2 = props.autoHighlight,
            autoHighlight = _props$autoHighlight2 === void 0 ? false : _props$autoHighlight2,
            _props$autoSelect2 = props.autoSelect,
            autoSelect = _props$autoSelect2 === void 0 ? false : _props$autoSelect2,
            _props$blurOnSelect2 = props.blurOnSelect,
            blurOnSelect = _props$blurOnSelect2 === void 0 ? false : _props$blurOnSelect2,
            ChipProps = props.ChipProps,
            className = props.className,
            _props$clearIcon = props.clearIcon,
            clearIcon = _props$clearIcon === void 0 ? _ClearIcon || (_ClearIcon = /* @__PURE__ */jsxRuntimeExports.jsx(ClearIcon, {
              fontSize: "small"
            })) : _props$clearIcon,
            _props$clearOnBlur2 = props.clearOnBlur,
            clearOnBlur = _props$clearOnBlur2 === void 0 ? !props.freeSolo : _props$clearOnBlur2,
            _props$clearOnEscape2 = props.clearOnEscape,
            clearOnEscape = _props$clearOnEscape2 === void 0 ? false : _props$clearOnEscape2,
            _props$clearText = props.clearText,
            clearText = _props$clearText === void 0 ? "Clear" : _props$clearText,
            _props$closeText = props.closeText,
            closeText = _props$closeText === void 0 ? "Close" : _props$closeText,
            _props$componentsProp = props.componentsProps,
            componentsProps = _props$componentsProp === void 0 ? {} : _props$componentsProp,
            _props$defaultValue2 = props.defaultValue,
            defaultValue = _props$defaultValue2 === void 0 ? props.multiple ? [] : null : _props$defaultValue2,
            _props$disableClearab2 = props.disableClearable,
            disableClearable = _props$disableClearab2 === void 0 ? false : _props$disableClearab2,
            _props$disableCloseOn2 = props.disableCloseOnSelect,
            disableCloseOnSelect = _props$disableCloseOn2 === void 0 ? false : _props$disableCloseOn2,
            _props$disabled = props.disabled,
            disabled = _props$disabled === void 0 ? false : _props$disabled,
            _props$disabledItemsF2 = props.disabledItemsFocusable,
            disabledItemsFocusable = _props$disabledItemsF2 === void 0 ? false : _props$disabledItemsF2,
            _props$disableListWra2 = props.disableListWrap,
            disableListWrap = _props$disableListWra2 === void 0 ? false : _props$disableListWra2,
            _props$disablePortal = props.disablePortal,
            disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal,
            _props$filterSelected2 = props.filterSelectedOptions,
            filterSelectedOptions = _props$filterSelected2 === void 0 ? false : _props$filterSelected2,
            _props$forcePopupIcon = props.forcePopupIcon,
            forcePopupIcon = _props$forcePopupIcon === void 0 ? "auto" : _props$forcePopupIcon,
            _props$freeSolo2 = props.freeSolo,
            freeSolo = _props$freeSolo2 === void 0 ? false : _props$freeSolo2,
            _props$fullWidth = props.fullWidth,
            fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
            _props$getLimitTagsTe = props.getLimitTagsText,
            getLimitTagsText = _props$getLimitTagsTe === void 0 ? more => `+${more}` : _props$getLimitTagsTe,
            getOptionLabelProp = props.getOptionLabel,
            groupBy = props.groupBy,
            _props$handleHomeEndK2 = props.handleHomeEndKeys,
            handleHomeEndKeys = _props$handleHomeEndK2 === void 0 ? !props.freeSolo : _props$handleHomeEndK2,
            _props$includeInputIn2 = props.includeInputInList,
            includeInputInList = _props$includeInputIn2 === void 0 ? false : _props$includeInputIn2,
            _props$limitTags = props.limitTags,
            limitTags = _props$limitTags === void 0 ? -1 : _props$limitTags,
            _props$ListboxCompone = props.ListboxComponent,
            ListboxComponent = _props$ListboxCompone === void 0 ? "ul" : _props$ListboxCompone,
            ListboxProps = props.ListboxProps,
            _props$loading = props.loading,
            loading = _props$loading === void 0 ? false : _props$loading,
            _props$loadingText = props.loadingText,
            loadingText = _props$loadingText === void 0 ? "Loading…" : _props$loadingText,
            _props$multiple2 = props.multiple,
            multiple = _props$multiple2 === void 0 ? false : _props$multiple2,
            _props$noOptionsText = props.noOptionsText,
            noOptionsText = _props$noOptionsText === void 0 ? "No options" : _props$noOptionsText,
            _props$openOnFocus2 = props.openOnFocus,
            openOnFocus = _props$openOnFocus2 === void 0 ? false : _props$openOnFocus2,
            _props$openText = props.openText,
            openText = _props$openText === void 0 ? "Open" : _props$openText,
            _props$PaperComponent = props.PaperComponent,
            PaperComponent = _props$PaperComponent === void 0 ? Paper : _props$PaperComponent,
            _props$PopperComponen = props.PopperComponent,
            PopperComponent = _props$PopperComponen === void 0 ? Popper : _props$PopperComponen,
            _props$popupIcon = props.popupIcon,
            popupIcon = _props$popupIcon === void 0 ? _ArrowDropDownIcon || (_ArrowDropDownIcon = /* @__PURE__ */jsxRuntimeExports.jsx(ArrowDropDownIcon, {})) : _props$popupIcon,
            _props$readOnly2 = props.readOnly,
            readOnly = _props$readOnly2 === void 0 ? false : _props$readOnly2,
            renderGroupProp = props.renderGroup,
            renderInput = props.renderInput,
            renderOptionProp = props.renderOption,
            renderTags = props.renderTags,
            _props$selectOnFocus2 = props.selectOnFocus,
            selectOnFocus = _props$selectOnFocus2 === void 0 ? !props.freeSolo : _props$selectOnFocus2,
            _props$size = props.size,
            size = _props$size === void 0 ? "medium" : _props$size,
            _props$slotProps = props.slotProps,
            slotProps = _props$slotProps === void 0 ? {} : _props$slotProps,
            other = _objectWithoutPropertiesLoose(props, _excluded$j);
          const _useAutocomplete = useAutocomplete(_extends$h({}, props, {
              componentName: "Autocomplete"
            })),
            getRootProps = _useAutocomplete.getRootProps,
            getInputProps = _useAutocomplete.getInputProps,
            getInputLabelProps = _useAutocomplete.getInputLabelProps,
            getPopupIndicatorProps = _useAutocomplete.getPopupIndicatorProps,
            getClearProps = _useAutocomplete.getClearProps,
            getTagProps = _useAutocomplete.getTagProps,
            getListboxProps = _useAutocomplete.getListboxProps,
            getOptionProps = _useAutocomplete.getOptionProps,
            value = _useAutocomplete.value,
            dirty = _useAutocomplete.dirty,
            expanded = _useAutocomplete.expanded,
            id = _useAutocomplete.id,
            popupOpen = _useAutocomplete.popupOpen,
            focused = _useAutocomplete.focused,
            focusedTag = _useAutocomplete.focusedTag,
            anchorEl = _useAutocomplete.anchorEl,
            setAnchorEl = _useAutocomplete.setAnchorEl,
            inputValue = _useAutocomplete.inputValue,
            groupedOptions = _useAutocomplete.groupedOptions;
          const hasClearIcon = !disableClearable && !disabled && dirty && !readOnly;
          const hasPopupIcon = (!freeSolo || forcePopupIcon === true) && forcePopupIcon !== false;
          const _getInputProps = getInputProps(),
            handleInputMouseDown = _getInputProps.onMouseDown;
          const _ref28 = ListboxProps != null ? ListboxProps : {},
            externalListboxRef = _ref28.ref;
          const _getListboxProps = getListboxProps(),
            listboxRef = _getListboxProps.ref,
            otherListboxProps = _objectWithoutPropertiesLoose(_getListboxProps, _excluded2$2);
          const combinedListboxRef = useForkRef(listboxRef, externalListboxRef);
          const defaultGetOptionLabel = option => {
            var _option$label;
            return (_option$label = option.label) != null ? _option$label : option;
          };
          const getOptionLabel = getOptionLabelProp || defaultGetOptionLabel;
          const ownerState = _extends$h({}, props, {
            disablePortal,
            expanded,
            focused,
            fullWidth,
            getOptionLabel,
            hasClearIcon,
            hasPopupIcon,
            inputFocused: focusedTag === -1,
            popupOpen,
            size
          });
          const classes = useUtilityClasses$8(ownerState);
          let startAdornment;
          if (multiple && value.length > 0) {
            const getCustomizedTagProps = params => _extends$h({
              className: classes.tag,
              disabled
            }, getTagProps(params));
            if (renderTags) {
              startAdornment = renderTags(value, getCustomizedTagProps, ownerState);
            } else {
              startAdornment = value.map((option, index) => {
                const _getCustomizedTagProp = getCustomizedTagProps({
                    index
                  }),
                  key = _getCustomizedTagProp.key,
                  customTagProps = _objectWithoutPropertiesLoose(_getCustomizedTagProp, _excluded3$1);
                return /* @__PURE__ */jsxRuntimeExports.jsx(Chip, _extends$h({
                  label: getOptionLabel(option),
                  size
                }, customTagProps, ChipProps), key);
              });
            }
          }
          if (limitTags > -1 && Array.isArray(startAdornment)) {
            const more = startAdornment.length - limitTags;
            if (!focused && more > 0) {
              startAdornment = startAdornment.splice(0, limitTags);
              startAdornment.push(/* @__PURE__ */jsxRuntimeExports.jsx("span", {
                className: classes.tag,
                children: getLimitTagsText(more)
              }, startAdornment.length));
            }
          }
          const defaultRenderGroup = params => /* @__PURE__ */jsxRuntimeExports.jsxs("li", {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(AutocompleteGroupLabel, {
              className: classes.groupLabel,
              ownerState,
              component: "div",
              children: params.group
            }), /* @__PURE__ */jsxRuntimeExports.jsx(AutocompleteGroupUl, {
              className: classes.groupUl,
              ownerState,
              children: params.children
            })]
          }, params.key);
          const renderGroup = renderGroupProp || defaultRenderGroup;
          const defaultRenderOption = (props2, option) => {
            const key = props2.key,
              otherProps = _objectWithoutPropertiesLoose(props2, _excluded4);
            return /* @__PURE__ */jsxRuntimeExports.jsx("li", _extends$h({}, otherProps, {
              children: getOptionLabel(option)
            }), key);
          };
          const renderOption = renderOptionProp || defaultRenderOption;
          const renderListOption = (option, index) => {
            const optionProps = getOptionProps({
              option,
              index
            });
            return renderOption(_extends$h({}, optionProps, {
              className: classes.option
            }), option, {
              selected: optionProps["aria-selected"],
              index,
              inputValue
            }, ownerState);
          };
          const clearIndicatorSlotProps = (_slotProps$clearIndic = slotProps.clearIndicator) != null ? _slotProps$clearIndic : componentsProps.clearIndicator;
          const paperSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : componentsProps.paper;
          const popperSlotProps = (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper;
          const popupIndicatorSlotProps = (_slotProps$popupIndic = slotProps.popupIndicator) != null ? _slotProps$popupIndic : componentsProps.popupIndicator;
          const renderAutocompletePopperChildren = children => /* @__PURE__ */jsxRuntimeExports.jsx(AutocompletePopper, _extends$h({
            as: PopperComponent,
            disablePortal,
            style: {
              width: anchorEl ? anchorEl.clientWidth : null
            },
            ownerState,
            role: "presentation",
            anchorEl,
            open: popupOpen
          }, popperSlotProps, {
            className: clsx(classes.popper, popperSlotProps == null ? void 0 : popperSlotProps.className),
            children: /* @__PURE__ */jsxRuntimeExports.jsx(AutocompletePaper, _extends$h({
              ownerState,
              as: PaperComponent
            }, paperSlotProps, {
              className: clsx(classes.paper, paperSlotProps == null ? void 0 : paperSlotProps.className),
              children
            }))
          }));
          let autocompletePopper = null;
          if (groupedOptions.length > 0) {
            autocompletePopper = renderAutocompletePopperChildren(/* @__PURE__ */jsxRuntimeExports.jsx(AutocompleteListbox, _extends$h({
              as: ListboxComponent,
              className: classes.listbox,
              ownerState
            }, otherListboxProps, ListboxProps, {
              ref: combinedListboxRef,
              children: groupedOptions.map((option, index) => {
                if (groupBy) {
                  return renderGroup({
                    key: option.key,
                    group: option.group,
                    children: option.options.map((option2, index2) => renderListOption(option2, option.index + index2))
                  });
                }
                return renderListOption(option, index);
              })
            })));
          } else if (loading && groupedOptions.length === 0) {
            autocompletePopper = renderAutocompletePopperChildren(/* @__PURE__ */jsxRuntimeExports.jsx(AutocompleteLoading, {
              className: classes.loading,
              ownerState,
              children: loadingText
            }));
          } else if (groupedOptions.length === 0 && !freeSolo && !loading) {
            autocompletePopper = renderAutocompletePopperChildren(/* @__PURE__ */jsxRuntimeExports.jsx(AutocompleteNoOptions, {
              className: classes.noOptions,
              ownerState,
              role: "presentation",
              onMouseDown: event => {
                event.preventDefault();
              },
              children: noOptionsText
            }));
          }
          return /* @__PURE__ */jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(AutocompleteRoot, _extends$h({
              ref,
              className: clsx(classes.root, className),
              ownerState
            }, getRootProps(other), {
              children: renderInput({
                id,
                disabled,
                fullWidth: true,
                size: size === "small" ? "small" : void 0,
                InputLabelProps: getInputLabelProps(),
                InputProps: _extends$h({
                  ref: setAnchorEl,
                  className: classes.inputRoot,
                  startAdornment,
                  onClick: event => {
                    if (event.target === event.currentTarget) {
                      handleInputMouseDown(event);
                    }
                  }
                }, (hasClearIcon || hasPopupIcon) && {
                  endAdornment: /* @__PURE__ */jsxRuntimeExports.jsxs(AutocompleteEndAdornment, {
                    className: classes.endAdornment,
                    ownerState,
                    children: [hasClearIcon ? /* @__PURE__ */jsxRuntimeExports.jsx(AutocompleteClearIndicator, _extends$h({}, getClearProps(), {
                      "aria-label": clearText,
                      title: clearText,
                      ownerState
                    }, clearIndicatorSlotProps, {
                      className: clsx(classes.clearIndicator, clearIndicatorSlotProps == null ? void 0 : clearIndicatorSlotProps.className),
                      children: clearIcon
                    })) : null, hasPopupIcon ? /* @__PURE__ */jsxRuntimeExports.jsx(AutocompletePopupIndicator, _extends$h({}, getPopupIndicatorProps(), {
                      disabled,
                      "aria-label": popupOpen ? closeText : openText,
                      title: popupOpen ? closeText : openText,
                      ownerState
                    }, popupIndicatorSlotProps, {
                      className: clsx(classes.popupIndicator, popupIndicatorSlotProps == null ? void 0 : popupIndicatorSlotProps.className),
                      children: popupIcon
                    })) : null]
                  })
                }),
                inputProps: _extends$h({
                  className: classes.input,
                  disabled,
                  readOnly
                }, getInputProps())
              })
            })), anchorEl ? autocompletePopper : null]
          });
        });
        const _excluded$i = ["children", "className", "color", "component", "disabled", "disableElevation", "disableFocusRipple", "disableRipple", "fullWidth", "orientation", "size", "variant"];
        const overridesResolver = (props, styles) => {
          const ownerState = props.ownerState;
          return [{
            [`& .${buttonGroupClasses.grouped}`]: styles.grouped
          }, {
            [`& .${buttonGroupClasses.grouped}`]: styles[`grouped${capitalize$1(ownerState.orientation)}`]
          }, {
            [`& .${buttonGroupClasses.grouped}`]: styles[`grouped${capitalize$1(ownerState.variant)}`]
          }, {
            [`& .${buttonGroupClasses.grouped}`]: styles[`grouped${capitalize$1(ownerState.variant)}${capitalize$1(ownerState.orientation)}`]
          }, {
            [`& .${buttonGroupClasses.grouped}`]: styles[`grouped${capitalize$1(ownerState.variant)}${capitalize$1(ownerState.color)}`]
          }, {
            [`& .${buttonGroupClasses.firstButton}`]: styles.firstButton
          }, {
            [`& .${buttonGroupClasses.lastButton}`]: styles.lastButton
          }, {
            [`& .${buttonGroupClasses.middleButton}`]: styles.middleButton
          }, styles.root, styles[ownerState.variant], ownerState.disableElevation === true && styles.disableElevation, ownerState.fullWidth && styles.fullWidth, ownerState.orientation === "vertical" && styles.vertical];
        };
        const useUtilityClasses$7 = ownerState => {
          const classes = ownerState.classes,
            color = ownerState.color,
            disabled = ownerState.disabled,
            disableElevation = ownerState.disableElevation,
            fullWidth = ownerState.fullWidth,
            orientation = ownerState.orientation,
            variant = ownerState.variant;
          const slots = {
            root: ["root", variant, orientation === "vertical" && "vertical", fullWidth && "fullWidth", disableElevation && "disableElevation"],
            grouped: ["grouped", `grouped${capitalize$1(orientation)}`, `grouped${capitalize$1(variant)}`, `grouped${capitalize$1(variant)}${capitalize$1(orientation)}`, `grouped${capitalize$1(variant)}${capitalize$1(color)}`, disabled && "disabled"],
            firstButton: ["firstButton"],
            lastButton: ["lastButton"],
            middleButton: ["middleButton"]
          };
          return composeClasses(slots, getButtonGroupUtilityClass, classes);
        };
        const ButtonGroupRoot = styled("div", {
          name: "MuiButtonGroup",
          slot: "Root",
          overridesResolver
        })(({
          theme,
          ownerState
        }) => _extends$h({
          display: "inline-flex",
          borderRadius: (theme.vars || theme).shape.borderRadius
        }, ownerState.variant === "contained" && {
          boxShadow: (theme.vars || theme).shadows[2]
        }, ownerState.disableElevation && {
          boxShadow: "none"
        }, ownerState.fullWidth && {
          width: "100%"
        }, ownerState.orientation === "vertical" && {
          flexDirection: "column"
        }, {
          [`& .${buttonGroupClasses.grouped}`]: _extends$h({
            minWidth: 40,
            "&:hover": _extends$h({}, ownerState.variant === "contained" && {
              boxShadow: "none"
            })
          }, ownerState.variant === "contained" && {
            boxShadow: "none"
          }),
          [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: _extends$h({}, ownerState.orientation === "horizontal" && {
            borderTopRightRadius: 0,
            borderBottomRightRadius: 0
          }, ownerState.orientation === "vertical" && {
            borderBottomRightRadius: 0,
            borderBottomLeftRadius: 0
          }, ownerState.variant === "text" && ownerState.orientation === "horizontal" && {
            borderRight: theme.vars ? `1px solid rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : `1px solid ${theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`,
            [`&.${buttonGroupClasses.disabled}`]: {
              borderRight: `1px solid ${(theme.vars || theme).palette.action.disabled}`
            }
          }, ownerState.variant === "text" && ownerState.orientation === "vertical" && {
            borderBottom: theme.vars ? `1px solid rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : `1px solid ${theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`,
            [`&.${buttonGroupClasses.disabled}`]: {
              borderBottom: `1px solid ${(theme.vars || theme).palette.action.disabled}`
            }
          }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
            borderColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : alpha_1(theme.palette[ownerState.color].main, 0.5)
          }, ownerState.variant === "outlined" && ownerState.orientation === "horizontal" && {
            borderRightColor: "transparent"
          }, ownerState.variant === "outlined" && ownerState.orientation === "vertical" && {
            borderBottomColor: "transparent"
          }, ownerState.variant === "contained" && ownerState.orientation === "horizontal" && {
            borderRight: `1px solid ${(theme.vars || theme).palette.grey[400]}`,
            [`&.${buttonGroupClasses.disabled}`]: {
              borderRight: `1px solid ${(theme.vars || theme).palette.action.disabled}`
            }
          }, ownerState.variant === "contained" && ownerState.orientation === "vertical" && {
            borderBottom: `1px solid ${(theme.vars || theme).palette.grey[400]}`,
            [`&.${buttonGroupClasses.disabled}`]: {
              borderBottom: `1px solid ${(theme.vars || theme).palette.action.disabled}`
            }
          }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
            borderColor: (theme.vars || theme).palette[ownerState.color].dark
          }, {
            "&:hover": _extends$h({}, ownerState.variant === "outlined" && ownerState.orientation === "horizontal" && {
              borderRightColor: "currentColor"
            }, ownerState.variant === "outlined" && ownerState.orientation === "vertical" && {
              borderBottomColor: "currentColor"
            })
          }),
          [`& .${buttonGroupClasses.lastButton},& .${buttonGroupClasses.middleButton}`]: _extends$h({}, ownerState.orientation === "horizontal" && {
            borderTopLeftRadius: 0,
            borderBottomLeftRadius: 0
          }, ownerState.orientation === "vertical" && {
            borderTopRightRadius: 0,
            borderTopLeftRadius: 0
          }, ownerState.variant === "outlined" && ownerState.orientation === "horizontal" && {
            marginLeft: -1
          }, ownerState.variant === "outlined" && ownerState.orientation === "vertical" && {
            marginTop: -1
          })
        }));
        const ButtonGroup = /* @__PURE__ */reactExports.forwardRef(function ButtonGroup2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiButtonGroup"
          });
          const children = props.children,
            className = props.className,
            _props$color2 = props.color,
            color = _props$color2 === void 0 ? "primary" : _props$color2,
            _props$component2 = props.component,
            component = _props$component2 === void 0 ? "div" : _props$component2,
            _props$disabled2 = props.disabled,
            disabled = _props$disabled2 === void 0 ? false : _props$disabled2,
            _props$disableElevati = props.disableElevation,
            disableElevation = _props$disableElevati === void 0 ? false : _props$disableElevati,
            _props$disableFocusRi = props.disableFocusRipple,
            disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi,
            _props$disableRipple = props.disableRipple,
            disableRipple = _props$disableRipple === void 0 ? false : _props$disableRipple,
            _props$fullWidth2 = props.fullWidth,
            fullWidth = _props$fullWidth2 === void 0 ? false : _props$fullWidth2,
            _props$orientation = props.orientation,
            orientation = _props$orientation === void 0 ? "horizontal" : _props$orientation,
            _props$size2 = props.size,
            size = _props$size2 === void 0 ? "medium" : _props$size2,
            _props$variant = props.variant,
            variant = _props$variant === void 0 ? "outlined" : _props$variant,
            other = _objectWithoutPropertiesLoose(props, _excluded$i);
          const ownerState = _extends$h({}, props, {
            color,
            component,
            disabled,
            disableElevation,
            disableFocusRipple,
            disableRipple,
            fullWidth,
            orientation,
            size,
            variant
          });
          const classes = useUtilityClasses$7(ownerState);
          const context = reactExports.useMemo(() => ({
            className: classes.grouped,
            color,
            disabled,
            disableElevation,
            disableFocusRipple,
            disableRipple,
            fullWidth,
            size,
            variant
          }), [color, disabled, disableElevation, disableFocusRipple, disableRipple, fullWidth, size, variant, classes.grouped]);
          const validChildren = getValidReactChildren(children);
          const childrenCount = validChildren.length;
          const getButtonPositionClassName = index => {
            const isFirstButton = index === 0;
            const isLastButton = index === childrenCount - 1;
            if (isFirstButton && isLastButton) {
              return "";
            }
            if (isFirstButton) {
              return classes.firstButton;
            }
            if (isLastButton) {
              return classes.lastButton;
            }
            return classes.middleButton;
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(ButtonGroupRoot, _extends$h({
            as: component,
            role: "group",
            className: clsx(classes.root, className),
            ref,
            ownerState
          }, other, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx(ButtonGroupContext.Provider, {
              value: context,
              children: validChildren.map((child, index) => {
                return /* @__PURE__ */jsxRuntimeExports.jsx(ButtonGroupButtonContext.Provider, {
                  value: getButtonPositionClassName(index),
                  children: child
                }, index);
              })
            })
          }));
        });
        function getDialogContentTextUtilityClass(slot) {
          return generateUtilityClass('MuiDialogContentText', slot);
        }
        generateUtilityClasses('MuiDialogContentText', ['root']);
        const _excluded$h = ["children", "className"];
        const useUtilityClasses$6 = ownerState => {
          const classes = ownerState.classes;
          const slots = {
            root: ["root"]
          };
          const composedClasses = composeClasses(slots, getDialogContentTextUtilityClass, classes);
          return _extends$h({}, classes, composedClasses);
        };
        const DialogContentTextRoot = styled(Typography, {
          shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === "classes",
          name: "MuiDialogContentText",
          slot: "Root",
          overridesResolver: (props, styles) => styles.root
        })({});
        const DialogContentText = /* @__PURE__ */reactExports.forwardRef(function DialogContentText2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiDialogContentText"
          });
          const className = props.className,
            ownerState = _objectWithoutPropertiesLoose(props, _excluded$h);
          const classes = useUtilityClasses$6(ownerState);
          return /* @__PURE__ */jsxRuntimeExports.jsx(DialogContentTextRoot, _extends$h({
            component: "p",
            variant: "body1",
            color: "text.secondary",
            ref,
            ownerState,
            className: clsx(classes.root, className)
          }, props, {
            classes
          }));
        });
        const _excluded$g = ["children", "className", "color", "component", "disabled", "disableFocusRipple", "focusVisibleClassName", "size", "variant"];
        const useUtilityClasses$5 = ownerState => {
          const color = ownerState.color,
            variant = ownerState.variant,
            classes = ownerState.classes,
            size = ownerState.size;
          const slots = {
            root: ["root", variant, `size${capitalize$1(size)}`, color === "inherit" ? "colorInherit" : color]
          };
          const composedClasses = composeClasses(slots, getFabUtilityClass, classes);
          return _extends$h({}, classes, composedClasses);
        };
        const FabRoot = styled(ButtonBase, {
          name: "MuiFab",
          slot: "Root",
          shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === "classes",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.root, styles[ownerState.variant], styles[`size${capitalize$1(ownerState.size)}`], ownerState.color === "inherit" && styles.colorInherit, styles[capitalize$1(ownerState.size)], styles[ownerState.color]];
          }
        })(({
          theme,
          ownerState
        }) => {
          var _theme$palette$getCon, _theme$palette;
          return _extends$h({}, theme.typography.button, {
            minHeight: 36,
            transition: theme.transitions.create(["background-color", "box-shadow", "border-color"], {
              duration: theme.transitions.duration.short
            }),
            borderRadius: "50%",
            padding: 0,
            minWidth: 0,
            width: 56,
            height: 56,
            zIndex: (theme.vars || theme).zIndex.fab,
            boxShadow: (theme.vars || theme).shadows[6],
            "&:active": {
              boxShadow: (theme.vars || theme).shadows[12]
            },
            color: theme.vars ? theme.vars.palette.text.primary : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
            backgroundColor: (theme.vars || theme).palette.grey[300],
            "&:hover": {
              backgroundColor: (theme.vars || theme).palette.grey.A100,
              // Reset on touch devices, it doesn't add specificity
              "@media (hover: none)": {
                backgroundColor: (theme.vars || theme).palette.grey[300]
              },
              textDecoration: "none"
            },
            [`&.${fabClasses.focusVisible}`]: {
              boxShadow: (theme.vars || theme).shadows[6]
            }
          }, ownerState.size === "small" && {
            width: 40,
            height: 40
          }, ownerState.size === "medium" && {
            width: 48,
            height: 48
          }, ownerState.variant === "extended" && {
            borderRadius: 48 / 2,
            padding: "0 16px",
            width: "auto",
            minHeight: "auto",
            minWidth: 48,
            height: 48
          }, ownerState.variant === "extended" && ownerState.size === "small" && {
            width: "auto",
            padding: "0 8px",
            borderRadius: 34 / 2,
            minWidth: 34,
            height: 34
          }, ownerState.variant === "extended" && ownerState.size === "medium" && {
            width: "auto",
            padding: "0 16px",
            borderRadius: 40 / 2,
            minWidth: 40,
            height: 40
          }, ownerState.color === "inherit" && {
            color: "inherit"
          });
        }, ({
          theme,
          ownerState
        }) => _extends$h({}, ownerState.color !== "inherit" && ownerState.color !== "default" && (theme.vars || theme).palette[ownerState.color] != null && {
          color: (theme.vars || theme).palette[ownerState.color].contrastText,
          backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
          "&:hover": {
            backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              backgroundColor: (theme.vars || theme).palette[ownerState.color].main
            }
          }
        }), ({
          theme
        }) => ({
          [`&.${fabClasses.disabled}`]: {
            color: (theme.vars || theme).palette.action.disabled,
            boxShadow: (theme.vars || theme).shadows[0],
            backgroundColor: (theme.vars || theme).palette.action.disabledBackground
          }
        }));
        const Fab = /* @__PURE__ */reactExports.forwardRef(function Fab2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiFab"
          });
          const children = props.children,
            className = props.className,
            _props$color3 = props.color,
            color = _props$color3 === void 0 ? "default" : _props$color3,
            _props$component3 = props.component,
            component = _props$component3 === void 0 ? "button" : _props$component3,
            _props$disabled3 = props.disabled,
            disabled = _props$disabled3 === void 0 ? false : _props$disabled3,
            _props$disableFocusRi2 = props.disableFocusRipple,
            disableFocusRipple = _props$disableFocusRi2 === void 0 ? false : _props$disableFocusRi2,
            focusVisibleClassName = props.focusVisibleClassName,
            _props$size3 = props.size,
            size = _props$size3 === void 0 ? "large" : _props$size3,
            _props$variant2 = props.variant,
            variant = _props$variant2 === void 0 ? "circular" : _props$variant2,
            other = _objectWithoutPropertiesLoose(props, _excluded$g);
          const ownerState = _extends$h({}, props, {
            color,
            component,
            disabled,
            disableFocusRipple,
            size,
            variant
          });
          const classes = useUtilityClasses$5(ownerState);
          return /* @__PURE__ */jsxRuntimeExports.jsx(FabRoot, _extends$h({
            className: clsx(classes.root, className),
            component,
            disabled,
            focusRipple: !disableFocusRipple,
            focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
            ownerState,
            ref
          }, other, {
            classes,
            children
          }));
        });
        function getIconUtilityClass(slot) {
          return generateUtilityClass('MuiIcon', slot);
        }
        generateUtilityClasses('MuiIcon', ['root', 'colorPrimary', 'colorSecondary', 'colorAction', 'colorError', 'colorDisabled', 'fontSizeInherit', 'fontSizeSmall', 'fontSizeMedium', 'fontSizeLarge']);
        const _excluded$f = ["baseClassName", "className", "color", "component", "fontSize"];
        const useUtilityClasses$4 = ownerState => {
          const color = ownerState.color,
            fontSize = ownerState.fontSize,
            classes = ownerState.classes;
          const slots = {
            root: ["root", color !== "inherit" && `color${capitalize$1(color)}`, `fontSize${capitalize$1(fontSize)}`]
          };
          return composeClasses(slots, getIconUtilityClass, classes);
        };
        const IconRoot = styled("span", {
          name: "MuiIcon",
          slot: "Root",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.root, ownerState.color !== "inherit" && styles[`color${capitalize$1(ownerState.color)}`], styles[`fontSize${capitalize$1(ownerState.fontSize)}`]];
          }
        })(({
          theme,
          ownerState
        }) => ({
          userSelect: "none",
          width: "1em",
          height: "1em",
          // Chrome fix for https://bugs.chromium.org/p/chromium/issues/detail?id=820541
          // To remove at some point.
          overflow: "hidden",
          display: "inline-block",
          // allow overflow hidden to take action
          textAlign: "center",
          // support non-square icon
          flexShrink: 0,
          fontSize: {
            inherit: "inherit",
            small: theme.typography.pxToRem(20),
            medium: theme.typography.pxToRem(24),
            large: theme.typography.pxToRem(36)
          }[ownerState.fontSize],
          // TODO v5 deprecate, v6 remove for sx
          color: {
            primary: (theme.vars || theme).palette.primary.main,
            secondary: (theme.vars || theme).palette.secondary.main,
            info: (theme.vars || theme).palette.info.main,
            success: (theme.vars || theme).palette.success.main,
            warning: (theme.vars || theme).palette.warning.main,
            action: (theme.vars || theme).palette.action.active,
            error: (theme.vars || theme).palette.error.main,
            disabled: (theme.vars || theme).palette.action.disabled,
            inherit: void 0
          }[ownerState.color]
        }));
        const Icon = /* @__PURE__ */reactExports.forwardRef(function Icon2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiIcon"
          });
          const _props$baseClassName = props.baseClassName,
            baseClassName = _props$baseClassName === void 0 ? "material-icons" : _props$baseClassName,
            className = props.className,
            _props$color4 = props.color,
            color = _props$color4 === void 0 ? "inherit" : _props$color4,
            _props$component4 = props.component,
            Component = _props$component4 === void 0 ? "span" : _props$component4,
            _props$fontSize = props.fontSize,
            fontSize = _props$fontSize === void 0 ? "medium" : _props$fontSize,
            other = _objectWithoutPropertiesLoose(props, _excluded$f);
          const ownerState = _extends$h({}, props, {
            baseClassName,
            color,
            component: Component,
            fontSize
          });
          const classes = useUtilityClasses$4(ownerState);
          return /* @__PURE__ */jsxRuntimeExports.jsx(IconRoot, _extends$h({
            as: Component,
            className: clsx(baseClassName,
            // Prevent the translation of the text content.
            // The font relies on the exact text content to render the icon.
            "notranslate", classes.root, className),
            ownerState,
            "aria-hidden": true,
            ref
          }, other));
        });
        Icon.muiName = "Icon";
        const _excluded$e = ["children", "className", "disableTypography", "inset", "primary", "primaryTypographyProps", "secondary", "secondaryTypographyProps"];
        const useUtilityClasses$3 = ownerState => {
          const classes = ownerState.classes,
            inset = ownerState.inset,
            primary = ownerState.primary,
            secondary = ownerState.secondary,
            dense = ownerState.dense;
          const slots = {
            root: ["root", inset && "inset", dense && "dense", primary && secondary && "multiline"],
            primary: ["primary"],
            secondary: ["secondary"]
          };
          return composeClasses(slots, getListItemTextUtilityClass, classes);
        };
        const ListItemTextRoot = styled("div", {
          name: "MuiListItemText",
          slot: "Root",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [{
              [`& .${listItemTextClasses.primary}`]: styles.primary
            }, {
              [`& .${listItemTextClasses.secondary}`]: styles.secondary
            }, styles.root, ownerState.inset && styles.inset, ownerState.primary && ownerState.secondary && styles.multiline, ownerState.dense && styles.dense];
          }
        })(({
          ownerState
        }) => _extends$h({
          flex: "1 1 auto",
          minWidth: 0,
          marginTop: 4,
          marginBottom: 4
        }, ownerState.primary && ownerState.secondary && {
          marginTop: 6,
          marginBottom: 6
        }, ownerState.inset && {
          paddingLeft: 56
        }));
        const ListItemText = /* @__PURE__ */reactExports.forwardRef(function ListItemText2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiListItemText"
          });
          const children = props.children,
            className = props.className,
            _props$disableTypogra = props.disableTypography,
            disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra,
            _props$inset2 = props.inset,
            inset = _props$inset2 === void 0 ? false : _props$inset2,
            primaryProp = props.primary,
            primaryTypographyProps = props.primaryTypographyProps,
            secondaryProp = props.secondary,
            secondaryTypographyProps = props.secondaryTypographyProps,
            other = _objectWithoutPropertiesLoose(props, _excluded$e);
          const _reactExports$useCont = reactExports.useContext(ListContext),
            dense = _reactExports$useCont.dense;
          let primary = primaryProp != null ? primaryProp : children;
          let secondary = secondaryProp;
          const ownerState = _extends$h({}, props, {
            disableTypography,
            inset,
            primary: !!primary,
            secondary: !!secondary,
            dense
          });
          const classes = useUtilityClasses$3(ownerState);
          if (primary != null && primary.type !== Typography && !disableTypography) {
            primary = /* @__PURE__ */jsxRuntimeExports.jsx(Typography, _extends$h({
              variant: dense ? "body2" : "body1",
              className: classes.primary,
              component: primaryTypographyProps != null && primaryTypographyProps.variant ? void 0 : "span",
              display: "block"
            }, primaryTypographyProps, {
              children: primary
            }));
          }
          if (secondary != null && secondary.type !== Typography && !disableTypography) {
            secondary = /* @__PURE__ */jsxRuntimeExports.jsx(Typography, _extends$h({
              variant: "body2",
              className: classes.secondary,
              color: "text.secondary",
              display: "block"
            }, secondaryTypographyProps, {
              children: secondary
            }));
          }
          return /* @__PURE__ */jsxRuntimeExports.jsxs(ListItemTextRoot, _extends$h({
            className: clsx(classes.root, className),
            ownerState,
            ref
          }, other, {
            children: [primary, secondary]
          }));
        });
        function areArraysEqual(array1, array2, itemComparer = (a, b) => a === b) {
          return array1.length === array2.length && array1.every((value, index) => itemComparer(value, array2[index]));
        }
        const INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;
        function asc(a, b) {
          return a - b;
        }
        function findClosest(values, currentValue) {
          var _values$reduce;
          const _ref29 = (_values$reduce = values.reduce((acc, value, index) => {
              const distance = Math.abs(currentValue - value);
              if (acc === null || distance < acc.distance || distance === acc.distance) {
                return {
                  distance,
                  index
                };
              }
              return acc;
            }, null)) != null ? _values$reduce : {},
            closestIndex = _ref29.index;
          return closestIndex;
        }
        function trackFinger(event, touchId) {
          // The event is TouchEvent
          if (touchId.current !== undefined && event.changedTouches) {
            const touchEvent = event;
            for (let i = 0; i < touchEvent.changedTouches.length; i += 1) {
              const touch = touchEvent.changedTouches[i];
              if (touch.identifier === touchId.current) {
                return {
                  x: touch.clientX,
                  y: touch.clientY
                };
              }
            }
            return false;
          }

          // The event is MouseEvent
          return {
            x: event.clientX,
            y: event.clientY
          };
        }
        function valueToPercent(value, min, max) {
          return (value - min) * 100 / (max - min);
        }
        function percentToValue(percent, min, max) {
          return (max - min) * percent + min;
        }
        function getDecimalPrecision(num) {
          // This handles the case when num is very small (0.00000001), js will turn this into 1e-8.
          // When num is bigger than 1 or less than -1 it won't get converted to this notation so it's fine.
          if (Math.abs(num) < 1) {
            const parts = num.toExponential().split('e-');
            const matissaDecimalPart = parts[0].split('.')[1];
            return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
          }
          const decimalPart = num.toString().split('.')[1];
          return decimalPart ? decimalPart.length : 0;
        }
        function roundValueToStep(value, step, min) {
          const nearest = Math.round((value - min) / step) * step + min;
          return Number(nearest.toFixed(getDecimalPrecision(step)));
        }
        function setValueIndex({
          values,
          newValue,
          index
        }) {
          const output = values.slice();
          output[index] = newValue;
          return output.sort(asc);
        }
        function focusThumb({
          sliderRef,
          activeIndex,
          setActive
        }) {
          var _sliderRef$current, _doc$activeElement;
          const doc = ownerDocument(sliderRef.current);
          if (!((_sliderRef$current = sliderRef.current) != null && _sliderRef$current.contains(doc.activeElement)) || Number(doc == null || (_doc$activeElement = doc.activeElement) == null ? void 0 : _doc$activeElement.getAttribute('data-index')) !== activeIndex) {
            var _sliderRef$current2;
            (_sliderRef$current2 = sliderRef.current) == null || _sliderRef$current2.querySelector(`[type="range"][data-index="${activeIndex}"]`).focus();
          }
          if (setActive) {
            setActive(activeIndex);
          }
        }
        function areValuesEqual(newValue, oldValue) {
          if (typeof newValue === 'number' && typeof oldValue === 'number') {
            return newValue === oldValue;
          }
          if (typeof newValue === 'object' && typeof oldValue === 'object') {
            return areArraysEqual(newValue, oldValue);
          }
          return false;
        }
        const axisProps = {
          horizontal: {
            offset: percent => ({
              left: `${percent}%`
            }),
            leap: percent => ({
              width: `${percent}%`
            })
          },
          'horizontal-reverse': {
            offset: percent => ({
              right: `${percent}%`
            }),
            leap: percent => ({
              width: `${percent}%`
            })
          },
          vertical: {
            offset: percent => ({
              bottom: `${percent}%`
            }),
            leap: percent => ({
              height: `${percent}%`
            })
          }
        };
        const Identity$1 = x => x;

        // TODO: remove support for Safari < 13.
        // https://caniuse.com/#search=touch-action
        //
        // Safari, on iOS, supports touch action since v13.
        // Over 80% of the iOS phones are compatible
        // in August 2020.
        // Utilizing the CSS.supports method to check if touch-action is supported.
        // Since CSS.supports is supported on all but Edge@12 and IE and touch-action
        // is supported on both Edge@12 and IE if CSS.supports is not available that means that
        // touch-action will be supported
        let cachedSupportsTouchActionNone;
        function doesSupportTouchActionNone() {
          if (cachedSupportsTouchActionNone === undefined) {
            if (typeof CSS !== 'undefined' && typeof CSS.supports === 'function') {
              cachedSupportsTouchActionNone = CSS.supports('touch-action', 'none');
            } else {
              cachedSupportsTouchActionNone = true;
            }
          }
          return cachedSupportsTouchActionNone;
        }
        /**
         *
         * Demos:
         *
         * - [Slider](https://mui.com/base-ui/react-slider/#hook)
         *
         * API:
         *
         * - [useSlider API](https://mui.com/base-ui/react-slider/hooks-api/#use-slider)
         */
        function useSlider(parameters) {
          const ariaLabelledby = parameters['aria-labelledby'],
            defaultValue = parameters.defaultValue,
            _parameters$disabled = parameters.disabled,
            disabled = _parameters$disabled === void 0 ? false : _parameters$disabled,
            _parameters$disableSw = parameters.disableSwap,
            disableSwap = _parameters$disableSw === void 0 ? false : _parameters$disableSw,
            _parameters$isRtl = parameters.isRtl,
            isRtl = _parameters$isRtl === void 0 ? false : _parameters$isRtl,
            _parameters$marks = parameters.marks,
            marksProp = _parameters$marks === void 0 ? false : _parameters$marks,
            _parameters$max = parameters.max,
            max = _parameters$max === void 0 ? 100 : _parameters$max,
            _parameters$min = parameters.min,
            min = _parameters$min === void 0 ? 0 : _parameters$min,
            name = parameters.name,
            onChange = parameters.onChange,
            onChangeCommitted = parameters.onChangeCommitted,
            _parameters$orientati = parameters.orientation,
            orientation = _parameters$orientati === void 0 ? 'horizontal' : _parameters$orientati,
            ref = parameters.rootRef,
            _parameters$scale = parameters.scale,
            scale = _parameters$scale === void 0 ? Identity$1 : _parameters$scale,
            _parameters$step2 = parameters.step,
            step = _parameters$step2 === void 0 ? 1 : _parameters$step2,
            _parameters$shiftStep = parameters.shiftStep,
            shiftStep = _parameters$shiftStep === void 0 ? 10 : _parameters$shiftStep,
            tabIndex = parameters.tabIndex,
            valueProp = parameters.value;
          const touchId = reactExports.useRef();
          // We can't use the :active browser pseudo-classes.
          // - The active state isn't triggered when clicking on the rail.
          // - The active state isn't transferred when inversing a range slider.
          const _reactExports$useStat9 = reactExports.useState(-1),
            _reactExports$useStat10 = _slicedToArray2(_reactExports$useStat9, 2),
            active = _reactExports$useStat10[0],
            setActive = _reactExports$useStat10[1];
          const _reactExports$useStat11 = reactExports.useState(-1),
            _reactExports$useStat12 = _slicedToArray2(_reactExports$useStat11, 2),
            open = _reactExports$useStat12[0],
            setOpen = _reactExports$useStat12[1];
          const _reactExports$useStat13 = reactExports.useState(false),
            _reactExports$useStat14 = _slicedToArray2(_reactExports$useStat13, 2),
            dragging = _reactExports$useStat14[0],
            setDragging = _reactExports$useStat14[1];
          const moveCount = reactExports.useRef(0);
          const _useControlled7 = useControlled({
              controlled: valueProp,
              default: defaultValue != null ? defaultValue : min,
              name: 'Slider'
            }),
            _useControlled8 = _slicedToArray2(_useControlled7, 2),
            valueDerived = _useControlled8[0],
            setValueState = _useControlled8[1];
          const handleChange = onChange && ((event, value, thumbIndex) => {
            // Redefine target to allow name and value to be read.
            // This allows seamless integration with the most popular form libraries.
            // https://github.com/mui/material-ui/issues/13485#issuecomment-676048492
            // Clone the event to not override `target` of the original event.
            const nativeEvent = event.nativeEvent || event;
            // @ts-ignore The nativeEvent is function, not object
            const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
            Object.defineProperty(clonedEvent, 'target', {
              writable: true,
              value: {
                value,
                name
              }
            });
            onChange(clonedEvent, value, thumbIndex);
          });
          const range = Array.isArray(valueDerived);
          let values = range ? valueDerived.slice().sort(asc) : [valueDerived];
          values = values.map(value => value == null ? min : clamp(value, min, max));
          const marks = marksProp === true && step !== null ? [...Array(Math.floor((max - min) / step) + 1)].map((_, index) => ({
            value: min + step * index
          })) : marksProp || [];
          const marksValues = marks.map(mark => mark.value);
          const _useIsFocusVisible = useIsFocusVisible(),
            isFocusVisibleRef = _useIsFocusVisible.isFocusVisibleRef,
            handleBlurVisible = _useIsFocusVisible.onBlur,
            handleFocusVisible = _useIsFocusVisible.onFocus,
            focusVisibleRef = _useIsFocusVisible.ref;
          const _reactExports$useStat15 = reactExports.useState(-1),
            _reactExports$useStat16 = _slicedToArray2(_reactExports$useStat15, 2),
            focusedThumbIndex = _reactExports$useStat16[0],
            setFocusedThumbIndex = _reactExports$useStat16[1];
          const sliderRef = reactExports.useRef();
          const handleFocusRef = useForkRef(focusVisibleRef, sliderRef);
          const handleRef = useForkRef(ref, handleFocusRef);
          const createHandleHiddenInputFocus = otherHandlers => event => {
            var _otherHandlers$onFocu;
            const index = Number(event.currentTarget.getAttribute('data-index'));
            handleFocusVisible(event);
            if (isFocusVisibleRef.current === true) {
              setFocusedThumbIndex(index);
            }
            setOpen(index);
            otherHandlers == null || (_otherHandlers$onFocu = otherHandlers.onFocus) == null || _otherHandlers$onFocu.call(otherHandlers, event);
          };
          const createHandleHiddenInputBlur = otherHandlers => event => {
            var _otherHandlers$onBlur;
            handleBlurVisible(event);
            if (isFocusVisibleRef.current === false) {
              setFocusedThumbIndex(-1);
            }
            setOpen(-1);
            otherHandlers == null || (_otherHandlers$onBlur = otherHandlers.onBlur) == null || _otherHandlers$onBlur.call(otherHandlers, event);
          };
          const changeValue = (event, valueInput) => {
            const index = Number(event.currentTarget.getAttribute('data-index'));
            const value = values[index];
            const marksIndex = marksValues.indexOf(value);
            let newValue = valueInput;
            if (marks && step == null) {
              const maxMarksValue = marksValues[marksValues.length - 1];
              if (newValue > maxMarksValue) {
                newValue = maxMarksValue;
              } else if (newValue < marksValues[0]) {
                newValue = marksValues[0];
              } else {
                newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];
              }
            }
            newValue = clamp(newValue, min, max);
            if (range) {
              // Bound the new value to the thumb's neighbours.
              if (disableSwap) {
                newValue = clamp(newValue, values[index - 1] || -Infinity, values[index + 1] || Infinity);
              }
              const previousValue = newValue;
              newValue = setValueIndex({
                values,
                newValue,
                index
              });
              let activeIndex = index;

              // Potentially swap the index if needed.
              if (!disableSwap) {
                activeIndex = newValue.indexOf(previousValue);
              }
              focusThumb({
                sliderRef,
                activeIndex
              });
            }
            setValueState(newValue);
            setFocusedThumbIndex(index);
            if (handleChange && !areValuesEqual(newValue, valueDerived)) {
              handleChange(event, newValue, index);
            }
            if (onChangeCommitted) {
              onChangeCommitted(event, newValue);
            }
          };
          const createHandleHiddenInputKeyDown = otherHandlers => event => {
            var _otherHandlers$onKeyD;
            // The Shift + Up/Down keyboard shortcuts for moving the slider makes sense to be supported
            // only if the step is defined. If the step is null, this means tha the marks are used for specifying the valid values.
            if (step !== null) {
              const index = Number(event.currentTarget.getAttribute('data-index'));
              const value = values[index];
              let newValue = null;
              if ((event.key === 'ArrowLeft' || event.key === 'ArrowDown') && event.shiftKey || event.key === 'PageDown') {
                newValue = Math.max(value - shiftStep, min);
              } else if ((event.key === 'ArrowRight' || event.key === 'ArrowUp') && event.shiftKey || event.key === 'PageUp') {
                newValue = Math.min(value + shiftStep, max);
              }
              if (newValue !== null) {
                changeValue(event, newValue);
                event.preventDefault();
              }
            }
            otherHandlers == null || (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
          };
          useEnhancedEffect(() => {
            if (disabled && sliderRef.current.contains(document.activeElement)) {
              var _document$activeEleme;
              // This is necessary because Firefox and Safari will keep focus
              // on a disabled element:
              // https://codesandbox.io/p/sandbox/mui-pr-22247-forked-h151h?file=/src/App.js
              // @ts-ignore
              (_document$activeEleme = document.activeElement) == null || _document$activeEleme.blur();
            }
          }, [disabled]);
          if (disabled && active !== -1) {
            setActive(-1);
          }
          if (disabled && focusedThumbIndex !== -1) {
            setFocusedThumbIndex(-1);
          }
          const createHandleHiddenInputChange = otherHandlers => event => {
            var _otherHandlers$onChan;
            (_otherHandlers$onChan = otherHandlers.onChange) == null || _otherHandlers$onChan.call(otherHandlers, event);
            // @ts-ignore
            changeValue(event, event.target.valueAsNumber);
          };
          const previousIndex = reactExports.useRef();
          let axis = orientation;
          if (isRtl && orientation === 'horizontal') {
            axis += '-reverse';
          }
          const getFingerNewValue = ({
            finger,
            move = false
          }) => {
            const slider = sliderRef.current;
            const _slider$getBoundingCl = slider.getBoundingClientRect(),
              width = _slider$getBoundingCl.width,
              height = _slider$getBoundingCl.height,
              bottom = _slider$getBoundingCl.bottom,
              left = _slider$getBoundingCl.left;
            let percent;
            if (axis.indexOf('vertical') === 0) {
              percent = (bottom - finger.y) / height;
            } else {
              percent = (finger.x - left) / width;
            }
            if (axis.indexOf('-reverse') !== -1) {
              percent = 1 - percent;
            }
            let newValue;
            newValue = percentToValue(percent, min, max);
            if (step) {
              newValue = roundValueToStep(newValue, step, min);
            } else {
              const closestIndex = findClosest(marksValues, newValue);
              newValue = marksValues[closestIndex];
            }
            newValue = clamp(newValue, min, max);
            let activeIndex = 0;
            if (range) {
              if (!move) {
                activeIndex = findClosest(values, newValue);
              } else {
                activeIndex = previousIndex.current;
              }

              // Bound the new value to the thumb's neighbours.
              if (disableSwap) {
                newValue = clamp(newValue, values[activeIndex - 1] || -Infinity, values[activeIndex + 1] || Infinity);
              }
              const previousValue = newValue;
              newValue = setValueIndex({
                values,
                newValue,
                index: activeIndex
              });

              // Potentially swap the index if needed.
              if (!(disableSwap && move)) {
                activeIndex = newValue.indexOf(previousValue);
                previousIndex.current = activeIndex;
              }
            }
            return {
              newValue,
              activeIndex
            };
          };
          const handleTouchMove = useEventCallback(nativeEvent => {
            const finger = trackFinger(nativeEvent, touchId);
            if (!finger) {
              return;
            }
            moveCount.current += 1;

            // Cancel move in case some other element consumed a mouseup event and it was not fired.
            // @ts-ignore buttons doesn't not exists on touch event
            if (nativeEvent.type === 'mousemove' && nativeEvent.buttons === 0) {
              // eslint-disable-next-line @typescript-eslint/no-use-before-define
              handleTouchEnd(nativeEvent);
              return;
            }
            const _getFingerNewValue = getFingerNewValue({
                finger,
                move: true
              }),
              newValue = _getFingerNewValue.newValue,
              activeIndex = _getFingerNewValue.activeIndex;
            focusThumb({
              sliderRef,
              activeIndex,
              setActive
            });
            setValueState(newValue);
            if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
              setDragging(true);
            }
            if (handleChange && !areValuesEqual(newValue, valueDerived)) {
              handleChange(nativeEvent, newValue, activeIndex);
            }
          });
          const handleTouchEnd = useEventCallback(nativeEvent => {
            const finger = trackFinger(nativeEvent, touchId);
            setDragging(false);
            if (!finger) {
              return;
            }
            const _getFingerNewValue2 = getFingerNewValue({
                finger,
                move: true
              }),
              newValue = _getFingerNewValue2.newValue;
            setActive(-1);
            if (nativeEvent.type === 'touchend') {
              setOpen(-1);
            }
            if (onChangeCommitted) {
              onChangeCommitted(nativeEvent, newValue);
            }
            touchId.current = undefined;

            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            stopListening();
          });
          const handleTouchStart = useEventCallback(nativeEvent => {
            if (disabled) {
              return;
            }
            // If touch-action: none; is not supported we need to prevent the scroll manually.
            if (!doesSupportTouchActionNone()) {
              nativeEvent.preventDefault();
            }
            const touch = nativeEvent.changedTouches[0];
            if (touch != null) {
              // A number that uniquely identifies the current finger in the touch session.
              touchId.current = touch.identifier;
            }
            const finger = trackFinger(nativeEvent, touchId);
            if (finger !== false) {
              const _getFingerNewValue3 = getFingerNewValue({
                  finger
                }),
                newValue = _getFingerNewValue3.newValue,
                activeIndex = _getFingerNewValue3.activeIndex;
              focusThumb({
                sliderRef,
                activeIndex,
                setActive
              });
              setValueState(newValue);
              if (handleChange && !areValuesEqual(newValue, valueDerived)) {
                handleChange(nativeEvent, newValue, activeIndex);
              }
            }
            moveCount.current = 0;
            const doc = ownerDocument(sliderRef.current);
            doc.addEventListener('touchmove', handleTouchMove, {
              passive: true
            });
            doc.addEventListener('touchend', handleTouchEnd, {
              passive: true
            });
          });
          const stopListening = reactExports.useCallback(() => {
            const doc = ownerDocument(sliderRef.current);
            doc.removeEventListener('mousemove', handleTouchMove);
            doc.removeEventListener('mouseup', handleTouchEnd);
            doc.removeEventListener('touchmove', handleTouchMove);
            doc.removeEventListener('touchend', handleTouchEnd);
          }, [handleTouchEnd, handleTouchMove]);
          reactExports.useEffect(() => {
            const slider = sliderRef.current;
            slider.addEventListener('touchstart', handleTouchStart, {
              passive: doesSupportTouchActionNone()
            });
            return () => {
              slider.removeEventListener('touchstart', handleTouchStart);
              stopListening();
            };
          }, [stopListening, handleTouchStart]);
          reactExports.useEffect(() => {
            if (disabled) {
              stopListening();
            }
          }, [disabled, stopListening]);
          const createHandleMouseDown = otherHandlers => event => {
            var _otherHandlers$onMous;
            (_otherHandlers$onMous = otherHandlers.onMouseDown) == null || _otherHandlers$onMous.call(otherHandlers, event);
            if (disabled) {
              return;
            }
            if (event.defaultPrevented) {
              return;
            }

            // Only handle left clicks
            if (event.button !== 0) {
              return;
            }

            // Avoid text selection
            event.preventDefault();
            const finger = trackFinger(event, touchId);
            if (finger !== false) {
              const _getFingerNewValue4 = getFingerNewValue({
                  finger
                }),
                newValue = _getFingerNewValue4.newValue,
                activeIndex = _getFingerNewValue4.activeIndex;
              focusThumb({
                sliderRef,
                activeIndex,
                setActive
              });
              setValueState(newValue);
              if (handleChange && !areValuesEqual(newValue, valueDerived)) {
                handleChange(event, newValue, activeIndex);
              }
            }
            moveCount.current = 0;
            const doc = ownerDocument(sliderRef.current);
            doc.addEventListener('mousemove', handleTouchMove, {
              passive: true
            });
            doc.addEventListener('mouseup', handleTouchEnd);
          };
          const trackOffset = valueToPercent(range ? values[0] : min, min, max);
          const trackLeap = valueToPercent(values[values.length - 1], min, max) - trackOffset;
          const getRootProps = (externalProps = {}) => {
            const externalHandlers = extractEventHandlers(externalProps);
            const ownEventHandlers = {
              onMouseDown: createHandleMouseDown(externalHandlers || {})
            };
            const mergedEventHandlers = _extends$h({}, externalHandlers, ownEventHandlers);
            return _extends$h({}, externalProps, {
              ref: handleRef
            }, mergedEventHandlers);
          };
          const createHandleMouseOver = otherHandlers => event => {
            var _otherHandlers$onMous2;
            (_otherHandlers$onMous2 = otherHandlers.onMouseOver) == null || _otherHandlers$onMous2.call(otherHandlers, event);
            const index = Number(event.currentTarget.getAttribute('data-index'));
            setOpen(index);
          };
          const createHandleMouseLeave = otherHandlers => event => {
            var _otherHandlers$onMous3;
            (_otherHandlers$onMous3 = otherHandlers.onMouseLeave) == null || _otherHandlers$onMous3.call(otherHandlers, event);
            setOpen(-1);
          };
          const getThumbProps = (externalProps = {}) => {
            const externalHandlers = extractEventHandlers(externalProps);
            const ownEventHandlers = {
              onMouseOver: createHandleMouseOver(externalHandlers || {}),
              onMouseLeave: createHandleMouseLeave(externalHandlers || {})
            };
            return _extends$h({}, externalProps, externalHandlers, ownEventHandlers);
          };
          const getThumbStyle = index => {
            return {
              // So the non active thumb doesn't show its label on hover.
              pointerEvents: active !== -1 && active !== index ? 'none' : undefined
            };
          };
          const getHiddenInputProps = (externalProps = {}) => {
            var _parameters$step;
            const externalHandlers = extractEventHandlers(externalProps);
            const ownEventHandlers = {
              onChange: createHandleHiddenInputChange(externalHandlers || {}),
              onFocus: createHandleHiddenInputFocus(externalHandlers || {}),
              onBlur: createHandleHiddenInputBlur(externalHandlers || {}),
              onKeyDown: createHandleHiddenInputKeyDown(externalHandlers || {})
            };
            const mergedEventHandlers = _extends$h({}, externalHandlers, ownEventHandlers);
            return _extends$h({
              tabIndex,
              'aria-labelledby': ariaLabelledby,
              'aria-orientation': orientation,
              'aria-valuemax': scale(max),
              'aria-valuemin': scale(min),
              name,
              type: 'range',
              min: parameters.min,
              max: parameters.max,
              step: parameters.step === null && parameters.marks ? 'any' : (_parameters$step = parameters.step) != null ? _parameters$step : undefined,
              disabled
            }, externalProps, mergedEventHandlers, {
              style: _extends$h({}, visuallyHidden, {
                direction: isRtl ? 'rtl' : 'ltr',
                // So that VoiceOver's focus indicator matches the thumb's dimensions
                width: '100%',
                height: '100%'
              })
            });
          };
          return {
            active,
            axis: axis,
            axisProps,
            dragging,
            focusedThumbIndex,
            getHiddenInputProps,
            getRootProps,
            getThumbProps,
            marks: marks,
            open,
            range,
            rootRef: handleRef,
            trackLeap,
            trackOffset,
            values,
            getThumbStyle
          };
        }
        const shouldSpreadAdditionalProps = Slot => {
          return !Slot || !isHostComponent(Slot);
        };
        const useValueLabelClasses = props => {
          const open = props.open;
          const utilityClasses = {
            offset: clsx(open && sliderClasses.valueLabelOpen),
            circle: sliderClasses.valueLabelCircle,
            label: sliderClasses.valueLabelLabel
          };
          return utilityClasses;
        };
        function SliderValueLabel$1(props) {
          const children = props.children,
            className = props.className,
            value = props.value;
          const classes = useValueLabelClasses(props);
          if (!children) {
            return null;
          }
          return /* @__PURE__ */reactExports.cloneElement(children, {
            className: clsx(children.props.className)
          }, /* @__PURE__ */jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [children.props.children, /* @__PURE__ */jsxRuntimeExports.jsx("span", {
              className: clsx(classes.offset, className),
              "aria-hidden": true,
              children: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                className: classes.circle,
                children: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                  className: classes.label,
                  children: value
                })
              })
            })]
          }));
        }
        const _excluded$d = ["aria-label", "aria-valuetext", "aria-labelledby", "component", "components", "componentsProps", "color", "classes", "className", "disableSwap", "disabled", "getAriaLabel", "getAriaValueText", "marks", "max", "min", "name", "onChange", "onChangeCommitted", "orientation", "shiftStep", "size", "step", "scale", "slotProps", "slots", "tabIndex", "track", "value", "valueLabelDisplay", "valueLabelFormat"];
        function Identity(x) {
          return x;
        }
        const SliderRoot = styled("span", {
          name: "MuiSlider",
          slot: "Root",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.root, styles[`color${capitalize$1(ownerState.color)}`], ownerState.size !== "medium" && styles[`size${capitalize$1(ownerState.size)}`], ownerState.marked && styles.marked, ownerState.orientation === "vertical" && styles.vertical, ownerState.track === "inverted" && styles.trackInverted, ownerState.track === false && styles.trackFalse];
          }
        })(({
          theme
        }) => {
          var _theme$vars;
          return {
            borderRadius: 12,
            boxSizing: "content-box",
            display: "inline-block",
            position: "relative",
            cursor: "pointer",
            touchAction: "none",
            WebkitTapHighlightColor: "transparent",
            "@media print": {
              colorAdjust: "exact"
            },
            [`&.${sliderClasses.disabled}`]: {
              pointerEvents: "none",
              cursor: "default",
              color: (theme.vars || theme).palette.grey[400]
            },
            [`&.${sliderClasses.dragging}`]: {
              [`& .${sliderClasses.thumb}, & .${sliderClasses.track}`]: {
                transition: "none"
              }
            },
            variants: [...Object.keys(((_theme$vars = theme.vars) != null ? _theme$vars : theme).palette).filter(key => {
              var _theme$vars2;
              return ((_theme$vars2 = theme.vars) != null ? _theme$vars2 : theme).palette[key].main;
            }).map(color => ({
              props: {
                color
              },
              style: {
                color: (theme.vars || theme).palette[color].main
              }
            })), {
              props: {
                orientation: "horizontal"
              },
              style: {
                height: 4,
                width: "100%",
                padding: "13px 0",
                // The primary input mechanism of the device includes a pointing device of limited accuracy.
                "@media (pointer: coarse)": {
                  // Reach 42px touch target, about ~8mm on screen.
                  padding: "20px 0"
                }
              }
            }, {
              props: {
                orientation: "horizontal",
                size: "small"
              },
              style: {
                height: 2
              }
            }, {
              props: {
                orientation: "horizontal",
                marked: true
              },
              style: {
                marginBottom: 20
              }
            }, {
              props: {
                orientation: "vertical"
              },
              style: {
                height: "100%",
                width: 4,
                padding: "0 13px",
                // The primary input mechanism of the device includes a pointing device of limited accuracy.
                "@media (pointer: coarse)": {
                  // Reach 42px touch target, about ~8mm on screen.
                  padding: "0 20px"
                }
              }
            }, {
              props: {
                orientation: "vertical",
                size: "small"
              },
              style: {
                width: 2
              }
            }, {
              props: {
                orientation: "vertical",
                marked: true
              },
              style: {
                marginRight: 44
              }
            }]
          };
        });
        const SliderRail = styled("span", {
          name: "MuiSlider",
          slot: "Rail",
          overridesResolver: (props, styles) => styles.rail
        })({
          display: "block",
          position: "absolute",
          borderRadius: "inherit",
          backgroundColor: "currentColor",
          opacity: 0.38,
          variants: [{
            props: {
              orientation: "horizontal"
            },
            style: {
              width: "100%",
              height: "inherit",
              top: "50%",
              transform: "translateY(-50%)"
            }
          }, {
            props: {
              orientation: "vertical"
            },
            style: {
              height: "100%",
              width: "inherit",
              left: "50%",
              transform: "translateX(-50%)"
            }
          }, {
            props: {
              track: "inverted"
            },
            style: {
              opacity: 1
            }
          }]
        });
        const SliderTrack = styled("span", {
          name: "MuiSlider",
          slot: "Track",
          overridesResolver: (props, styles) => styles.track
        })(({
          theme
        }) => {
          var _theme$vars3;
          return {
            display: "block",
            position: "absolute",
            borderRadius: "inherit",
            border: "1px solid currentColor",
            backgroundColor: "currentColor",
            transition: theme.transitions.create(["left", "width", "bottom", "height"], {
              duration: theme.transitions.duration.shortest
            }),
            variants: [{
              props: {
                size: "small"
              },
              style: {
                border: "none"
              }
            }, {
              props: {
                orientation: "horizontal"
              },
              style: {
                height: "inherit",
                top: "50%",
                transform: "translateY(-50%)"
              }
            }, {
              props: {
                orientation: "vertical"
              },
              style: {
                width: "inherit",
                left: "50%",
                transform: "translateX(-50%)"
              }
            }, {
              props: {
                track: false
              },
              style: {
                display: "none"
              }
            }, ...Object.keys(((_theme$vars3 = theme.vars) != null ? _theme$vars3 : theme).palette).filter(key => {
              var _theme$vars4;
              return ((_theme$vars4 = theme.vars) != null ? _theme$vars4 : theme).palette[key].main;
            }).map(color => ({
              props: {
                color,
                track: "inverted"
              },
              style: _extends$h({}, theme.vars ? {
                backgroundColor: theme.vars.palette.Slider[`${color}Track`],
                borderColor: theme.vars.palette.Slider[`${color}Track`]
              } : _extends$h({
                backgroundColor: lighten_1(theme.palette[color].main, 0.62),
                borderColor: lighten_1(theme.palette[color].main, 0.62)
              }, theme.applyStyles("dark", {
                backgroundColor: darken_1(theme.palette[color].main, 0.5)
              }), theme.applyStyles("dark", {
                borderColor: darken_1(theme.palette[color].main, 0.5)
              })))
            }))]
          };
        });
        const SliderThumb = styled("span", {
          name: "MuiSlider",
          slot: "Thumb",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.thumb, styles[`thumbColor${capitalize$1(ownerState.color)}`], ownerState.size !== "medium" && styles[`thumbSize${capitalize$1(ownerState.size)}`]];
          }
        })(({
          theme
        }) => {
          var _theme$vars5;
          return {
            position: "absolute",
            width: 20,
            height: 20,
            boxSizing: "border-box",
            borderRadius: "50%",
            outline: 0,
            backgroundColor: "currentColor",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            transition: theme.transitions.create(["box-shadow", "left", "bottom"], {
              duration: theme.transitions.duration.shortest
            }),
            "&::before": {
              position: "absolute",
              content: '""',
              borderRadius: "inherit",
              width: "100%",
              height: "100%",
              boxShadow: (theme.vars || theme).shadows[2]
            },
            "&::after": {
              position: "absolute",
              content: '""',
              borderRadius: "50%",
              // 42px is the hit target
              width: 42,
              height: 42,
              top: "50%",
              left: "50%",
              transform: "translate(-50%, -50%)"
            },
            [`&.${sliderClasses.disabled}`]: {
              "&:hover": {
                boxShadow: "none"
              }
            },
            variants: [{
              props: {
                size: "small"
              },
              style: {
                width: 12,
                height: 12,
                "&::before": {
                  boxShadow: "none"
                }
              }
            }, {
              props: {
                orientation: "horizontal"
              },
              style: {
                top: "50%",
                transform: "translate(-50%, -50%)"
              }
            }, {
              props: {
                orientation: "vertical"
              },
              style: {
                left: "50%",
                transform: "translate(-50%, 50%)"
              }
            }, ...Object.keys(((_theme$vars5 = theme.vars) != null ? _theme$vars5 : theme).palette).filter(key => {
              var _theme$vars6;
              return ((_theme$vars6 = theme.vars) != null ? _theme$vars6 : theme).palette[key].main;
            }).map(color => ({
              props: {
                color
              },
              style: {
                [`&:hover, &.${sliderClasses.focusVisible}`]: _extends$h({}, theme.vars ? {
                  boxShadow: `0px 0px 0px 8px rgba(${theme.vars.palette[color].mainChannel} / 0.16)`
                } : {
                  boxShadow: `0px 0px 0px 8px ${alpha_1(theme.palette[color].main, 0.16)}`
                }, {
                  "@media (hover: none)": {
                    boxShadow: "none"
                  }
                }),
                [`&.${sliderClasses.active}`]: _extends$h({}, theme.vars ? {
                  boxShadow: `0px 0px 0px 14px rgba(${theme.vars.palette[color].mainChannel} / 0.16)`
                } : {
                  boxShadow: `0px 0px 0px 14px ${alpha_1(theme.palette[color].main, 0.16)}`
                })
              }
            }))]
          };
        });
        const SliderValueLabel = styled(SliderValueLabel$1, {
          name: "MuiSlider",
          slot: "ValueLabel",
          overridesResolver: (props, styles) => styles.valueLabel
        })(({
          theme
        }) => _extends$h({
          zIndex: 1,
          whiteSpace: "nowrap"
        }, theme.typography.body2, {
          fontWeight: 500,
          transition: theme.transitions.create(["transform"], {
            duration: theme.transitions.duration.shortest
          }),
          position: "absolute",
          backgroundColor: (theme.vars || theme).palette.grey[600],
          borderRadius: 2,
          color: (theme.vars || theme).palette.common.white,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          padding: "0.25rem 0.75rem",
          variants: [{
            props: {
              orientation: "horizontal"
            },
            style: {
              transform: "translateY(-100%) scale(0)",
              top: "-10px",
              transformOrigin: "bottom center",
              "&::before": {
                position: "absolute",
                content: '""',
                width: 8,
                height: 8,
                transform: "translate(-50%, 50%) rotate(45deg)",
                backgroundColor: "inherit",
                bottom: 0,
                left: "50%"
              },
              [`&.${sliderClasses.valueLabelOpen}`]: {
                transform: "translateY(-100%) scale(1)"
              }
            }
          }, {
            props: {
              orientation: "vertical"
            },
            style: {
              transform: "translateY(-50%) scale(0)",
              right: "30px",
              top: "50%",
              transformOrigin: "right center",
              "&::before": {
                position: "absolute",
                content: '""',
                width: 8,
                height: 8,
                transform: "translate(-50%, -50%) rotate(45deg)",
                backgroundColor: "inherit",
                right: -8,
                top: "50%"
              },
              [`&.${sliderClasses.valueLabelOpen}`]: {
                transform: "translateY(-50%) scale(1)"
              }
            }
          }, {
            props: {
              size: "small"
            },
            style: {
              fontSize: theme.typography.pxToRem(12),
              padding: "0.25rem 0.5rem"
            }
          }, {
            props: {
              orientation: "vertical",
              size: "small"
            },
            style: {
              right: "20px"
            }
          }]
        }));
        const SliderMark = styled("span", {
          name: "MuiSlider",
          slot: "Mark",
          shouldForwardProp: prop => slotShouldForwardProp(prop) && prop !== "markActive",
          overridesResolver: (props, styles) => {
            const markActive = props.markActive;
            return [styles.mark, markActive && styles.markActive];
          }
        })(({
          theme
        }) => ({
          position: "absolute",
          width: 2,
          height: 2,
          borderRadius: 1,
          backgroundColor: "currentColor",
          variants: [{
            props: {
              orientation: "horizontal"
            },
            style: {
              top: "50%",
              transform: "translate(-1px, -50%)"
            }
          }, {
            props: {
              orientation: "vertical"
            },
            style: {
              left: "50%",
              transform: "translate(-50%, 1px)"
            }
          }, {
            props: {
              markActive: true
            },
            style: {
              backgroundColor: (theme.vars || theme).palette.background.paper,
              opacity: 0.8
            }
          }]
        }));
        const SliderMarkLabel = styled("span", {
          name: "MuiSlider",
          slot: "MarkLabel",
          shouldForwardProp: prop => slotShouldForwardProp(prop) && prop !== "markLabelActive",
          overridesResolver: (props, styles) => styles.markLabel
        })(({
          theme
        }) => _extends$h({}, theme.typography.body2, {
          color: (theme.vars || theme).palette.text.secondary,
          position: "absolute",
          whiteSpace: "nowrap",
          variants: [{
            props: {
              orientation: "horizontal"
            },
            style: {
              top: 30,
              transform: "translateX(-50%)",
              "@media (pointer: coarse)": {
                top: 40
              }
            }
          }, {
            props: {
              orientation: "vertical"
            },
            style: {
              left: 36,
              transform: "translateY(50%)",
              "@media (pointer: coarse)": {
                left: 44
              }
            }
          }, {
            props: {
              markLabelActive: true
            },
            style: {
              color: (theme.vars || theme).palette.text.primary
            }
          }]
        }));
        const useUtilityClasses$2 = ownerState => {
          const disabled = ownerState.disabled,
            dragging = ownerState.dragging,
            marked = ownerState.marked,
            orientation = ownerState.orientation,
            track = ownerState.track,
            classes = ownerState.classes,
            color = ownerState.color,
            size = ownerState.size;
          const slots = {
            root: ["root", disabled && "disabled", dragging && "dragging", marked && "marked", orientation === "vertical" && "vertical", track === "inverted" && "trackInverted", track === false && "trackFalse", color && `color${capitalize$1(color)}`, size && `size${capitalize$1(size)}`],
            rail: ["rail"],
            track: ["track"],
            mark: ["mark"],
            markActive: ["markActive"],
            markLabel: ["markLabel"],
            markLabelActive: ["markLabelActive"],
            valueLabel: ["valueLabel"],
            thumb: ["thumb", disabled && "disabled", size && `thumbSize${capitalize$1(size)}`, color && `thumbColor${capitalize$1(color)}`],
            active: ["active"],
            disabled: ["disabled"],
            focusVisible: ["focusVisible"]
          };
          return composeClasses(slots, getSliderUtilityClass, classes);
        };
        const Forward = ({
          children
        }) => children;
        const Slider$1 = /* @__PURE__ */reactExports.forwardRef(function Slider2(inputProps, ref) {
          var _ref, _slots$root, _ref2, _slots$rail, _ref3, _slots$track, _ref4, _slots$thumb, _ref5, _slots$valueLabel, _ref6, _slots$mark, _ref7, _slots$markLabel, _ref8, _slots$input, _slotProps$root, _slotProps$rail, _slotProps$track, _slotProps$thumb, _slotProps$valueLabel, _slotProps$mark, _slotProps$markLabel, _slotProps$input;
          const props = useDefaultProps({
            props: inputProps,
            name: "MuiSlider"
          });
          const isRtl = useRtl();
          const ariaLabel = props["aria-label"],
            ariaValuetext = props["aria-valuetext"],
            ariaLabelledby = props["aria-labelledby"],
            _props$component5 = props.component,
            component = _props$component5 === void 0 ? "span" : _props$component5,
            _props$components = props.components,
            components = _props$components === void 0 ? {} : _props$components,
            _props$componentsProp2 = props.componentsProps,
            componentsProps = _props$componentsProp2 === void 0 ? {} : _props$componentsProp2,
            _props$color5 = props.color,
            color = _props$color5 === void 0 ? "primary" : _props$color5,
            classesProp = props.classes,
            className = props.className,
            _props$disableSwap = props.disableSwap,
            disableSwap = _props$disableSwap === void 0 ? false : _props$disableSwap,
            _props$disabled4 = props.disabled,
            disabled = _props$disabled4 === void 0 ? false : _props$disabled4,
            getAriaLabel = props.getAriaLabel,
            getAriaValueText = props.getAriaValueText,
            _props$marks = props.marks,
            marksProp = _props$marks === void 0 ? false : _props$marks,
            _props$max = props.max,
            max = _props$max === void 0 ? 100 : _props$max,
            _props$min = props.min,
            min = _props$min === void 0 ? 0 : _props$min,
            _props$orientation2 = props.orientation,
            orientation = _props$orientation2 === void 0 ? "horizontal" : _props$orientation2,
            _props$shiftStep = props.shiftStep,
            shiftStep = _props$shiftStep === void 0 ? 10 : _props$shiftStep,
            _props$size4 = props.size,
            size = _props$size4 === void 0 ? "medium" : _props$size4,
            _props$step = props.step,
            step = _props$step === void 0 ? 1 : _props$step,
            _props$scale = props.scale,
            scale = _props$scale === void 0 ? Identity : _props$scale,
            slotProps = props.slotProps,
            slots = props.slots,
            _props$track = props.track,
            track = _props$track === void 0 ? "normal" : _props$track,
            _props$valueLabelDisp = props.valueLabelDisplay,
            valueLabelDisplay = _props$valueLabelDisp === void 0 ? "off" : _props$valueLabelDisp,
            _props$valueLabelForm = props.valueLabelFormat,
            valueLabelFormat = _props$valueLabelForm === void 0 ? Identity : _props$valueLabelForm,
            other = _objectWithoutPropertiesLoose(props, _excluded$d);
          const ownerState = _extends$h({}, props, {
            isRtl,
            max,
            min,
            classes: classesProp,
            disabled,
            disableSwap,
            orientation,
            marks: marksProp,
            color,
            size,
            step,
            shiftStep,
            scale,
            track,
            valueLabelDisplay,
            valueLabelFormat
          });
          const _useSlider = useSlider(_extends$h({}, ownerState, {
              rootRef: ref
            })),
            axisProps = _useSlider.axisProps,
            getRootProps = _useSlider.getRootProps,
            getHiddenInputProps = _useSlider.getHiddenInputProps,
            getThumbProps = _useSlider.getThumbProps,
            open = _useSlider.open,
            active = _useSlider.active,
            axis = _useSlider.axis,
            focusedThumbIndex = _useSlider.focusedThumbIndex,
            range = _useSlider.range,
            dragging = _useSlider.dragging,
            marks = _useSlider.marks,
            values = _useSlider.values,
            trackOffset = _useSlider.trackOffset,
            trackLeap = _useSlider.trackLeap,
            getThumbStyle = _useSlider.getThumbStyle;
          ownerState.marked = marks.length > 0 && marks.some(mark => mark.label);
          ownerState.dragging = dragging;
          ownerState.focusedThumbIndex = focusedThumbIndex;
          const classes = useUtilityClasses$2(ownerState);
          const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : SliderRoot;
          const RailSlot = (_ref2 = (_slots$rail = slots == null ? void 0 : slots.rail) != null ? _slots$rail : components.Rail) != null ? _ref2 : SliderRail;
          const TrackSlot = (_ref3 = (_slots$track = slots == null ? void 0 : slots.track) != null ? _slots$track : components.Track) != null ? _ref3 : SliderTrack;
          const ThumbSlot = (_ref4 = (_slots$thumb = slots == null ? void 0 : slots.thumb) != null ? _slots$thumb : components.Thumb) != null ? _ref4 : SliderThumb;
          const ValueLabelSlot = (_ref5 = (_slots$valueLabel = slots == null ? void 0 : slots.valueLabel) != null ? _slots$valueLabel : components.ValueLabel) != null ? _ref5 : SliderValueLabel;
          const MarkSlot = (_ref6 = (_slots$mark = slots == null ? void 0 : slots.mark) != null ? _slots$mark : components.Mark) != null ? _ref6 : SliderMark;
          const MarkLabelSlot = (_ref7 = (_slots$markLabel = slots == null ? void 0 : slots.markLabel) != null ? _slots$markLabel : components.MarkLabel) != null ? _ref7 : SliderMarkLabel;
          const InputSlot = (_ref8 = (_slots$input = slots == null ? void 0 : slots.input) != null ? _slots$input : components.Input) != null ? _ref8 : "input";
          const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
          const railSlotProps = (_slotProps$rail = slotProps == null ? void 0 : slotProps.rail) != null ? _slotProps$rail : componentsProps.rail;
          const trackSlotProps = (_slotProps$track = slotProps == null ? void 0 : slotProps.track) != null ? _slotProps$track : componentsProps.track;
          const thumbSlotProps = (_slotProps$thumb = slotProps == null ? void 0 : slotProps.thumb) != null ? _slotProps$thumb : componentsProps.thumb;
          const valueLabelSlotProps = (_slotProps$valueLabel = slotProps == null ? void 0 : slotProps.valueLabel) != null ? _slotProps$valueLabel : componentsProps.valueLabel;
          const markSlotProps = (_slotProps$mark = slotProps == null ? void 0 : slotProps.mark) != null ? _slotProps$mark : componentsProps.mark;
          const markLabelSlotProps = (_slotProps$markLabel = slotProps == null ? void 0 : slotProps.markLabel) != null ? _slotProps$markLabel : componentsProps.markLabel;
          const inputSlotProps = (_slotProps$input = slotProps == null ? void 0 : slotProps.input) != null ? _slotProps$input : componentsProps.input;
          const rootProps = useSlotProps({
            elementType: RootSlot,
            getSlotProps: getRootProps,
            externalSlotProps: rootSlotProps,
            externalForwardedProps: other,
            additionalProps: _extends$h({}, shouldSpreadAdditionalProps(RootSlot) && {
              as: component
            }),
            ownerState: _extends$h({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
            className: [classes.root, className]
          });
          const railProps = useSlotProps({
            elementType: RailSlot,
            externalSlotProps: railSlotProps,
            ownerState,
            className: classes.rail
          });
          const trackProps = useSlotProps({
            elementType: TrackSlot,
            externalSlotProps: trackSlotProps,
            additionalProps: {
              style: _extends$h({}, axisProps[axis].offset(trackOffset), axisProps[axis].leap(trackLeap))
            },
            ownerState: _extends$h({}, ownerState, trackSlotProps == null ? void 0 : trackSlotProps.ownerState),
            className: classes.track
          });
          const thumbProps = useSlotProps({
            elementType: ThumbSlot,
            getSlotProps: getThumbProps,
            externalSlotProps: thumbSlotProps,
            ownerState: _extends$h({}, ownerState, thumbSlotProps == null ? void 0 : thumbSlotProps.ownerState),
            className: classes.thumb
          });
          const valueLabelProps = useSlotProps({
            elementType: ValueLabelSlot,
            externalSlotProps: valueLabelSlotProps,
            ownerState: _extends$h({}, ownerState, valueLabelSlotProps == null ? void 0 : valueLabelSlotProps.ownerState),
            className: classes.valueLabel
          });
          const markProps = useSlotProps({
            elementType: MarkSlot,
            externalSlotProps: markSlotProps,
            ownerState,
            className: classes.mark
          });
          const markLabelProps = useSlotProps({
            elementType: MarkLabelSlot,
            externalSlotProps: markLabelSlotProps,
            ownerState,
            className: classes.markLabel
          });
          const inputSliderProps = useSlotProps({
            elementType: InputSlot,
            getSlotProps: getHiddenInputProps,
            externalSlotProps: inputSlotProps,
            ownerState
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs(RootSlot, _extends$h({}, rootProps, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(RailSlot, _extends$h({}, railProps)), /* @__PURE__ */jsxRuntimeExports.jsx(TrackSlot, _extends$h({}, trackProps)), marks.filter(mark => mark.value >= min && mark.value <= max).map((mark, index) => {
              const percent = valueToPercent(mark.value, min, max);
              const style = axisProps[axis].offset(percent);
              let markActive;
              if (track === false) {
                markActive = values.indexOf(mark.value) !== -1;
              } else {
                markActive = track === "normal" && (range ? mark.value >= values[0] && mark.value <= values[values.length - 1] : mark.value <= values[0]) || track === "inverted" && (range ? mark.value <= values[0] || mark.value >= values[values.length - 1] : mark.value >= values[0]);
              }
              return /* @__PURE__ */jsxRuntimeExports.jsxs(reactExports.Fragment, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(MarkSlot, _extends$h({
                  "data-index": index
                }, markProps, !isHostComponent(MarkSlot) && {
                  markActive
                }, {
                  style: _extends$h({}, style, markProps.style),
                  className: clsx(markProps.className, markActive && classes.markActive)
                })), mark.label != null ? /* @__PURE__ */jsxRuntimeExports.jsx(MarkLabelSlot, _extends$h({
                  "aria-hidden": true,
                  "data-index": index
                }, markLabelProps, !isHostComponent(MarkLabelSlot) && {
                  markLabelActive: markActive
                }, {
                  style: _extends$h({}, style, markLabelProps.style),
                  className: clsx(classes.markLabel, markLabelProps.className, markActive && classes.markLabelActive),
                  children: mark.label
                })) : null]
              }, index);
            }), values.map((value, index) => {
              const percent = valueToPercent(value, min, max);
              const style = axisProps[axis].offset(percent);
              const ValueLabelComponent = valueLabelDisplay === "off" ? Forward : ValueLabelSlot;
              return /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */ /* @__PURE__ */jsxRuntimeExports.jsx(ValueLabelComponent, _extends$h({}, !isHostComponent(ValueLabelComponent) && {
                valueLabelFormat,
                valueLabelDisplay,
                value: typeof valueLabelFormat === "function" ? valueLabelFormat(scale(value), index) : valueLabelFormat,
                index,
                open: open === index || active === index || valueLabelDisplay === "on",
                disabled
              }, valueLabelProps, {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ThumbSlot, _extends$h({
                  "data-index": index
                }, thumbProps, {
                  className: clsx(classes.thumb, thumbProps.className, active === index && classes.active, focusedThumbIndex === index && classes.focusVisible),
                  style: _extends$h({}, style, getThumbStyle(index), thumbProps.style),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(InputSlot, _extends$h({
                    "data-index": index,
                    "aria-label": getAriaLabel ? getAriaLabel(index) : ariaLabel,
                    "aria-valuenow": scale(value),
                    "aria-labelledby": ariaLabelledby,
                    "aria-valuetext": getAriaValueText ? getAriaValueText(scale(value), index) : ariaValuetext,
                    value: values[index]
                  }, inputSliderProps))
                }))
              }), index);
            })]
          }));
        });
        const _excluded$c = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
        const styles$M = {
          entering: {
            transform: "none"
          },
          entered: {
            transform: "none"
          }
        };
        const Zoom = /* @__PURE__ */reactExports.forwardRef(function Zoom2(props, ref) {
          const theme = useTheme();
          const defaultTimeout = {
            enter: theme.transitions.duration.enteringScreen,
            exit: theme.transitions.duration.leavingScreen
          };
          const addEndListener = props.addEndListener,
            _props$appear = props.appear,
            appear = _props$appear === void 0 ? true : _props$appear,
            _children4 = props.children,
            easing = props.easing,
            inProp = props.in,
            onEnter = props.onEnter,
            onEntered = props.onEntered,
            onEntering = props.onEntering,
            onExit = props.onExit,
            onExited = props.onExited,
            onExiting = props.onExiting,
            style = props.style,
            _props$timeout = props.timeout,
            timeout = _props$timeout === void 0 ? defaultTimeout : _props$timeout,
            _props$TransitionComp = props.TransitionComponent,
            TransitionComponent = _props$TransitionComp === void 0 ? Transition : _props$TransitionComp,
            other = _objectWithoutPropertiesLoose(props, _excluded$c);
          const nodeRef = reactExports.useRef(null);
          const handleRef = useForkRef(nodeRef, _children4.ref, ref);
          const normalizedTransitionCallback = callback => maybeIsAppearing => {
            if (callback) {
              const node = nodeRef.current;
              if (maybeIsAppearing === void 0) {
                callback(node);
              } else {
                callback(node, maybeIsAppearing);
              }
            }
          };
          const handleEntering = normalizedTransitionCallback(onEntering);
          const handleEnter = normalizedTransitionCallback((node, isAppearing) => {
            reflow(node);
            const transitionProps = getTransitionProps({
              style,
              timeout,
              easing
            }, {
              mode: "enter"
            });
            node.style.webkitTransition = theme.transitions.create("transform", transitionProps);
            node.style.transition = theme.transitions.create("transform", transitionProps);
            if (onEnter) {
              onEnter(node, isAppearing);
            }
          });
          const handleEntered = normalizedTransitionCallback(onEntered);
          const handleExiting = normalizedTransitionCallback(onExiting);
          const handleExit = normalizedTransitionCallback(node => {
            const transitionProps = getTransitionProps({
              style,
              timeout,
              easing
            }, {
              mode: "exit"
            });
            node.style.webkitTransition = theme.transitions.create("transform", transitionProps);
            node.style.transition = theme.transitions.create("transform", transitionProps);
            if (onExit) {
              onExit(node);
            }
          });
          const handleExited = normalizedTransitionCallback(onExited);
          const handleAddEndListener = next => {
            if (addEndListener) {
              addEndListener(nodeRef.current, next);
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(TransitionComponent, _extends$h({
            appear,
            in: inProp,
            nodeRef,
            onEnter: handleEnter,
            onEntered: handleEntered,
            onEntering: handleEntering,
            onExit: handleExit,
            onExited: handleExited,
            onExiting: handleExiting,
            addEndListener: handleAddEndListener,
            timeout
          }, other, {
            children: (state, childProps) => {
              return /* @__PURE__ */reactExports.cloneElement(_children4, _extends$h({
                style: _extends$h({
                  transform: "scale(0)",
                  visibility: state === "exited" && !inProp ? "hidden" : void 0
                }, styles$M[state], style, _children4.props.style),
                ref: handleRef
              }, childProps));
            }
          }));
        });
        function getSpeedDialUtilityClass(slot) {
          return generateUtilityClass('MuiSpeedDial', slot);
        }
        const speedDialClasses = generateUtilityClasses('MuiSpeedDial', ['root', 'fab', 'directionUp', 'directionDown', 'directionLeft', 'directionRight', 'actions', 'actionsClosed']);
        const _excluded$b = ["ref"],
          _excluded2$1 = ["ariaLabel", "FabProps", "children", "className", "direction", "hidden", "icon", "onBlur", "onClose", "onFocus", "onKeyDown", "onMouseEnter", "onMouseLeave", "onOpen", "open", "openIcon", "TransitionComponent", "transitionDuration", "TransitionProps"],
          _excluded3 = ["ref"];
        const useUtilityClasses$1 = ownerState => {
          const classes = ownerState.classes,
            open = ownerState.open,
            direction = ownerState.direction;
          const slots = {
            root: ["root", `direction${capitalize$1(direction)}`],
            fab: ["fab"],
            actions: ["actions", !open && "actionsClosed"]
          };
          return composeClasses(slots, getSpeedDialUtilityClass, classes);
        };
        function getOrientation(direction) {
          if (direction === "up" || direction === "down") {
            return "vertical";
          }
          if (direction === "right" || direction === "left") {
            return "horizontal";
          }
          return void 0;
        }
        const dialRadius = 32;
        const spacingActions = 16;
        const SpeedDialRoot = styled("div", {
          name: "MuiSpeedDial",
          slot: "Root",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.root, styles[`direction${capitalize$1(ownerState.direction)}`]];
          }
        })(({
          theme,
          ownerState
        }) => _extends$h({
          zIndex: (theme.vars || theme).zIndex.speedDial,
          display: "flex",
          alignItems: "center",
          pointerEvents: "none"
        }, ownerState.direction === "up" && {
          flexDirection: "column-reverse",
          [`& .${speedDialClasses.actions}`]: {
            flexDirection: "column-reverse",
            marginBottom: -dialRadius,
            paddingBottom: spacingActions + dialRadius
          }
        }, ownerState.direction === "down" && {
          flexDirection: "column",
          [`& .${speedDialClasses.actions}`]: {
            flexDirection: "column",
            marginTop: -dialRadius,
            paddingTop: spacingActions + dialRadius
          }
        }, ownerState.direction === "left" && {
          flexDirection: "row-reverse",
          [`& .${speedDialClasses.actions}`]: {
            flexDirection: "row-reverse",
            marginRight: -dialRadius,
            paddingRight: spacingActions + dialRadius
          }
        }, ownerState.direction === "right" && {
          flexDirection: "row",
          [`& .${speedDialClasses.actions}`]: {
            flexDirection: "row",
            marginLeft: -dialRadius,
            paddingLeft: spacingActions + dialRadius
          }
        }));
        const SpeedDialFab = styled(Fab, {
          name: "MuiSpeedDial",
          slot: "Fab",
          overridesResolver: (props, styles) => styles.fab
        })(() => ({
          pointerEvents: "auto"
        }));
        const SpeedDialActions = styled("div", {
          name: "MuiSpeedDial",
          slot: "Actions",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.actions, !ownerState.open && styles.actionsClosed];
          }
        })(({
          ownerState
        }) => _extends$h({
          display: "flex",
          pointerEvents: "auto"
        }, !ownerState.open && {
          transition: "top 0s linear 0.2s",
          pointerEvents: "none"
        }));
        const SpeedDial = /* @__PURE__ */reactExports.forwardRef(function SpeedDial2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiSpeedDial"
          });
          const theme = useTheme();
          const defaultTransitionDuration = {
            enter: theme.transitions.duration.enteringScreen,
            exit: theme.transitions.duration.leavingScreen
          };
          const ariaLabel = props.ariaLabel,
            _props$FabProps = props.FabProps,
            _props$FabProps2 = _props$FabProps === void 0 ? {} : _props$FabProps,
            origDialButtonRef = _props$FabProps2.ref,
            childrenProp = props.children,
            className = props.className,
            _props$direction2 = props.direction,
            direction = _props$direction2 === void 0 ? "up" : _props$direction2,
            _props$hidden = props.hidden,
            hidden = _props$hidden === void 0 ? false : _props$hidden,
            icon = props.icon,
            onBlur = props.onBlur,
            onClose = props.onClose,
            onFocus = props.onFocus,
            onKeyDown = props.onKeyDown,
            onMouseEnter = props.onMouseEnter,
            onMouseLeave = props.onMouseLeave,
            onOpen = props.onOpen,
            openProp = props.open,
            _props$TransitionComp2 = props.TransitionComponent,
            TransitionComponent = _props$TransitionComp2 === void 0 ? Zoom : _props$TransitionComp2,
            _props$transitionDura = props.transitionDuration,
            transitionDuration = _props$transitionDura === void 0 ? defaultTransitionDuration : _props$transitionDura,
            TransitionProps = props.TransitionProps,
            FabProps = _objectWithoutPropertiesLoose(props.FabProps, _excluded$b),
            other = _objectWithoutPropertiesLoose(props, _excluded2$1);
          const _useControlled9 = useControlled({
              controlled: openProp,
              default: false,
              name: "SpeedDial",
              state: "open"
            }),
            _useControlled10 = _slicedToArray2(_useControlled9, 2),
            open = _useControlled10[0],
            setOpenState = _useControlled10[1];
          const ownerState = _extends$h({}, props, {
            open,
            direction
          });
          const classes = useUtilityClasses$1(ownerState);
          const eventTimer = useTimeout();
          const focusedAction = reactExports.useRef(0);
          const nextItemArrowKey = reactExports.useRef();
          const actions = reactExports.useRef([]);
          actions.current = [actions.current[0]];
          const handleOwnFabRef = reactExports.useCallback(fabFef => {
            actions.current[0] = fabFef;
          }, []);
          const handleFabRef = useForkRef(origDialButtonRef, handleOwnFabRef);
          const createHandleSpeedDialActionButtonRef = (dialActionIndex, origButtonRef) => {
            return buttonRef => {
              actions.current[dialActionIndex + 1] = buttonRef;
              if (origButtonRef) {
                origButtonRef(buttonRef);
              }
            };
          };
          const handleKeyDown = event => {
            if (onKeyDown) {
              onKeyDown(event);
            }
            const key = event.key.replace("Arrow", "").toLowerCase();
            const _nextItemArrowKey$cur = nextItemArrowKey.current,
              nextItemArrowKeyCurrent = _nextItemArrowKey$cur === void 0 ? key : _nextItemArrowKey$cur;
            if (event.key === "Escape") {
              setOpenState(false);
              actions.current[0].focus();
              if (onClose) {
                onClose(event, "escapeKeyDown");
              }
              return;
            }
            if (getOrientation(key) === getOrientation(nextItemArrowKeyCurrent) && getOrientation(key) !== void 0) {
              event.preventDefault();
              const actionStep = key === nextItemArrowKeyCurrent ? 1 : -1;
              const nextAction = clamp(focusedAction.current + actionStep, 0, actions.current.length - 1);
              actions.current[nextAction].focus();
              focusedAction.current = nextAction;
              nextItemArrowKey.current = nextItemArrowKeyCurrent;
            }
          };
          reactExports.useEffect(() => {
            if (!open) {
              focusedAction.current = 0;
              nextItemArrowKey.current = void 0;
            }
          }, [open]);
          const handleClose = event => {
            if (event.type === "mouseleave" && onMouseLeave) {
              onMouseLeave(event);
            }
            if (event.type === "blur" && onBlur) {
              onBlur(event);
            }
            eventTimer.clear();
            if (event.type === "blur") {
              eventTimer.start(0, () => {
                setOpenState(false);
                if (onClose) {
                  onClose(event, "blur");
                }
              });
            } else {
              setOpenState(false);
              if (onClose) {
                onClose(event, "mouseLeave");
              }
            }
          };
          const handleClick = event => {
            if (FabProps.onClick) {
              FabProps.onClick(event);
            }
            eventTimer.clear();
            if (open) {
              setOpenState(false);
              if (onClose) {
                onClose(event, "toggle");
              }
            } else {
              setOpenState(true);
              if (onOpen) {
                onOpen(event, "toggle");
              }
            }
          };
          const handleOpen = event => {
            if (event.type === "mouseenter" && onMouseEnter) {
              onMouseEnter(event);
            }
            if (event.type === "focus" && onFocus) {
              onFocus(event);
            }
            eventTimer.clear();
            if (!open) {
              eventTimer.start(0, () => {
                setOpenState(true);
                if (onOpen) {
                  const eventMap = {
                    focus: "focus",
                    mouseenter: "mouseEnter"
                  };
                  onOpen(event, eventMap[event.type]);
                }
              });
            }
          };
          const id = ariaLabel.replace(/^[^a-z]+|[^\w:.-]+/gi, "");
          const allItems = reactExports.Children.toArray(childrenProp).filter(child => {
            return /* @__PURE__ */reactExports.isValidElement(child);
          });
          const children = allItems.map((child, index) => {
            const _child$props = child.props,
              _child$props$FabProps = _child$props.FabProps,
              _child$props$FabProps2 = _child$props$FabProps === void 0 ? {} : _child$props$FabProps,
              origButtonRef = _child$props$FabProps2.ref,
              tooltipPlacementProp = _child$props.tooltipPlacement,
              ChildFabProps = _objectWithoutPropertiesLoose(_child$props.FabProps, _excluded3);
            const tooltipPlacement = tooltipPlacementProp || (getOrientation(direction) === "vertical" ? "left" : "top");
            return /* @__PURE__ */reactExports.cloneElement(child, {
              FabProps: _extends$h({}, ChildFabProps, {
                ref: createHandleSpeedDialActionButtonRef(index, origButtonRef)
              }),
              delay: 30 * (open ? index : allItems.length - index),
              open,
              tooltipPlacement,
              id: `${id}-action-${index}`
            });
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs(SpeedDialRoot, _extends$h({
            className: clsx(classes.root, className),
            ref,
            role: "presentation",
            onKeyDown: handleKeyDown,
            onBlur: handleClose,
            onFocus: handleOpen,
            onMouseEnter: handleOpen,
            onMouseLeave: handleClose,
            ownerState
          }, other, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(TransitionComponent, _extends$h({
              in: !hidden,
              timeout: transitionDuration,
              unmountOnExit: true
            }, TransitionProps, {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(SpeedDialFab, _extends$h({
                color: "primary",
                "aria-label": ariaLabel,
                "aria-haspopup": "true",
                "aria-expanded": open,
                "aria-controls": `${id}-actions`
              }, FabProps, {
                onClick: handleClick,
                className: clsx(classes.fab, FabProps.className),
                ref: handleFabRef,
                ownerState,
                children: /* @__PURE__ */reactExports.isValidElement(icon) && isMuiElement(icon, ["SpeedDialIcon"]) ? /* @__PURE__ */reactExports.cloneElement(icon, {
                  open
                }) : icon
              }))
            })), /* @__PURE__ */jsxRuntimeExports.jsx(SpeedDialActions, {
              id: `${id}-actions`,
              role: "menu",
              "aria-orientation": getOrientation(direction),
              className: clsx(classes.actions, !open && classes.actionsClosed),
              ownerState,
              children
            })]
          }));
        });
        function getSpeedDialActionUtilityClass(slot) {
          return generateUtilityClass('MuiSpeedDialAction', slot);
        }
        const speedDialActionClasses = generateUtilityClasses('MuiSpeedDialAction', ['fab', 'fabClosed', 'staticTooltip', 'staticTooltipClosed', 'staticTooltipLabel', 'tooltipPlacementLeft', 'tooltipPlacementRight']);
        const _excluded$a = ["className", "delay", "FabProps", "icon", "id", "open", "TooltipClasses", "tooltipOpen", "tooltipPlacement", "tooltipTitle"];
        const useUtilityClasses = ownerState => {
          const open = ownerState.open,
            tooltipPlacement = ownerState.tooltipPlacement,
            classes = ownerState.classes;
          const slots = {
            fab: ["fab", !open && "fabClosed"],
            staticTooltip: ["staticTooltip", `tooltipPlacement${capitalize$1(tooltipPlacement)}`, !open && "staticTooltipClosed"],
            staticTooltipLabel: ["staticTooltipLabel"]
          };
          return composeClasses(slots, getSpeedDialActionUtilityClass, classes);
        };
        const SpeedDialActionFab = styled(Fab, {
          name: "MuiSpeedDialAction",
          slot: "Fab",
          skipVariantsResolver: false,
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.fab, !ownerState.open && styles.fabClosed];
          }
        })(({
          theme,
          ownerState
        }) => _extends$h({
          margin: 8,
          color: (theme.vars || theme).palette.text.secondary,
          backgroundColor: (theme.vars || theme).palette.background.paper,
          "&:hover": {
            backgroundColor: theme.vars ? theme.vars.palette.SpeedDialAction.fabHoverBg : emphasize_1(theme.palette.background.paper, 0.15)
          },
          transition: `${theme.transitions.create("transform", {
            duration: theme.transitions.duration.shorter
          })}, opacity 0.8s`,
          opacity: 1
        }, !ownerState.open && {
          opacity: 0,
          transform: "scale(0)"
        }));
        const SpeedDialActionStaticTooltip = styled("span", {
          name: "MuiSpeedDialAction",
          slot: "StaticTooltip",
          overridesResolver: (props, styles) => {
            const ownerState = props.ownerState;
            return [styles.staticTooltip, !ownerState.open && styles.staticTooltipClosed, styles[`tooltipPlacement${capitalize$1(ownerState.tooltipPlacement)}`]];
          }
        })(({
          theme,
          ownerState
        }) => ({
          position: "relative",
          display: "flex",
          alignItems: "center",
          [`& .${speedDialActionClasses.staticTooltipLabel}`]: _extends$h({
            transition: theme.transitions.create(["transform", "opacity"], {
              duration: theme.transitions.duration.shorter
            }),
            opacity: 1
          }, !ownerState.open && {
            opacity: 0,
            transform: "scale(0.5)"
          }, ownerState.tooltipPlacement === "left" && {
            transformOrigin: "100% 50%",
            right: "100%",
            marginRight: 8
          }, ownerState.tooltipPlacement === "right" && {
            transformOrigin: "0% 50%",
            left: "100%",
            marginLeft: 8
          })
        }));
        const SpeedDialActionStaticTooltipLabel = styled("span", {
          name: "MuiSpeedDialAction",
          slot: "StaticTooltipLabel",
          overridesResolver: (props, styles) => styles.staticTooltipLabel
        })(({
          theme
        }) => _extends$h({
          position: "absolute"
        }, theme.typography.body1, {
          backgroundColor: (theme.vars || theme).palette.background.paper,
          borderRadius: (theme.vars || theme).shape.borderRadius,
          boxShadow: (theme.vars || theme).shadows[1],
          color: (theme.vars || theme).palette.text.secondary,
          padding: "4px 16px",
          wordBreak: "keep-all"
        }));
        const SpeedDialAction = /* @__PURE__ */reactExports.forwardRef(function SpeedDialAction2(inProps, ref) {
          const props = useDefaultProps({
            props: inProps,
            name: "MuiSpeedDialAction"
          });
          const className = props.className,
            _props$delay = props.delay,
            delay = _props$delay === void 0 ? 0 : _props$delay,
            _props$FabProps3 = props.FabProps,
            FabProps = _props$FabProps3 === void 0 ? {} : _props$FabProps3,
            icon = props.icon,
            id = props.id,
            open = props.open,
            TooltipClasses = props.TooltipClasses,
            _props$tooltipOpen = props.tooltipOpen,
            tooltipOpenProp = _props$tooltipOpen === void 0 ? false : _props$tooltipOpen,
            _props$tooltipPlaceme = props.tooltipPlacement,
            tooltipPlacement = _props$tooltipPlaceme === void 0 ? "left" : _props$tooltipPlaceme,
            tooltipTitle = props.tooltipTitle,
            other = _objectWithoutPropertiesLoose(props, _excluded$a);
          const ownerState = _extends$h({}, props, {
            tooltipPlacement
          });
          const classes = useUtilityClasses(ownerState);
          const _reactExports$useStat17 = reactExports.useState(tooltipOpenProp),
            _reactExports$useStat18 = _slicedToArray2(_reactExports$useStat17, 2),
            tooltipOpen = _reactExports$useStat18[0],
            setTooltipOpen = _reactExports$useStat18[1];
          const handleTooltipClose = () => {
            setTooltipOpen(false);
          };
          const handleTooltipOpen = () => {
            setTooltipOpen(true);
          };
          const transitionStyle = {
            transitionDelay: `${delay}ms`
          };
          const fab = /* @__PURE__ */jsxRuntimeExports.jsx(SpeedDialActionFab, _extends$h({
            size: "small",
            className: clsx(classes.fab, className),
            tabIndex: -1,
            role: "menuitem",
            ownerState
          }, FabProps, {
            style: _extends$h({}, transitionStyle, FabProps.style),
            children: icon
          }));
          if (tooltipOpenProp) {
            return /* @__PURE__ */jsxRuntimeExports.jsxs(SpeedDialActionStaticTooltip, _extends$h({
              id,
              ref,
              className: classes.staticTooltip,
              ownerState
            }, other, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(SpeedDialActionStaticTooltipLabel, {
                style: transitionStyle,
                id: `${id}-label`,
                className: classes.staticTooltipLabel,
                ownerState,
                children: tooltipTitle
              }), /* @__PURE__ */reactExports.cloneElement(fab, {
                "aria-labelledby": `${id}-label`
              })]
            }));
          }
          if (!open && tooltipOpen) {
            setTooltipOpen(false);
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(Tooltip, _extends$h({
            id,
            ref,
            title: tooltipTitle,
            placement: tooltipPlacement,
            onClose: handleTooltipClose,
            onOpen: handleTooltipOpen,
            open: open && tooltipOpen,
            classes: TooltipClasses
          }, other, {
            children: fab
          }));
        });

        /**
         * useDragLayer Hook
         * @param collector The property collector
         */
        function useDragLayer(collect) {
          const dragDropManager = useDragDropManager();
          const monitor = dragDropManager.getMonitor();
          const _useCollector = useCollector(monitor, collect),
            _useCollector2 = _slicedToArray2(_useCollector, 2),
            collected = _useCollector2[0],
            updateCollected = _useCollector2[1];
          reactExports.useEffect(() => monitor.subscribeToOffsetChange(updateCollected));
          reactExports.useEffect(() => monitor.subscribeToStateChange(updateCollected));
          return collected;
        }
        const Cancel = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2m5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12z"
        }), 'Cancel');
        const EditOutlined = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "m14.06 9.02.92.92L5.92 19H5v-.92zM17.66 3c-.25 0-.51.1-.7.29l-1.83 1.83 3.75 3.75 1.83-1.83c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.2-.2-.45-.29-.71-.29m-3.6 3.19L3 17.25V21h3.75L17.81 9.94z"
        }), 'EditOutlined');
        const Palette = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M12 2C6.49 2 2 6.49 2 12s4.49 10 10 10c1.38 0 2.5-1.12 2.5-2.5 0-.61-.23-1.2-.64-1.67-.08-.1-.13-.21-.13-.33 0-.28.22-.5.5-.5H16c3.31 0 6-2.69 6-6 0-4.96-4.49-9-10-9m5.5 11c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5m-3-4c-.83 0-1.5-.67-1.5-1.5S13.67 6 14.5 6s1.5.67 1.5 1.5S15.33 9 14.5 9M5 11.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5S7.33 13 6.5 13 5 12.33 5 11.5m6-4c0 .83-.67 1.5-1.5 1.5S8 8.33 8 7.5 8.67 6 9.5 6s1.5.67 1.5 1.5"
        }), 'Palette');
        const noPadding$1 = "_noPadding_1ii70_1";
        const addRow = "_addRow_1ii70_5";
        const addColumn = "_addColumn_1ii70_9";
        const addIcon = "_addIcon_1ii70_13";
        const svgContainer$1 = "_svgContainer_1ii70_23";
        const addButton = "_addButton_1ii70_31";
        const styles$L = {
          noPadding: noPadding$1,
          addRow: addRow,
          addColumn: addColumn,
          addIcon: addIcon,
          svgContainer: svgContainer$1,
          addButton: addButton
        };
        const mainContainer = "_mainContainer_as1f9_1";
        const updateButtons = "_updateButtons_as1f9_5";
        const save = "_save_as1f9_14";
        const header = "_header_as1f9_18";
        const styles$K = {
          mainContainer: mainContainer,
          updateButtons: updateButtons,
          save: save,
          header: header
        };
        const groupEmptyHint$1 = "_groupEmptyHint_1pku9_2";
        const groupEmptyHintHover$1 = "_groupEmptyHintHover_1pku9_14";
        const footer = "_footer_1pku9_18";
        const contentPanel = "_contentPanel_1pku9_22";
        const cardImage = "_cardImage_1pku9_30";
        const customScrollBar = "_customScrollBar_1pku9_38";
        const virtuosoStyle = "_virtuosoStyle_1pku9_42";
        const cardMediaContent = "_cardMediaContent_1pku9_47";
        const buttonContainer$2 = "_buttonContainer_1pku9_55";
        const button = "_button_1pku9_55";
        const styles$J = {
          groupEmptyHint: groupEmptyHint$1,
          groupEmptyHintHover: groupEmptyHintHover$1,
          footer: footer,
          contentPanel: contentPanel,
          cardImage: cardImage,
          customScrollBar: customScrollBar,
          virtuosoStyle: virtuosoStyle,
          cardMediaContent: cardMediaContent,
          buttonContainer: buttonContainer$2,
          button: button
        };
        const errorDisplay$2 = "_errorDisplay_1joy4_1";
        const clickable = "_clickable_1joy4_10";
        const styles$I = {
          errorDisplay: errorDisplay$2,
          clickable: clickable
        };
        var ErrorOutline = {};
        var _interopRequireDefault$v = interopRequireDefaultExports;
        Object.defineProperty(ErrorOutline, "__esModule", {
          value: true
        });
        var default_1$n = ErrorOutline.default = void 0;
        var _createSvgIcon$n = _interopRequireDefault$v(requireCreateSvgIcon());
        var _jsxRuntime$n = jsxRuntimeExports;
        default_1$n = ErrorOutline.default = (0, _createSvgIcon$n.default)(/*#__PURE__*/(0, _jsxRuntime$n.jsx)("path", {
          d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2M12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8"
        }), 'ErrorOutline');
        function ErrorDisplay(props) {
          const _useTranslation = useTranslation("design"),
            t = _useTranslation.t;
          const dispatch = useDispatch();
          const selectDesignState = state => state.designState[props.code] || {};
          const selectErrorsAndInstructions = createSelector([selectDesignState], designState => {
            var _designState$instruct;
            const instructionsWithErrors = (_designState$instruct = designState.instructionList) === null || _designState$instruct === void 0 ? void 0 : _designState$instruct.filter(instruction => {
              var _instruction$errors;
              return ((_instruction$errors = instruction.errors) === null || _instruction$errors === void 0 ? void 0 : _instruction$errors.length) > 0;
            });
            return {
              errors: designState.errors,
              designErrors: designState.designErrors,
              instructions: instructionsWithErrors !== null && instructionsWithErrors !== void 0 && instructionsWithErrors.length ? instructionsWithErrors : void 0
            };
          });
          const _useSelector = useSelector(selectErrorsAndInstructions),
            errors = _useSelector.errors,
            designErrors = _useSelector.designErrors,
            instructions = _useSelector.instructions;
          const hasErrors = (errors === null || errors === void 0 ? void 0 : errors.length) > 0 || (designErrors === null || designErrors === void 0 ? void 0 : designErrors.length) > 0 || (instructions === null || instructions === void 0 ? void 0 : instructions.length) > 0;
          const type = useSelector(state => {
            var _state$designState$pr;
            return props.code == "Survey" ? "" : isGroup(props.code) ? ((_state$designState$pr = state.designState[props.code].groupType) === null || _state$designState$pr === void 0 ? void 0 : _state$designState$pr.toLowerCase()) || "group" : state.designState[props.code].type;
          });
          const onErrClick = instruction => {
            if (instruction.code === "conditional_relevance") {
              dispatch(setup({
                code: props.code,
                rules: setupOptions(type),
                highlighted: "relevance",
                expanded: ["relevance"]
              }));
            } else if (instruction.code === "random_group" || instruction.code === "priority_groups") {
              if (props.code == "Survey") {
                dispatch(setup(_objectSpread3(_objectSpread3({}, surveySetup$1), {}, {
                  highlighted: "random"
                })));
              } else {
                dispatch(setup({
                  code: props.code,
                  rules: setupOptions(type),
                  highlighted: "random",
                  expanded: ["random"]
                }));
              }
            } else if (instruction.code.startsWith("skip_to")) {
              dispatch(setup({
                code: props.code,
                rules: setupOptions(type),
                highlighted: "skip_logic",
                expanded: ["skip_logic"]
              }));
            }
            return "";
          };
          const isClickable = instruction => {
            return instruction.code === "conditional_relevance" || instruction.code === "random_group" || instruction.code === "priority_groups" || instruction.code.startsWith("skip_to");
          };
          return hasErrors ? /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            className: styles$I.errorDisplay,
            children: [errors && errors.map(el => {
              return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$o, {
                  style: {
                    verticalAlign: "middle"
                  }
                }), mapComponentError(props.code, el, t)]
              }, el);
            }), designErrors && designErrors.map(el => {
              return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$o, {
                  style: {
                    verticalAlign: "middle"
                  }
                }), el.message]
              }, el.code);
            }), instructions && instructions.map(el => {
              return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                className: isClickable(el) ? styles$I.clickable : "",
                onClick: () => onErrClick(el),
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$n, {
                  style: {
                    verticalAlign: "middle"
                  }
                }), mapInstructionError(el, t)]
              }, el.code);
            })]
          }) : /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
        }
        const mapComponentError = (code, error, t) => {
          if (error === "EMPTY_PARENT") {
            return t("err_empty_parent", {
              component_name: componentName(code, t),
              child_name: componentChildName(code, t)
            });
          } else if (error === "DUPLICATE_CODE") {
            return t("err_duplicate_code"), {
              component_name: componentName(code, t)
            };
          } else if (error === "NO_END_GROUP") {
            return t("err_no_end_group");
          } else if (error === "MISPLACED_END_GROUP") {
            return t("err_misplaced_end_group");
          } else if (error === "MISPLACED_WELCOME_GROUP") {
            return t("err_misplaced_welcome_group");
          }
          return "";
        };
        const mapInstructionError = (instruction, t) => {
          if (instruction.code === "value" && instruction.errors[0].name == "InvalidInstructionInEndGroup") {
            return t("err_value_in_end_group");
          } else if (instruction.code === "conditional_relevance") {
            return t("err_relevance");
          } else if (instruction.code === "random_group") {
            return t("err_random");
          } else if (instruction.code === "priority_groups") {
            return t("err_priority");
          } else if (instruction.code.startsWith("reference")) {
            return /* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
              t,
              values: {
                codes: instruction.errors.map(error => {
                  var _error$dependency;
                  return (_error$dependency = error.dependency) === null || _error$dependency === void 0 ? void 0 : _error$dependency.componentCode;
                }).join(", "),
                lang: instruction.lang
              },
              i18nKey: "err_reference"
            });
          } else if (instruction.code.startsWith("skip_to")) {
            return t("err_skip");
          }
          return "";
        };
        const componentName = (code, t) => {
          if (code == "Survey") {
            return t("survey");
          } else if (isQuestion(code)) {
            return t("question");
          } else if (isGroup(code)) {
            return t("group");
          }
          return t("option");
        };
        const componentChildName = (code, t) => {
          if (isGroup(code)) {
            return t("question");
          } else if (code == "Survey") {
            return t("group");
          }
          return t("option");
        };
        const ErrorDisplay$1 = reactExports.memo(ErrorDisplay);
        var ViewCompact = {};
        var _interopRequireDefault$u = interopRequireDefaultExports;
        Object.defineProperty(ViewCompact, "__esModule", {
          value: true
        });
        var default_1$m = ViewCompact.default = void 0;
        var _createSvgIcon$m = _interopRequireDefault$u(requireCreateSvgIcon());
        var _jsxRuntime$m = jsxRuntimeExports;
        default_1$m = ViewCompact.default = (0, _createSvgIcon$m.default)(/*#__PURE__*/(0, _jsxRuntime$m.jsx)("path", {
          d: "M4 18h2.5v-2.5H4zm0-4.75h2.5v-2.5H4zM4 8.5h2.5V6H4zM17.5 6v2.5H20V6zM13 8.5h2.5V6H13zm4.5 9.5H20v-2.5h-2.5zm0-4.75H20v-2.5h-2.5zM8.5 18H11v-2.5H8.5zm4.5 0h2.5v-2.5H13zM8.5 8.5H11V6H8.5zm4.5 4.75h2.5v-2.5H13zm-4.5 0H11v-2.5H8.5z"
        }), 'ViewCompact');
        const textDescriptionContent = "_textDescriptionContent_o9cn8_1";
        const moveBox$1 = "_moveBox_o9cn8_7";
        const groupQuestion = "_groupQuestion_o9cn8_13";
        const titleContainer = "_titleContainer_o9cn8_22";
        const titleQuestion = "_titleQuestion_o9cn8_29";
        const iconBox = "_iconBox_o9cn8_39";
        const actionToolbarVisible$1 = "_actionToolbarVisible_o9cn8_59";
        const fadeInMoveRight$1 = "_fadeInMoveRight_o9cn8_1";
        const contentContainer$1 = "_contentContainer_o9cn8_64";
        const styles$H = {
          textDescriptionContent: textDescriptionContent,
          moveBox: moveBox$1,
          groupQuestion: groupQuestion,
          titleContainer: titleContainer,
          titleQuestion: titleQuestion,
          iconBox: iconBox,
          actionToolbarVisible: actionToolbarVisible$1,
          fadeInMoveRight: fadeInMoveRight$1,
          contentContainer: contentContainer$1
        };
        const fullWidth = "_fullWidth_1dvff_1";
        const toolbarClass = "_toolbarClass_1dvff_6";
        const noPadding = "_noPadding_1dvff_12";
        const placeholder$2 = "_placeholder_1dvff_25";
        const styles$G = {
          fullWidth: fullWidth,
          toolbarClass: toolbarClass,
          "rdw-editor-toolbar": "_rdw-editor-toolbar_1dvff_6",
          noPadding: noPadding,
          placeholder: placeholder$2
        };

        /**
         * Removes all key-value entries from the list cache.
         *
         * @private
         * @name clear
         * @memberOf ListCache
         */

        function listCacheClear$2() {
          this.__data__ = [];
          this.size = 0;
        }
        var _listCacheClear = listCacheClear$2;

        /**
         * Performs a
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */

        function eq$6(value, other) {
          return value === other || value !== value && other !== other;
        }
        var eq_1 = eq$6;
        var eq$5 = eq_1;

        /**
         * Gets the index at which the `key` is found in `array` of key-value pairs.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} key The key to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function assocIndexOf$5(array, key) {
          var length = array.length;
          while (length--) {
            if (eq$5(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        var _assocIndexOf = assocIndexOf$5;
        var assocIndexOf$4 = _assocIndexOf;

        /** Used for built-in method references. */
        var arrayProto$1 = Array.prototype;

        /** Built-in value references. */
        var splice$1 = arrayProto$1.splice;

        /**
         * Removes `key` and its value from the list cache.
         *
         * @private
         * @name delete
         * @memberOf ListCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function listCacheDelete$2(key) {
          var data = this.__data__,
            index = assocIndexOf$4(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice$1.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        var _listCacheDelete = listCacheDelete$2;
        var assocIndexOf$3 = _assocIndexOf;

        /**
         * Gets the list cache value for `key`.
         *
         * @private
         * @name get
         * @memberOf ListCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function listCacheGet$2(key) {
          var data = this.__data__,
            index = assocIndexOf$3(data, key);
          return index < 0 ? undefined : data[index][1];
        }
        var _listCacheGet = listCacheGet$2;
        var assocIndexOf$2 = _assocIndexOf;

        /**
         * Checks if a list cache value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf ListCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function listCacheHas$2(key) {
          return assocIndexOf$2(this.__data__, key) > -1;
        }
        var _listCacheHas = listCacheHas$2;
        var assocIndexOf$1 = _assocIndexOf;

        /**
         * Sets the list cache `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf ListCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the list cache instance.
         */
        function listCacheSet$2(key, value) {
          var data = this.__data__,
            index = assocIndexOf$1(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        var _listCacheSet = listCacheSet$2;
        var listCacheClear$1 = _listCacheClear,
          listCacheDelete$1 = _listCacheDelete,
          listCacheGet$1 = _listCacheGet,
          listCacheHas$1 = _listCacheHas,
          listCacheSet$1 = _listCacheSet;

        /**
         * Creates an list cache object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function ListCache$5(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        // Add methods to `ListCache`.
        ListCache$5.prototype.clear = listCacheClear$1;
        ListCache$5.prototype['delete'] = listCacheDelete$1;
        ListCache$5.prototype.get = listCacheGet$1;
        ListCache$5.prototype.has = listCacheHas$1;
        ListCache$5.prototype.set = listCacheSet$1;
        var _ListCache = ListCache$5;
        var ListCache$4 = _ListCache;

        /**
         * Removes all key-value entries from the stack.
         *
         * @private
         * @name clear
         * @memberOf Stack
         */
        function stackClear$2() {
          this.__data__ = new ListCache$4();
          this.size = 0;
        }
        var _stackClear = stackClear$2;

        /**
         * Removes `key` and its value from the stack.
         *
         * @private
         * @name delete
         * @memberOf Stack
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */

        function stackDelete$2(key) {
          var data = this.__data__,
            result = data['delete'](key);
          this.size = data.size;
          return result;
        }
        var _stackDelete = stackDelete$2;

        /**
         * Gets the stack value for `key`.
         *
         * @private
         * @name get
         * @memberOf Stack
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */

        function stackGet$2(key) {
          return this.__data__.get(key);
        }
        var _stackGet = stackGet$2;

        /**
         * Checks if a stack value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Stack
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */

        function stackHas$2(key) {
          return this.__data__.has(key);
        }
        var _stackHas = stackHas$2;

        /** Detect free variable `global` from Node.js. */

        var freeGlobal$2 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
        var _freeGlobal = freeGlobal$2;
        var freeGlobal$1 = _freeGlobal;

        /** Detect free variable `self`. */
        var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

        /** Used as a reference to the global object. */
        var root$a = freeGlobal$1 || freeSelf$1 || Function('return this')();
        var _root = root$a;
        var root$9 = _root;

        /** Built-in value references. */
        var Symbol$8 = root$9.Symbol;
        var _Symbol = Symbol$8;
        var Symbol$7 = _Symbol;

        /** Used for built-in method references. */
        var objectProto$u = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$p = objectProto$u.hasOwnProperty;

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString$3 = objectProto$u.toString;

        /** Built-in value references. */
        var symToStringTag$3 = Symbol$7 ? Symbol$7.toStringTag : undefined;

        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */
        function getRawTag$2(value) {
          var isOwn = hasOwnProperty$p.call(value, symToStringTag$3),
            tag = value[symToStringTag$3];
          try {
            value[symToStringTag$3] = undefined;
            var unmasked = true;
          } catch (e) {}
          var result = nativeObjectToString$3.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag$3] = tag;
            } else {
              delete value[symToStringTag$3];
            }
          }
          return result;
        }
        var _getRawTag = getRawTag$2;

        /** Used for built-in method references. */

        var objectProto$t = Object.prototype;

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString$2 = objectProto$t.toString;

        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */
        function objectToString$2(value) {
          return nativeObjectToString$2.call(value);
        }
        var _objectToString = objectToString$2;
        var Symbol$6 = _Symbol,
          getRawTag$1 = _getRawTag,
          objectToString$1 = _objectToString;

        /** `Object#toString` result references. */
        var nullTag$1 = '[object Null]',
          undefinedTag$1 = '[object Undefined]';

        /** Built-in value references. */
        var symToStringTag$2 = Symbol$6 ? Symbol$6.toStringTag : undefined;

        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        function baseGetTag$8(value) {
          if (value == null) {
            return value === undefined ? undefinedTag$1 : nullTag$1;
          }
          return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$1(value) : objectToString$1(value);
        }
        var _baseGetTag = baseGetTag$8;

        /**
         * Checks if `value` is the
         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */

        function isObject$k(value) {
          var type = typeof value;
          return value != null && (type == 'object' || type == 'function');
        }
        var isObject_1 = isObject$k;
        var baseGetTag$7 = _baseGetTag,
          isObject$j = isObject_1;

        /** `Object#toString` result references. */
        var asyncTag$1 = '[object AsyncFunction]',
          funcTag$4 = '[object Function]',
          genTag$2 = '[object GeneratorFunction]',
          proxyTag$1 = '[object Proxy]';

        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction$6(value) {
          if (!isObject$j(value)) {
            return false;
          }
          // The use of `Object#toString` avoids issues with the `typeof` operator
          // in Safari 9 which returns 'object' for typed arrays and other constructors.
          var tag = baseGetTag$7(value);
          return tag == funcTag$4 || tag == genTag$2 || tag == asyncTag$1 || tag == proxyTag$1;
        }
        var isFunction_1 = isFunction$6;
        var root$8 = _root;

        /** Used to detect overreaching core-js shims. */
        var coreJsData$2 = root$8['__core-js_shared__'];
        var _coreJsData = coreJsData$2;
        var coreJsData$1 = _coreJsData;

        /** Used to detect methods masquerading as native. */
        var maskSrcKey$1 = function () {
          var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
          return uid ? 'Symbol(src)_1.' + uid : '';
        }();

        /**
         * Checks if `func` has its source masked.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
         */
        function isMasked$2(func) {
          return !!maskSrcKey$1 && maskSrcKey$1 in func;
        }
        var _isMasked = isMasked$2;

        /** Used for built-in method references. */

        var funcProto$5 = Function.prototype;

        /** Used to resolve the decompiled source of functions. */
        var funcToString$5 = funcProto$5.toString;

        /**
         * Converts `func` to its source code.
         *
         * @private
         * @param {Function} func The function to convert.
         * @returns {string} Returns the source code.
         */
        function toSource$3(func) {
          if (func != null) {
            try {
              return funcToString$5.call(func);
            } catch (e) {}
            try {
              return func + '';
            } catch (e) {}
          }
          return '';
        }
        var _toSource = toSource$3;
        var isFunction$5 = isFunction_1,
          isMasked$1 = _isMasked,
          isObject$i = isObject_1,
          toSource$2 = _toSource;

        /**
         * Used to match `RegExp`
         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
         */
        var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;

        /** Used to detect host constructors (Safari). */
        var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;

        /** Used for built-in method references. */
        var funcProto$4 = Function.prototype,
          objectProto$s = Object.prototype;

        /** Used to resolve the decompiled source of functions. */
        var funcToString$4 = funcProto$4.toString;

        /** Used to check objects for own properties. */
        var hasOwnProperty$o = objectProto$s.hasOwnProperty;

        /** Used to detect if a method is native. */
        var reIsNative$1 = RegExp('^' + funcToString$4.call(hasOwnProperty$o).replace(reRegExpChar$1, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

        /**
         * The base implementation of `_.isNative` without bad shim checks.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         */
        function baseIsNative$2(value) {
          if (!isObject$i(value) || isMasked$1(value)) {
            return false;
          }
          var pattern = isFunction$5(value) ? reIsNative$1 : reIsHostCtor$1;
          return pattern.test(toSource$2(value));
        }
        var _baseIsNative = baseIsNative$2;

        /**
         * Gets the value at `key` of `object`.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */

        function getValue$3(object, key) {
          return object == null ? undefined : object[key];
        }
        var _getValue = getValue$3;
        var baseIsNative$1 = _baseIsNative,
          getValue$2 = _getValue;

        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative$8(object, key) {
          var value = getValue$2(object, key);
          return baseIsNative$1(value) ? value : undefined;
        }
        var _getNative = getNative$8;
        var getNative$7 = _getNative,
          root$7 = _root;

        /* Built-in method references that are verified to be native. */
        var Map$6 = getNative$7(root$7, 'Map');
        var _Map = Map$6;
        var getNative$6 = _getNative;

        /* Built-in method references that are verified to be native. */
        var nativeCreate$5 = getNative$6(Object, 'create');
        var _nativeCreate = nativeCreate$5;
        var nativeCreate$4 = _nativeCreate;

        /**
         * Removes all key-value entries from the hash.
         *
         * @private
         * @name clear
         * @memberOf Hash
         */
        function hashClear$2() {
          this.__data__ = nativeCreate$4 ? nativeCreate$4(null) : {};
          this.size = 0;
        }
        var _hashClear = hashClear$2;

        /**
         * Removes `key` and its value from the hash.
         *
         * @private
         * @name delete
         * @memberOf Hash
         * @param {Object} hash The hash to modify.
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */

        function hashDelete$2(key) {
          var result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }
        var _hashDelete = hashDelete$2;
        var nativeCreate$3 = _nativeCreate;

        /** Used to stand-in for `undefined` hash values. */
        var HASH_UNDEFINED$5 = '__lodash_hash_undefined__';

        /** Used for built-in method references. */
        var objectProto$r = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$n = objectProto$r.hasOwnProperty;

        /**
         * Gets the hash value for `key`.
         *
         * @private
         * @name get
         * @memberOf Hash
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function hashGet$2(key) {
          var data = this.__data__;
          if (nativeCreate$3) {
            var result = data[key];
            return result === HASH_UNDEFINED$5 ? undefined : result;
          }
          return hasOwnProperty$n.call(data, key) ? data[key] : undefined;
        }
        var _hashGet = hashGet$2;
        var nativeCreate$2 = _nativeCreate;

        /** Used for built-in method references. */
        var objectProto$q = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$m = objectProto$q.hasOwnProperty;

        /**
         * Checks if a hash value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Hash
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function hashHas$2(key) {
          var data = this.__data__;
          return nativeCreate$2 ? data[key] !== undefined : hasOwnProperty$m.call(data, key);
        }
        var _hashHas = hashHas$2;
        var nativeCreate$1 = _nativeCreate;

        /** Used to stand-in for `undefined` hash values. */
        var HASH_UNDEFINED$4 = '__lodash_hash_undefined__';

        /**
         * Sets the hash `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Hash
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the hash instance.
         */
        function hashSet$2(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate$1 && value === undefined ? HASH_UNDEFINED$4 : value;
          return this;
        }
        var _hashSet = hashSet$2;
        var hashClear$1 = _hashClear,
          hashDelete$1 = _hashDelete,
          hashGet$1 = _hashGet,
          hashHas$1 = _hashHas,
          hashSet$1 = _hashSet;

        /**
         * Creates a hash object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Hash$2(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        // Add methods to `Hash`.
        Hash$2.prototype.clear = hashClear$1;
        Hash$2.prototype['delete'] = hashDelete$1;
        Hash$2.prototype.get = hashGet$1;
        Hash$2.prototype.has = hashHas$1;
        Hash$2.prototype.set = hashSet$1;
        var _Hash = Hash$2;
        var Hash$1 = _Hash,
          ListCache$3 = _ListCache,
          Map$5 = _Map;

        /**
         * Removes all key-value entries from the map.
         *
         * @private
         * @name clear
         * @memberOf MapCache
         */
        function mapCacheClear$2() {
          this.size = 0;
          this.__data__ = {
            'hash': new Hash$1(),
            'map': new (Map$5 || ListCache$3)(),
            'string': new Hash$1()
          };
        }
        var _mapCacheClear = mapCacheClear$2;

        /**
         * Checks if `value` is suitable for use as unique object key.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
         */

        function isKeyable$2(value) {
          var type = typeof value;
          return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
        }
        var _isKeyable = isKeyable$2;
        var isKeyable$1 = _isKeyable;

        /**
         * Gets the data for `map`.
         *
         * @private
         * @param {Object} map The map to query.
         * @param {string} key The reference key.
         * @returns {*} Returns the map data.
         */
        function getMapData$5(map, key) {
          var data = map.__data__;
          return isKeyable$1(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
        }
        var _getMapData = getMapData$5;
        var getMapData$4 = _getMapData;

        /**
         * Removes `key` and its value from the map.
         *
         * @private
         * @name delete
         * @memberOf MapCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function mapCacheDelete$2(key) {
          var result = getMapData$4(this, key)['delete'](key);
          this.size -= result ? 1 : 0;
          return result;
        }
        var _mapCacheDelete = mapCacheDelete$2;
        var getMapData$3 = _getMapData;

        /**
         * Gets the map value for `key`.
         *
         * @private
         * @name get
         * @memberOf MapCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function mapCacheGet$2(key) {
          return getMapData$3(this, key).get(key);
        }
        var _mapCacheGet = mapCacheGet$2;
        var getMapData$2 = _getMapData;

        /**
         * Checks if a map value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf MapCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function mapCacheHas$2(key) {
          return getMapData$2(this, key).has(key);
        }
        var _mapCacheHas = mapCacheHas$2;
        var getMapData$1 = _getMapData;

        /**
         * Sets the map `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf MapCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the map cache instance.
         */
        function mapCacheSet$2(key, value) {
          var data = getMapData$1(this, key),
            size = data.size;
          data.set(key, value);
          this.size += data.size == size ? 0 : 1;
          return this;
        }
        var _mapCacheSet = mapCacheSet$2;
        var mapCacheClear$1 = _mapCacheClear,
          mapCacheDelete$1 = _mapCacheDelete,
          mapCacheGet$1 = _mapCacheGet,
          mapCacheHas$1 = _mapCacheHas,
          mapCacheSet$1 = _mapCacheSet;

        /**
         * Creates a map cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function MapCache$4(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        // Add methods to `MapCache`.
        MapCache$4.prototype.clear = mapCacheClear$1;
        MapCache$4.prototype['delete'] = mapCacheDelete$1;
        MapCache$4.prototype.get = mapCacheGet$1;
        MapCache$4.prototype.has = mapCacheHas$1;
        MapCache$4.prototype.set = mapCacheSet$1;
        var _MapCache = MapCache$4;
        var ListCache$2 = _ListCache,
          Map$4 = _Map,
          MapCache$3 = _MapCache;

        /** Used as the size to enable large array optimizations. */
        var LARGE_ARRAY_SIZE$1 = 200;

        /**
         * Sets the stack `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Stack
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the stack cache instance.
         */
        function stackSet$2(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache$2) {
            var pairs = data.__data__;
            if (!Map$4 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache$3(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        var _stackSet = stackSet$2;
        var ListCache$1 = _ListCache,
          stackClear$1 = _stackClear,
          stackDelete$1 = _stackDelete,
          stackGet$1 = _stackGet,
          stackHas$1 = _stackHas,
          stackSet$1 = _stackSet;

        /**
         * Creates a stack cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Stack$6(entries) {
          var data = this.__data__ = new ListCache$1(entries);
          this.size = data.size;
        }

        // Add methods to `Stack`.
        Stack$6.prototype.clear = stackClear$1;
        Stack$6.prototype['delete'] = stackDelete$1;
        Stack$6.prototype.get = stackGet$1;
        Stack$6.prototype.has = stackHas$1;
        Stack$6.prototype.set = stackSet$1;
        var _Stack = Stack$6;

        /** Used to stand-in for `undefined` hash values. */

        var HASH_UNDEFINED$3 = '__lodash_hash_undefined__';

        /**
         * Adds `value` to the array cache.
         *
         * @private
         * @name add
         * @memberOf SetCache
         * @alias push
         * @param {*} value The value to cache.
         * @returns {Object} Returns the cache instance.
         */
        function setCacheAdd$2(value) {
          this.__data__.set(value, HASH_UNDEFINED$3);
          return this;
        }
        var _setCacheAdd = setCacheAdd$2;

        /**
         * Checks if `value` is in the array cache.
         *
         * @private
         * @name has
         * @memberOf SetCache
         * @param {*} value The value to search for.
         * @returns {number} Returns `true` if `value` is found, else `false`.
         */

        function setCacheHas$2(value) {
          return this.__data__.has(value);
        }
        var _setCacheHas = setCacheHas$2;
        var MapCache$2 = _MapCache,
          setCacheAdd$1 = _setCacheAdd,
          setCacheHas$1 = _setCacheHas;

        /**
         *
         * Creates an array cache object to store unique values.
         *
         * @private
         * @constructor
         * @param {Array} [values] The values to cache.
         */
        function SetCache$2(values) {
          var index = -1,
            length = values == null ? 0 : values.length;
          this.__data__ = new MapCache$2();
          while (++index < length) {
            this.add(values[index]);
          }
        }

        // Add methods to `SetCache`.
        SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd$1;
        SetCache$2.prototype.has = setCacheHas$1;
        var _SetCache = SetCache$2;

        /**
         * A specialized version of `_.some` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */

        function arraySome$2(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        var _arraySome = arraySome$2;

        /**
         * Checks if a `cache` value for `key` exists.
         *
         * @private
         * @param {Object} cache The cache to query.
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */

        function cacheHas$2(cache, key) {
          return cache.has(key);
        }
        var _cacheHas = cacheHas$2;
        var SetCache$1 = _SetCache,
          arraySome$1 = _arraySome,
          cacheHas$1 = _cacheHas;

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$b = 1,
          COMPARE_UNORDERED_FLAG$7 = 2;

        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `array` and `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays$3(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$b,
            arrLength = array.length,
            othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          // Check that cyclic values are equal.
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1,
            result = true,
            seen = bitmask & COMPARE_UNORDERED_FLAG$7 ? new SetCache$1() : undefined;
          stack.set(array, other);
          stack.set(other, array);

          // Ignore non-index properties.
          while (++index < arrLength) {
            var arrValue = array[index],
              othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (seen) {
              if (!arraySome$1(other, function (othValue, othIndex) {
                if (!cacheHas$1(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result = false;
              break;
            }
          }
          stack['delete'](array);
          stack['delete'](other);
          return result;
        }
        var _equalArrays = equalArrays$3;
        var root$6 = _root;

        /** Built-in value references. */
        var Uint8Array$4 = root$6.Uint8Array;
        var _Uint8Array = Uint8Array$4;

        /**
         * Converts `map` to its key-value pairs.
         *
         * @private
         * @param {Object} map The map to convert.
         * @returns {Array} Returns the key-value pairs.
         */

        function mapToArray$2(map) {
          var index = -1,
            result = Array(map.size);
          map.forEach(function (value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        var _mapToArray = mapToArray$2;

        /**
         * Converts `set` to an array of its values.
         *
         * @private
         * @param {Object} set The set to convert.
         * @returns {Array} Returns the values.
         */

        function setToArray$2(set) {
          var index = -1,
            result = Array(set.size);
          set.forEach(function (value) {
            result[++index] = value;
          });
          return result;
        }
        var _setToArray = setToArray$2;
        var Symbol$5 = _Symbol,
          Uint8Array$3 = _Uint8Array,
          eq$4 = eq_1,
          equalArrays$2 = _equalArrays,
          mapToArray$1 = _mapToArray,
          setToArray$1 = _setToArray;

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$a = 1,
          COMPARE_UNORDERED_FLAG$6 = 2;

        /** `Object#toString` result references. */
        var boolTag$5 = '[object Boolean]',
          dateTag$5 = '[object Date]',
          errorTag$4 = '[object Error]',
          mapTag$8 = '[object Map]',
          numberTag$5 = '[object Number]',
          regexpTag$5 = '[object RegExp]',
          setTag$8 = '[object Set]',
          stringTag$6 = '[object String]',
          symbolTag$5 = '[object Symbol]';
        var arrayBufferTag$5 = '[object ArrayBuffer]',
          dataViewTag$7 = '[object DataView]';

        /** Used to convert symbols to primitives and strings. */
        var symbolProto$4 = Symbol$5 ? Symbol$5.prototype : undefined,
          symbolValueOf$2 = symbolProto$4 ? symbolProto$4.valueOf : undefined;

        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag$2(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag$7:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag$5:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$3(object), new Uint8Array$3(other))) {
                return false;
              }
              return true;
            case boolTag$5:
            case dateTag$5:
            case numberTag$5:
              // Coerce booleans to `1` or `0` and dates to milliseconds.
              // Invalid dates are coerced to `NaN`.
              return eq$4(+object, +other);
            case errorTag$4:
              return object.name == other.name && object.message == other.message;
            case regexpTag$5:
            case stringTag$6:
              // Coerce regexes to strings and treat strings, primitives and objects,
              // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
              // for more details.
              return object == other + '';
            case mapTag$8:
              var convert = mapToArray$1;
            case setTag$8:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG$a;
              convert || (convert = setToArray$1);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              // Assume cyclic values are equal.
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG$6;

              // Recursively compare objects (susceptible to call stack limits).
              stack.set(object, other);
              var result = equalArrays$2(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack['delete'](object);
              return result;
            case symbolTag$5:
              if (symbolValueOf$2) {
                return symbolValueOf$2.call(object) == symbolValueOf$2.call(other);
              }
          }
          return false;
        }
        var _equalByTag = equalByTag$2;

        /**
         * Appends the elements of `values` to `array`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to append.
         * @returns {Array} Returns `array`.
         */

        function arrayPush$4(array, values) {
          var index = -1,
            length = values.length,
            offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        var _arrayPush = arrayPush$4;

        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */

        var isArray$g = Array.isArray;
        var isArray_1 = isArray$g;
        var arrayPush$3 = _arrayPush,
          isArray$f = isArray_1;

        /**
         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @param {Function} symbolsFunc The function to get the symbols of `object`.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function baseGetAllKeys$3(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray$f(object) ? result : arrayPush$3(result, symbolsFunc(object));
        }
        var _baseGetAllKeys = baseGetAllKeys$3;

        /**
         * A specialized version of `_.filter` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */

        function arrayFilter$2(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        var _arrayFilter = arrayFilter$2;

        /**
         * This method returns a new empty array.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Array} Returns the new empty array.
         * @example
         *
         * var arrays = _.times(2, _.stubArray);
         *
         * console.log(arrays);
         * // => [[], []]
         *
         * console.log(arrays[0] === arrays[1]);
         * // => false
         */

        function stubArray$3() {
          return [];
        }
        var stubArray_1 = stubArray$3;
        var arrayFilter$1 = _arrayFilter,
          stubArray$2 = stubArray_1;

        /** Used for built-in method references. */
        var objectProto$p = Object.prototype;

        /** Built-in value references. */
        var propertyIsEnumerable$3 = objectProto$p.propertyIsEnumerable;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeGetSymbols$2 = Object.getOwnPropertySymbols;

        /**
         * Creates an array of the own enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbols$4 = !nativeGetSymbols$2 ? stubArray$2 : function (object) {
          if (object == null) {
            return [];
          }
          object = Object(object);
          return arrayFilter$1(nativeGetSymbols$2(object), function (symbol) {
            return propertyIsEnumerable$3.call(object, symbol);
          });
        };
        var _getSymbols = getSymbols$4;

        /**
         * The base implementation of `_.times` without support for iteratee shorthands
         * or max array length checks.
         *
         * @private
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         */

        function baseTimes$2(n, iteratee) {
          var index = -1,
            result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        var _baseTimes = baseTimes$2;

        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */

        function isObjectLike$b(value) {
          return value != null && typeof value == 'object';
        }
        var isObjectLike_1 = isObjectLike$b;
        var baseGetTag$6 = _baseGetTag,
          isObjectLike$a = isObjectLike_1;

        /** `Object#toString` result references. */
        var argsTag$6 = '[object Arguments]';

        /**
         * The base implementation of `_.isArguments`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         */
        function baseIsArguments$2(value) {
          return isObjectLike$a(value) && baseGetTag$6(value) == argsTag$6;
        }
        var _baseIsArguments = baseIsArguments$2;
        var baseIsArguments$1 = _baseIsArguments,
          isObjectLike$9 = isObjectLike_1;

        /** Used for built-in method references. */
        var objectProto$o = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$l = objectProto$o.hasOwnProperty;

        /** Built-in value references. */
        var propertyIsEnumerable$2 = objectProto$o.propertyIsEnumerable;

        /**
         * Checks if `value` is likely an `arguments` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         *  else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        var isArguments$8 = baseIsArguments$1(function () {
          return arguments;
        }()) ? baseIsArguments$1 : function (value) {
          return isObjectLike$9(value) && hasOwnProperty$l.call(value, 'callee') && !propertyIsEnumerable$2.call(value, 'callee');
        };
        var isArguments_1 = isArguments$8;
        var isBuffer$6 = {
          exports: {}
        };

        /**
         * This method returns `false`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `false`.
         * @example
         *
         * _.times(2, _.stubFalse);
         * // => [false, false]
         */

        function stubFalse$1() {
          return false;
        }
        var stubFalse_1 = stubFalse$1;
        isBuffer$6.exports;
        (function (module, exports) {
          var root = _root,
            stubFalse = stubFalse_1;

          /** Detect free variable `exports`. */
          var freeExports = exports && !exports.nodeType && exports;

          /** Detect free variable `module`. */
          var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

          /** Detect the popular CommonJS extension `module.exports`. */
          var moduleExports = freeModule && freeModule.exports === freeExports;

          /** Built-in value references. */
          var Buffer = moduleExports ? root.Buffer : undefined;

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

          /**
           * Checks if `value` is a buffer.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
           * @example
           *
           * _.isBuffer(new Buffer(2));
           * // => true
           *
           * _.isBuffer(new Uint8Array(2));
           * // => false
           */
          var isBuffer = nativeIsBuffer || stubFalse;
          module.exports = isBuffer;
        })(isBuffer$6, isBuffer$6.exports);
        var isBufferExports = isBuffer$6.exports;

        /** Used as references for various `Number` constants. */

        var MAX_SAFE_INTEGER$3 = 9007199254740991;

        /** Used to detect unsigned integer values. */
        var reIsUint$1 = /^(?:0|[1-9]\d*)$/;

        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex$5(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER$3 : length;
          return !!length && (type == 'number' || type != 'symbol' && reIsUint$1.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }
        var _isIndex = isIndex$5;

        /** Used as references for various `Number` constants. */

        var MAX_SAFE_INTEGER$2 = 9007199254740991;

        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This method is loosely based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */
        function isLength$4(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
        }
        var isLength_1 = isLength$4;
        var baseGetTag$5 = _baseGetTag,
          isLength$3 = isLength_1,
          isObjectLike$8 = isObjectLike_1;

        /** `Object#toString` result references. */
        var argsTag$5 = '[object Arguments]',
          arrayTag$4 = '[object Array]',
          boolTag$4 = '[object Boolean]',
          dateTag$4 = '[object Date]',
          errorTag$3 = '[object Error]',
          funcTag$3 = '[object Function]',
          mapTag$7 = '[object Map]',
          numberTag$4 = '[object Number]',
          objectTag$8 = '[object Object]',
          regexpTag$4 = '[object RegExp]',
          setTag$7 = '[object Set]',
          stringTag$5 = '[object String]',
          weakMapTag$4 = '[object WeakMap]';
        var arrayBufferTag$4 = '[object ArrayBuffer]',
          dataViewTag$6 = '[object DataView]',
          float32Tag$3 = '[object Float32Array]',
          float64Tag$3 = '[object Float64Array]',
          int8Tag$3 = '[object Int8Array]',
          int16Tag$3 = '[object Int16Array]',
          int32Tag$3 = '[object Int32Array]',
          uint8Tag$3 = '[object Uint8Array]',
          uint8ClampedTag$3 = '[object Uint8ClampedArray]',
          uint16Tag$3 = '[object Uint16Array]',
          uint32Tag$3 = '[object Uint32Array]';

        /** Used to identify `toStringTag` values of typed arrays. */
        var typedArrayTags$1 = {};
        typedArrayTags$1[float32Tag$3] = typedArrayTags$1[float64Tag$3] = typedArrayTags$1[int8Tag$3] = typedArrayTags$1[int16Tag$3] = typedArrayTags$1[int32Tag$3] = typedArrayTags$1[uint8Tag$3] = typedArrayTags$1[uint8ClampedTag$3] = typedArrayTags$1[uint16Tag$3] = typedArrayTags$1[uint32Tag$3] = true;
        typedArrayTags$1[argsTag$5] = typedArrayTags$1[arrayTag$4] = typedArrayTags$1[arrayBufferTag$4] = typedArrayTags$1[boolTag$4] = typedArrayTags$1[dataViewTag$6] = typedArrayTags$1[dateTag$4] = typedArrayTags$1[errorTag$3] = typedArrayTags$1[funcTag$3] = typedArrayTags$1[mapTag$7] = typedArrayTags$1[numberTag$4] = typedArrayTags$1[objectTag$8] = typedArrayTags$1[regexpTag$4] = typedArrayTags$1[setTag$7] = typedArrayTags$1[stringTag$5] = typedArrayTags$1[weakMapTag$4] = false;

        /**
         * The base implementation of `_.isTypedArray` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         */
        function baseIsTypedArray$2(value) {
          return isObjectLike$8(value) && isLength$3(value.length) && !!typedArrayTags$1[baseGetTag$5(value)];
        }
        var _baseIsTypedArray = baseIsTypedArray$2;

        /**
         * The base implementation of `_.unary` without support for storing metadata.
         *
         * @private
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         */

        function baseUnary$4(func) {
          return function (value) {
            return func(value);
          };
        }
        var _baseUnary = baseUnary$4;
        var _nodeUtil = {
          exports: {}
        };
        _nodeUtil.exports;
        (function (module, exports) {
          var freeGlobal = _freeGlobal;

          /** Detect free variable `exports`. */
          var freeExports = exports && !exports.nodeType && exports;

          /** Detect free variable `module`. */
          var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

          /** Detect the popular CommonJS extension `module.exports`. */
          var moduleExports = freeModule && freeModule.exports === freeExports;

          /** Detect free variable `process` from Node.js. */
          var freeProcess = moduleExports && freeGlobal.process;

          /** Used to access faster Node.js helpers. */
          var nodeUtil = function () {
            try {
              // Use `util.types` for Node.js 10+.
              var types = freeModule && freeModule.require && freeModule.require('util').types;
              if (types) {
                return types;
              }

              // Legacy `process.binding('util')` for Node.js < 10.
              return freeProcess && freeProcess.binding && freeProcess.binding('util');
            } catch (e) {}
          }();
          module.exports = nodeUtil;
        })(_nodeUtil, _nodeUtil.exports);
        var _nodeUtilExports = _nodeUtil.exports;
        var baseIsTypedArray$1 = _baseIsTypedArray,
          baseUnary$3 = _baseUnary,
          nodeUtil$3 = _nodeUtilExports;

        /* Node.js helper references. */
        var nodeIsTypedArray$1 = nodeUtil$3 && nodeUtil$3.isTypedArray;

        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        var isTypedArray$4 = nodeIsTypedArray$1 ? baseUnary$3(nodeIsTypedArray$1) : baseIsTypedArray$1;
        var isTypedArray_1 = isTypedArray$4;
        var baseTimes$1 = _baseTimes,
          isArguments$7 = isArguments_1,
          isArray$e = isArray_1,
          isBuffer$5 = isBufferExports,
          isIndex$4 = _isIndex,
          isTypedArray$3 = isTypedArray_1;

        /** Used for built-in method references. */
        var objectProto$n = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$k = objectProto$n.hasOwnProperty;

        /**
         * Creates an array of the enumerable property names of the array-like `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @param {boolean} inherited Specify returning inherited property names.
         * @returns {Array} Returns the array of property names.
         */
        function arrayLikeKeys$3(value, inherited) {
          var isArr = isArray$e(value),
            isArg = !isArr && isArguments$7(value),
            isBuff = !isArr && !isArg && isBuffer$5(value),
            isType = !isArr && !isArg && !isBuff && isTypedArray$3(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result = skipIndexes ? baseTimes$1(value.length, String) : [],
            length = result.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty$k.call(value, key)) && !(skipIndexes && (
            // Safari 9 has enumerable `arguments.length` in strict mode.
            key == 'length' ||
            // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == 'offset' || key == 'parent') ||
            // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
            // Skip index properties.
            isIndex$4(key, length)))) {
              result.push(key);
            }
          }
          return result;
        }
        var _arrayLikeKeys = arrayLikeKeys$3;

        /** Used for built-in method references. */

        var objectProto$m = Object.prototype;

        /**
         * Checks if `value` is likely a prototype object.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
         */
        function isPrototype$4(value) {
          var Ctor = value && value.constructor,
            proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$m;
          return value === proto;
        }
        var _isPrototype = isPrototype$4;

        /**
         * Creates a unary function that invokes `func` with its argument transformed.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {Function} transform The argument transform.
         * @returns {Function} Returns the new function.
         */

        function overArg$3(func, transform) {
          return function (arg) {
            return func(transform(arg));
          };
        }
        var _overArg = overArg$3;
        var overArg$2 = _overArg;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeKeys$2 = overArg$2(Object.keys, Object);
        var _nativeKeys = nativeKeys$2;
        var isPrototype$3 = _isPrototype,
          nativeKeys$1 = _nativeKeys;

        /** Used for built-in method references. */
        var objectProto$l = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$j = objectProto$l.hasOwnProperty;

        /**
         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeys$2(object) {
          if (!isPrototype$3(object)) {
            return nativeKeys$1(object);
          }
          var result = [];
          for (var key in Object(object)) {
            if (hasOwnProperty$j.call(object, key) && key != 'constructor') {
              result.push(key);
            }
          }
          return result;
        }
        var _baseKeys = baseKeys$2;
        var isFunction$4 = isFunction_1,
          isLength$2 = isLength_1;

        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */
        function isArrayLike$8(value) {
          return value != null && isLength$2(value.length) && !isFunction$4(value);
        }
        var isArrayLike_1 = isArrayLike$8;
        var arrayLikeKeys$2 = _arrayLikeKeys,
          baseKeys$1 = _baseKeys,
          isArrayLike$7 = isArrayLike_1;

        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        function keys$8(object) {
          return isArrayLike$7(object) ? arrayLikeKeys$2(object) : baseKeys$1(object);
        }
        var keys_1 = keys$8;
        const keys$9 = /*@__PURE__*/getDefaultExportFromCjs(keys_1);
        var baseGetAllKeys$2 = _baseGetAllKeys,
          getSymbols$3 = _getSymbols,
          keys$7 = keys_1;

        /**
         * Creates an array of own enumerable property names and symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeys$3(object) {
          return baseGetAllKeys$2(object, keys$7, getSymbols$3);
        }
        var _getAllKeys = getAllKeys$3;
        var getAllKeys$2 = _getAllKeys;

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$9 = 1;

        /** Used for built-in method references. */
        var objectProto$k = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$i = objectProto$k.hasOwnProperty;

        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects$2(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$9,
            objProps = getAllKeys$2(object),
            objLength = objProps.length,
            othProps = getAllKeys$2(other),
            othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty$i.call(other, key))) {
              return false;
            }
          }
          // Check that cyclic values are equal.
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
              othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            // Recursively compare objects (susceptible to call stack limits).
            if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (result && !skipCtor) {
            var objCtor = object.constructor,
              othCtor = other.constructor;

            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack['delete'](object);
          stack['delete'](other);
          return result;
        }
        var _equalObjects = equalObjects$2;
        var getNative$5 = _getNative,
          root$5 = _root;

        /* Built-in method references that are verified to be native. */
        var DataView$3 = getNative$5(root$5, 'DataView');
        var _DataView = DataView$3;
        var getNative$4 = _getNative,
          root$4 = _root;

        /* Built-in method references that are verified to be native. */
        var Promise$3 = getNative$4(root$4, 'Promise');
        var _Promise = Promise$3;
        var getNative$3 = _getNative,
          root$3 = _root;

        /* Built-in method references that are verified to be native. */
        var Set$4 = getNative$3(root$3, 'Set');
        var _Set = Set$4;
        var getNative$2 = _getNative,
          root$2 = _root;

        /* Built-in method references that are verified to be native. */
        var WeakMap$3 = getNative$2(root$2, 'WeakMap');
        var _WeakMap = WeakMap$3;
        var DataView$2 = _DataView,
          Map$3 = _Map,
          Promise$2 = _Promise,
          Set$3 = _Set,
          WeakMap$2 = _WeakMap,
          baseGetTag$4 = _baseGetTag,
          toSource$1 = _toSource;

        /** `Object#toString` result references. */
        var mapTag$6 = '[object Map]',
          objectTag$7 = '[object Object]',
          promiseTag$1 = '[object Promise]',
          setTag$6 = '[object Set]',
          weakMapTag$3 = '[object WeakMap]';
        var dataViewTag$5 = '[object DataView]';

        /** Used to detect maps, sets, and weakmaps. */
        var dataViewCtorString$1 = toSource$1(DataView$2),
          mapCtorString$1 = toSource$1(Map$3),
          promiseCtorString$1 = toSource$1(Promise$2),
          setCtorString$1 = toSource$1(Set$3),
          weakMapCtorString$1 = toSource$1(WeakMap$2);

        /**
         * Gets the `toStringTag` of `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        var getTag$5 = baseGetTag$4;

        // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
        if (DataView$2 && getTag$5(new DataView$2(new ArrayBuffer(1))) != dataViewTag$5 || Map$3 && getTag$5(new Map$3()) != mapTag$6 || Promise$2 && getTag$5(Promise$2.resolve()) != promiseTag$1 || Set$3 && getTag$5(new Set$3()) != setTag$6 || WeakMap$2 && getTag$5(new WeakMap$2()) != weakMapTag$3) {
          getTag$5 = function getTag$5(value) {
            var result = baseGetTag$4(value),
              Ctor = result == objectTag$7 ? value.constructor : undefined,
              ctorString = Ctor ? toSource$1(Ctor) : '';
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString$1:
                  return dataViewTag$5;
                case mapCtorString$1:
                  return mapTag$6;
                case promiseCtorString$1:
                  return promiseTag$1;
                case setCtorString$1:
                  return setTag$6;
                case weakMapCtorString$1:
                  return weakMapTag$3;
              }
            }
            return result;
          };
        }
        var _getTag = getTag$5;
        var Stack$5 = _Stack,
          equalArrays$1 = _equalArrays,
          equalByTag$1 = _equalByTag,
          equalObjects$1 = _equalObjects,
          getTag$4 = _getTag,
          isArray$d = isArray_1,
          isBuffer$4 = isBufferExports,
          isTypedArray$2 = isTypedArray_1;

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$8 = 1;

        /** `Object#toString` result references. */
        var argsTag$4 = '[object Arguments]',
          arrayTag$3 = '[object Array]',
          objectTag$6 = '[object Object]';

        /** Used for built-in method references. */
        var objectProto$j = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$h = objectProto$j.hasOwnProperty;

        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} [stack] Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep$2(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray$d(object),
            othIsArr = isArray$d(other),
            objTag = objIsArr ? arrayTag$3 : getTag$4(object),
            othTag = othIsArr ? arrayTag$3 : getTag$4(other);
          objTag = objTag == argsTag$4 ? objectTag$6 : objTag;
          othTag = othTag == argsTag$4 ? objectTag$6 : othTag;
          var objIsObj = objTag == objectTag$6,
            othIsObj = othTag == objectTag$6,
            isSameTag = objTag == othTag;
          if (isSameTag && isBuffer$4(object)) {
            if (!isBuffer$4(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack$5());
            return objIsArr || isTypedArray$2(object) ? equalArrays$1(object, other, bitmask, customizer, equalFunc, stack) : equalByTag$1(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG$8)) {
            var objIsWrapped = objIsObj && hasOwnProperty$h.call(object, '__wrapped__'),
              othIsWrapped = othIsObj && hasOwnProperty$h.call(other, '__wrapped__');
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object,
                othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack$5());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack$5());
          return equalObjects$1(object, other, bitmask, customizer, equalFunc, stack);
        }
        var _baseIsEqualDeep = baseIsEqualDeep$2;
        var baseIsEqualDeep$1 = _baseIsEqualDeep,
          isObjectLike$7 = isObjectLike_1;

        /**
         * The base implementation of `_.isEqual` which supports partial comparisons
         * and tracks traversed objects.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Unordered comparison
         *  2 - Partial comparison
         * @param {Function} [customizer] The function to customize comparisons.
         * @param {Object} [stack] Tracks traversed `value` and `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual$4(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike$7(value) && !isObjectLike$7(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep$1(value, other, bitmask, customizer, baseIsEqual$4, stack);
        }
        var _baseIsEqual = baseIsEqual$4;
        var baseIsEqual$3 = _baseIsEqual;

        /**
         * Performs a deep comparison between two values to determine if they are
         * equivalent.
         *
         * **Note:** This method supports comparing arrays, array buffers, booleans,
         * date objects, error objects, maps, numbers, `Object` objects, regexes,
         * sets, strings, symbols, and typed arrays. `Object` objects are compared
         * by their own, not inherited, enumerable properties. Functions and DOM
         * nodes are compared by strict equality, i.e. `===`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.isEqual(object, other);
         * // => true
         *
         * object === other;
         * // => false
         */
        function isEqual(value, other) {
          return baseIsEqual$3(value, other);
        }
        var isEqual_1$1 = isEqual;
        var quill = {
          exports: {}
        };

        /*!
         * Quill Editor v1.3.7
         * https://quilljs.com/
         * Copyright (c) 2014, Jason Chen
         * Copyright (c) 2013, salesforce.com
         */

        (function (module, exports) {
          (function webpackUniversalModuleDefinition(root, factory) {
            module.exports = factory();
          })(typeof self !== 'undefined' ? self : commonjsGlobal, function () {
            return /******/function (modules) {
              // webpackBootstrap
              /******/ // The module cache
              /******/
              var installedModules = {};
              /******/
              /******/ // The require function
              /******/
              function __webpack_require__(moduleId) {
                /******/
                /******/ // Check if module is in cache
                /******/if (installedModules[moduleId]) {
                  /******/return installedModules[moduleId].exports;
                  /******/
                }
                /******/ // Create a new module (and put it into the cache)
                /******/
                var module = installedModules[moduleId] = {
                  /******/i: moduleId,
                  /******/l: false,
                  /******/exports: {}
                  /******/
                };
                /******/
                /******/ // Execute the module function
                /******/
                modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                /******/
                /******/ // Flag the module as loaded
                /******/
                module.l = true;
                /******/
                /******/ // Return the exports of the module
                /******/
                return module.exports;
                /******/
              }
              /******/
              /******/
              /******/ // expose the modules object (__webpack_modules__)
              /******/
              __webpack_require__.m = modules;
              /******/
              /******/ // expose the module cache
              /******/
              __webpack_require__.c = installedModules;
              /******/
              /******/ // define getter function for harmony exports
              /******/
              __webpack_require__.d = function (exports, name, getter) {
                /******/if (!__webpack_require__.o(exports, name)) {
                  /******/Object.defineProperty(exports, name, {
                    /******/configurable: false,
                    /******/enumerable: true,
                    /******/get: getter
                    /******/
                  });
                  /******/
                }
                /******/
              };
              /******/
              /******/ // getDefaultExport function for compatibility with non-harmony modules
              /******/
              __webpack_require__.n = function (module) {
                /******/var getter = module && module.__esModule ? /******/function getDefault() {
                  return module['default'];
                } : /******/function getModuleExports() {
                  return module;
                };
                /******/
                __webpack_require__.d(getter, 'a', getter);
                /******/
                return getter;
                /******/
              };
              /******/
              /******/ // Object.prototype.hasOwnProperty.call
              /******/
              __webpack_require__.o = function (object, property) {
                return Object.prototype.hasOwnProperty.call(object, property);
              };
              /******/
              /******/ // __webpack_public_path__
              /******/
              __webpack_require__.p = "";
              /******/
              /******/ // Load entry module and return exports
              /******/
              return __webpack_require__(__webpack_require__.s = 109);
              /******/
            }
            /************************************************************************/
            /******/([(/* 0 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var container_1 = __webpack_require__(17);
              var format_1 = __webpack_require__(18);
              var leaf_1 = __webpack_require__(19);
              var scroll_1 = __webpack_require__(45);
              var inline_1 = __webpack_require__(46);
              var block_1 = __webpack_require__(47);
              var embed_1 = __webpack_require__(48);
              var text_1 = __webpack_require__(49);
              var attributor_1 = __webpack_require__(12);
              var class_1 = __webpack_require__(32);
              var style_1 = __webpack_require__(33);
              var store_1 = __webpack_require__(31);
              var Registry = __webpack_require__(1);
              var Parchment = {
                Scope: Registry.Scope,
                create: Registry.create,
                find: Registry.find,
                query: Registry.query,
                register: Registry.register,
                Container: container_1.default,
                Format: format_1.default,
                Leaf: leaf_1.default,
                Embed: embed_1.default,
                Scroll: scroll_1.default,
                Block: block_1.default,
                Inline: inline_1.default,
                Text: text_1.default,
                Attributor: {
                  Attribute: attributor_1.default,
                  Class: class_1.default,
                  Style: style_1.default,
                  Store: store_1.default
                }
              };
              exports.default = Parchment;

              /***/
            }), (/* 1 */
            /***/function (module, exports, __webpack_require__) {
              var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function (d, b) {
                  d.__proto__ = b;
                } || function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
                return function (d, b) {
                  extendStatics(d, b);
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
              }();
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var ParchmentError = /** @class */function (_super) {
                __extends(ParchmentError, _super);
                function ParchmentError(message) {
                  var _this = this;
                  message = '[Parchment] ' + message;
                  _this = _super.call(this, message) || this;
                  _this.message = message;
                  _this.name = _this.constructor.name;
                  return _this;
                }
                return ParchmentError;
              }(Error);
              exports.ParchmentError = ParchmentError;
              var attributes = {};
              var classes = {};
              var tags = {};
              var types = {};
              exports.DATA_KEY = '__blot';
              var Scope;
              (function (Scope) {
                Scope[Scope["TYPE"] = 3] = "TYPE";
                Scope[Scope["LEVEL"] = 12] = "LEVEL";
                Scope[Scope["ATTRIBUTE"] = 13] = "ATTRIBUTE";
                Scope[Scope["BLOT"] = 14] = "BLOT";
                Scope[Scope["INLINE"] = 7] = "INLINE";
                Scope[Scope["BLOCK"] = 11] = "BLOCK";
                Scope[Scope["BLOCK_BLOT"] = 10] = "BLOCK_BLOT";
                Scope[Scope["INLINE_BLOT"] = 6] = "INLINE_BLOT";
                Scope[Scope["BLOCK_ATTRIBUTE"] = 9] = "BLOCK_ATTRIBUTE";
                Scope[Scope["INLINE_ATTRIBUTE"] = 5] = "INLINE_ATTRIBUTE";
                Scope[Scope["ANY"] = 15] = "ANY";
              })(Scope = exports.Scope || (exports.Scope = {}));
              function create(input, value) {
                var match = query(input);
                if (match == null) {
                  throw new ParchmentError("Unable to create " + input + " blot");
                }
                var BlotClass = match;
                var node =
                // @ts-ignore
                input instanceof Node || input['nodeType'] === Node.TEXT_NODE ? input : BlotClass.create(value);
                return new BlotClass(node, value);
              }
              exports.create = create;
              function find(node, bubble) {
                if (bubble === void 0) {
                  bubble = false;
                }
                if (node == null) return null;
                // @ts-ignore
                if (node[exports.DATA_KEY] != null) return node[exports.DATA_KEY].blot;
                if (bubble) return find(node.parentNode, bubble);
                return null;
              }
              exports.find = find;
              function query(query, scope) {
                if (scope === void 0) {
                  scope = Scope.ANY;
                }
                var match;
                if (typeof query === 'string') {
                  match = types[query] || attributes[query];
                  // @ts-ignore
                } else if (query instanceof Text || query['nodeType'] === Node.TEXT_NODE) {
                  match = types['text'];
                } else if (typeof query === 'number') {
                  if (query & Scope.LEVEL & Scope.BLOCK) {
                    match = types['block'];
                  } else if (query & Scope.LEVEL & Scope.INLINE) {
                    match = types['inline'];
                  }
                } else if (query instanceof HTMLElement) {
                  var names = (query.getAttribute('class') || '').split(/\s+/);
                  for (var i in names) {
                    match = classes[names[i]];
                    if (match) break;
                  }
                  match = match || tags[query.tagName];
                }
                if (match == null) return null;
                // @ts-ignore
                if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope) return match;
                return null;
              }
              exports.query = query;
              function register() {
                var Definitions = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  Definitions[_i] = arguments[_i];
                }
                if (Definitions.length > 1) {
                  return Definitions.map(function (d) {
                    return register(d);
                  });
                }
                var Definition = Definitions[0];
                if (typeof Definition.blotName !== 'string' && typeof Definition.attrName !== 'string') {
                  throw new ParchmentError('Invalid definition');
                } else if (Definition.blotName === 'abstract') {
                  throw new ParchmentError('Cannot register abstract class');
                }
                types[Definition.blotName || Definition.attrName] = Definition;
                if (typeof Definition.keyName === 'string') {
                  attributes[Definition.keyName] = Definition;
                } else {
                  if (Definition.className != null) {
                    classes[Definition.className] = Definition;
                  }
                  if (Definition.tagName != null) {
                    if (Array.isArray(Definition.tagName)) {
                      Definition.tagName = Definition.tagName.map(function (tagName) {
                        return tagName.toUpperCase();
                      });
                    } else {
                      Definition.tagName = Definition.tagName.toUpperCase();
                    }
                    var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [Definition.tagName];
                    tagNames.forEach(function (tag) {
                      if (tags[tag] == null || Definition.className == null) {
                        tags[tag] = Definition;
                      }
                    });
                  }
                }
                return Definition;
              }
              exports.register = register;

              /***/
            }), (/* 2 */
            /***/function (module, exports, __webpack_require__) {
              var diff = __webpack_require__(51);
              var equal = __webpack_require__(11);
              var extend = __webpack_require__(3);
              var op = __webpack_require__(20);
              var NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()

              var Delta = function Delta(ops) {
                // Assume we are given a well formed ops
                if (Array.isArray(ops)) {
                  this.ops = ops;
                } else if (ops != null && Array.isArray(ops.ops)) {
                  this.ops = ops.ops;
                } else {
                  this.ops = [];
                }
              };
              Delta.prototype.insert = function (text, attributes) {
                var newOp = {};
                if (text.length === 0) return this;
                newOp.insert = text;
                if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
                  newOp.attributes = attributes;
                }
                return this.push(newOp);
              };
              Delta.prototype['delete'] = function (length) {
                if (length <= 0) return this;
                return this.push({
                  'delete': length
                });
              };
              Delta.prototype.retain = function (length, attributes) {
                if (length <= 0) return this;
                var newOp = {
                  retain: length
                };
                if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
                  newOp.attributes = attributes;
                }
                return this.push(newOp);
              };
              Delta.prototype.push = function (newOp) {
                var index = this.ops.length;
                var lastOp = this.ops[index - 1];
                newOp = extend(true, {}, newOp);
                if (typeof lastOp === 'object') {
                  if (typeof newOp['delete'] === 'number' && typeof lastOp['delete'] === 'number') {
                    this.ops[index - 1] = {
                      'delete': lastOp['delete'] + newOp['delete']
                    };
                    return this;
                  }
                  // Since it does not matter if we insert before or after deleting at the same index,
                  // always prefer to insert first
                  if (typeof lastOp['delete'] === 'number' && newOp.insert != null) {
                    index -= 1;
                    lastOp = this.ops[index - 1];
                    if (typeof lastOp !== 'object') {
                      this.ops.unshift(newOp);
                      return this;
                    }
                  }
                  if (equal(newOp.attributes, lastOp.attributes)) {
                    if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
                      this.ops[index - 1] = {
                        insert: lastOp.insert + newOp.insert
                      };
                      if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;
                      return this;
                    } else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
                      this.ops[index - 1] = {
                        retain: lastOp.retain + newOp.retain
                      };
                      if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;
                      return this;
                    }
                  }
                }
                if (index === this.ops.length) {
                  this.ops.push(newOp);
                } else {
                  this.ops.splice(index, 0, newOp);
                }
                return this;
              };
              Delta.prototype.chop = function () {
                var lastOp = this.ops[this.ops.length - 1];
                if (lastOp && lastOp.retain && !lastOp.attributes) {
                  this.ops.pop();
                }
                return this;
              };
              Delta.prototype.filter = function (predicate) {
                return this.ops.filter(predicate);
              };
              Delta.prototype.forEach = function (predicate) {
                this.ops.forEach(predicate);
              };
              Delta.prototype.map = function (predicate) {
                return this.ops.map(predicate);
              };
              Delta.prototype.partition = function (predicate) {
                var passed = [],
                  failed = [];
                this.forEach(function (op) {
                  var target = predicate(op) ? passed : failed;
                  target.push(op);
                });
                return [passed, failed];
              };
              Delta.prototype.reduce = function (predicate, initial) {
                return this.ops.reduce(predicate, initial);
              };
              Delta.prototype.changeLength = function () {
                return this.reduce(function (length, elem) {
                  if (elem.insert) {
                    return length + op.length(elem);
                  } else if (elem.delete) {
                    return length - elem.delete;
                  }
                  return length;
                }, 0);
              };
              Delta.prototype.length = function () {
                return this.reduce(function (length, elem) {
                  return length + op.length(elem);
                }, 0);
              };
              Delta.prototype.slice = function (start, end) {
                start = start || 0;
                if (typeof end !== 'number') end = Infinity;
                var ops = [];
                var iter = op.iterator(this.ops);
                var index = 0;
                while (index < end && iter.hasNext()) {
                  var nextOp;
                  if (index < start) {
                    nextOp = iter.next(start - index);
                  } else {
                    nextOp = iter.next(end - index);
                    ops.push(nextOp);
                  }
                  index += op.length(nextOp);
                }
                return new Delta(ops);
              };
              Delta.prototype.compose = function (other) {
                var thisIter = op.iterator(this.ops);
                var otherIter = op.iterator(other.ops);
                var ops = [];
                var firstOther = otherIter.peek();
                if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {
                  var firstLeft = firstOther.retain;
                  while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {
                    firstLeft -= thisIter.peekLength();
                    ops.push(thisIter.next());
                  }
                  if (firstOther.retain - firstLeft > 0) {
                    otherIter.next(firstOther.retain - firstLeft);
                  }
                }
                var delta = new Delta(ops);
                while (thisIter.hasNext() || otherIter.hasNext()) {
                  if (otherIter.peekType() === 'insert') {
                    delta.push(otherIter.next());
                  } else if (thisIter.peekType() === 'delete') {
                    delta.push(thisIter.next());
                  } else {
                    var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                    var thisOp = thisIter.next(length);
                    var otherOp = otherIter.next(length);
                    if (typeof otherOp.retain === 'number') {
                      var newOp = {};
                      if (typeof thisOp.retain === 'number') {
                        newOp.retain = length;
                      } else {
                        newOp.insert = thisOp.insert;
                      }
                      // Preserve null when composing with a retain, otherwise remove it for inserts
                      var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
                      if (attributes) newOp.attributes = attributes;
                      delta.push(newOp);

                      // Optimization if rest of other is just retain
                      if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {
                        var rest = new Delta(thisIter.rest());
                        return delta.concat(rest).chop();
                      }

                      // Other op should be delete, we could be an insert or retain
                      // Insert + delete cancels out
                    } else if (typeof otherOp['delete'] === 'number' && typeof thisOp.retain === 'number') {
                      delta.push(otherOp);
                    }
                  }
                }
                return delta.chop();
              };
              Delta.prototype.concat = function (other) {
                var delta = new Delta(this.ops.slice());
                if (other.ops.length > 0) {
                  delta.push(other.ops[0]);
                  delta.ops = delta.ops.concat(other.ops.slice(1));
                }
                return delta;
              };
              Delta.prototype.diff = function (other, index) {
                if (this.ops === other.ops) {
                  return new Delta();
                }
                var strings = [this, other].map(function (delta) {
                  return delta.map(function (op) {
                    if (op.insert != null) {
                      return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;
                    }
                    var prep = delta === other ? 'on' : 'with';
                    throw new Error('diff() called ' + prep + ' non-document');
                  }).join('');
                });
                var delta = new Delta();
                var diffResult = diff(strings[0], strings[1], index);
                var thisIter = op.iterator(this.ops);
                var otherIter = op.iterator(other.ops);
                diffResult.forEach(function (component) {
                  var length = component[1].length;
                  while (length > 0) {
                    var opLength = 0;
                    switch (component[0]) {
                      case diff.INSERT:
                        opLength = Math.min(otherIter.peekLength(), length);
                        delta.push(otherIter.next(opLength));
                        break;
                      case diff.DELETE:
                        opLength = Math.min(length, thisIter.peekLength());
                        thisIter.next(opLength);
                        delta['delete'](opLength);
                        break;
                      case diff.EQUAL:
                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
                        var thisOp = thisIter.next(opLength);
                        var otherOp = otherIter.next(opLength);
                        if (equal(thisOp.insert, otherOp.insert)) {
                          delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));
                        } else {
                          delta.push(otherOp)['delete'](opLength);
                        }
                        break;
                    }
                    length -= opLength;
                  }
                });
                return delta.chop();
              };
              Delta.prototype.eachLine = function (predicate, newline) {
                newline = newline || '\n';
                var iter = op.iterator(this.ops);
                var line = new Delta();
                var i = 0;
                while (iter.hasNext()) {
                  if (iter.peekType() !== 'insert') return;
                  var thisOp = iter.peek();
                  var start = op.length(thisOp) - iter.peekLength();
                  var index = typeof thisOp.insert === 'string' ? thisOp.insert.indexOf(newline, start) - start : -1;
                  if (index < 0) {
                    line.push(iter.next());
                  } else if (index > 0) {
                    line.push(iter.next(index));
                  } else {
                    if (predicate(line, iter.next(1).attributes || {}, i) === false) {
                      return;
                    }
                    i += 1;
                    line = new Delta();
                  }
                }
                if (line.length() > 0) {
                  predicate(line, {}, i);
                }
              };
              Delta.prototype.transform = function (other, priority) {
                priority = !!priority;
                if (typeof other === 'number') {
                  return this.transformPosition(other, priority);
                }
                var thisIter = op.iterator(this.ops);
                var otherIter = op.iterator(other.ops);
                var delta = new Delta();
                while (thisIter.hasNext() || otherIter.hasNext()) {
                  if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
                    delta.retain(op.length(thisIter.next()));
                  } else if (otherIter.peekType() === 'insert') {
                    delta.push(otherIter.next());
                  } else {
                    var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                    var thisOp = thisIter.next(length);
                    var otherOp = otherIter.next(length);
                    if (thisOp['delete']) {
                      // Our delete either makes their delete redundant or removes their retain
                      continue;
                    } else if (otherOp['delete']) {
                      delta.push(otherOp);
                    } else {
                      // We retain either their retain or insert
                      delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
                    }
                  }
                }
                return delta.chop();
              };
              Delta.prototype.transformPosition = function (index, priority) {
                priority = !!priority;
                var thisIter = op.iterator(this.ops);
                var offset = 0;
                while (thisIter.hasNext() && offset <= index) {
                  var length = thisIter.peekLength();
                  var nextType = thisIter.peekType();
                  thisIter.next();
                  if (nextType === 'delete') {
                    index -= Math.min(length, index - offset);
                    continue;
                  } else if (nextType === 'insert' && (offset < index || !priority)) {
                    index += length;
                  }
                  offset += length;
                }
                return index;
              };
              module.exports = Delta;

              /***/
            }), (/* 3 */
            /***/function (module, exports) {
              var hasOwn = Object.prototype.hasOwnProperty;
              var toStr = Object.prototype.toString;
              var defineProperty = Object.defineProperty;
              var gOPD = Object.getOwnPropertyDescriptor;
              var isArray = function isArray(arr) {
                if (typeof Array.isArray === 'function') {
                  return Array.isArray(arr);
                }
                return toStr.call(arr) === '[object Array]';
              };
              var isPlainObject = function isPlainObject(obj) {
                if (!obj || toStr.call(obj) !== '[object Object]') {
                  return false;
                }
                var hasOwnConstructor = hasOwn.call(obj, 'constructor');
                var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
                // Not own constructor property must be Object
                if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
                  return false;
                }

                // Own properties are enumerated firstly, so to speed up,
                // if last one is own, then all properties are own.
                var key;
                for (key in obj) {/**/}
                return typeof key === 'undefined' || hasOwn.call(obj, key);
              };

              // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
              var setProperty = function setProperty(target, options) {
                if (defineProperty && options.name === '__proto__') {
                  defineProperty(target, options.name, {
                    enumerable: true,
                    configurable: true,
                    value: options.newValue,
                    writable: true
                  });
                } else {
                  target[options.name] = options.newValue;
                }
              };

              // Return undefined instead of __proto__ if '__proto__' is not an own property
              var getProperty = function getProperty(obj, name) {
                if (name === '__proto__') {
                  if (!hasOwn.call(obj, name)) {
                    return void 0;
                  } else if (gOPD) {
                    // In early versions of node, obj['__proto__'] is buggy when obj has
                    // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
                    return gOPD(obj, name).value;
                  }
                }
                return obj[name];
              };
              module.exports = function extend() {
                var options, name, src, copy, copyIsArray, clone;
                var target = arguments[0];
                var i = 1;
                var length = arguments.length;
                var deep = false;

                // Handle a deep copy situation
                if (typeof target === 'boolean') {
                  deep = target;
                  target = arguments[1] || {};
                  // skip the boolean and the target
                  i = 2;
                }
                if (target == null || typeof target !== 'object' && typeof target !== 'function') {
                  target = {};
                }
                for (; i < length; ++i) {
                  options = arguments[i];
                  // Only deal with non-null/undefined values
                  if (options != null) {
                    // Extend the base object
                    for (name in options) {
                      src = getProperty(target, name);
                      copy = getProperty(options, name);

                      // Prevent never-ending loop
                      if (target !== copy) {
                        // Recurse if we're merging plain objects or arrays
                        if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                          if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && isArray(src) ? src : [];
                          } else {
                            clone = src && isPlainObject(src) ? src : {};
                          }

                          // Never move original objects, clone them
                          setProperty(target, {
                            name: name,
                            newValue: extend(deep, clone, copy)
                          });

                          // Don't bring in undefined values
                        } else if (typeof copy !== 'undefined') {
                          setProperty(target, {
                            name: name,
                            newValue: copy
                          });
                        }
                      }
                    }
                  }
                }

                // Return the modified object
                return target;
              };

              /***/
            }), (/* 4 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.default = exports.BlockEmbed = exports.bubbleFormats = undefined;
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _extend = __webpack_require__(3);
              var _extend2 = _interopRequireDefault(_extend);
              var _quillDelta = __webpack_require__(2);
              var _quillDelta2 = _interopRequireDefault(_quillDelta);
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _break = __webpack_require__(16);
              var _break2 = _interopRequireDefault(_break);
              var _inline = __webpack_require__(6);
              var _inline2 = _interopRequireDefault(_inline);
              var _text = __webpack_require__(7);
              var _text2 = _interopRequireDefault(_text);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var NEWLINE_LENGTH = 1;
              var BlockEmbed = function (_Parchment$Embed) {
                _inherits(BlockEmbed, _Parchment$Embed);
                function BlockEmbed() {
                  _classCallCheck(this, BlockEmbed);
                  return _possibleConstructorReturn(this, (BlockEmbed.__proto__ || Object.getPrototypeOf(BlockEmbed)).apply(this, arguments));
                }
                _createClass(BlockEmbed, [{
                  key: 'attach',
                  value: function attach() {
                    _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'attach', this).call(this);
                    this.attributes = new _parchment2.default.Attributor.Store(this.domNode);
                  }
                }, {
                  key: 'delta',
                  value: function delta() {
                    return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));
                  }
                }, {
                  key: 'format',
                  value: function format(name, value) {
                    var attribute = _parchment2.default.query(name, _parchment2.default.Scope.BLOCK_ATTRIBUTE);
                    if (attribute != null) {
                      this.attributes.attribute(attribute, value);
                    }
                  }
                }, {
                  key: 'formatAt',
                  value: function formatAt(index, length, name, value) {
                    this.format(name, value);
                  }
                }, {
                  key: 'insertAt',
                  value: function insertAt(index, value, def) {
                    if (typeof value === 'string' && value.endsWith('\n')) {
                      var block = _parchment2.default.create(Block.blotName);
                      this.parent.insertBefore(block, index === 0 ? this : this.next);
                      block.insertAt(0, value.slice(0, -1));
                    } else {
                      _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'insertAt', this).call(this, index, value, def);
                    }
                  }
                }]);
                return BlockEmbed;
              }(_parchment2.default.Embed);
              BlockEmbed.scope = _parchment2.default.Scope.BLOCK_BLOT;
              // It is important for cursor behavior BlockEmbeds use tags that are block level elements

              var Block = function (_Parchment$Block) {
                _inherits(Block, _Parchment$Block);
                function Block(domNode) {
                  _classCallCheck(this, Block);
                  var _this2 = _possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).call(this, domNode));
                  _this2.cache = {};
                  return _this2;
                }
                _createClass(Block, [{
                  key: 'delta',
                  value: function delta() {
                    if (this.cache.delta == null) {
                      this.cache.delta = this.descendants(_parchment2.default.Leaf).reduce(function (delta, leaf) {
                        if (leaf.length() === 0) {
                          return delta;
                        } else {
                          return delta.insert(leaf.value(), bubbleFormats(leaf));
                        }
                      }, new _quillDelta2.default()).insert('\n', bubbleFormats(this));
                    }
                    return this.cache.delta;
                  }
                }, {
                  key: 'deleteAt',
                  value: function deleteAt(index, length) {
                    _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'deleteAt', this).call(this, index, length);
                    this.cache = {};
                  }
                }, {
                  key: 'formatAt',
                  value: function formatAt(index, length, name, value) {
                    if (length <= 0) return;
                    if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
                      if (index + length === this.length()) {
                        this.format(name, value);
                      }
                    } else {
                      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'formatAt', this).call(this, index, Math.min(length, this.length() - index - 1), name, value);
                    }
                    this.cache = {};
                  }
                }, {
                  key: 'insertAt',
                  value: function insertAt(index, value, def) {
                    if (def != null) return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, index, value, def);
                    if (value.length === 0) return;
                    var lines = value.split('\n');
                    var text = lines.shift();
                    if (text.length > 0) {
                      if (index < this.length() - 1 || this.children.tail == null) {
                        _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, Math.min(index, this.length() - 1), text);
                      } else {
                        this.children.tail.insertAt(this.children.tail.length(), text);
                      }
                      this.cache = {};
                    }
                    var block = this;
                    lines.reduce(function (index, line) {
                      block = block.split(index, true);
                      block.insertAt(0, line);
                      return line.length;
                    }, index + text.length);
                  }
                }, {
                  key: 'insertBefore',
                  value: function insertBefore(blot, ref) {
                    var head = this.children.head;
                    _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertBefore', this).call(this, blot, ref);
                    if (head instanceof _break2.default) {
                      head.remove();
                    }
                    this.cache = {};
                  }
                }, {
                  key: 'length',
                  value: function length() {
                    if (this.cache.length == null) {
                      this.cache.length = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'length', this).call(this) + NEWLINE_LENGTH;
                    }
                    return this.cache.length;
                  }
                }, {
                  key: 'moveChildren',
                  value: function moveChildren(target, ref) {
                    _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'moveChildren', this).call(this, target, ref);
                    this.cache = {};
                  }
                }, {
                  key: 'optimize',
                  value: function optimize(context) {
                    _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'optimize', this).call(this, context);
                    this.cache = {};
                  }
                }, {
                  key: 'path',
                  value: function path(index) {
                    return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'path', this).call(this, index, true);
                  }
                }, {
                  key: 'removeChild',
                  value: function removeChild(child) {
                    _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'removeChild', this).call(this, child);
                    this.cache = {};
                  }
                }, {
                  key: 'split',
                  value: function split(index) {
                    var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                    if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {
                      var clone = this.clone();
                      if (index === 0) {
                        this.parent.insertBefore(clone, this);
                        return this;
                      } else {
                        this.parent.insertBefore(clone, this.next);
                        return clone;
                      }
                    } else {
                      var next = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'split', this).call(this, index, force);
                      this.cache = {};
                      return next;
                    }
                  }
                }]);
                return Block;
              }(_parchment2.default.Block);
              Block.blotName = 'block';
              Block.tagName = 'P';
              Block.defaultChild = 'break';
              Block.allowedChildren = [_inline2.default, _parchment2.default.Embed, _text2.default];
              function bubbleFormats(blot) {
                var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                if (blot == null) return formats;
                if (typeof blot.formats === 'function') {
                  formats = (0, _extend2.default)(formats, blot.formats());
                }
                if (blot.parent == null || blot.parent.blotName == 'scroll' || blot.parent.statics.scope !== blot.statics.scope) {
                  return formats;
                }
                return bubbleFormats(blot.parent, formats);
              }
              exports.bubbleFormats = bubbleFormats;
              exports.BlockEmbed = BlockEmbed;
              exports.default = Block;

              /***/
            }), (/* 5 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.default = exports.overload = exports.expandConfig = undefined;
              var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                return typeof obj;
              } : function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              };
              var _slicedToArray = function () {
                function sliceIterator(arr, i) {
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i) break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"]) _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }
                return function (arr, i) {
                  if (Array.isArray(arr)) {
                    return arr;
                  } else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                  } else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                  }
                };
              }();
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              __webpack_require__(50);
              var _quillDelta = __webpack_require__(2);
              var _quillDelta2 = _interopRequireDefault(_quillDelta);
              var _editor = __webpack_require__(14);
              var _editor2 = _interopRequireDefault(_editor);
              var _emitter3 = __webpack_require__(8);
              var _emitter4 = _interopRequireDefault(_emitter3);
              var _module = __webpack_require__(9);
              var _module2 = _interopRequireDefault(_module);
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _selection = __webpack_require__(15);
              var _selection2 = _interopRequireDefault(_selection);
              var _extend = __webpack_require__(3);
              var _extend2 = _interopRequireDefault(_extend);
              var _logger = __webpack_require__(10);
              var _logger2 = _interopRequireDefault(_logger);
              var _theme = __webpack_require__(34);
              var _theme2 = _interopRequireDefault(_theme);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var debug = (0, _logger2.default)('quill');
              var Quill = function () {
                _createClass(Quill, null, [{
                  key: 'debug',
                  value: function debug(limit) {
                    if (limit === true) {
                      limit = 'log';
                    }
                    _logger2.default.level(limit);
                  }
                }, {
                  key: 'find',
                  value: function find(node) {
                    return node.__quill || _parchment2.default.find(node);
                  }
                }, {
                  key: 'import',
                  value: function _import(name) {
                    if (this.imports[name] == null) {
                      debug.error('Cannot import ' + name + '. Are you sure it was registered?');
                    }
                    return this.imports[name];
                  }
                }, {
                  key: 'register',
                  value: function register(path, target) {
                    var _this = this;
                    var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                    if (typeof path !== 'string') {
                      var name = path.attrName || path.blotName;
                      if (typeof name === 'string') {
                        // register(Blot | Attributor, overwrite)
                        this.register('formats/' + name, path, target);
                      } else {
                        Object.keys(path).forEach(function (key) {
                          _this.register(key, path[key], target);
                        });
                      }
                    } else {
                      if (this.imports[path] != null && !overwrite) {
                        debug.warn('Overwriting ' + path + ' with', target);
                      }
                      this.imports[path] = target;
                      if ((path.startsWith('blots/') || path.startsWith('formats/')) && target.blotName !== 'abstract') {
                        _parchment2.default.register(target);
                      } else if (path.startsWith('modules') && typeof target.register === 'function') {
                        target.register();
                      }
                    }
                  }
                }]);
                function Quill(container) {
                  var _this2 = this;
                  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                  _classCallCheck(this, Quill);
                  this.options = expandConfig(container, options);
                  this.container = this.options.container;
                  if (this.container == null) {
                    return debug.error('Invalid Quill container', container);
                  }
                  if (this.options.debug) {
                    Quill.debug(this.options.debug);
                  }
                  var html = this.container.innerHTML.trim();
                  this.container.classList.add('ql-container');
                  this.container.innerHTML = '';
                  this.container.__quill = this;
                  this.root = this.addContainer('ql-editor');
                  this.root.classList.add('ql-blank');
                  this.root.setAttribute('data-gramm', false);
                  this.scrollingContainer = this.options.scrollingContainer || this.root;
                  this.emitter = new _emitter4.default();
                  this.scroll = _parchment2.default.create(this.root, {
                    emitter: this.emitter,
                    whitelist: this.options.formats
                  });
                  this.editor = new _editor2.default(this.scroll);
                  this.selection = new _selection2.default(this.scroll, this.emitter);
                  this.theme = new this.options.theme(this, this.options);
                  this.keyboard = this.theme.addModule('keyboard');
                  this.clipboard = this.theme.addModule('clipboard');
                  this.history = this.theme.addModule('history');
                  this.theme.init();
                  this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type) {
                    if (type === _emitter4.default.events.TEXT_CHANGE) {
                      _this2.root.classList.toggle('ql-blank', _this2.editor.isBlank());
                    }
                  });
                  this.emitter.on(_emitter4.default.events.SCROLL_UPDATE, function (source, mutations) {
                    var range = _this2.selection.lastRange;
                    var index = range && range.length === 0 ? range.index : undefined;
                    modify.call(_this2, function () {
                      return _this2.editor.update(null, mutations, index);
                    }, source);
                  });
                  var contents = this.clipboard.convert('<div class=\'ql-editor\' style="white-space: normal;">' + html + '<p><br></p></div>');
                  this.setContents(contents);
                  this.history.clear();
                  if (this.options.placeholder) {
                    this.root.setAttribute('data-placeholder', this.options.placeholder);
                  }
                  if (this.options.readOnly) {
                    this.disable();
                  }
                }
                _createClass(Quill, [{
                  key: 'addContainer',
                  value: function addContainer(container) {
                    var refNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                    if (typeof container === 'string') {
                      var className = container;
                      container = document.createElement('div');
                      container.classList.add(className);
                    }
                    this.container.insertBefore(container, refNode);
                    return container;
                  }
                }, {
                  key: 'blur',
                  value: function blur() {
                    this.selection.setRange(null);
                  }
                }, {
                  key: 'deleteText',
                  value: function deleteText(index, length, source) {
                    var _this3 = this;
                    var _overload = overload(index, length, source);
                    var _overload2 = _slicedToArray(_overload, 4);
                    index = _overload2[0];
                    length = _overload2[1];
                    source = _overload2[3];
                    return modify.call(this, function () {
                      return _this3.editor.deleteText(index, length);
                    }, source, index, -1 * length);
                  }
                }, {
                  key: 'disable',
                  value: function disable() {
                    this.enable(false);
                  }
                }, {
                  key: 'enable',
                  value: function enable() {
                    var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                    this.scroll.enable(enabled);
                    this.container.classList.toggle('ql-disabled', !enabled);
                  }
                }, {
                  key: 'focus',
                  value: function focus() {
                    var scrollTop = this.scrollingContainer.scrollTop;
                    this.selection.focus();
                    this.scrollingContainer.scrollTop = scrollTop;
                    this.scrollIntoView();
                  }
                }, {
                  key: 'format',
                  value: function format(name, value) {
                    var _this4 = this;
                    var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;
                    return modify.call(this, function () {
                      var range = _this4.getSelection(true);
                      var change = new _quillDelta2.default();
                      if (range == null) {
                        return change;
                      } else if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
                        change = _this4.editor.formatLine(range.index, range.length, _defineProperty({}, name, value));
                      } else if (range.length === 0) {
                        _this4.selection.format(name, value);
                        return change;
                      } else {
                        change = _this4.editor.formatText(range.index, range.length, _defineProperty({}, name, value));
                      }
                      _this4.setSelection(range, _emitter4.default.sources.SILENT);
                      return change;
                    }, source);
                  }
                }, {
                  key: 'formatLine',
                  value: function formatLine(index, length, name, value, source) {
                    var _this5 = this;
                    var formats = void 0;
                    var _overload3 = overload(index, length, name, value, source);
                    var _overload4 = _slicedToArray(_overload3, 4);
                    index = _overload4[0];
                    length = _overload4[1];
                    formats = _overload4[2];
                    source = _overload4[3];
                    return modify.call(this, function () {
                      return _this5.editor.formatLine(index, length, formats);
                    }, source, index, 0);
                  }
                }, {
                  key: 'formatText',
                  value: function formatText(index, length, name, value, source) {
                    var _this6 = this;
                    var formats = void 0;
                    var _overload5 = overload(index, length, name, value, source);
                    var _overload6 = _slicedToArray(_overload5, 4);
                    index = _overload6[0];
                    length = _overload6[1];
                    formats = _overload6[2];
                    source = _overload6[3];
                    return modify.call(this, function () {
                      return _this6.editor.formatText(index, length, formats);
                    }, source, index, 0);
                  }
                }, {
                  key: 'getBounds',
                  value: function getBounds(index) {
                    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    var bounds = void 0;
                    if (typeof index === 'number') {
                      bounds = this.selection.getBounds(index, length);
                    } else {
                      bounds = this.selection.getBounds(index.index, index.length);
                    }
                    var containerBounds = this.container.getBoundingClientRect();
                    return {
                      bottom: bounds.bottom - containerBounds.top,
                      height: bounds.height,
                      left: bounds.left - containerBounds.left,
                      right: bounds.right - containerBounds.left,
                      top: bounds.top - containerBounds.top,
                      width: bounds.width
                    };
                  }
                }, {
                  key: 'getContents',
                  value: function getContents() {
                    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;
                    var _overload7 = overload(index, length);
                    var _overload8 = _slicedToArray(_overload7, 2);
                    index = _overload8[0];
                    length = _overload8[1];
                    return this.editor.getContents(index, length);
                  }
                }, {
                  key: 'getFormat',
                  value: function getFormat() {
                    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getSelection(true);
                    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    if (typeof index === 'number') {
                      return this.editor.getFormat(index, length);
                    } else {
                      return this.editor.getFormat(index.index, index.length);
                    }
                  }
                }, {
                  key: 'getIndex',
                  value: function getIndex(blot) {
                    return blot.offset(this.scroll);
                  }
                }, {
                  key: 'getLength',
                  value: function getLength() {
                    return this.scroll.length();
                  }
                }, {
                  key: 'getLeaf',
                  value: function getLeaf(index) {
                    return this.scroll.leaf(index);
                  }
                }, {
                  key: 'getLine',
                  value: function getLine(index) {
                    return this.scroll.line(index);
                  }
                }, {
                  key: 'getLines',
                  value: function getLines() {
                    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;
                    if (typeof index !== 'number') {
                      return this.scroll.lines(index.index, index.length);
                    } else {
                      return this.scroll.lines(index, length);
                    }
                  }
                }, {
                  key: 'getModule',
                  value: function getModule(name) {
                    return this.theme.modules[name];
                  }
                }, {
                  key: 'getSelection',
                  value: function getSelection() {
                    var focus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                    if (focus) this.focus();
                    this.update(); // Make sure we access getRange with editor in consistent state
                    return this.selection.getRange()[0];
                  }
                }, {
                  key: 'getText',
                  value: function getText() {
                    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;
                    var _overload9 = overload(index, length);
                    var _overload10 = _slicedToArray(_overload9, 2);
                    index = _overload10[0];
                    length = _overload10[1];
                    return this.editor.getText(index, length);
                  }
                }, {
                  key: 'hasFocus',
                  value: function hasFocus() {
                    return this.selection.hasFocus();
                  }
                }, {
                  key: 'insertEmbed',
                  value: function insertEmbed(index, embed, value) {
                    var _this7 = this;
                    var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Quill.sources.API;
                    return modify.call(this, function () {
                      return _this7.editor.insertEmbed(index, embed, value);
                    }, source, index);
                  }
                }, {
                  key: 'insertText',
                  value: function insertText(index, text, name, value, source) {
                    var _this8 = this;
                    var formats = void 0;
                    var _overload11 = overload(index, 0, name, value, source);
                    var _overload12 = _slicedToArray(_overload11, 4);
                    index = _overload12[0];
                    formats = _overload12[2];
                    source = _overload12[3];
                    return modify.call(this, function () {
                      return _this8.editor.insertText(index, text, formats);
                    }, source, index, text.length);
                  }
                }, {
                  key: 'isEnabled',
                  value: function isEnabled() {
                    return !this.container.classList.contains('ql-disabled');
                  }
                }, {
                  key: 'off',
                  value: function off() {
                    return this.emitter.off.apply(this.emitter, arguments);
                  }
                }, {
                  key: 'on',
                  value: function on() {
                    return this.emitter.on.apply(this.emitter, arguments);
                  }
                }, {
                  key: 'once',
                  value: function once() {
                    return this.emitter.once.apply(this.emitter, arguments);
                  }
                }, {
                  key: 'pasteHTML',
                  value: function pasteHTML(index, html, source) {
                    this.clipboard.dangerouslyPasteHTML(index, html, source);
                  }
                }, {
                  key: 'removeFormat',
                  value: function removeFormat(index, length, source) {
                    var _this9 = this;
                    var _overload13 = overload(index, length, source);
                    var _overload14 = _slicedToArray(_overload13, 4);
                    index = _overload14[0];
                    length = _overload14[1];
                    source = _overload14[3];
                    return modify.call(this, function () {
                      return _this9.editor.removeFormat(index, length);
                    }, source, index);
                  }
                }, {
                  key: 'scrollIntoView',
                  value: function scrollIntoView() {
                    this.selection.scrollIntoView(this.scrollingContainer);
                  }
                }, {
                  key: 'setContents',
                  value: function setContents(delta) {
                    var _this10 = this;
                    var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;
                    return modify.call(this, function () {
                      delta = new _quillDelta2.default(delta);
                      var length = _this10.getLength();
                      var deleted = _this10.editor.deleteText(0, length);
                      var applied = _this10.editor.applyDelta(delta);
                      var lastOp = applied.ops[applied.ops.length - 1];
                      if (lastOp != null && typeof lastOp.insert === 'string' && lastOp.insert[lastOp.insert.length - 1] === '\n') {
                        _this10.editor.deleteText(_this10.getLength() - 1, 1);
                        applied.delete(1);
                      }
                      var ret = deleted.compose(applied);
                      return ret;
                    }, source);
                  }
                }, {
                  key: 'setSelection',
                  value: function setSelection(index, length, source) {
                    if (index == null) {
                      this.selection.setRange(null, length || Quill.sources.API);
                    } else {
                      var _overload15 = overload(index, length, source);
                      var _overload16 = _slicedToArray(_overload15, 4);
                      index = _overload16[0];
                      length = _overload16[1];
                      source = _overload16[3];
                      this.selection.setRange(new _selection.Range(index, length), source);
                      if (source !== _emitter4.default.sources.SILENT) {
                        this.selection.scrollIntoView(this.scrollingContainer);
                      }
                    }
                  }
                }, {
                  key: 'setText',
                  value: function setText(text) {
                    var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;
                    var delta = new _quillDelta2.default().insert(text);
                    return this.setContents(delta, source);
                  }
                }, {
                  key: 'update',
                  value: function update() {
                    var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;
                    var change = this.scroll.update(source); // Will update selection before selection.update() does if text changes
                    this.selection.update(source);
                    return change;
                  }
                }, {
                  key: 'updateContents',
                  value: function updateContents(delta) {
                    var _this11 = this;
                    var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;
                    return modify.call(this, function () {
                      delta = new _quillDelta2.default(delta);
                      return _this11.editor.applyDelta(delta, source);
                    }, source, true);
                  }
                }]);
                return Quill;
              }();
              Quill.DEFAULTS = {
                bounds: null,
                formats: null,
                modules: {},
                placeholder: '',
                readOnly: false,
                scrollingContainer: null,
                strict: true,
                theme: 'default'
              };
              Quill.events = _emitter4.default.events;
              Quill.sources = _emitter4.default.sources;
              // eslint-disable-next-line no-undef
              Quill.version = "1.3.7";
              Quill.imports = {
                'delta': _quillDelta2.default,
                'parchment': _parchment2.default,
                'core/module': _module2.default,
                'core/theme': _theme2.default
              };
              function expandConfig(container, userConfig) {
                userConfig = (0, _extend2.default)(true, {
                  container: container,
                  modules: {
                    clipboard: true,
                    keyboard: true,
                    history: true
                  }
                }, userConfig);
                if (!userConfig.theme || userConfig.theme === Quill.DEFAULTS.theme) {
                  userConfig.theme = _theme2.default;
                } else {
                  userConfig.theme = Quill.import('themes/' + userConfig.theme);
                  if (userConfig.theme == null) {
                    throw new Error('Invalid theme ' + userConfig.theme + '. Did you register it?');
                  }
                }
                var themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);
                [themeConfig, userConfig].forEach(function (config) {
                  config.modules = config.modules || {};
                  Object.keys(config.modules).forEach(function (module) {
                    if (config.modules[module] === true) {
                      config.modules[module] = {};
                    }
                  });
                });
                var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));
                var moduleConfig = moduleNames.reduce(function (config, name) {
                  var moduleClass = Quill.import('modules/' + name);
                  if (moduleClass == null) {
                    debug.error('Cannot load ' + name + ' module. Are you sure you registered it?');
                  } else {
                    config[name] = moduleClass.DEFAULTS || {};
                  }
                  return config;
                }, {});
                // Special case toolbar shorthand
                if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {
                  userConfig.modules.toolbar = {
                    container: userConfig.modules.toolbar
                  };
                }
                userConfig = (0, _extend2.default)(true, {}, Quill.DEFAULTS, {
                  modules: moduleConfig
                }, themeConfig, userConfig);
                ['bounds', 'container', 'scrollingContainer'].forEach(function (key) {
                  if (typeof userConfig[key] === 'string') {
                    userConfig[key] = document.querySelector(userConfig[key]);
                  }
                });
                userConfig.modules = Object.keys(userConfig.modules).reduce(function (config, name) {
                  if (userConfig.modules[name]) {
                    config[name] = userConfig.modules[name];
                  }
                  return config;
                }, {});
                return userConfig;
              }

              // Handle selection preservation and TEXT_CHANGE emission
              // common to modification APIs
              function modify(modifier, source, index, shift) {
                if (this.options.strict && !this.isEnabled() && source === _emitter4.default.sources.USER) {
                  return new _quillDelta2.default();
                }
                var range = index == null ? null : this.getSelection();
                var oldDelta = this.editor.delta;
                var change = modifier();
                if (range != null) {
                  if (index === true) index = range.index;
                  if (shift == null) {
                    range = shiftRange(range, change, source);
                  } else if (shift !== 0) {
                    range = shiftRange(range, index, shift, source);
                  }
                  this.setSelection(range, _emitter4.default.sources.SILENT);
                }
                if (change.length() > 0) {
                  var _emitter;
                  var args = [_emitter4.default.events.TEXT_CHANGE, change, oldDelta, source];
                  (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
                  if (source !== _emitter4.default.sources.SILENT) {
                    var _emitter2;
                    (_emitter2 = this.emitter).emit.apply(_emitter2, args);
                  }
                }
                return change;
              }
              function overload(index, length, name, value, source) {
                var formats = {};
                if (typeof index.index === 'number' && typeof index.length === 'number') {
                  // Allow for throwaway end (used by insertText/insertEmbed)
                  if (typeof length !== 'number') {
                    source = value, value = name, name = length, length = index.length, index = index.index;
                  } else {
                    length = index.length, index = index.index;
                  }
                } else if (typeof length !== 'number') {
                  source = value, value = name, name = length, length = 0;
                }
                // Handle format being object, two format name/value strings or excluded
                if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
                  formats = name;
                  source = value;
                } else if (typeof name === 'string') {
                  if (value != null) {
                    formats[name] = value;
                  } else {
                    source = name;
                  }
                }
                // Handle optional source
                source = source || _emitter4.default.sources.API;
                return [index, length, formats, source];
              }
              function shiftRange(range, index, length, source) {
                if (range == null) return null;
                var start = void 0,
                  end = void 0;
                if (index instanceof _quillDelta2.default) {
                  var _map = [range.index, range.index + range.length].map(function (pos) {
                    return index.transformPosition(pos, source !== _emitter4.default.sources.USER);
                  });
                  var _map2 = _slicedToArray(_map, 2);
                  start = _map2[0];
                  end = _map2[1];
                } else {
                  var _map3 = [range.index, range.index + range.length].map(function (pos) {
                    if (pos < index || pos === index && source === _emitter4.default.sources.USER) return pos;
                    if (length >= 0) {
                      return pos + length;
                    } else {
                      return Math.max(index, pos + length);
                    }
                  });
                  var _map4 = _slicedToArray(_map3, 2);
                  start = _map4[0];
                  end = _map4[1];
                }
                return new _selection.Range(start, end - start);
              }
              exports.expandConfig = expandConfig;
              exports.overload = overload;
              exports.default = Quill;

              /***/
            }), (/* 6 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _text = __webpack_require__(7);
              var _text2 = _interopRequireDefault(_text);
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var Inline = function (_Parchment$Inline) {
                _inherits(Inline, _Parchment$Inline);
                function Inline() {
                  _classCallCheck(this, Inline);
                  return _possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));
                }
                _createClass(Inline, [{
                  key: 'formatAt',
                  value: function formatAt(index, length, name, value) {
                    if (Inline.compare(this.statics.blotName, name) < 0 && _parchment2.default.query(name, _parchment2.default.Scope.BLOT)) {
                      var blot = this.isolate(index, length);
                      if (value) {
                        blot.wrap(name, value);
                      }
                    } else {
                      _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'formatAt', this).call(this, index, length, name, value);
                    }
                  }
                }, {
                  key: 'optimize',
                  value: function optimize(context) {
                    _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'optimize', this).call(this, context);
                    if (this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
                      var parent = this.parent.isolate(this.offset(), this.length());
                      this.moveChildren(parent);
                      parent.wrap(this);
                    }
                  }
                }], [{
                  key: 'compare',
                  value: function compare(self, other) {
                    var selfIndex = Inline.order.indexOf(self);
                    var otherIndex = Inline.order.indexOf(other);
                    if (selfIndex >= 0 || otherIndex >= 0) {
                      return selfIndex - otherIndex;
                    } else if (self === other) {
                      return 0;
                    } else if (self < other) {
                      return -1;
                    } else {
                      return 1;
                    }
                  }
                }]);
                return Inline;
              }(_parchment2.default.Inline);
              Inline.allowedChildren = [Inline, _parchment2.default.Embed, _text2.default];
              // Lower index means deeper in the DOM tree, since not found (-1) is for embeds
              Inline.order = ['cursor', 'inline',
              // Must be lower
              'underline', 'strike', 'italic', 'bold', 'script', 'link', 'code' // Must be higher
              ];
              exports.default = Inline;

              /***/
            }), (/* 7 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var TextBlot = function (_Parchment$Text) {
                _inherits(TextBlot, _Parchment$Text);
                function TextBlot() {
                  _classCallCheck(this, TextBlot);
                  return _possibleConstructorReturn(this, (TextBlot.__proto__ || Object.getPrototypeOf(TextBlot)).apply(this, arguments));
                }
                return TextBlot;
              }(_parchment2.default.Text);
              exports.default = TextBlot;

              /***/
            }), (/* 8 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _eventemitter = __webpack_require__(54);
              var _eventemitter2 = _interopRequireDefault(_eventemitter);
              var _logger = __webpack_require__(10);
              var _logger2 = _interopRequireDefault(_logger);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var debug = (0, _logger2.default)('quill:events');
              var EVENTS = ['selectionchange', 'mousedown', 'mouseup', 'click'];
              EVENTS.forEach(function (eventName) {
                document.addEventListener(eventName, function () {
                  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }
                  [].slice.call(document.querySelectorAll('.ql-container')).forEach(function (node) {
                    // TODO use WeakMap
                    if (node.__quill && node.__quill.emitter) {
                      var _node$__quill$emitter;
                      (_node$__quill$emitter = node.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);
                    }
                  });
                });
              });
              var Emitter = function (_EventEmitter) {
                _inherits(Emitter, _EventEmitter);
                function Emitter() {
                  _classCallCheck(this, Emitter);
                  var _this = _possibleConstructorReturn(this, (Emitter.__proto__ || Object.getPrototypeOf(Emitter)).call(this));
                  _this.listeners = {};
                  _this.on('error', debug.error);
                  return _this;
                }
                _createClass(Emitter, [{
                  key: 'emit',
                  value: function emit() {
                    debug.log.apply(debug, arguments);
                    _get(Emitter.prototype.__proto__ || Object.getPrototypeOf(Emitter.prototype), 'emit', this).apply(this, arguments);
                  }
                }, {
                  key: 'handleDOM',
                  value: function handleDOM(event) {
                    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                      args[_key2 - 1] = arguments[_key2];
                    }
                    (this.listeners[event.type] || []).forEach(function (_ref) {
                      var node = _ref.node,
                        handler = _ref.handler;
                      if (event.target === node || node.contains(event.target)) {
                        handler.apply(undefined, [event].concat(args));
                      }
                    });
                  }
                }, {
                  key: 'listenDOM',
                  value: function listenDOM(eventName, node, handler) {
                    if (!this.listeners[eventName]) {
                      this.listeners[eventName] = [];
                    }
                    this.listeners[eventName].push({
                      node: node,
                      handler: handler
                    });
                  }
                }]);
                return Emitter;
              }(_eventemitter2.default);
              Emitter.events = {
                EDITOR_CHANGE: 'editor-change',
                SCROLL_BEFORE_UPDATE: 'scroll-before-update',
                SCROLL_OPTIMIZE: 'scroll-optimize',
                SCROLL_UPDATE: 'scroll-update',
                SELECTION_CHANGE: 'selection-change',
                TEXT_CHANGE: 'text-change'
              };
              Emitter.sources = {
                API: 'api',
                SILENT: 'silent',
                USER: 'user'
              };
              exports.default = Emitter;

              /***/
            }), (/* 9 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var Module = function Module(quill) {
                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                _classCallCheck(this, Module);
                this.quill = quill;
                this.options = options;
              };
              Module.DEFAULTS = {};
              exports.default = Module;

              /***/
            }), (/* 10 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var levels = ['error', 'warn', 'log', 'info'];
              var level = 'warn';
              function debug(method) {
                if (levels.indexOf(method) <= levels.indexOf(level)) {
                  var _console;
                  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                  }
                  (_console = console)[method].apply(_console, args); // eslint-disable-line no-console
                }
              }
              function namespace(ns) {
                return levels.reduce(function (logger, method) {
                  logger[method] = debug.bind(console, method, ns);
                  return logger;
                }, {});
              }
              debug.level = namespace.level = function (newLevel) {
                level = newLevel;
              };
              exports.default = namespace;

              /***/
            }), (/* 11 */
            /***/function (module, exports, __webpack_require__) {
              var pSlice = Array.prototype.slice;
              var objectKeys = __webpack_require__(52);
              var isArguments = __webpack_require__(53);
              var deepEqual = module.exports = function (actual, expected, opts) {
                if (!opts) opts = {};
                // 7.1. All identical values are equivalent, as determined by ===.
                if (actual === expected) {
                  return true;
                } else if (actual instanceof Date && expected instanceof Date) {
                  return actual.getTime() === expected.getTime();

                  // 7.3. Other pairs that do not both pass typeof value == 'object',
                  // equivalence is determined by ==.
                } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
                  return opts.strict ? actual === expected : actual == expected;

                  // 7.4. For all other Object pairs, including Array objects, equivalence is
                  // determined by having the same number of owned properties (as verified
                  // with Object.prototype.hasOwnProperty.call), the same set of keys
                  // (although not necessarily the same order), equivalent values for every
                  // corresponding key, and an identical 'prototype' property. Note: this
                  // accounts for both named and indexed properties on Arrays.
                } else {
                  return objEquiv(actual, expected, opts);
                }
              };
              function isUndefinedOrNull(value) {
                return value === null || value === undefined;
              }
              function isBuffer(x) {
                if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
                if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
                  return false;
                }
                if (x.length > 0 && typeof x[0] !== 'number') return false;
                return true;
              }
              function objEquiv(a, b, opts) {
                var i, key;
                if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
                // an identical 'prototype' property.
                if (a.prototype !== b.prototype) return false;
                //~~~I've managed to break Object.keys through screwy arguments passing.
                //   Converting to array solves the problem.
                if (isArguments(a)) {
                  if (!isArguments(b)) {
                    return false;
                  }
                  a = pSlice.call(a);
                  b = pSlice.call(b);
                  return deepEqual(a, b, opts);
                }
                if (isBuffer(a)) {
                  if (!isBuffer(b)) {
                    return false;
                  }
                  if (a.length !== b.length) return false;
                  for (i = 0; i < a.length; i++) {
                    if (a[i] !== b[i]) return false;
                  }
                  return true;
                }
                try {
                  var ka = objectKeys(a),
                    kb = objectKeys(b);
                } catch (e) {
                  //happens when one is a string literal and the other isn't
                  return false;
                }
                // having the same number of owned properties (keys incorporates
                // hasOwnProperty)
                if (ka.length != kb.length) return false;
                //the same set of keys (although not necessarily the same order),
                ka.sort();
                kb.sort();
                //~~~cheap key test
                for (i = ka.length - 1; i >= 0; i--) {
                  if (ka[i] != kb[i]) return false;
                }
                //equivalent values for every corresponding key, and
                //~~~possibly expensive deep test
                for (i = ka.length - 1; i >= 0; i--) {
                  key = ka[i];
                  if (!deepEqual(a[key], b[key], opts)) return false;
                }
                return typeof a === typeof b;
              }

              /***/
            }), (/* 12 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var Registry = __webpack_require__(1);
              var Attributor = /** @class */function () {
                function Attributor(attrName, keyName, options) {
                  if (options === void 0) {
                    options = {};
                  }
                  this.attrName = attrName;
                  this.keyName = keyName;
                  var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;
                  if (options.scope != null) {
                    // Ignore type bits, force attribute bit
                    this.scope = options.scope & Registry.Scope.LEVEL | attributeBit;
                  } else {
                    this.scope = Registry.Scope.ATTRIBUTE;
                  }
                  if (options.whitelist != null) this.whitelist = options.whitelist;
                }
                Attributor.keys = function (node) {
                  return [].map.call(node.attributes, function (item) {
                    return item.name;
                  });
                };
                Attributor.prototype.add = function (node, value) {
                  if (!this.canAdd(node, value)) return false;
                  node.setAttribute(this.keyName, value);
                  return true;
                };
                Attributor.prototype.canAdd = function (node, value) {
                  var match = Registry.query(node, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));
                  if (match == null) return false;
                  if (this.whitelist == null) return true;
                  if (typeof value === 'string') {
                    return this.whitelist.indexOf(value.replace(/["']/g, '')) > -1;
                  } else {
                    return this.whitelist.indexOf(value) > -1;
                  }
                };
                Attributor.prototype.remove = function (node) {
                  node.removeAttribute(this.keyName);
                };
                Attributor.prototype.value = function (node) {
                  var value = node.getAttribute(this.keyName);
                  if (this.canAdd(node, value) && value) {
                    return value;
                  }
                  return '';
                };
                return Attributor;
              }();
              exports.default = Attributor;

              /***/
            }), (/* 13 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.default = exports.Code = undefined;
              var _slicedToArray = function () {
                function sliceIterator(arr, i) {
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i) break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"]) _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }
                return function (arr, i) {
                  if (Array.isArray(arr)) {
                    return arr;
                  } else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                  } else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                  }
                };
              }();
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _quillDelta = __webpack_require__(2);
              var _quillDelta2 = _interopRequireDefault(_quillDelta);
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _block = __webpack_require__(4);
              var _block2 = _interopRequireDefault(_block);
              var _inline = __webpack_require__(6);
              var _inline2 = _interopRequireDefault(_inline);
              var _text = __webpack_require__(7);
              var _text2 = _interopRequireDefault(_text);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var Code = function (_Inline) {
                _inherits(Code, _Inline);
                function Code() {
                  _classCallCheck(this, Code);
                  return _possibleConstructorReturn(this, (Code.__proto__ || Object.getPrototypeOf(Code)).apply(this, arguments));
                }
                return Code;
              }(_inline2.default);
              Code.blotName = 'code';
              Code.tagName = 'CODE';
              var CodeBlock = function (_Block) {
                _inherits(CodeBlock, _Block);
                function CodeBlock() {
                  _classCallCheck(this, CodeBlock);
                  return _possibleConstructorReturn(this, (CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock)).apply(this, arguments));
                }
                _createClass(CodeBlock, [{
                  key: 'delta',
                  value: function delta() {
                    var _this3 = this;
                    var text = this.domNode.textContent;
                    if (text.endsWith('\n')) {
                      // Should always be true
                      text = text.slice(0, -1);
                    }
                    return text.split('\n').reduce(function (delta, frag) {
                      return delta.insert(frag).insert('\n', _this3.formats());
                    }, new _quillDelta2.default());
                  }
                }, {
                  key: 'format',
                  value: function format(name, value) {
                    if (name === this.statics.blotName && value) return;
                    var _descendant = this.descendant(_text2.default, this.length() - 1),
                      _descendant2 = _slicedToArray(_descendant, 1),
                      text = _descendant2[0];
                    if (text != null) {
                      text.deleteAt(text.length() - 1, 1);
                    }
                    _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'format', this).call(this, name, value);
                  }
                }, {
                  key: 'formatAt',
                  value: function formatAt(index, length, name, value) {
                    if (length === 0) return;
                    if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {
                      return;
                    }
                    var nextNewline = this.newlineIndex(index);
                    if (nextNewline < 0 || nextNewline >= index + length) return;
                    var prevNewline = this.newlineIndex(index, true) + 1;
                    var isolateLength = nextNewline - prevNewline + 1;
                    var blot = this.isolate(prevNewline, isolateLength);
                    var next = blot.next;
                    blot.format(name, value);
                    if (next instanceof CodeBlock) {
                      next.formatAt(0, index - prevNewline + length - isolateLength, name, value);
                    }
                  }
                }, {
                  key: 'insertAt',
                  value: function insertAt(index, value, def) {
                    if (def != null) return;
                    var _descendant3 = this.descendant(_text2.default, index),
                      _descendant4 = _slicedToArray(_descendant3, 2),
                      text = _descendant4[0],
                      offset = _descendant4[1];
                    text.insertAt(offset, value);
                  }
                }, {
                  key: 'length',
                  value: function length() {
                    var length = this.domNode.textContent.length;
                    if (!this.domNode.textContent.endsWith('\n')) {
                      return length + 1;
                    }
                    return length;
                  }
                }, {
                  key: 'newlineIndex',
                  value: function newlineIndex(searchIndex) {
                    var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                    if (!reverse) {
                      var offset = this.domNode.textContent.slice(searchIndex).indexOf('\n');
                      return offset > -1 ? searchIndex + offset : -1;
                    } else {
                      return this.domNode.textContent.slice(0, searchIndex).lastIndexOf('\n');
                    }
                  }
                }, {
                  key: 'optimize',
                  value: function optimize(context) {
                    if (!this.domNode.textContent.endsWith('\n')) {
                      this.appendChild(_parchment2.default.create('text', '\n'));
                    }
                    _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'optimize', this).call(this, context);
                    var next = this.next;
                    if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {
                      next.optimize(context);
                      next.moveChildren(this);
                      next.remove();
                    }
                  }
                }, {
                  key: 'replace',
                  value: function replace(target) {
                    _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'replace', this).call(this, target);
                    [].slice.call(this.domNode.querySelectorAll('*')).forEach(function (node) {
                      var blot = _parchment2.default.find(node);
                      if (blot == null) {
                        node.parentNode.removeChild(node);
                      } else if (blot instanceof _parchment2.default.Embed) {
                        blot.remove();
                      } else {
                        blot.unwrap();
                      }
                    });
                  }
                }], [{
                  key: 'create',
                  value: function create(value) {
                    var domNode = _get(CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock), 'create', this).call(this, value);
                    domNode.setAttribute('spellcheck', false);
                    return domNode;
                  }
                }, {
                  key: 'formats',
                  value: function formats() {
                    return true;
                  }
                }]);
                return CodeBlock;
              }(_block2.default);
              CodeBlock.blotName = 'code-block';
              CodeBlock.tagName = 'PRE';
              CodeBlock.TAB = '  ';
              exports.Code = Code;
              exports.default = CodeBlock;

              /***/
            }), (/* 14 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                return typeof obj;
              } : function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              };
              var _slicedToArray = function () {
                function sliceIterator(arr, i) {
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i) break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"]) _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }
                return function (arr, i) {
                  if (Array.isArray(arr)) {
                    return arr;
                  } else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                  } else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                  }
                };
              }();
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _quillDelta = __webpack_require__(2);
              var _quillDelta2 = _interopRequireDefault(_quillDelta);
              var _op = __webpack_require__(20);
              var _op2 = _interopRequireDefault(_op);
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _code = __webpack_require__(13);
              var _code2 = _interopRequireDefault(_code);
              var _cursor = __webpack_require__(24);
              var _cursor2 = _interopRequireDefault(_cursor);
              var _block = __webpack_require__(4);
              var _block2 = _interopRequireDefault(_block);
              var _break = __webpack_require__(16);
              var _break2 = _interopRequireDefault(_break);
              var _clone = __webpack_require__(21);
              var _clone2 = _interopRequireDefault(_clone);
              var _deepEqual = __webpack_require__(11);
              var _deepEqual2 = _interopRequireDefault(_deepEqual);
              var _extend = __webpack_require__(3);
              var _extend2 = _interopRequireDefault(_extend);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var ASCII = /^[ -~]*$/;
              var Editor = function () {
                function Editor(scroll) {
                  _classCallCheck(this, Editor);
                  this.scroll = scroll;
                  this.delta = this.getDelta();
                }
                _createClass(Editor, [{
                  key: 'applyDelta',
                  value: function applyDelta(delta) {
                    var _this = this;
                    var consumeNextNewline = false;
                    this.scroll.update();
                    var scrollLength = this.scroll.length();
                    this.scroll.batchStart();
                    delta = normalizeDelta(delta);
                    delta.reduce(function (index, op) {
                      var length = op.retain || op.delete || op.insert.length || 1;
                      var attributes = op.attributes || {};
                      if (op.insert != null) {
                        if (typeof op.insert === 'string') {
                          var text = op.insert;
                          if (text.endsWith('\n') && consumeNextNewline) {
                            consumeNextNewline = false;
                            text = text.slice(0, -1);
                          }
                          if (index >= scrollLength && !text.endsWith('\n')) {
                            consumeNextNewline = true;
                          }
                          _this.scroll.insertAt(index, text);
                          var _scroll$line = _this.scroll.line(index),
                            _scroll$line2 = _slicedToArray(_scroll$line, 2),
                            line = _scroll$line2[0],
                            offset = _scroll$line2[1];
                          var formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));
                          if (line instanceof _block2.default) {
                            var _line$descendant = line.descendant(_parchment2.default.Leaf, offset),
                              _line$descendant2 = _slicedToArray(_line$descendant, 1),
                              leaf = _line$descendant2[0];
                            formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));
                          }
                          attributes = _op2.default.attributes.diff(formats, attributes) || {};
                        } else if (_typeof(op.insert) === 'object') {
                          var key = Object.keys(op.insert)[0]; // There should only be one key
                          if (key == null) return index;
                          _this.scroll.insertAt(index, key, op.insert[key]);
                        }
                        scrollLength += length;
                      }
                      Object.keys(attributes).forEach(function (name) {
                        _this.scroll.formatAt(index, length, name, attributes[name]);
                      });
                      return index + length;
                    }, 0);
                    delta.reduce(function (index, op) {
                      if (typeof op.delete === 'number') {
                        _this.scroll.deleteAt(index, op.delete);
                        return index;
                      }
                      return index + (op.retain || op.insert.length || 1);
                    }, 0);
                    this.scroll.batchEnd();
                    return this.update(delta);
                  }
                }, {
                  key: 'deleteText',
                  value: function deleteText(index, length) {
                    this.scroll.deleteAt(index, length);
                    return this.update(new _quillDelta2.default().retain(index).delete(length));
                  }
                }, {
                  key: 'formatLine',
                  value: function formatLine(index, length) {
                    var _this2 = this;
                    var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                    this.scroll.update();
                    Object.keys(formats).forEach(function (format) {
                      if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format]) return;
                      var lines = _this2.scroll.lines(index, Math.max(length, 1));
                      var lengthRemaining = length;
                      lines.forEach(function (line) {
                        var lineLength = line.length();
                        if (!(line instanceof _code2.default)) {
                          line.format(format, formats[format]);
                        } else {
                          var codeIndex = index - line.offset(_this2.scroll);
                          var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;
                          line.formatAt(codeIndex, codeLength, format, formats[format]);
                        }
                        lengthRemaining -= lineLength;
                      });
                    });
                    this.scroll.optimize();
                    return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));
                  }
                }, {
                  key: 'formatText',
                  value: function formatText(index, length) {
                    var _this3 = this;
                    var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                    Object.keys(formats).forEach(function (format) {
                      _this3.scroll.formatAt(index, length, format, formats[format]);
                    });
                    return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));
                  }
                }, {
                  key: 'getContents',
                  value: function getContents(index, length) {
                    return this.delta.slice(index, index + length);
                  }
                }, {
                  key: 'getDelta',
                  value: function getDelta() {
                    return this.scroll.lines().reduce(function (delta, line) {
                      return delta.concat(line.delta());
                    }, new _quillDelta2.default());
                  }
                }, {
                  key: 'getFormat',
                  value: function getFormat(index) {
                    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    var lines = [],
                      leaves = [];
                    if (length === 0) {
                      this.scroll.path(index).forEach(function (path) {
                        var _path = _slicedToArray(path, 1),
                          blot = _path[0];
                        if (blot instanceof _block2.default) {
                          lines.push(blot);
                        } else if (blot instanceof _parchment2.default.Leaf) {
                          leaves.push(blot);
                        }
                      });
                    } else {
                      lines = this.scroll.lines(index, length);
                      leaves = this.scroll.descendants(_parchment2.default.Leaf, index, length);
                    }
                    var formatsArr = [lines, leaves].map(function (blots) {
                      if (blots.length === 0) return {};
                      var formats = (0, _block.bubbleFormats)(blots.shift());
                      while (Object.keys(formats).length > 0) {
                        var blot = blots.shift();
                        if (blot == null) return formats;
                        formats = combineFormats((0, _block.bubbleFormats)(blot), formats);
                      }
                      return formats;
                    });
                    return _extend2.default.apply(_extend2.default, formatsArr);
                  }
                }, {
                  key: 'getText',
                  value: function getText(index, length) {
                    return this.getContents(index, length).filter(function (op) {
                      return typeof op.insert === 'string';
                    }).map(function (op) {
                      return op.insert;
                    }).join('');
                  }
                }, {
                  key: 'insertEmbed',
                  value: function insertEmbed(index, embed, value) {
                    this.scroll.insertAt(index, embed, value);
                    return this.update(new _quillDelta2.default().retain(index).insert(_defineProperty({}, embed, value)));
                  }
                }, {
                  key: 'insertText',
                  value: function insertText(index, text) {
                    var _this4 = this;
                    var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                    text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                    this.scroll.insertAt(index, text);
                    Object.keys(formats).forEach(function (format) {
                      _this4.scroll.formatAt(index, text.length, format, formats[format]);
                    });
                    return this.update(new _quillDelta2.default().retain(index).insert(text, (0, _clone2.default)(formats)));
                  }
                }, {
                  key: 'isBlank',
                  value: function isBlank() {
                    if (this.scroll.children.length == 0) return true;
                    if (this.scroll.children.length > 1) return false;
                    var block = this.scroll.children.head;
                    if (block.statics.blotName !== _block2.default.blotName) return false;
                    if (block.children.length > 1) return false;
                    return block.children.head instanceof _break2.default;
                  }
                }, {
                  key: 'removeFormat',
                  value: function removeFormat(index, length) {
                    var text = this.getText(index, length);
                    var _scroll$line3 = this.scroll.line(index + length),
                      _scroll$line4 = _slicedToArray(_scroll$line3, 2),
                      line = _scroll$line4[0],
                      offset = _scroll$line4[1];
                    var suffixLength = 0,
                      suffix = new _quillDelta2.default();
                    if (line != null) {
                      if (!(line instanceof _code2.default)) {
                        suffixLength = line.length() - offset;
                      } else {
                        suffixLength = line.newlineIndex(offset) - offset + 1;
                      }
                      suffix = line.delta().slice(offset, offset + suffixLength - 1).insert('\n');
                    }
                    var contents = this.getContents(index, length + suffixLength);
                    var diff = contents.diff(new _quillDelta2.default().insert(text).concat(suffix));
                    var delta = new _quillDelta2.default().retain(index).concat(diff);
                    return this.applyDelta(delta);
                  }
                }, {
                  key: 'update',
                  value: function update(change) {
                    var mutations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
                    var cursorIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
                    var oldDelta = this.delta;
                    if (mutations.length === 1 && mutations[0].type === 'characterData' && mutations[0].target.data.match(ASCII) && _parchment2.default.find(mutations[0].target)) {
                      // Optimization for character changes
                      var textBlot = _parchment2.default.find(mutations[0].target);
                      var formats = (0, _block.bubbleFormats)(textBlot);
                      var index = textBlot.offset(this.scroll);
                      var oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, '');
                      var oldText = new _quillDelta2.default().insert(oldValue);
                      var newText = new _quillDelta2.default().insert(textBlot.value());
                      var diffDelta = new _quillDelta2.default().retain(index).concat(oldText.diff(newText, cursorIndex));
                      change = diffDelta.reduce(function (delta, op) {
                        if (op.insert) {
                          return delta.insert(op.insert, formats);
                        } else {
                          return delta.push(op);
                        }
                      }, new _quillDelta2.default());
                      this.delta = oldDelta.compose(change);
                    } else {
                      this.delta = this.getDelta();
                      if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {
                        change = oldDelta.diff(this.delta, cursorIndex);
                      }
                    }
                    return change;
                  }
                }]);
                return Editor;
              }();
              function combineFormats(formats, combined) {
                return Object.keys(combined).reduce(function (merged, name) {
                  if (formats[name] == null) return merged;
                  if (combined[name] === formats[name]) {
                    merged[name] = combined[name];
                  } else if (Array.isArray(combined[name])) {
                    if (combined[name].indexOf(formats[name]) < 0) {
                      merged[name] = combined[name].concat([formats[name]]);
                    }
                  } else {
                    merged[name] = [combined[name], formats[name]];
                  }
                  return merged;
                }, {});
              }
              function normalizeDelta(delta) {
                return delta.reduce(function (delta, op) {
                  if (op.insert === 1) {
                    var attributes = (0, _clone2.default)(op.attributes);
                    delete attributes['image'];
                    return delta.insert({
                      image: op.attributes.image
                    }, attributes);
                  }
                  if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {
                    op = (0, _clone2.default)(op);
                    if (op.attributes.list) {
                      op.attributes.list = 'ordered';
                    } else {
                      op.attributes.list = 'bullet';
                      delete op.attributes.bullet;
                    }
                  }
                  if (typeof op.insert === 'string') {
                    var text = op.insert.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                    return delta.insert(text, op.attributes);
                  }
                  return delta.push(op);
                }, new _quillDelta2.default());
              }
              exports.default = Editor;

              /***/
            }), (/* 15 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.default = exports.Range = undefined;
              var _slicedToArray = function () {
                function sliceIterator(arr, i) {
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i) break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"]) _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }
                return function (arr, i) {
                  if (Array.isArray(arr)) {
                    return arr;
                  } else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                  } else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                  }
                };
              }();
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _clone = __webpack_require__(21);
              var _clone2 = _interopRequireDefault(_clone);
              var _deepEqual = __webpack_require__(11);
              var _deepEqual2 = _interopRequireDefault(_deepEqual);
              var _emitter3 = __webpack_require__(8);
              var _emitter4 = _interopRequireDefault(_emitter3);
              var _logger = __webpack_require__(10);
              var _logger2 = _interopRequireDefault(_logger);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                  for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                } else {
                  return Array.from(arr);
                }
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var debug = (0, _logger2.default)('quill:selection');
              var Range = function Range(index) {
                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                _classCallCheck(this, Range);
                this.index = index;
                this.length = length;
              };
              var Selection = function () {
                function Selection(scroll, emitter) {
                  var _this = this;
                  _classCallCheck(this, Selection);
                  this.emitter = emitter;
                  this.scroll = scroll;
                  this.composing = false;
                  this.mouseDown = false;
                  this.root = this.scroll.domNode;
                  this.cursor = _parchment2.default.create('cursor', this);
                  // savedRange is last non-null range
                  this.lastRange = this.savedRange = new Range(0, 0);
                  this.handleComposition();
                  this.handleDragging();
                  this.emitter.listenDOM('selectionchange', document, function () {
                    if (!_this.mouseDown) {
                      setTimeout(_this.update.bind(_this, _emitter4.default.sources.USER), 1);
                    }
                  });
                  this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type, delta) {
                    if (type === _emitter4.default.events.TEXT_CHANGE && delta.length() > 0) {
                      _this.update(_emitter4.default.sources.SILENT);
                    }
                  });
                  this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE, function () {
                    if (!_this.hasFocus()) return;
                    var native = _this.getNativeRange();
                    if (native == null) return;
                    if (native.start.node === _this.cursor.textNode) return; // cursor.restore() will handle
                    // TODO unclear if this has negative side effects
                    _this.emitter.once(_emitter4.default.events.SCROLL_UPDATE, function () {
                      try {
                        _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);
                      } catch (ignored) {}
                    });
                  });
                  this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE, function (mutations, context) {
                    if (context.range) {
                      var _context$range = context.range,
                        startNode = _context$range.startNode,
                        startOffset = _context$range.startOffset,
                        endNode = _context$range.endNode,
                        endOffset = _context$range.endOffset;
                      _this.setNativeRange(startNode, startOffset, endNode, endOffset);
                    }
                  });
                  this.update(_emitter4.default.sources.SILENT);
                }
                _createClass(Selection, [{
                  key: 'handleComposition',
                  value: function handleComposition() {
                    var _this2 = this;
                    this.root.addEventListener('compositionstart', function () {
                      _this2.composing = true;
                    });
                    this.root.addEventListener('compositionend', function () {
                      _this2.composing = false;
                      if (_this2.cursor.parent) {
                        var range = _this2.cursor.restore();
                        if (!range) return;
                        setTimeout(function () {
                          _this2.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
                        }, 1);
                      }
                    });
                  }
                }, {
                  key: 'handleDragging',
                  value: function handleDragging() {
                    var _this3 = this;
                    this.emitter.listenDOM('mousedown', document.body, function () {
                      _this3.mouseDown = true;
                    });
                    this.emitter.listenDOM('mouseup', document.body, function () {
                      _this3.mouseDown = false;
                      _this3.update(_emitter4.default.sources.USER);
                    });
                  }
                }, {
                  key: 'focus',
                  value: function focus() {
                    if (this.hasFocus()) return;
                    this.root.focus();
                    this.setRange(this.savedRange);
                  }
                }, {
                  key: 'format',
                  value: function format(_format, value) {
                    if (this.scroll.whitelist != null && !this.scroll.whitelist[_format]) return;
                    this.scroll.update();
                    var nativeRange = this.getNativeRange();
                    if (nativeRange == null || !nativeRange.native.collapsed || _parchment2.default.query(_format, _parchment2.default.Scope.BLOCK)) return;
                    if (nativeRange.start.node !== this.cursor.textNode) {
                      var blot = _parchment2.default.find(nativeRange.start.node, false);
                      if (blot == null) return;
                      // TODO Give blot ability to not split
                      if (blot instanceof _parchment2.default.Leaf) {
                        var after = blot.split(nativeRange.start.offset);
                        blot.parent.insertBefore(this.cursor, after);
                      } else {
                        blot.insertBefore(this.cursor, nativeRange.start.node); // Should never happen
                      }
                      this.cursor.attach();
                    }
                    this.cursor.format(_format, value);
                    this.scroll.optimize();
                    this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
                    this.update();
                  }
                }, {
                  key: 'getBounds',
                  value: function getBounds(index) {
                    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    var scrollLength = this.scroll.length();
                    index = Math.min(index, scrollLength - 1);
                    length = Math.min(index + length, scrollLength - 1) - index;
                    var node = void 0,
                      _scroll$leaf = this.scroll.leaf(index),
                      _scroll$leaf2 = _slicedToArray(_scroll$leaf, 2),
                      leaf = _scroll$leaf2[0],
                      offset = _scroll$leaf2[1];
                    if (leaf == null) return null;
                    var _leaf$position = leaf.position(offset, true);
                    var _leaf$position2 = _slicedToArray(_leaf$position, 2);
                    node = _leaf$position2[0];
                    offset = _leaf$position2[1];
                    var range = document.createRange();
                    if (length > 0) {
                      range.setStart(node, offset);
                      var _scroll$leaf3 = this.scroll.leaf(index + length);
                      var _scroll$leaf4 = _slicedToArray(_scroll$leaf3, 2);
                      leaf = _scroll$leaf4[0];
                      offset = _scroll$leaf4[1];
                      if (leaf == null) return null;
                      var _leaf$position3 = leaf.position(offset, true);
                      var _leaf$position4 = _slicedToArray(_leaf$position3, 2);
                      node = _leaf$position4[0];
                      offset = _leaf$position4[1];
                      range.setEnd(node, offset);
                      return range.getBoundingClientRect();
                    } else {
                      var side = 'left';
                      var rect = void 0;
                      if (node instanceof Text) {
                        if (offset < node.data.length) {
                          range.setStart(node, offset);
                          range.setEnd(node, offset + 1);
                        } else {
                          range.setStart(node, offset - 1);
                          range.setEnd(node, offset);
                          side = 'right';
                        }
                        rect = range.getBoundingClientRect();
                      } else {
                        rect = leaf.domNode.getBoundingClientRect();
                        if (offset > 0) side = 'right';
                      }
                      return {
                        bottom: rect.top + rect.height,
                        height: rect.height,
                        left: rect[side],
                        right: rect[side],
                        top: rect.top,
                        width: 0
                      };
                    }
                  }
                }, {
                  key: 'getNativeRange',
                  value: function getNativeRange() {
                    var selection = document.getSelection();
                    if (selection == null || selection.rangeCount <= 0) return null;
                    var nativeRange = selection.getRangeAt(0);
                    if (nativeRange == null) return null;
                    var range = this.normalizeNative(nativeRange);
                    debug.info('getNativeRange', range);
                    return range;
                  }
                }, {
                  key: 'getRange',
                  value: function getRange() {
                    var normalized = this.getNativeRange();
                    if (normalized == null) return [null, null];
                    var range = this.normalizedToRange(normalized);
                    return [range, normalized];
                  }
                }, {
                  key: 'hasFocus',
                  value: function hasFocus() {
                    return document.activeElement === this.root;
                  }
                }, {
                  key: 'normalizedToRange',
                  value: function normalizedToRange(range) {
                    var _this4 = this;
                    var positions = [[range.start.node, range.start.offset]];
                    if (!range.native.collapsed) {
                      positions.push([range.end.node, range.end.offset]);
                    }
                    var indexes = positions.map(function (position) {
                      var _position = _slicedToArray(position, 2),
                        node = _position[0],
                        offset = _position[1];
                      var blot = _parchment2.default.find(node, true);
                      var index = blot.offset(_this4.scroll);
                      if (offset === 0) {
                        return index;
                      } else if (blot instanceof _parchment2.default.Container) {
                        return index + blot.length();
                      } else {
                        return index + blot.index(node, offset);
                      }
                    });
                    var end = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);
                    var start = Math.min.apply(Math, [end].concat(_toConsumableArray(indexes)));
                    return new Range(start, end - start);
                  }
                }, {
                  key: 'normalizeNative',
                  value: function normalizeNative(nativeRange) {
                    if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {
                      return null;
                    }
                    var range = {
                      start: {
                        node: nativeRange.startContainer,
                        offset: nativeRange.startOffset
                      },
                      end: {
                        node: nativeRange.endContainer,
                        offset: nativeRange.endOffset
                      },
                      native: nativeRange
                    };
                    [range.start, range.end].forEach(function (position) {
                      var node = position.node,
                        offset = position.offset;
                      while (!(node instanceof Text) && node.childNodes.length > 0) {
                        if (node.childNodes.length > offset) {
                          node = node.childNodes[offset];
                          offset = 0;
                        } else if (node.childNodes.length === offset) {
                          node = node.lastChild;
                          offset = node instanceof Text ? node.data.length : node.childNodes.length + 1;
                        } else {
                          break;
                        }
                      }
                      position.node = node, position.offset = offset;
                    });
                    return range;
                  }
                }, {
                  key: 'rangeToNative',
                  value: function rangeToNative(range) {
                    var _this5 = this;
                    var indexes = range.collapsed ? [range.index] : [range.index, range.index + range.length];
                    var args = [];
                    var scrollLength = this.scroll.length();
                    indexes.forEach(function (index, i) {
                      index = Math.min(scrollLength - 1, index);
                      var node = void 0,
                        _scroll$leaf5 = _this5.scroll.leaf(index),
                        _scroll$leaf6 = _slicedToArray(_scroll$leaf5, 2),
                        leaf = _scroll$leaf6[0],
                        offset = _scroll$leaf6[1];
                      var _leaf$position5 = leaf.position(offset, i !== 0);
                      var _leaf$position6 = _slicedToArray(_leaf$position5, 2);
                      node = _leaf$position6[0];
                      offset = _leaf$position6[1];
                      args.push(node, offset);
                    });
                    if (args.length < 2) {
                      args = args.concat(args);
                    }
                    return args;
                  }
                }, {
                  key: 'scrollIntoView',
                  value: function scrollIntoView(scrollingContainer) {
                    var range = this.lastRange;
                    if (range == null) return;
                    var bounds = this.getBounds(range.index, range.length);
                    if (bounds == null) return;
                    var limit = this.scroll.length() - 1;
                    var _scroll$line = this.scroll.line(Math.min(range.index, limit)),
                      _scroll$line2 = _slicedToArray(_scroll$line, 1),
                      first = _scroll$line2[0];
                    var last = first;
                    if (range.length > 0) {
                      var _scroll$line3 = this.scroll.line(Math.min(range.index + range.length, limit));
                      var _scroll$line4 = _slicedToArray(_scroll$line3, 1);
                      last = _scroll$line4[0];
                    }
                    if (first == null || last == null) return;
                    var scrollBounds = scrollingContainer.getBoundingClientRect();
                    if (bounds.top < scrollBounds.top) {
                      scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;
                    } else if (bounds.bottom > scrollBounds.bottom) {
                      scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;
                    }
                  }
                }, {
                  key: 'setNativeRange',
                  value: function setNativeRange(startNode, startOffset) {
                    var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startNode;
                    var endOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startOffset;
                    var force = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
                    debug.info('setNativeRange', startNode, startOffset, endNode, endOffset);
                    if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {
                      return;
                    }
                    var selection = document.getSelection();
                    if (selection == null) return;
                    if (startNode != null) {
                      if (!this.hasFocus()) this.root.focus();
                      var native = (this.getNativeRange() || {}).native;
                      if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {
                        if (startNode.tagName == "BR") {
                          startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);
                          startNode = startNode.parentNode;
                        }
                        if (endNode.tagName == "BR") {
                          endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);
                          endNode = endNode.parentNode;
                        }
                        var range = document.createRange();
                        range.setStart(startNode, startOffset);
                        range.setEnd(endNode, endOffset);
                        selection.removeAllRanges();
                        selection.addRange(range);
                      }
                    } else {
                      selection.removeAllRanges();
                      this.root.blur();
                      document.body.focus(); // root.blur() not enough on IE11+Travis+SauceLabs (but not local VMs)
                    }
                  }
                }, {
                  key: 'setRange',
                  value: function setRange(range) {
                    var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                    var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;
                    if (typeof force === 'string') {
                      source = force;
                      force = false;
                    }
                    debug.info('setRange', range);
                    if (range != null) {
                      var args = this.rangeToNative(range);
                      this.setNativeRange.apply(this, _toConsumableArray(args).concat([force]));
                    } else {
                      this.setNativeRange(null);
                    }
                    this.update(source);
                  }
                }, {
                  key: 'update',
                  value: function update() {
                    var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;
                    var oldRange = this.lastRange;
                    var _getRange = this.getRange(),
                      _getRange2 = _slicedToArray(_getRange, 2),
                      lastRange = _getRange2[0],
                      nativeRange = _getRange2[1];
                    this.lastRange = lastRange;
                    if (this.lastRange != null) {
                      this.savedRange = this.lastRange;
                    }
                    if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {
                      var _emitter;
                      if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {
                        this.cursor.restore();
                      }
                      var args = [_emitter4.default.events.SELECTION_CHANGE, (0, _clone2.default)(this.lastRange), (0, _clone2.default)(oldRange), source];
                      (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
                      if (source !== _emitter4.default.sources.SILENT) {
                        var _emitter2;
                        (_emitter2 = this.emitter).emit.apply(_emitter2, args);
                      }
                    }
                  }
                }]);
                return Selection;
              }();
              function contains(parent, descendant) {
                try {
                  // Firefox inserts inaccessible nodes around video elements
                  descendant.parentNode;
                } catch (e) {
                  return false;
                }
                // IE11 has bug with Text nodes
                // https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect
                if (descendant instanceof Text) {
                  descendant = descendant.parentNode;
                }
                return parent.contains(descendant);
              }
              exports.Range = Range;
              exports.default = Selection;

              /***/
            }), (/* 16 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var Break = function (_Parchment$Embed) {
                _inherits(Break, _Parchment$Embed);
                function Break() {
                  _classCallCheck(this, Break);
                  return _possibleConstructorReturn(this, (Break.__proto__ || Object.getPrototypeOf(Break)).apply(this, arguments));
                }
                _createClass(Break, [{
                  key: 'insertInto',
                  value: function insertInto(parent, ref) {
                    if (parent.children.length === 0) {
                      _get(Break.prototype.__proto__ || Object.getPrototypeOf(Break.prototype), 'insertInto', this).call(this, parent, ref);
                    } else {
                      this.remove();
                    }
                  }
                }, {
                  key: 'length',
                  value: function length() {
                    return 0;
                  }
                }, {
                  key: 'value',
                  value: function value() {
                    return '';
                  }
                }], [{
                  key: 'value',
                  value: function value() {
                    return undefined;
                  }
                }]);
                return Break;
              }(_parchment2.default.Embed);
              Break.blotName = 'break';
              Break.tagName = 'BR';
              exports.default = Break;

              /***/
            }), (/* 17 */
            /***/function (module, exports, __webpack_require__) {
              var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function (d, b) {
                  d.__proto__ = b;
                } || function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
                return function (d, b) {
                  extendStatics(d, b);
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
              }();
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var linked_list_1 = __webpack_require__(44);
              var shadow_1 = __webpack_require__(30);
              var Registry = __webpack_require__(1);
              var ContainerBlot = /** @class */function (_super) {
                __extends(ContainerBlot, _super);
                function ContainerBlot(domNode) {
                  var _this = _super.call(this, domNode) || this;
                  _this.build();
                  return _this;
                }
                ContainerBlot.prototype.appendChild = function (other) {
                  this.insertBefore(other);
                };
                ContainerBlot.prototype.attach = function () {
                  _super.prototype.attach.call(this);
                  this.children.forEach(function (child) {
                    child.attach();
                  });
                };
                ContainerBlot.prototype.build = function () {
                  var _this = this;
                  this.children = new linked_list_1.default();
                  // Need to be reversed for if DOM nodes already in order
                  [].slice.call(this.domNode.childNodes).reverse().forEach(function (node) {
                    try {
                      var child = makeBlot(node);
                      _this.insertBefore(child, _this.children.head || undefined);
                    } catch (err) {
                      if (err instanceof Registry.ParchmentError) return;else throw err;
                    }
                  });
                };
                ContainerBlot.prototype.deleteAt = function (index, length) {
                  if (index === 0 && length === this.length()) {
                    return this.remove();
                  }
                  this.children.forEachAt(index, length, function (child, offset, length) {
                    child.deleteAt(offset, length);
                  });
                };
                ContainerBlot.prototype.descendant = function (criteria, index) {
                  var _a = this.children.find(index),
                    child = _a[0],
                    offset = _a[1];
                  if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
                    return [child, offset];
                  } else if (child instanceof ContainerBlot) {
                    return child.descendant(criteria, offset);
                  } else {
                    return [null, -1];
                  }
                };
                ContainerBlot.prototype.descendants = function (criteria, index, length) {
                  if (index === void 0) {
                    index = 0;
                  }
                  if (length === void 0) {
                    length = Number.MAX_VALUE;
                  }
                  var descendants = [];
                  var lengthLeft = length;
                  this.children.forEachAt(index, length, function (child, index, length) {
                    if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
                      descendants.push(child);
                    }
                    if (child instanceof ContainerBlot) {
                      descendants = descendants.concat(child.descendants(criteria, index, lengthLeft));
                    }
                    lengthLeft -= length;
                  });
                  return descendants;
                };
                ContainerBlot.prototype.detach = function () {
                  this.children.forEach(function (child) {
                    child.detach();
                  });
                  _super.prototype.detach.call(this);
                };
                ContainerBlot.prototype.formatAt = function (index, length, name, value) {
                  this.children.forEachAt(index, length, function (child, offset, length) {
                    child.formatAt(offset, length, name, value);
                  });
                };
                ContainerBlot.prototype.insertAt = function (index, value, def) {
                  var _a = this.children.find(index),
                    child = _a[0],
                    offset = _a[1];
                  if (child) {
                    child.insertAt(offset, value, def);
                  } else {
                    var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
                    this.appendChild(blot);
                  }
                };
                ContainerBlot.prototype.insertBefore = function (childBlot, refBlot) {
                  if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(function (child) {
                    return childBlot instanceof child;
                  })) {
                    throw new Registry.ParchmentError("Cannot insert " + childBlot.statics.blotName + " into " + this.statics.blotName);
                  }
                  childBlot.insertInto(this, refBlot);
                };
                ContainerBlot.prototype.length = function () {
                  return this.children.reduce(function (memo, child) {
                    return memo + child.length();
                  }, 0);
                };
                ContainerBlot.prototype.moveChildren = function (targetParent, refNode) {
                  this.children.forEach(function (child) {
                    targetParent.insertBefore(child, refNode);
                  });
                };
                ContainerBlot.prototype.optimize = function (context) {
                  _super.prototype.optimize.call(this, context);
                  if (this.children.length === 0) {
                    if (this.statics.defaultChild != null) {
                      var child = Registry.create(this.statics.defaultChild);
                      this.appendChild(child);
                      child.optimize(context);
                    } else {
                      this.remove();
                    }
                  }
                };
                ContainerBlot.prototype.path = function (index, inclusive) {
                  if (inclusive === void 0) {
                    inclusive = false;
                  }
                  var _a = this.children.find(index, inclusive),
                    child = _a[0],
                    offset = _a[1];
                  var position = [[this, index]];
                  if (child instanceof ContainerBlot) {
                    return position.concat(child.path(offset, inclusive));
                  } else if (child != null) {
                    position.push([child, offset]);
                  }
                  return position;
                };
                ContainerBlot.prototype.removeChild = function (child) {
                  this.children.remove(child);
                };
                ContainerBlot.prototype.replace = function (target) {
                  if (target instanceof ContainerBlot) {
                    target.moveChildren(this);
                  }
                  _super.prototype.replace.call(this, target);
                };
                ContainerBlot.prototype.split = function (index, force) {
                  if (force === void 0) {
                    force = false;
                  }
                  if (!force) {
                    if (index === 0) return this;
                    if (index === this.length()) return this.next;
                  }
                  var after = this.clone();
                  this.parent.insertBefore(after, this.next);
                  this.children.forEachAt(index, this.length(), function (child, offset, length) {
                    child = child.split(offset, force);
                    after.appendChild(child);
                  });
                  return after;
                };
                ContainerBlot.prototype.unwrap = function () {
                  this.moveChildren(this.parent, this.next);
                  this.remove();
                };
                ContainerBlot.prototype.update = function (mutations, context) {
                  var _this = this;
                  var addedNodes = [];
                  var removedNodes = [];
                  mutations.forEach(function (mutation) {
                    if (mutation.target === _this.domNode && mutation.type === 'childList') {
                      addedNodes.push.apply(addedNodes, mutation.addedNodes);
                      removedNodes.push.apply(removedNodes, mutation.removedNodes);
                    }
                  });
                  removedNodes.forEach(function (node) {
                    // Check node has actually been removed
                    // One exception is Chrome does not immediately remove IFRAMEs
                    // from DOM but MutationRecord is correct in its reported removal
                    if (node.parentNode != null &&
                    // @ts-ignore
                    node.tagName !== 'IFRAME' && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                      return;
                    }
                    var blot = Registry.find(node);
                    if (blot == null) return;
                    if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {
                      blot.detach();
                    }
                  });
                  addedNodes.filter(function (node) {
                    return node.parentNode == _this.domNode;
                  }).sort(function (a, b) {
                    if (a === b) return 0;
                    if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {
                      return 1;
                    }
                    return -1;
                  }).forEach(function (node) {
                    var refBlot = null;
                    if (node.nextSibling != null) {
                      refBlot = Registry.find(node.nextSibling);
                    }
                    var blot = makeBlot(node);
                    if (blot.next != refBlot || blot.next == null) {
                      if (blot.parent != null) {
                        blot.parent.removeChild(_this);
                      }
                      _this.insertBefore(blot, refBlot || undefined);
                    }
                  });
                };
                return ContainerBlot;
              }(shadow_1.default);
              function makeBlot(node) {
                var blot = Registry.find(node);
                if (blot == null) {
                  try {
                    blot = Registry.create(node);
                  } catch (e) {
                    blot = Registry.create(Registry.Scope.INLINE);
                    [].slice.call(node.childNodes).forEach(function (child) {
                      // @ts-ignore
                      blot.domNode.appendChild(child);
                    });
                    if (node.parentNode) {
                      node.parentNode.replaceChild(blot.domNode, node);
                    }
                    blot.attach();
                  }
                }
                return blot;
              }
              exports.default = ContainerBlot;

              /***/
            }), (/* 18 */
            /***/function (module, exports, __webpack_require__) {
              var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function (d, b) {
                  d.__proto__ = b;
                } || function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
                return function (d, b) {
                  extendStatics(d, b);
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
              }();
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var attributor_1 = __webpack_require__(12);
              var store_1 = __webpack_require__(31);
              var container_1 = __webpack_require__(17);
              var Registry = __webpack_require__(1);
              var FormatBlot = /** @class */function (_super) {
                __extends(FormatBlot, _super);
                function FormatBlot(domNode) {
                  var _this = _super.call(this, domNode) || this;
                  _this.attributes = new store_1.default(_this.domNode);
                  return _this;
                }
                FormatBlot.formats = function (domNode) {
                  if (typeof this.tagName === 'string') {
                    return true;
                  } else if (Array.isArray(this.tagName)) {
                    return domNode.tagName.toLowerCase();
                  }
                  return undefined;
                };
                FormatBlot.prototype.format = function (name, value) {
                  var format = Registry.query(name);
                  if (format instanceof attributor_1.default) {
                    this.attributes.attribute(format, value);
                  } else if (value) {
                    if (format != null && (name !== this.statics.blotName || this.formats()[name] !== value)) {
                      this.replaceWith(name, value);
                    }
                  }
                };
                FormatBlot.prototype.formats = function () {
                  var formats = this.attributes.values();
                  var format = this.statics.formats(this.domNode);
                  if (format != null) {
                    formats[this.statics.blotName] = format;
                  }
                  return formats;
                };
                FormatBlot.prototype.replaceWith = function (name, value) {
                  var replacement = _super.prototype.replaceWith.call(this, name, value);
                  this.attributes.copy(replacement);
                  return replacement;
                };
                FormatBlot.prototype.update = function (mutations, context) {
                  var _this = this;
                  _super.prototype.update.call(this, mutations, context);
                  if (mutations.some(function (mutation) {
                    return mutation.target === _this.domNode && mutation.type === 'attributes';
                  })) {
                    this.attributes.build();
                  }
                };
                FormatBlot.prototype.wrap = function (name, value) {
                  var wrapper = _super.prototype.wrap.call(this, name, value);
                  if (wrapper instanceof FormatBlot && wrapper.statics.scope === this.statics.scope) {
                    this.attributes.move(wrapper);
                  }
                  return wrapper;
                };
                return FormatBlot;
              }(container_1.default);
              exports.default = FormatBlot;

              /***/
            }), (/* 19 */
            /***/function (module, exports, __webpack_require__) {
              var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function (d, b) {
                  d.__proto__ = b;
                } || function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
                return function (d, b) {
                  extendStatics(d, b);
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
              }();
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var shadow_1 = __webpack_require__(30);
              var Registry = __webpack_require__(1);
              var LeafBlot = /** @class */function (_super) {
                __extends(LeafBlot, _super);
                function LeafBlot() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                LeafBlot.value = function (domNode) {
                  return true;
                };
                LeafBlot.prototype.index = function (node, offset) {
                  if (this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                    return Math.min(offset, 1);
                  }
                  return -1;
                };
                LeafBlot.prototype.position = function (index, inclusive) {
                  var offset = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);
                  if (index > 0) offset += 1;
                  return [this.parent.domNode, offset];
                };
                LeafBlot.prototype.value = function () {
                  var _a;
                  return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;
                };
                LeafBlot.scope = Registry.Scope.INLINE_BLOT;
                return LeafBlot;
              }(shadow_1.default);
              exports.default = LeafBlot;

              /***/
            }), (/* 20 */
            /***/function (module, exports, __webpack_require__) {
              var equal = __webpack_require__(11);
              var extend = __webpack_require__(3);
              var lib = {
                attributes: {
                  compose: function compose(a, b, keepNull) {
                    if (typeof a !== 'object') a = {};
                    if (typeof b !== 'object') b = {};
                    var attributes = extend(true, {}, b);
                    if (!keepNull) {
                      attributes = Object.keys(attributes).reduce(function (copy, key) {
                        if (attributes[key] != null) {
                          copy[key] = attributes[key];
                        }
                        return copy;
                      }, {});
                    }
                    for (var key in a) {
                      if (a[key] !== undefined && b[key] === undefined) {
                        attributes[key] = a[key];
                      }
                    }
                    return Object.keys(attributes).length > 0 ? attributes : undefined;
                  },
                  diff: function diff(a, b) {
                    if (typeof a !== 'object') a = {};
                    if (typeof b !== 'object') b = {};
                    var attributes = Object.keys(a).concat(Object.keys(b)).reduce(function (attributes, key) {
                      if (!equal(a[key], b[key])) {
                        attributes[key] = b[key] === undefined ? null : b[key];
                      }
                      return attributes;
                    }, {});
                    return Object.keys(attributes).length > 0 ? attributes : undefined;
                  },
                  transform: function transform(a, b, priority) {
                    if (typeof a !== 'object') return b;
                    if (typeof b !== 'object') return undefined;
                    if (!priority) return b; // b simply overwrites us without priority
                    var attributes = Object.keys(b).reduce(function (attributes, key) {
                      if (a[key] === undefined) attributes[key] = b[key]; // null is a valid value
                      return attributes;
                    }, {});
                    return Object.keys(attributes).length > 0 ? attributes : undefined;
                  }
                },
                iterator: function iterator(ops) {
                  return new Iterator(ops);
                },
                length: function length(op) {
                  if (typeof op['delete'] === 'number') {
                    return op['delete'];
                  } else if (typeof op.retain === 'number') {
                    return op.retain;
                  } else {
                    return typeof op.insert === 'string' ? op.insert.length : 1;
                  }
                }
              };
              function Iterator(ops) {
                this.ops = ops;
                this.index = 0;
                this.offset = 0;
              }
              Iterator.prototype.hasNext = function () {
                return this.peekLength() < Infinity;
              };
              Iterator.prototype.next = function (length) {
                if (!length) length = Infinity;
                var nextOp = this.ops[this.index];
                if (nextOp) {
                  var offset = this.offset;
                  var opLength = lib.length(nextOp);
                  if (length >= opLength - offset) {
                    length = opLength - offset;
                    this.index += 1;
                    this.offset = 0;
                  } else {
                    this.offset += length;
                  }
                  if (typeof nextOp['delete'] === 'number') {
                    return {
                      'delete': length
                    };
                  } else {
                    var retOp = {};
                    if (nextOp.attributes) {
                      retOp.attributes = nextOp.attributes;
                    }
                    if (typeof nextOp.retain === 'number') {
                      retOp.retain = length;
                    } else if (typeof nextOp.insert === 'string') {
                      retOp.insert = nextOp.insert.substr(offset, length);
                    } else {
                      // offset should === 0, length should === 1
                      retOp.insert = nextOp.insert;
                    }
                    return retOp;
                  }
                } else {
                  return {
                    retain: Infinity
                  };
                }
              };
              Iterator.prototype.peek = function () {
                return this.ops[this.index];
              };
              Iterator.prototype.peekLength = function () {
                if (this.ops[this.index]) {
                  // Should never return 0 if our index is being managed correctly
                  return lib.length(this.ops[this.index]) - this.offset;
                } else {
                  return Infinity;
                }
              };
              Iterator.prototype.peekType = function () {
                if (this.ops[this.index]) {
                  if (typeof this.ops[this.index]['delete'] === 'number') {
                    return 'delete';
                  } else if (typeof this.ops[this.index].retain === 'number') {
                    return 'retain';
                  } else {
                    return 'insert';
                  }
                }
                return 'retain';
              };
              Iterator.prototype.rest = function () {
                if (!this.hasNext()) {
                  return [];
                } else if (this.offset === 0) {
                  return this.ops.slice(this.index);
                } else {
                  var offset = this.offset;
                  var index = this.index;
                  var next = this.next();
                  var rest = this.ops.slice(this.index);
                  this.offset = offset;
                  this.index = index;
                  return [next].concat(rest);
                }
              };
              module.exports = lib;

              /***/
            }), (/* 21 */
            /***/function (module, exports) {
              var clone = function () {
                function _instanceof(obj, type) {
                  return type != null && obj instanceof type;
                }
                var nativeMap;
                try {
                  nativeMap = Map;
                } catch (_) {
                  // maybe a reference error because no `Map`. Give it a dummy value that no
                  // value will ever be an instanceof.
                  nativeMap = function nativeMap() {};
                }
                var nativeSet;
                try {
                  nativeSet = Set;
                } catch (_) {
                  nativeSet = function nativeSet() {};
                }
                var nativePromise;
                try {
                  nativePromise = Promise;
                } catch (_) {
                  nativePromise = function nativePromise() {};
                }

                /**
                 * Clones (copies) an Object using deep copying.
                 *
                 * This function supports circular references by default, but if you are certain
                 * there are no circular references in your object, you can save some CPU time
                 * by calling clone(obj, false).
                 *
                 * Caution: if `circular` is false and `parent` contains circular references,
                 * your program may enter an infinite loop and crash.
                 *
                 * @param `parent` - the object to be cloned
                 * @param `circular` - set to true if the object to be cloned may contain
                 *    circular references. (optional - true by default)
                 * @param `depth` - set to a number if the object is only to be cloned to
                 *    a particular depth. (optional - defaults to Infinity)
                 * @param `prototype` - sets the prototype to be used when cloning an object.
                 *    (optional - defaults to parent prototype).
                 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
                 *    should be cloned as well. Non-enumerable properties on the prototype
                 *    chain will be ignored. (optional - false by default)
                */
                function clone(parent, circular, depth, prototype, includeNonEnumerable) {
                  if (typeof circular === 'object') {
                    depth = circular.depth;
                    prototype = circular.prototype;
                    includeNonEnumerable = circular.includeNonEnumerable;
                    circular = circular.circular;
                  }
                  // maintain two arrays for circular references, where corresponding parents
                  // and children have the same index
                  var allParents = [];
                  var allChildren = [];
                  var useBuffer = typeof Buffer != 'undefined';
                  if (typeof circular == 'undefined') circular = true;
                  if (typeof depth == 'undefined') depth = Infinity;

                  // recurse this function so we don't reset allParents and allChildren
                  function _clone(parent, depth) {
                    // cloning null always returns null
                    if (parent === null) return null;
                    if (depth === 0) return parent;
                    var child;
                    var proto;
                    if (typeof parent != 'object') {
                      return parent;
                    }
                    if (_instanceof(parent, nativeMap)) {
                      child = new nativeMap();
                    } else if (_instanceof(parent, nativeSet)) {
                      child = new nativeSet();
                    } else if (_instanceof(parent, nativePromise)) {
                      child = new nativePromise(function (resolve, reject) {
                        parent.then(function (value) {
                          resolve(_clone(value, depth - 1));
                        }, function (err) {
                          reject(_clone(err, depth - 1));
                        });
                      });
                    } else if (clone.__isArray(parent)) {
                      child = [];
                    } else if (clone.__isRegExp(parent)) {
                      child = new RegExp(parent.source, __getRegExpFlags(parent));
                      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
                    } else if (clone.__isDate(parent)) {
                      child = new Date(parent.getTime());
                    } else if (useBuffer && Buffer.isBuffer(parent)) {
                      if (Buffer.allocUnsafe) {
                        // Node.js >= 4.5.0
                        child = Buffer.allocUnsafe(parent.length);
                      } else {
                        // Older Node.js versions
                        child = new Buffer(parent.length);
                      }
                      parent.copy(child);
                      return child;
                    } else if (_instanceof(parent, Error)) {
                      child = Object.create(parent);
                    } else {
                      if (typeof prototype == 'undefined') {
                        proto = Object.getPrototypeOf(parent);
                        child = Object.create(proto);
                      } else {
                        child = Object.create(prototype);
                        proto = prototype;
                      }
                    }
                    if (circular) {
                      var index = allParents.indexOf(parent);
                      if (index != -1) {
                        return allChildren[index];
                      }
                      allParents.push(parent);
                      allChildren.push(child);
                    }
                    if (_instanceof(parent, nativeMap)) {
                      parent.forEach(function (value, key) {
                        var keyChild = _clone(key, depth - 1);
                        var valueChild = _clone(value, depth - 1);
                        child.set(keyChild, valueChild);
                      });
                    }
                    if (_instanceof(parent, nativeSet)) {
                      parent.forEach(function (value) {
                        var entryChild = _clone(value, depth - 1);
                        child.add(entryChild);
                      });
                    }
                    for (var i in parent) {
                      var attrs;
                      if (proto) {
                        attrs = Object.getOwnPropertyDescriptor(proto, i);
                      }
                      if (attrs && attrs.set == null) {
                        continue;
                      }
                      child[i] = _clone(parent[i], depth - 1);
                    }
                    if (Object.getOwnPropertySymbols) {
                      var symbols = Object.getOwnPropertySymbols(parent);
                      for (var i = 0; i < symbols.length; i++) {
                        // Don't need to worry about cloning a symbol because it is a primitive,
                        // like a number or string.
                        var symbol = symbols[i];
                        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
                        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                          continue;
                        }
                        child[symbol] = _clone(parent[symbol], depth - 1);
                        if (!descriptor.enumerable) {
                          Object.defineProperty(child, symbol, {
                            enumerable: false
                          });
                        }
                      }
                    }
                    if (includeNonEnumerable) {
                      var allPropertyNames = Object.getOwnPropertyNames(parent);
                      for (var i = 0; i < allPropertyNames.length; i++) {
                        var propertyName = allPropertyNames[i];
                        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
                        if (descriptor && descriptor.enumerable) {
                          continue;
                        }
                        child[propertyName] = _clone(parent[propertyName], depth - 1);
                        Object.defineProperty(child, propertyName, {
                          enumerable: false
                        });
                      }
                    }
                    return child;
                  }
                  return _clone(parent, depth);
                }

                /**
                 * Simple flat clone using prototype, accepts only objects, usefull for property
                 * override on FLAT configuration object (no nested props).
                 *
                 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
                 * works.
                 */
                clone.clonePrototype = function clonePrototype(parent) {
                  if (parent === null) return null;
                  var c = function c() {};
                  c.prototype = parent;
                  return new c();
                };

                // private utility functions

                function __objToStr(o) {
                  return Object.prototype.toString.call(o);
                }
                clone.__objToStr = __objToStr;
                function __isDate(o) {
                  return typeof o === 'object' && __objToStr(o) === '[object Date]';
                }
                clone.__isDate = __isDate;
                function __isArray(o) {
                  return typeof o === 'object' && __objToStr(o) === '[object Array]';
                }
                clone.__isArray = __isArray;
                function __isRegExp(o) {
                  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
                }
                clone.__isRegExp = __isRegExp;
                function __getRegExpFlags(re) {
                  var flags = '';
                  if (re.global) flags += 'g';
                  if (re.ignoreCase) flags += 'i';
                  if (re.multiline) flags += 'm';
                  return flags;
                }
                clone.__getRegExpFlags = __getRegExpFlags;
                return clone;
              }();
              if (typeof module === 'object' && module.exports) {
                module.exports = clone;
              }

              /***/
            }), (/* 22 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _slicedToArray = function () {
                function sliceIterator(arr, i) {
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i) break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"]) _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }
                return function (arr, i) {
                  if (Array.isArray(arr)) {
                    return arr;
                  } else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                  } else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                  }
                };
              }();
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _emitter = __webpack_require__(8);
              var _emitter2 = _interopRequireDefault(_emitter);
              var _block = __webpack_require__(4);
              var _block2 = _interopRequireDefault(_block);
              var _break = __webpack_require__(16);
              var _break2 = _interopRequireDefault(_break);
              var _code = __webpack_require__(13);
              var _code2 = _interopRequireDefault(_code);
              var _container = __webpack_require__(25);
              var _container2 = _interopRequireDefault(_container);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              function isLine(blot) {
                return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;
              }
              var Scroll = function (_Parchment$Scroll) {
                _inherits(Scroll, _Parchment$Scroll);
                function Scroll(domNode, config) {
                  _classCallCheck(this, Scroll);
                  var _this = _possibleConstructorReturn(this, (Scroll.__proto__ || Object.getPrototypeOf(Scroll)).call(this, domNode));
                  _this.emitter = config.emitter;
                  if (Array.isArray(config.whitelist)) {
                    _this.whitelist = config.whitelist.reduce(function (whitelist, format) {
                      whitelist[format] = true;
                      return whitelist;
                    }, {});
                  }
                  // Some reason fixes composition issues with character languages in Windows/Chrome, Safari
                  _this.domNode.addEventListener('DOMNodeInserted', function () {});
                  _this.optimize();
                  _this.enable();
                  return _this;
                }
                _createClass(Scroll, [{
                  key: 'batchStart',
                  value: function batchStart() {
                    this.batch = true;
                  }
                }, {
                  key: 'batchEnd',
                  value: function batchEnd() {
                    this.batch = false;
                    this.optimize();
                  }
                }, {
                  key: 'deleteAt',
                  value: function deleteAt(index, length) {
                    var _line = this.line(index),
                      _line2 = _slicedToArray(_line, 2),
                      first = _line2[0],
                      offset = _line2[1];
                    var _line3 = this.line(index + length),
                      _line4 = _slicedToArray(_line3, 1),
                      last = _line4[0];
                    _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'deleteAt', this).call(this, index, length);
                    if (last != null && first !== last && offset > 0) {
                      if (first instanceof _block.BlockEmbed || last instanceof _block.BlockEmbed) {
                        this.optimize();
                        return;
                      }
                      if (first instanceof _code2.default) {
                        var newlineIndex = first.newlineIndex(first.length(), true);
                        if (newlineIndex > -1) {
                          first = first.split(newlineIndex + 1);
                          if (first === last) {
                            this.optimize();
                            return;
                          }
                        }
                      } else if (last instanceof _code2.default) {
                        var _newlineIndex = last.newlineIndex(0);
                        if (_newlineIndex > -1) {
                          last.split(_newlineIndex + 1);
                        }
                      }
                      var ref = last.children.head instanceof _break2.default ? null : last.children.head;
                      first.moveChildren(last, ref);
                      first.remove();
                    }
                    this.optimize();
                  }
                }, {
                  key: 'enable',
                  value: function enable() {
                    var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                    this.domNode.setAttribute('contenteditable', enabled);
                  }
                }, {
                  key: 'formatAt',
                  value: function formatAt(index, length, format, value) {
                    if (this.whitelist != null && !this.whitelist[format]) return;
                    _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'formatAt', this).call(this, index, length, format, value);
                    this.optimize();
                  }
                }, {
                  key: 'insertAt',
                  value: function insertAt(index, value, def) {
                    if (def != null && this.whitelist != null && !this.whitelist[value]) return;
                    if (index >= this.length()) {
                      if (def == null || _parchment2.default.query(value, _parchment2.default.Scope.BLOCK) == null) {
                        var blot = _parchment2.default.create(this.statics.defaultChild);
                        this.appendChild(blot);
                        if (def == null && value.endsWith('\n')) {
                          value = value.slice(0, -1);
                        }
                        blot.insertAt(0, value, def);
                      } else {
                        var embed = _parchment2.default.create(value, def);
                        this.appendChild(embed);
                      }
                    } else {
                      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertAt', this).call(this, index, value, def);
                    }
                    this.optimize();
                  }
                }, {
                  key: 'insertBefore',
                  value: function insertBefore(blot, ref) {
                    if (blot.statics.scope === _parchment2.default.Scope.INLINE_BLOT) {
                      var wrapper = _parchment2.default.create(this.statics.defaultChild);
                      wrapper.appendChild(blot);
                      blot = wrapper;
                    }
                    _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertBefore', this).call(this, blot, ref);
                  }
                }, {
                  key: 'leaf',
                  value: function leaf(index) {
                    return this.path(index).pop() || [null, -1];
                  }
                }, {
                  key: 'line',
                  value: function line(index) {
                    if (index === this.length()) {
                      return this.line(index - 1);
                    }
                    return this.descendant(isLine, index);
                  }
                }, {
                  key: 'lines',
                  value: function lines() {
                    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;
                    var getLines = function getLines(blot, index, length) {
                      var lines = [],
                        lengthLeft = length;
                      blot.children.forEachAt(index, length, function (child, index, length) {
                        if (isLine(child)) {
                          lines.push(child);
                        } else if (child instanceof _parchment2.default.Container) {
                          lines = lines.concat(getLines(child, index, lengthLeft));
                        }
                        lengthLeft -= length;
                      });
                      return lines;
                    };
                    return getLines(this, index, length);
                  }
                }, {
                  key: 'optimize',
                  value: function optimize() {
                    var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    if (this.batch === true) return;
                    _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'optimize', this).call(this, mutations, context);
                    if (mutations.length > 0) {
                      this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context);
                    }
                  }
                }, {
                  key: 'path',
                  value: function path(index) {
                    return _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'path', this).call(this, index).slice(1); // Exclude self
                  }
                }, {
                  key: 'update',
                  value: function update(mutations) {
                    if (this.batch === true) return;
                    var source = _emitter2.default.sources.USER;
                    if (typeof mutations === 'string') {
                      source = mutations;
                    }
                    if (!Array.isArray(mutations)) {
                      mutations = this.observer.takeRecords();
                    }
                    if (mutations.length > 0) {
                      this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);
                    }
                    _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'update', this).call(this, mutations.concat([])); // pass copy
                    if (mutations.length > 0) {
                      this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);
                    }
                  }
                }]);
                return Scroll;
              }(_parchment2.default.Scroll);
              Scroll.blotName = 'scroll';
              Scroll.className = 'ql-editor';
              Scroll.tagName = 'DIV';
              Scroll.defaultChild = 'block';
              Scroll.allowedChildren = [_block2.default, _block.BlockEmbed, _container2.default];
              exports.default = Scroll;

              /***/
            }), (/* 23 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.SHORTKEY = exports.default = undefined;
              var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                return typeof obj;
              } : function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              };
              var _slicedToArray = function () {
                function sliceIterator(arr, i) {
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i) break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"]) _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }
                return function (arr, i) {
                  if (Array.isArray(arr)) {
                    return arr;
                  } else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                  } else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                  }
                };
              }();
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _clone = __webpack_require__(21);
              var _clone2 = _interopRequireDefault(_clone);
              var _deepEqual = __webpack_require__(11);
              var _deepEqual2 = _interopRequireDefault(_deepEqual);
              var _extend = __webpack_require__(3);
              var _extend2 = _interopRequireDefault(_extend);
              var _quillDelta = __webpack_require__(2);
              var _quillDelta2 = _interopRequireDefault(_quillDelta);
              var _op = __webpack_require__(20);
              var _op2 = _interopRequireDefault(_op);
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _quill = __webpack_require__(5);
              var _quill2 = _interopRequireDefault(_quill);
              var _logger = __webpack_require__(10);
              var _logger2 = _interopRequireDefault(_logger);
              var _module = __webpack_require__(9);
              var _module2 = _interopRequireDefault(_module);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var debug = (0, _logger2.default)('quill:keyboard');
              var SHORTKEY = /Mac/i.test(navigator.platform) ? 'metaKey' : 'ctrlKey';
              var Keyboard = function (_Module) {
                _inherits(Keyboard, _Module);
                _createClass(Keyboard, null, [{
                  key: 'match',
                  value: function match(evt, binding) {
                    binding = normalize(binding);
                    if (['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].some(function (key) {
                      return !!binding[key] !== evt[key] && binding[key] !== null;
                    })) {
                      return false;
                    }
                    return binding.key === (evt.which || evt.keyCode);
                  }
                }]);
                function Keyboard(quill, options) {
                  _classCallCheck(this, Keyboard);
                  var _this = _possibleConstructorReturn(this, (Keyboard.__proto__ || Object.getPrototypeOf(Keyboard)).call(this, quill, options));
                  _this.bindings = {};
                  Object.keys(_this.options.bindings).forEach(function (name) {
                    if (name === 'list autofill' && quill.scroll.whitelist != null && !quill.scroll.whitelist['list']) {
                      return;
                    }
                    if (_this.options.bindings[name]) {
                      _this.addBinding(_this.options.bindings[name]);
                    }
                  });
                  _this.addBinding({
                    key: Keyboard.keys.ENTER,
                    shiftKey: null
                  }, handleEnter);
                  _this.addBinding({
                    key: Keyboard.keys.ENTER,
                    metaKey: null,
                    ctrlKey: null,
                    altKey: null
                  }, function () {});
                  if (/Firefox/i.test(navigator.userAgent)) {
                    // Need to handle delete and backspace for Firefox in the general case #1171
                    _this.addBinding({
                      key: Keyboard.keys.BACKSPACE
                    }, {
                      collapsed: true
                    }, handleBackspace);
                    _this.addBinding({
                      key: Keyboard.keys.DELETE
                    }, {
                      collapsed: true
                    }, handleDelete);
                  } else {
                    _this.addBinding({
                      key: Keyboard.keys.BACKSPACE
                    }, {
                      collapsed: true,
                      prefix: /^.?$/
                    }, handleBackspace);
                    _this.addBinding({
                      key: Keyboard.keys.DELETE
                    }, {
                      collapsed: true,
                      suffix: /^.?$/
                    }, handleDelete);
                  }
                  _this.addBinding({
                    key: Keyboard.keys.BACKSPACE
                  }, {
                    collapsed: false
                  }, handleDeleteRange);
                  _this.addBinding({
                    key: Keyboard.keys.DELETE
                  }, {
                    collapsed: false
                  }, handleDeleteRange);
                  _this.addBinding({
                    key: Keyboard.keys.BACKSPACE,
                    altKey: null,
                    ctrlKey: null,
                    metaKey: null,
                    shiftKey: null
                  }, {
                    collapsed: true,
                    offset: 0
                  }, handleBackspace);
                  _this.listen();
                  return _this;
                }
                _createClass(Keyboard, [{
                  key: 'addBinding',
                  value: function addBinding(key) {
                    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    var handler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                    var binding = normalize(key);
                    if (binding == null || binding.key == null) {
                      return debug.warn('Attempted to add invalid keyboard binding', binding);
                    }
                    if (typeof context === 'function') {
                      context = {
                        handler: context
                      };
                    }
                    if (typeof handler === 'function') {
                      handler = {
                        handler: handler
                      };
                    }
                    binding = (0, _extend2.default)(binding, context, handler);
                    this.bindings[binding.key] = this.bindings[binding.key] || [];
                    this.bindings[binding.key].push(binding);
                  }
                }, {
                  key: 'listen',
                  value: function listen() {
                    var _this2 = this;
                    this.quill.root.addEventListener('keydown', function (evt) {
                      if (evt.defaultPrevented) return;
                      var which = evt.which || evt.keyCode;
                      var bindings = (_this2.bindings[which] || []).filter(function (binding) {
                        return Keyboard.match(evt, binding);
                      });
                      if (bindings.length === 0) return;
                      var range = _this2.quill.getSelection();
                      if (range == null || !_this2.quill.hasFocus()) return;
                      var _quill$getLine = _this2.quill.getLine(range.index),
                        _quill$getLine2 = _slicedToArray(_quill$getLine, 2),
                        line = _quill$getLine2[0],
                        offset = _quill$getLine2[1];
                      var _quill$getLeaf = _this2.quill.getLeaf(range.index),
                        _quill$getLeaf2 = _slicedToArray(_quill$getLeaf, 2),
                        leafStart = _quill$getLeaf2[0],
                        offsetStart = _quill$getLeaf2[1];
                      var _ref = range.length === 0 ? [leafStart, offsetStart] : _this2.quill.getLeaf(range.index + range.length),
                        _ref2 = _slicedToArray(_ref, 2),
                        leafEnd = _ref2[0],
                        offsetEnd = _ref2[1];
                      var prefixText = leafStart instanceof _parchment2.default.Text ? leafStart.value().slice(0, offsetStart) : '';
                      var suffixText = leafEnd instanceof _parchment2.default.Text ? leafEnd.value().slice(offsetEnd) : '';
                      var curContext = {
                        collapsed: range.length === 0,
                        empty: range.length === 0 && line.length() <= 1,
                        format: _this2.quill.getFormat(range),
                        offset: offset,
                        prefix: prefixText,
                        suffix: suffixText
                      };
                      var prevented = bindings.some(function (binding) {
                        if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) return false;
                        if (binding.empty != null && binding.empty !== curContext.empty) return false;
                        if (binding.offset != null && binding.offset !== curContext.offset) return false;
                        if (Array.isArray(binding.format)) {
                          // any format is present
                          if (binding.format.every(function (name) {
                            return curContext.format[name] == null;
                          })) {
                            return false;
                          }
                        } else if (_typeof(binding.format) === 'object') {
                          // all formats must match
                          if (!Object.keys(binding.format).every(function (name) {
                            if (binding.format[name] === true) return curContext.format[name] != null;
                            if (binding.format[name] === false) return curContext.format[name] == null;
                            return (0, _deepEqual2.default)(binding.format[name], curContext.format[name]);
                          })) {
                            return false;
                          }
                        }
                        if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) return false;
                        if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) return false;
                        return binding.handler.call(_this2, range, curContext) !== true;
                      });
                      if (prevented) {
                        evt.preventDefault();
                      }
                    });
                  }
                }]);
                return Keyboard;
              }(_module2.default);
              Keyboard.keys = {
                BACKSPACE: 8,
                TAB: 9,
                ENTER: 13,
                ESCAPE: 27,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40,
                DELETE: 46
              };
              Keyboard.DEFAULTS = {
                bindings: {
                  'bold': makeFormatHandler('bold'),
                  'italic': makeFormatHandler('italic'),
                  'underline': makeFormatHandler('underline'),
                  'indent': {
                    // highlight tab or tab at beginning of list, indent or blockquote
                    key: Keyboard.keys.TAB,
                    format: ['blockquote', 'indent', 'list'],
                    handler: function handler(range, context) {
                      if (context.collapsed && context.offset !== 0) return true;
                      this.quill.format('indent', '+1', _quill2.default.sources.USER);
                    }
                  },
                  'outdent': {
                    key: Keyboard.keys.TAB,
                    shiftKey: true,
                    format: ['blockquote', 'indent', 'list'],
                    // highlight tab or tab at beginning of list, indent or blockquote
                    handler: function handler(range, context) {
                      if (context.collapsed && context.offset !== 0) return true;
                      this.quill.format('indent', '-1', _quill2.default.sources.USER);
                    }
                  },
                  'outdent backspace': {
                    key: Keyboard.keys.BACKSPACE,
                    collapsed: true,
                    shiftKey: null,
                    metaKey: null,
                    ctrlKey: null,
                    altKey: null,
                    format: ['indent', 'list'],
                    offset: 0,
                    handler: function handler(range, context) {
                      if (context.format.indent != null) {
                        this.quill.format('indent', '-1', _quill2.default.sources.USER);
                      } else if (context.format.list != null) {
                        this.quill.format('list', false, _quill2.default.sources.USER);
                      }
                    }
                  },
                  'indent code-block': makeCodeBlockHandler(true),
                  'outdent code-block': makeCodeBlockHandler(false),
                  'remove tab': {
                    key: Keyboard.keys.TAB,
                    shiftKey: true,
                    collapsed: true,
                    prefix: /\t$/,
                    handler: function handler(range) {
                      this.quill.deleteText(range.index - 1, 1, _quill2.default.sources.USER);
                    }
                  },
                  'tab': {
                    key: Keyboard.keys.TAB,
                    handler: function handler(range) {
                      this.quill.history.cutoff();
                      var delta = new _quillDelta2.default().retain(range.index).delete(range.length).insert('\t');
                      this.quill.updateContents(delta, _quill2.default.sources.USER);
                      this.quill.history.cutoff();
                      this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                    }
                  },
                  'list empty enter': {
                    key: Keyboard.keys.ENTER,
                    collapsed: true,
                    format: ['list'],
                    empty: true,
                    handler: function handler(range, context) {
                      this.quill.format('list', false, _quill2.default.sources.USER);
                      if (context.format.indent) {
                        this.quill.format('indent', false, _quill2.default.sources.USER);
                      }
                    }
                  },
                  'checklist enter': {
                    key: Keyboard.keys.ENTER,
                    collapsed: true,
                    format: {
                      list: 'checked'
                    },
                    handler: function handler(range) {
                      var _quill$getLine3 = this.quill.getLine(range.index),
                        _quill$getLine4 = _slicedToArray(_quill$getLine3, 2),
                        line = _quill$getLine4[0],
                        offset = _quill$getLine4[1];
                      var formats = (0, _extend2.default)({}, line.formats(), {
                        list: 'checked'
                      });
                      var delta = new _quillDelta2.default().retain(range.index).insert('\n', formats).retain(line.length() - offset - 1).retain(1, {
                        list: 'unchecked'
                      });
                      this.quill.updateContents(delta, _quill2.default.sources.USER);
                      this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                      this.quill.scrollIntoView();
                    }
                  },
                  'header enter': {
                    key: Keyboard.keys.ENTER,
                    collapsed: true,
                    format: ['header'],
                    suffix: /^$/,
                    handler: function handler(range, context) {
                      var _quill$getLine5 = this.quill.getLine(range.index),
                        _quill$getLine6 = _slicedToArray(_quill$getLine5, 2),
                        line = _quill$getLine6[0],
                        offset = _quill$getLine6[1];
                      var delta = new _quillDelta2.default().retain(range.index).insert('\n', context.format).retain(line.length() - offset - 1).retain(1, {
                        header: null
                      });
                      this.quill.updateContents(delta, _quill2.default.sources.USER);
                      this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                      this.quill.scrollIntoView();
                    }
                  },
                  'list autofill': {
                    key: ' ',
                    collapsed: true,
                    format: {
                      list: false
                    },
                    prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
                    handler: function handler(range, context) {
                      var length = context.prefix.length;
                      var _quill$getLine7 = this.quill.getLine(range.index),
                        _quill$getLine8 = _slicedToArray(_quill$getLine7, 2),
                        line = _quill$getLine8[0],
                        offset = _quill$getLine8[1];
                      if (offset > length) return true;
                      var value = void 0;
                      switch (context.prefix.trim()) {
                        case '[]':
                        case '[ ]':
                          value = 'unchecked';
                          break;
                        case '[x]':
                          value = 'checked';
                          break;
                        case '-':
                        case '*':
                          value = 'bullet';
                          break;
                        default:
                          value = 'ordered';
                      }
                      this.quill.insertText(range.index, ' ', _quill2.default.sources.USER);
                      this.quill.history.cutoff();
                      var delta = new _quillDelta2.default().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, {
                        list: value
                      });
                      this.quill.updateContents(delta, _quill2.default.sources.USER);
                      this.quill.history.cutoff();
                      this.quill.setSelection(range.index - length, _quill2.default.sources.SILENT);
                    }
                  },
                  'code exit': {
                    key: Keyboard.keys.ENTER,
                    collapsed: true,
                    format: ['code-block'],
                    prefix: /\n\n$/,
                    suffix: /^\s+$/,
                    handler: function handler(range) {
                      var _quill$getLine9 = this.quill.getLine(range.index),
                        _quill$getLine10 = _slicedToArray(_quill$getLine9, 2),
                        line = _quill$getLine10[0],
                        offset = _quill$getLine10[1];
                      var delta = new _quillDelta2.default().retain(range.index + line.length() - offset - 2).retain(1, {
                        'code-block': null
                      }).delete(1);
                      this.quill.updateContents(delta, _quill2.default.sources.USER);
                    }
                  },
                  'embed left': makeEmbedArrowHandler(Keyboard.keys.LEFT, false),
                  'embed left shift': makeEmbedArrowHandler(Keyboard.keys.LEFT, true),
                  'embed right': makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),
                  'embed right shift': makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)
                }
              };
              function makeEmbedArrowHandler(key, shiftKey) {
                var _ref3;
                var where = key === Keyboard.keys.LEFT ? 'prefix' : 'suffix';
                return _ref3 = {
                  key: key,
                  shiftKey: shiftKey,
                  altKey: null
                }, _defineProperty(_ref3, where, /^$/), _defineProperty(_ref3, 'handler', function handler(range) {
                  var index = range.index;
                  if (key === Keyboard.keys.RIGHT) {
                    index += range.length + 1;
                  }
                  var _quill$getLeaf3 = this.quill.getLeaf(index),
                    _quill$getLeaf4 = _slicedToArray(_quill$getLeaf3, 1),
                    leaf = _quill$getLeaf4[0];
                  if (!(leaf instanceof _parchment2.default.Embed)) return true;
                  if (key === Keyboard.keys.LEFT) {
                    if (shiftKey) {
                      this.quill.setSelection(range.index - 1, range.length + 1, _quill2.default.sources.USER);
                    } else {
                      this.quill.setSelection(range.index - 1, _quill2.default.sources.USER);
                    }
                  } else {
                    if (shiftKey) {
                      this.quill.setSelection(range.index, range.length + 1, _quill2.default.sources.USER);
                    } else {
                      this.quill.setSelection(range.index + range.length + 1, _quill2.default.sources.USER);
                    }
                  }
                  return false;
                }), _ref3;
              }
              function handleBackspace(range, context) {
                if (range.index === 0 || this.quill.getLength() <= 1) return;
                var _quill$getLine11 = this.quill.getLine(range.index),
                  _quill$getLine12 = _slicedToArray(_quill$getLine11, 1),
                  line = _quill$getLine12[0];
                var formats = {};
                if (context.offset === 0) {
                  var _quill$getLine13 = this.quill.getLine(range.index - 1),
                    _quill$getLine14 = _slicedToArray(_quill$getLine13, 1),
                    prev = _quill$getLine14[0];
                  if (prev != null && prev.length() > 1) {
                    var curFormats = line.formats();
                    var prevFormats = this.quill.getFormat(range.index - 1, 1);
                    formats = _op2.default.attributes.diff(curFormats, prevFormats) || {};
                  }
                }
                // Check for astral symbols
                var length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix) ? 2 : 1;
                this.quill.deleteText(range.index - length, length, _quill2.default.sources.USER);
                if (Object.keys(formats).length > 0) {
                  this.quill.formatLine(range.index - length, length, formats, _quill2.default.sources.USER);
                }
                this.quill.focus();
              }
              function handleDelete(range, context) {
                // Check for astral symbols
                var length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix) ? 2 : 1;
                if (range.index >= this.quill.getLength() - length) return;
                var formats = {},
                  nextLength = 0;
                var _quill$getLine15 = this.quill.getLine(range.index),
                  _quill$getLine16 = _slicedToArray(_quill$getLine15, 1),
                  line = _quill$getLine16[0];
                if (context.offset >= line.length() - 1) {
                  var _quill$getLine17 = this.quill.getLine(range.index + 1),
                    _quill$getLine18 = _slicedToArray(_quill$getLine17, 1),
                    next = _quill$getLine18[0];
                  if (next) {
                    var curFormats = line.formats();
                    var nextFormats = this.quill.getFormat(range.index, 1);
                    formats = _op2.default.attributes.diff(curFormats, nextFormats) || {};
                    nextLength = next.length();
                  }
                }
                this.quill.deleteText(range.index, length, _quill2.default.sources.USER);
                if (Object.keys(formats).length > 0) {
                  this.quill.formatLine(range.index + nextLength - 1, length, formats, _quill2.default.sources.USER);
                }
              }
              function handleDeleteRange(range) {
                var lines = this.quill.getLines(range);
                var formats = {};
                if (lines.length > 1) {
                  var firstFormats = lines[0].formats();
                  var lastFormats = lines[lines.length - 1].formats();
                  formats = _op2.default.attributes.diff(lastFormats, firstFormats) || {};
                }
                this.quill.deleteText(range, _quill2.default.sources.USER);
                if (Object.keys(formats).length > 0) {
                  this.quill.formatLine(range.index, 1, formats, _quill2.default.sources.USER);
                }
                this.quill.setSelection(range.index, _quill2.default.sources.SILENT);
                this.quill.focus();
              }
              function handleEnter(range, context) {
                var _this3 = this;
                if (range.length > 0) {
                  this.quill.scroll.deleteAt(range.index, range.length); // So we do not trigger text-change
                }
                var lineFormats = Object.keys(context.format).reduce(function (lineFormats, format) {
                  if (_parchment2.default.query(format, _parchment2.default.Scope.BLOCK) && !Array.isArray(context.format[format])) {
                    lineFormats[format] = context.format[format];
                  }
                  return lineFormats;
                }, {});
                this.quill.insertText(range.index, '\n', lineFormats, _quill2.default.sources.USER);
                // Earlier scroll.deleteAt might have messed up our selection,
                // so insertText's built in selection preservation is not reliable
                this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                this.quill.focus();
                Object.keys(context.format).forEach(function (name) {
                  if (lineFormats[name] != null) return;
                  if (Array.isArray(context.format[name])) return;
                  if (name === 'link') return;
                  _this3.quill.format(name, context.format[name], _quill2.default.sources.USER);
                });
              }
              function makeCodeBlockHandler(indent) {
                return {
                  key: Keyboard.keys.TAB,
                  shiftKey: !indent,
                  format: {
                    'code-block': true
                  },
                  handler: function handler(range) {
                    var CodeBlock = _parchment2.default.query('code-block');
                    var index = range.index,
                      length = range.length;
                    var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index),
                      _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2),
                      block = _quill$scroll$descend2[0],
                      offset = _quill$scroll$descend2[1];
                    if (block == null) return;
                    var scrollIndex = this.quill.getIndex(block);
                    var start = block.newlineIndex(offset, true) + 1;
                    var end = block.newlineIndex(scrollIndex + offset + length);
                    var lines = block.domNode.textContent.slice(start, end).split('\n');
                    offset = 0;
                    lines.forEach(function (line, i) {
                      if (indent) {
                        block.insertAt(start + offset, CodeBlock.TAB);
                        offset += CodeBlock.TAB.length;
                        if (i === 0) {
                          index += CodeBlock.TAB.length;
                        } else {
                          length += CodeBlock.TAB.length;
                        }
                      } else if (line.startsWith(CodeBlock.TAB)) {
                        block.deleteAt(start + offset, CodeBlock.TAB.length);
                        offset -= CodeBlock.TAB.length;
                        if (i === 0) {
                          index -= CodeBlock.TAB.length;
                        } else {
                          length -= CodeBlock.TAB.length;
                        }
                      }
                      offset += line.length + 1;
                    });
                    this.quill.update(_quill2.default.sources.USER);
                    this.quill.setSelection(index, length, _quill2.default.sources.SILENT);
                  }
                };
              }
              function makeFormatHandler(format) {
                return {
                  key: format[0].toUpperCase(),
                  shortKey: true,
                  handler: function handler(range, context) {
                    this.quill.format(format, !context.format[format], _quill2.default.sources.USER);
                  }
                };
              }
              function normalize(binding) {
                if (typeof binding === 'string' || typeof binding === 'number') {
                  return normalize({
                    key: binding
                  });
                }
                if ((typeof binding === 'undefined' ? 'undefined' : _typeof(binding)) === 'object') {
                  binding = (0, _clone2.default)(binding, false);
                }
                if (typeof binding.key === 'string') {
                  if (Keyboard.keys[binding.key.toUpperCase()] != null) {
                    binding.key = Keyboard.keys[binding.key.toUpperCase()];
                  } else if (binding.key.length === 1) {
                    binding.key = binding.key.toUpperCase().charCodeAt(0);
                  } else {
                    return null;
                  }
                }
                if (binding.shortKey) {
                  binding[SHORTKEY] = binding.shortKey;
                  delete binding.shortKey;
                }
                return binding;
              }
              exports.default = Keyboard;
              exports.SHORTKEY = SHORTKEY;

              /***/
            }), (/* 24 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _slicedToArray = function () {
                function sliceIterator(arr, i) {
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i) break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"]) _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }
                return function (arr, i) {
                  if (Array.isArray(arr)) {
                    return arr;
                  } else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                  } else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                  }
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _text = __webpack_require__(7);
              var _text2 = _interopRequireDefault(_text);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var Cursor = function (_Parchment$Embed) {
                _inherits(Cursor, _Parchment$Embed);
                _createClass(Cursor, null, [{
                  key: 'value',
                  value: function value() {
                    return undefined;
                  }
                }]);
                function Cursor(domNode, selection) {
                  _classCallCheck(this, Cursor);
                  var _this = _possibleConstructorReturn(this, (Cursor.__proto__ || Object.getPrototypeOf(Cursor)).call(this, domNode));
                  _this.selection = selection;
                  _this.textNode = document.createTextNode(Cursor.CONTENTS);
                  _this.domNode.appendChild(_this.textNode);
                  _this._length = 0;
                  return _this;
                }
                _createClass(Cursor, [{
                  key: 'detach',
                  value: function detach() {
                    // super.detach() will also clear domNode.__blot
                    if (this.parent != null) this.parent.removeChild(this);
                  }
                }, {
                  key: 'format',
                  value: function format(name, value) {
                    if (this._length !== 0) {
                      return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'format', this).call(this, name, value);
                    }
                    var target = this,
                      index = 0;
                    while (target != null && target.statics.scope !== _parchment2.default.Scope.BLOCK_BLOT) {
                      index += target.offset(target.parent);
                      target = target.parent;
                    }
                    if (target != null) {
                      this._length = Cursor.CONTENTS.length;
                      target.optimize();
                      target.formatAt(index, Cursor.CONTENTS.length, name, value);
                      this._length = 0;
                    }
                  }
                }, {
                  key: 'index',
                  value: function index(node, offset) {
                    if (node === this.textNode) return 0;
                    return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'index', this).call(this, node, offset);
                  }
                }, {
                  key: 'length',
                  value: function length() {
                    return this._length;
                  }
                }, {
                  key: 'position',
                  value: function position() {
                    return [this.textNode, this.textNode.data.length];
                  }
                }, {
                  key: 'remove',
                  value: function remove() {
                    _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'remove', this).call(this);
                    this.parent = null;
                  }
                }, {
                  key: 'restore',
                  value: function restore() {
                    if (this.selection.composing || this.parent == null) return;
                    var textNode = this.textNode;
                    var range = this.selection.getNativeRange();
                    var restoreText = void 0,
                      start = void 0,
                      end = void 0;
                    if (range != null && range.start.node === textNode && range.end.node === textNode) {
                      var _ref = [textNode, range.start.offset, range.end.offset];
                      restoreText = _ref[0];
                      start = _ref[1];
                      end = _ref[2];
                    }
                    // Link format will insert text outside of anchor tag
                    while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
                      this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
                    }
                    if (this.textNode.data !== Cursor.CONTENTS) {
                      var text = this.textNode.data.split(Cursor.CONTENTS).join('');
                      if (this.next instanceof _text2.default) {
                        restoreText = this.next.domNode;
                        this.next.insertAt(0, text);
                        this.textNode.data = Cursor.CONTENTS;
                      } else {
                        this.textNode.data = text;
                        this.parent.insertBefore(_parchment2.default.create(this.textNode), this);
                        this.textNode = document.createTextNode(Cursor.CONTENTS);
                        this.domNode.appendChild(this.textNode);
                      }
                    }
                    this.remove();
                    if (start != null) {
                      var _map = [start, end].map(function (offset) {
                        return Math.max(0, Math.min(restoreText.data.length, offset - 1));
                      });
                      var _map2 = _slicedToArray(_map, 2);
                      start = _map2[0];
                      end = _map2[1];
                      return {
                        startNode: restoreText,
                        startOffset: start,
                        endNode: restoreText,
                        endOffset: end
                      };
                    }
                  }
                }, {
                  key: 'update',
                  value: function update(mutations, context) {
                    var _this2 = this;
                    if (mutations.some(function (mutation) {
                      return mutation.type === 'characterData' && mutation.target === _this2.textNode;
                    })) {
                      var range = this.restore();
                      if (range) context.range = range;
                    }
                  }
                }, {
                  key: 'value',
                  value: function value() {
                    return '';
                  }
                }]);
                return Cursor;
              }(_parchment2.default.Embed);
              Cursor.blotName = 'cursor';
              Cursor.className = 'ql-cursor';
              Cursor.tagName = 'span';
              Cursor.CONTENTS = '\uFEFF'; // Zero width no break space

              exports.default = Cursor;

              /***/
            }), (/* 25 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _block = __webpack_require__(4);
              var _block2 = _interopRequireDefault(_block);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var Container = function (_Parchment$Container) {
                _inherits(Container, _Parchment$Container);
                function Container() {
                  _classCallCheck(this, Container);
                  return _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));
                }
                return Container;
              }(_parchment2.default.Container);
              Container.allowedChildren = [_block2.default, _block.BlockEmbed, Container];
              exports.default = Container;

              /***/
            }), (/* 26 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.ColorStyle = exports.ColorClass = exports.ColorAttributor = undefined;
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var ColorAttributor = function (_Parchment$Attributor) {
                _inherits(ColorAttributor, _Parchment$Attributor);
                function ColorAttributor() {
                  _classCallCheck(this, ColorAttributor);
                  return _possibleConstructorReturn(this, (ColorAttributor.__proto__ || Object.getPrototypeOf(ColorAttributor)).apply(this, arguments));
                }
                _createClass(ColorAttributor, [{
                  key: 'value',
                  value: function value(domNode) {
                    var value = _get(ColorAttributor.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor.prototype), 'value', this).call(this, domNode);
                    if (!value.startsWith('rgb(')) return value;
                    value = value.replace(/^[^\d]+/, '').replace(/[^\d]+$/, '');
                    return '#' + value.split(',').map(function (component) {
                      return ('00' + parseInt(component).toString(16)).slice(-2);
                    }).join('');
                  }
                }]);
                return ColorAttributor;
              }(_parchment2.default.Attributor.Style);
              var ColorClass = new _parchment2.default.Attributor.Class('color', 'ql-color', {
                scope: _parchment2.default.Scope.INLINE
              });
              var ColorStyle = new ColorAttributor('color', 'color', {
                scope: _parchment2.default.Scope.INLINE
              });
              exports.ColorAttributor = ColorAttributor;
              exports.ColorClass = ColorClass;
              exports.ColorStyle = ColorStyle;

              /***/
            }), (/* 27 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.sanitize = exports.default = undefined;
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _inline = __webpack_require__(6);
              var _inline2 = _interopRequireDefault(_inline);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var Link = function (_Inline) {
                _inherits(Link, _Inline);
                function Link() {
                  _classCallCheck(this, Link);
                  return _possibleConstructorReturn(this, (Link.__proto__ || Object.getPrototypeOf(Link)).apply(this, arguments));
                }
                _createClass(Link, [{
                  key: 'format',
                  value: function format(name, value) {
                    if (name !== this.statics.blotName || !value) return _get(Link.prototype.__proto__ || Object.getPrototypeOf(Link.prototype), 'format', this).call(this, name, value);
                    value = this.constructor.sanitize(value);
                    this.domNode.setAttribute('href', value);
                  }
                }], [{
                  key: 'create',
                  value: function create(value) {
                    var node = _get(Link.__proto__ || Object.getPrototypeOf(Link), 'create', this).call(this, value);
                    value = this.sanitize(value);
                    node.setAttribute('href', value);
                    node.setAttribute('rel', 'noopener noreferrer');
                    node.setAttribute('target', '_blank');
                    return node;
                  }
                }, {
                  key: 'formats',
                  value: function formats(domNode) {
                    return domNode.getAttribute('href');
                  }
                }, {
                  key: 'sanitize',
                  value: function sanitize(url) {
                    return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
                  }
                }]);
                return Link;
              }(_inline2.default);
              Link.blotName = 'link';
              Link.tagName = 'A';
              Link.SANITIZED_URL = 'about:blank';
              Link.PROTOCOL_WHITELIST = ['http', 'https', 'mailto', 'tel'];
              function _sanitize(url, protocols) {
                var anchor = document.createElement('a');
                anchor.href = url;
                var protocol = anchor.href.slice(0, anchor.href.indexOf(':'));
                return protocols.indexOf(protocol) > -1;
              }
              exports.default = Link;
              exports.sanitize = _sanitize;

              /***/
            }), (/* 28 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                return typeof obj;
              } : function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              };
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _keyboard = __webpack_require__(23);
              var _keyboard2 = _interopRequireDefault(_keyboard);
              var _dropdown = __webpack_require__(107);
              var _dropdown2 = _interopRequireDefault(_dropdown);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var optionsCounter = 0;
              function toggleAriaAttribute(element, attribute) {
                element.setAttribute(attribute, !(element.getAttribute(attribute) === 'true'));
              }
              var Picker = function () {
                function Picker(select) {
                  var _this = this;
                  _classCallCheck(this, Picker);
                  this.select = select;
                  this.container = document.createElement('span');
                  this.buildPicker();
                  this.select.style.display = 'none';
                  this.select.parentNode.insertBefore(this.container, this.select);
                  this.label.addEventListener('mousedown', function () {
                    _this.togglePicker();
                  });
                  this.label.addEventListener('keydown', function (event) {
                    switch (event.keyCode) {
                      // Allows the "Enter" key to open the picker
                      case _keyboard2.default.keys.ENTER:
                        _this.togglePicker();
                        break;

                      // Allows the "Escape" key to close the picker
                      case _keyboard2.default.keys.ESCAPE:
                        _this.escape();
                        event.preventDefault();
                        break;
                    }
                  });
                  this.select.addEventListener('change', this.update.bind(this));
                }
                _createClass(Picker, [{
                  key: 'togglePicker',
                  value: function togglePicker() {
                    this.container.classList.toggle('ql-expanded');
                    // Toggle aria-expanded and aria-hidden to make the picker accessible
                    toggleAriaAttribute(this.label, 'aria-expanded');
                    toggleAriaAttribute(this.options, 'aria-hidden');
                  }
                }, {
                  key: 'buildItem',
                  value: function buildItem(option) {
                    var _this2 = this;
                    var item = document.createElement('span');
                    item.tabIndex = '0';
                    item.setAttribute('role', 'button');
                    item.classList.add('ql-picker-item');
                    if (option.hasAttribute('value')) {
                      item.setAttribute('data-value', option.getAttribute('value'));
                    }
                    if (option.textContent) {
                      item.setAttribute('data-label', option.textContent);
                    }
                    item.addEventListener('click', function () {
                      _this2.selectItem(item, true);
                    });
                    item.addEventListener('keydown', function (event) {
                      switch (event.keyCode) {
                        // Allows the "Enter" key to select an item
                        case _keyboard2.default.keys.ENTER:
                          _this2.selectItem(item, true);
                          event.preventDefault();
                          break;

                        // Allows the "Escape" key to close the picker
                        case _keyboard2.default.keys.ESCAPE:
                          _this2.escape();
                          event.preventDefault();
                          break;
                      }
                    });
                    return item;
                  }
                }, {
                  key: 'buildLabel',
                  value: function buildLabel() {
                    var label = document.createElement('span');
                    label.classList.add('ql-picker-label');
                    label.innerHTML = _dropdown2.default;
                    label.tabIndex = '0';
                    label.setAttribute('role', 'button');
                    label.setAttribute('aria-expanded', 'false');
                    this.container.appendChild(label);
                    return label;
                  }
                }, {
                  key: 'buildOptions',
                  value: function buildOptions() {
                    var _this3 = this;
                    var options = document.createElement('span');
                    options.classList.add('ql-picker-options');

                    // Don't want screen readers to read this until options are visible
                    options.setAttribute('aria-hidden', 'true');
                    options.tabIndex = '-1';

                    // Need a unique id for aria-controls
                    options.id = 'ql-picker-options-' + optionsCounter;
                    optionsCounter += 1;
                    this.label.setAttribute('aria-controls', options.id);
                    this.options = options;
                    [].slice.call(this.select.options).forEach(function (option) {
                      var item = _this3.buildItem(option);
                      options.appendChild(item);
                      if (option.selected === true) {
                        _this3.selectItem(item);
                      }
                    });
                    this.container.appendChild(options);
                  }
                }, {
                  key: 'buildPicker',
                  value: function buildPicker() {
                    var _this4 = this;
                    [].slice.call(this.select.attributes).forEach(function (item) {
                      _this4.container.setAttribute(item.name, item.value);
                    });
                    this.container.classList.add('ql-picker');
                    this.label = this.buildLabel();
                    this.buildOptions();
                  }
                }, {
                  key: 'escape',
                  value: function escape() {
                    var _this5 = this;

                    // Close menu and return focus to trigger label
                    this.close();
                    // Need setTimeout for accessibility to ensure that the browser executes
                    // focus on the next process thread and after any DOM content changes
                    setTimeout(function () {
                      return _this5.label.focus();
                    }, 1);
                  }
                }, {
                  key: 'close',
                  value: function close() {
                    this.container.classList.remove('ql-expanded');
                    this.label.setAttribute('aria-expanded', 'false');
                    this.options.setAttribute('aria-hidden', 'true');
                  }
                }, {
                  key: 'selectItem',
                  value: function selectItem(item) {
                    var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                    var selected = this.container.querySelector('.ql-selected');
                    if (item === selected) return;
                    if (selected != null) {
                      selected.classList.remove('ql-selected');
                    }
                    if (item == null) return;
                    item.classList.add('ql-selected');
                    this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);
                    if (item.hasAttribute('data-value')) {
                      this.label.setAttribute('data-value', item.getAttribute('data-value'));
                    } else {
                      this.label.removeAttribute('data-value');
                    }
                    if (item.hasAttribute('data-label')) {
                      this.label.setAttribute('data-label', item.getAttribute('data-label'));
                    } else {
                      this.label.removeAttribute('data-label');
                    }
                    if (trigger) {
                      if (typeof Event === 'function') {
                        this.select.dispatchEvent(new Event('change'));
                      } else if ((typeof Event === 'undefined' ? 'undefined' : _typeof(Event)) === 'object') {
                        // IE11
                        var event = document.createEvent('Event');
                        event.initEvent('change', true, true);
                        this.select.dispatchEvent(event);
                      }
                      this.close();
                    }
                  }
                }, {
                  key: 'update',
                  value: function update() {
                    var option = void 0;
                    if (this.select.selectedIndex > -1) {
                      var item = this.container.querySelector('.ql-picker-options').children[this.select.selectedIndex];
                      option = this.select.options[this.select.selectedIndex];
                      this.selectItem(item);
                    } else {
                      this.selectItem(null);
                    }
                    var isActive = option != null && option !== this.select.querySelector('option[selected]');
                    this.label.classList.toggle('ql-active', isActive);
                  }
                }]);
                return Picker;
              }();
              exports.default = Picker;

              /***/
            }), (/* 29 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _quill = __webpack_require__(5);
              var _quill2 = _interopRequireDefault(_quill);
              var _block = __webpack_require__(4);
              var _block2 = _interopRequireDefault(_block);
              var _break = __webpack_require__(16);
              var _break2 = _interopRequireDefault(_break);
              var _container = __webpack_require__(25);
              var _container2 = _interopRequireDefault(_container);
              var _cursor = __webpack_require__(24);
              var _cursor2 = _interopRequireDefault(_cursor);
              var _embed = __webpack_require__(35);
              var _embed2 = _interopRequireDefault(_embed);
              var _inline = __webpack_require__(6);
              var _inline2 = _interopRequireDefault(_inline);
              var _scroll = __webpack_require__(22);
              var _scroll2 = _interopRequireDefault(_scroll);
              var _text = __webpack_require__(7);
              var _text2 = _interopRequireDefault(_text);
              var _clipboard = __webpack_require__(55);
              var _clipboard2 = _interopRequireDefault(_clipboard);
              var _history = __webpack_require__(42);
              var _history2 = _interopRequireDefault(_history);
              var _keyboard = __webpack_require__(23);
              var _keyboard2 = _interopRequireDefault(_keyboard);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              _quill2.default.register({
                'blots/block': _block2.default,
                'blots/block/embed': _block.BlockEmbed,
                'blots/break': _break2.default,
                'blots/container': _container2.default,
                'blots/cursor': _cursor2.default,
                'blots/embed': _embed2.default,
                'blots/inline': _inline2.default,
                'blots/scroll': _scroll2.default,
                'blots/text': _text2.default,
                'modules/clipboard': _clipboard2.default,
                'modules/history': _history2.default,
                'modules/keyboard': _keyboard2.default
              });
              _parchment2.default.register(_block2.default, _break2.default, _cursor2.default, _inline2.default, _scroll2.default, _text2.default);
              exports.default = _quill2.default;

              /***/
            }), (/* 30 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var Registry = __webpack_require__(1);
              var ShadowBlot = /** @class */function () {
                function ShadowBlot(domNode) {
                  this.domNode = domNode;
                  // @ts-ignore
                  this.domNode[Registry.DATA_KEY] = {
                    blot: this
                  };
                }
                Object.defineProperty(ShadowBlot.prototype, "statics", {
                  // Hack for accessing inherited static methods
                  get: function get() {
                    return this.constructor;
                  },
                  enumerable: true,
                  configurable: true
                });
                ShadowBlot.create = function (value) {
                  if (this.tagName == null) {
                    throw new Registry.ParchmentError('Blot definition missing tagName');
                  }
                  var node;
                  if (Array.isArray(this.tagName)) {
                    if (typeof value === 'string') {
                      value = value.toUpperCase();
                      if (parseInt(value).toString() === value) {
                        value = parseInt(value);
                      }
                    }
                    if (typeof value === 'number') {
                      node = document.createElement(this.tagName[value - 1]);
                    } else if (this.tagName.indexOf(value) > -1) {
                      node = document.createElement(value);
                    } else {
                      node = document.createElement(this.tagName[0]);
                    }
                  } else {
                    node = document.createElement(this.tagName);
                  }
                  if (this.className) {
                    node.classList.add(this.className);
                  }
                  return node;
                };
                ShadowBlot.prototype.attach = function () {
                  if (this.parent != null) {
                    this.scroll = this.parent.scroll;
                  }
                };
                ShadowBlot.prototype.clone = function () {
                  var domNode = this.domNode.cloneNode(false);
                  return Registry.create(domNode);
                };
                ShadowBlot.prototype.detach = function () {
                  if (this.parent != null) this.parent.removeChild(this);
                  // @ts-ignore
                  delete this.domNode[Registry.DATA_KEY];
                };
                ShadowBlot.prototype.deleteAt = function (index, length) {
                  var blot = this.isolate(index, length);
                  blot.remove();
                };
                ShadowBlot.prototype.formatAt = function (index, length, name, value) {
                  var blot = this.isolate(index, length);
                  if (Registry.query(name, Registry.Scope.BLOT) != null && value) {
                    blot.wrap(name, value);
                  } else if (Registry.query(name, Registry.Scope.ATTRIBUTE) != null) {
                    var parent = Registry.create(this.statics.scope);
                    blot.wrap(parent);
                    parent.format(name, value);
                  }
                };
                ShadowBlot.prototype.insertAt = function (index, value, def) {
                  var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
                  var ref = this.split(index);
                  this.parent.insertBefore(blot, ref);
                };
                ShadowBlot.prototype.insertInto = function (parentBlot, refBlot) {
                  if (refBlot === void 0) {
                    refBlot = null;
                  }
                  if (this.parent != null) {
                    this.parent.children.remove(this);
                  }
                  var refDomNode = null;
                  parentBlot.children.insertBefore(this, refBlot);
                  if (refBlot != null) {
                    refDomNode = refBlot.domNode;
                  }
                  if (this.domNode.parentNode != parentBlot.domNode || this.domNode.nextSibling != refDomNode) {
                    parentBlot.domNode.insertBefore(this.domNode, refDomNode);
                  }
                  this.parent = parentBlot;
                  this.attach();
                };
                ShadowBlot.prototype.isolate = function (index, length) {
                  var target = this.split(index);
                  target.split(length);
                  return target;
                };
                ShadowBlot.prototype.length = function () {
                  return 1;
                };
                ShadowBlot.prototype.offset = function (root) {
                  if (root === void 0) {
                    root = this.parent;
                  }
                  if (this.parent == null || this == root) return 0;
                  return this.parent.children.offset(this) + this.parent.offset(root);
                };
                ShadowBlot.prototype.optimize = function (context) {
                  // TODO clean up once we use WeakMap
                  // @ts-ignore
                  if (this.domNode[Registry.DATA_KEY] != null) {
                    // @ts-ignore
                    delete this.domNode[Registry.DATA_KEY].mutations;
                  }
                };
                ShadowBlot.prototype.remove = function () {
                  if (this.domNode.parentNode != null) {
                    this.domNode.parentNode.removeChild(this.domNode);
                  }
                  this.detach();
                };
                ShadowBlot.prototype.replace = function (target) {
                  if (target.parent == null) return;
                  target.parent.insertBefore(this, target.next);
                  target.remove();
                };
                ShadowBlot.prototype.replaceWith = function (name, value) {
                  var replacement = typeof name === 'string' ? Registry.create(name, value) : name;
                  replacement.replace(this);
                  return replacement;
                };
                ShadowBlot.prototype.split = function (index, force) {
                  return index === 0 ? this : this.next;
                };
                ShadowBlot.prototype.update = function (mutations, context) {
                  // Nothing to do by default
                };
                ShadowBlot.prototype.wrap = function (name, value) {
                  var wrapper = typeof name === 'string' ? Registry.create(name, value) : name;
                  if (this.parent != null) {
                    this.parent.insertBefore(wrapper, this.next);
                  }
                  wrapper.appendChild(this);
                  return wrapper;
                };
                ShadowBlot.blotName = 'abstract';
                return ShadowBlot;
              }();
              exports.default = ShadowBlot;

              /***/
            }), (/* 31 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var attributor_1 = __webpack_require__(12);
              var class_1 = __webpack_require__(32);
              var style_1 = __webpack_require__(33);
              var Registry = __webpack_require__(1);
              var AttributorStore = /** @class */function () {
                function AttributorStore(domNode) {
                  this.attributes = {};
                  this.domNode = domNode;
                  this.build();
                }
                AttributorStore.prototype.attribute = function (attribute, value) {
                  // verb
                  if (value) {
                    if (attribute.add(this.domNode, value)) {
                      if (attribute.value(this.domNode) != null) {
                        this.attributes[attribute.attrName] = attribute;
                      } else {
                        delete this.attributes[attribute.attrName];
                      }
                    }
                  } else {
                    attribute.remove(this.domNode);
                    delete this.attributes[attribute.attrName];
                  }
                };
                AttributorStore.prototype.build = function () {
                  var _this = this;
                  this.attributes = {};
                  var attributes = attributor_1.default.keys(this.domNode);
                  var classes = class_1.default.keys(this.domNode);
                  var styles = style_1.default.keys(this.domNode);
                  attributes.concat(classes).concat(styles).forEach(function (name) {
                    var attr = Registry.query(name, Registry.Scope.ATTRIBUTE);
                    if (attr instanceof attributor_1.default) {
                      _this.attributes[attr.attrName] = attr;
                    }
                  });
                };
                AttributorStore.prototype.copy = function (target) {
                  var _this = this;
                  Object.keys(this.attributes).forEach(function (key) {
                    var value = _this.attributes[key].value(_this.domNode);
                    target.format(key, value);
                  });
                };
                AttributorStore.prototype.move = function (target) {
                  var _this = this;
                  this.copy(target);
                  Object.keys(this.attributes).forEach(function (key) {
                    _this.attributes[key].remove(_this.domNode);
                  });
                  this.attributes = {};
                };
                AttributorStore.prototype.values = function () {
                  var _this = this;
                  return Object.keys(this.attributes).reduce(function (attributes, name) {
                    attributes[name] = _this.attributes[name].value(_this.domNode);
                    return attributes;
                  }, {});
                };
                return AttributorStore;
              }();
              exports.default = AttributorStore;

              /***/
            }), (/* 32 */
            /***/function (module, exports, __webpack_require__) {
              var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function (d, b) {
                  d.__proto__ = b;
                } || function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
                return function (d, b) {
                  extendStatics(d, b);
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
              }();
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var attributor_1 = __webpack_require__(12);
              function match(node, prefix) {
                var className = node.getAttribute('class') || '';
                return className.split(/\s+/).filter(function (name) {
                  return name.indexOf(prefix + "-") === 0;
                });
              }
              var ClassAttributor = /** @class */function (_super) {
                __extends(ClassAttributor, _super);
                function ClassAttributor() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                ClassAttributor.keys = function (node) {
                  return (node.getAttribute('class') || '').split(/\s+/).map(function (name) {
                    return name.split('-').slice(0, -1).join('-');
                  });
                };
                ClassAttributor.prototype.add = function (node, value) {
                  if (!this.canAdd(node, value)) return false;
                  this.remove(node);
                  node.classList.add(this.keyName + "-" + value);
                  return true;
                };
                ClassAttributor.prototype.remove = function (node) {
                  var matches = match(node, this.keyName);
                  matches.forEach(function (name) {
                    node.classList.remove(name);
                  });
                  if (node.classList.length === 0) {
                    node.removeAttribute('class');
                  }
                };
                ClassAttributor.prototype.value = function (node) {
                  var result = match(node, this.keyName)[0] || '';
                  var value = result.slice(this.keyName.length + 1); // +1 for hyphen
                  return this.canAdd(node, value) ? value : '';
                };
                return ClassAttributor;
              }(attributor_1.default);
              exports.default = ClassAttributor;

              /***/
            }), (/* 33 */
            /***/function (module, exports, __webpack_require__) {
              var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function (d, b) {
                  d.__proto__ = b;
                } || function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
                return function (d, b) {
                  extendStatics(d, b);
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
              }();
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var attributor_1 = __webpack_require__(12);
              function camelize(name) {
                var parts = name.split('-');
                var rest = parts.slice(1).map(function (part) {
                  return part[0].toUpperCase() + part.slice(1);
                }).join('');
                return parts[0] + rest;
              }
              var StyleAttributor = /** @class */function (_super) {
                __extends(StyleAttributor, _super);
                function StyleAttributor() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                StyleAttributor.keys = function (node) {
                  return (node.getAttribute('style') || '').split(';').map(function (value) {
                    var arr = value.split(':');
                    return arr[0].trim();
                  });
                };
                StyleAttributor.prototype.add = function (node, value) {
                  if (!this.canAdd(node, value)) return false;
                  // @ts-ignore
                  node.style[camelize(this.keyName)] = value;
                  return true;
                };
                StyleAttributor.prototype.remove = function (node) {
                  // @ts-ignore
                  node.style[camelize(this.keyName)] = '';
                  if (!node.getAttribute('style')) {
                    node.removeAttribute('style');
                  }
                };
                StyleAttributor.prototype.value = function (node) {
                  // @ts-ignore
                  var value = node.style[camelize(this.keyName)];
                  return this.canAdd(node, value) ? value : '';
                };
                return StyleAttributor;
              }(attributor_1.default);
              exports.default = StyleAttributor;

              /***/
            }), (/* 34 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var Theme = function () {
                function Theme(quill, options) {
                  _classCallCheck(this, Theme);
                  this.quill = quill;
                  this.options = options;
                  this.modules = {};
                }
                _createClass(Theme, [{
                  key: 'init',
                  value: function init() {
                    var _this = this;
                    Object.keys(this.options.modules).forEach(function (name) {
                      if (_this.modules[name] == null) {
                        _this.addModule(name);
                      }
                    });
                  }
                }, {
                  key: 'addModule',
                  value: function addModule(name) {
                    var moduleClass = this.quill.constructor.import('modules/' + name);
                    this.modules[name] = new moduleClass(this.quill, this.options.modules[name] || {});
                    return this.modules[name];
                  }
                }]);
                return Theme;
              }();
              Theme.DEFAULTS = {
                modules: {}
              };
              Theme.themes = {
                'default': Theme
              };
              exports.default = Theme;

              /***/
            }), (/* 35 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _text = __webpack_require__(7);
              var _text2 = _interopRequireDefault(_text);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var GUARD_TEXT = '\uFEFF';
              var Embed = function (_Parchment$Embed) {
                _inherits(Embed, _Parchment$Embed);
                function Embed(node) {
                  _classCallCheck(this, Embed);
                  var _this = _possibleConstructorReturn(this, (Embed.__proto__ || Object.getPrototypeOf(Embed)).call(this, node));
                  _this.contentNode = document.createElement('span');
                  _this.contentNode.setAttribute('contenteditable', false);
                  [].slice.call(_this.domNode.childNodes).forEach(function (childNode) {
                    _this.contentNode.appendChild(childNode);
                  });
                  _this.leftGuard = document.createTextNode(GUARD_TEXT);
                  _this.rightGuard = document.createTextNode(GUARD_TEXT);
                  _this.domNode.appendChild(_this.leftGuard);
                  _this.domNode.appendChild(_this.contentNode);
                  _this.domNode.appendChild(_this.rightGuard);
                  return _this;
                }
                _createClass(Embed, [{
                  key: 'index',
                  value: function index(node, offset) {
                    if (node === this.leftGuard) return 0;
                    if (node === this.rightGuard) return 1;
                    return _get(Embed.prototype.__proto__ || Object.getPrototypeOf(Embed.prototype), 'index', this).call(this, node, offset);
                  }
                }, {
                  key: 'restore',
                  value: function restore(node) {
                    var range = void 0,
                      textNode = void 0;
                    var text = node.data.split(GUARD_TEXT).join('');
                    if (node === this.leftGuard) {
                      if (this.prev instanceof _text2.default) {
                        var prevLength = this.prev.length();
                        this.prev.insertAt(prevLength, text);
                        range = {
                          startNode: this.prev.domNode,
                          startOffset: prevLength + text.length
                        };
                      } else {
                        textNode = document.createTextNode(text);
                        this.parent.insertBefore(_parchment2.default.create(textNode), this);
                        range = {
                          startNode: textNode,
                          startOffset: text.length
                        };
                      }
                    } else if (node === this.rightGuard) {
                      if (this.next instanceof _text2.default) {
                        this.next.insertAt(0, text);
                        range = {
                          startNode: this.next.domNode,
                          startOffset: text.length
                        };
                      } else {
                        textNode = document.createTextNode(text);
                        this.parent.insertBefore(_parchment2.default.create(textNode), this.next);
                        range = {
                          startNode: textNode,
                          startOffset: text.length
                        };
                      }
                    }
                    node.data = GUARD_TEXT;
                    return range;
                  }
                }, {
                  key: 'update',
                  value: function update(mutations, context) {
                    var _this2 = this;
                    mutations.forEach(function (mutation) {
                      if (mutation.type === 'characterData' && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {
                        var range = _this2.restore(mutation.target);
                        if (range) context.range = range;
                      }
                    });
                  }
                }]);
                return Embed;
              }(_parchment2.default.Embed);
              exports.default = Embed;

              /***/
            }), (/* 36 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.AlignStyle = exports.AlignClass = exports.AlignAttribute = undefined;
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              var config = {
                scope: _parchment2.default.Scope.BLOCK,
                whitelist: ['right', 'center', 'justify']
              };
              var AlignAttribute = new _parchment2.default.Attributor.Attribute('align', 'align', config);
              var AlignClass = new _parchment2.default.Attributor.Class('align', 'ql-align', config);
              var AlignStyle = new _parchment2.default.Attributor.Style('align', 'text-align', config);
              exports.AlignAttribute = AlignAttribute;
              exports.AlignClass = AlignClass;
              exports.AlignStyle = AlignStyle;

              /***/
            }), (/* 37 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.BackgroundStyle = exports.BackgroundClass = undefined;
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _color = __webpack_require__(26);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              var BackgroundClass = new _parchment2.default.Attributor.Class('background', 'ql-bg', {
                scope: _parchment2.default.Scope.INLINE
              });
              var BackgroundStyle = new _color.ColorAttributor('background', 'background-color', {
                scope: _parchment2.default.Scope.INLINE
              });
              exports.BackgroundClass = BackgroundClass;
              exports.BackgroundStyle = BackgroundStyle;

              /***/
            }), (/* 38 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.DirectionStyle = exports.DirectionClass = exports.DirectionAttribute = undefined;
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              var config = {
                scope: _parchment2.default.Scope.BLOCK,
                whitelist: ['rtl']
              };
              var DirectionAttribute = new _parchment2.default.Attributor.Attribute('direction', 'dir', config);
              var DirectionClass = new _parchment2.default.Attributor.Class('direction', 'ql-direction', config);
              var DirectionStyle = new _parchment2.default.Attributor.Style('direction', 'direction', config);
              exports.DirectionAttribute = DirectionAttribute;
              exports.DirectionClass = DirectionClass;
              exports.DirectionStyle = DirectionStyle;

              /***/
            }), (/* 39 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.FontClass = exports.FontStyle = undefined;
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var config = {
                scope: _parchment2.default.Scope.INLINE,
                whitelist: ['serif', 'monospace']
              };
              var FontClass = new _parchment2.default.Attributor.Class('font', 'ql-font', config);
              var FontStyleAttributor = function (_Parchment$Attributor) {
                _inherits(FontStyleAttributor, _Parchment$Attributor);
                function FontStyleAttributor() {
                  _classCallCheck(this, FontStyleAttributor);
                  return _possibleConstructorReturn(this, (FontStyleAttributor.__proto__ || Object.getPrototypeOf(FontStyleAttributor)).apply(this, arguments));
                }
                _createClass(FontStyleAttributor, [{
                  key: 'value',
                  value: function value(node) {
                    return _get(FontStyleAttributor.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor.prototype), 'value', this).call(this, node).replace(/["']/g, '');
                  }
                }]);
                return FontStyleAttributor;
              }(_parchment2.default.Attributor.Style);
              var FontStyle = new FontStyleAttributor('font', 'font-family', config);
              exports.FontStyle = FontStyle;
              exports.FontClass = FontClass;

              /***/
            }), (/* 40 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.SizeStyle = exports.SizeClass = undefined;
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              var SizeClass = new _parchment2.default.Attributor.Class('size', 'ql-size', {
                scope: _parchment2.default.Scope.INLINE,
                whitelist: ['small', 'large', 'huge']
              });
              var SizeStyle = new _parchment2.default.Attributor.Style('size', 'font-size', {
                scope: _parchment2.default.Scope.INLINE,
                whitelist: ['10px', '18px', '32px']
              });
              exports.SizeClass = SizeClass;
              exports.SizeStyle = SizeStyle;

              /***/
            }), (/* 41 */
            /***/function (module, exports, __webpack_require__) {
              module.exports = {
                'align': {
                  '': __webpack_require__(76),
                  'center': __webpack_require__(77),
                  'right': __webpack_require__(78),
                  'justify': __webpack_require__(79)
                },
                'background': __webpack_require__(80),
                'blockquote': __webpack_require__(81),
                'bold': __webpack_require__(82),
                'clean': __webpack_require__(83),
                'code': __webpack_require__(58),
                'code-block': __webpack_require__(58),
                'color': __webpack_require__(84),
                'direction': {
                  '': __webpack_require__(85),
                  'rtl': __webpack_require__(86)
                },
                'float': {
                  'center': __webpack_require__(87),
                  'full': __webpack_require__(88),
                  'left': __webpack_require__(89),
                  'right': __webpack_require__(90)
                },
                'formula': __webpack_require__(91),
                'header': {
                  '1': __webpack_require__(92),
                  '2': __webpack_require__(93)
                },
                'italic': __webpack_require__(94),
                'image': __webpack_require__(95),
                'indent': {
                  '+1': __webpack_require__(96),
                  '-1': __webpack_require__(97)
                },
                'link': __webpack_require__(98),
                'list': {
                  'ordered': __webpack_require__(99),
                  'bullet': __webpack_require__(100),
                  'check': __webpack_require__(101)
                },
                'script': {
                  'sub': __webpack_require__(102),
                  'super': __webpack_require__(103)
                },
                'strike': __webpack_require__(104),
                'underline': __webpack_require__(105),
                'video': __webpack_require__(106)
              };

              /***/
            }), (/* 42 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.getLastChangeIndex = exports.default = undefined;
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _quill = __webpack_require__(5);
              var _quill2 = _interopRequireDefault(_quill);
              var _module = __webpack_require__(9);
              var _module2 = _interopRequireDefault(_module);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var History = function (_Module) {
                _inherits(History, _Module);
                function History(quill, options) {
                  _classCallCheck(this, History);
                  var _this = _possibleConstructorReturn(this, (History.__proto__ || Object.getPrototypeOf(History)).call(this, quill, options));
                  _this.lastRecorded = 0;
                  _this.ignoreChange = false;
                  _this.clear();
                  _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (eventName, delta, oldDelta, source) {
                    if (eventName !== _quill2.default.events.TEXT_CHANGE || _this.ignoreChange) return;
                    if (!_this.options.userOnly || source === _quill2.default.sources.USER) {
                      _this.record(delta, oldDelta);
                    } else {
                      _this.transform(delta);
                    }
                  });
                  _this.quill.keyboard.addBinding({
                    key: 'Z',
                    shortKey: true
                  }, _this.undo.bind(_this));
                  _this.quill.keyboard.addBinding({
                    key: 'Z',
                    shortKey: true,
                    shiftKey: true
                  }, _this.redo.bind(_this));
                  if (/Win/i.test(navigator.platform)) {
                    _this.quill.keyboard.addBinding({
                      key: 'Y',
                      shortKey: true
                    }, _this.redo.bind(_this));
                  }
                  return _this;
                }
                _createClass(History, [{
                  key: 'change',
                  value: function change(source, dest) {
                    if (this.stack[source].length === 0) return;
                    var delta = this.stack[source].pop();
                    this.stack[dest].push(delta);
                    this.lastRecorded = 0;
                    this.ignoreChange = true;
                    this.quill.updateContents(delta[source], _quill2.default.sources.USER);
                    this.ignoreChange = false;
                    var index = getLastChangeIndex(delta[source]);
                    this.quill.setSelection(index);
                  }
                }, {
                  key: 'clear',
                  value: function clear() {
                    this.stack = {
                      undo: [],
                      redo: []
                    };
                  }
                }, {
                  key: 'cutoff',
                  value: function cutoff() {
                    this.lastRecorded = 0;
                  }
                }, {
                  key: 'record',
                  value: function record(changeDelta, oldDelta) {
                    if (changeDelta.ops.length === 0) return;
                    this.stack.redo = [];
                    var undoDelta = this.quill.getContents().diff(oldDelta);
                    var timestamp = Date.now();
                    if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {
                      var delta = this.stack.undo.pop();
                      undoDelta = undoDelta.compose(delta.undo);
                      changeDelta = delta.redo.compose(changeDelta);
                    } else {
                      this.lastRecorded = timestamp;
                    }
                    this.stack.undo.push({
                      redo: changeDelta,
                      undo: undoDelta
                    });
                    if (this.stack.undo.length > this.options.maxStack) {
                      this.stack.undo.shift();
                    }
                  }
                }, {
                  key: 'redo',
                  value: function redo() {
                    this.change('redo', 'undo');
                  }
                }, {
                  key: 'transform',
                  value: function transform(delta) {
                    this.stack.undo.forEach(function (change) {
                      change.undo = delta.transform(change.undo, true);
                      change.redo = delta.transform(change.redo, true);
                    });
                    this.stack.redo.forEach(function (change) {
                      change.undo = delta.transform(change.undo, true);
                      change.redo = delta.transform(change.redo, true);
                    });
                  }
                }, {
                  key: 'undo',
                  value: function undo() {
                    this.change('undo', 'redo');
                  }
                }]);
                return History;
              }(_module2.default);
              History.DEFAULTS = {
                delay: 1000,
                maxStack: 100,
                userOnly: false
              };
              function endsWithNewlineChange(delta) {
                var lastOp = delta.ops[delta.ops.length - 1];
                if (lastOp == null) return false;
                if (lastOp.insert != null) {
                  return typeof lastOp.insert === 'string' && lastOp.insert.endsWith('\n');
                }
                if (lastOp.attributes != null) {
                  return Object.keys(lastOp.attributes).some(function (attr) {
                    return _parchment2.default.query(attr, _parchment2.default.Scope.BLOCK) != null;
                  });
                }
                return false;
              }
              function getLastChangeIndex(delta) {
                var deleteLength = delta.reduce(function (length, op) {
                  length += op.delete || 0;
                  return length;
                }, 0);
                var changeIndex = delta.length() - deleteLength;
                if (endsWithNewlineChange(delta)) {
                  changeIndex -= 1;
                }
                return changeIndex;
              }
              exports.default = History;
              exports.getLastChangeIndex = getLastChangeIndex;

              /***/
            }), (/* 43 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.default = exports.BaseTooltip = undefined;
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _extend = __webpack_require__(3);
              var _extend2 = _interopRequireDefault(_extend);
              var _quillDelta = __webpack_require__(2);
              var _quillDelta2 = _interopRequireDefault(_quillDelta);
              var _emitter = __webpack_require__(8);
              var _emitter2 = _interopRequireDefault(_emitter);
              var _keyboard = __webpack_require__(23);
              var _keyboard2 = _interopRequireDefault(_keyboard);
              var _theme = __webpack_require__(34);
              var _theme2 = _interopRequireDefault(_theme);
              var _colorPicker = __webpack_require__(59);
              var _colorPicker2 = _interopRequireDefault(_colorPicker);
              var _iconPicker = __webpack_require__(60);
              var _iconPicker2 = _interopRequireDefault(_iconPicker);
              var _picker = __webpack_require__(28);
              var _picker2 = _interopRequireDefault(_picker);
              var _tooltip = __webpack_require__(61);
              var _tooltip2 = _interopRequireDefault(_tooltip);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var ALIGNS = [false, 'center', 'right', 'justify'];
              var COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];
              var FONTS = [false, 'serif', 'monospace'];
              var HEADERS = ['1', '2', '3', false];
              var SIZES = ['small', false, 'large', 'huge'];
              var BaseTheme = function (_Theme) {
                _inherits(BaseTheme, _Theme);
                function BaseTheme(quill, options) {
                  _classCallCheck(this, BaseTheme);
                  var _this = _possibleConstructorReturn(this, (BaseTheme.__proto__ || Object.getPrototypeOf(BaseTheme)).call(this, quill, options));
                  var listener = function listener(e) {
                    if (!document.body.contains(quill.root)) {
                      return document.body.removeEventListener('click', listener);
                    }
                    if (_this.tooltip != null && !_this.tooltip.root.contains(e.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {
                      _this.tooltip.hide();
                    }
                    if (_this.pickers != null) {
                      _this.pickers.forEach(function (picker) {
                        if (!picker.container.contains(e.target)) {
                          picker.close();
                        }
                      });
                    }
                  };
                  quill.emitter.listenDOM('click', document.body, listener);
                  return _this;
                }
                _createClass(BaseTheme, [{
                  key: 'addModule',
                  value: function addModule(name) {
                    var module = _get(BaseTheme.prototype.__proto__ || Object.getPrototypeOf(BaseTheme.prototype), 'addModule', this).call(this, name);
                    if (name === 'toolbar') {
                      this.extendToolbar(module);
                    }
                    return module;
                  }
                }, {
                  key: 'buildButtons',
                  value: function buildButtons(buttons, icons) {
                    buttons.forEach(function (button) {
                      var className = button.getAttribute('class') || '';
                      className.split(/\s+/).forEach(function (name) {
                        if (!name.startsWith('ql-')) return;
                        name = name.slice('ql-'.length);
                        if (icons[name] == null) return;
                        if (name === 'direction') {
                          button.innerHTML = icons[name][''] + icons[name]['rtl'];
                        } else if (typeof icons[name] === 'string') {
                          button.innerHTML = icons[name];
                        } else {
                          var value = button.value || '';
                          if (value != null && icons[name][value]) {
                            button.innerHTML = icons[name][value];
                          }
                        }
                      });
                    });
                  }
                }, {
                  key: 'buildPickers',
                  value: function buildPickers(selects, icons) {
                    var _this2 = this;
                    this.pickers = selects.map(function (select) {
                      if (select.classList.contains('ql-align')) {
                        if (select.querySelector('option') == null) {
                          fillSelect(select, ALIGNS);
                        }
                        return new _iconPicker2.default(select, icons.align);
                      } else if (select.classList.contains('ql-background') || select.classList.contains('ql-color')) {
                        var format = select.classList.contains('ql-background') ? 'background' : 'color';
                        if (select.querySelector('option') == null) {
                          fillSelect(select, COLORS, format === 'background' ? '#ffffff' : '#000000');
                        }
                        return new _colorPicker2.default(select, icons[format]);
                      } else {
                        if (select.querySelector('option') == null) {
                          if (select.classList.contains('ql-font')) {
                            fillSelect(select, FONTS);
                          } else if (select.classList.contains('ql-header')) {
                            fillSelect(select, HEADERS);
                          } else if (select.classList.contains('ql-size')) {
                            fillSelect(select, SIZES);
                          }
                        }
                        return new _picker2.default(select);
                      }
                    });
                    var update = function update() {
                      _this2.pickers.forEach(function (picker) {
                        picker.update();
                      });
                    };
                    this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update);
                  }
                }]);
                return BaseTheme;
              }(_theme2.default);
              BaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {
                modules: {
                  toolbar: {
                    handlers: {
                      formula: function formula() {
                        this.quill.theme.tooltip.edit('formula');
                      },
                      image: function image() {
                        var _this3 = this;
                        var fileInput = this.container.querySelector('input.ql-image[type=file]');
                        if (fileInput == null) {
                          fileInput = document.createElement('input');
                          fileInput.setAttribute('type', 'file');
                          fileInput.setAttribute('accept', 'image/png, image/gif, image/jpeg, image/bmp, image/x-icon');
                          fileInput.classList.add('ql-image');
                          fileInput.addEventListener('change', function () {
                            if (fileInput.files != null && fileInput.files[0] != null) {
                              var reader = new FileReader();
                              reader.onload = function (e) {
                                var range = _this3.quill.getSelection(true);
                                _this3.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert({
                                  image: e.target.result
                                }), _emitter2.default.sources.USER);
                                _this3.quill.setSelection(range.index + 1, _emitter2.default.sources.SILENT);
                                fileInput.value = "";
                              };
                              reader.readAsDataURL(fileInput.files[0]);
                            }
                          });
                          this.container.appendChild(fileInput);
                        }
                        fileInput.click();
                      },
                      video: function video() {
                        this.quill.theme.tooltip.edit('video');
                      }
                    }
                  }
                }
              });
              var BaseTooltip = function (_Tooltip) {
                _inherits(BaseTooltip, _Tooltip);
                function BaseTooltip(quill, boundsContainer) {
                  _classCallCheck(this, BaseTooltip);
                  var _this4 = _possibleConstructorReturn(this, (BaseTooltip.__proto__ || Object.getPrototypeOf(BaseTooltip)).call(this, quill, boundsContainer));
                  _this4.textbox = _this4.root.querySelector('input[type="text"]');
                  _this4.listen();
                  return _this4;
                }
                _createClass(BaseTooltip, [{
                  key: 'listen',
                  value: function listen() {
                    var _this5 = this;
                    this.textbox.addEventListener('keydown', function (event) {
                      if (_keyboard2.default.match(event, 'enter')) {
                        _this5.save();
                        event.preventDefault();
                      } else if (_keyboard2.default.match(event, 'escape')) {
                        _this5.cancel();
                        event.preventDefault();
                      }
                    });
                  }
                }, {
                  key: 'cancel',
                  value: function cancel() {
                    this.hide();
                  }
                }, {
                  key: 'edit',
                  value: function edit() {
                    var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'link';
                    var preview = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                    this.root.classList.remove('ql-hidden');
                    this.root.classList.add('ql-editing');
                    if (preview != null) {
                      this.textbox.value = preview;
                    } else if (mode !== this.root.getAttribute('data-mode')) {
                      this.textbox.value = '';
                    }
                    this.position(this.quill.getBounds(this.quill.selection.savedRange));
                    this.textbox.select();
                    this.textbox.setAttribute('placeholder', this.textbox.getAttribute('data-' + mode) || '');
                    this.root.setAttribute('data-mode', mode);
                  }
                }, {
                  key: 'restoreFocus',
                  value: function restoreFocus() {
                    var scrollTop = this.quill.scrollingContainer.scrollTop;
                    this.quill.focus();
                    this.quill.scrollingContainer.scrollTop = scrollTop;
                  }
                }, {
                  key: 'save',
                  value: function save() {
                    var value = this.textbox.value;
                    switch (this.root.getAttribute('data-mode')) {
                      case 'link':
                        {
                          var scrollTop = this.quill.root.scrollTop;
                          if (this.linkRange) {
                            this.quill.formatText(this.linkRange, 'link', value, _emitter2.default.sources.USER);
                            delete this.linkRange;
                          } else {
                            this.restoreFocus();
                            this.quill.format('link', value, _emitter2.default.sources.USER);
                          }
                          this.quill.root.scrollTop = scrollTop;
                          break;
                        }
                      case 'video':
                        {
                          value = extractVideoUrl(value);
                        }
                      // eslint-disable-next-line no-fallthrough
                      case 'formula':
                        {
                          if (!value) break;
                          var range = this.quill.getSelection(true);
                          if (range != null) {
                            var index = range.index + range.length;
                            this.quill.insertEmbed(index, this.root.getAttribute('data-mode'), value, _emitter2.default.sources.USER);
                            if (this.root.getAttribute('data-mode') === 'formula') {
                              this.quill.insertText(index + 1, ' ', _emitter2.default.sources.USER);
                            }
                            this.quill.setSelection(index + 2, _emitter2.default.sources.USER);
                          }
                          break;
                        }
                    }
                    this.textbox.value = '';
                    this.hide();
                  }
                }]);
                return BaseTooltip;
              }(_tooltip2.default);
              function extractVideoUrl(url) {
                var match = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
                if (match) {
                  return (match[1] || 'https') + '://www.youtube.com/embed/' + match[2] + '?showinfo=0';
                }
                if (match = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
                  // eslint-disable-line no-cond-assign
                  return (match[1] || 'https') + '://player.vimeo.com/video/' + match[2] + '/';
                }
                return url;
              }
              function fillSelect(select, values) {
                var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                values.forEach(function (value) {
                  var option = document.createElement('option');
                  if (value === defaultValue) {
                    option.setAttribute('selected', 'selected');
                  } else {
                    option.setAttribute('value', value);
                  }
                  select.appendChild(option);
                });
              }
              exports.BaseTooltip = BaseTooltip;
              exports.default = BaseTheme;

              /***/
            }), (/* 44 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var LinkedList = /** @class */function () {
                function LinkedList() {
                  this.head = this.tail = null;
                  this.length = 0;
                }
                LinkedList.prototype.append = function () {
                  var nodes = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    nodes[_i] = arguments[_i];
                  }
                  this.insertBefore(nodes[0], null);
                  if (nodes.length > 1) {
                    this.append.apply(this, nodes.slice(1));
                  }
                };
                LinkedList.prototype.contains = function (node) {
                  var cur,
                    next = this.iterator();
                  while (cur = next()) {
                    if (cur === node) return true;
                  }
                  return false;
                };
                LinkedList.prototype.insertBefore = function (node, refNode) {
                  if (!node) return;
                  node.next = refNode;
                  if (refNode != null) {
                    node.prev = refNode.prev;
                    if (refNode.prev != null) {
                      refNode.prev.next = node;
                    }
                    refNode.prev = node;
                    if (refNode === this.head) {
                      this.head = node;
                    }
                  } else if (this.tail != null) {
                    this.tail.next = node;
                    node.prev = this.tail;
                    this.tail = node;
                  } else {
                    node.prev = null;
                    this.head = this.tail = node;
                  }
                  this.length += 1;
                };
                LinkedList.prototype.offset = function (target) {
                  var index = 0,
                    cur = this.head;
                  while (cur != null) {
                    if (cur === target) return index;
                    index += cur.length();
                    cur = cur.next;
                  }
                  return -1;
                };
                LinkedList.prototype.remove = function (node) {
                  if (!this.contains(node)) return;
                  if (node.prev != null) node.prev.next = node.next;
                  if (node.next != null) node.next.prev = node.prev;
                  if (node === this.head) this.head = node.next;
                  if (node === this.tail) this.tail = node.prev;
                  this.length -= 1;
                };
                LinkedList.prototype.iterator = function (curNode) {
                  if (curNode === void 0) {
                    curNode = this.head;
                  }
                  // TODO use yield when we can
                  return function () {
                    var ret = curNode;
                    if (curNode != null) curNode = curNode.next;
                    return ret;
                  };
                };
                LinkedList.prototype.find = function (index, inclusive) {
                  if (inclusive === void 0) {
                    inclusive = false;
                  }
                  var cur,
                    next = this.iterator();
                  while (cur = next()) {
                    var length = cur.length();
                    if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0)) {
                      return [cur, index];
                    }
                    index -= length;
                  }
                  return [null, 0];
                };
                LinkedList.prototype.forEach = function (callback) {
                  var cur,
                    next = this.iterator();
                  while (cur = next()) {
                    callback(cur);
                  }
                };
                LinkedList.prototype.forEachAt = function (index, length, callback) {
                  if (length <= 0) return;
                  var _a = this.find(index),
                    startNode = _a[0],
                    offset = _a[1];
                  var cur,
                    curIndex = index - offset,
                    next = this.iterator(startNode);
                  while ((cur = next()) && curIndex < index + length) {
                    var curLength = cur.length();
                    if (index > curIndex) {
                      callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));
                    } else {
                      callback(cur, 0, Math.min(curLength, index + length - curIndex));
                    }
                    curIndex += curLength;
                  }
                };
                LinkedList.prototype.map = function (callback) {
                  return this.reduce(function (memo, cur) {
                    memo.push(callback(cur));
                    return memo;
                  }, []);
                };
                LinkedList.prototype.reduce = function (callback, memo) {
                  var cur,
                    next = this.iterator();
                  while (cur = next()) {
                    memo = callback(memo, cur);
                  }
                  return memo;
                };
                return LinkedList;
              }();
              exports.default = LinkedList;

              /***/
            }), (/* 45 */
            /***/function (module, exports, __webpack_require__) {
              var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function (d, b) {
                  d.__proto__ = b;
                } || function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
                return function (d, b) {
                  extendStatics(d, b);
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
              }();
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var container_1 = __webpack_require__(17);
              var Registry = __webpack_require__(1);
              var OBSERVER_CONFIG = {
                attributes: true,
                characterData: true,
                characterDataOldValue: true,
                childList: true,
                subtree: true
              };
              var MAX_OPTIMIZE_ITERATIONS = 100;
              var ScrollBlot = /** @class */function (_super) {
                __extends(ScrollBlot, _super);
                function ScrollBlot(node) {
                  var _this = _super.call(this, node) || this;
                  _this.scroll = _this;
                  _this.observer = new MutationObserver(function (mutations) {
                    _this.update(mutations);
                  });
                  _this.observer.observe(_this.domNode, OBSERVER_CONFIG);
                  _this.attach();
                  return _this;
                }
                ScrollBlot.prototype.detach = function () {
                  _super.prototype.detach.call(this);
                  this.observer.disconnect();
                };
                ScrollBlot.prototype.deleteAt = function (index, length) {
                  this.update();
                  if (index === 0 && length === this.length()) {
                    this.children.forEach(function (child) {
                      child.remove();
                    });
                  } else {
                    _super.prototype.deleteAt.call(this, index, length);
                  }
                };
                ScrollBlot.prototype.formatAt = function (index, length, name, value) {
                  this.update();
                  _super.prototype.formatAt.call(this, index, length, name, value);
                };
                ScrollBlot.prototype.insertAt = function (index, value, def) {
                  this.update();
                  _super.prototype.insertAt.call(this, index, value, def);
                };
                ScrollBlot.prototype.optimize = function (mutations, context) {
                  var _this = this;
                  if (mutations === void 0) {
                    mutations = [];
                  }
                  if (context === void 0) {
                    context = {};
                  }
                  _super.prototype.optimize.call(this, context);
                  // We must modify mutations directly, cannot make copy and then modify
                  var records = [].slice.call(this.observer.takeRecords());
                  // Array.push currently seems to be implemented by a non-tail recursive function
                  // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());
                  while (records.length > 0) mutations.push(records.pop());
                  // TODO use WeakMap
                  var _mark = function mark(blot, markParent) {
                    if (markParent === void 0) {
                      markParent = true;
                    }
                    if (blot == null || blot === _this) return;
                    if (blot.domNode.parentNode == null) return;
                    // @ts-ignore
                    if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                      // @ts-ignore
                      blot.domNode[Registry.DATA_KEY].mutations = [];
                    }
                    if (markParent) _mark(blot.parent);
                  };
                  var _optimize = function optimize(blot) {
                    // Post-order traversal
                    if (
                    // @ts-ignore
                    blot.domNode[Registry.DATA_KEY] == null ||
                    // @ts-ignore
                    blot.domNode[Registry.DATA_KEY].mutations == null) {
                      return;
                    }
                    if (blot instanceof container_1.default) {
                      blot.children.forEach(_optimize);
                    }
                    blot.optimize(context);
                  };
                  var remaining = mutations;
                  for (var i = 0; remaining.length > 0; i += 1) {
                    if (i >= MAX_OPTIMIZE_ITERATIONS) {
                      throw new Error('[Parchment] Maximum optimize iterations reached');
                    }
                    remaining.forEach(function (mutation) {
                      var blot = Registry.find(mutation.target, true);
                      if (blot == null) return;
                      if (blot.domNode === mutation.target) {
                        if (mutation.type === 'childList') {
                          _mark(Registry.find(mutation.previousSibling, false));
                          [].forEach.call(mutation.addedNodes, function (node) {
                            var child = Registry.find(node, false);
                            _mark(child, false);
                            if (child instanceof container_1.default) {
                              child.children.forEach(function (grandChild) {
                                _mark(grandChild, false);
                              });
                            }
                          });
                        } else if (mutation.type === 'attributes') {
                          _mark(blot.prev);
                        }
                      }
                      _mark(blot);
                    });
                    this.children.forEach(_optimize);
                    remaining = [].slice.call(this.observer.takeRecords());
                    records = remaining.slice();
                    while (records.length > 0) mutations.push(records.pop());
                  }
                };
                ScrollBlot.prototype.update = function (mutations, context) {
                  var _this = this;
                  if (context === void 0) {
                    context = {};
                  }
                  mutations = mutations || this.observer.takeRecords();
                  // TODO use WeakMap
                  mutations.map(function (mutation) {
                    var blot = Registry.find(mutation.target, true);
                    if (blot == null) return null;
                    // @ts-ignore
                    if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                      // @ts-ignore
                      blot.domNode[Registry.DATA_KEY].mutations = [mutation];
                      return blot;
                    } else {
                      // @ts-ignore
                      blot.domNode[Registry.DATA_KEY].mutations.push(mutation);
                      return null;
                    }
                  }).forEach(function (blot) {
                    if (blot == null || blot === _this ||
                    //@ts-ignore
                    blot.domNode[Registry.DATA_KEY] == null) return;
                    // @ts-ignore
                    blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context);
                  });
                  // @ts-ignore
                  if (this.domNode[Registry.DATA_KEY].mutations != null) {
                    // @ts-ignore
                    _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context);
                  }
                  this.optimize(mutations, context);
                };
                ScrollBlot.blotName = 'scroll';
                ScrollBlot.defaultChild = 'block';
                ScrollBlot.scope = Registry.Scope.BLOCK_BLOT;
                ScrollBlot.tagName = 'DIV';
                return ScrollBlot;
              }(container_1.default);
              exports.default = ScrollBlot;

              /***/
            }), (/* 46 */
            /***/function (module, exports, __webpack_require__) {
              var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function (d, b) {
                  d.__proto__ = b;
                } || function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
                return function (d, b) {
                  extendStatics(d, b);
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
              }();
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var format_1 = __webpack_require__(18);
              var Registry = __webpack_require__(1);
              // Shallow object comparison
              function isEqual(obj1, obj2) {
                if (Object.keys(obj1).length !== Object.keys(obj2).length) return false;
                // @ts-ignore
                for (var prop in obj1) {
                  // @ts-ignore
                  if (obj1[prop] !== obj2[prop]) return false;
                }
                return true;
              }
              var InlineBlot = /** @class */function (_super) {
                __extends(InlineBlot, _super);
                function InlineBlot() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                InlineBlot.formats = function (domNode) {
                  if (domNode.tagName === InlineBlot.tagName) return undefined;
                  return _super.formats.call(this, domNode);
                };
                InlineBlot.prototype.format = function (name, value) {
                  var _this = this;
                  if (name === this.statics.blotName && !value) {
                    this.children.forEach(function (child) {
                      if (!(child instanceof format_1.default)) {
                        child = child.wrap(InlineBlot.blotName, true);
                      }
                      _this.attributes.copy(child);
                    });
                    this.unwrap();
                  } else {
                    _super.prototype.format.call(this, name, value);
                  }
                };
                InlineBlot.prototype.formatAt = function (index, length, name, value) {
                  if (this.formats()[name] != null || Registry.query(name, Registry.Scope.ATTRIBUTE)) {
                    var blot = this.isolate(index, length);
                    blot.format(name, value);
                  } else {
                    _super.prototype.formatAt.call(this, index, length, name, value);
                  }
                };
                InlineBlot.prototype.optimize = function (context) {
                  _super.prototype.optimize.call(this, context);
                  var formats = this.formats();
                  if (Object.keys(formats).length === 0) {
                    return this.unwrap(); // unformatted span
                  }
                  var next = this.next;
                  if (next instanceof InlineBlot && next.prev === this && isEqual(formats, next.formats())) {
                    next.moveChildren(this);
                    next.remove();
                  }
                };
                InlineBlot.blotName = 'inline';
                InlineBlot.scope = Registry.Scope.INLINE_BLOT;
                InlineBlot.tagName = 'SPAN';
                return InlineBlot;
              }(format_1.default);
              exports.default = InlineBlot;

              /***/
            }), (/* 47 */
            /***/function (module, exports, __webpack_require__) {
              var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function (d, b) {
                  d.__proto__ = b;
                } || function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
                return function (d, b) {
                  extendStatics(d, b);
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
              }();
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var format_1 = __webpack_require__(18);
              var Registry = __webpack_require__(1);
              var BlockBlot = /** @class */function (_super) {
                __extends(BlockBlot, _super);
                function BlockBlot() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                BlockBlot.formats = function (domNode) {
                  var tagName = Registry.query(BlockBlot.blotName).tagName;
                  if (domNode.tagName === tagName) return undefined;
                  return _super.formats.call(this, domNode);
                };
                BlockBlot.prototype.format = function (name, value) {
                  if (Registry.query(name, Registry.Scope.BLOCK) == null) {
                    return;
                  } else if (name === this.statics.blotName && !value) {
                    this.replaceWith(BlockBlot.blotName);
                  } else {
                    _super.prototype.format.call(this, name, value);
                  }
                };
                BlockBlot.prototype.formatAt = function (index, length, name, value) {
                  if (Registry.query(name, Registry.Scope.BLOCK) != null) {
                    this.format(name, value);
                  } else {
                    _super.prototype.formatAt.call(this, index, length, name, value);
                  }
                };
                BlockBlot.prototype.insertAt = function (index, value, def) {
                  if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {
                    // Insert text or inline
                    _super.prototype.insertAt.call(this, index, value, def);
                  } else {
                    var after = this.split(index);
                    var blot = Registry.create(value, def);
                    after.parent.insertBefore(blot, after);
                  }
                };
                BlockBlot.prototype.update = function (mutations, context) {
                  if (navigator.userAgent.match(/Trident/)) {
                    this.build();
                  } else {
                    _super.prototype.update.call(this, mutations, context);
                  }
                };
                BlockBlot.blotName = 'block';
                BlockBlot.scope = Registry.Scope.BLOCK_BLOT;
                BlockBlot.tagName = 'P';
                return BlockBlot;
              }(format_1.default);
              exports.default = BlockBlot;

              /***/
            }), (/* 48 */
            /***/function (module, exports, __webpack_require__) {
              var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function (d, b) {
                  d.__proto__ = b;
                } || function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
                return function (d, b) {
                  extendStatics(d, b);
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
              }();
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var leaf_1 = __webpack_require__(19);
              var EmbedBlot = /** @class */function (_super) {
                __extends(EmbedBlot, _super);
                function EmbedBlot() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                EmbedBlot.formats = function (domNode) {
                  return undefined;
                };
                EmbedBlot.prototype.format = function (name, value) {
                  // super.formatAt wraps, which is what we want in general,
                  // but this allows subclasses to overwrite for formats
                  // that just apply to particular embeds
                  _super.prototype.formatAt.call(this, 0, this.length(), name, value);
                };
                EmbedBlot.prototype.formatAt = function (index, length, name, value) {
                  if (index === 0 && length === this.length()) {
                    this.format(name, value);
                  } else {
                    _super.prototype.formatAt.call(this, index, length, name, value);
                  }
                };
                EmbedBlot.prototype.formats = function () {
                  return this.statics.formats(this.domNode);
                };
                return EmbedBlot;
              }(leaf_1.default);
              exports.default = EmbedBlot;

              /***/
            }), (/* 49 */
            /***/function (module, exports, __webpack_require__) {
              var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function (d, b) {
                  d.__proto__ = b;
                } || function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
                return function (d, b) {
                  extendStatics(d, b);
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
              }();
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var leaf_1 = __webpack_require__(19);
              var Registry = __webpack_require__(1);
              var TextBlot = /** @class */function (_super) {
                __extends(TextBlot, _super);
                function TextBlot(node) {
                  var _this = _super.call(this, node) || this;
                  _this.text = _this.statics.value(_this.domNode);
                  return _this;
                }
                TextBlot.create = function (value) {
                  return document.createTextNode(value);
                };
                TextBlot.value = function (domNode) {
                  var text = domNode.data;
                  // @ts-ignore
                  if (text['normalize']) text = text['normalize']();
                  return text;
                };
                TextBlot.prototype.deleteAt = function (index, length) {
                  this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);
                };
                TextBlot.prototype.index = function (node, offset) {
                  if (this.domNode === node) {
                    return offset;
                  }
                  return -1;
                };
                TextBlot.prototype.insertAt = function (index, value, def) {
                  if (def == null) {
                    this.text = this.text.slice(0, index) + value + this.text.slice(index);
                    this.domNode.data = this.text;
                  } else {
                    _super.prototype.insertAt.call(this, index, value, def);
                  }
                };
                TextBlot.prototype.length = function () {
                  return this.text.length;
                };
                TextBlot.prototype.optimize = function (context) {
                  _super.prototype.optimize.call(this, context);
                  this.text = this.statics.value(this.domNode);
                  if (this.text.length === 0) {
                    this.remove();
                  } else if (this.next instanceof TextBlot && this.next.prev === this) {
                    this.insertAt(this.length(), this.next.value());
                    this.next.remove();
                  }
                };
                TextBlot.prototype.position = function (index, inclusive) {
                  return [this.domNode, index];
                };
                TextBlot.prototype.split = function (index, force) {
                  if (force === void 0) {
                    force = false;
                  }
                  if (!force) {
                    if (index === 0) return this;
                    if (index === this.length()) return this.next;
                  }
                  var after = Registry.create(this.domNode.splitText(index));
                  this.parent.insertBefore(after, this.next);
                  this.text = this.statics.value(this.domNode);
                  return after;
                };
                TextBlot.prototype.update = function (mutations, context) {
                  var _this = this;
                  if (mutations.some(function (mutation) {
                    return mutation.type === 'characterData' && mutation.target === _this.domNode;
                  })) {
                    this.text = this.statics.value(this.domNode);
                  }
                };
                TextBlot.prototype.value = function () {
                  return this.text;
                };
                TextBlot.blotName = 'text';
                TextBlot.scope = Registry.Scope.INLINE_BLOT;
                return TextBlot;
              }(leaf_1.default);
              exports.default = TextBlot;

              /***/
            }), (/* 50 */
            /***/function (module, exports, __webpack_require__) {
              var elem = document.createElement('div');
              elem.classList.toggle('test-class', false);
              if (elem.classList.contains('test-class')) {
                var _toggle = DOMTokenList.prototype.toggle;
                DOMTokenList.prototype.toggle = function (token, force) {
                  if (arguments.length > 1 && !this.contains(token) === !force) {
                    return force;
                  } else {
                    return _toggle.call(this, token);
                  }
                };
              }
              if (!String.prototype.startsWith) {
                String.prototype.startsWith = function (searchString, position) {
                  position = position || 0;
                  return this.substr(position, searchString.length) === searchString;
                };
              }
              if (!String.prototype.endsWith) {
                String.prototype.endsWith = function (searchString, position) {
                  var subjectString = this.toString();
                  if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
                    position = subjectString.length;
                  }
                  position -= searchString.length;
                  var lastIndex = subjectString.indexOf(searchString, position);
                  return lastIndex !== -1 && lastIndex === position;
                };
              }
              if (!Array.prototype.find) {
                Object.defineProperty(Array.prototype, "find", {
                  value: function value(predicate) {
                    if (this === null) {
                      throw new TypeError('Array.prototype.find called on null or undefined');
                    }
                    if (typeof predicate !== 'function') {
                      throw new TypeError('predicate must be a function');
                    }
                    var list = Object(this);
                    var length = list.length >>> 0;
                    var thisArg = arguments[1];
                    var value;
                    for (var i = 0; i < length; i++) {
                      value = list[i];
                      if (predicate.call(thisArg, value, i, list)) {
                        return value;
                      }
                    }
                    return undefined;
                  }
                });
              }
              document.addEventListener("DOMContentLoaded", function () {
                // Disable resizing in Firefox
                document.execCommand("enableObjectResizing", false, false);
                // Disable automatic linkifying in IE11
                document.execCommand("autoUrlDetect", false, false);
              });

              /***/
            }), (/* 51 */
            /***/function (module, exports) {
              /**
               * This library modifies the diff-patch-match library by Neil Fraser
               * by removing the patch and match functionality and certain advanced
               * options in the diff function. The original license is as follows:
               *
               * ===
               *
               * Diff Match and Patch
               *
               * Copyright 2006 Google Inc.
               * http://code.google.com/p/google-diff-match-patch/
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *   http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */

              /**
               * The data structure representing a diff is an array of tuples:
               * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
               * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
               */
              var DIFF_DELETE = -1;
              var DIFF_INSERT = 1;
              var DIFF_EQUAL = 0;

              /**
               * Find the differences between two texts.  Simplifies the problem by stripping
               * any common prefix or suffix off the texts before diffing.
               * @param {string} text1 Old string to be diffed.
               * @param {string} text2 New string to be diffed.
               * @param {Int} cursor_pos Expected edit position in text1 (optional)
               * @return {Array} Array of diff tuples.
               */
              function diff_main(text1, text2, cursor_pos) {
                // Check for equality (speedup).
                if (text1 == text2) {
                  if (text1) {
                    return [[DIFF_EQUAL, text1]];
                  }
                  return [];
                }

                // Check cursor_pos within bounds
                if (cursor_pos < 0 || text1.length < cursor_pos) {
                  cursor_pos = null;
                }

                // Trim off common prefix (speedup).
                var commonlength = diff_commonPrefix(text1, text2);
                var commonprefix = text1.substring(0, commonlength);
                text1 = text1.substring(commonlength);
                text2 = text2.substring(commonlength);

                // Trim off common suffix (speedup).
                commonlength = diff_commonSuffix(text1, text2);
                var commonsuffix = text1.substring(text1.length - commonlength);
                text1 = text1.substring(0, text1.length - commonlength);
                text2 = text2.substring(0, text2.length - commonlength);

                // Compute the diff on the middle block.
                var diffs = diff_compute_(text1, text2);

                // Restore the prefix and suffix.
                if (commonprefix) {
                  diffs.unshift([DIFF_EQUAL, commonprefix]);
                }
                if (commonsuffix) {
                  diffs.push([DIFF_EQUAL, commonsuffix]);
                }
                diff_cleanupMerge(diffs);
                if (cursor_pos != null) {
                  diffs = fix_cursor(diffs, cursor_pos);
                }
                diffs = fix_emoji(diffs);
                return diffs;
              }

              /**
               * Find the differences between two texts.  Assumes that the texts do not
               * have any common prefix or suffix.
               * @param {string} text1 Old string to be diffed.
               * @param {string} text2 New string to be diffed.
               * @return {Array} Array of diff tuples.
               */
              function diff_compute_(text1, text2) {
                var diffs;
                if (!text1) {
                  // Just add some text (speedup).
                  return [[DIFF_INSERT, text2]];
                }
                if (!text2) {
                  // Just delete some text (speedup).
                  return [[DIFF_DELETE, text1]];
                }
                var longtext = text1.length > text2.length ? text1 : text2;
                var shorttext = text1.length > text2.length ? text2 : text1;
                var i = longtext.indexOf(shorttext);
                if (i != -1) {
                  // Shorter text is inside the longer text (speedup).
                  diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
                  // Swap insertions for deletions if diff is reversed.
                  if (text1.length > text2.length) {
                    diffs[0][0] = diffs[2][0] = DIFF_DELETE;
                  }
                  return diffs;
                }
                if (shorttext.length == 1) {
                  // Single character string.
                  // After the previous speedup, the character can't be an equality.
                  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
                }

                // Check to see if the problem can be split in two.
                var hm = diff_halfMatch_(text1, text2);
                if (hm) {
                  // A half-match was found, sort out the return data.
                  var text1_a = hm[0];
                  var text1_b = hm[1];
                  var text2_a = hm[2];
                  var text2_b = hm[3];
                  var mid_common = hm[4];
                  // Send both pairs off for separate processing.
                  var diffs_a = diff_main(text1_a, text2_a);
                  var diffs_b = diff_main(text1_b, text2_b);
                  // Merge the results.
                  return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
                }
                return diff_bisect_(text1, text2);
              }

              /**
               * Find the 'middle snake' of a diff, split the problem in two
               * and return the recursively constructed diff.
               * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
               * @param {string} text1 Old string to be diffed.
               * @param {string} text2 New string to be diffed.
               * @return {Array} Array of diff tuples.
               * @private
               */
              function diff_bisect_(text1, text2) {
                // Cache the text lengths to prevent multiple calls.
                var text1_length = text1.length;
                var text2_length = text2.length;
                var max_d = Math.ceil((text1_length + text2_length) / 2);
                var v_offset = max_d;
                var v_length = 2 * max_d;
                var v1 = new Array(v_length);
                var v2 = new Array(v_length);
                // Setting all elements to -1 is faster in Chrome & Firefox than mixing
                // integers and undefined.
                for (var x = 0; x < v_length; x++) {
                  v1[x] = -1;
                  v2[x] = -1;
                }
                v1[v_offset + 1] = 0;
                v2[v_offset + 1] = 0;
                var delta = text1_length - text2_length;
                // If the total number of characters is odd, then the front path will collide
                // with the reverse path.
                var front = delta % 2 != 0;
                // Offsets for start and end of k loop.
                // Prevents mapping of space beyond the grid.
                var k1start = 0;
                var k1end = 0;
                var k2start = 0;
                var k2end = 0;
                for (var d = 0; d < max_d; d++) {
                  // Walk the front path one step.
                  for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
                    var k1_offset = v_offset + k1;
                    var x1;
                    if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
                      x1 = v1[k1_offset + 1];
                    } else {
                      x1 = v1[k1_offset - 1] + 1;
                    }
                    var y1 = x1 - k1;
                    while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
                      x1++;
                      y1++;
                    }
                    v1[k1_offset] = x1;
                    if (x1 > text1_length) {
                      // Ran off the right of the graph.
                      k1end += 2;
                    } else if (y1 > text2_length) {
                      // Ran off the bottom of the graph.
                      k1start += 2;
                    } else if (front) {
                      var k2_offset = v_offset + delta - k1;
                      if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
                        // Mirror x2 onto top-left coordinate system.
                        var x2 = text1_length - v2[k2_offset];
                        if (x1 >= x2) {
                          // Overlap detected.
                          return diff_bisectSplit_(text1, text2, x1, y1);
                        }
                      }
                    }
                  }

                  // Walk the reverse path one step.
                  for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
                    var k2_offset = v_offset + k2;
                    var x2;
                    if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
                      x2 = v2[k2_offset + 1];
                    } else {
                      x2 = v2[k2_offset - 1] + 1;
                    }
                    var y2 = x2 - k2;
                    while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
                      x2++;
                      y2++;
                    }
                    v2[k2_offset] = x2;
                    if (x2 > text1_length) {
                      // Ran off the left of the graph.
                      k2end += 2;
                    } else if (y2 > text2_length) {
                      // Ran off the top of the graph.
                      k2start += 2;
                    } else if (!front) {
                      var k1_offset = v_offset + delta - k2;
                      if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                        var x1 = v1[k1_offset];
                        var y1 = v_offset + x1 - k1_offset;
                        // Mirror x2 onto top-left coordinate system.
                        x2 = text1_length - x2;
                        if (x1 >= x2) {
                          // Overlap detected.
                          return diff_bisectSplit_(text1, text2, x1, y1);
                        }
                      }
                    }
                  }
                }
                // Diff took too long and hit the deadline or
                // number of diffs equals number of characters, no commonality at all.
                return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
              }

              /**
               * Given the location of the 'middle snake', split the diff in two parts
               * and recurse.
               * @param {string} text1 Old string to be diffed.
               * @param {string} text2 New string to be diffed.
               * @param {number} x Index of split point in text1.
               * @param {number} y Index of split point in text2.
               * @return {Array} Array of diff tuples.
               */
              function diff_bisectSplit_(text1, text2, x, y) {
                var text1a = text1.substring(0, x);
                var text2a = text2.substring(0, y);
                var text1b = text1.substring(x);
                var text2b = text2.substring(y);

                // Compute both diffs serially.
                var diffs = diff_main(text1a, text2a);
                var diffsb = diff_main(text1b, text2b);
                return diffs.concat(diffsb);
              }

              /**
               * Determine the common prefix of two strings.
               * @param {string} text1 First string.
               * @param {string} text2 Second string.
               * @return {number} The number of characters common to the start of each
               *     string.
               */
              function diff_commonPrefix(text1, text2) {
                // Quick check for common null cases.
                if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
                  return 0;
                }
                // Binary search.
                // Performance analysis: http://neil.fraser.name/news/2007/10/09/
                var pointermin = 0;
                var pointermax = Math.min(text1.length, text2.length);
                var pointermid = pointermax;
                var pointerstart = 0;
                while (pointermin < pointermid) {
                  if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
                    pointermin = pointermid;
                    pointerstart = pointermin;
                  } else {
                    pointermax = pointermid;
                  }
                  pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
                }
                return pointermid;
              }

              /**
               * Determine the common suffix of two strings.
               * @param {string} text1 First string.
               * @param {string} text2 Second string.
               * @return {number} The number of characters common to the end of each string.
               */
              function diff_commonSuffix(text1, text2) {
                // Quick check for common null cases.
                if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
                  return 0;
                }
                // Binary search.
                // Performance analysis: http://neil.fraser.name/news/2007/10/09/
                var pointermin = 0;
                var pointermax = Math.min(text1.length, text2.length);
                var pointermid = pointermax;
                var pointerend = 0;
                while (pointermin < pointermid) {
                  if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
                    pointermin = pointermid;
                    pointerend = pointermin;
                  } else {
                    pointermax = pointermid;
                  }
                  pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
                }
                return pointermid;
              }

              /**
               * Do the two texts share a substring which is at least half the length of the
               * longer text?
               * This speedup can produce non-minimal diffs.
               * @param {string} text1 First string.
               * @param {string} text2 Second string.
               * @return {Array.<string>} Five element Array, containing the prefix of
               *     text1, the suffix of text1, the prefix of text2, the suffix of
               *     text2 and the common middle.  Or null if there was no match.
               */
              function diff_halfMatch_(text1, text2) {
                var longtext = text1.length > text2.length ? text1 : text2;
                var shorttext = text1.length > text2.length ? text2 : text1;
                if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
                  return null; // Pointless.
                }

                /**
                 * Does a substring of shorttext exist within longtext such that the substring
                 * is at least half the length of longtext?
                 * Closure, but does not reference any external variables.
                 * @param {string} longtext Longer string.
                 * @param {string} shorttext Shorter string.
                 * @param {number} i Start index of quarter length substring within longtext.
                 * @return {Array.<string>} Five element Array, containing the prefix of
                 *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
                 *     of shorttext and the common middle.  Or null if there was no match.
                 * @private
                 */
                function diff_halfMatchI_(longtext, shorttext, i) {
                  // Start with a 1/4 length substring at position i as a seed.
                  var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
                  var j = -1;
                  var best_common = '';
                  var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
                  while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
                    var prefixLength = diff_commonPrefix(longtext.substring(i), shorttext.substring(j));
                    var suffixLength = diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));
                    if (best_common.length < suffixLength + prefixLength) {
                      best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
                      best_longtext_a = longtext.substring(0, i - suffixLength);
                      best_longtext_b = longtext.substring(i + prefixLength);
                      best_shorttext_a = shorttext.substring(0, j - suffixLength);
                      best_shorttext_b = shorttext.substring(j + prefixLength);
                    }
                  }
                  if (best_common.length * 2 >= longtext.length) {
                    return [best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common];
                  } else {
                    return null;
                  }
                }

                // First check if the second quarter is the seed for a half-match.
                var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
                // Check again based on the third quarter.
                var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
                var hm;
                if (!hm1 && !hm2) {
                  return null;
                } else if (!hm2) {
                  hm = hm1;
                } else if (!hm1) {
                  hm = hm2;
                } else {
                  // Both matched.  Select the longest.
                  hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
                }

                // A half-match was found, sort out the return data.
                var text1_a, text1_b, text2_a, text2_b;
                if (text1.length > text2.length) {
                  text1_a = hm[0];
                  text1_b = hm[1];
                  text2_a = hm[2];
                  text2_b = hm[3];
                } else {
                  text2_a = hm[0];
                  text2_b = hm[1];
                  text1_a = hm[2];
                  text1_b = hm[3];
                }
                var mid_common = hm[4];
                return [text1_a, text1_b, text2_a, text2_b, mid_common];
              }

              /**
               * Reorder and merge like edit sections.  Merge equalities.
               * Any edit section can move as long as it doesn't cross an equality.
               * @param {Array} diffs Array of diff tuples.
               */
              function diff_cleanupMerge(diffs) {
                diffs.push([DIFF_EQUAL, '']); // Add a dummy entry at the end.
                var pointer = 0;
                var count_delete = 0;
                var count_insert = 0;
                var text_delete = '';
                var text_insert = '';
                var commonlength;
                while (pointer < diffs.length) {
                  switch (diffs[pointer][0]) {
                    case DIFF_INSERT:
                      count_insert++;
                      text_insert += diffs[pointer][1];
                      pointer++;
                      break;
                    case DIFF_DELETE:
                      count_delete++;
                      text_delete += diffs[pointer][1];
                      pointer++;
                      break;
                    case DIFF_EQUAL:
                      // Upon reaching an equality, check for prior redundancies.
                      if (count_delete + count_insert > 1) {
                        if (count_delete !== 0 && count_insert !== 0) {
                          // Factor out any common prefixies.
                          commonlength = diff_commonPrefix(text_insert, text_delete);
                          if (commonlength !== 0) {
                            if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                              diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                            } else {
                              diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                              pointer++;
                            }
                            text_insert = text_insert.substring(commonlength);
                            text_delete = text_delete.substring(commonlength);
                          }
                          // Factor out any common suffixies.
                          commonlength = diff_commonSuffix(text_insert, text_delete);
                          if (commonlength !== 0) {
                            diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                            text_insert = text_insert.substring(0, text_insert.length - commonlength);
                            text_delete = text_delete.substring(0, text_delete.length - commonlength);
                          }
                        }
                        // Delete the offending records and add the merged ones.
                        if (count_delete === 0) {
                          diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT, text_insert]);
                        } else if (count_insert === 0) {
                          diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE, text_delete]);
                        } else {
                          diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
                        }
                        pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
                      } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                        // Merge this equality with the previous one.
                        diffs[pointer - 1][1] += diffs[pointer][1];
                        diffs.splice(pointer, 1);
                      } else {
                        pointer++;
                      }
                      count_insert = 0;
                      count_delete = 0;
                      text_delete = '';
                      text_insert = '';
                      break;
                  }
                }
                if (diffs[diffs.length - 1][1] === '') {
                  diffs.pop(); // Remove the dummy entry at the end.
                }

                // Second pass: look for single edits surrounded on both sides by equalities
                // which can be shifted sideways to eliminate an equality.
                // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
                var changes = false;
                pointer = 1;
                // Intentionally ignore the first and last element (don't need checking).
                while (pointer < diffs.length - 1) {
                  if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
                    // This is a single edit surrounded by equalities.
                    if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                      // Shift the edit over the previous equality.
                      diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                      diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                      diffs.splice(pointer - 1, 1);
                      changes = true;
                    } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
                      // Shift the edit over the next equality.
                      diffs[pointer - 1][1] += diffs[pointer + 1][1];
                      diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                      diffs.splice(pointer + 1, 1);
                      changes = true;
                    }
                  }
                  pointer++;
                }
                // If shifts were made, the diff needs reordering and another shift sweep.
                if (changes) {
                  diff_cleanupMerge(diffs);
                }
              }
              var diff = diff_main;
              diff.INSERT = DIFF_INSERT;
              diff.DELETE = DIFF_DELETE;
              diff.EQUAL = DIFF_EQUAL;
              module.exports = diff;

              /*
               * Modify a diff such that the cursor position points to the start of a change:
               * E.g.
               *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
               *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
               *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
               *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
               *
               * @param {Array} diffs Array of diff tuples
               * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
               * @return {Array} A tuple [cursor location in the modified diff, modified diff]
               */
              function cursor_normalize_diff(diffs, cursor_pos) {
                if (cursor_pos === 0) {
                  return [DIFF_EQUAL, diffs];
                }
                for (var current_pos = 0, i = 0; i < diffs.length; i++) {
                  var d = diffs[i];
                  if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {
                    var next_pos = current_pos + d[1].length;
                    if (cursor_pos === next_pos) {
                      return [i + 1, diffs];
                    } else if (cursor_pos < next_pos) {
                      // copy to prevent side effects
                      diffs = diffs.slice();
                      // split d into two diff changes
                      var split_pos = cursor_pos - current_pos;
                      var d_left = [d[0], d[1].slice(0, split_pos)];
                      var d_right = [d[0], d[1].slice(split_pos)];
                      diffs.splice(i, 1, d_left, d_right);
                      return [i + 1, diffs];
                    } else {
                      current_pos = next_pos;
                    }
                  }
                }
                throw new Error('cursor_pos is out of bounds!');
              }

              /*
               * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
               *
               * Case 1)
               *   Check if a naive shift is possible:
               *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
               *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
               * Case 2)
               *   Check if the following shifts are possible:
               *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
               *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
               *         ^            ^
               *         d          d_next
               *
               * @param {Array} diffs Array of diff tuples
               * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
               * @return {Array} Array of diff tuples
               */
              function fix_cursor(diffs, cursor_pos) {
                var norm = cursor_normalize_diff(diffs, cursor_pos);
                var ndiffs = norm[1];
                var cursor_pointer = norm[0];
                var d = ndiffs[cursor_pointer];
                var d_next = ndiffs[cursor_pointer + 1];
                if (d == null) {
                  // Text was deleted from end of original string,
                  // cursor is now out of bounds in new string
                  return diffs;
                } else if (d[0] !== DIFF_EQUAL) {
                  // A modification happened at the cursor location.
                  // This is the expected outcome, so we can return the original diff.
                  return diffs;
                } else {
                  if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
                    // Case 1)
                    // It is possible to perform a naive shift
                    ndiffs.splice(cursor_pointer, 2, d_next, d);
                    return merge_tuples(ndiffs, cursor_pointer, 2);
                  } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
                    // Case 2)
                    // d[1] is a prefix of d_next[1]
                    // We can assume that d_next[0] !== 0, since d[0] === 0
                    // Shift edit locations..
                    ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
                    var suffix = d_next[1].slice(d[1].length);
                    if (suffix.length > 0) {
                      ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
                    }
                    return merge_tuples(ndiffs, cursor_pointer, 3);
                  } else {
                    // Not possible to perform any modification
                    return diffs;
                  }
                }
              }

              /*
               * Check diff did not split surrogate pairs.
               * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
               *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
               *
               * @param {Array} diffs Array of diff tuples
               * @return {Array} Array of diff tuples
               */
              function fix_emoji(diffs) {
                var compact = false;
                var starts_with_pair_end = function starts_with_pair_end(str) {
                  return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
                };
                var ends_with_pair_start = function ends_with_pair_start(str) {
                  return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;
                };
                for (var i = 2; i < diffs.length; i += 1) {
                  if (diffs[i - 2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i - 2][1]) && diffs[i - 1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i - 1][1]) && diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {
                    compact = true;
                    diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
                    diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
                    diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
                  }
                }
                if (!compact) {
                  return diffs;
                }
                var fixed_diffs = [];
                for (var i = 0; i < diffs.length; i += 1) {
                  if (diffs[i][1].length > 0) {
                    fixed_diffs.push(diffs[i]);
                  }
                }
                return fixed_diffs;
              }

              /*
               * Try to merge tuples with their neigbors in a given range.
               * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
               *
               * @param {Array} diffs Array of diff tuples.
               * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
               * @param {Int} length Number of consecutive elements to check.
               * @return {Array} Array of merged diff tuples.
               */
              function merge_tuples(diffs, start, length) {
                // Check from (start-1) to (start+length).
                for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
                  if (i + 1 < diffs.length) {
                    var left_d = diffs[i];
                    var right_d = diffs[i + 1];
                    if (left_d[0] === right_d[1]) {
                      diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
                    }
                  }
                }
                return diffs;
              }

              /***/
            }), (/* 52 */
            /***/function (module, exports) {
              exports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;
              exports.shim = shim;
              function shim(obj) {
                var keys = [];
                for (var key in obj) keys.push(key);
                return keys;
              }

              /***/
            }), (/* 53 */
            /***/function (module, exports) {
              var supportsArgumentsClass = function () {
                return Object.prototype.toString.call(arguments);
              }() == '[object Arguments]';
              exports = module.exports = supportsArgumentsClass ? supported : unsupported;
              exports.supported = supported;
              function supported(object) {
                return Object.prototype.toString.call(object) == '[object Arguments]';
              }
              exports.unsupported = unsupported;
              function unsupported(object) {
                return object && typeof object == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;
              }

              /***/
            }), (/* 54 */
            /***/function (module, exports) {
              var has = Object.prototype.hasOwnProperty,
                prefix = '~';

              /**
               * Constructor to create a storage for our `EE` objects.
               * An `Events` instance is a plain object whose properties are event names.
               *
               * @constructor
               * @api private
               */
              function Events() {}

              //
              // We try to not inherit from `Object.prototype`. In some engines creating an
              // instance in this way is faster than calling `Object.create(null)` directly.
              // If `Object.create(null)` is not supported we prefix the event names with a
              // character to make sure that the built-in object properties are not
              // overridden or used as an attack vector.
              //
              if (Object.create) {
                Events.prototype = Object.create(null);

                //
                // This hack is needed because the `__proto__` property is still inherited in
                // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
                //
                if (!new Events().__proto__) prefix = false;
              }

              /**
               * Representation of a single event listener.
               *
               * @param {Function} fn The listener function.
               * @param {Mixed} context The context to invoke the listener with.
               * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
               * @constructor
               * @api private
               */
              function EE(fn, context, once) {
                this.fn = fn;
                this.context = context;
                this.once = once || false;
              }

              /**
               * Minimal `EventEmitter` interface that is molded against the Node.js
               * `EventEmitter` interface.
               *
               * @constructor
               * @api public
               */
              function EventEmitter() {
                this._events = new Events();
                this._eventsCount = 0;
              }

              /**
               * Return an array listing the events for which the emitter has registered
               * listeners.
               *
               * @returns {Array}
               * @api public
               */
              EventEmitter.prototype.eventNames = function eventNames() {
                var names = [],
                  events,
                  name;
                if (this._eventsCount === 0) return names;
                for (name in events = this._events) {
                  if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
                }
                if (Object.getOwnPropertySymbols) {
                  return names.concat(Object.getOwnPropertySymbols(events));
                }
                return names;
              };

              /**
               * Return the listeners registered for a given event.
               *
               * @param {String|Symbol} event The event name.
               * @param {Boolean} exists Only check if there are listeners.
               * @returns {Array|Boolean}
               * @api public
               */
              EventEmitter.prototype.listeners = function listeners(event, exists) {
                var evt = prefix ? prefix + event : event,
                  available = this._events[evt];
                if (exists) return !!available;
                if (!available) return [];
                if (available.fn) return [available.fn];
                for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
                  ee[i] = available[i].fn;
                }
                return ee;
              };

              /**
               * Calls each of the listeners registered for a given event.
               *
               * @param {String|Symbol} event The event name.
               * @returns {Boolean} `true` if the event had listeners, else `false`.
               * @api public
               */
              EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
                var evt = prefix ? prefix + event : event;
                if (!this._events[evt]) return false;
                var listeners = this._events[evt],
                  len = arguments.length,
                  args,
                  i;
                if (listeners.fn) {
                  if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
                  switch (len) {
                    case 1:
                      return listeners.fn.call(listeners.context), true;
                    case 2:
                      return listeners.fn.call(listeners.context, a1), true;
                    case 3:
                      return listeners.fn.call(listeners.context, a1, a2), true;
                    case 4:
                      return listeners.fn.call(listeners.context, a1, a2, a3), true;
                    case 5:
                      return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                    case 6:
                      return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
                  }
                  for (i = 1, args = new Array(len - 1); i < len; i++) {
                    args[i - 1] = arguments[i];
                  }
                  listeners.fn.apply(listeners.context, args);
                } else {
                  var length = listeners.length,
                    j;
                  for (i = 0; i < length; i++) {
                    if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
                    switch (len) {
                      case 1:
                        listeners[i].fn.call(listeners[i].context);
                        break;
                      case 2:
                        listeners[i].fn.call(listeners[i].context, a1);
                        break;
                      case 3:
                        listeners[i].fn.call(listeners[i].context, a1, a2);
                        break;
                      case 4:
                        listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                        break;
                      default:
                        if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                          args[j - 1] = arguments[j];
                        }
                        listeners[i].fn.apply(listeners[i].context, args);
                    }
                  }
                }
                return true;
              };

              /**
               * Add a listener for a given event.
               *
               * @param {String|Symbol} event The event name.
               * @param {Function} fn The listener function.
               * @param {Mixed} [context=this] The context to invoke the listener with.
               * @returns {EventEmitter} `this`.
               * @api public
               */
              EventEmitter.prototype.on = function on(event, fn, context) {
                var listener = new EE(fn, context || this),
                  evt = prefix ? prefix + event : event;
                if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;else if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];
                return this;
              };

              /**
               * Add a one-time listener for a given event.
               *
               * @param {String|Symbol} event The event name.
               * @param {Function} fn The listener function.
               * @param {Mixed} [context=this] The context to invoke the listener with.
               * @returns {EventEmitter} `this`.
               * @api public
               */
              EventEmitter.prototype.once = function once(event, fn, context) {
                var listener = new EE(fn, context || this, true),
                  evt = prefix ? prefix + event : event;
                if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;else if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];
                return this;
              };

              /**
               * Remove the listeners of a given event.
               *
               * @param {String|Symbol} event The event name.
               * @param {Function} fn Only remove the listeners that match this function.
               * @param {Mixed} context Only remove the listeners that have this context.
               * @param {Boolean} once Only remove one-time listeners.
               * @returns {EventEmitter} `this`.
               * @api public
               */
              EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
                var evt = prefix ? prefix + event : event;
                if (!this._events[evt]) return this;
                if (!fn) {
                  if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
                  return this;
                }
                var listeners = this._events[evt];
                if (listeners.fn) {
                  if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
                    if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
                  }
                } else {
                  for (var i = 0, events = [], length = listeners.length; i < length; i++) {
                    if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                      events.push(listeners[i]);
                    }
                  }

                  //
                  // Reset the array, or remove it completely if we have no more listeners.
                  //
                  if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
                }
                return this;
              };

              /**
               * Remove all listeners, or those of the specified event.
               *
               * @param {String|Symbol} [event] The event name.
               * @returns {EventEmitter} `this`.
               * @api public
               */
              EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
                var evt;
                if (event) {
                  evt = prefix ? prefix + event : event;
                  if (this._events[evt]) {
                    if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
                  }
                } else {
                  this._events = new Events();
                  this._eventsCount = 0;
                }
                return this;
              };

              //
              // Alias methods names because people roll like that.
              //
              EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
              EventEmitter.prototype.addListener = EventEmitter.prototype.on;

              //
              // This function doesn't apply anymore.
              //
              EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
                return this;
              };

              //
              // Expose the prefix.
              //
              EventEmitter.prefixed = prefix;

              //
              // Allow `EventEmitter` to be imported as module namespace.
              //
              EventEmitter.EventEmitter = EventEmitter;

              //
              // Expose the module.
              //
              if ('undefined' !== typeof module) {
                module.exports = EventEmitter;
              }

              /***/
            }), (/* 55 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.matchText = exports.matchSpacing = exports.matchNewline = exports.matchBlot = exports.matchAttributor = exports.default = undefined;
              var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                return typeof obj;
              } : function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              };
              var _slicedToArray = function () {
                function sliceIterator(arr, i) {
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i) break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"]) _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }
                return function (arr, i) {
                  if (Array.isArray(arr)) {
                    return arr;
                  } else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                  } else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                  }
                };
              }();
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _extend2 = __webpack_require__(3);
              var _extend3 = _interopRequireDefault(_extend2);
              var _quillDelta = __webpack_require__(2);
              var _quillDelta2 = _interopRequireDefault(_quillDelta);
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _quill = __webpack_require__(5);
              var _quill2 = _interopRequireDefault(_quill);
              var _logger = __webpack_require__(10);
              var _logger2 = _interopRequireDefault(_logger);
              var _module = __webpack_require__(9);
              var _module2 = _interopRequireDefault(_module);
              var _align = __webpack_require__(36);
              var _background = __webpack_require__(37);
              var _code = __webpack_require__(13);
              var _code2 = _interopRequireDefault(_code);
              var _color = __webpack_require__(26);
              var _direction = __webpack_require__(38);
              var _font = __webpack_require__(39);
              var _size = __webpack_require__(40);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var debug = (0, _logger2.default)('quill:clipboard');
              var DOM_KEY = '__ql-matcher';
              var CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ['br', matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchSpacing], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ['li', matchIndent], ['b', matchAlias.bind(matchAlias, 'bold')], ['i', matchAlias.bind(matchAlias, 'italic')], ['style', matchIgnore]];
              var ATTRIBUTE_ATTRIBUTORS = [_align.AlignAttribute, _direction.DirectionAttribute].reduce(function (memo, attr) {
                memo[attr.keyName] = attr;
                return memo;
              }, {});
              var STYLE_ATTRIBUTORS = [_align.AlignStyle, _background.BackgroundStyle, _color.ColorStyle, _direction.DirectionStyle, _font.FontStyle, _size.SizeStyle].reduce(function (memo, attr) {
                memo[attr.keyName] = attr;
                return memo;
              }, {});
              var Clipboard = function (_Module) {
                _inherits(Clipboard, _Module);
                function Clipboard(quill, options) {
                  _classCallCheck(this, Clipboard);
                  var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this, quill, options));
                  _this.quill.root.addEventListener('paste', _this.onPaste.bind(_this));
                  _this.container = _this.quill.addContainer('ql-clipboard');
                  _this.container.setAttribute('contenteditable', true);
                  _this.container.setAttribute('tabindex', -1);
                  _this.matchers = [];
                  CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function (_ref) {
                    var _ref2 = _slicedToArray(_ref, 2),
                      selector = _ref2[0],
                      matcher = _ref2[1];
                    if (!options.matchVisual && matcher === matchSpacing) return;
                    _this.addMatcher(selector, matcher);
                  });
                  return _this;
                }
                _createClass(Clipboard, [{
                  key: 'addMatcher',
                  value: function addMatcher(selector, matcher) {
                    this.matchers.push([selector, matcher]);
                  }
                }, {
                  key: 'convert',
                  value: function convert(html) {
                    if (typeof html === 'string') {
                      this.container.innerHTML = html.replace(/\>\r?\n +\</g, '><'); // Remove spaces between tags
                      return this.convert();
                    }
                    var formats = this.quill.getFormat(this.quill.selection.savedRange.index);
                    if (formats[_code2.default.blotName]) {
                      var text = this.container.innerText;
                      this.container.innerHTML = '';
                      return new _quillDelta2.default().insert(text, _defineProperty({}, _code2.default.blotName, formats[_code2.default.blotName]));
                    }
                    var _prepareMatching = this.prepareMatching(),
                      _prepareMatching2 = _slicedToArray(_prepareMatching, 2),
                      elementMatchers = _prepareMatching2[0],
                      textMatchers = _prepareMatching2[1];
                    var delta = traverse(this.container, elementMatchers, textMatchers);
                    // Remove trailing newline
                    if (deltaEndsWith(delta, '\n') && delta.ops[delta.ops.length - 1].attributes == null) {
                      delta = delta.compose(new _quillDelta2.default().retain(delta.length() - 1).delete(1));
                    }
                    debug.log('convert', this.container.innerHTML, delta);
                    this.container.innerHTML = '';
                    return delta;
                  }
                }, {
                  key: 'dangerouslyPasteHTML',
                  value: function dangerouslyPasteHTML(index, html) {
                    var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _quill2.default.sources.API;
                    if (typeof index === 'string') {
                      this.quill.setContents(this.convert(index), html);
                      this.quill.setSelection(0, _quill2.default.sources.SILENT);
                    } else {
                      var paste = this.convert(html);
                      this.quill.updateContents(new _quillDelta2.default().retain(index).concat(paste), source);
                      this.quill.setSelection(index + paste.length(), _quill2.default.sources.SILENT);
                    }
                  }
                }, {
                  key: 'onPaste',
                  value: function onPaste(e) {
                    var _this2 = this;
                    if (e.defaultPrevented || !this.quill.isEnabled()) return;
                    var range = this.quill.getSelection();
                    var delta = new _quillDelta2.default().retain(range.index);
                    var scrollTop = this.quill.scrollingContainer.scrollTop;
                    this.container.focus();
                    this.quill.selection.update(_quill2.default.sources.SILENT);
                    setTimeout(function () {
                      delta = delta.concat(_this2.convert()).delete(range.length);
                      _this2.quill.updateContents(delta, _quill2.default.sources.USER);
                      // range.length contributes to delta.length()
                      _this2.quill.setSelection(delta.length() - range.length, _quill2.default.sources.SILENT);
                      _this2.quill.scrollingContainer.scrollTop = scrollTop;
                      _this2.quill.focus();
                    }, 1);
                  }
                }, {
                  key: 'prepareMatching',
                  value: function prepareMatching() {
                    var _this3 = this;
                    var elementMatchers = [],
                      textMatchers = [];
                    this.matchers.forEach(function (pair) {
                      var _pair = _slicedToArray(pair, 2),
                        selector = _pair[0],
                        matcher = _pair[1];
                      switch (selector) {
                        case Node.TEXT_NODE:
                          textMatchers.push(matcher);
                          break;
                        case Node.ELEMENT_NODE:
                          elementMatchers.push(matcher);
                          break;
                        default:
                          [].forEach.call(_this3.container.querySelectorAll(selector), function (node) {
                            // TODO use weakmap
                            node[DOM_KEY] = node[DOM_KEY] || [];
                            node[DOM_KEY].push(matcher);
                          });
                          break;
                      }
                    });
                    return [elementMatchers, textMatchers];
                  }
                }]);
                return Clipboard;
              }(_module2.default);
              Clipboard.DEFAULTS = {
                matchers: [],
                matchVisual: true
              };
              function applyFormat(delta, format, value) {
                if ((typeof format === 'undefined' ? 'undefined' : _typeof(format)) === 'object') {
                  return Object.keys(format).reduce(function (delta, key) {
                    return applyFormat(delta, key, format[key]);
                  }, delta);
                } else {
                  return delta.reduce(function (delta, op) {
                    if (op.attributes && op.attributes[format]) {
                      return delta.push(op);
                    } else {
                      return delta.insert(op.insert, (0, _extend3.default)({}, _defineProperty({}, format, value), op.attributes));
                    }
                  }, new _quillDelta2.default());
                }
              }
              function computeStyle(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) return {};
                var DOM_KEY = '__ql-computed-style';
                return node[DOM_KEY] || (node[DOM_KEY] = window.getComputedStyle(node));
              }
              function deltaEndsWith(delta, text) {
                var endText = "";
                for (var i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i) {
                  var op = delta.ops[i];
                  if (typeof op.insert !== 'string') break;
                  endText = op.insert + endText;
                }
                return endText.slice(-1 * text.length) === text;
              }
              function isLine(node) {
                if (node.childNodes.length === 0) return false; // Exclude embed blocks
                var style = computeStyle(node);
                return ['block', 'list-item'].indexOf(style.display) > -1;
              }
              function traverse(node, elementMatchers, textMatchers) {
                // Post-order
                if (node.nodeType === node.TEXT_NODE) {
                  return textMatchers.reduce(function (delta, matcher) {
                    return matcher(node, delta);
                  }, new _quillDelta2.default());
                } else if (node.nodeType === node.ELEMENT_NODE) {
                  return [].reduce.call(node.childNodes || [], function (delta, childNode) {
                    var childrenDelta = traverse(childNode, elementMatchers, textMatchers);
                    if (childNode.nodeType === node.ELEMENT_NODE) {
                      childrenDelta = elementMatchers.reduce(function (childrenDelta, matcher) {
                        return matcher(childNode, childrenDelta);
                      }, childrenDelta);
                      childrenDelta = (childNode[DOM_KEY] || []).reduce(function (childrenDelta, matcher) {
                        return matcher(childNode, childrenDelta);
                      }, childrenDelta);
                    }
                    return delta.concat(childrenDelta);
                  }, new _quillDelta2.default());
                } else {
                  return new _quillDelta2.default();
                }
              }
              function matchAlias(format, node, delta) {
                return applyFormat(delta, format, true);
              }
              function matchAttributor(node, delta) {
                var attributes = _parchment2.default.Attributor.Attribute.keys(node);
                var classes = _parchment2.default.Attributor.Class.keys(node);
                var styles = _parchment2.default.Attributor.Style.keys(node);
                var formats = {};
                attributes.concat(classes).concat(styles).forEach(function (name) {
                  var attr = _parchment2.default.query(name, _parchment2.default.Scope.ATTRIBUTE);
                  if (attr != null) {
                    formats[attr.attrName] = attr.value(node);
                    if (formats[attr.attrName]) return;
                  }
                  attr = ATTRIBUTE_ATTRIBUTORS[name];
                  if (attr != null && (attr.attrName === name || attr.keyName === name)) {
                    formats[attr.attrName] = attr.value(node) || undefined;
                  }
                  attr = STYLE_ATTRIBUTORS[name];
                  if (attr != null && (attr.attrName === name || attr.keyName === name)) {
                    attr = STYLE_ATTRIBUTORS[name];
                    formats[attr.attrName] = attr.value(node) || undefined;
                  }
                });
                if (Object.keys(formats).length > 0) {
                  delta = applyFormat(delta, formats);
                }
                return delta;
              }
              function matchBlot(node, delta) {
                var match = _parchment2.default.query(node);
                if (match == null) return delta;
                if (match.prototype instanceof _parchment2.default.Embed) {
                  var embed = {};
                  var value = match.value(node);
                  if (value != null) {
                    embed[match.blotName] = value;
                    delta = new _quillDelta2.default().insert(embed, match.formats(node));
                  }
                } else if (typeof match.formats === 'function') {
                  delta = applyFormat(delta, match.blotName, match.formats(node));
                }
                return delta;
              }
              function matchBreak(node, delta) {
                if (!deltaEndsWith(delta, '\n')) {
                  delta.insert('\n');
                }
                return delta;
              }
              function matchIgnore() {
                return new _quillDelta2.default();
              }
              function matchIndent(node, delta) {
                var match = _parchment2.default.query(node);
                if (match == null || match.blotName !== 'list-item' || !deltaEndsWith(delta, '\n')) {
                  return delta;
                }
                var indent = -1,
                  parent = node.parentNode;
                while (!parent.classList.contains('ql-clipboard')) {
                  if ((_parchment2.default.query(parent) || {}).blotName === 'list') {
                    indent += 1;
                  }
                  parent = parent.parentNode;
                }
                if (indent <= 0) return delta;
                return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).retain(1, {
                  indent: indent
                }));
              }
              function matchNewline(node, delta) {
                if (!deltaEndsWith(delta, '\n')) {
                  if (isLine(node) || delta.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {
                    delta.insert('\n');
                  }
                }
                return delta;
              }
              function matchSpacing(node, delta) {
                if (isLine(node) && node.nextElementSibling != null && !deltaEndsWith(delta, '\n\n')) {
                  var nodeHeight = node.offsetHeight + parseFloat(computeStyle(node).marginTop) + parseFloat(computeStyle(node).marginBottom);
                  if (node.nextElementSibling.offsetTop > node.offsetTop + nodeHeight * 1.5) {
                    delta.insert('\n');
                  }
                }
                return delta;
              }
              function matchStyles(node, delta) {
                var formats = {};
                var style = node.style || {};
                if (style.fontStyle && computeStyle(node).fontStyle === 'italic') {
                  formats.italic = true;
                }
                if (style.fontWeight && (computeStyle(node).fontWeight.startsWith('bold') || parseInt(computeStyle(node).fontWeight) >= 700)) {
                  formats.bold = true;
                }
                if (Object.keys(formats).length > 0) {
                  delta = applyFormat(delta, formats);
                }
                if (parseFloat(style.textIndent || 0) > 0) {
                  // Could be 0.5in
                  delta = new _quillDelta2.default().insert('\t').concat(delta);
                }
                return delta;
              }
              function matchText(node, delta) {
                var text = node.data;
                // Word represents empty line with <o:p>&nbsp;</o:p>
                if (node.parentNode.tagName === 'O:P') {
                  return delta.insert(text.trim());
                }
                if (text.trim().length === 0 && node.parentNode.classList.contains('ql-clipboard')) {
                  return delta;
                }
                if (!computeStyle(node.parentNode).whiteSpace.startsWith('pre')) {
                  // eslint-disable-next-line func-style
                  var replacer = function replacer(collapse, match) {
                    match = match.replace(/[^\u00a0]/g, ''); // \u00a0 is nbsp;
                    return match.length < 1 && collapse ? ' ' : match;
                  };
                  text = text.replace(/\r\n/g, ' ').replace(/\n/g, ' ');
                  text = text.replace(/\s\s+/g, replacer.bind(replacer, true)); // collapse whitespace
                  if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {
                    text = text.replace(/^\s+/, replacer.bind(replacer, false));
                  }
                  if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {
                    text = text.replace(/\s+$/, replacer.bind(replacer, false));
                  }
                }
                return delta.insert(text);
              }
              exports.default = Clipboard;
              exports.matchAttributor = matchAttributor;
              exports.matchBlot = matchBlot;
              exports.matchNewline = matchNewline;
              exports.matchSpacing = matchSpacing;
              exports.matchText = matchText;

              /***/
            }), (/* 56 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _inline = __webpack_require__(6);
              var _inline2 = _interopRequireDefault(_inline);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var Bold = function (_Inline) {
                _inherits(Bold, _Inline);
                function Bold() {
                  _classCallCheck(this, Bold);
                  return _possibleConstructorReturn(this, (Bold.__proto__ || Object.getPrototypeOf(Bold)).apply(this, arguments));
                }
                _createClass(Bold, [{
                  key: 'optimize',
                  value: function optimize(context) {
                    _get(Bold.prototype.__proto__ || Object.getPrototypeOf(Bold.prototype), 'optimize', this).call(this, context);
                    if (this.domNode.tagName !== this.statics.tagName[0]) {
                      this.replaceWith(this.statics.blotName);
                    }
                  }
                }], [{
                  key: 'create',
                  value: function create() {
                    return _get(Bold.__proto__ || Object.getPrototypeOf(Bold), 'create', this).call(this);
                  }
                }, {
                  key: 'formats',
                  value: function formats() {
                    return true;
                  }
                }]);
                return Bold;
              }(_inline2.default);
              Bold.blotName = 'bold';
              Bold.tagName = ['STRONG', 'B'];
              exports.default = Bold;

              /***/
            }), (/* 57 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.addControls = exports.default = undefined;
              var _slicedToArray = function () {
                function sliceIterator(arr, i) {
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i) break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"]) _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }
                return function (arr, i) {
                  if (Array.isArray(arr)) {
                    return arr;
                  } else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                  } else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                  }
                };
              }();
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _quillDelta = __webpack_require__(2);
              var _quillDelta2 = _interopRequireDefault(_quillDelta);
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _quill = __webpack_require__(5);
              var _quill2 = _interopRequireDefault(_quill);
              var _logger = __webpack_require__(10);
              var _logger2 = _interopRequireDefault(_logger);
              var _module = __webpack_require__(9);
              var _module2 = _interopRequireDefault(_module);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var debug = (0, _logger2.default)('quill:toolbar');
              var Toolbar = function (_Module) {
                _inherits(Toolbar, _Module);
                function Toolbar(quill, options) {
                  _classCallCheck(this, Toolbar);
                  var _this = _possibleConstructorReturn(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, quill, options));
                  if (Array.isArray(_this.options.container)) {
                    var container = document.createElement('div');
                    addControls(container, _this.options.container);
                    quill.container.parentNode.insertBefore(container, quill.container);
                    _this.container = container;
                  } else if (typeof _this.options.container === 'string') {
                    _this.container = document.querySelector(_this.options.container);
                  } else {
                    _this.container = _this.options.container;
                  }
                  if (!(_this.container instanceof HTMLElement)) {
                    var _ret;
                    return _ret = debug.error('Container required for toolbar', _this.options), _possibleConstructorReturn(_this, _ret);
                  }
                  _this.container.classList.add('ql-toolbar');
                  _this.controls = [];
                  _this.handlers = {};
                  Object.keys(_this.options.handlers).forEach(function (format) {
                    _this.addHandler(format, _this.options.handlers[format]);
                  });
                  [].forEach.call(_this.container.querySelectorAll('button, select'), function (input) {
                    _this.attach(input);
                  });
                  _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (type, range) {
                    if (type === _quill2.default.events.SELECTION_CHANGE) {
                      _this.update(range);
                    }
                  });
                  _this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function () {
                    var _this$quill$selection = _this.quill.selection.getRange(),
                      _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1),
                      range = _this$quill$selection2[0]; // quill.getSelection triggers update

                    _this.update(range);
                  });
                  return _this;
                }
                _createClass(Toolbar, [{
                  key: 'addHandler',
                  value: function addHandler(format, handler) {
                    this.handlers[format] = handler;
                  }
                }, {
                  key: 'attach',
                  value: function attach(input) {
                    var _this2 = this;
                    var format = [].find.call(input.classList, function (className) {
                      return className.indexOf('ql-') === 0;
                    });
                    if (!format) return;
                    format = format.slice('ql-'.length);
                    if (input.tagName === 'BUTTON') {
                      input.setAttribute('type', 'button');
                    }
                    if (this.handlers[format] == null) {
                      if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format] == null) {
                        debug.warn('ignoring attaching to disabled format', format, input);
                        return;
                      }
                      if (_parchment2.default.query(format) == null) {
                        debug.warn('ignoring attaching to nonexistent format', format, input);
                        return;
                      }
                    }
                    var eventName = input.tagName === 'SELECT' ? 'change' : 'click';
                    input.addEventListener(eventName, function (e) {
                      var value = void 0;
                      if (input.tagName === 'SELECT') {
                        if (input.selectedIndex < 0) return;
                        var selected = input.options[input.selectedIndex];
                        if (selected.hasAttribute('selected')) {
                          value = false;
                        } else {
                          value = selected.value || false;
                        }
                      } else {
                        if (input.classList.contains('ql-active')) {
                          value = false;
                        } else {
                          value = input.value || !input.hasAttribute('value');
                        }
                        e.preventDefault();
                      }
                      _this2.quill.focus();
                      var _quill$selection$getR = _this2.quill.selection.getRange(),
                        _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1),
                        range = _quill$selection$getR2[0];
                      if (_this2.handlers[format] != null) {
                        _this2.handlers[format].call(_this2, value);
                      } else if (_parchment2.default.query(format).prototype instanceof _parchment2.default.Embed) {
                        value = prompt('Enter ' + format);
                        if (!value) return;
                        _this2.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert(_defineProperty({}, format, value)), _quill2.default.sources.USER);
                      } else {
                        _this2.quill.format(format, value, _quill2.default.sources.USER);
                      }
                      _this2.update(range);
                    });
                    // TODO use weakmap
                    this.controls.push([format, input]);
                  }
                }, {
                  key: 'update',
                  value: function update(range) {
                    var formats = range == null ? {} : this.quill.getFormat(range);
                    this.controls.forEach(function (pair) {
                      var _pair = _slicedToArray(pair, 2),
                        format = _pair[0],
                        input = _pair[1];
                      if (input.tagName === 'SELECT') {
                        var option = void 0;
                        if (range == null) {
                          option = null;
                        } else if (formats[format] == null) {
                          option = input.querySelector('option[selected]');
                        } else if (!Array.isArray(formats[format])) {
                          var value = formats[format];
                          if (typeof value === 'string') {
                            value = value.replace(/\"/g, '\\"');
                          }
                          option = input.querySelector('option[value="' + value + '"]');
                        }
                        if (option == null) {
                          input.value = ''; // TODO make configurable?
                          input.selectedIndex = -1;
                        } else {
                          option.selected = true;
                        }
                      } else {
                        if (range == null) {
                          input.classList.remove('ql-active');
                        } else if (input.hasAttribute('value')) {
                          // both being null should match (default values)
                          // '1' should match with 1 (headers)
                          var isActive = formats[format] === input.getAttribute('value') || formats[format] != null && formats[format].toString() === input.getAttribute('value') || formats[format] == null && !input.getAttribute('value');
                          input.classList.toggle('ql-active', isActive);
                        } else {
                          input.classList.toggle('ql-active', formats[format] != null);
                        }
                      }
                    });
                  }
                }]);
                return Toolbar;
              }(_module2.default);
              Toolbar.DEFAULTS = {};
              function addButton(container, format, value) {
                var input = document.createElement('button');
                input.setAttribute('type', 'button');
                input.classList.add('ql-' + format);
                if (value != null) {
                  input.value = value;
                }
                container.appendChild(input);
              }
              function addControls(container, groups) {
                if (!Array.isArray(groups[0])) {
                  groups = [groups];
                }
                groups.forEach(function (controls) {
                  var group = document.createElement('span');
                  group.classList.add('ql-formats');
                  controls.forEach(function (control) {
                    if (typeof control === 'string') {
                      addButton(group, control);
                    } else {
                      var format = Object.keys(control)[0];
                      var value = control[format];
                      if (Array.isArray(value)) {
                        addSelect(group, format, value);
                      } else {
                        addButton(group, format, value);
                      }
                    }
                  });
                  container.appendChild(group);
                });
              }
              function addSelect(container, format, values) {
                var input = document.createElement('select');
                input.classList.add('ql-' + format);
                values.forEach(function (value) {
                  var option = document.createElement('option');
                  if (value !== false) {
                    option.setAttribute('value', value);
                  } else {
                    option.setAttribute('selected', 'selected');
                  }
                  input.appendChild(option);
                });
                container.appendChild(input);
              }
              Toolbar.DEFAULTS = {
                container: null,
                handlers: {
                  clean: function clean() {
                    var _this3 = this;
                    var range = this.quill.getSelection();
                    if (range == null) return;
                    if (range.length == 0) {
                      var formats = this.quill.getFormat();
                      Object.keys(formats).forEach(function (name) {
                        // Clean functionality in existing apps only clean inline formats
                        if (_parchment2.default.query(name, _parchment2.default.Scope.INLINE) != null) {
                          _this3.quill.format(name, false);
                        }
                      });
                    } else {
                      this.quill.removeFormat(range, _quill2.default.sources.USER);
                    }
                  },
                  direction: function direction(value) {
                    var align = this.quill.getFormat()['align'];
                    if (value === 'rtl' && align == null) {
                      this.quill.format('align', 'right', _quill2.default.sources.USER);
                    } else if (!value && align === 'right') {
                      this.quill.format('align', false, _quill2.default.sources.USER);
                    }
                    this.quill.format('direction', value, _quill2.default.sources.USER);
                  },
                  indent: function indent(value) {
                    var range = this.quill.getSelection();
                    var formats = this.quill.getFormat(range);
                    var indent = parseInt(formats.indent || 0);
                    if (value === '+1' || value === '-1') {
                      var modifier = value === '+1' ? 1 : -1;
                      if (formats.direction === 'rtl') modifier *= -1;
                      this.quill.format('indent', indent + modifier, _quill2.default.sources.USER);
                    }
                  },
                  link: function link(value) {
                    if (value === true) {
                      value = prompt('Enter link URL:');
                    }
                    this.quill.format('link', value, _quill2.default.sources.USER);
                  },
                  list: function list(value) {
                    var range = this.quill.getSelection();
                    var formats = this.quill.getFormat(range);
                    if (value === 'check') {
                      if (formats['list'] === 'checked' || formats['list'] === 'unchecked') {
                        this.quill.format('list', false, _quill2.default.sources.USER);
                      } else {
                        this.quill.format('list', 'unchecked', _quill2.default.sources.USER);
                      }
                    } else {
                      this.quill.format('list', value, _quill2.default.sources.USER);
                    }
                  }
                }
              };
              exports.default = Toolbar;
              exports.addControls = addControls;

              /***/
            }), (/* 58 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <polyline class=\"ql-even ql-stroke\" points=\"5 7 3 9 5 11\"></polyline> <polyline class=\"ql-even ql-stroke\" points=\"13 7 15 9 13 11\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>";

              /***/
            }), (/* 59 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _picker = __webpack_require__(28);
              var _picker2 = _interopRequireDefault(_picker);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var ColorPicker = function (_Picker) {
                _inherits(ColorPicker, _Picker);
                function ColorPicker(select, label) {
                  _classCallCheck(this, ColorPicker);
                  var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this, select));
                  _this.label.innerHTML = label;
                  _this.container.classList.add('ql-color-picker');
                  [].slice.call(_this.container.querySelectorAll('.ql-picker-item'), 0, 7).forEach(function (item) {
                    item.classList.add('ql-primary');
                  });
                  return _this;
                }
                _createClass(ColorPicker, [{
                  key: 'buildItem',
                  value: function buildItem(option) {
                    var item = _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'buildItem', this).call(this, option);
                    item.style.backgroundColor = option.getAttribute('value') || '';
                    return item;
                  }
                }, {
                  key: 'selectItem',
                  value: function selectItem(item, trigger) {
                    _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'selectItem', this).call(this, item, trigger);
                    var colorLabel = this.label.querySelector('.ql-color-label');
                    var value = item ? item.getAttribute('data-value') || '' : '';
                    if (colorLabel) {
                      if (colorLabel.tagName === 'line') {
                        colorLabel.style.stroke = value;
                      } else {
                        colorLabel.style.fill = value;
                      }
                    }
                  }
                }]);
                return ColorPicker;
              }(_picker2.default);
              exports.default = ColorPicker;

              /***/
            }), (/* 60 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _picker = __webpack_require__(28);
              var _picker2 = _interopRequireDefault(_picker);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var IconPicker = function (_Picker) {
                _inherits(IconPicker, _Picker);
                function IconPicker(select, icons) {
                  _classCallCheck(this, IconPicker);
                  var _this = _possibleConstructorReturn(this, (IconPicker.__proto__ || Object.getPrototypeOf(IconPicker)).call(this, select));
                  _this.container.classList.add('ql-icon-picker');
                  [].forEach.call(_this.container.querySelectorAll('.ql-picker-item'), function (item) {
                    item.innerHTML = icons[item.getAttribute('data-value') || ''];
                  });
                  _this.defaultItem = _this.container.querySelector('.ql-selected');
                  _this.selectItem(_this.defaultItem);
                  return _this;
                }
                _createClass(IconPicker, [{
                  key: 'selectItem',
                  value: function selectItem(item, trigger) {
                    _get(IconPicker.prototype.__proto__ || Object.getPrototypeOf(IconPicker.prototype), 'selectItem', this).call(this, item, trigger);
                    item = item || this.defaultItem;
                    this.label.innerHTML = item.innerHTML;
                  }
                }]);
                return IconPicker;
              }(_picker2.default);
              exports.default = IconPicker;

              /***/
            }), (/* 61 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var Tooltip = function () {
                function Tooltip(quill, boundsContainer) {
                  var _this = this;
                  _classCallCheck(this, Tooltip);
                  this.quill = quill;
                  this.boundsContainer = boundsContainer || document.body;
                  this.root = quill.addContainer('ql-tooltip');
                  this.root.innerHTML = this.constructor.TEMPLATE;
                  if (this.quill.root === this.quill.scrollingContainer) {
                    this.quill.root.addEventListener('scroll', function () {
                      _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + 'px';
                    });
                  }
                  this.hide();
                }
                _createClass(Tooltip, [{
                  key: 'hide',
                  value: function hide() {
                    this.root.classList.add('ql-hidden');
                  }
                }, {
                  key: 'position',
                  value: function position(reference) {
                    var left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;
                    // root.scrollTop should be 0 if scrollContainer !== root
                    var top = reference.bottom + this.quill.root.scrollTop;
                    this.root.style.left = left + 'px';
                    this.root.style.top = top + 'px';
                    this.root.classList.remove('ql-flip');
                    var containerBounds = this.boundsContainer.getBoundingClientRect();
                    var rootBounds = this.root.getBoundingClientRect();
                    var shift = 0;
                    if (rootBounds.right > containerBounds.right) {
                      shift = containerBounds.right - rootBounds.right;
                      this.root.style.left = left + shift + 'px';
                    }
                    if (rootBounds.left < containerBounds.left) {
                      shift = containerBounds.left - rootBounds.left;
                      this.root.style.left = left + shift + 'px';
                    }
                    if (rootBounds.bottom > containerBounds.bottom) {
                      var height = rootBounds.bottom - rootBounds.top;
                      var verticalShift = reference.bottom - reference.top + height;
                      this.root.style.top = top - verticalShift + 'px';
                      this.root.classList.add('ql-flip');
                    }
                    return shift;
                  }
                }, {
                  key: 'show',
                  value: function show() {
                    this.root.classList.remove('ql-editing');
                    this.root.classList.remove('ql-hidden');
                  }
                }]);
                return Tooltip;
              }();
              exports.default = Tooltip;

              /***/
            }), (/* 62 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _slicedToArray = function () {
                function sliceIterator(arr, i) {
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i) break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"]) _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }
                return function (arr, i) {
                  if (Array.isArray(arr)) {
                    return arr;
                  } else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                  } else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                  }
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _extend = __webpack_require__(3);
              var _extend2 = _interopRequireDefault(_extend);
              var _emitter = __webpack_require__(8);
              var _emitter2 = _interopRequireDefault(_emitter);
              var _base = __webpack_require__(43);
              var _base2 = _interopRequireDefault(_base);
              var _link = __webpack_require__(27);
              var _link2 = _interopRequireDefault(_link);
              var _selection = __webpack_require__(15);
              var _icons = __webpack_require__(41);
              var _icons2 = _interopRequireDefault(_icons);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var TOOLBAR_CONFIG = [[{
                header: ['1', '2', '3', false]
              }], ['bold', 'italic', 'underline', 'link'], [{
                list: 'ordered'
              }, {
                list: 'bullet'
              }], ['clean']];
              var SnowTheme = function (_BaseTheme) {
                _inherits(SnowTheme, _BaseTheme);
                function SnowTheme(quill, options) {
                  _classCallCheck(this, SnowTheme);
                  if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
                    options.modules.toolbar.container = TOOLBAR_CONFIG;
                  }
                  var _this = _possibleConstructorReturn(this, (SnowTheme.__proto__ || Object.getPrototypeOf(SnowTheme)).call(this, quill, options));
                  _this.quill.container.classList.add('ql-snow');
                  return _this;
                }
                _createClass(SnowTheme, [{
                  key: 'extendToolbar',
                  value: function extendToolbar(toolbar) {
                    toolbar.container.classList.add('ql-snow');
                    this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2.default);
                    this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2.default);
                    this.tooltip = new SnowTooltip(this.quill, this.options.bounds);
                    if (toolbar.container.querySelector('.ql-link')) {
                      this.quill.keyboard.addBinding({
                        key: 'K',
                        shortKey: true
                      }, function (range, context) {
                        toolbar.handlers['link'].call(toolbar, !context.format.link);
                      });
                    }
                  }
                }]);
                return SnowTheme;
              }(_base2.default);
              SnowTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
                modules: {
                  toolbar: {
                    handlers: {
                      link: function link(value) {
                        if (value) {
                          var range = this.quill.getSelection();
                          if (range == null || range.length == 0) return;
                          var preview = this.quill.getText(range);
                          if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf('mailto:') !== 0) {
                            preview = 'mailto:' + preview;
                          }
                          var tooltip = this.quill.theme.tooltip;
                          tooltip.edit('link', preview);
                        } else {
                          this.quill.format('link', false);
                        }
                      }
                    }
                  }
                }
              });
              var SnowTooltip = function (_BaseTooltip) {
                _inherits(SnowTooltip, _BaseTooltip);
                function SnowTooltip(quill, bounds) {
                  _classCallCheck(this, SnowTooltip);
                  var _this2 = _possibleConstructorReturn(this, (SnowTooltip.__proto__ || Object.getPrototypeOf(SnowTooltip)).call(this, quill, bounds));
                  _this2.preview = _this2.root.querySelector('a.ql-preview');
                  return _this2;
                }
                _createClass(SnowTooltip, [{
                  key: 'listen',
                  value: function listen() {
                    var _this3 = this;
                    _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'listen', this).call(this);
                    this.root.querySelector('a.ql-action').addEventListener('click', function (event) {
                      if (_this3.root.classList.contains('ql-editing')) {
                        _this3.save();
                      } else {
                        _this3.edit('link', _this3.preview.textContent);
                      }
                      event.preventDefault();
                    });
                    this.root.querySelector('a.ql-remove').addEventListener('click', function (event) {
                      if (_this3.linkRange != null) {
                        var range = _this3.linkRange;
                        _this3.restoreFocus();
                        _this3.quill.formatText(range, 'link', false, _emitter2.default.sources.USER);
                        delete _this3.linkRange;
                      }
                      event.preventDefault();
                      _this3.hide();
                    });
                    this.quill.on(_emitter2.default.events.SELECTION_CHANGE, function (range, oldRange, source) {
                      if (range == null) return;
                      if (range.length === 0 && source === _emitter2.default.sources.USER) {
                        var _quill$scroll$descend = _this3.quill.scroll.descendant(_link2.default, range.index),
                          _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2),
                          link = _quill$scroll$descend2[0],
                          offset = _quill$scroll$descend2[1];
                        if (link != null) {
                          _this3.linkRange = new _selection.Range(range.index - offset, link.length());
                          var preview = _link2.default.formats(link.domNode);
                          _this3.preview.textContent = preview;
                          _this3.preview.setAttribute('href', preview);
                          _this3.show();
                          _this3.position(_this3.quill.getBounds(_this3.linkRange));
                          return;
                        }
                      } else {
                        delete _this3.linkRange;
                      }
                      _this3.hide();
                    });
                  }
                }, {
                  key: 'show',
                  value: function show() {
                    _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'show', this).call(this);
                    this.root.removeAttribute('data-mode');
                  }
                }]);
                return SnowTooltip;
              }(_base.BaseTooltip);
              SnowTooltip.TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join('');
              exports.default = SnowTheme;

              /***/
            }), (/* 63 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _core = __webpack_require__(29);
              var _core2 = _interopRequireDefault(_core);
              var _align = __webpack_require__(36);
              var _direction = __webpack_require__(38);
              var _indent = __webpack_require__(64);
              var _blockquote = __webpack_require__(65);
              var _blockquote2 = _interopRequireDefault(_blockquote);
              var _header = __webpack_require__(66);
              var _header2 = _interopRequireDefault(_header);
              var _list = __webpack_require__(67);
              var _list2 = _interopRequireDefault(_list);
              var _background = __webpack_require__(37);
              var _color = __webpack_require__(26);
              var _font = __webpack_require__(39);
              var _size = __webpack_require__(40);
              var _bold = __webpack_require__(56);
              var _bold2 = _interopRequireDefault(_bold);
              var _italic = __webpack_require__(68);
              var _italic2 = _interopRequireDefault(_italic);
              var _link = __webpack_require__(27);
              var _link2 = _interopRequireDefault(_link);
              var _script = __webpack_require__(69);
              var _script2 = _interopRequireDefault(_script);
              var _strike = __webpack_require__(70);
              var _strike2 = _interopRequireDefault(_strike);
              var _underline = __webpack_require__(71);
              var _underline2 = _interopRequireDefault(_underline);
              var _image = __webpack_require__(72);
              var _image2 = _interopRequireDefault(_image);
              var _video = __webpack_require__(73);
              var _video2 = _interopRequireDefault(_video);
              var _code = __webpack_require__(13);
              var _code2 = _interopRequireDefault(_code);
              var _formula = __webpack_require__(74);
              var _formula2 = _interopRequireDefault(_formula);
              var _syntax = __webpack_require__(75);
              var _syntax2 = _interopRequireDefault(_syntax);
              var _toolbar = __webpack_require__(57);
              var _toolbar2 = _interopRequireDefault(_toolbar);
              var _icons = __webpack_require__(41);
              var _icons2 = _interopRequireDefault(_icons);
              var _picker = __webpack_require__(28);
              var _picker2 = _interopRequireDefault(_picker);
              var _colorPicker = __webpack_require__(59);
              var _colorPicker2 = _interopRequireDefault(_colorPicker);
              var _iconPicker = __webpack_require__(60);
              var _iconPicker2 = _interopRequireDefault(_iconPicker);
              var _tooltip = __webpack_require__(61);
              var _tooltip2 = _interopRequireDefault(_tooltip);
              var _bubble = __webpack_require__(108);
              var _bubble2 = _interopRequireDefault(_bubble);
              var _snow = __webpack_require__(62);
              var _snow2 = _interopRequireDefault(_snow);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              _core2.default.register({
                'attributors/attribute/direction': _direction.DirectionAttribute,
                'attributors/class/align': _align.AlignClass,
                'attributors/class/background': _background.BackgroundClass,
                'attributors/class/color': _color.ColorClass,
                'attributors/class/direction': _direction.DirectionClass,
                'attributors/class/font': _font.FontClass,
                'attributors/class/size': _size.SizeClass,
                'attributors/style/align': _align.AlignStyle,
                'attributors/style/background': _background.BackgroundStyle,
                'attributors/style/color': _color.ColorStyle,
                'attributors/style/direction': _direction.DirectionStyle,
                'attributors/style/font': _font.FontStyle,
                'attributors/style/size': _size.SizeStyle
              }, true);
              _core2.default.register({
                'formats/align': _align.AlignClass,
                'formats/direction': _direction.DirectionClass,
                'formats/indent': _indent.IndentClass,
                'formats/background': _background.BackgroundStyle,
                'formats/color': _color.ColorStyle,
                'formats/font': _font.FontClass,
                'formats/size': _size.SizeClass,
                'formats/blockquote': _blockquote2.default,
                'formats/code-block': _code2.default,
                'formats/header': _header2.default,
                'formats/list': _list2.default,
                'formats/bold': _bold2.default,
                'formats/code': _code.Code,
                'formats/italic': _italic2.default,
                'formats/link': _link2.default,
                'formats/script': _script2.default,
                'formats/strike': _strike2.default,
                'formats/underline': _underline2.default,
                'formats/image': _image2.default,
                'formats/video': _video2.default,
                'formats/list/item': _list.ListItem,
                'modules/formula': _formula2.default,
                'modules/syntax': _syntax2.default,
                'modules/toolbar': _toolbar2.default,
                'themes/bubble': _bubble2.default,
                'themes/snow': _snow2.default,
                'ui/icons': _icons2.default,
                'ui/picker': _picker2.default,
                'ui/icon-picker': _iconPicker2.default,
                'ui/color-picker': _colorPicker2.default,
                'ui/tooltip': _tooltip2.default
              }, true);
              exports.default = _core2.default;

              /***/
            }), (/* 64 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.IndentClass = undefined;
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var IdentAttributor = function (_Parchment$Attributor) {
                _inherits(IdentAttributor, _Parchment$Attributor);
                function IdentAttributor() {
                  _classCallCheck(this, IdentAttributor);
                  return _possibleConstructorReturn(this, (IdentAttributor.__proto__ || Object.getPrototypeOf(IdentAttributor)).apply(this, arguments));
                }
                _createClass(IdentAttributor, [{
                  key: 'add',
                  value: function add(node, value) {
                    if (value === '+1' || value === '-1') {
                      var indent = this.value(node) || 0;
                      value = value === '+1' ? indent + 1 : indent - 1;
                    }
                    if (value === 0) {
                      this.remove(node);
                      return true;
                    } else {
                      return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'add', this).call(this, node, value);
                    }
                  }
                }, {
                  key: 'canAdd',
                  value: function canAdd(node, value) {
                    return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, value) || _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, parseInt(value));
                  }
                }, {
                  key: 'value',
                  value: function value(node) {
                    return parseInt(_get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'value', this).call(this, node)) || undefined; // Don't return NaN
                  }
                }]);
                return IdentAttributor;
              }(_parchment2.default.Attributor.Class);
              var IndentClass = new IdentAttributor('indent', 'ql-indent', {
                scope: _parchment2.default.Scope.BLOCK,
                whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
              });
              exports.IndentClass = IndentClass;

              /***/
            }), (/* 65 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _block = __webpack_require__(4);
              var _block2 = _interopRequireDefault(_block);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var Blockquote = function (_Block) {
                _inherits(Blockquote, _Block);
                function Blockquote() {
                  _classCallCheck(this, Blockquote);
                  return _possibleConstructorReturn(this, (Blockquote.__proto__ || Object.getPrototypeOf(Blockquote)).apply(this, arguments));
                }
                return Blockquote;
              }(_block2.default);
              Blockquote.blotName = 'blockquote';
              Blockquote.tagName = 'blockquote';
              exports.default = Blockquote;

              /***/
            }), (/* 66 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _block = __webpack_require__(4);
              var _block2 = _interopRequireDefault(_block);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var Header = function (_Block) {
                _inherits(Header, _Block);
                function Header() {
                  _classCallCheck(this, Header);
                  return _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).apply(this, arguments));
                }
                _createClass(Header, null, [{
                  key: 'formats',
                  value: function formats(domNode) {
                    return this.tagName.indexOf(domNode.tagName) + 1;
                  }
                }]);
                return Header;
              }(_block2.default);
              Header.blotName = 'header';
              Header.tagName = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'];
              exports.default = Header;

              /***/
            }), (/* 67 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.default = exports.ListItem = undefined;
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _block = __webpack_require__(4);
              var _block2 = _interopRequireDefault(_block);
              var _container = __webpack_require__(25);
              var _container2 = _interopRequireDefault(_container);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var ListItem = function (_Block) {
                _inherits(ListItem, _Block);
                function ListItem() {
                  _classCallCheck(this, ListItem);
                  return _possibleConstructorReturn(this, (ListItem.__proto__ || Object.getPrototypeOf(ListItem)).apply(this, arguments));
                }
                _createClass(ListItem, [{
                  key: 'format',
                  value: function format(name, value) {
                    if (name === List.blotName && !value) {
                      this.replaceWith(_parchment2.default.create(this.statics.scope));
                    } else {
                      _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'format', this).call(this, name, value);
                    }
                  }
                }, {
                  key: 'remove',
                  value: function remove() {
                    if (this.prev == null && this.next == null) {
                      this.parent.remove();
                    } else {
                      _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'remove', this).call(this);
                    }
                  }
                }, {
                  key: 'replaceWith',
                  value: function replaceWith(name, value) {
                    this.parent.isolate(this.offset(this.parent), this.length());
                    if (name === this.parent.statics.blotName) {
                      this.parent.replaceWith(name, value);
                      return this;
                    } else {
                      this.parent.unwrap();
                      return _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'replaceWith', this).call(this, name, value);
                    }
                  }
                }], [{
                  key: 'formats',
                  value: function formats(domNode) {
                    return domNode.tagName === this.tagName ? undefined : _get(ListItem.__proto__ || Object.getPrototypeOf(ListItem), 'formats', this).call(this, domNode);
                  }
                }]);
                return ListItem;
              }(_block2.default);
              ListItem.blotName = 'list-item';
              ListItem.tagName = 'LI';
              var List = function (_Container) {
                _inherits(List, _Container);
                _createClass(List, null, [{
                  key: 'create',
                  value: function create(value) {
                    var tagName = value === 'ordered' ? 'OL' : 'UL';
                    var node = _get(List.__proto__ || Object.getPrototypeOf(List), 'create', this).call(this, tagName);
                    if (value === 'checked' || value === 'unchecked') {
                      node.setAttribute('data-checked', value === 'checked');
                    }
                    return node;
                  }
                }, {
                  key: 'formats',
                  value: function formats(domNode) {
                    if (domNode.tagName === 'OL') return 'ordered';
                    if (domNode.tagName === 'UL') {
                      if (domNode.hasAttribute('data-checked')) {
                        return domNode.getAttribute('data-checked') === 'true' ? 'checked' : 'unchecked';
                      } else {
                        return 'bullet';
                      }
                    }
                    return undefined;
                  }
                }]);
                function List(domNode) {
                  _classCallCheck(this, List);
                  var _this2 = _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, domNode));
                  var listEventHandler = function listEventHandler(e) {
                    if (e.target.parentNode !== domNode) return;
                    var format = _this2.statics.formats(domNode);
                    var blot = _parchment2.default.find(e.target);
                    if (format === 'checked') {
                      blot.format('list', 'unchecked');
                    } else if (format === 'unchecked') {
                      blot.format('list', 'checked');
                    }
                  };
                  domNode.addEventListener('touchstart', listEventHandler);
                  domNode.addEventListener('mousedown', listEventHandler);
                  return _this2;
                }
                _createClass(List, [{
                  key: 'format',
                  value: function format(name, value) {
                    if (this.children.length > 0) {
                      this.children.tail.format(name, value);
                    }
                  }
                }, {
                  key: 'formats',
                  value: function formats() {
                    // We don't inherit from FormatBlot
                    return _defineProperty({}, this.statics.blotName, this.statics.formats(this.domNode));
                  }
                }, {
                  key: 'insertBefore',
                  value: function insertBefore(blot, ref) {
                    if (blot instanceof ListItem) {
                      _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'insertBefore', this).call(this, blot, ref);
                    } else {
                      var index = ref == null ? this.length() : ref.offset(this);
                      var after = this.split(index);
                      after.parent.insertBefore(blot, after);
                    }
                  }
                }, {
                  key: 'optimize',
                  value: function optimize(context) {
                    _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'optimize', this).call(this, context);
                    var next = this.next;
                    if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName && next.domNode.getAttribute('data-checked') === this.domNode.getAttribute('data-checked')) {
                      next.moveChildren(this);
                      next.remove();
                    }
                  }
                }, {
                  key: 'replace',
                  value: function replace(target) {
                    if (target.statics.blotName !== this.statics.blotName) {
                      var item = _parchment2.default.create(this.statics.defaultChild);
                      target.moveChildren(item);
                      this.appendChild(item);
                    }
                    _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'replace', this).call(this, target);
                  }
                }]);
                return List;
              }(_container2.default);
              List.blotName = 'list';
              List.scope = _parchment2.default.Scope.BLOCK_BLOT;
              List.tagName = ['OL', 'UL'];
              List.defaultChild = 'list-item';
              List.allowedChildren = [ListItem];
              exports.ListItem = ListItem;
              exports.default = List;

              /***/
            }), (/* 68 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _bold = __webpack_require__(56);
              var _bold2 = _interopRequireDefault(_bold);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var Italic = function (_Bold) {
                _inherits(Italic, _Bold);
                function Italic() {
                  _classCallCheck(this, Italic);
                  return _possibleConstructorReturn(this, (Italic.__proto__ || Object.getPrototypeOf(Italic)).apply(this, arguments));
                }
                return Italic;
              }(_bold2.default);
              Italic.blotName = 'italic';
              Italic.tagName = ['EM', 'I'];
              exports.default = Italic;

              /***/
            }), (/* 69 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _inline = __webpack_require__(6);
              var _inline2 = _interopRequireDefault(_inline);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var Script = function (_Inline) {
                _inherits(Script, _Inline);
                function Script() {
                  _classCallCheck(this, Script);
                  return _possibleConstructorReturn(this, (Script.__proto__ || Object.getPrototypeOf(Script)).apply(this, arguments));
                }
                _createClass(Script, null, [{
                  key: 'create',
                  value: function create(value) {
                    if (value === 'super') {
                      return document.createElement('sup');
                    } else if (value === 'sub') {
                      return document.createElement('sub');
                    } else {
                      return _get(Script.__proto__ || Object.getPrototypeOf(Script), 'create', this).call(this, value);
                    }
                  }
                }, {
                  key: 'formats',
                  value: function formats(domNode) {
                    if (domNode.tagName === 'SUB') return 'sub';
                    if (domNode.tagName === 'SUP') return 'super';
                    return undefined;
                  }
                }]);
                return Script;
              }(_inline2.default);
              Script.blotName = 'script';
              Script.tagName = ['SUB', 'SUP'];
              exports.default = Script;

              /***/
            }), (/* 70 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _inline = __webpack_require__(6);
              var _inline2 = _interopRequireDefault(_inline);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var Strike = function (_Inline) {
                _inherits(Strike, _Inline);
                function Strike() {
                  _classCallCheck(this, Strike);
                  return _possibleConstructorReturn(this, (Strike.__proto__ || Object.getPrototypeOf(Strike)).apply(this, arguments));
                }
                return Strike;
              }(_inline2.default);
              Strike.blotName = 'strike';
              Strike.tagName = 'S';
              exports.default = Strike;

              /***/
            }), (/* 71 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _inline = __webpack_require__(6);
              var _inline2 = _interopRequireDefault(_inline);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var Underline = function (_Inline) {
                _inherits(Underline, _Inline);
                function Underline() {
                  _classCallCheck(this, Underline);
                  return _possibleConstructorReturn(this, (Underline.__proto__ || Object.getPrototypeOf(Underline)).apply(this, arguments));
                }
                return Underline;
              }(_inline2.default);
              Underline.blotName = 'underline';
              Underline.tagName = 'U';
              exports.default = Underline;

              /***/
            }), (/* 72 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _link = __webpack_require__(27);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var ATTRIBUTES = ['alt', 'height', 'width'];
              var Image = function (_Parchment$Embed) {
                _inherits(Image, _Parchment$Embed);
                function Image() {
                  _classCallCheck(this, Image);
                  return _possibleConstructorReturn(this, (Image.__proto__ || Object.getPrototypeOf(Image)).apply(this, arguments));
                }
                _createClass(Image, [{
                  key: 'format',
                  value: function format(name, value) {
                    if (ATTRIBUTES.indexOf(name) > -1) {
                      if (value) {
                        this.domNode.setAttribute(name, value);
                      } else {
                        this.domNode.removeAttribute(name);
                      }
                    } else {
                      _get(Image.prototype.__proto__ || Object.getPrototypeOf(Image.prototype), 'format', this).call(this, name, value);
                    }
                  }
                }], [{
                  key: 'create',
                  value: function create(value) {
                    var node = _get(Image.__proto__ || Object.getPrototypeOf(Image), 'create', this).call(this, value);
                    if (typeof value === 'string') {
                      node.setAttribute('src', this.sanitize(value));
                    }
                    return node;
                  }
                }, {
                  key: 'formats',
                  value: function formats(domNode) {
                    return ATTRIBUTES.reduce(function (formats, attribute) {
                      if (domNode.hasAttribute(attribute)) {
                        formats[attribute] = domNode.getAttribute(attribute);
                      }
                      return formats;
                    }, {});
                  }
                }, {
                  key: 'match',
                  value: function match(url) {
                    return /\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url);
                  }
                }, {
                  key: 'sanitize',
                  value: function sanitize(url) {
                    return (0, _link.sanitize)(url, ['http', 'https', 'data']) ? url : '//:0';
                  }
                }, {
                  key: 'value',
                  value: function value(domNode) {
                    return domNode.getAttribute('src');
                  }
                }]);
                return Image;
              }(_parchment2.default.Embed);
              Image.blotName = 'image';
              Image.tagName = 'IMG';
              exports.default = Image;

              /***/
            }), (/* 73 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _block = __webpack_require__(4);
              var _link = __webpack_require__(27);
              var _link2 = _interopRequireDefault(_link);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var ATTRIBUTES = ['height', 'width'];
              var Video = function (_BlockEmbed) {
                _inherits(Video, _BlockEmbed);
                function Video() {
                  _classCallCheck(this, Video);
                  return _possibleConstructorReturn(this, (Video.__proto__ || Object.getPrototypeOf(Video)).apply(this, arguments));
                }
                _createClass(Video, [{
                  key: 'format',
                  value: function format(name, value) {
                    if (ATTRIBUTES.indexOf(name) > -1) {
                      if (value) {
                        this.domNode.setAttribute(name, value);
                      } else {
                        this.domNode.removeAttribute(name);
                      }
                    } else {
                      _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), 'format', this).call(this, name, value);
                    }
                  }
                }], [{
                  key: 'create',
                  value: function create(value) {
                    var node = _get(Video.__proto__ || Object.getPrototypeOf(Video), 'create', this).call(this, value);
                    node.setAttribute('frameborder', '0');
                    node.setAttribute('allowfullscreen', true);
                    node.setAttribute('src', this.sanitize(value));
                    return node;
                  }
                }, {
                  key: 'formats',
                  value: function formats(domNode) {
                    return ATTRIBUTES.reduce(function (formats, attribute) {
                      if (domNode.hasAttribute(attribute)) {
                        formats[attribute] = domNode.getAttribute(attribute);
                      }
                      return formats;
                    }, {});
                  }
                }, {
                  key: 'sanitize',
                  value: function sanitize(url) {
                    return _link2.default.sanitize(url);
                  }
                }, {
                  key: 'value',
                  value: function value(domNode) {
                    return domNode.getAttribute('src');
                  }
                }]);
                return Video;
              }(_block.BlockEmbed);
              Video.blotName = 'video';
              Video.className = 'ql-video';
              Video.tagName = 'IFRAME';
              exports.default = Video;

              /***/
            }), (/* 74 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.default = exports.FormulaBlot = undefined;
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _embed = __webpack_require__(35);
              var _embed2 = _interopRequireDefault(_embed);
              var _quill = __webpack_require__(5);
              var _quill2 = _interopRequireDefault(_quill);
              var _module = __webpack_require__(9);
              var _module2 = _interopRequireDefault(_module);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var FormulaBlot = function (_Embed) {
                _inherits(FormulaBlot, _Embed);
                function FormulaBlot() {
                  _classCallCheck(this, FormulaBlot);
                  return _possibleConstructorReturn(this, (FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot)).apply(this, arguments));
                }
                _createClass(FormulaBlot, null, [{
                  key: 'create',
                  value: function create(value) {
                    var node = _get(FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot), 'create', this).call(this, value);
                    if (typeof value === 'string') {
                      window.katex.render(value, node, {
                        throwOnError: false,
                        errorColor: '#f00'
                      });
                      node.setAttribute('data-value', value);
                    }
                    return node;
                  }
                }, {
                  key: 'value',
                  value: function value(domNode) {
                    return domNode.getAttribute('data-value');
                  }
                }]);
                return FormulaBlot;
              }(_embed2.default);
              FormulaBlot.blotName = 'formula';
              FormulaBlot.className = 'ql-formula';
              FormulaBlot.tagName = 'SPAN';
              var Formula = function (_Module) {
                _inherits(Formula, _Module);
                _createClass(Formula, null, [{
                  key: 'register',
                  value: function register() {
                    _quill2.default.register(FormulaBlot, true);
                  }
                }]);
                function Formula() {
                  _classCallCheck(this, Formula);
                  var _this2 = _possibleConstructorReturn(this, (Formula.__proto__ || Object.getPrototypeOf(Formula)).call(this));
                  if (window.katex == null) {
                    throw new Error('Formula module requires KaTeX.');
                  }
                  return _this2;
                }
                return Formula;
              }(_module2.default);
              exports.FormulaBlot = FormulaBlot;
              exports.default = Formula;

              /***/
            }), (/* 75 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.default = exports.CodeToken = exports.CodeBlock = undefined;
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _parchment = __webpack_require__(0);
              var _parchment2 = _interopRequireDefault(_parchment);
              var _quill = __webpack_require__(5);
              var _quill2 = _interopRequireDefault(_quill);
              var _module = __webpack_require__(9);
              var _module2 = _interopRequireDefault(_module);
              var _code = __webpack_require__(13);
              var _code2 = _interopRequireDefault(_code);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var SyntaxCodeBlock = function (_CodeBlock) {
                _inherits(SyntaxCodeBlock, _CodeBlock);
                function SyntaxCodeBlock() {
                  _classCallCheck(this, SyntaxCodeBlock);
                  return _possibleConstructorReturn(this, (SyntaxCodeBlock.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock)).apply(this, arguments));
                }
                _createClass(SyntaxCodeBlock, [{
                  key: 'replaceWith',
                  value: function replaceWith(block) {
                    this.domNode.textContent = this.domNode.textContent;
                    this.attach();
                    _get(SyntaxCodeBlock.prototype.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock.prototype), 'replaceWith', this).call(this, block);
                  }
                }, {
                  key: 'highlight',
                  value: function highlight(_highlight) {
                    var text = this.domNode.textContent;
                    if (this.cachedText !== text) {
                      if (text.trim().length > 0 || this.cachedText == null) {
                        this.domNode.innerHTML = _highlight(text);
                        this.domNode.normalize();
                        this.attach();
                      }
                      this.cachedText = text;
                    }
                  }
                }]);
                return SyntaxCodeBlock;
              }(_code2.default);
              SyntaxCodeBlock.className = 'ql-syntax';
              var CodeToken = new _parchment2.default.Attributor.Class('token', 'hljs', {
                scope: _parchment2.default.Scope.INLINE
              });
              var Syntax = function (_Module) {
                _inherits(Syntax, _Module);
                _createClass(Syntax, null, [{
                  key: 'register',
                  value: function register() {
                    _quill2.default.register(CodeToken, true);
                    _quill2.default.register(SyntaxCodeBlock, true);
                  }
                }]);
                function Syntax(quill, options) {
                  _classCallCheck(this, Syntax);
                  var _this2 = _possibleConstructorReturn(this, (Syntax.__proto__ || Object.getPrototypeOf(Syntax)).call(this, quill, options));
                  if (typeof _this2.options.highlight !== 'function') {
                    throw new Error('Syntax module requires highlight.js. Please include the library on the page before Quill.');
                  }
                  var timer = null;
                  _this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function () {
                    clearTimeout(timer);
                    timer = setTimeout(function () {
                      _this2.highlight();
                      timer = null;
                    }, _this2.options.interval);
                  });
                  _this2.highlight();
                  return _this2;
                }
                _createClass(Syntax, [{
                  key: 'highlight',
                  value: function highlight() {
                    var _this3 = this;
                    if (this.quill.selection.composing) return;
                    this.quill.update(_quill2.default.sources.USER);
                    var range = this.quill.getSelection();
                    this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function (code) {
                      code.highlight(_this3.options.highlight);
                    });
                    this.quill.update(_quill2.default.sources.SILENT);
                    if (range != null) {
                      this.quill.setSelection(range, _quill2.default.sources.SILENT);
                    }
                  }
                }]);
                return Syntax;
              }(_module2.default);
              Syntax.DEFAULTS = {
                highlight: function () {
                  if (window.hljs == null) return null;
                  return function (text) {
                    var result = window.hljs.highlightAuto(text);
                    return result.value;
                  };
                }(),
                interval: 1000
              };
              exports.CodeBlock = SyntaxCodeBlock;
              exports.CodeToken = CodeToken;
              exports.default = Syntax;

              /***/
            }), (/* 76 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>";

              /***/
            }), (/* 77 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>";

              /***/
            }), (/* 78 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>";

              /***/
            }), (/* 79 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>";

              /***/
            }), (/* 80 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <g class=\"ql-fill ql-color-label\"> <polygon points=\"6 6.868 6 6 5 6 5 7 5.942 7 6 6.868\"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points=\"6.817 5 6 5 6 6 6.38 6 6.817 5\"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points=\"4 11.439 4 11 3 11 3 12 3.755 12 4 11.439\"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points=\"4.63 10 4 10 4 11 4.192 11 4.63 10\"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points=\"13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174\"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points=\"12 6.868 12 6 11.62 6 12 6.868\"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points=\"12.933 9 13 9 13 8 12.495 8 12.933 9\"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points=\"5.5 13 9 5 12.5 13\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>";

              /***/
            }), (/* 81 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=4 y=5></rect> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=11 y=5></rect> <path class=\"ql-even ql-fill ql-stroke\" d=M7,8c0,4.031-3,5-3,5></path> <path class=\"ql-even ql-fill ql-stroke\" d=M14,8c0,4.031-3,5-3,5></path> </svg>";

              /***/
            }), (/* 82 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>";

              /***/
            }), (/* 83 */
            /***/function (module, exports) {
              module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>";

              /***/
            }), (/* 84 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-color-label ql-stroke ql-transparent\" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points=\"5.5 11 9 3 12.5 11\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>";

              /***/
            }), (/* 85 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"3 11 5 9 3 7 3 11\"></polygon> <line class=\"ql-stroke ql-fill\" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>";

              /***/
            }), (/* 86 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"15 12 13 10 15 8 15 12\"></polygon> <line class=\"ql-stroke ql-fill\" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>";

              /***/
            }), (/* 87 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>";

              /***/
            }), (/* 88 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>";

              /***/
            }), (/* 89 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>";

              /***/
            }), (/* 90 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform=\"translate(24 18) rotate(-180)\"/> </svg>";

              /***/
            }), (/* 91 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>";

              /***/
            }), (/* 92 */
            /***/function (module, exports) {
              module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>";

              /***/
            }), (/* 93 */
            /***/function (module, exports) {
              module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>";

              /***/
            }), (/* 94 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>";

              /***/
            }), (/* 95 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class=\"ql-even ql-fill\" points=\"5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12\"></polyline> </svg>";

              /***/
            }), (/* 96 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=\"ql-fill ql-stroke\" points=\"3 7 3 11 5 9 3 7\"></polyline> </svg>";

              /***/
            }), (/* 97 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"5 7 5 11 3 9 5 7\"></polyline> </svg>";

              /***/
            }), (/* 98 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class=\"ql-even ql-stroke\" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class=\"ql-even ql-stroke\" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>";

              /***/
            }), (/* 99 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class=\"ql-stroke ql-thin\" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class=\"ql-stroke ql-thin\" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class=\"ql-stroke ql-thin\" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>";

              /***/
            }), (/* 100 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>";

              /***/
            }), (/* 101 */
            /***/function (module, exports) {
              module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points=\"3 4 4 5 6 3\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points=\"3 14 4 15 6 13\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"3 9 4 10 6 8\"></polyline> </svg>";

              /***/
            }), (/* 102 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>";

              /***/
            }), (/* 103 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>";

              /***/
            }), (/* 104 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-stroke ql-thin\" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>";

              /***/
            }), (/* 105 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>";

              /***/
            }), (/* 106 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>";

              /***/
            }), (/* 107 */
            /***/function (module, exports) {
              module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=ql-stroke points=\"7 11 9 13 11 11 7 11\"></polygon> <polygon class=ql-stroke points=\"7 7 9 5 11 7 7 7\"></polygon> </svg>";

              /***/
            }), (/* 108 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.default = exports.BubbleTooltip = undefined;
              var _get = function get(object, property, receiver) {
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                  var parent = Object.getPrototypeOf(object);
                  if (parent === null) {
                    return undefined;
                  } else {
                    return get(parent, property, receiver);
                  }
                } else if ("value" in desc) {
                  return desc.value;
                } else {
                  var getter = desc.get;
                  if (getter === undefined) {
                    return undefined;
                  }
                  return getter.call(receiver);
                }
              };
              var _createClass = function () {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function (Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _extend = __webpack_require__(3);
              var _extend2 = _interopRequireDefault(_extend);
              var _emitter = __webpack_require__(8);
              var _emitter2 = _interopRequireDefault(_emitter);
              var _base = __webpack_require__(43);
              var _base2 = _interopRequireDefault(_base);
              var _selection = __webpack_require__(15);
              var _icons = __webpack_require__(41);
              var _icons2 = _interopRequireDefault(_icons);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                  default: obj
                };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
              }
              var TOOLBAR_CONFIG = [['bold', 'italic', 'link'], [{
                header: 1
              }, {
                header: 2
              }, 'blockquote']];
              var BubbleTheme = function (_BaseTheme) {
                _inherits(BubbleTheme, _BaseTheme);
                function BubbleTheme(quill, options) {
                  _classCallCheck(this, BubbleTheme);
                  if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
                    options.modules.toolbar.container = TOOLBAR_CONFIG;
                  }
                  var _this = _possibleConstructorReturn(this, (BubbleTheme.__proto__ || Object.getPrototypeOf(BubbleTheme)).call(this, quill, options));
                  _this.quill.container.classList.add('ql-bubble');
                  return _this;
                }
                _createClass(BubbleTheme, [{
                  key: 'extendToolbar',
                  value: function extendToolbar(toolbar) {
                    this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
                    this.tooltip.root.appendChild(toolbar.container);
                    this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2.default);
                    this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2.default);
                  }
                }]);
                return BubbleTheme;
              }(_base2.default);
              BubbleTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
                modules: {
                  toolbar: {
                    handlers: {
                      link: function link(value) {
                        if (!value) {
                          this.quill.format('link', false);
                        } else {
                          this.quill.theme.tooltip.edit();
                        }
                      }
                    }
                  }
                }
              });
              var BubbleTooltip = function (_BaseTooltip) {
                _inherits(BubbleTooltip, _BaseTooltip);
                function BubbleTooltip(quill, bounds) {
                  _classCallCheck(this, BubbleTooltip);
                  var _this2 = _possibleConstructorReturn(this, (BubbleTooltip.__proto__ || Object.getPrototypeOf(BubbleTooltip)).call(this, quill, bounds));
                  _this2.quill.on(_emitter2.default.events.EDITOR_CHANGE, function (type, range, oldRange, source) {
                    if (type !== _emitter2.default.events.SELECTION_CHANGE) return;
                    if (range != null && range.length > 0 && source === _emitter2.default.sources.USER) {
                      _this2.show();
                      // Lock our width so we will expand beyond our offsetParent boundaries
                      _this2.root.style.left = '0px';
                      _this2.root.style.width = '';
                      _this2.root.style.width = _this2.root.offsetWidth + 'px';
                      var lines = _this2.quill.getLines(range.index, range.length);
                      if (lines.length === 1) {
                        _this2.position(_this2.quill.getBounds(range));
                      } else {
                        var lastLine = lines[lines.length - 1];
                        var index = _this2.quill.getIndex(lastLine);
                        var length = Math.min(lastLine.length() - 1, range.index + range.length - index);
                        var _bounds = _this2.quill.getBounds(new _selection.Range(index, length));
                        _this2.position(_bounds);
                      }
                    } else if (document.activeElement !== _this2.textbox && _this2.quill.hasFocus()) {
                      _this2.hide();
                    }
                  });
                  return _this2;
                }
                _createClass(BubbleTooltip, [{
                  key: 'listen',
                  value: function listen() {
                    var _this3 = this;
                    _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'listen', this).call(this);
                    this.root.querySelector('.ql-close').addEventListener('click', function () {
                      _this3.root.classList.remove('ql-editing');
                    });
                    this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE, function () {
                      // Let selection be restored by toolbar handlers before repositioning
                      setTimeout(function () {
                        if (_this3.root.classList.contains('ql-hidden')) return;
                        var range = _this3.quill.getSelection();
                        if (range != null) {
                          _this3.position(_this3.quill.getBounds(range));
                        }
                      }, 1);
                    });
                  }
                }, {
                  key: 'cancel',
                  value: function cancel() {
                    this.show();
                  }
                }, {
                  key: 'position',
                  value: function position(reference) {
                    var shift = _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'position', this).call(this, reference);
                    var arrow = this.root.querySelector('.ql-tooltip-arrow');
                    arrow.style.marginLeft = '';
                    if (shift === 0) return shift;
                    arrow.style.marginLeft = -1 * shift - arrow.offsetWidth / 2 + 'px';
                  }
                }]);
                return BubbleTooltip;
              }(_base.BaseTooltip);
              BubbleTooltip.TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', '</div>'].join('');
              exports.BubbleTooltip = BubbleTooltip;
              exports.default = BubbleTheme;

              /***/
            }), (/* 109 */
            /***/function (module, exports, __webpack_require__) {
              module.exports = __webpack_require__(63);

              /***/
            }
            /******/)])["default"];
          });
        })(quill);
        var quillExports = quill.exports;
        const Quill = /*@__PURE__*/getDefaultExportFromCjs(quillExports);

        /*
        React-Quill
        https://github.com/zenoamaro/react-quill
        */
        var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
          var _extendStatics = function extendStatics(d, b) {
            _extendStatics = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (d, b) {
              d.__proto__ = b;
            } || function (d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return _extendStatics(d, b);
          };
          return function (d, b) {
            _extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var __assign = commonjsGlobal && commonjsGlobal.__assign || function () {
          __assign = Object.assign || function (t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
          };
          return __assign.apply(this, arguments);
        };
        var __spreadArrays = commonjsGlobal && commonjsGlobal.__spreadArrays || function () {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
          return r;
        };
        var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
          return mod && mod.__esModule ? mod : {
            "default": mod
          };
        };
        var react_1 = __importDefault(reactExports);
        var react_dom_1 = __importDefault(reactDomExports);
        var isEqual_1 = __importDefault(isEqual_1$1);
        var quill_1 = __importDefault(quillExports);
        var ReactQuill = /** @class */function (_super) {
          __extends(ReactQuill, _super);
          function ReactQuill(props) {
            var _this = _super.call(this, props) || this;
            /*
            Changing one of these props should cause a full re-render and a
            re-instantiation of the Quill editor.
            */
            _this.dirtyProps = ['modules', 'formats', 'bounds', 'theme', 'children'];
            /*
            Changing one of these props should cause a regular update. These are mostly
            props that act on the container, rather than the quillized editing area.
            */
            _this.cleanProps = ['id', 'className', 'style', 'placeholder', 'tabIndex', 'onChange', 'onChangeSelection', 'onFocus', 'onBlur', 'onKeyPress', 'onKeyDown', 'onKeyUp'];
            _this.state = {
              generation: 0
            };
            /*
            Tracks the internal selection of the Quill editor
            */
            _this.selection = null;
            _this.onEditorChange = function (eventName, rangeOrDelta, oldRangeOrDelta, source) {
              var _a, _b, _c, _d;
              if (eventName === 'text-change') {
                (_b = (_a = _this).onEditorChangeText) === null || _b === void 0 ? void 0 : _b.call(_a, _this.editor.root.innerHTML, rangeOrDelta, source, _this.unprivilegedEditor);
              } else if (eventName === 'selection-change') {
                (_d = (_c = _this).onEditorChangeSelection) === null || _d === void 0 ? void 0 : _d.call(_c, rangeOrDelta, source, _this.unprivilegedEditor);
              }
            };
            var value = _this.isControlled() ? props.value : props.defaultValue;
            _this.value = value !== null && value !== void 0 ? value : '';
            return _this;
          }
          ReactQuill.prototype.validateProps = function (props) {
            var _a;
            if (react_1.default.Children.count(props.children) > 1) throw new Error('The Quill editing area can only be composed of a single React element.');
            if (react_1.default.Children.count(props.children)) {
              var child = react_1.default.Children.only(props.children);
              if (((_a = child) === null || _a === void 0 ? void 0 : _a.type) === 'textarea') throw new Error('Quill does not support editing on a <textarea>. Use a <div> instead.');
            }
            if (this.lastDeltaChangeSet && props.value === this.lastDeltaChangeSet) throw new Error('You are passing the `delta` object from the `onChange` event back ' + 'as `value`. You most probably want `editor.getContents()` instead. ' + 'See: https://github.com/zenoamaro/react-quill#using-deltas');
          };
          ReactQuill.prototype.shouldComponentUpdate = function (nextProps, nextState) {
            var _this = this;
            var _a;
            this.validateProps(nextProps);
            // If the editor hasn't been instantiated yet, or the component has been
            // regenerated, we already know we should update.
            if (!this.editor || this.state.generation !== nextState.generation) {
              return true;
            }
            // Handle value changes in-place
            if ('value' in nextProps) {
              var prevContents = this.getEditorContents();
              var nextContents = (_a = nextProps.value, _a !== null && _a !== void 0 ? _a : '');
              // NOTE: Seeing that Quill is missing a way to prevent edits, we have to
              //       settle for a hybrid between controlled and uncontrolled mode. We
              //       can't prevent the change, but we'll still override content
              //       whenever `value` differs from current state.
              // NOTE: Comparing an HTML string and a Quill Delta will always trigger a
              //       change, regardless of whether they represent the same document.
              if (!this.isEqualValue(nextContents, prevContents)) {
                this.setEditorContents(this.editor, nextContents);
              }
            }
            // Handle read-only changes in-place
            if (nextProps.readOnly !== this.props.readOnly) {
              this.setEditorReadOnly(this.editor, nextProps.readOnly);
            }
            // Clean and Dirty props require a render
            return __spreadArrays(this.cleanProps, this.dirtyProps).some(function (prop) {
              return !isEqual_1.default(nextProps[prop], _this.props[prop]);
            });
          };
          ReactQuill.prototype.shouldComponentRegenerate = function (nextProps) {
            var _this = this;
            // Whenever a `dirtyProp` changes, the editor needs reinstantiation.
            return this.dirtyProps.some(function (prop) {
              return !isEqual_1.default(nextProps[prop], _this.props[prop]);
            });
          };
          ReactQuill.prototype.componentDidMount = function () {
            this.instantiateEditor();
            this.setEditorContents(this.editor, this.getEditorContents());
          };
          ReactQuill.prototype.componentWillUnmount = function () {
            this.destroyEditor();
          };
          ReactQuill.prototype.componentDidUpdate = function (prevProps, prevState) {
            var _this = this;
            // If we're changing one of the `dirtyProps`, the entire Quill Editor needs
            // to be re-instantiated. Regenerating the editor will cause the whole tree,
            // including the container, to be cleaned up and re-rendered from scratch.
            // Store the contents so they can be restored later.
            if (this.editor && this.shouldComponentRegenerate(prevProps)) {
              var delta = this.editor.getContents();
              var selection = this.editor.getSelection();
              this.regenerationSnapshot = {
                delta: delta,
                selection: selection
              };
              this.setState({
                generation: this.state.generation + 1
              });
              this.destroyEditor();
            }
            // The component has been regenerated, so it must be re-instantiated, and
            // its content must be restored to the previous values from the snapshot.
            if (this.state.generation !== prevState.generation) {
              var _a = this.regenerationSnapshot,
                delta = _a.delta,
                selection_1 = _a.selection;
              delete this.regenerationSnapshot;
              this.instantiateEditor();
              var editor_1 = this.editor;
              editor_1.setContents(delta);
              postpone(function () {
                return _this.setEditorSelection(editor_1, selection_1);
              });
            }
          };
          ReactQuill.prototype.instantiateEditor = function () {
            if (this.editor) {
              this.hookEditor(this.editor);
            } else {
              this.editor = this.createEditor(this.getEditingArea(), this.getEditorConfig());
            }
          };
          ReactQuill.prototype.destroyEditor = function () {
            if (!this.editor) return;
            this.unhookEditor(this.editor);
          };
          /*
          We consider the component to be controlled if `value` is being sent in props.
          */
          ReactQuill.prototype.isControlled = function () {
            return 'value' in this.props;
          };
          ReactQuill.prototype.getEditorConfig = function () {
            return {
              bounds: this.props.bounds,
              formats: this.props.formats,
              modules: this.props.modules,
              placeholder: this.props.placeholder,
              readOnly: this.props.readOnly,
              scrollingContainer: this.props.scrollingContainer,
              tabIndex: this.props.tabIndex,
              theme: this.props.theme
            };
          };
          ReactQuill.prototype.getEditor = function () {
            if (!this.editor) throw new Error('Accessing non-instantiated editor');
            return this.editor;
          };
          /**
          Creates an editor on the given element. The editor will be passed the
          configuration, have its events bound,
          */
          ReactQuill.prototype.createEditor = function (element, config) {
            var editor = new quill_1.default(element, config);
            if (config.tabIndex != null) {
              this.setEditorTabIndex(editor, config.tabIndex);
            }
            this.hookEditor(editor);
            return editor;
          };
          ReactQuill.prototype.hookEditor = function (editor) {
            // Expose the editor on change events via a weaker, unprivileged proxy
            // object that does not allow accidentally modifying editor state.
            this.unprivilegedEditor = this.makeUnprivilegedEditor(editor);
            // Using `editor-change` allows picking up silent updates, like selection
            // changes on typing.
            editor.on('editor-change', this.onEditorChange);
          };
          ReactQuill.prototype.unhookEditor = function (editor) {
            editor.off('editor-change', this.onEditorChange);
          };
          ReactQuill.prototype.getEditorContents = function () {
            return this.value;
          };
          ReactQuill.prototype.getEditorSelection = function () {
            return this.selection;
          };
          /*
          True if the value is a Delta instance or a Delta look-alike.
          */
          ReactQuill.prototype.isDelta = function (value) {
            return value && value.ops;
          };
          /*
          Special comparison function that knows how to compare Deltas.
          */
          ReactQuill.prototype.isEqualValue = function (value, nextValue) {
            if (this.isDelta(value) && this.isDelta(nextValue)) {
              return isEqual_1.default(value.ops, nextValue.ops);
            } else {
              return isEqual_1.default(value, nextValue);
            }
          };
          /*
          Replace the contents of the editor, but keep the previous selection hanging
          around so that the cursor won't move.
          */
          ReactQuill.prototype.setEditorContents = function (editor, value) {
            var _this = this;
            this.value = value;
            var sel = this.getEditorSelection();
            if (typeof value === 'string') {
              editor.setContents(editor.clipboard.convert(value));
            } else {
              editor.setContents(value);
            }
            postpone(function () {
              return _this.setEditorSelection(editor, sel);
            });
          };
          ReactQuill.prototype.setEditorSelection = function (editor, range) {
            this.selection = range;
            if (range) {
              // Validate bounds before applying.
              var length_1 = editor.getLength();
              range.index = Math.max(0, Math.min(range.index, length_1 - 1));
              range.length = Math.max(0, Math.min(range.length, length_1 - 1 - range.index));
              editor.setSelection(range);
            }
          };
          ReactQuill.prototype.setEditorTabIndex = function (editor, tabIndex) {
            var _a, _b;
            if ((_b = (_a = editor) === null || _a === void 0 ? void 0 : _a.scroll) === null || _b === void 0 ? void 0 : _b.domNode) {
              editor.scroll.domNode.tabIndex = tabIndex;
            }
          };
          ReactQuill.prototype.setEditorReadOnly = function (editor, value) {
            if (value) {
              editor.disable();
            } else {
              editor.enable();
            }
          };
          /*
          Returns a weaker, unprivileged proxy object that only exposes read-only
          accessors found on the editor instance, without any state-modifying methods.
          */
          ReactQuill.prototype.makeUnprivilegedEditor = function (editor) {
            var e = editor;
            return {
              getHTML: function getHTML() {
                return e.root.innerHTML;
              },
              getLength: e.getLength.bind(e),
              getText: e.getText.bind(e),
              getContents: e.getContents.bind(e),
              getSelection: e.getSelection.bind(e),
              getBounds: e.getBounds.bind(e)
            };
          };
          ReactQuill.prototype.getEditingArea = function () {
            if (!this.editingArea) {
              throw new Error('Instantiating on missing editing area');
            }
            var element = react_dom_1.default.findDOMNode(this.editingArea);
            if (!element) {
              throw new Error('Cannot find element for editing area');
            }
            if (element.nodeType === 3) {
              throw new Error('Editing area cannot be a text node');
            }
            return element;
          };
          /*
          Renders an editor area, unless it has been provided one to clone.
          */
          ReactQuill.prototype.renderEditingArea = function () {
            var _this = this;
            var _a = this.props,
              children = _a.children,
              preserveWhitespace = _a.preserveWhitespace;
            var generation = this.state.generation;
            var properties = {
              key: generation,
              ref: function ref(instance) {
                _this.editingArea = instance;
              }
            };
            if (react_1.default.Children.count(children)) {
              return react_1.default.cloneElement(react_1.default.Children.only(children), properties);
            }
            return preserveWhitespace ? react_1.default.createElement("pre", __assign({}, properties)) : react_1.default.createElement("div", __assign({}, properties));
          };
          ReactQuill.prototype.render = function () {
            var _a;
            return react_1.default.createElement("div", {
              id: this.props.id,
              style: this.props.style,
              key: this.state.generation,
              className: "quill " + (_a = this.props.className, _a !== null && _a !== void 0 ? _a : ''),
              onKeyPress: this.props.onKeyPress,
              onKeyDown: this.props.onKeyDown,
              onKeyUp: this.props.onKeyUp
            }, this.renderEditingArea());
          };
          ReactQuill.prototype.onEditorChangeText = function (value, delta, source, editor) {
            var _a, _b;
            if (!this.editor) return;
            // We keep storing the same type of value as what the user gives us,
            // so that value comparisons will be more stable and predictable.
            var nextContents = this.isDelta(this.value) ? editor.getContents() : editor.getHTML();
            if (nextContents !== this.getEditorContents()) {
              // Taint this `delta` object, so we can recognize whether the user
              // is trying to send it back as `value`, preventing a likely loop.
              this.lastDeltaChangeSet = delta;
              this.value = nextContents;
              (_b = (_a = this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value, delta, source, editor);
            }
          };
          ReactQuill.prototype.onEditorChangeSelection = function (nextSelection, source, editor) {
            var _a, _b, _c, _d, _e, _f;
            if (!this.editor) return;
            var currentSelection = this.getEditorSelection();
            var hasGainedFocus = !currentSelection && nextSelection;
            var hasLostFocus = currentSelection && !nextSelection;
            if (isEqual_1.default(nextSelection, currentSelection)) return;
            this.selection = nextSelection;
            (_b = (_a = this.props).onChangeSelection) === null || _b === void 0 ? void 0 : _b.call(_a, nextSelection, source, editor);
            if (hasGainedFocus) {
              (_d = (_c = this.props).onFocus) === null || _d === void 0 ? void 0 : _d.call(_c, nextSelection, source, editor);
            } else if (hasLostFocus) {
              (_f = (_e = this.props).onBlur) === null || _f === void 0 ? void 0 : _f.call(_e, currentSelection, source, editor);
            }
          };
          ReactQuill.prototype.focus = function () {
            if (!this.editor) return;
            this.editor.focus();
          };
          ReactQuill.prototype.blur = function () {
            if (!this.editor) return;
            this.selection = null;
            this.editor.blur();
          };
          ReactQuill.displayName = 'React Quill';
          /*
          Export Quill to be able to call `register`
          */
          ReactQuill.Quill = quill_1.default;
          ReactQuill.defaultProps = {
            theme: 'snow',
            modules: {},
            readOnly: false
          };
          return ReactQuill;
        }(react_1.default.Component);
        /*
        Small helper to execute a function in the next micro-tick.
        */
        function postpone(fn) {
          Promise.resolve().then(fn);
        }
        var lib$2 = ReactQuill;
        const ReactQuill$1 = /*@__PURE__*/getDefaultExportFromCjs(lib$2);
        function ownKeys$F(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread2$1(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$F(Object(source), !0).forEach(function (key) {
              _defineProperty$3(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$F(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _typeof$2(obj) {
          "@babel/helpers - typeof";

          return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          }, _typeof$2(obj);
        }
        function _classCallCheck$a(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
          }
        }
        function _createClass$8(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", {
            writable: false
          });
          return Constructor;
        }
        function _defineProperty$3(obj, key, value) {
          key = _toPropertyKey$1(key);
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _extends$g() {
          _extends$g = Object.assign ? Object.assign.bind() : function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          return _extends$g.apply(this, arguments);
        }
        function _inherits$a(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              writable: true,
              configurable: true
            }
          });
          Object.defineProperty(subClass, "prototype", {
            writable: false
          });
          if (superClass) _setPrototypeOf(subClass, superClass);
        }
        function _getPrototypeOf(o) {
          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
          };
          return _getPrototypeOf(o);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o;
          };
          return _setPrototypeOf(o, p);
        }
        function _isNativeReflectConstruct$s() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        function _assertThisInitialized(self) {
          if (self === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self;
        }
        function _possibleConstructorReturn$a(self, call) {
          if (call && (typeof call === "object" || typeof call === "function")) {
            return call;
          } else if (call !== void 0) {
            throw new TypeError("Derived constructors may only return object or undefined");
          }
          return _assertThisInitialized(self);
        }
        function _createSuper(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$a(this, result);
          };
        }
        function _superPropBase$1(object, property) {
          while (!Object.prototype.hasOwnProperty.call(object, property)) {
            object = _getPrototypeOf(object);
            if (object === null) break;
          }
          return object;
        }
        function _get$1() {
          if (typeof Reflect !== "undefined" && Reflect.get) {
            _get$1 = Reflect.get.bind();
          } else {
            _get$1 = function _get(target, property, receiver) {
              var base = _superPropBase$1(target, property);
              if (!base) return;
              var desc = Object.getOwnPropertyDescriptor(base, property);
              if (desc.get) {
                return desc.get.call(arguments.length < 3 ? target : receiver);
              }
              return desc.value;
            };
          }
          return _get$1.apply(this, arguments);
        }
        function _unsupportedIterableToArray$g(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$g(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$g(o, minLen);
        }
        function _arrayLikeToArray$g(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function _createForOfIteratorHelper$f(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$g(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e4) {
                  throw _e4;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e5) {
              didErr = true;
              err = _e5;
            },
            f: function f() {
              try {
                if (!normalCompletion && it.return != null) it.return();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _toPrimitive$1(input, hint) {
          if (typeof input !== "object" || input === null) return input;
          var prim = input[Symbol.toPrimitive];
          if (prim !== undefined) {
            var res = prim.call(input, hint || "default");
            if (typeof res !== "object") return res;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (hint === "string" ? String : Number)(input);
        }
        function _toPropertyKey$1(arg) {
          var key = _toPrimitive$1(arg, "string");
          return typeof key === "symbol" ? key : String(key);
        }
        var Keys = {
          TAB: 9,
          ENTER: 13,
          ESCAPE: 27,
          UP: 38,
          DOWN: 40
        };
        function attachDataValues(element, data, dataAttributes) {
          var mention = element;
          Object.keys(data).forEach(function (key) {
            if (dataAttributes.indexOf(key) > -1) {
              mention.dataset[key] = data[key];
            } else {
              delete mention.dataset[key];
            }
          });
          return mention;
        }
        function setInnerContent(element, value) {
          if (value === null) return;
          if (_typeof$2(value) === "object") element.appendChild(value);else element.innerText = value;
        }
        function getMentionCharIndex(text, mentionDenotationChars, isolateChar, allowInlineMentionChar) {
          return mentionDenotationChars.reduce(function (prev, mentionChar) {
            var mentionCharIndex;
            if (isolateChar && allowInlineMentionChar) {
              var regex = new RegExp("^".concat(mentionChar, "|\\s").concat(mentionChar), "g");
              var lastMatch = (text.match(regex) || []).pop();
              if (!lastMatch) {
                return {
                  mentionChar: prev.mentionChar,
                  mentionCharIndex: prev.mentionCharIndex
                };
              }
              mentionCharIndex = lastMatch !== mentionChar ? text.lastIndexOf(lastMatch) + lastMatch.length - mentionChar.length : 0;
            } else {
              mentionCharIndex = text.lastIndexOf(mentionChar);
            }
            if (mentionCharIndex > prev.mentionCharIndex) {
              return {
                mentionChar: mentionChar,
                mentionCharIndex: mentionCharIndex
              };
            }
            return {
              mentionChar: prev.mentionChar,
              mentionCharIndex: prev.mentionCharIndex
            };
          }, {
            mentionChar: null,
            mentionCharIndex: -1
          });
        }
        function hasValidChars(text, allowedChars) {
          return allowedChars.test(text);
        }
        function hasValidMentionCharIndex(mentionCharIndex, text, isolateChar, textPrefix) {
          if (mentionCharIndex === -1) {
            return false;
          }
          if (!isolateChar) {
            return true;
          }
          var mentionPrefix = mentionCharIndex ? text[mentionCharIndex - 1] : textPrefix;
          return !mentionPrefix || !!mentionPrefix.match(/\s/);
        }
        var Embed = Quill["import"]("blots/embed");
        var MentionBlot = /*#__PURE__*/function (_Embed) {
          _inherits$a(MentionBlot, _Embed);
          var _super = _createSuper(MentionBlot);
          function MentionBlot(scroll, node) {
            var _this;
            _classCallCheck$a(this, MentionBlot);
            _this = _super.call(this, scroll, node);
            _defineProperty$3(_assertThisInitialized(_this), "hoverHandler", void 0);
            _defineProperty$3(_assertThisInitialized(_this), "hoverHandler", void 0);
            _this.clickHandler = null;
            _this.hoverHandler = null;
            _this.mounted = false;
            return _this;
          }
          _createClass$8(MentionBlot, [{
            key: "attach",
            value: function attach() {
              _get$1(_getPrototypeOf(MentionBlot.prototype), "attach", this).call(this);
              if (!this.mounted) {
                this.mounted = true;
                this.clickHandler = this.getClickHandler();
                this.hoverHandler = this.getHoverHandler();
                this.domNode.addEventListener("click", this.clickHandler, false);
                this.domNode.addEventListener("mouseenter", this.hoverHandler, false);
              }
            }
          }, {
            key: "detach",
            value: function detach() {
              _get$1(_getPrototypeOf(MentionBlot.prototype), "detach", this).call(this);
              this.mounted = false;
              if (this.clickHandler) {
                this.domNode.removeEventListener("click", this.clickHandler);
                this.clickHandler = null;
              }
            }
          }, {
            key: "getClickHandler",
            value: function getClickHandler() {
              var _this2 = this;
              return function (e) {
                var event = _this2.buildEvent("mention-clicked", e);
                window.dispatchEvent(event);
                e.preventDefault();
              };
            }
          }, {
            key: "getHoverHandler",
            value: function getHoverHandler() {
              var _this3 = this;
              return function (e) {
                var event = _this3.buildEvent("mention-hovered", e);
                window.dispatchEvent(event);
                e.preventDefault();
              };
            }
          }, {
            key: "buildEvent",
            value: function buildEvent(name, e) {
              var event = new Event(name, {
                bubbles: true,
                cancelable: true
              });
              event.value = _extends$g({}, this.domNode.dataset);
              event.event = e;
              return event;
            }
          }], [{
            key: "create",
            value: function create(data) {
              var node = _get$1(_getPrototypeOf(MentionBlot), "create", this).call(this);
              var denotationChar = document.createElement("span");
              denotationChar.className = "ql-mention-denotation-char";
              denotationChar.innerText = data.denotationChar;
              node.appendChild(denotationChar);
              if (typeof this.render === "function") {
                node.appendChild(this.render(data));
              } else {
                node.innerText += data.value;
              }
              return MentionBlot.setDataValues(node, data);
            }
          }, {
            key: "setDataValues",
            value: function setDataValues(element, data) {
              var domNode = element;
              Object.keys(data).forEach(function (key) {
                domNode.dataset[key] = data[key];
              });
              return domNode;
            }
          }, {
            key: "value",
            value: function value(domNode) {
              return domNode.dataset;
            }
          }]);
          return MentionBlot;
        }(Embed);
        MentionBlot.blotName = "mention";
        MentionBlot.tagName = "span";
        MentionBlot.className = "mention";
        Quill.register("blots/mention", MentionBlot);
        var Mention = /*#__PURE__*/function () {
          function Mention(quill, options) {
            var _this = this;
            _classCallCheck$a(this, Mention);
            this.isOpen = false;
            this.itemIndex = 0;
            this.mentionCharPos = null;
            this.cursorPos = null;
            this.values = [];
            this.suspendMouseEnter = false;
            //this token is an object that may contains one key "abandoned", set to
            //true when the previous source call should be ignored in favor or a
            //more recent execution.  This token will be null unless a source call
            //is in progress.
            this.existingSourceExecutionToken = null;
            this.quill = quill;
            this.options = {
              source: null,
              renderItem: function renderItem(_ref) {
                var value = _ref.value;
                return "".concat(value);
              },
              renderLoading: function renderLoading() {
                return null;
              },
              onSelect: function onSelect(item, insertItem) {
                insertItem(item);
              },
              mentionDenotationChars: ["@"],
              showDenotationChar: true,
              allowedChars: /^[a-zA-Z0-9_]*$/,
              minChars: 0,
              maxChars: 31,
              offsetTop: 2,
              offsetLeft: 0,
              isolateCharacter: false,
              allowInlineMentionChar: false,
              fixMentionsToQuill: false,
              positioningStrategy: "normal",
              defaultMenuOrientation: "bottom",
              blotName: "mention",
              dataAttributes: ["id", "value", "denotationChar", "link", "target", "disabled"],
              linkTarget: "_blank",
              onOpen: function onOpen() {
                return true;
              },
              onBeforeClose: function onBeforeClose() {
                return true;
              },
              onClose: function onClose() {
                return true;
              },
              // Style options
              listItemClass: "ql-mention-list-item",
              mentionContainerClass: "ql-mention-list-container",
              mentionListClass: "ql-mention-list",
              spaceAfterInsert: true,
              selectKeys: [Keys.ENTER]
            };
            _extends$g(this.options, options, {
              dataAttributes: Array.isArray(options.dataAttributes) ? this.options.dataAttributes.concat(options.dataAttributes) : this.options.dataAttributes
            });

            //Bind all option-functions so they have a reasonable context
            for (var o in this.options) {
              if (typeof this.options[o] === "function") {
                this.options[o] = this.options[o].bind(this);
              }
            }

            //create mention container
            this.mentionContainer = document.createElement("div");
            this.mentionContainer.className = this.options.mentionContainerClass ? this.options.mentionContainerClass : "";
            this.mentionContainer.style.cssText = "display: none; position: absolute;";
            this.mentionContainer.onmousemove = this.onContainerMouseMove.bind(this);
            if (this.options.fixMentionsToQuill) {
              this.mentionContainer.style.width = "auto";
            }
            this.mentionList = document.createElement("ul");
            this.mentionList.id = "quill-mention-list";
            quill.root.setAttribute("aria-owns", "quill-mention-list");
            this.mentionList.className = this.options.mentionListClass ? this.options.mentionListClass : "";
            this.mentionContainer.appendChild(this.mentionList);
            quill.on("text-change", this.onTextChange.bind(this));
            quill.on("selection-change", this.onSelectionChange.bind(this));

            //Pasting doesn't fire selection-change after the pasted text is
            //inserted, so here we manually trigger one
            quill.container.addEventListener("paste", function () {
              setTimeout(function () {
                var range = quill.getSelection();
                _this.onSelectionChange(range);
              });
            });
            quill.keyboard.addBinding({
              key: Keys.TAB
            }, this.selectHandler.bind(this));
            quill.keyboard.bindings[Keys.TAB].unshift(quill.keyboard.bindings[Keys.TAB].pop());
            var _iterator = _createForOfIteratorHelper$f(this.options.selectKeys),
              _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var selectKey = _step.value;
                quill.keyboard.addBinding({
                  key: selectKey
                }, this.selectHandler.bind(this));
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            quill.keyboard.bindings[Keys.ENTER].unshift(quill.keyboard.bindings[Keys.ENTER].pop());
            quill.keyboard.addBinding({
              key: Keys.ESCAPE
            }, this.escapeHandler.bind(this));
            quill.keyboard.addBinding({
              key: Keys.UP
            }, this.upHandler.bind(this));
            quill.keyboard.addBinding({
              key: Keys.DOWN
            }, this.downHandler.bind(this));
          }
          _createClass$8(Mention, [{
            key: "selectHandler",
            value: function selectHandler() {
              if (this.isOpen && !this.existingSourceExecutionToken) {
                this.selectItem();
                return false;
              }
              return true;
            }
          }, {
            key: "escapeHandler",
            value: function escapeHandler() {
              if (this.isOpen) {
                if (this.existingSourceExecutionToken) {
                  this.existingSourceExecutionToken.abandoned = true;
                }
                this.hideMentionList();
                return false;
              }
              return true;
            }
          }, {
            key: "upHandler",
            value: function upHandler() {
              if (this.isOpen && !this.existingSourceExecutionToken) {
                this.prevItem();
                return false;
              }
              return true;
            }
          }, {
            key: "downHandler",
            value: function downHandler() {
              if (this.isOpen && !this.existingSourceExecutionToken) {
                this.nextItem();
                return false;
              }
              return true;
            }
          }, {
            key: "showMentionList",
            value: function showMentionList() {
              if (this.options.positioningStrategy === "fixed") {
                document.body.appendChild(this.mentionContainer);
              } else {
                this.quill.container.appendChild(this.mentionContainer);
              }
              this.mentionContainer.style.visibility = "hidden";
              this.mentionContainer.style.display = "";
              this.mentionContainer.scrollTop = 0;
              this.setMentionContainerPosition();
              this.setIsOpen(true);
            }
          }, {
            key: "hideMentionList",
            value: function hideMentionList() {
              this.options.onBeforeClose();
              this.mentionContainer.style.display = "none";
              this.mentionContainer.remove();
              this.setIsOpen(false);
              this.quill.root.removeAttribute("aria-activedescendant");
            }
          }, {
            key: "highlightItem",
            value: function highlightItem() {
              var scrollItemInView = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
              for (var i = 0; i < this.mentionList.childNodes.length; i += 1) {
                this.mentionList.childNodes[i].classList.remove("selected");
              }
              if (this.itemIndex === -1 || this.mentionList.childNodes[this.itemIndex].dataset.disabled === "true") {
                return;
              }
              this.mentionList.childNodes[this.itemIndex].classList.add("selected");
              this.quill.root.setAttribute("aria-activedescendant", this.mentionList.childNodes[this.itemIndex].id);
              if (scrollItemInView) {
                this.mentionList.childNodes[this.itemIndex].scrollIntoView({
                  behaviour: "smooth",
                  block: "nearest"
                });
              }
            }
          }, {
            key: "onContainerMouseMove",
            value: function onContainerMouseMove() {
              this.suspendMouseEnter = false;
            }
          }, {
            key: "selectItem",
            value: function selectItem() {
              var _this2 = this;
              if (this.itemIndex === -1) {
                return;
              }
              var data = this.mentionList.childNodes[this.itemIndex].dataset;
              if (data.disabled) {
                return;
              }
              this.options.onSelect(data, function (asyncData) {
                var programmaticInsert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                var overriddenOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                return _this2.insertItem(asyncData, programmaticInsert, overriddenOptions);
              });
              this.hideMentionList();
            }
          }, {
            key: "insertItem",
            value: function insertItem(data, programmaticInsert) {
              var overriddenOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              var render = data;
              if (render === null) {
                return;
              }
              var options = _objectSpread2$1(_objectSpread2$1({}, this.options), overriddenOptions);
              if (!options.showDenotationChar) {
                render.denotationChar = "";
              }
              var insertAtPos;
              if (!programmaticInsert) {
                insertAtPos = this.mentionCharPos;
                this.quill.deleteText(this.mentionCharPos, this.cursorPos - this.mentionCharPos, Quill.sources.USER);
              } else {
                insertAtPos = this.cursorPos;
              }
              var delta = this.quill.insertEmbed(insertAtPos, options.blotName, render, Quill.sources.USER);
              if (options.spaceAfterInsert) {
                this.quill.insertText(insertAtPos + 1, " ", Quill.sources.USER);
                // setSelection here sets cursor position
                this.quill.setSelection(insertAtPos + 2, Quill.sources.USER);
              } else {
                this.quill.setSelection(insertAtPos + 1, Quill.sources.USER);
              }
              this.hideMentionList();
              return delta;
            }
          }, {
            key: "onItemMouseEnter",
            value: function onItemMouseEnter(e) {
              if (this.suspendMouseEnter) {
                return;
              }
              var index = Number(e.target.dataset.index);
              if (!Number.isNaN(index) && index !== this.itemIndex) {
                this.itemIndex = index;
                this.highlightItem(false);
              }
            }
          }, {
            key: "onDisabledItemMouseEnter",
            value: function onDisabledItemMouseEnter(e) {
              if (this.suspendMouseEnter) {
                return;
              }
              this.itemIndex = -1;
              this.highlightItem(false);
            }
          }, {
            key: "onItemClick",
            value: function onItemClick(e) {
              if (e.button !== 0) {
                return;
              }
              e.preventDefault();
              e.stopImmediatePropagation();
              this.itemIndex = e.currentTarget.dataset.index;
              this.highlightItem();
              this.selectItem();
            }
          }, {
            key: "onItemMouseDown",
            value: function onItemMouseDown(e) {
              e.preventDefault();
              e.stopImmediatePropagation();
            }
          }, {
            key: "renderLoading",
            value: function renderLoading() {
              var renderedLoading = this.options.renderLoading();
              if (!renderedLoading) {
                return;
              }
              if (this.mentionContainer.getElementsByClassName("ql-mention-loading").length > 0) {
                this.showMentionList();
                return;
              }
              this.mentionList.innerHTML = "";
              var loadingDiv = document.createElement("div");
              loadingDiv.className = "ql-mention-loading";
              setInnerContent(loadingDiv, this.options.renderLoading());
              this.mentionContainer.append(loadingDiv);
              this.showMentionList();
            }
          }, {
            key: "removeLoading",
            value: function removeLoading() {
              var loadingDiv = this.mentionContainer.getElementsByClassName("ql-mention-loading");
              if (loadingDiv.length > 0) {
                loadingDiv[0].remove();
              }
            }
          }, {
            key: "renderList",
            value: function renderList(mentionChar, data, searchTerm) {
              if (data && data.length > 0) {
                this.removeLoading();
                this.values = data;
                this.mentionList.innerText = "";
                var initialSelection = -1;
                for (var i = 0; i < data.length; i += 1) {
                  var li = document.createElement("li");
                  li.id = "quill-mention-item-" + i;
                  li.className = this.options.listItemClass ? this.options.listItemClass : "";
                  if (data[i].disabled) {
                    li.className += " disabled";
                    li.setAttribute("aria-hidden", "true");
                  } else if (initialSelection === -1) {
                    initialSelection = i;
                  }
                  li.dataset.index = i;
                  var renderedItem = this.options.renderItem(data[i], searchTerm);
                  setInnerContent(li, renderedItem);
                  if (!data[i].disabled) {
                    li.onmouseenter = this.onItemMouseEnter.bind(this);
                    li.onmouseup = this.onItemClick.bind(this);
                    li.onmousedown = this.onItemMouseDown.bind(this);
                  } else {
                    li.onmouseenter = this.onDisabledItemMouseEnter.bind(this);
                  }
                  li.dataset.denotationChar = mentionChar;
                  this.mentionList.appendChild(attachDataValues(li, data[i], this.options.dataAttributes));
                }
                this.itemIndex = initialSelection;
                this.highlightItem();
                this.showMentionList();
              } else {
                this.hideMentionList();
              }
            }
          }, {
            key: "nextItem",
            value: function nextItem() {
              var increment = 0;
              var newIndex;
              do {
                increment++;
                newIndex = (this.itemIndex + increment) % this.values.length;
                var disabled = this.mentionList.childNodes[newIndex].dataset.disabled === "true";
                if (increment === this.values.length + 1) {
                  //we've wrapped around w/o finding an enabled item
                  newIndex = -1;
                  break;
                }
              } while (disabled);
              this.itemIndex = newIndex;
              this.suspendMouseEnter = true;
              this.highlightItem();
            }
          }, {
            key: "prevItem",
            value: function prevItem() {
              var decrement = 0;
              var newIndex;
              do {
                decrement++;
                newIndex = (this.itemIndex + this.values.length - decrement) % this.values.length;
                var disabled = this.mentionList.childNodes[newIndex].dataset.disabled === "true";
                if (decrement === this.values.length + 1) {
                  //we've wrapped around w/o finding an enabled item
                  newIndex = -1;
                  break;
                }
              } while (disabled);
              this.itemIndex = newIndex;
              this.suspendMouseEnter = true;
              this.highlightItem();
            }
          }, {
            key: "containerBottomIsNotVisible",
            value: function containerBottomIsNotVisible(topPos, containerPos) {
              var mentionContainerBottom = topPos + this.mentionContainer.offsetHeight + containerPos.top;
              return mentionContainerBottom > window.pageYOffset + window.innerHeight;
            }
          }, {
            key: "containerRightIsNotVisible",
            value: function containerRightIsNotVisible(leftPos, containerPos) {
              if (this.options.fixMentionsToQuill) {
                return false;
              }
              var rightPos = leftPos + this.mentionContainer.offsetWidth + containerPos.left;
              var browserWidth = window.pageXOffset + document.documentElement.clientWidth;
              return rightPos > browserWidth;
            }
          }, {
            key: "setIsOpen",
            value: function setIsOpen(isOpen) {
              if (this.isOpen !== isOpen) {
                if (isOpen) {
                  this.options.onOpen();
                } else {
                  this.options.onClose();
                }
                this.isOpen = isOpen;
              }
            }
          }, {
            key: "setMentionContainerPosition",
            value: function setMentionContainerPosition() {
              if (this.options.positioningStrategy === "fixed") {
                this.setMentionContainerPosition_Fixed();
              } else {
                this.setMentionContainerPosition_Normal();
              }
            }
          }, {
            key: "setMentionContainerPosition_Normal",
            value: function setMentionContainerPosition_Normal() {
              var _this3 = this;
              var containerPos = this.quill.container.getBoundingClientRect();
              var mentionCharPos = this.quill.getBounds(this.mentionCharPos);
              var containerHeight = this.mentionContainer.offsetHeight;
              var topPos = this.options.offsetTop;
              var leftPos = this.options.offsetLeft;

              // handle horizontal positioning
              if (this.options.fixMentionsToQuill) {
                var rightPos = 0;
                this.mentionContainer.style.right = "".concat(rightPos, "px");
              } else {
                leftPos += mentionCharPos.left;
              }
              if (this.containerRightIsNotVisible(leftPos, containerPos)) {
                var containerWidth = this.mentionContainer.offsetWidth + this.options.offsetLeft;
                var quillWidth = containerPos.width;
                leftPos = quillWidth - containerWidth;
              }

              // handle vertical positioning
              if (this.options.defaultMenuOrientation === "top") {
                // Attempt to align the mention container with the top of the quill editor
                if (this.options.fixMentionsToQuill) {
                  topPos = -1 * (containerHeight + this.options.offsetTop);
                } else {
                  topPos = mentionCharPos.top - (containerHeight + this.options.offsetTop);
                }

                // default to bottom if the top is not visible
                if (topPos + containerPos.top <= 0) {
                  var overMentionCharPos = this.options.offsetTop;
                  if (this.options.fixMentionsToQuill) {
                    overMentionCharPos += containerPos.height;
                  } else {
                    overMentionCharPos += mentionCharPos.bottom;
                  }
                  topPos = overMentionCharPos;
                }
              } else {
                // Attempt to align the mention container with the bottom of the quill editor
                if (this.options.fixMentionsToQuill) {
                  topPos += containerPos.height;
                } else {
                  topPos += mentionCharPos.bottom;
                }

                // default to the top if the bottom is not visible
                if (this.containerBottomIsNotVisible(topPos, containerPos)) {
                  var _overMentionCharPos = this.options.offsetTop * -1;
                  if (!this.options.fixMentionsToQuill) {
                    _overMentionCharPos += mentionCharPos.top;
                  }
                  topPos = _overMentionCharPos - containerHeight;
                }
              }
              if (topPos >= 0) {
                this.options.mentionContainerClass.split(" ").forEach(function (className) {
                  _this3.mentionContainer.classList.add("".concat(className, "-bottom"));
                  _this3.mentionContainer.classList.remove("".concat(className, "-top"));
                });
              } else {
                this.options.mentionContainerClass.split(" ").forEach(function (className) {
                  _this3.mentionContainer.classList.add("".concat(className, "-top"));
                  _this3.mentionContainer.classList.remove("".concat(className, "-bottom"));
                });
              }
              this.mentionContainer.style.top = "".concat(topPos, "px");
              this.mentionContainer.style.left = "".concat(leftPos, "px");
              this.mentionContainer.style.visibility = "visible";
            }
          }, {
            key: "setMentionContainerPosition_Fixed",
            value: function setMentionContainerPosition_Fixed() {
              var _this4 = this;
              this.mentionContainer.style.position = "fixed";
              this.mentionContainer.style.height = null;
              var containerPos = this.quill.container.getBoundingClientRect();
              var mentionCharPos = this.quill.getBounds(this.mentionCharPos);
              var mentionCharPosAbsolute = {
                left: containerPos.left + mentionCharPos.left,
                top: containerPos.top + mentionCharPos.top,
                width: 0,
                height: mentionCharPos.height
              };

              //Which rectangle should it be relative to
              var relativeToPos = this.options.fixMentionsToQuill ? containerPos : mentionCharPosAbsolute;
              var topPos = this.options.offsetTop;
              var leftPos = this.options.offsetLeft;

              // handle horizontal positioning
              if (this.options.fixMentionsToQuill) {
                var rightPos = relativeToPos.right;
                this.mentionContainer.style.right = "".concat(rightPos, "px");
              } else {
                leftPos += relativeToPos.left;

                //if its off the righ edge, push it back
                if (leftPos + this.mentionContainer.offsetWidth > document.documentElement.clientWidth) {
                  leftPos -= leftPos + this.mentionContainer.offsetWidth - document.documentElement.clientWidth;
                }
              }
              var availableSpaceTop = relativeToPos.top;
              var availableSpaceBottom = document.documentElement.clientHeight - (relativeToPos.top + relativeToPos.height);
              var fitsBottom = this.mentionContainer.offsetHeight <= availableSpaceBottom;
              var fitsTop = this.mentionContainer.offsetHeight <= availableSpaceTop;
              var placement;
              if (this.options.defaultMenuOrientation === "top" && fitsTop) {
                placement = "top";
              } else if (this.options.defaultMenuOrientation === "bottom" && fitsBottom) {
                placement = "bottom";
              } else {
                //it doesnt fit either so put it where there's the most space
                placement = availableSpaceBottom > availableSpaceTop ? "bottom" : "top";
              }
              if (placement === "bottom") {
                topPos = relativeToPos.top + relativeToPos.height;
                if (!fitsBottom) {
                  //shrink it to fit
                  //3 is a bit of a fudge factor so it doesnt touch the edge of the screen
                  this.mentionContainer.style.height = availableSpaceBottom - 3 + "px";
                }
                this.options.mentionContainerClass.split(" ").forEach(function (className) {
                  _this4.mentionContainer.classList.add("".concat(className, "-bottom"));
                  _this4.mentionContainer.classList.remove("".concat(className, "-top"));
                });
              } else {
                topPos = relativeToPos.top - this.mentionContainer.offsetHeight;
                if (!fitsTop) {
                  //shrink it to fit
                  //3 is a bit of a fudge factor so it doesnt touch the edge of the screen
                  this.mentionContainer.style.height = availableSpaceTop - 3 + "px";
                  topPos = 3;
                }
                this.options.mentionContainerClass.split(" ").forEach(function (className) {
                  _this4.mentionContainer.classList.add("".concat(className, "-top"));
                  _this4.mentionContainer.classList.remove("".concat(className, "-bottom"));
                });
              }
              this.mentionContainer.style.top = "".concat(topPos, "px");
              this.mentionContainer.style.left = "".concat(leftPos, "px");
              this.mentionContainer.style.visibility = "visible";
            }
          }, {
            key: "getTextBeforeCursor",
            value: function getTextBeforeCursor() {
              var startPos = Math.max(0, this.cursorPos - this.options.maxChars);
              var textBeforeCursorPos = this.quill.getText(startPos, this.cursorPos - startPos);
              return textBeforeCursorPos;
            }
          }, {
            key: "onSomethingChange",
            value: function onSomethingChange() {
              var _this5 = this;
              var range = this.quill.getSelection();
              if (range == null) return;
              this.cursorPos = range.index;
              var textBeforeCursor = this.getTextBeforeCursor();
              var textOffset = Math.max(0, this.cursorPos - this.options.maxChars);
              var textPrefix = textOffset ? this.quill.getText(textOffset - 1, textOffset) : "";
              var _getMentionCharIndex = getMentionCharIndex(textBeforeCursor, this.options.mentionDenotationChars, this.options.isolateCharacter, this.options.allowInlineMentionChar),
                mentionChar = _getMentionCharIndex.mentionChar,
                mentionCharIndex = _getMentionCharIndex.mentionCharIndex;
              if (hasValidMentionCharIndex(mentionCharIndex, textBeforeCursor, this.options.isolateCharacter, textPrefix)) {
                var mentionCharPos = this.cursorPos - (textBeforeCursor.length - mentionCharIndex);
                this.mentionCharPos = mentionCharPos;
                var textAfter = textBeforeCursor.substring(mentionCharIndex + mentionChar.length);
                if (textAfter.length >= this.options.minChars && hasValidChars(textAfter, this.getAllowedCharsRegex(mentionChar))) {
                  if (this.existingSourceExecutionToken) {
                    this.existingSourceExecutionToken.abandoned = true;
                  }
                  this.renderLoading();
                  var sourceRequestToken = {
                    abandoned: false
                  };
                  this.existingSourceExecutionToken = sourceRequestToken;
                  this.options.source(textAfter, function (data, searchTerm) {
                    if (sourceRequestToken.abandoned) {
                      return;
                    }
                    _this5.existingSourceExecutionToken = null;
                    _this5.renderList(mentionChar, data, searchTerm);
                  }, mentionChar);
                } else {
                  if (this.existingSourceExecutionToken) {
                    this.existingSourceExecutionToken.abandoned = true;
                  }
                  this.hideMentionList();
                }
              } else {
                if (this.existingSourceExecutionToken) {
                  this.existingSourceExecutionToken.abandoned = true;
                }
                this.hideMentionList();
              }
            }
          }, {
            key: "getAllowedCharsRegex",
            value: function getAllowedCharsRegex(denotationChar) {
              if (this.options.allowedChars instanceof RegExp) {
                return this.options.allowedChars;
              } else {
                return this.options.allowedChars(denotationChar);
              }
            }
          }, {
            key: "onTextChange",
            value: function onTextChange(delta, oldDelta, source) {
              if (source === "user") {
                this.onSomethingChange();
              }
            }
          }, {
            key: "onSelectionChange",
            value: function onSelectionChange(range) {
              if (range && range.length === 0) {
                this.onSomethingChange();
              } else {
                this.hideMentionList();
              }
            }
          }, {
            key: "openMenu",
            value: function openMenu(denotationChar) {
              var selection = this.quill.getSelection(true);
              this.quill.insertText(selection.index, denotationChar);
              this.quill.blur();
              this.quill.focus();
            }
          }]);
          return Mention;
        }();
        Quill.register("modules/mention", Mention);

        /**
         * This library modifies the diff-patch-match library by Neil Fraser
         * by removing the patch and match functionality and certain advanced
         * options in the diff function. The original license is as follows:
         *
         * ===
         *
         * Diff Match and Patch
         *
         * Copyright 2006 Google Inc.
         * http://code.google.com/p/google-diff-match-patch/
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * The data structure representing a diff is an array of tuples:
         * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
         * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
         */
        var DIFF_DELETE = -1;
        var DIFF_INSERT = 1;
        var DIFF_EQUAL = 0;

        /**
         * Find the differences between two texts.  Simplifies the problem by stripping
         * any common prefix or suffix off the texts before diffing.
         * @param {string} text1 Old string to be diffed.
         * @param {string} text2 New string to be diffed.
         * @param {Int} cursor_pos Expected edit position in text1 (optional)
         * @return {Array} Array of diff tuples.
         */
        function diff_main(text1, text2, cursor_pos) {
          // Check for equality (speedup).
          if (text1 == text2) {
            if (text1) {
              return [[DIFF_EQUAL, text1]];
            }
            return [];
          }

          // Check cursor_pos within bounds
          if (cursor_pos < 0 || text1.length < cursor_pos) {
            cursor_pos = null;
          }

          // Trim off common prefix (speedup).
          var commonlength = diff_commonPrefix(text1, text2);
          var commonprefix = text1.substring(0, commonlength);
          text1 = text1.substring(commonlength);
          text2 = text2.substring(commonlength);

          // Trim off common suffix (speedup).
          commonlength = diff_commonSuffix(text1, text2);
          var commonsuffix = text1.substring(text1.length - commonlength);
          text1 = text1.substring(0, text1.length - commonlength);
          text2 = text2.substring(0, text2.length - commonlength);

          // Compute the diff on the middle block.
          var diffs = diff_compute_(text1, text2);

          // Restore the prefix and suffix.
          if (commonprefix) {
            diffs.unshift([DIFF_EQUAL, commonprefix]);
          }
          if (commonsuffix) {
            diffs.push([DIFF_EQUAL, commonsuffix]);
          }
          diff_cleanupMerge(diffs);
          if (cursor_pos != null) {
            diffs = fix_cursor(diffs, cursor_pos);
          }
          diffs = fix_emoji(diffs);
          return diffs;
        }

        /**
         * Find the differences between two texts.  Assumes that the texts do not
         * have any common prefix or suffix.
         * @param {string} text1 Old string to be diffed.
         * @param {string} text2 New string to be diffed.
         * @return {Array} Array of diff tuples.
         */
        function diff_compute_(text1, text2) {
          var diffs;
          if (!text1) {
            // Just add some text (speedup).
            return [[DIFF_INSERT, text2]];
          }
          if (!text2) {
            // Just delete some text (speedup).
            return [[DIFF_DELETE, text1]];
          }
          var longtext = text1.length > text2.length ? text1 : text2;
          var shorttext = text1.length > text2.length ? text2 : text1;
          var i = longtext.indexOf(shorttext);
          if (i != -1) {
            // Shorter text is inside the longer text (speedup).
            diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
            // Swap insertions for deletions if diff is reversed.
            if (text1.length > text2.length) {
              diffs[0][0] = diffs[2][0] = DIFF_DELETE;
            }
            return diffs;
          }
          if (shorttext.length == 1) {
            // Single character string.
            // After the previous speedup, the character can't be an equality.
            return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
          }

          // Check to see if the problem can be split in two.
          var hm = diff_halfMatch_(text1, text2);
          if (hm) {
            // A half-match was found, sort out the return data.
            var text1_a = hm[0];
            var text1_b = hm[1];
            var text2_a = hm[2];
            var text2_b = hm[3];
            var mid_common = hm[4];
            // Send both pairs off for separate processing.
            var diffs_a = diff_main(text1_a, text2_a);
            var diffs_b = diff_main(text1_b, text2_b);
            // Merge the results.
            return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
          }
          return diff_bisect_(text1, text2);
        }

        /**
         * Find the 'middle snake' of a diff, split the problem in two
         * and return the recursively constructed diff.
         * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
         * @param {string} text1 Old string to be diffed.
         * @param {string} text2 New string to be diffed.
         * @return {Array} Array of diff tuples.
         * @private
         */
        function diff_bisect_(text1, text2) {
          // Cache the text lengths to prevent multiple calls.
          var text1_length = text1.length;
          var text2_length = text2.length;
          var max_d = Math.ceil((text1_length + text2_length) / 2);
          var v_offset = max_d;
          var v_length = 2 * max_d;
          var v1 = new Array(v_length);
          var v2 = new Array(v_length);
          // Setting all elements to -1 is faster in Chrome & Firefox than mixing
          // integers and undefined.
          for (var x = 0; x < v_length; x++) {
            v1[x] = -1;
            v2[x] = -1;
          }
          v1[v_offset + 1] = 0;
          v2[v_offset + 1] = 0;
          var delta = text1_length - text2_length;
          // If the total number of characters is odd, then the front path will collide
          // with the reverse path.
          var front = delta % 2 != 0;
          // Offsets for start and end of k loop.
          // Prevents mapping of space beyond the grid.
          var k1start = 0;
          var k1end = 0;
          var k2start = 0;
          var k2end = 0;
          for (var d = 0; d < max_d; d++) {
            // Walk the front path one step.
            for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
              var k1_offset = v_offset + k1;
              var x1;
              if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
                x1 = v1[k1_offset + 1];
              } else {
                x1 = v1[k1_offset - 1] + 1;
              }
              var y1 = x1 - k1;
              while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
                x1++;
                y1++;
              }
              v1[k1_offset] = x1;
              if (x1 > text1_length) {
                // Ran off the right of the graph.
                k1end += 2;
              } else if (y1 > text2_length) {
                // Ran off the bottom of the graph.
                k1start += 2;
              } else if (front) {
                var k2_offset = v_offset + delta - k1;
                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
                  // Mirror x2 onto top-left coordinate system.
                  var x2 = text1_length - v2[k2_offset];
                  if (x1 >= x2) {
                    // Overlap detected.
                    return diff_bisectSplit_(text1, text2, x1, y1);
                  }
                }
              }
            }

            // Walk the reverse path one step.
            for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
              var k2_offset = v_offset + k2;
              var x2;
              if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
                x2 = v2[k2_offset + 1];
              } else {
                x2 = v2[k2_offset - 1] + 1;
              }
              var y2 = x2 - k2;
              while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
                x2++;
                y2++;
              }
              v2[k2_offset] = x2;
              if (x2 > text1_length) {
                // Ran off the left of the graph.
                k2end += 2;
              } else if (y2 > text2_length) {
                // Ran off the top of the graph.
                k2start += 2;
              } else if (!front) {
                var k1_offset = v_offset + delta - k2;
                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                  var x1 = v1[k1_offset];
                  var y1 = v_offset + x1 - k1_offset;
                  // Mirror x2 onto top-left coordinate system.
                  x2 = text1_length - x2;
                  if (x1 >= x2) {
                    // Overlap detected.
                    return diff_bisectSplit_(text1, text2, x1, y1);
                  }
                }
              }
            }
          }
          // Diff took too long and hit the deadline or
          // number of diffs equals number of characters, no commonality at all.
          return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
        }

        /**
         * Given the location of the 'middle snake', split the diff in two parts
         * and recurse.
         * @param {string} text1 Old string to be diffed.
         * @param {string} text2 New string to be diffed.
         * @param {number} x Index of split point in text1.
         * @param {number} y Index of split point in text2.
         * @return {Array} Array of diff tuples.
         */
        function diff_bisectSplit_(text1, text2, x, y) {
          var text1a = text1.substring(0, x);
          var text2a = text2.substring(0, y);
          var text1b = text1.substring(x);
          var text2b = text2.substring(y);

          // Compute both diffs serially.
          var diffs = diff_main(text1a, text2a);
          var diffsb = diff_main(text1b, text2b);
          return diffs.concat(diffsb);
        }

        /**
         * Determine the common prefix of two strings.
         * @param {string} text1 First string.
         * @param {string} text2 Second string.
         * @return {number} The number of characters common to the start of each
         *     string.
         */
        function diff_commonPrefix(text1, text2) {
          // Quick check for common null cases.
          if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
            return 0;
          }
          // Binary search.
          // Performance analysis: http://neil.fraser.name/news/2007/10/09/
          var pointermin = 0;
          var pointermax = Math.min(text1.length, text2.length);
          var pointermid = pointermax;
          var pointerstart = 0;
          while (pointermin < pointermid) {
            if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
              pointermin = pointermid;
              pointerstart = pointermin;
            } else {
              pointermax = pointermid;
            }
            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
          }
          return pointermid;
        }

        /**
         * Determine the common suffix of two strings.
         * @param {string} text1 First string.
         * @param {string} text2 Second string.
         * @return {number} The number of characters common to the end of each string.
         */
        function diff_commonSuffix(text1, text2) {
          // Quick check for common null cases.
          if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
            return 0;
          }
          // Binary search.
          // Performance analysis: http://neil.fraser.name/news/2007/10/09/
          var pointermin = 0;
          var pointermax = Math.min(text1.length, text2.length);
          var pointermid = pointermax;
          var pointerend = 0;
          while (pointermin < pointermid) {
            if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
              pointermin = pointermid;
              pointerend = pointermin;
            } else {
              pointermax = pointermid;
            }
            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
          }
          return pointermid;
        }

        /**
         * Do the two texts share a substring which is at least half the length of the
         * longer text?
         * This speedup can produce non-minimal diffs.
         * @param {string} text1 First string.
         * @param {string} text2 Second string.
         * @return {Array.<string>} Five element Array, containing the prefix of
         *     text1, the suffix of text1, the prefix of text2, the suffix of
         *     text2 and the common middle.  Or null if there was no match.
         */
        function diff_halfMatch_(text1, text2) {
          var longtext = text1.length > text2.length ? text1 : text2;
          var shorttext = text1.length > text2.length ? text2 : text1;
          if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
            return null; // Pointless.
          }

          /**
           * Does a substring of shorttext exist within longtext such that the substring
           * is at least half the length of longtext?
           * Closure, but does not reference any external variables.
           * @param {string} longtext Longer string.
           * @param {string} shorttext Shorter string.
           * @param {number} i Start index of quarter length substring within longtext.
           * @return {Array.<string>} Five element Array, containing the prefix of
           *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
           *     of shorttext and the common middle.  Or null if there was no match.
           * @private
           */
          function diff_halfMatchI_(longtext, shorttext, i) {
            // Start with a 1/4 length substring at position i as a seed.
            var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
            var j = -1;
            var best_common = '';
            var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
            while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
              var prefixLength = diff_commonPrefix(longtext.substring(i), shorttext.substring(j));
              var suffixLength = diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));
              if (best_common.length < suffixLength + prefixLength) {
                best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
                best_longtext_a = longtext.substring(0, i - suffixLength);
                best_longtext_b = longtext.substring(i + prefixLength);
                best_shorttext_a = shorttext.substring(0, j - suffixLength);
                best_shorttext_b = shorttext.substring(j + prefixLength);
              }
            }
            if (best_common.length * 2 >= longtext.length) {
              return [best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common];
            } else {
              return null;
            }
          }

          // First check if the second quarter is the seed for a half-match.
          var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
          // Check again based on the third quarter.
          var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
          var hm;
          if (!hm1 && !hm2) {
            return null;
          } else if (!hm2) {
            hm = hm1;
          } else if (!hm1) {
            hm = hm2;
          } else {
            // Both matched.  Select the longest.
            hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
          }

          // A half-match was found, sort out the return data.
          var text1_a, text1_b, text2_a, text2_b;
          if (text1.length > text2.length) {
            text1_a = hm[0];
            text1_b = hm[1];
            text2_a = hm[2];
            text2_b = hm[3];
          } else {
            text2_a = hm[0];
            text2_b = hm[1];
            text1_a = hm[2];
            text1_b = hm[3];
          }
          var mid_common = hm[4];
          return [text1_a, text1_b, text2_a, text2_b, mid_common];
        }

        /**
         * Reorder and merge like edit sections.  Merge equalities.
         * Any edit section can move as long as it doesn't cross an equality.
         * @param {Array} diffs Array of diff tuples.
         */
        function diff_cleanupMerge(diffs) {
          diffs.push([DIFF_EQUAL, '']); // Add a dummy entry at the end.
          var pointer = 0;
          var count_delete = 0;
          var count_insert = 0;
          var text_delete = '';
          var text_insert = '';
          var commonlength;
          while (pointer < diffs.length) {
            switch (diffs[pointer][0]) {
              case DIFF_INSERT:
                count_insert++;
                text_insert += diffs[pointer][1];
                pointer++;
                break;
              case DIFF_DELETE:
                count_delete++;
                text_delete += diffs[pointer][1];
                pointer++;
                break;
              case DIFF_EQUAL:
                // Upon reaching an equality, check for prior redundancies.
                if (count_delete + count_insert > 1) {
                  if (count_delete !== 0 && count_insert !== 0) {
                    // Factor out any common prefixies.
                    commonlength = diff_commonPrefix(text_insert, text_delete);
                    if (commonlength !== 0) {
                      if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                        diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                      } else {
                        diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                        pointer++;
                      }
                      text_insert = text_insert.substring(commonlength);
                      text_delete = text_delete.substring(commonlength);
                    }
                    // Factor out any common suffixies.
                    commonlength = diff_commonSuffix(text_insert, text_delete);
                    if (commonlength !== 0) {
                      diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                      text_insert = text_insert.substring(0, text_insert.length - commonlength);
                      text_delete = text_delete.substring(0, text_delete.length - commonlength);
                    }
                  }
                  // Delete the offending records and add the merged ones.
                  if (count_delete === 0) {
                    diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT, text_insert]);
                  } else if (count_insert === 0) {
                    diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE, text_delete]);
                  } else {
                    diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
                  }
                  pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
                } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                  // Merge this equality with the previous one.
                  diffs[pointer - 1][1] += diffs[pointer][1];
                  diffs.splice(pointer, 1);
                } else {
                  pointer++;
                }
                count_insert = 0;
                count_delete = 0;
                text_delete = '';
                text_insert = '';
                break;
            }
          }
          if (diffs[diffs.length - 1][1] === '') {
            diffs.pop(); // Remove the dummy entry at the end.
          }

          // Second pass: look for single edits surrounded on both sides by equalities
          // which can be shifted sideways to eliminate an equality.
          // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
          var changes = false;
          pointer = 1;
          // Intentionally ignore the first and last element (don't need checking).
          while (pointer < diffs.length - 1) {
            if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
              // This is a single edit surrounded by equalities.
              if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                // Shift the edit over the previous equality.
                diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                diffs.splice(pointer - 1, 1);
                changes = true;
              } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
                // Shift the edit over the next equality.
                diffs[pointer - 1][1] += diffs[pointer + 1][1];
                diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                diffs.splice(pointer + 1, 1);
                changes = true;
              }
            }
            pointer++;
          }
          // If shifts were made, the diff needs reordering and another shift sweep.
          if (changes) {
            diff_cleanupMerge(diffs);
          }
        }
        var diff$2 = diff_main;
        diff$2.INSERT = DIFF_INSERT;
        diff$2.DELETE = DIFF_DELETE;
        diff$2.EQUAL = DIFF_EQUAL;
        var diff_1 = diff$2;

        /*
         * Modify a diff such that the cursor position points to the start of a change:
         * E.g.
         *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
         *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
         *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
         *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
         *
         * @param {Array} diffs Array of diff tuples
         * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
         * @return {Array} A tuple [cursor location in the modified diff, modified diff]
         */
        function cursor_normalize_diff(diffs, cursor_pos) {
          if (cursor_pos === 0) {
            return [DIFF_EQUAL, diffs];
          }
          for (var current_pos = 0, i = 0; i < diffs.length; i++) {
            var d = diffs[i];
            if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {
              var next_pos = current_pos + d[1].length;
              if (cursor_pos === next_pos) {
                return [i + 1, diffs];
              } else if (cursor_pos < next_pos) {
                // copy to prevent side effects
                diffs = diffs.slice();
                // split d into two diff changes
                var split_pos = cursor_pos - current_pos;
                var d_left = [d[0], d[1].slice(0, split_pos)];
                var d_right = [d[0], d[1].slice(split_pos)];
                diffs.splice(i, 1, d_left, d_right);
                return [i + 1, diffs];
              } else {
                current_pos = next_pos;
              }
            }
          }
          throw new Error('cursor_pos is out of bounds!');
        }

        /*
         * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
         *
         * Case 1)
         *   Check if a naive shift is possible:
         *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
         *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
         * Case 2)
         *   Check if the following shifts are possible:
         *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
         *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
         *         ^            ^
         *         d          d_next
         *
         * @param {Array} diffs Array of diff tuples
         * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
         * @return {Array} Array of diff tuples
         */
        function fix_cursor(diffs, cursor_pos) {
          var norm = cursor_normalize_diff(diffs, cursor_pos);
          var ndiffs = norm[1];
          var cursor_pointer = norm[0];
          var d = ndiffs[cursor_pointer];
          var d_next = ndiffs[cursor_pointer + 1];
          if (d == null) {
            // Text was deleted from end of original string,
            // cursor is now out of bounds in new string
            return diffs;
          } else if (d[0] !== DIFF_EQUAL) {
            // A modification happened at the cursor location.
            // This is the expected outcome, so we can return the original diff.
            return diffs;
          } else {
            if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
              // Case 1)
              // It is possible to perform a naive shift
              ndiffs.splice(cursor_pointer, 2, d_next, d);
              return merge_tuples(ndiffs, cursor_pointer, 2);
            } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
              // Case 2)
              // d[1] is a prefix of d_next[1]
              // We can assume that d_next[0] !== 0, since d[0] === 0
              // Shift edit locations..
              ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
              var suffix = d_next[1].slice(d[1].length);
              if (suffix.length > 0) {
                ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
              }
              return merge_tuples(ndiffs, cursor_pointer, 3);
            } else {
              // Not possible to perform any modification
              return diffs;
            }
          }
        }

        /*
         * Check diff did not split surrogate pairs.
         * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
         *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
         *
         * @param {Array} diffs Array of diff tuples
         * @return {Array} Array of diff tuples
         */
        function fix_emoji(diffs) {
          var compact = false;
          var starts_with_pair_end = function starts_with_pair_end(str) {
            return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
          };
          var ends_with_pair_start = function ends_with_pair_start(str) {
            return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;
          };
          for (var i = 2; i < diffs.length; i += 1) {
            if (diffs[i - 2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i - 2][1]) && diffs[i - 1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i - 1][1]) && diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {
              compact = true;
              diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
              diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
              diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
            }
          }
          if (!compact) {
            return diffs;
          }
          var fixed_diffs = [];
          for (var i = 0; i < diffs.length; i += 1) {
            if (diffs[i][1].length > 0) {
              fixed_diffs.push(diffs[i]);
            }
          }
          return fixed_diffs;
        }

        /*
         * Try to merge tuples with their neigbors in a given range.
         * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
         *
         * @param {Array} diffs Array of diff tuples.
         * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
         * @param {Int} length Number of consecutive elements to check.
         * @return {Array} Array of merged diff tuples.
         */
        function merge_tuples(diffs, start, length) {
          // Check from (start-1) to (start+length).
          for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
            if (i + 1 < diffs.length) {
              var left_d = diffs[i];
              var right_d = diffs[i + 1];
              if (left_d[0] === right_d[1]) {
                diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
              }
            }
          }
          return diffs;
        }
        var toStr$4 = Object.prototype.toString;
        var isArguments$6 = function isArguments(value) {
          var str = toStr$4.call(value);
          var isArgs = str === '[object Arguments]';
          if (!isArgs) {
            isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr$4.call(value.callee) === '[object Function]';
          }
          return isArgs;
        };
        var implementation$8;
        var hasRequiredImplementation;
        function requireImplementation() {
          if (hasRequiredImplementation) return implementation$8;
          hasRequiredImplementation = 1;
          var keysShim;
          if (!Object.keys) {
            // modified from https://github.com/es-shims/es5-shim
            var has = Object.prototype.hasOwnProperty;
            var toStr = Object.prototype.toString;
            var isArgs = isArguments$6; // eslint-disable-line global-require
            var isEnumerable = Object.prototype.propertyIsEnumerable;
            var hasDontEnumBug = !isEnumerable.call({
              toString: null
            }, 'toString');
            var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
            var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
            var equalsConstructorPrototype = function equalsConstructorPrototype(o) {
              var ctor = o.constructor;
              return ctor && ctor.prototype === o;
            };
            var excludedKeys = {
              $applicationCache: true,
              $console: true,
              $external: true,
              $frame: true,
              $frameElement: true,
              $frames: true,
              $innerHeight: true,
              $innerWidth: true,
              $onmozfullscreenchange: true,
              $onmozfullscreenerror: true,
              $outerHeight: true,
              $outerWidth: true,
              $pageXOffset: true,
              $pageYOffset: true,
              $parent: true,
              $scrollLeft: true,
              $scrollTop: true,
              $scrollX: true,
              $scrollY: true,
              $self: true,
              $webkitIndexedDB: true,
              $webkitStorageInfo: true,
              $window: true
            };
            var hasAutomationEqualityBug = function () {
              /* global window */
              if (typeof window === 'undefined') {
                return false;
              }
              for (var k in window) {
                try {
                  if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
                    try {
                      equalsConstructorPrototype(window[k]);
                    } catch (e) {
                      return true;
                    }
                  }
                } catch (e) {
                  return true;
                }
              }
              return false;
            }();
            var equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy(o) {
              /* global window */
              if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
                return equalsConstructorPrototype(o);
              }
              try {
                return equalsConstructorPrototype(o);
              } catch (e) {
                return false;
              }
            };
            keysShim = function keys(object) {
              var isObject = object !== null && typeof object === 'object';
              var isFunction = toStr.call(object) === '[object Function]';
              var isArguments = isArgs(object);
              var isString = isObject && toStr.call(object) === '[object String]';
              var theKeys = [];
              if (!isObject && !isFunction && !isArguments) {
                throw new TypeError('Object.keys called on a non-object');
              }
              var skipProto = hasProtoEnumBug && isFunction;
              if (isString && object.length > 0 && !has.call(object, 0)) {
                for (var i = 0; i < object.length; ++i) {
                  theKeys.push(String(i));
                }
              }
              if (isArguments && object.length > 0) {
                for (var j = 0; j < object.length; ++j) {
                  theKeys.push(String(j));
                }
              } else {
                for (var name in object) {
                  if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                    theKeys.push(String(name));
                  }
                }
              }
              if (hasDontEnumBug) {
                var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                for (var k = 0; k < dontEnums.length; ++k) {
                  if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                    theKeys.push(dontEnums[k]);
                  }
                }
              }
              return theKeys;
            };
          }
          implementation$8 = keysShim;
          return implementation$8;
        }
        var slice = Array.prototype.slice;
        var isArgs = isArguments$6;
        var origKeys = Object.keys;
        var keysShim = origKeys ? function keys(o) {
          return origKeys(o);
        } : requireImplementation();
        var originalKeys = Object.keys;
        keysShim.shim = function shimObjectKeys() {
          if (Object.keys) {
            var keysWorksWithArguments = function () {
              // Safari 5.0 bug
              var args = Object.keys(arguments);
              return args && args.length === arguments.length;
            }(1, 2);
            if (!keysWorksWithArguments) {
              Object.keys = function keys(object) {
                // eslint-disable-line func-name-matching
                if (isArgs(object)) {
                  return originalKeys(slice.call(object));
                }
                return originalKeys(object);
              };
            }
          } else {
            Object.keys = keysShim;
          }
          return Object.keys || keysShim;
        };
        var objectKeys$1 = keysShim;

        /* eslint complexity: [2, 18], max-statements: [2, 33] */
        var shams$1 = function hasSymbols() {
          if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
            return false;
          }
          if (typeof Symbol.iterator === 'symbol') {
            return true;
          }
          var obj = {};
          var sym = Symbol('test');
          var symObj = Object(sym);
          if (typeof sym === 'string') {
            return false;
          }
          if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
            return false;
          }
          if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
            return false;
          }

          // temp disabled per https://github.com/ljharb/object.assign/issues/17
          // if (sym instanceof Symbol) { return false; }
          // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
          // if (!(symObj instanceof Symbol)) { return false; }

          // if (typeof Symbol.prototype.toString !== 'function') { return false; }
          // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

          var symVal = 42;
          obj[sym] = symVal;
          for (sym in obj) {
            return false;
          } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
          if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
            return false;
          }
          if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
            return false;
          }
          var syms = Object.getOwnPropertySymbols(obj);
          if (syms.length !== 1 || syms[0] !== sym) {
            return false;
          }
          if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
            return false;
          }
          if (typeof Object.getOwnPropertyDescriptor === 'function') {
            var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
            if (descriptor.value !== symVal || descriptor.enumerable !== true) {
              return false;
            }
          }
          return true;
        };
        var hasSymbols$3 = shams$1;

        /** @type {import('.')} */
        var shams = function hasToStringTagShams() {
          return hasSymbols$3() && !!Symbol.toStringTag;
        };

        /** @type {import('.')} */
        var esErrors = Error;

        /** @type {import('./eval')} */
        var _eval = EvalError;

        /** @type {import('./range')} */
        var range$2 = RangeError;

        /** @type {import('./ref')} */
        var ref = ReferenceError;

        /** @type {import('./syntax')} */
        var syntax = SyntaxError;

        /** @type {import('./type')} */
        var type$1 = TypeError;

        /** @type {import('./uri')} */
        var uri = URIError;
        var origSymbol = typeof Symbol !== 'undefined' && Symbol;
        var hasSymbolSham = shams$1;
        var hasSymbols$2 = function hasNativeSymbols() {
          if (typeof origSymbol !== 'function') {
            return false;
          }
          if (typeof Symbol !== 'function') {
            return false;
          }
          if (typeof origSymbol('foo') !== 'symbol') {
            return false;
          }
          if (typeof Symbol('bar') !== 'symbol') {
            return false;
          }
          return hasSymbolSham();
        };
        var test = {
          __proto__: null,
          foo: {}
        };
        var $Object$1 = Object;

        /** @type {import('.')} */
        var hasProto$1 = function hasProto() {
          // @ts-expect-error: TS errors on an inherited property for some reason
          return {
            __proto__: test
          }.foo === test.foo && !(test instanceof $Object$1);
        };

        /* eslint no-invalid-this: 1 */

        var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
        var toStr$3 = Object.prototype.toString;
        var max$2 = Math.max;
        var funcType = '[object Function]';
        var concatty = function concatty(a, b) {
          var arr = [];
          for (var i = 0; i < a.length; i += 1) {
            arr[i] = a[i];
          }
          for (var j = 0; j < b.length; j += 1) {
            arr[j + a.length] = b[j];
          }
          return arr;
        };
        var slicy = function slicy(arrLike, offset) {
          var arr = [];
          for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
            arr[j] = arrLike[i];
          }
          return arr;
        };
        var joiny = function joiny(arr, joiner) {
          var str = '';
          for (var i = 0; i < arr.length; i += 1) {
            str += arr[i];
            if (i + 1 < arr.length) {
              str += joiner;
            }
          }
          return str;
        };
        var implementation$7 = function bind(that) {
          var target = this;
          if (typeof target !== 'function' || toStr$3.apply(target) !== funcType) {
            throw new TypeError(ERROR_MESSAGE + target);
          }
          var args = slicy(arguments, 1);
          var bound;
          var binder = function binder() {
            if (this instanceof bound) {
              var result = target.apply(this, concatty(args, arguments));
              if (Object(result) === result) {
                return result;
              }
              return this;
            }
            return target.apply(that, concatty(args, arguments));
          };
          var boundLength = max$2(0, target.length - args.length);
          var boundArgs = [];
          for (var i = 0; i < boundLength; i++) {
            boundArgs[i] = '$' + i;
          }
          bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
          if (target.prototype) {
            var Empty = function Empty() {};
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
          }
          return bound;
        };
        var implementation$6 = implementation$7;
        var functionBind = Function.prototype.bind || implementation$6;
        var call$1 = Function.prototype.call;
        var $hasOwn = Object.prototype.hasOwnProperty;
        var bind$1 = functionBind;

        /** @type {import('.')} */
        var hasown = bind$1.call(call$1, $hasOwn);
        var undefined$1;
        var $Error = esErrors;
        var $EvalError = _eval;
        var $RangeError = range$2;
        var $ReferenceError = ref;
        var $SyntaxError$1 = syntax;
        var $TypeError$4 = type$1;
        var $URIError = uri;
        var $Function = Function;

        // eslint-disable-next-line consistent-return
        var getEvalledConstructor = function getEvalledConstructor(expressionSyntax) {
          try {
            return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
          } catch (e) {}
        };
        var $gOPD$2 = Object.getOwnPropertyDescriptor;
        if ($gOPD$2) {
          try {
            $gOPD$2({}, '');
          } catch (e) {
            $gOPD$2 = null; // this is IE 8, which has a broken gOPD
          }
        }
        var throwTypeError = function throwTypeError() {
          throw new $TypeError$4();
        };
        var ThrowTypeError = $gOPD$2 ? function () {
          try {
            // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
            arguments.callee; // IE 8 does not throw here
            return throwTypeError;
          } catch (calleeThrows) {
            try {
              // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
              return $gOPD$2(arguments, 'callee').get;
            } catch (gOPDthrows) {
              return throwTypeError;
            }
          }
        }() : throwTypeError;
        var hasSymbols$1 = hasSymbols$2();
        var hasProto = hasProto$1();
        var getProto$1 = Object.getPrototypeOf || (hasProto ? function (x) {
          return x.__proto__;
        } // eslint-disable-line no-proto
        : null);
        var needsEval = {};
        var TypedArray = typeof Uint8Array === 'undefined' || !getProto$1 ? undefined$1 : getProto$1(Uint8Array);
        var INTRINSICS = {
          __proto__: null,
          '%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
          '%Array%': Array,
          '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
          '%ArrayIteratorPrototype%': hasSymbols$1 && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
          '%AsyncFromSyncIteratorPrototype%': undefined$1,
          '%AsyncFunction%': needsEval,
          '%AsyncGenerator%': needsEval,
          '%AsyncGeneratorFunction%': needsEval,
          '%AsyncIteratorPrototype%': needsEval,
          '%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
          '%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
          '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined$1 : BigInt64Array,
          '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined$1 : BigUint64Array,
          '%Boolean%': Boolean,
          '%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
          '%Date%': Date,
          '%decodeURI%': decodeURI,
          '%decodeURIComponent%': decodeURIComponent,
          '%encodeURI%': encodeURI,
          '%encodeURIComponent%': encodeURIComponent,
          '%Error%': $Error,
          '%eval%': eval,
          // eslint-disable-line no-eval
          '%EvalError%': $EvalError,
          '%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
          '%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
          '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
          '%Function%': $Function,
          '%GeneratorFunction%': needsEval,
          '%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
          '%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
          '%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
          '%isFinite%': isFinite,
          '%isNaN%': isNaN,
          '%IteratorPrototype%': hasSymbols$1 && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
          '%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
          '%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
          '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols$1 || !getProto$1 ? undefined$1 : getProto$1(new Map()[Symbol.iterator]()),
          '%Math%': Math,
          '%Number%': Number,
          '%Object%': Object,
          '%parseFloat%': parseFloat,
          '%parseInt%': parseInt,
          '%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
          '%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
          '%RangeError%': $RangeError,
          '%ReferenceError%': $ReferenceError,
          '%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
          '%RegExp%': RegExp,
          '%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
          '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols$1 || !getProto$1 ? undefined$1 : getProto$1(new Set()[Symbol.iterator]()),
          '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
          '%String%': String,
          '%StringIteratorPrototype%': hasSymbols$1 && getProto$1 ? getProto$1(''[Symbol.iterator]()) : undefined$1,
          '%Symbol%': hasSymbols$1 ? Symbol : undefined$1,
          '%SyntaxError%': $SyntaxError$1,
          '%ThrowTypeError%': ThrowTypeError,
          '%TypedArray%': TypedArray,
          '%TypeError%': $TypeError$4,
          '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
          '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
          '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
          '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
          '%URIError%': $URIError,
          '%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
          '%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
          '%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet
        };
        if (getProto$1) {
          try {
            null.error; // eslint-disable-line no-unused-expressions
          } catch (e) {
            // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
            var errorProto = getProto$1(getProto$1(e));
            INTRINSICS['%Error.prototype%'] = errorProto;
          }
        }
        var doEval = function doEval(name) {
          var value;
          if (name === '%AsyncFunction%') {
            value = getEvalledConstructor('async function () {}');
          } else if (name === '%GeneratorFunction%') {
            value = getEvalledConstructor('function* () {}');
          } else if (name === '%AsyncGeneratorFunction%') {
            value = getEvalledConstructor('async function* () {}');
          } else if (name === '%AsyncGenerator%') {
            var fn = doEval('%AsyncGeneratorFunction%');
            if (fn) {
              value = fn.prototype;
            }
          } else if (name === '%AsyncIteratorPrototype%') {
            var gen = doEval('%AsyncGenerator%');
            if (gen && getProto$1) {
              value = getProto$1(gen.prototype);
            }
          }
          INTRINSICS[name] = value;
          return value;
        };
        var LEGACY_ALIASES = {
          __proto__: null,
          '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
          '%ArrayPrototype%': ['Array', 'prototype'],
          '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
          '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
          '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
          '%ArrayProto_values%': ['Array', 'prototype', 'values'],
          '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
          '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
          '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
          '%BooleanPrototype%': ['Boolean', 'prototype'],
          '%DataViewPrototype%': ['DataView', 'prototype'],
          '%DatePrototype%': ['Date', 'prototype'],
          '%ErrorPrototype%': ['Error', 'prototype'],
          '%EvalErrorPrototype%': ['EvalError', 'prototype'],
          '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
          '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
          '%FunctionPrototype%': ['Function', 'prototype'],
          '%Generator%': ['GeneratorFunction', 'prototype'],
          '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
          '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
          '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
          '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
          '%JSONParse%': ['JSON', 'parse'],
          '%JSONStringify%': ['JSON', 'stringify'],
          '%MapPrototype%': ['Map', 'prototype'],
          '%NumberPrototype%': ['Number', 'prototype'],
          '%ObjectPrototype%': ['Object', 'prototype'],
          '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
          '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
          '%PromisePrototype%': ['Promise', 'prototype'],
          '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
          '%Promise_all%': ['Promise', 'all'],
          '%Promise_reject%': ['Promise', 'reject'],
          '%Promise_resolve%': ['Promise', 'resolve'],
          '%RangeErrorPrototype%': ['RangeError', 'prototype'],
          '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
          '%RegExpPrototype%': ['RegExp', 'prototype'],
          '%SetPrototype%': ['Set', 'prototype'],
          '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
          '%StringPrototype%': ['String', 'prototype'],
          '%SymbolPrototype%': ['Symbol', 'prototype'],
          '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
          '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
          '%TypeErrorPrototype%': ['TypeError', 'prototype'],
          '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
          '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
          '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
          '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
          '%URIErrorPrototype%': ['URIError', 'prototype'],
          '%WeakMapPrototype%': ['WeakMap', 'prototype'],
          '%WeakSetPrototype%': ['WeakSet', 'prototype']
        };
        var bind = functionBind;
        var hasOwn$1 = hasown;
        var $concat = bind.call(Function.call, Array.prototype.concat);
        var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
        var $replace = bind.call(Function.call, String.prototype.replace);
        var $strSlice = bind.call(Function.call, String.prototype.slice);
        var $exec$1 = bind.call(Function.call, RegExp.prototype.exec);

        /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
        var rePropName$2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
        var reEscapeChar$2 = /\\(\\)?/g; /** Used to match backslashes in property paths. */
        var stringToPath$3 = function stringToPath(string) {
          var first = $strSlice(string, 0, 1);
          var last = $strSlice(string, -1);
          if (first === '%' && last !== '%') {
            throw new $SyntaxError$1('invalid intrinsic syntax, expected closing `%`');
          } else if (last === '%' && first !== '%') {
            throw new $SyntaxError$1('invalid intrinsic syntax, expected opening `%`');
          }
          var result = [];
          $replace(string, rePropName$2, function (match, number, quote, subString) {
            result[result.length] = quote ? $replace(subString, reEscapeChar$2, '$1') : number || match;
          });
          return result;
        };
        /* end adaptation */

        var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
          var intrinsicName = name;
          var alias;
          if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
            alias = LEGACY_ALIASES[intrinsicName];
            intrinsicName = '%' + alias[0] + '%';
          }
          if (hasOwn$1(INTRINSICS, intrinsicName)) {
            var value = INTRINSICS[intrinsicName];
            if (value === needsEval) {
              value = doEval(intrinsicName);
            }
            if (typeof value === 'undefined' && !allowMissing) {
              throw new $TypeError$4('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
            }
            return {
              alias: alias,
              name: intrinsicName,
              value: value
            };
          }
          throw new $SyntaxError$1('intrinsic ' + name + ' does not exist!');
        };
        var getIntrinsic = function GetIntrinsic(name, allowMissing) {
          if (typeof name !== 'string' || name.length === 0) {
            throw new $TypeError$4('intrinsic name must be a non-empty string');
          }
          if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
            throw new $TypeError$4('"allowMissing" argument must be a boolean');
          }
          if ($exec$1(/^%?[^%]*%?$/, name) === null) {
            throw new $SyntaxError$1('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
          }
          var parts = stringToPath$3(name);
          var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
          var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
          var intrinsicRealName = intrinsic.name;
          var value = intrinsic.value;
          var skipFurtherCaching = false;
          var alias = intrinsic.alias;
          if (alias) {
            intrinsicBaseName = alias[0];
            $spliceApply(parts, $concat([0, 1], alias));
          }
          for (var i = 1, isOwn = true; i < parts.length; i += 1) {
            var part = parts[i];
            var first = $strSlice(part, 0, 1);
            var last = $strSlice(part, -1);
            if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
              throw new $SyntaxError$1('property names with quotes must have matching quotes');
            }
            if (part === 'constructor' || !isOwn) {
              skipFurtherCaching = true;
            }
            intrinsicBaseName += '.' + part;
            intrinsicRealName = '%' + intrinsicBaseName + '%';
            if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
              value = INTRINSICS[intrinsicRealName];
            } else if (value != null) {
              if (!(part in value)) {
                if (!allowMissing) {
                  throw new $TypeError$4('base intrinsic for ' + name + ' exists, but the property is not available.');
                }
                return void undefined$1;
              }
              if ($gOPD$2 && i + 1 >= parts.length) {
                var desc = $gOPD$2(value, part);
                isOwn = !!desc;

                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                  value = desc.get;
                } else {
                  value = value[part];
                }
              } else {
                isOwn = hasOwn$1(value, part);
                value = value[part];
              }
              if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
              }
            }
          }
          return value;
        };
        var callBind$3 = {
          exports: {}
        };
        var GetIntrinsic$3 = getIntrinsic;

        /** @type {import('.')} */
        var $defineProperty$2 = GetIntrinsic$3('%Object.defineProperty%', true) || false;
        if ($defineProperty$2) {
          try {
            $defineProperty$2({}, 'a', {
              value: 1
            });
          } catch (e) {
            // IE 8 has a broken defineProperty
            $defineProperty$2 = false;
          }
        }
        var esDefineProperty = $defineProperty$2;
        var GetIntrinsic$2 = getIntrinsic;
        var $gOPD$1 = GetIntrinsic$2('%Object.getOwnPropertyDescriptor%', true);
        if ($gOPD$1) {
          try {
            $gOPD$1([], 'length');
          } catch (e) {
            // IE 8 has a broken gOPD
            $gOPD$1 = null;
          }
        }
        var gopd$1 = $gOPD$1;
        var $defineProperty$1 = esDefineProperty;
        var $SyntaxError = syntax;
        var $TypeError$3 = type$1;
        var gopd = gopd$1;

        /** @type {import('.')} */
        var defineDataProperty$1 = function defineDataProperty(obj, property, value) {
          if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
            throw new $TypeError$3('`obj` must be an object or a function`');
          }
          if (typeof property !== 'string' && typeof property !== 'symbol') {
            throw new $TypeError$3('`property` must be a string or a symbol`');
          }
          if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
            throw new $TypeError$3('`nonEnumerable`, if provided, must be a boolean or null');
          }
          if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
            throw new $TypeError$3('`nonWritable`, if provided, must be a boolean or null');
          }
          if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
            throw new $TypeError$3('`nonConfigurable`, if provided, must be a boolean or null');
          }
          if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
            throw new $TypeError$3('`loose`, if provided, must be a boolean');
          }
          var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
          var nonWritable = arguments.length > 4 ? arguments[4] : null;
          var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
          var loose = arguments.length > 6 ? arguments[6] : false;

          /* @type {false | TypedPropertyDescriptor<unknown>} */
          var desc = !!gopd && gopd(obj, property);
          if ($defineProperty$1) {
            $defineProperty$1(obj, property, {
              configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
              enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
              value: value,
              writable: nonWritable === null && desc ? desc.writable : !nonWritable
            });
          } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
            // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
            obj[property] = value; // eslint-disable-line no-param-reassign
          } else {
            throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
          }
        };
        var $defineProperty = esDefineProperty;
        var hasPropertyDescriptors = function hasPropertyDescriptors() {
          return !!$defineProperty;
        };
        hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
          // node v0.6 has a bug where array lengths can be Set but not Defined
          if (!$defineProperty) {
            return null;
          }
          try {
            return $defineProperty([], 'length', {
              value: 1
            }).length !== 1;
          } catch (e) {
            // In Firefox 4-22, defining length on an array throws an exception.
            return true;
          }
        };
        var hasPropertyDescriptors_1 = hasPropertyDescriptors;
        var GetIntrinsic$1 = getIntrinsic;
        var define$4 = defineDataProperty$1;
        var hasDescriptors$1 = hasPropertyDescriptors_1();
        var gOPD$4 = gopd$1;
        var $TypeError$2 = type$1;
        var $floor = GetIntrinsic$1('%Math.floor%');

        /** @type {import('.')} */
        var setFunctionLength = function setFunctionLength(fn, length) {
          if (typeof fn !== 'function') {
            throw new $TypeError$2('`fn` is not a function');
          }
          if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
            throw new $TypeError$2('`length` must be a positive 32-bit integer');
          }
          var loose = arguments.length > 2 && !!arguments[2];
          var functionLengthIsConfigurable = true;
          var functionLengthIsWritable = true;
          if ('length' in fn && gOPD$4) {
            var desc = gOPD$4(fn, 'length');
            if (desc && !desc.configurable) {
              functionLengthIsConfigurable = false;
            }
            if (desc && !desc.writable) {
              functionLengthIsWritable = false;
            }
          }
          if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
            if (hasDescriptors$1) {
              define$4(/** @type {Parameters<define>[0]} */fn, 'length', length, true, true);
            } else {
              define$4(/** @type {Parameters<define>[0]} */fn, 'length', length);
            }
          }
          return fn;
        };
        (function (module) {
          var bind = functionBind;
          var GetIntrinsic = getIntrinsic;
          var setFunctionLength$1 = setFunctionLength;
          var $TypeError = type$1;
          var $apply = GetIntrinsic('%Function.prototype.apply%');
          var $call = GetIntrinsic('%Function.prototype.call%');
          var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
          var $defineProperty = esDefineProperty;
          var $max = GetIntrinsic('%Math.max%');
          module.exports = function callBind(originalFunction) {
            if (typeof originalFunction !== 'function') {
              throw new $TypeError('a function is required');
            }
            var func = $reflectApply(bind, $call, arguments);
            return setFunctionLength$1(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
          };
          var applyBind = function applyBind() {
            return $reflectApply(bind, $apply, arguments);
          };
          if ($defineProperty) {
            $defineProperty(module.exports, 'apply', {
              value: applyBind
            });
          } else {
            module.exports.apply = applyBind;
          }
        })(callBind$3);
        var callBindExports = callBind$3.exports;
        var GetIntrinsic = getIntrinsic;
        var callBind$2 = callBindExports;
        var $indexOf = callBind$2(GetIntrinsic('String.prototype.indexOf'));
        var callBound$2 = function callBoundIntrinsic(name, allowMissing) {
          var intrinsic = GetIntrinsic(name, !!allowMissing);
          if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
            return callBind$2(intrinsic);
          }
          return intrinsic;
        };
        var hasToStringTag$2 = shams();
        var callBound$1 = callBound$2;
        var $toString$1 = callBound$1('Object.prototype.toString');
        var isStandardArguments = function isArguments(value) {
          if (hasToStringTag$2 && value && typeof value === 'object' && Symbol.toStringTag in value) {
            return false;
          }
          return $toString$1(value) === '[object Arguments]';
        };
        var isLegacyArguments = function isArguments(value) {
          if (isStandardArguments(value)) {
            return true;
          }
          return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString$1(value) !== '[object Array]' && $toString$1(value.callee) === '[object Function]';
        };
        var supportsStandardArguments = function () {
          return isStandardArguments(arguments);
        }();
        isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

        var isArguments$5 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
        var keys$6 = objectKeys$1;
        var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
        var toStr$2 = Object.prototype.toString;
        var concat = Array.prototype.concat;
        var defineDataProperty = defineDataProperty$1;
        var isFunction$3 = function isFunction$3(fn) {
          return typeof fn === 'function' && toStr$2.call(fn) === '[object Function]';
        };
        var supportsDescriptors$2 = hasPropertyDescriptors_1();
        var defineProperty$6 = function defineProperty$6(object, name, value, predicate) {
          if (name in object) {
            if (predicate === true) {
              if (object[name] === value) {
                return;
              }
            } else if (!isFunction$3(predicate) || !predicate()) {
              return;
            }
          }
          if (supportsDescriptors$2) {
            defineDataProperty(object, name, value, true);
          } else {
            defineDataProperty(object, name, value);
          }
        };
        var defineProperties = function defineProperties(object, map) {
          var predicates = arguments.length > 2 ? arguments[2] : {};
          var props = keys$6(map);
          if (hasSymbols) {
            props = concat.call(props, Object.getOwnPropertySymbols(map));
          }
          for (var i = 0; i < props.length; i += 1) {
            defineProperty$6(object, props[i], map[props[i]], predicates[props[i]]);
          }
        };
        defineProperties.supportsDescriptors = !!supportsDescriptors$2;
        var defineProperties_1 = defineProperties;
        var numberIsNaN = function numberIsNaN(value) {
          return value !== value;
        };
        var implementation$5 = function is(a, b) {
          if (a === 0 && b === 0) {
            return 1 / a === 1 / b;
          }
          if (a === b) {
            return true;
          }
          if (numberIsNaN(a) && numberIsNaN(b)) {
            return true;
          }
          return false;
        };
        var implementation$4 = implementation$5;
        var polyfill$2 = function getPolyfill() {
          return typeof Object.is === 'function' ? Object.is : implementation$4;
        };
        var getPolyfill$3 = polyfill$2;
        var define$3 = defineProperties_1;
        var shim$3 = function shimObjectIs() {
          var polyfill = getPolyfill$3();
          define$3(Object, {
            is: polyfill
          }, {
            is: function testObjectIs() {
              return Object.is !== polyfill;
            }
          });
          return polyfill;
        };
        var define$2 = defineProperties_1;
        var callBind$1 = callBindExports;
        var implementation$3 = implementation$5;
        var getPolyfill$2 = polyfill$2;
        var shim$2 = shim$3;
        var polyfill$1 = callBind$1(getPolyfill$2(), Object);
        define$2(polyfill$1, {
          getPolyfill: getPolyfill$2,
          implementation: implementation$3,
          shim: shim$2
        });
        var objectIs = polyfill$1;
        var callBound = callBound$2;
        var hasToStringTag$1 = shams();
        var has$1;
        var $exec;
        var isRegexMarker;
        var badStringifier;
        if (hasToStringTag$1) {
          has$1 = callBound('Object.prototype.hasOwnProperty');
          $exec = callBound('RegExp.prototype.exec');
          isRegexMarker = {};
          var throwRegexMarker = function throwRegexMarker() {
            throw isRegexMarker;
          };
          badStringifier = {
            toString: throwRegexMarker,
            valueOf: throwRegexMarker
          };
          if (typeof Symbol.toPrimitive === 'symbol') {
            badStringifier[Symbol.toPrimitive] = throwRegexMarker;
          }
        }
        var $toString = callBound('Object.prototype.toString');
        var gOPD$3 = Object.getOwnPropertyDescriptor;
        var regexClass = '[object RegExp]';
        var isRegex$1 = hasToStringTag$1
        // eslint-disable-next-line consistent-return
        ? function isRegex(value) {
          if (!value || typeof value !== 'object') {
            return false;
          }
          var descriptor = gOPD$3(value, 'lastIndex');
          var hasLastIndexDataProperty = descriptor && has$1(descriptor, 'value');
          if (!hasLastIndexDataProperty) {
            return false;
          }
          try {
            $exec(value, badStringifier);
          } catch (e) {
            return e === isRegexMarker;
          }
        } : function isRegex(value) {
          // In older browsers, typeof regex incorrectly returns 'function'
          if (!value || typeof value !== 'object' && typeof value !== 'function') {
            return false;
          }
          return $toString(value) === regexClass;
        };
        var functionsHaveNames = function functionsHaveNames() {
          return typeof function f() {}.name === 'string';
        };
        var gOPD$2 = Object.getOwnPropertyDescriptor;
        if (gOPD$2) {
          try {
            gOPD$2([], 'length');
          } catch (e) {
            // IE 8 has a broken gOPD
            gOPD$2 = null;
          }
        }
        functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
          if (!functionsHaveNames() || !gOPD$2) {
            return false;
          }
          var desc = gOPD$2(function () {}, 'name');
          return !!desc && !!desc.configurable;
        };
        var $bind = Function.prototype.bind;
        functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
          return functionsHaveNames() && typeof $bind === 'function' && function f() {}.bind().name !== '';
        };
        var functionsHaveNames_1 = functionsHaveNames;
        var define$1 = defineDataProperty$1;
        var hasDescriptors = hasPropertyDescriptors_1();
        var functionsHaveConfigurableNames = functionsHaveNames_1.functionsHaveConfigurableNames();
        var $TypeError$1 = type$1;

        /** @type {import('.')} */
        var setFunctionName$1 = function setFunctionName(fn, name) {
          if (typeof fn !== 'function') {
            throw new $TypeError$1('`fn` is not a function');
          }
          var loose = arguments.length > 2 && !!arguments[2];
          if (!loose || functionsHaveConfigurableNames) {
            if (hasDescriptors) {
              define$1(/** @type {Parameters<define>[0]} */fn, 'name', name, true, true);
            } else {
              define$1(/** @type {Parameters<define>[0]} */fn, 'name', name);
            }
          }
          return fn;
        };
        var setFunctionName = setFunctionName$1;
        var $TypeError = type$1;
        var $Object = Object;
        var implementation$2 = setFunctionName(function flags() {
          if (this == null || this !== $Object(this)) {
            throw new $TypeError('RegExp.prototype.flags getter called on non-object');
          }
          var result = '';
          if (this.hasIndices) {
            result += 'd';
          }
          if (this.global) {
            result += 'g';
          }
          if (this.ignoreCase) {
            result += 'i';
          }
          if (this.multiline) {
            result += 'm';
          }
          if (this.dotAll) {
            result += 's';
          }
          if (this.unicode) {
            result += 'u';
          }
          if (this.unicodeSets) {
            result += 'v';
          }
          if (this.sticky) {
            result += 'y';
          }
          return result;
        }, 'get flags', true);
        var implementation$1 = implementation$2;
        var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
        var $gOPD = Object.getOwnPropertyDescriptor;
        var polyfill = function getPolyfill() {
          if (supportsDescriptors$1 && /a/mig.flags === 'gim') {
            var descriptor = $gOPD(RegExp.prototype, 'flags');
            if (descriptor && typeof descriptor.get === 'function' && 'dotAll' in RegExp.prototype && 'hasIndices' in RegExp.prototype) {
              /* eslint getter-return: 0 */
              var calls = '';
              var o = {};
              Object.defineProperty(o, 'hasIndices', {
                get: function get() {
                  calls += 'd';
                }
              });
              Object.defineProperty(o, 'sticky', {
                get: function get() {
                  calls += 'y';
                }
              });
              descriptor.get.call(o);
              if (calls === 'dy') {
                return descriptor.get;
              }
            }
          }
          return implementation$1;
        };
        var supportsDescriptors = defineProperties_1.supportsDescriptors;
        var getPolyfill$1 = polyfill;
        var gOPD$1 = Object.getOwnPropertyDescriptor;
        var defineProperty$5 = Object.defineProperty;
        var TypeErr = TypeError;
        var getProto = Object.getPrototypeOf;
        var regex = /a/;
        var shim$1 = function shimFlags() {
          if (!supportsDescriptors || !getProto) {
            throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
          }
          var polyfill = getPolyfill$1();
          var proto = getProto(regex);
          var descriptor = gOPD$1(proto, 'flags');
          if (!descriptor || descriptor.get !== polyfill) {
            defineProperty$5(proto, 'flags', {
              configurable: true,
              enumerable: false,
              get: polyfill
            });
          }
          return polyfill;
        };
        var define = defineProperties_1;
        var callBind = callBindExports;
        var implementation = implementation$2;
        var getPolyfill = polyfill;
        var shim = shim$1;
        var flagsBound = callBind(getPolyfill());
        define(flagsBound, {
          getPolyfill: getPolyfill,
          implementation: implementation,
          shim: shim
        });
        var regexp_prototype_flags = flagsBound;
        var getDay = Date.prototype.getDay;
        var tryDateObject = function tryDateGetDayCall(value) {
          try {
            getDay.call(value);
            return true;
          } catch (e) {
            return false;
          }
        };
        var toStr$1 = Object.prototype.toString;
        var dateClass = '[object Date]';
        var hasToStringTag = shams();
        var isDateObject = function isDateObject(value) {
          if (typeof value !== 'object' || value === null) {
            return false;
          }
          return hasToStringTag ? tryDateObject(value) : toStr$1.call(value) === dateClass;
        };
        var objectKeys = objectKeys$1;
        var isArguments$4 = isArguments$5;
        var is$1 = objectIs;
        var isRegex = isRegex$1;
        var flags = regexp_prototype_flags;
        var isDate$1 = isDateObject;
        var getTime = Date.prototype.getTime;
        function deepEqual$2(actual, expected, options) {
          var opts = options || {};

          // 7.1. All identical values are equivalent, as determined by ===.
          if (opts.strict ? is$1(actual, expected) : actual === expected) {
            return true;
          }

          // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
          if (!actual || !expected || typeof actual !== 'object' && typeof expected !== 'object') {
            return opts.strict ? is$1(actual, expected) : actual == expected;
          }

          /*
           * 7.4. For all other Object pairs, including Array objects, equivalence is
           * determined by having the same number of owned properties (as verified
           * with Object.prototype.hasOwnProperty.call), the same set of keys
           * (although not necessarily the same order), equivalent values for every
           * corresponding key, and an identical 'prototype' property. Note: this
           * accounts for both named and indexed properties on Arrays.
           */
          // eslint-disable-next-line no-use-before-define
          return objEquiv(actual, expected, opts);
        }
        function isUndefinedOrNull(value) {
          return value === null || value === undefined;
        }
        function isBuffer$3(x) {
          if (!x || typeof x !== 'object' || typeof x.length !== 'number') {
            return false;
          }
          if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
            return false;
          }
          if (x.length > 0 && typeof x[0] !== 'number') {
            return false;
          }
          return true;
        }
        function objEquiv(a, b, opts) {
          /* eslint max-statements: [2, 50] */
          var i, key;
          if (typeof a !== typeof b) {
            return false;
          }
          if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) {
            return false;
          }

          // an identical 'prototype' property.
          if (a.prototype !== b.prototype) {
            return false;
          }
          if (isArguments$4(a) !== isArguments$4(b)) {
            return false;
          }
          var aIsRegex = isRegex(a);
          var bIsRegex = isRegex(b);
          if (aIsRegex !== bIsRegex) {
            return false;
          }
          if (aIsRegex || bIsRegex) {
            return a.source === b.source && flags(a) === flags(b);
          }
          if (isDate$1(a) && isDate$1(b)) {
            return getTime.call(a) === getTime.call(b);
          }
          var aIsBuffer = isBuffer$3(a);
          var bIsBuffer = isBuffer$3(b);
          if (aIsBuffer !== bIsBuffer) {
            return false;
          }
          if (aIsBuffer || bIsBuffer) {
            // && would work too, because both are true or both false here
            if (a.length !== b.length) {
              return false;
            }
            for (i = 0; i < a.length; i++) {
              if (a[i] !== b[i]) {
                return false;
              }
            }
            return true;
          }
          if (typeof a !== typeof b) {
            return false;
          }
          try {
            var ka = objectKeys(a);
            var kb = objectKeys(b);
          } catch (e) {
            // happens when one is a string literal and the other isn't
            return false;
          }
          // having the same number of owned properties (keys incorporates hasOwnProperty)
          if (ka.length !== kb.length) {
            return false;
          }

          // the same set of keys (although not necessarily the same order),
          ka.sort();
          kb.sort();
          // ~~~cheap key test
          for (i = ka.length - 1; i >= 0; i--) {
            if (ka[i] != kb[i]) {
              return false;
            }
          }
          // equivalent values for every corresponding key, and ~~~possibly expensive deep test
          for (i = ka.length - 1; i >= 0; i--) {
            key = ka[i];
            if (!deepEqual$2(a[key], b[key], opts)) {
              return false;
            }
          }
          return true;
        }
        var deepEqual_1 = deepEqual$2;
        var hasOwn = Object.prototype.hasOwnProperty;
        var toStr = Object.prototype.toString;
        var defineProperty$4 = Object.defineProperty;
        var gOPD = Object.getOwnPropertyDescriptor;
        var isArray$c = function isArray(arr) {
          if (typeof Array.isArray === 'function') {
            return Array.isArray(arr);
          }
          return toStr.call(arr) === '[object Array]';
        };
        var isPlainObject$5 = function isPlainObject(obj) {
          if (!obj || toStr.call(obj) !== '[object Object]') {
            return false;
          }
          var hasOwnConstructor = hasOwn.call(obj, 'constructor');
          var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
          // Not own constructor property must be Object
          if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
            return false;
          }

          // Own properties are enumerated firstly, so to speed up,
          // if last one is own, then all properties are own.
          var key;
          for (key in obj) {/**/}
          return typeof key === 'undefined' || hasOwn.call(obj, key);
        };

        // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
        var setProperty = function setProperty(target, options) {
          if (defineProperty$4 && options.name === '__proto__') {
            defineProperty$4(target, options.name, {
              enumerable: true,
              configurable: true,
              value: options.newValue,
              writable: true
            });
          } else {
            target[options.name] = options.newValue;
          }
        };

        // Return undefined instead of __proto__ if '__proto__' is not an own property
        var getProperty = function getProperty(obj, name) {
          if (name === '__proto__') {
            if (!hasOwn.call(obj, name)) {
              return void 0;
            } else if (gOPD) {
              // In early versions of node, obj['__proto__'] is buggy when obj has
              // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
              return gOPD(obj, name).value;
            }
          }
          return obj[name];
        };
        var extend$3 = function extend() {
          var options, name, src, copy, copyIsArray, clone;
          var target = arguments[0];
          var i = 1;
          var length = arguments.length;
          var deep = false;

          // Handle a deep copy situation
          if (typeof target === 'boolean') {
            deep = target;
            target = arguments[1] || {};
            // skip the boolean and the target
            i = 2;
          }
          if (target == null || typeof target !== 'object' && typeof target !== 'function') {
            target = {};
          }
          for (; i < length; ++i) {
            options = arguments[i];
            // Only deal with non-null/undefined values
            if (options != null) {
              // Extend the base object
              for (name in options) {
                src = getProperty(target, name);
                copy = getProperty(options, name);

                // Prevent never-ending loop
                if (target !== copy) {
                  // Recurse if we're merging plain objects or arrays
                  if (deep && copy && (isPlainObject$5(copy) || (copyIsArray = isArray$c(copy)))) {
                    if (copyIsArray) {
                      copyIsArray = false;
                      clone = src && isArray$c(src) ? src : [];
                    } else {
                      clone = src && isPlainObject$5(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    setProperty(target, {
                      name: name,
                      newValue: extend(deep, clone, copy)
                    });

                    // Don't bring in undefined values
                  } else if (typeof copy !== 'undefined') {
                    setProperty(target, {
                      name: name,
                      newValue: copy
                    });
                  }
                }
              }
            }
          }

          // Return the modified object
          return target;
        };
        var equal$1 = deepEqual_1;
        var extend$2 = extend$3;
        var lib$1 = {
          attributes: {
            compose: function compose(a, b, keepNull) {
              if (typeof a !== 'object') a = {};
              if (typeof b !== 'object') b = {};
              var attributes = extend$2(true, {}, b);
              if (!keepNull) {
                attributes = Object.keys(attributes).reduce(function (copy, key) {
                  if (attributes[key] != null) {
                    copy[key] = attributes[key];
                  }
                  return copy;
                }, {});
              }
              for (var key in a) {
                if (a[key] !== undefined && b[key] === undefined) {
                  attributes[key] = a[key];
                }
              }
              return Object.keys(attributes).length > 0 ? attributes : undefined;
            },
            diff: function diff(a, b) {
              if (typeof a !== 'object') a = {};
              if (typeof b !== 'object') b = {};
              var attributes = Object.keys(a).concat(Object.keys(b)).reduce(function (attributes, key) {
                if (!equal$1(a[key], b[key])) {
                  attributes[key] = b[key] === undefined ? null : b[key];
                }
                return attributes;
              }, {});
              return Object.keys(attributes).length > 0 ? attributes : undefined;
            },
            transform: function transform(a, b, priority) {
              if (typeof a !== 'object') return b;
              if (typeof b !== 'object') return undefined;
              if (!priority) return b; // b simply overwrites us without priority
              var attributes = Object.keys(b).reduce(function (attributes, key) {
                if (a[key] === undefined) attributes[key] = b[key]; // null is a valid value
                return attributes;
              }, {});
              return Object.keys(attributes).length > 0 ? attributes : undefined;
            }
          },
          iterator: function iterator(ops) {
            return new Iterator$1(ops);
          },
          length: function length(op) {
            if (typeof op['delete'] === 'number') {
              return op['delete'];
            } else if (typeof op.retain === 'number') {
              return op.retain;
            } else {
              return typeof op.insert === 'string' ? op.insert.length : 1;
            }
          }
        };
        function Iterator$1(ops) {
          this.ops = ops;
          this.index = 0;
          this.offset = 0;
        }
        Iterator$1.prototype.hasNext = function () {
          return this.peekLength() < Infinity;
        };
        Iterator$1.prototype.next = function (length) {
          if (!length) length = Infinity;
          var nextOp = this.ops[this.index];
          if (nextOp) {
            var offset = this.offset;
            var opLength = lib$1.length(nextOp);
            if (length >= opLength - offset) {
              length = opLength - offset;
              this.index += 1;
              this.offset = 0;
            } else {
              this.offset += length;
            }
            if (typeof nextOp['delete'] === 'number') {
              return {
                'delete': length
              };
            } else {
              var retOp = {};
              if (nextOp.attributes) {
                retOp.attributes = nextOp.attributes;
              }
              if (typeof nextOp.retain === 'number') {
                retOp.retain = length;
              } else if (typeof nextOp.insert === 'string') {
                retOp.insert = nextOp.insert.substr(offset, length);
              } else {
                // offset should === 0, length should === 1
                retOp.insert = nextOp.insert;
              }
              return retOp;
            }
          } else {
            return {
              retain: Infinity
            };
          }
        };
        Iterator$1.prototype.peek = function () {
          return this.ops[this.index];
        };
        Iterator$1.prototype.peekLength = function () {
          if (this.ops[this.index]) {
            // Should never return 0 if our index is being managed correctly
            return lib$1.length(this.ops[this.index]) - this.offset;
          } else {
            return Infinity;
          }
        };
        Iterator$1.prototype.peekType = function () {
          if (this.ops[this.index]) {
            if (typeof this.ops[this.index]['delete'] === 'number') {
              return 'delete';
            } else if (typeof this.ops[this.index].retain === 'number') {
              return 'retain';
            } else {
              return 'insert';
            }
          }
          return 'retain';
        };
        Iterator$1.prototype.rest = function () {
          if (!this.hasNext()) {
            return [];
          } else if (this.offset === 0) {
            return this.ops.slice(this.index);
          } else {
            var offset = this.offset;
            var index = this.index;
            var next = this.next();
            var rest = this.ops.slice(this.index);
            this.offset = offset;
            this.index = index;
            return [next].concat(rest);
          }
        };
        var op$1 = lib$1;
        var diff$1 = diff_1;
        var equal = deepEqual_1;
        var extend$1 = extend$3;
        var op = op$1;
        var NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()

        var Delta = function Delta(ops) {
          // Assume we are given a well formed ops
          if (Array.isArray(ops)) {
            this.ops = ops;
          } else if (ops != null && Array.isArray(ops.ops)) {
            this.ops = ops.ops;
          } else {
            this.ops = [];
          }
        };
        Delta.prototype.insert = function (text, attributes) {
          var newOp = {};
          if (text.length === 0) return this;
          newOp.insert = text;
          if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
            newOp.attributes = attributes;
          }
          return this.push(newOp);
        };
        Delta.prototype['delete'] = function (length) {
          if (length <= 0) return this;
          return this.push({
            'delete': length
          });
        };
        Delta.prototype.retain = function (length, attributes) {
          if (length <= 0) return this;
          var newOp = {
            retain: length
          };
          if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
            newOp.attributes = attributes;
          }
          return this.push(newOp);
        };
        Delta.prototype.push = function (newOp) {
          var index = this.ops.length;
          var lastOp = this.ops[index - 1];
          newOp = extend$1(true, {}, newOp);
          if (typeof lastOp === 'object') {
            if (typeof newOp['delete'] === 'number' && typeof lastOp['delete'] === 'number') {
              this.ops[index - 1] = {
                'delete': lastOp['delete'] + newOp['delete']
              };
              return this;
            }
            // Since it does not matter if we insert before or after deleting at the same index,
            // always prefer to insert first
            if (typeof lastOp['delete'] === 'number' && newOp.insert != null) {
              index -= 1;
              lastOp = this.ops[index - 1];
              if (typeof lastOp !== 'object') {
                this.ops.unshift(newOp);
                return this;
              }
            }
            if (equal(newOp.attributes, lastOp.attributes)) {
              if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
                this.ops[index - 1] = {
                  insert: lastOp.insert + newOp.insert
                };
                if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;
                return this;
              } else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
                this.ops[index - 1] = {
                  retain: lastOp.retain + newOp.retain
                };
                if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;
                return this;
              }
            }
          }
          if (index === this.ops.length) {
            this.ops.push(newOp);
          } else {
            this.ops.splice(index, 0, newOp);
          }
          return this;
        };
        Delta.prototype.chop = function () {
          var lastOp = this.ops[this.ops.length - 1];
          if (lastOp && lastOp.retain && !lastOp.attributes) {
            this.ops.pop();
          }
          return this;
        };
        Delta.prototype.filter = function (predicate) {
          return this.ops.filter(predicate);
        };
        Delta.prototype.forEach = function (predicate) {
          this.ops.forEach(predicate);
        };
        Delta.prototype.map = function (predicate) {
          return this.ops.map(predicate);
        };
        Delta.prototype.partition = function (predicate) {
          var passed = [],
            failed = [];
          this.forEach(function (op) {
            var target = predicate(op) ? passed : failed;
            target.push(op);
          });
          return [passed, failed];
        };
        Delta.prototype.reduce = function (predicate, initial) {
          return this.ops.reduce(predicate, initial);
        };
        Delta.prototype.changeLength = function () {
          return this.reduce(function (length, elem) {
            if (elem.insert) {
              return length + op.length(elem);
            } else if (elem.delete) {
              return length - elem.delete;
            }
            return length;
          }, 0);
        };
        Delta.prototype.length = function () {
          return this.reduce(function (length, elem) {
            return length + op.length(elem);
          }, 0);
        };
        Delta.prototype.slice = function (start, end) {
          start = start || 0;
          if (typeof end !== 'number') end = Infinity;
          var ops = [];
          var iter = op.iterator(this.ops);
          var index = 0;
          while (index < end && iter.hasNext()) {
            var nextOp;
            if (index < start) {
              nextOp = iter.next(start - index);
            } else {
              nextOp = iter.next(end - index);
              ops.push(nextOp);
            }
            index += op.length(nextOp);
          }
          return new Delta(ops);
        };
        Delta.prototype.compose = function (other) {
          var thisIter = op.iterator(this.ops);
          var otherIter = op.iterator(other.ops);
          var ops = [];
          var firstOther = otherIter.peek();
          if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {
            var firstLeft = firstOther.retain;
            while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {
              firstLeft -= thisIter.peekLength();
              ops.push(thisIter.next());
            }
            if (firstOther.retain - firstLeft > 0) {
              otherIter.next(firstOther.retain - firstLeft);
            }
          }
          var delta = new Delta(ops);
          while (thisIter.hasNext() || otherIter.hasNext()) {
            if (otherIter.peekType() === 'insert') {
              delta.push(otherIter.next());
            } else if (thisIter.peekType() === 'delete') {
              delta.push(thisIter.next());
            } else {
              var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
              var thisOp = thisIter.next(length);
              var otherOp = otherIter.next(length);
              if (typeof otherOp.retain === 'number') {
                var newOp = {};
                if (typeof thisOp.retain === 'number') {
                  newOp.retain = length;
                } else {
                  newOp.insert = thisOp.insert;
                }
                // Preserve null when composing with a retain, otherwise remove it for inserts
                var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
                if (attributes) newOp.attributes = attributes;
                delta.push(newOp);

                // Optimization if rest of other is just retain
                if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {
                  var rest = new Delta(thisIter.rest());
                  return delta.concat(rest).chop();
                }

                // Other op should be delete, we could be an insert or retain
                // Insert + delete cancels out
              } else if (typeof otherOp['delete'] === 'number' && typeof thisOp.retain === 'number') {
                delta.push(otherOp);
              }
            }
          }
          return delta.chop();
        };
        Delta.prototype.concat = function (other) {
          var delta = new Delta(this.ops.slice());
          if (other.ops.length > 0) {
            delta.push(other.ops[0]);
            delta.ops = delta.ops.concat(other.ops.slice(1));
          }
          return delta;
        };
        Delta.prototype.diff = function (other, index) {
          if (this.ops === other.ops) {
            return new Delta();
          }
          var strings = [this, other].map(function (delta) {
            return delta.map(function (op) {
              if (op.insert != null) {
                return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;
              }
              var prep = delta === other ? 'on' : 'with';
              throw new Error('diff() called ' + prep + ' non-document');
            }).join('');
          });
          var delta = new Delta();
          var diffResult = diff$1(strings[0], strings[1], index);
          var thisIter = op.iterator(this.ops);
          var otherIter = op.iterator(other.ops);
          diffResult.forEach(function (component) {
            var length = component[1].length;
            while (length > 0) {
              var opLength = 0;
              switch (component[0]) {
                case diff$1.INSERT:
                  opLength = Math.min(otherIter.peekLength(), length);
                  delta.push(otherIter.next(opLength));
                  break;
                case diff$1.DELETE:
                  opLength = Math.min(length, thisIter.peekLength());
                  thisIter.next(opLength);
                  delta['delete'](opLength);
                  break;
                case diff$1.EQUAL:
                  opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
                  var thisOp = thisIter.next(opLength);
                  var otherOp = otherIter.next(opLength);
                  if (equal(thisOp.insert, otherOp.insert)) {
                    delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));
                  } else {
                    delta.push(otherOp)['delete'](opLength);
                  }
                  break;
              }
              length -= opLength;
            }
          });
          return delta.chop();
        };
        Delta.prototype.eachLine = function (predicate, newline) {
          newline = newline || '\n';
          var iter = op.iterator(this.ops);
          var line = new Delta();
          var i = 0;
          while (iter.hasNext()) {
            if (iter.peekType() !== 'insert') return;
            var thisOp = iter.peek();
            var start = op.length(thisOp) - iter.peekLength();
            var index = typeof thisOp.insert === 'string' ? thisOp.insert.indexOf(newline, start) - start : -1;
            if (index < 0) {
              line.push(iter.next());
            } else if (index > 0) {
              line.push(iter.next(index));
            } else {
              if (predicate(line, iter.next(1).attributes || {}, i) === false) {
                return;
              }
              i += 1;
              line = new Delta();
            }
          }
          if (line.length() > 0) {
            predicate(line, {}, i);
          }
        };
        Delta.prototype.transform = function (other, priority) {
          priority = !!priority;
          if (typeof other === 'number') {
            return this.transformPosition(other, priority);
          }
          var thisIter = op.iterator(this.ops);
          var otherIter = op.iterator(other.ops);
          var delta = new Delta();
          while (thisIter.hasNext() || otherIter.hasNext()) {
            if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
              delta.retain(op.length(thisIter.next()));
            } else if (otherIter.peekType() === 'insert') {
              delta.push(otherIter.next());
            } else {
              var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
              var thisOp = thisIter.next(length);
              var otherOp = otherIter.next(length);
              if (thisOp['delete']) {
                // Our delete either makes their delete redundant or removes their retain
                continue;
              } else if (otherOp['delete']) {
                delta.push(otherOp);
              } else {
                // We retain either their retain or insert
                delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
              }
            }
          }
          return delta.chop();
        };
        Delta.prototype.transformPosition = function (index, priority) {
          priority = !!priority;
          var thisIter = op.iterator(this.ops);
          var offset = 0;
          while (thisIter.hasNext() && offset <= index) {
            var length = thisIter.peekLength();
            var nextType = thisIter.peekType();
            thisIter.next();
            if (nextType === 'delete') {
              index -= Math.min(length, index - offset);
              continue;
            } else if (nextType === 'insert' && (offset < index || !priority)) {
              index += length;
            }
            offset += length;
          }
          return index;
        };
        var delta = Delta;
        const Delta$1 = /*@__PURE__*/getDefaultExportFromCjs(delta);
        const Clipboard = lib$2.Quill.import("modules/clipboard");
        class SurveyFormClipboard extends Clipboard {
          onPaste(e) {
            e.preventDefault();
            const range = this.quill.getSelection();
            const text = e.clipboardData.getData("text/plain");
            text.split("\r\n").filter(function (item) {
              return item;
            });
            const delta = new Delta$1().retain(range.index).delete(range.length).insert(text);
            const index = text.length + range.index;
            const length = 0;
            this.quill.updateContents(delta, "silent");
            this.quill.setSelection(index, length, "silent");
          }
        }
        const accessibleDependencies = (componentIndices, code) => {
          let dependencies = [];
          if (!componentIndices) {
            return dependencies;
          }
          let componentIndex = componentIndices.find(element => element.code === code);
          if (!componentIndex) {
            return dependencies;
          }
          if (componentIndex.parent) {
            let componentParents = parents$1(componentIndices, componentIndex);
            componentParents.forEach(element => {
              dependencies = dependencies.concat(accessibleSiblings$1(componentIndices, element));
            });
          }
          if (isGroup(componentIndex.code) || isQuestion(componentIndex.code)) {
            dependencies = dependencies.concat(accessibleSiblings$1(componentIndices, componentIndex));
          }
          return dependencies;
        };
        const parents$1 = (componentIndices, componentIndex) => {
          let result = [];
          let parent = componentIndices.find(element => element.code === componentIndex.parent);
          if (parent && parent.parent) {
            result.push(parent);
            result = result.concat(parents$1(componentIndices, parent));
          }
          return result;
        };
        const accessibleSiblings$1 = (componentIndices, componentIndex) => {
          let result = [];
          if (!isGroup(componentIndex.code) && !isQuestion(componentIndex.code)) {
            return result;
          }
          let accessibleSiblings = componentIndices.filter(elem => {
            return elem.parent === componentIndex.parent && elem.maxIndex < componentIndex.minIndex && (!componentIndex.prioritisedSiblings || componentIndex.prioritisedSiblings.indexOf(elem.code) === -1);
          });
          accessibleSiblings.forEach(sibling => {
            result = result.concat(sibling.code);
            result = result.concat(childrenDependencies$1(componentIndices, sibling));
          });
          return result;
        };
        const childrenDependencies$1 = (componentIndices, componentIndex) => {
          let result = [];
          if (!isGroup(componentIndex.code)) {
            return result;
          }
          if (componentIndex.children) {
            componentIndex.children.forEach(childCode => {
              let child = componentIndices.find(element => element.code === childCode);
              result = result.concat(child.code);
              result = result.concat(childrenDependencies$1(componentIndices, child));
            });
          }
          return result;
        };
        const buildReferences = (componentIndices, code, state, mainLang) => {
          let dependencies = accessibleDependencies(componentIndices, code);
          let returnResult = [];
          dependencies.forEach(el => {
            if (isQuestion(el)) {
              const reference = buildReference(el, state[el], state, mainLang);
              if (reference.length) {
                returnResult = returnResult.concat(reference);
              }
            }
          });
          return returnResult;
        };
        const buildReference = (code, component, state, mainLang) => {
          var _component$content;
          const label = code + ". " + stripTags((_component$content = component.content) === null || _component$content === void 0 || (_component$content = _component$content.label) === null || _component$content === void 0 ? void 0 : _component$content[mainLang]);
          let instruction = "";
          let type = component.type;
          switch (component.type) {
            case "scq_icon_array":
            case "scq_array":
              return component.children.filter(el => el.type == "row").map(element => {
                var _state$element$qualif;
                return {
                  value: label + " - " + code + ". " + stripTags((_state$element$qualif = state[element.qualifiedCode].content) === null || _state$element$qualif === void 0 || (_state$element$qualif = _state$element$qualif.label) === null || _state$element$qualif === void 0 ? void 0 : _state$element$qualif[mainLang]),
                  id: code + element.code,
                  type: "SCQ Array Row",
                  instruction: code + element.code + ".masked_value"
                };
              });
            case "text":
              type = "Short Text";
              instruction = `${code}.value`;
              break;
            case "nps":
              type = "NPS";
              instruction = `${code}.value`;
              break;
            case "email":
              type = "Email";
              instruction = `${code}.value`;
              break;
            case "paragraph":
              instruction = `${code}.value`;
              type = "Long Text";
              break;
            case "number":
              type = "Number";
              instruction = `${code}.value`;
              break;
            case "date":
              type = "Date";
              instruction = `${code}.masked_value`;
              break;
            case "time":
              type = "time";
              instruction = `${code}.masked_value`;
              break;
            case "date_time":
              type = "Date Time";
              instruction = `${code}.masked_value`;
              break;
            case "scq":
              type = "SCQ";
              instruction = `${code}.masked_value`;
              break;
            case "icon_scq":
              type = "Icon SCQ";
              instruction = `${code}.masked_value`;
              break;
            case "image_scq":
              type = "Image SCQ";
              instruction = `${code}.masked_value`;
              break;
            case "mcq":
              type = "MCQ";
              instruction = `${code}.masked_value`;
              break;
            case "image_mcq":
              type = "Image MCQ";
              instruction = `${code}.masked_value`;
              break;
            case "icon_mcq":
              type = "Icon MCQ";
              instruction = `${code}.masked_value`;
              break;
            default:
              return [];
          }
          return [{
            id: code,
            instruction,
            value: label,
            type
          }];
        };
        lib$2.Quill.register("modules/mentions", Mention);
        lib$2.Quill.register("modules/clipboard", SurveyFormClipboard, true);
        function DraftEditor({
          value,
          onBlurListener,
          extended,
          isRtl,
          lang,
          code
        }) {
          console.debug("DraftEditor for: " + code);
          const oneLine = (value2, oneLine2) => {
            return !oneLine2 ? value2 : "<p>" + value2.replace(/<br>/gi, "").replace(/<p>/gi, "").replace(/<\/p>/, "") + "</p>";
          };
          const editor = React.createRef();
          const _reactExports$useStat19 = reactExports.useState(oneLine(value, !extended)),
            _reactExports$useStat20 = _slicedToArray2(_reactExports$useStat19, 2),
            state = _reactExports$useStat20[0],
            setState = _reactExports$useStat20[1];
          const _reactExports$useStat21 = reactExports.useState(0),
            _reactExports$useStat22 = _slicedToArray2(_reactExports$useStat21, 2),
            lastFocus = _reactExports$useStat22[0],
            setLastFocus = _reactExports$useStat22[1];
          function references(_x8) {
            return _references.apply(this, arguments);
          }
          function _references() {
            _references = _asyncToGenerator2(function* (searchTerm) {
              const designState = manageStore.getState().designState;
              const values = buildReferences(designState.componentIndex, code, designState, designState.langInfo.mainLang);
              if (searchTerm.length === 0) {
                return values;
              } else {
                const matches = [];
                for (var i = 0; i < values.length; i++) {
                  if (values[i].value.toLowerCase().indexOf(searchTerm.toLowerCase()) >= 0) {
                    matches.push(values[i]);
                  }
                }
                return matches;
              }
            });
            return _references.apply(this, arguments);
          }
          reactExports.useEffect(() => {
            const quill = editor.current.getEditor();
            quill.setSelection(quill.getLength(), 0);
          }, [editor.current]);
          const modules = reactExports.useMemo(() => {
            return {
              mention: {
                dataAttributes: ["instruction", "type"],
                isolateCharacter: true,
                allowedChars: /[^\p{L}\p{N}]*$/,
                mentionDenotationChars: ["@"],
                showDenotationChar: false,
                onSelect: function onSelect(item, insertItem) {
                  insertItem(_objectSpread3(_objectSpread3({}, item), {}, {
                    value: `{{${item.id}:${item.type}}}`
                  }));
                },
                source: function () {
                  var _source2 = _asyncToGenerator2(function* (searchTerm, renderList) {
                    const values = yield references(searchTerm);
                    renderList(values);
                  });
                  function source(_x9, _x10) {
                    return _source2.apply(this, arguments);
                  }
                  return source;
                }()
              },
              toolbar: {
                container: extended ? [["bold", "italic", "underline", "strike", "link"], [{
                  list: "ordered"
                }, {
                  list: "bullet"
                }, {
                  indent: "-1"
                }, {
                  indent: "+1"
                }], [{
                  color: []
                }, {
                  background: []
                }], ["clean"]] : [["bold", "italic", "underline", "strike", "link"], [{
                  color: []
                }, {
                  background: []
                }], ["clean"]],
                clipboard: {
                  // Add the clipboard module with paste and matchVisual options
                  matchVisual: false
                  // Disable matching visual formatting during paste
                }
                // handlers: {
                //   // handlers object will be merged with default handlers object
                //   link: function (value) {
                //     if (value) {
                //       var href = prompt("Enter the URL");
                //       this.quill.format("link", href);
                //     } else {
                //       this.quill.format("link", false);
                //     }
                //   },
                // },
              }
            };
          }, []);
          const formats = ["bold", "italic", "underline", "strike", "direction", "list", "bullet", "indent", "color", "background", "mention", "link"];
          let timeoutID = null;
          const onFocus = () => {
            setLastFocus(Date.now());
            timeoutID && clearTimeout(timeoutID);
          };
          const onBlur = () => {
            timeoutID = setTimeout(() => {
              onBlurListener(state, lang);
            }, 500);
          };
          const onChange = value2 => {
            onFocus();
            setState(oneLine(value2, !extended));
          };
          const onContainerClick = e => {
            if (e.target.tagName === "A" && e.target.className == "ql-preview") {
              e.preventDefault();
              window.open(e.target.href, "_blank");
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            onClick: onContainerClick,
            className: "quill-wrapper",
            onFocus,
            onBlur,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(ReactQuill$1, {
              className: isRtl ? "rtl" : "ltr",
              theme: "snow",
              bounds: ".quill-wrapper",
              ref: editor,
              modules,
              formats,
              value: state,
              onChange
            })
          });
        }
        const DraftEditor$1 = React.memo(DraftEditor);
        function ContentEditor$1({
          placeholder,
          extended,
          contentKey,
          code,
          editable
        }) {
          const dispatch = useDispatch();
          const content = useSelector(state => {
            var _state$designState$co;
            return (_state$designState$co = state.designState[code].content) === null || _state$designState$co === void 0 ? void 0 : _state$designState$co[contentKey];
          });
          const langInfo = useSelector(state => {
            return state.designState.langInfo;
          });
          useSelector(state => {
            var _state$designState$co2;
            return code[0] == "G" ? ((_state$designState$co2 = state.designState[code].groupType) === null || _state$designState$co2 === void 0 ? void 0 : _state$designState$co2.toLowerCase()) || "group" : state.designState[code].type;
          });
          const lang = langInfo.lang;
          const mainLang = langInfo.mainLang;
          const onMainLang = langInfo.onMainLang;
          const value = (content === null || content === void 0 ? void 0 : content[lang]) || "";
          const finalPlaceholder = onMainLang ? placeholder : isNotEmptyHtml(content === null || content === void 0 ? void 0 : content[mainLang]) ? content === null || content === void 0 ? void 0 : content[mainLang] : placeholder;
          const _reactExports$useStat23 = reactExports.useState(false),
            _reactExports$useStat24 = _slicedToArray2(_reactExports$useStat23, 2),
            isActive = _reactExports$useStat24[0],
            setActive = _reactExports$useStat24[1];
          const OnEditorBlurred = reactExports.useCallback((text, editorLang) => {
            setActive(false);
            if (lang != editorLang) {
              return;
            } else if (text != value) {
              dispatch(changeContent({
                code,
                key: contentKey,
                lang,
                value: text
              }));
            }
          }, [value]);
          const onContainerClicked = event => {
            event.preventDefault();
            setActive(true);
          };
          const isRtl = rtlLanguage.includes(lang);
          return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
            className: styles$G.fullWidth,
            onClick: e => {
              if (editable) {
                onContainerClicked(e);
              }
            },
            children: isActive ? /* @__PURE__ */jsxRuntimeExports.jsx(DraftEditor$1, {
              lang,
              isRtl,
              code,
              extended,
              onBlurListener: OnEditorBlurred,
              value
            }) : isNotEmptyHtml(value) ? /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: `${isRtl ? "rtl" : "ltr"} ql-editor ${styles$G.noPadding}`,
              dangerouslySetInnerHTML: {
                __html: value
              }
            }) : /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: `${isRtl ? "rtl" : "ltr"} ql-editor ${styles$G.placeholder}`,
              dangerouslySetInnerHTML: {
                __html: finalPlaceholder
              }
            })
          });
        }
        const ContentEditor$2 = React.memo(ContentEditor$1);
        const actionControl = "_actionControl_1xa5v_1";
        const statusIcon = "_statusIcon_1xa5v_8";
        const questionContainer = "_questionContainer_1xa5v_12";
        const actionIcon = "_actionIcon_1xa5v_16";
        const settingIcon$2 = "_settingIcon_1xa5v_17";
        const deleteIcon = "_deleteIcon_1xa5v_25";
        const styles$F = {
          actionControl: actionControl,
          statusIcon: statusIcon,
          questionContainer: questionContainer,
          actionIcon: actionIcon,
          settingIcon: settingIcon$2,
          deleteIcon: deleteIcon
        };
        var Verified = {};
        var _interopRequireDefault$t = interopRequireDefaultExports;
        Object.defineProperty(Verified, "__esModule", {
          value: true
        });
        var default_1$l = Verified.default = void 0;
        var _createSvgIcon$l = _interopRequireDefault$t(requireCreateSvgIcon());
        var _jsxRuntime$l = jsxRuntimeExports;
        default_1$l = Verified.default = (0, _createSvgIcon$l.default)(/*#__PURE__*/(0, _jsxRuntime$l.jsx)("path", {
          d: "m23 12-2.44-2.79.34-3.69-3.61-.82-1.89-3.2L12 2.96 8.6 1.5 6.71 4.69 3.1 5.5l.34 3.7L1 12l2.44 2.79-.34 3.7 3.61.82L8.6 22.5l3.4-1.47 3.4 1.46 1.89-3.19 3.61-.82-.34-3.69zm-12.91 4.72-3.8-3.81 1.48-1.48 2.32 2.33 5.85-5.87 1.48 1.48z"
        }), 'Verified');
        var Shuffle = {};
        var _interopRequireDefault$s = interopRequireDefaultExports;
        Object.defineProperty(Shuffle, "__esModule", {
          value: true
        });
        var default_1$k = Shuffle.default = void 0;
        var _createSvgIcon$k = _interopRequireDefault$s(requireCreateSvgIcon());
        var _jsxRuntime$k = jsxRuntimeExports;
        default_1$k = Shuffle.default = (0, _createSvgIcon$k.default)(/*#__PURE__*/(0, _jsxRuntime$k.jsx)("path", {
          d: "M10.59 9.17 5.41 4 4 5.41l5.17 5.17zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4zm.33 9.41-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04z"
        }), 'Shuffle');
        var LowPriority = {};
        var _interopRequireDefault$r = interopRequireDefaultExports;
        Object.defineProperty(LowPriority, "__esModule", {
          value: true
        });
        var default_1$j = LowPriority.default = void 0;
        var _createSvgIcon$j = _interopRequireDefault$r(requireCreateSvgIcon());
        var _jsxRuntime$j = jsxRuntimeExports;
        default_1$j = LowPriority.default = (0, _createSvgIcon$j.default)(/*#__PURE__*/(0, _jsxRuntime$j.jsx)("path", {
          d: "M14 5h8v2h-8zm0 5.5h8v2h-8zm0 5.5h8v2h-8zM2 11.5C2 15.08 4.92 18 8.5 18H9v2l3-3-3-3v2h-.5C6.02 16 4 13.98 4 11.5S6.02 7 8.5 7H12V5H8.5C4.92 5 2 7.92 2 11.5"
        }), 'LowPriority');
        var MoveDown = {};
        var _interopRequireDefault$q = interopRequireDefaultExports;
        Object.defineProperty(MoveDown, "__esModule", {
          value: true
        });
        var default_1$i = MoveDown.default = void 0;
        var _createSvgIcon$i = _interopRequireDefault$q(requireCreateSvgIcon());
        var _jsxRuntime$i = jsxRuntimeExports;
        default_1$i = MoveDown.default = (0, _createSvgIcon$i.default)(/*#__PURE__*/(0, _jsxRuntime$i.jsx)("path", {
          d: "M3 11c0 2.45 1.76 4.47 4.08 4.91l-1.49-1.49L7 13l4 4.01L7 21l-1.41-1.41 1.58-1.58v-.06C3.7 17.54 1 14.58 1 11c0-3.87 3.13-7 7-7h3v2H8c-2.76 0-5 2.24-5 5m19 0V4h-9v7zm-2-2h-5V6h5zm-7 4h9v7h-9z"
        }), 'MoveDown');
        function ActionToolbar({
          code,
          isGroup,
          parentCode,
          disableDelete,
          onDelete,
          onClone,
          t
        }) {
          const dispatch = useDispatch();
          const theme = useTheme$1();
          const type = useSelector(state => {
            var _state$designState$co3;
            return isGroup ? ((_state$designState$co3 = state.designState[code].groupType) === null || _state$designState$co3 === void 0 ? void 0 : _state$designState$co3.toLowerCase()) || "group" : state.designState[code].type;
          });
          const _reactExports$useStat25 = reactExports.useState(false),
            _reactExports$useStat26 = _slicedToArray2(_reactExports$useStat25, 2),
            open = _reactExports$useStat26[0],
            setOpen = _reactExports$useStat26[1];
          const handleClose = () => setOpen(false);
          const hasRelevance = useSelector(state => {
            var _state$designState$co4;
            let instruction = (_state$designState$co4 = state.designState[code]) === null || _state$designState$co4 === void 0 || (_state$designState$co4 = _state$designState$co4.instructionList) === null || _state$designState$co4 === void 0 ? void 0 : _state$designState$co4.find(el => el.code == "conditional_relevance");
            return typeof instruction !== "undefined" && !instruction.errors;
          });
          const hasValidation = useSelector(state => {
            var _state$designState$co5;
            return !isGroup && ((_state$designState$co5 = state.designState[code]) === null || _state$designState$co5 === void 0 || (_state$designState$co5 = _state$designState$co5.instructionList) === null || _state$designState$co5 === void 0 || (_state$designState$co5 = _state$designState$co5.filter(el => el.code.startsWith("validation_") && !el.errors)) === null || _state$designState$co5 === void 0 ? void 0 : _state$designState$co5.length) > 0;
          });
          const setSetup = () => {
            dispatch(setup({
              code,
              rules: setupOptions(type)
            }));
          };
          const expandRelevance = () => {
            dispatch(setup({
              code,
              rules: setupOptions(type),
              highlighted: "relevance",
              expanded: ["relevance"]
            }));
          };
          const expandValidation = () => {
            dispatch(setup({
              code,
              rules: setupOptions(type),
              highlighted: "validation",
              expanded: ["validation"]
            }));
          };
          const expandSkipLogic = () => {
            dispatch(setup({
              code,
              rules: setupOptions(type),
              highlighted: "skip_logic",
              expanded: ["skip_logic"]
            }));
          };
          const expandParentRandom = () => {
            if (isGroup) {
              dispatch(setup(_objectSpread3(_objectSpread3({}, surveySetup), {}, {
                highlighted: "random"
              })));
            } else {
              dispatch(setup({
                code: parentCode,
                rules: setupOptions("group"),
                highlighted: "random",
                expanded: ["random"]
              }));
            }
          };
          const textColor = theme.textStyles.question.color;
          const hasSkip = useSelector(state => {
            var _state$designState$co6, _skipInstructions$fil;
            let skipInstructions = (_state$designState$co6 = state.designState[code]) === null || _state$designState$co6 === void 0 || (_state$designState$co6 = _state$designState$co6.instructionList) === null || _state$designState$co6 === void 0 ? void 0 : _state$designState$co6.filter(el => el.code.startsWith("skip_to"));
            return (skipInstructions === null || skipInstructions === void 0 || (_skipInstructions$fil = skipInstructions.filter(el => !el.errors)) === null || _skipInstructions$fil === void 0 ? void 0 : _skipInstructions$fil.length) >= 1;
          });
          const isRandomized = useSelector(state => {
            var _state$designState$co7;
            let indexObj = (_state$designState$co7 = state.designState.componentIndex) === null || _state$designState$co7 === void 0 ? void 0 : _state$designState$co7.find(el => el.code == code);
            return indexObj && indexObj.minIndex != indexObj.maxIndex;
          });
          const isPrioritised = useSelector(state => {
            var _state$designState$co8, _indexObj$prioritised;
            let indexObj = (_state$designState$co8 = state.designState.componentIndex) === null || _state$designState$co8 === void 0 ? void 0 : _state$designState$co8.find(el => el.code == code);
            return (indexObj === null || indexObj === void 0 || (_indexObj$prioritised = indexObj.prioritisedSiblings) === null || _indexObj$prioritised === void 0 ? void 0 : _indexObj$prioritised.length) > 0;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$F.actionControl,
            onClick: e => {
              if (e.target !== e.currentTarget) {
                e.preventDefault();
                e.stopPropagation();
              }
            },
            children: [hasRelevance && /* @__PURE__ */jsxRuntimeExports.jsx(CustomTooltip, {
              title: "Has show/Hide Condition",
              showIcon: false,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                className: styles$F.statusIcon,
                onClick: () => expandRelevance(),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$p, {
                  style: {
                    color: textColor
                  }
                })
              })
            }), hasValidation && /* @__PURE__ */jsxRuntimeExports.jsx(CustomTooltip, {
              title: "Has Validation",
              showIcon: false,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                className: styles$F.statusIcon,
                onClick: () => expandValidation(),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$l, {
                  style: {
                    color: textColor
                  }
                })
              })
            }), isRandomized && /* @__PURE__ */jsxRuntimeExports.jsx(CustomTooltip, {
              title: "Is part of a valid Random Group (within parent)",
              showIcon: false,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                className: styles$F.statusIcon,
                onClick: () => expandParentRandom(),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$k, {
                  style: {
                    color: textColor
                  }
                })
              })
            }), isPrioritised && /* @__PURE__ */jsxRuntimeExports.jsx(CustomTooltip, {
              title: "Is part of a valid Priority Group (within parent)",
              showIcon: false,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                className: styles$F.statusIcon,
                onClick: () => expandParentRandom(),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$j, {
                  style: {
                    color: textColor
                  }
                })
              })
            }), hasSkip && /* @__PURE__ */jsxRuntimeExports.jsx(CustomTooltip, {
              title: "Has active Skip Logic",
              showIcon: false,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                className: styles$F.statusIcon,
                onClick: () => expandSkipLogic(),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$i, {
                  style: {
                    color: textColor
                  }
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
              onClick: () => setSetup(),
              children: /* @__PURE__ */jsxRuntimeExports.jsx(SurveyIcon, {
                name: "settings",
                size: ".75em",
                color: `${textColor}`
              })
            }), !isGroup && /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
              onClick: () => onClone(),
              children: /* @__PURE__ */jsxRuntimeExports.jsx(SurveyIcon, {
                name: "duplicate",
                size: ".75em",
                color: `${textColor}`
              })
            }), !disableDelete && /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
              onClick: () => setOpen(true),
              disabled: disableDelete,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(SurveyIcon, {
                name: "delete",
                size: ".75em",
                color: textColor
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(DeleteModal, {
              open,
              description: t("delete_question"),
              handleClose,
              handleDelete: onDelete
            })]
          });
        }
        const ActionToolbar$1 = React.memo(ActionToolbar);
        const questionItem$8 = "_questionItem_wb37f_1";
        const styles$E = {
          questionItem: questionItem$8
        };
        function TextQuestionDesign({
          code
        }) {
          var _state$validation, _state$content;
          const theme = useTheme();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles$E.questionItem,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              disabled: true,
              variant: "standard",
              required: (_state$validation = state.validation) !== null && _state$validation !== void 0 && (_state$validation = _state$validation.validation_required) !== null && _state$validation !== void 0 && _state$validation.isActive ? true : false,
              label: state.showHint && (((_state$content = state.content) === null || _state$content === void 0 || (_state$content = _state$content.hint) === null || _state$content === void 0 ? void 0 : _state$content[lang]) || ""),
              value: "",
              InputProps: {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  color: theme.textStyles.text.color,
                  fontSize: theme.textStyles.text.size,
                  "&.Mui-disabled": {
                    color: theme.textStyles.text.color,
                    borderBottom: "1px solid"
                  }
                }
              }
            })
          });
        }
        const TextQuestionDesign$1 = React.memo(TextQuestionDesign);
        const questionItem$7 = "_questionItem_1sx0f_1";
        const styles$D = {
          questionItem: questionItem$7
        };
        function EmailQuestionDesign({
          code
        }) {
          var _state$validation2, _state$content2;
          const theme = useTheme();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles$D.questionItem,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              disabled: true,
              variant: "standard",
              required: (_state$validation2 = state.validation) !== null && _state$validation2 !== void 0 && (_state$validation2 = _state$validation2.validation_required) !== null && _state$validation2 !== void 0 && _state$validation2.isActive ? true : false,
              label: state.showHint && (((_state$content2 = state.content) === null || _state$content2 === void 0 || (_state$content2 = _state$content2.hint) === null || _state$content2 === void 0 ? void 0 : _state$content2[lang]) || ""),
              InputProps: {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  color: theme.textStyles.text.color,
                  fontSize: theme.textStyles.text.size
                }
              },
              value: ""
            })
          });
        }
        const EmailQuestionDesign$1 = React.memo(EmailQuestionDesign);
        const questionItem$6 = "_questionItem_169qj_1";
        const styles$C = {
          questionItem: questionItem$6
        };
        function NumberQuestionDesign({
          code
        }) {
          var _state$validation3, _state$content3;
          const theme = useTheme();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles$C.questionItem,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              disabled: true,
              variant: "standard",
              required: (_state$validation3 = state.validation) !== null && _state$validation3 !== void 0 && (_state$validation3 = _state$validation3.validation_required) !== null && _state$validation3 !== void 0 && _state$validation3.isActive ? true : false,
              label: state.showHint && (((_state$content3 = state.content) === null || _state$content3 === void 0 || (_state$content3 = _state$content3.hint) === null || _state$content3 === void 0 ? void 0 : _state$content3[lang]) || ""),
              value: "",
              InputProps: {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  color: theme.textStyles.text.color,
                  fontSize: theme.textStyles.text.size
                }
              }
            })
          });
        }
        const NumberQuestionDesign$1 = React.memo(NumberQuestionDesign);
        const questionItem$5 = "_questionItem_13fbu_1";
        const paragraph = "_paragraph_13fbu_15";
        const wordCount = "_wordCount_13fbu_19";
        const styles$B = {
          questionItem: questionItem$5,
          paragraph: paragraph,
          wordCount: wordCount
        };
        function ParagraphQuestionDesign({
          code,
          t
        }) {
          var _state$validation4, _state$content4;
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$B.questionItem,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(TextareaAutosize, {
              disabled: true,
              className: styles$B.paragraph,
              required: (_state$validation4 = state.validation) !== null && _state$validation4 !== void 0 && (_state$validation4 = _state$validation4.validation_required) !== null && _state$validation4 !== void 0 && _state$validation4.isActive ? true : false,
              placeholder: state.showHint && (((_state$content4 = state.content) === null || _state$content4 === void 0 || (_state$content4 = _state$content4.hint) === null || _state$content4 === void 0 ? void 0 : _state$content4[lang]) || ""),
              minRows: state.minRows || 2,
              value: ""
            }), state.showWordCount ? /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$B.wordCount,
              children: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                children: t("word_count", {
                  lng: lang,
                  count: 0
                })
              })
            }) : ""]
          });
        }
        const ParagraphQuestionDesign$1 = React.memo(ParagraphQuestionDesign);
        const questionItem$4 = "_questionItem_1sx0f_1";
        const styles$A = {
          questionItem: questionItem$4
        };
        function FileUploadQuestionDesign({
          code
        }) {
          var _state$validation5;
          const theme = useTheme();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles$A.questionItem,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              variant: "standard",
              required: (_state$validation5 = state.validation) !== null && _state$validation5 !== void 0 && (_state$validation5 = _state$validation5.validation_required) !== null && _state$validation5 !== void 0 && _state$validation5.isActive ? true : false,
              label: state.showHint && state.content.hint ? state.content.hint[lang] : "",
              InputProps: {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  color: theme.textStyles.text.color,
                  fontSize: theme.textStyles.text.size
                }
              },
              value: "",
              type: "file",
              disabled: true
            })
          });
        }
        const FileUploadQuestionDesign$1 = React.memo(FileUploadQuestionDesign);
        const questionItem$3 = "_questionItem_1sx0f_1";
        const styles$z = {
          questionItem: questionItem$3
        };
        function DateTimeQuestionDesign({
          code
        }) {
          var _state$validation6, _state$content5;
          const theme = useTheme();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles$z.questionItem,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              disabled: true,
              variant: "standard",
              required: (_state$validation6 = state.validation) !== null && _state$validation6 !== void 0 && (_state$validation6 = _state$validation6.validation_required) !== null && _state$validation6 !== void 0 && _state$validation6.isActive ? true : false,
              label: state.showHint && (_state$content5 = state.content) !== null && _state$content5 !== void 0 && _state$content5.hint ? state.content.hint[lang] : "",
              value: "",
              InputProps: {
                sx: {
                  fontFamily: theme.textStyles.text,
                  color: theme.textStyles.text.color,
                  fontSize: theme.textStyles.text.size
                }
              },
              placeholder: state.dateFormat
            })
          });
        }
        const DateTimeQuestionDesign$1 = React.memo(DateTimeQuestionDesign);
        const questionItem$2 = "_questionItem_wb37f_1";
        const styles$y = {
          questionItem: questionItem$2
        };
        function TimeQuestionDesign({
          code
        }) {
          var _state$validation7, _state$content6;
          const theme = useTheme();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles$y.questionItem,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              disabled: true,
              variant: "standard",
              required: (_state$validation7 = state.validation) !== null && _state$validation7 !== void 0 && (_state$validation7 = _state$validation7.validation_required) !== null && _state$validation7 !== void 0 && _state$validation7.isActive ? true : false,
              label: state.showHint && (_state$content6 = state.content) !== null && _state$content6 !== void 0 && _state$content6.hint ? state.content.hint[lang] : "",
              value: "",
              type: "time",
              InputProps: {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  color: theme.textStyles.text.color,
                  fontSize: theme.textStyles.text.size
                }
              }
            })
          });
        }
        const TimeQuestionDesign$1 = React.memo(TimeQuestionDesign);
        var DragIndicator = {};
        var _interopRequireDefault$p = interopRequireDefaultExports;
        Object.defineProperty(DragIndicator, "__esModule", {
          value: true
        });
        var default_1$h = DragIndicator.default = void 0;
        var _createSvgIcon$h = _interopRequireDefault$p(requireCreateSvgIcon());
        var _jsxRuntime$h = jsxRuntimeExports;
        default_1$h = DragIndicator.default = (0, _createSvgIcon$h.default)(/*#__PURE__*/(0, _jsxRuntime$h.jsx)("path", {
          d: "M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2m-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
        }), 'DragIndicator');
        function SCQArray(props) {
          const theme = useTheme();
          const t = props.t;
          const langInfo = useSelector(state => {
            return state.designState.langInfo;
          });
          langInfo.lang === langInfo.mainLang;
          const children = useSelector(state => state.designState[props.code].children);
          useSelector(state => {
            var _state$designState$se;
            return ((_state$designState$se = state.designState.setup) === null || _state$designState$se === void 0 ? void 0 : _state$designState$se.code) == props.code;
          });
          const rows = React.useMemo(() => (children === null || children === void 0 ? void 0 : children.filter(el => el.type == "row")) || [], [children]);
          const columns = React.useMemo(() => (children === null || children === void 0 ? void 0 : children.filter(el => el.type == "column")) || [], [children]);
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [inDesign(props.designMode) && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$L.addColumn,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  fontSize: theme.textStyles.text.size,
                  color: theme.textStyles.question.color
                },
                size: "small",
                onClick: e => props.addNewAnswer(props.code, props.type, "column"),
                children: t("add_column")
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(TableContainer, {
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(Table, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(TableHead, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsxs(TableRow, {
                    children: [inDesign(props.designMode) && /* @__PURE__ */jsxRuntimeExports.jsx(TableCell, {
                      sx: {
                        padding: "0"
                      }
                    }, "move"), /* @__PURE__ */jsxRuntimeExports.jsx(TableCell, {}, "content"), columns.map((item, index) => {
                      return /* @__PURE__ */jsxRuntimeExports.jsx(SCQArrayHeaderDesign$1, {
                        parentQualifiedCode: props.qualifiedCode,
                        langInfo,
                        designMode: props.designMode,
                        t: props.t,
                        item,
                        index
                      }, item.qualifiedCode);
                    }), inDesign(props.designMode) && /* @__PURE__ */jsxRuntimeExports.jsx(TableCell, {
                      sx: {
                        padding: "0"
                      }
                    }, "remove")]
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx(TableBody, {
                  children: rows.map((item, index) => {
                    return /* @__PURE__ */jsxRuntimeExports.jsx(SCQArrayRowDesign$1, {
                      parentQualifiedCode: props.qualifiedCode,
                      langInfo,
                      t: props.t,
                      designMode: props.designMode,
                      item,
                      colCount: columns.length,
                      index
                    }, item.qualifiedCode);
                  })
                })]
              })
            }), props.onMainLang && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$L.addRow,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  fontSize: theme.textStyles.text.size,
                  color: theme.textStyles.question.color
                },
                size: "small",
                onClick: e => props.addNewAnswer(props.code, props.type, "row"),
                children: t("add_row")
              })
            })]
          });
        }
        const SCQArray$1 = React.memo(SCQArray);
        function SCQArrayRowDesign$1({
          item,
          index,
          colCount,
          designMode,
          t,
          langInfo,
          parentQualifiedCode
        }) {
          const dispatch = useDispatch();
          const theme = useTheme();
          const ref = reactExports.useRef();
          const onMainLang = langInfo.lang === langInfo.mainLang;
          const content = useSelector(state => {
            var _state$designState$it;
            return (_state$designState$it = state.designState[item.qualifiedCode].content) === null || _state$designState$it === void 0 || (_state$designState$it = _state$designState$it["label"]) === null || _state$designState$it === void 0 ? void 0 : _state$designState$it[langInfo.lang];
          });
          const mainContent = useSelector(state => {
            var _state$designState$it2;
            return (_state$designState$it2 = state.designState[item.qualifiedCode].content) === null || _state$designState$it2 === void 0 || (_state$designState$it2 = _state$designState$it2["label"]) === null || _state$designState$it2 === void 0 ? void 0 : _state$designState$it2[langInfo.mainLang];
          });
          const itemType = `col-${parentQualifiedCode}`;
          const _useDrag = useDrag({
              type: itemType,
              item: {
                qualifiedCode: item.qualifiedCode,
                index
              },
              collect: monitor => monitor.isDragging()
            }, [index]),
            _useDrag2 = _slicedToArray2(_useDrag, 3),
            isDragging = _useDrag2[0],
            drag = _useDrag2[1],
            preview = _useDrag2[2];
          const _useDrop = useDrop({
              accept: itemType,
              collect(monitor) {
                return {
                  handlerId: monitor.getHandlerId()
                };
              },
              hover(item2, monitor) {
                var _ref$current;
                if (!ref.current || !monitor.isOver({
                  shallow: true
                }) || !item2) {
                  return;
                }
                const dragIndex = item2.index;
                const hoverIndex = index;
                if (dragIndex === hoverIndex) {
                  return;
                }
                const hoverBoundingRect = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.getBoundingClientRect();
                const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
                const clientOffset = monitor.getClientOffset();
                const hoverClientY = clientOffset.y - hoverBoundingRect.top;
                if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {
                  return;
                }
                if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {
                  return;
                }
                dispatch(onDrag({
                  type: "reorder_answers_by_type",
                  id: item2.qualifiedCode,
                  fromIndex: item2.index,
                  toIndex: hoverIndex
                }));
                item2.index = hoverIndex;
              }
            }),
            _useDrop2 = _slicedToArray2(_useDrop, 2),
            handlerId = _useDrop2[0].handlerId,
            drop = _useDrop2[1];
          drop(preview(ref));
          return /* @__PURE__ */jsxRuntimeExports.jsxs(TableRow, {
            style: {
              opacity: isDragging ? "0.2" : "1"
            },
            ref,
            "data-handler-id": handlerId,
            children: [inDesign(designMode) && /* @__PURE__ */jsxRuntimeExports.jsx(TableCell, {
              ref: drag,
              sx: {
                padding: "0",
                color: theme.textStyles.text.color
              },
              children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$h, {})
            }, "move"), /* @__PURE__ */jsxRuntimeExports.jsx(TableCell, {
              sx: {
                fontFamily: theme.textStyles.text.font,
                color: theme.textStyles.text.color,
                fontSize: theme.textStyles.text.size,
                padding: "4px"
              },
              children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
                variant: "standard",
                value: content || "",
                onChange: e => {
                  dispatch(changeContent({
                    code: item.qualifiedCode,
                    key: "label",
                    lang: langInfo.lang,
                    value: e.target.value
                  }));
                },
                placeholder: onMainLang ? t("content_editor_placeholder_option") : mainContent || t("content_editor_placeholder_option"),
                InputProps: {
                  disableUnderline: true,
                  sx: {
                    fontFamily: theme.textStyles.text.font,
                    color: theme.textStyles.text.color,
                    fontSize: theme.textStyles.text.size
                  }
                }
              })
            }), [...Array(colCount)].map((_option, index2) => {
              return /* @__PURE__ */jsxRuntimeExports.jsx(TableCell, {
                scope: "row",
                align: "center",
                sx: {
                  padding: "4px"
                },
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Radio, {
                  sx: {
                    "&.Mui-disabled": {
                      color: theme.textStyles.text.color
                    }
                  },
                  disabled: true
                })
              }, index2);
            }), inDesign(designMode) && /* @__PURE__ */jsxRuntimeExports.jsx(TableCell, {
              onClick: e => dispatch(removeAnswer(item.qualifiedCode)),
              sx: {
                padding: "0",
                color: theme.textStyles.text.color
              },
              children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$o, {})
            }, "remove")]
          }, item.code);
        }
        function SCQArrayHeaderDesign$1({
          item,
          index,
          designMode,
          t,
          langInfo,
          parentQualifiedCode
        }) {
          const dispatch = useDispatch();
          const theme = useTheme();
          const ref = reactExports.useRef();
          const onMainLang = langInfo.lang === langInfo.mainLang;
          const isRtl = rtlLanguage.includes(langInfo.lang);
          const isLtr = !isRtl;
          const content = useSelector(state => {
            var _state$designState$it3;
            return (_state$designState$it3 = state.designState[item.qualifiedCode].content) === null || _state$designState$it3 === void 0 || (_state$designState$it3 = _state$designState$it3["label"]) === null || _state$designState$it3 === void 0 ? void 0 : _state$designState$it3[langInfo.lang];
          });
          const mainContent = useSelector(state => {
            var _state$designState$it4;
            return (_state$designState$it4 = state.designState[item.qualifiedCode].content) === null || _state$designState$it4 === void 0 || (_state$designState$it4 = _state$designState$it4["label"]) === null || _state$designState$it4 === void 0 ? void 0 : _state$designState$it4[langInfo.mainLang];
          });
          const itemType = `row-${parentQualifiedCode}`;
          const _useDrag3 = useDrag({
              type: itemType,
              item: {
                qualifiedCode: item.qualifiedCode,
                index
              },
              collect: monitor => monitor.isDragging()
            }, [index]),
            _useDrag4 = _slicedToArray2(_useDrag3, 3),
            isDragging = _useDrag4[0],
            drag = _useDrag4[1],
            preview = _useDrag4[2];
          const _useDrop3 = useDrop({
              accept: itemType,
              collect(monitor) {
                return {
                  handlerId: monitor.getHandlerId()
                };
              },
              hover(item2, monitor) {
                var _ref$current2;
                if (!ref.current || !monitor.isOver({
                  shallow: true
                }) || !item2) {
                  return;
                }
                const dragIndex = item2.index;
                const hoverIndex = index;
                if (dragIndex === hoverIndex) {
                  return;
                }
                const hoverBoundingRect = (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.getBoundingClientRect();
                const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;
                const clientOffset = monitor.getClientOffset();
                const hoverClientX = clientOffset.x - hoverBoundingRect.left;
                if (isLtr && dragIndex < hoverIndex && hoverClientX < hoverMiddleX) {
                  return;
                }
                if (isLtr && dragIndex > hoverIndex && hoverClientX > hoverMiddleX) {
                  return;
                }
                if (isRtl && dragIndex < hoverIndex && hoverClientX > hoverMiddleX) {
                  return;
                }
                if (isRtl && dragIndex > hoverIndex && hoverClientX < hoverMiddleX) {
                  return;
                }
                dispatch(onDrag({
                  type: "reorder_answers_by_type",
                  id: item2.qualifiedCode,
                  fromIndex: item2.index,
                  toIndex: hoverIndex
                }));
                item2.index = hoverIndex;
              }
            }),
            _useDrop4 = _slicedToArray2(_useDrop3, 2),
            handlerId = _useDrop4[0].handlerId,
            drop = _useDrop4[1];
          drop(preview(ref));
          return /* @__PURE__ */jsxRuntimeExports.jsxs(TableCell, {
            ref,
            "data-handler-id": handlerId,
            align: "center",
            sx: {
              opacity: isDragging ? "0.2" : "1",
              fontFamily: theme.textStyles.text.font,
              color: theme.textStyles.text.color,
              fontSize: theme.textStyles.text.size,
              padding: "4px"
            },
            children: [inDesign(designMode) && /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              style: {
                display: "inline-flex"
              },
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                ref: drag,
                sx: {
                  padding: "0"
                },
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$h, {})
              }, "move"), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                sx: {
                  padding: "0"
                },
                onClick: e => dispatch(removeAnswer(item.qualifiedCode)),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$o, {})
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              variant: "standard",
              value: content || "",
              onChange: e => {
                dispatch(changeContent({
                  code: item.qualifiedCode,
                  key: "label",
                  lang: langInfo.lang,
                  value: e.target.value
                }));
              },
              placeholder: onMainLang ? t("content_editor_placeholder_option") : mainContent || t("content_editor_placeholder_option"),
              inputProps: {
                style: {
                  textAlign: "center"
                }
              },
              InputProps: {
                disableUnderline: true,
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  color: theme.textStyles.text.color,
                  fontSize: theme.textStyles.text.size
                }
              }
            })]
          }, item.qualifiedCode);
        }
        var Videocam = {};
        var _interopRequireDefault$o = interopRequireDefaultExports;
        Object.defineProperty(Videocam, "__esModule", {
          value: true
        });
        var default_1$g = Videocam.default = void 0;
        var _createSvgIcon$g = _interopRequireDefault$o(requireCreateSvgIcon());
        var _jsxRuntime$g = jsxRuntimeExports;
        default_1$g = Videocam.default = (0, _createSvgIcon$g.default)(/*#__PURE__*/(0, _jsxRuntime$g.jsx)("path", {
          d: "M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11z"
        }), 'Videocam');
        const placeholder$1 = "_placeholder_4iqf5_1";
        const buttonContainer$1 = "_buttonContainer_4iqf5_9";
        const styles$x = {
          placeholder: placeholder$1,
          buttonContainer: buttonContainer$1
        };
        function VideoDisplayDesign({
          code,
          t,
          onMainLang
        }) {
          var _state$resources, _state$resources2;
          const designService = useService("design");
          const dispatch = useDispatch();
          const _reactExports$useStat27 = reactExports.useState(false),
            _reactExports$useStat28 = _slicedToArray2(_reactExports$useStat27, 2),
            isUploading = _reactExports$useStat28[0],
            setUploading = _reactExports$useStat28[1];
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const handleVideoUpload = e => {
            e.preventDefault();
            setUploading(true);
            let file = e.target.files[0];
            designService.uploadResource(file).then(response => {
              setUploading(false);
              dispatch(changeResources({
                code,
                key: "videoUrl",
                value: response.name
              }));
            }).catch(err => {
              console.error(err);
            });
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [!isUploading && ((_state$resources = state.resources) === null || _state$resources === void 0 ? void 0 : _state$resources.videoUrl) && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              style: {
                position: "relative",
                marginTop: "16px",
                // 16:9 aspect ratio
                paddingTop: state.audio_only ? "10%" : "56%"
              },
              children: /* @__PURE__ */jsxRuntimeExports.jsx(ReactPlayer, {
                url: buildResourceUrl(state.resources.videoUrl),
                loop: state.loop || false,
                light: true,
                controls: true,
                config: {
                  forceAudio: state.audio_only || false
                },
                style: {
                  backgroundColor: "black",
                  position: "absolute",
                  top: "0",
                  left: "0"
                },
                volume: 1,
                width: "100%",
                height: "100%"
              })
            }), isUploading ? /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$x.buttonContainer,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(LoadingDots, {}), /* @__PURE__ */jsxRuntimeExports.jsx("br", {}), /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                children: t("uploading_video")
              })]
            }) : onMainLang ? /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$x.buttonContainer,
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(Button, {
                component: "label",
                variant: "outlined",
                startIcon: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$g, {}),
                children: [(_state$resources2 = state.resources) !== null && _state$resources2 !== void 0 && _state$resources2.videoUrl ? t("replace_video") : t("upload_video"), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                  hidden: true,
                  id: code,
                  accept: "video/*",
                  type: "file",
                  onChange: handleVideoUpload
                })]
              })
            }) : /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {})]
          });
        }
        const signatureCanvas = "_signatureCanvas_1uxb1_1";
        const styles$w = {
          signatureCanvas: signatureCanvas
        };
        function SignatureDesign() {
          return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
            className: styles$w.signatureCanvas,
            sx: {
              backgroundColor: "background.default"
            },
            children: /* @__PURE__ */jsxRuntimeExports.jsx("img", {
              src: "/signature.png",
              style: {
                backgroundColor: "rgba(255,255,255,255)",
                width: "80%",
                maxWidth: "500px",
                height: "200px"
              }
            })
          });
        }
        const SignatureDesign$1 = React.memo(SignatureDesign);
        var Photo = {};
        var _interopRequireDefault$n = interopRequireDefaultExports;
        Object.defineProperty(Photo, "__esModule", {
          value: true
        });
        var default_1$f = Photo.default = void 0;
        var _createSvgIcon$f = _interopRequireDefault$n(requireCreateSvgIcon());
        var _jsxRuntime$f = jsxRuntimeExports;
        default_1$f = Photo.default = (0, _createSvgIcon$f.default)(/*#__PURE__*/(0, _jsxRuntime$f.jsx)("path", {
          d: "M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2M8.5 13.5l2.5 3.01L14.5 12l4.5 6H5z"
        }), 'Photo');
        const placeholder = "_placeholder_xjf3c_1";
        const buttonContainer = "_buttonContainer_xjf3c_9";
        const imageContainer$2 = "_imageContainer_xjf3c_14";
        const styles$v = {
          placeholder: placeholder,
          buttonContainer: buttonContainer,
          imageContainer: imageContainer$2
        };
        function ImageDisplayDesign({
          code,
          t,
          onMainLang
        }) {
          var _state$resources3, _state$resources4;
          const designService = useService("design");
          const dispatch = useDispatch();
          const _reactExports$useStat29 = reactExports.useState(false),
            _reactExports$useStat30 = _slicedToArray2(_reactExports$useStat29, 2),
            isUploading = _reactExports$useStat30[0],
            setUploading = _reactExports$useStat30[1];
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const handleUpload = e => {
            e.preventDefault();
            setUploading(true);
            let file = e.target.files[0];
            designService.uploadResource(file).then(response => {
              setUploading(false);
              dispatch(changeResources({
                code,
                key: "imageUrl",
                value: response.name
              }));
            }).catch(err => {
              console.error(err);
            });
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [!isUploading && ((_state$resources3 = state.resources) === null || _state$resources3 === void 0 ? void 0 : _state$resources3.imageUrl) && /* @__PURE__ */jsxRuntimeExports.jsx("img", {
              style: {
                width: "100%"
              },
              src: buildResourceUrl(state.resources.imageUrl)
            }), isUploading ? /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$v.buttonContainer,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(LoadingDots, {}), /* @__PURE__ */jsxRuntimeExports.jsx("br", {}), /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                children: t("uploading_image")
              })]
            }) : onMainLang ? /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$v.buttonContainer,
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(Button, {
                variant: "outlined",
                component: "label",
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$f, {
                  className: "mr-10"
                }), (_state$resources4 = state.resources) !== null && _state$resources4 !== void 0 && _state$resources4.imageUrl ? t("replace_image") : t("upload_image"), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                  hidden: true,
                  accept: "image/*",
                  type: "file",
                  onChange: handleUpload
                })]
              })
            }) : /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {})]
          });
        }
        const ImageDisplayDesign$1 = React.memo(ImageDisplayDesign);
        const choicesContainer$1 = "_choicesContainer_k0bnu_1";
        const choice = "_choice_k0bnu_1";
        const choiceLabels = "_choiceLabels_k0bnu_19";
        const styles$u = {
          choicesContainer: choicesContainer$1,
          choice: choice,
          choiceLabels: choiceLabels
        };
        function NPSDesign({
          code
        }) {
          var _state$content7, _state$content8;
          useTheme();
          let columns = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              className: styles$u.choiceLabels,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                children: (_state$content7 = state.content) === null || _state$content7 === void 0 || (_state$content7 = _state$content7.lower_bound_hint) === null || _state$content7 === void 0 ? void 0 : _state$content7[lang]
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                children: (_state$content8 = state.content) === null || _state$content8 === void 0 || (_state$content8 = _state$content8.higher_bound_hint) === null || _state$content8 === void 0 ? void 0 : _state$content8[lang]
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
              className: styles$u.choicesContainer,
              children: columns.map(option => {
                return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                  className: styles$u.choice,
                  children: option
                }, option);
              })
            })]
          });
        }
        const NPSDesign$1 = React.memo(NPSDesign);
        const container$2 = "_container_cyg3h_1";
        const styles$t = {
          container: container$2
        };
        function PhotoCaptureDesign({
          code
        }) {
          var _state$content9;
          useTheme$1();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            className: styles$t.container,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("img", {
              src: "/camera.png",
              style: {
                maxHeight: "200px"
              }
            }), /* @__PURE__ */jsxRuntimeExports.jsx("br", {}), state.showHint && /* @__PURE__ */jsxRuntimeExports.jsx("span", {
              children: ((_state$content9 = state.content) === null || _state$content9 === void 0 || (_state$content9 = _state$content9.hint) === null || _state$content9 === void 0 ? void 0 : _state$content9[lang]) || ""
            })]
          });
        }
        const PhotoCaptureDesign$1 = React.memo(PhotoCaptureDesign);
        const container$1 = "_container_cyg3h_1";
        const styles$s = {
          container: container$1
        };
        function VideoCaptureDesign({
          code
        }) {
          var _state$content10;
          useTheme$1();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            className: styles$s.container,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("img", {
              src: "/video.png",
              style: {
                maxHeight: "200px"
              }
            }), /* @__PURE__ */jsxRuntimeExports.jsx("br", {}), state.showHint && /* @__PURE__ */jsxRuntimeExports.jsx("span", {
              children: ((_state$content10 = state.content) === null || _state$content10 === void 0 || (_state$content10 = _state$content10.hint) === null || _state$content10 === void 0 ? void 0 : _state$content10[lang]) || ""
            })]
          });
        }
        const VideoCaptureDesign$1 = React.memo(VideoCaptureDesign);
        const container = "_container_cyg3h_1";
        const styles$r = {
          container: container
        };
        function BarcodeDesign({
          code
        }) {
          var _state$content11;
          useTheme$1();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            className: styles$r.container,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("img", {
              src: "/barcode.png",
              style: {
                maxHeight: "200px"
              }
            }), /* @__PURE__ */jsxRuntimeExports.jsx("br", {}), state.showHint && /* @__PURE__ */jsxRuntimeExports.jsx("span", {
              children: ((_state$content11 = state.content) === null || _state$content11 === void 0 || (_state$content11 = _state$content11.hint) === null || _state$content11 === void 0 ? void 0 : _state$content11[lang]) || ""
            })]
          });
        }
        const BarcodeDesign$1 = React.memo(BarcodeDesign);
        const answerAdd = "_answerAdd_5tmqk_1";
        const questionItem$1 = "_questionItem_5tmqk_9";
        const choicesContainer = "_choicesContainer_5tmqk_15";
        const styles$q = {
          answerAdd: answerAdd,
          questionItem: questionItem$1,
          choicesContainer: choicesContainer
        };
        const answerItem = "_answerItem_shykq_1";
        const answerIcon = "_answerIcon_shykq_10";
        const answerIconOther = "_answerIconOther_shykq_18";
        const answerNumberOrder = "_answerNumberOrder_shykq_27";
        const answerControl = "_answerControl_shykq_32";
        const answerControlRtl = "_answerControlRtl_shykq_37";
        const answerControlOther = "_answerControlOther_shykq_42";
        const answerControlOtherRtl = "_answerControlOtherRtl_shykq_47";
        const answerOtherControl = "_answerOtherControl_shykq_52";
        const styles$p = {
          answerItem: answerItem,
          answerIcon: answerIcon,
          answerIconOther: answerIconOther,
          answerNumberOrder: answerNumberOrder,
          answerControl: answerControl,
          answerControlRtl: answerControlRtl,
          answerControlOther: answerControlOther,
          answerControlOtherRtl: answerControlOtherRtl,
          answerOtherControl: answerOtherControl
        };
        var Build = {};
        var _interopRequireDefault$m = interopRequireDefaultExports;
        Object.defineProperty(Build, "__esModule", {
          value: true
        });
        var default_1$e = Build.default = void 0;
        var _createSvgIcon$e = _interopRequireDefault$m(requireCreateSvgIcon());
        var _jsxRuntime$e = jsxRuntimeExports;
        default_1$e = Build.default = (0, _createSvgIcon$e.default)(/*#__PURE__*/(0, _jsxRuntime$e.jsx)("path", {
          d: "m22.7 19-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4"
        }), 'Build');
        function ChoiceItemDesign(props) {
          const dispatch = useDispatch();
          const theme = useTheme();
          const ref = reactExports.useRef(null);
          const langInfo = useSelector(state => {
            return state.designState.langInfo;
          });
          const answer = useSelector(state => {
            return state.designState[props.qualifiedCode];
          });
          const onMainLang = langInfo.lang === langInfo.mainLang;
          const lang = langInfo.lang;
          const isRtl = rtlLanguage.includes(lang);
          const isInSetup = useSelector(state => {
            var _state$designState$se2;
            return answer.type === "other" && ((_state$designState$se2 = state.designState.setup) === null || _state$designState$se2 === void 0 ? void 0 : _state$designState$se2.code) == props.qualifiedCode + "Atext";
          });
          const content = useSelector(state => {
            var _state$designState$pr2;
            return (_state$designState$pr2 = state.designState[props.qualifiedCode].content) === null || _state$designState$pr2 === void 0 || (_state$designState$pr2 = _state$designState$pr2["label"]) === null || _state$designState$pr2 === void 0 ? void 0 : _state$designState$pr2[lang];
          });
          const mainContent = useSelector(state => {
            var _state$designState$pr3;
            return (_state$designState$pr3 = state.designState[props.qualifiedCode].content) === null || _state$designState$pr3 === void 0 || (_state$designState$pr3 = _state$designState$pr3["label"]) === null || _state$designState$pr3 === void 0 ? void 0 : _state$designState$pr3[langInfo.mainLang];
          });
          const getStyles = isDragging2 => {
            const styles2 = {
              transition: "all 500ms"
            };
            if (isDragging2) {
              styles2.opacity = 0.5;
            }
            return styles2;
          };
          const _useDrag5 = useDrag({
              type: props.droppableId,
              item: {
                index: props.index,
                draggableId: props.qualifiedCode,
                type: props.droppableId,
                code: props.code,
                itemType: props.type,
                droppableId: props.droppableId
              },
              collect: monitor => monitor.isDragging()
            }, [props]),
            _useDrag6 = _slicedToArray2(_useDrag5, 3),
            isDragging = _useDrag6[0],
            drag = _useDrag6[1],
            preview = _useDrag6[2];
          const _useDrop5 = useDrop({
              accept: props.droppableId,
              collect(monitor) {
                return {
                  handlerId: monitor.getHandlerId()
                };
              },
              hover(item, monitor) {
                var _ref$current3;
                if (!ref.current || !monitor.isOver({
                  shallow: true
                }) || !item) {
                  return;
                }
                const dragIndex = item.index;
                const hoverIndex = props.index;
                if (dragIndex === hoverIndex) {
                  return;
                }
                const hoverBoundingRect = (_ref$current3 = ref.current) === null || _ref$current3 === void 0 ? void 0 : _ref$current3.getBoundingClientRect();
                const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
                const clientOffset = monitor.getClientOffset();
                const hoverClientY = clientOffset.y - hoverBoundingRect.top;
                if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {
                  return;
                }
                if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {
                  return;
                }
                dispatch(onDrag({
                  type: "reorder_answers",
                  id: item.draggableId,
                  fromIndex: item.index,
                  toIndex: props.index
                }));
                item.index = hoverIndex;
              }
            }),
            _useDrop6 = _slicedToArray2(_useDrop5, 2),
            handlerId = _useDrop6[0].handlerId,
            drop = _useDrop6[1];
          drop(preview(ref));
          getContrastColor(theme.palette.background.paper);
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            ref,
            style: getStyles(isDragging),
            "data-handler-id": handlerId,
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              sx: {
                backgroundColor: isInSetup ? "beige" : "inherit"
              },
              className: styles$p.answerItem,
              children: [inDesign(props.designMode) && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                ref: drag,
                className: styles$p.answerIcon,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$h, {
                  ref: drag,
                  sx: {
                    fontSize: 18
                  }
                })
              }), props.label ? /* @__PURE__ */jsxRuntimeExports.jsx("b", {
                children: props.label
              }) : "", /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
                variant: "standard",
                disabled: !contentEditable(props.designMode),
                className: answer.type === "other" && isRtl ? styles$p.answerControlOtherRtl : answer.type === "other" ? styles$p.answerControlOther : isRtl ? styles$p.answerControlRtl : styles$p.answerControl,
                value: content || "",
                onChange: e => dispatch(changeContent({
                  code: props.qualifiedCode,
                  key: "label",
                  lang,
                  value: e.target.value
                })),
                placeholder: onMainLang ? props.t("content_editor_placeholder_option") : mainContent || props.t("content_editor_placeholder_option"),
                InputProps: {
                  sx: {
                    fontFamily: theme.textStyles.text.font,
                    color: theme.textStyles.text.color,
                    fontSize: theme.textStyles.text.size
                  }
                }
              }), answer.type === "other" && /* @__PURE__ */jsxRuntimeExports.jsx(default_1$e, {
                sx: {
                  fontSize: 18
                },
                className: styles$p.answerIconOther,
                onClick: () => {
                  dispatch(setup({
                    code: props.qualifiedCode + "Atext",
                    rules: setupOptions("other_text")
                  }));
                }
              }, "setup"), inDesign(props.designMode) && /* @__PURE__ */jsxRuntimeExports.jsx(default_1$o, {
                sx: {
                  fontSize: 18
                },
                className: styles$p.answerIcon,
                onClick: e => dispatch(removeAnswer(props.qualifiedCode))
              }, "close")]
            })
          });
        }
        function ChoiceQuestion(props) {
          const theme = useTheme();
          const t = props.t;
          const children = useSelector(state => {
            return state.designState[props.code].children;
          });
          const questionType = useSelector(state => {
            return state.designState[props.code].type;
          });
          const isOther = (questionType == "mcq" || questionType == "scq") && (!children || !children.some(el => el.code === "Aother"));
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$q.questionItem,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$q.choicesContainer,
              children: children && children.length > 0 && children.map((item, index) => /* @__PURE__ */jsxRuntimeExports.jsx(ChoiceItemDesign, {
                designMode: props.designMode,
                code: item.code,
                t: props.t,
                label: item.code,
                qualifiedCode: item.qualifiedCode,
                index,
                type: props.type,
                droppableId: `option-${props.code}`
              }, item.code))
            }), inDesign(props.designMode) && /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$q.answerAdd,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                size: "small",
                style: {
                  fontFamily: theme.textStyles.text.font,
                  fontSize: theme.textStyles.text.size,
                  color: theme.textStyles.question.color
                },
                onClick: () => props.addNewAnswer(props.code, questionType),
                children: t("add_option")
              }), isOther && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx("span", {
                  style: {
                    color: theme.textStyles.question.color
                  },
                  children: t("or")
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  style: {
                    fontFamily: theme.textStyles.text.font,
                    fontSize: theme.textStyles.text.size,
                    color: theme.textStyles.question.color
                  },
                  size: "small",
                  className: styles$q.answerIcon,
                  onClick: () => props.addNewAnswer(props.code, questionType, "other"),
                  children: t("add_other")
                })]
              })]
            })]
          });
        }
        const ChoiceQuestion$1 = React.memo(ChoiceQuestion);
        const addAnswerIcon$2 = "_addAnswerIcon_4rcog_1";
        const questionItem = "_questionItem_4rcog_5";
        const addAnswerButton$2 = "_addAnswerButton_4rcog_10";
        const styles$o = {
          addAnswerIcon: addAnswerIcon$2,
          questionItem: questionItem,
          addAnswerButton: addAnswerButton$2
        };
        const imageIconButton$1 = "_imageIconButton_chgwf_1";
        const imageContainer$1 = "_imageContainer_chgwf_8";
        const addAnswerIcon$1 = "_addAnswerIcon_chgwf_16";
        const loadingContainer$1 = "_loadingContainer_chgwf_20";
        const addAnswerButton$1 = "_addAnswerButton_chgwf_26";
        const buttonContainers$1 = "_buttonContainers_chgwf_34";
        const styles$n = {
          imageIconButton: imageIconButton$1,
          imageContainer: imageContainer$1,
          addAnswerIcon: addAnswerIcon$1,
          loadingContainer: loadingContainer$1,
          addAnswerButton: addAnswerButton$1,
          buttonContainers: buttonContainers$1
        };
        var DeleteOutline = {};
        var _interopRequireDefault$l = interopRequireDefaultExports;
        Object.defineProperty(DeleteOutline, "__esModule", {
          value: true
        });
        var default_1$d = DeleteOutline.default = void 0;
        var _createSvgIcon$d = _interopRequireDefault$l(requireCreateSvgIcon());
        var _jsxRuntime$d = jsxRuntimeExports;
        default_1$d = DeleteOutline.default = (0, _createSvgIcon$d.default)(/*#__PURE__*/(0, _jsxRuntime$d.jsx)("path", {
          d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM8 9h8v10H8zm7.5-5-1-1h-5l-1 1H5v2h14V4z"
        }), 'DeleteOutline');
        var Add = {};
        var _interopRequireDefault$k = interopRequireDefaultExports;
        Object.defineProperty(Add, "__esModule", {
          value: true
        });
        var default_1$c = Add.default = void 0;
        var _createSvgIcon$c = _interopRequireDefault$k(requireCreateSvgIcon());
        var _jsxRuntime$c = jsxRuntimeExports;
        default_1$c = Add.default = (0, _createSvgIcon$c.default)(/*#__PURE__*/(0, _jsxRuntime$c.jsx)("path", {
          d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
        }), 'Add');
        function ImageChoiceItemDesign({
          parentCode,
          index,
          qualifiedCode,
          type,
          columnNumber,
          imageAspectRatio,
          designMode,
          hideText,
          t,
          addAnswer
        }) {
          var _answer$resources;
          const designService = useService("design");
          const dispatch = useDispatch();
          const theme = useTheme();
          const ref = reactExports.useRef();
          const _reactExports$useStat31 = reactExports.useState(false),
            _reactExports$useStat32 = _slicedToArray2(_reactExports$useStat31, 2),
            isUploading = _reactExports$useStat32[0],
            setUploading = _reactExports$useStat32[1];
          const langInfo = useSelector(state => {
            return state.designState.langInfo;
          });
          const answer = useSelector(state => {
            return type == "add" ? void 0 : state.designState[qualifiedCode];
          });
          const onMainLang = langInfo.lang === langInfo.mainLang;
          const lang = langInfo.lang;
          const isRtl = rtlLanguage.includes(lang);
          const content = useSelector(state => {
            var _state$designState$qu;
            return type == "add" ? void 0 : (_state$designState$qu = state.designState[qualifiedCode].content) === null || _state$designState$qu === void 0 || (_state$designState$qu = _state$designState$qu["label"]) === null || _state$designState$qu === void 0 ? void 0 : _state$designState$qu[lang];
          });
          const mainContent = useSelector(state => {
            var _state$designState$qu2;
            return type == "add" ? void 0 : (_state$designState$qu2 = state.designState[qualifiedCode].content) === null || _state$designState$qu2 === void 0 || (_state$designState$qu2 = _state$designState$qu2["label"]) === null || _state$designState$qu2 === void 0 ? void 0 : _state$designState$qu2[langInfo.mainLang];
          });
          const onDelete = () => {
            if (window.confirm(`Are you sure?`)) {
              dispatch(removeAnswer(qualifiedCode));
            }
          };
          const backgroundImage = answer !== null && answer !== void 0 && (_answer$resources = answer.resources) !== null && _answer$resources !== void 0 && _answer$resources.image ? `url('${buildResourceUrl(answer.resources.image)}')` : "0";
          function handleImageChange(e) {
            e.preventDefault();
            let file = e.target.files[0];
            setUploading(true);
            designService.uploadResource(file).then(response => {
              setUploading(false);
              dispatch(changeResources({
                code: qualifiedCode,
                key: "image",
                value: response.name
              }));
            }).catch(err => {
              setUploading(false);
              console.error(err);
            });
          }
          const dragType = parentCode + "image-drag";
          const getRowByIndex = index2 => {
            return Math.round(index2 / columnNumber);
          };
          const getColByIndex = index2 => {
            return index2 % columnNumber;
          };
          const colIndex = getColByIndex(index);
          const rowIndex = getRowByIndex(index);
          const _useDrag7 = useDrag({
              type: dragType,
              item: {
                index,
                colIndex,
                rowIndex,
                draggableId: qualifiedCode,
                parentCode,
                type: dragType,
                itemType: dragType
              },
              collect: monitor => monitor.isDragging()
            }, [index]),
            _useDrag8 = _slicedToArray2(_useDrag7, 3),
            isDragging = _useDrag8[0],
            drag = _useDrag8[1],
            preview = _useDrag8[2];
          const _useDrop7 = useDrop({
              accept: dragType,
              collect(monitor) {
                return {
                  handlerId: monitor.getHandlerId()
                };
              },
              hover(item, monitor) {
                var _ref$current4;
                if (!ref.current || !monitor.isOver({
                  shallow: true
                }) || !item) {
                  return;
                }
                const dragIndex = item.index;
                const hoverIndex = index;
                const dragRowIndex = item.rowIndex;
                const hoverRowIndex = rowIndex;
                const dragColIndex = item.colIndex;
                const hoverColIndex = colIndex;
                if (dragIndex === hoverIndex) {
                  return;
                }
                const hoverBoundingRect = (_ref$current4 = ref.current) === null || _ref$current4 === void 0 ? void 0 : _ref$current4.getBoundingClientRect();
                const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
                const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;
                const clientOffset = monitor.getClientOffset();
                const hoverClientY = clientOffset.y - hoverBoundingRect.top;
                const hoverClientX = clientOffset.x - hoverBoundingRect.left;
                if (dragRowIndex < hoverRowIndex && hoverClientY < hoverMiddleY && dragColIndex < hoverColIndex && hoverClientX < hoverMiddleX) {
                  return;
                }
                if (dragRowIndex > hoverRowIndex && hoverClientY > hoverMiddleY && dragColIndex > hoverColIndex && hoverClientX > hoverMiddleX) {
                  return;
                }
                {
                  dispatch(onDrag({
                    type: "reorder_answers",
                    id: item.draggableId,
                    fromIndex: dragIndex,
                    toIndex: hoverIndex
                  }));
                  item.index = hoverIndex;
                  item.rowIndex = hoverRowIndex;
                  item.colIndex = hoverColIndex;
                }
              }
            }),
            _useDrop8 = _slicedToArray2(_useDrop7, 2),
            handlerId = _useDrop8[0].handlerId,
            drop = _useDrop8[1];
          drop(preview(ref));
          return type == "add" ? /* @__PURE__ */jsxRuntimeExports.jsx(Grid$1, {
            height: "100%",
            item: true,
            xs: 12 / columnNumber,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
              className: styles$n.addAnswerButton,
              style: {
                minHeight: "100px",
                height: "100%",
                width: "100%",
                backgroundColor: theme.palette.background.default,
                borderRadius: "4px"
              },
              children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                sx: {
                  color: theme.textStyles.text.color
                },
                className: styles$n.addAnswerIcon,
                onClick: () => {
                  addAnswer();
                },
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$c, {})
              })
            })
          }, "add") : /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(Grid$1, {
              style: {
                opacity: isDragging ? "0.2" : "1"
              },
              item: true,
              xs: 12 / columnNumber,
              children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                className: styles$n.imageContainer,
                style: {
                  paddingTop: 100 / imageAspectRatio + "%",
                  backgroundColor: theme.palette.background.default,
                  backgroundImage
                },
                ref,
                "data-handler-id": handlerId,
                children: [inDesign(designMode) && /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                  className: styles$n.buttonContainers,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                    sx: {
                      color: theme.textStyles.text.color
                    },
                    className: styles$n.imageIconButton,
                    onClick: () => {
                      onDelete();
                    },
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$d, {})
                  }), /* @__PURE__ */jsxRuntimeExports.jsxs(IconButton, {
                    sx: {
                      color: theme.textStyles.text.color
                    },
                    component: "label",
                    className: styles$n.imageIconButton,
                    children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$f, {}), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                      hidden: true,
                      id: qualifiedCode,
                      accept: "image/*",
                      multiple: true,
                      type: "file",
                      onChange: handleImageChange
                    })]
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                    sx: {
                      color: theme.textStyles.text.color
                    },
                    ref: drag,
                    className: styles$n.imageIconButton,
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$h, {})
                  })]
                }), isUploading && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  className: styles$n.loadingContainer,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingDots, {})
                })]
              }), !hideText && /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
                dir: isRtl ? "rtl" : "ltr",
                variant: "standard",
                value: content || "",
                disabled: !contentEditable(designMode),
                onChange: e => dispatch(changeContent({
                  code: qualifiedCode,
                  key: "label",
                  lang,
                  value: e.target.value
                })),
                placeholder: onMainLang ? t("content_editor_placeholder_option") : mainContent || t("content_editor_placeholder_option"),
                inputProps: {
                  style: {
                    textAlign: "center"
                  }
                },
                InputProps: {
                  sx: {
                    fontFamily: theme.textStyles.text.font,
                    color: theme.textStyles.text.color,
                    fontSize: theme.textStyles.text.size
                  }
                }
              })]
            }, qualifiedCode)
          });
        }
        const imageIconButton = "_imageIconButton_lgrld_1";
        const imageContainer = "_imageContainer_lgrld_8";
        const addAnswerIcon = "_addAnswerIcon_lgrld_12";
        const loadingContainer = "_loadingContainer_lgrld_16";
        const addAnswerButton = "_addAnswerButton_lgrld_23";
        const svgContainer = "_svgContainer_lgrld_31";
        const buttonContainers = "_buttonContainers_lgrld_36";
        const styles$m = {
          imageIconButton: imageIconButton,
          imageContainer: imageContainer,
          addAnswerIcon: addAnswerIcon,
          loadingContainer: loadingContainer,
          addAnswerButton: addAnswerButton,
          svgContainer: svgContainer,
          buttonContainers: buttonContainers
        };
        class IconService {
          search(searchTerm, cancelToken) {
            return new Promise((resolve, reject) => {
              axios.get(`https://api.iconify.design/search?query=${searchTerm}&limit=250`, {
                cancelToken: cancelToken.token
              }).then(data => {
                resolve(data.data.icons);
              }).catch(err => {
                if (axios.isCancel(err)) {
                  console.debug("Request canceled:", err.message);
                } else {
                  reject(err);
                }
              });
            });
          }
        }
        const IconService$1 = new IconService();
        const resultImage = "_resultImage_2y7qe_1";
        const styles$l = {
          resultImage: resultImage
        };
        function IconSelector({
          currentIcon,
          onIconSelected
        }) {
          const _useTranslation2 = useTranslation("design"),
            t = _useTranslation2.t;
          const _reactExports$useStat33 = reactExports.useState(""),
            _reactExports$useStat34 = _slicedToArray2(_reactExports$useStat33, 2),
            searchTerm = _reactExports$useStat34[0],
            setSearchTerm = _reactExports$useStat34[1];
          const _reactExports$useStat35 = reactExports.useState(null),
            _reactExports$useStat36 = _slicedToArray2(_reactExports$useStat35, 2),
            cancelToken = _reactExports$useStat36[0],
            setCancelToken = _reactExports$useStat36[1];
          const _reactExports$useStat37 = reactExports.useState([]),
            _reactExports$useStat38 = _slicedToArray2(_reactExports$useStat37, 2),
            searchResults = _reactExports$useStat38[0],
            setSearchResults = _reactExports$useStat38[1];
          reactExports.useEffect(() => {
            if (cancelToken) {
              cancelToken.cancel("Operation canceled by the user.");
            }
            if (searchTerm) {
              const source = axios.CancelToken.source();
              setCancelToken(source);
              IconService$1.search(searchTerm, source).then(result => {
                setSearchResults(result);
              }).catch(e => {
                console.error(e);
              });
            } else {
              setSearchResults([]);
            }
          }, [searchTerm]);
          const handleInputChange = event => {
            setSearchTerm(event.target.value);
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Dialog, {
            fullScreen: true,
            sx: {
              margin: "200px",
              backgroundColor: "white"
            },
            open: true,
            onClose: () => onIconSelected(false),
            "aria-labelledby": "alert-dialog-title-logic-builder",
            "aria-describedby": "alert-dialog-description",
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(DialogTitle, {
              id: "alert-dialog-title-logic-builder",
              children: t("select Icon")
            }), /* @__PURE__ */jsxRuntimeExports.jsx(DialogContent, {
              children: /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx("input", {
                  type: "text",
                  placeholder: "Search for icons",
                  value: searchTerm,
                  onChange: handleInputChange
                }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  className: "search-results",
                  children: searchResults.map((icon, index) => {
                    const parts = icon.split(":");
                    return /* @__PURE__ */jsxRuntimeExports.jsx(SVGDisplay, {
                      onClick: onIconSelected,
                      source: `https://api.iconify.design/${parts[0]}/${parts[1]}.svg`
                    }, index);
                  })
                })]
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(DialogActions, {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                onClick: () => {},
                autoFocus: true,
                children: "Select"
              })
            })]
          });
        }
        function SVGDisplay({
          source,
          onClick: _onClick
        }) {
          const _reactExports$useStat39 = reactExports.useState(""),
            _reactExports$useStat40 = _slicedToArray2(_reactExports$useStat39, 2),
            svgSource = _reactExports$useStat40[0],
            setSvgSource = _reactExports$useStat40[1];
          reactExports.useEffect(() => {
            axios.get(source).then(response => {
              if (isSVGValid(response.data)) {
                setSvgSource(response.data);
              }
            });
          }, [source]);
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            onClick: () => {
              _onClick(svgSource);
            },
            className: styles$l.resultImage,
            dangerouslySetInnerHTML: {
              __html: svgSource
            }
          });
        }
        function isSVGValid(svgContent) {
          if (typeof svgContent !== "string") {
            return false;
          }
          return /^<svg[\s\S]*<\/svg>$/.test(svgContent);
        }
        function IconChoiceItemDesign({
          parentCode,
          index,
          qualifiedCode,
          type,
          columnNumber,
          designMode,
          imageHeight,
          hideText,
          t,
          addAnswer
        }) {
          var _answer$resources2, _answer$content, _answer$content2;
          const designService = useService("design");
          const dispatch = useDispatch();
          const ref = reactExports.useRef(null);
          const theme = useTheme();
          const _reactExports$useStat41 = reactExports.useState(false),
            _reactExports$useStat42 = _slicedToArray2(_reactExports$useStat41, 2),
            iconSelectoOpen = _reactExports$useStat42[0],
            setIconSelectorOpen = _reactExports$useStat42[1];
          const langInfo = useSelector(state => {
            return state.designState.langInfo;
          });
          const answer = useSelector(state => {
            return type == "add" ? void 0 : state.designState[qualifiedCode];
          });
          const onMainLang = langInfo.lang === langInfo.mainLang;
          const lang = langInfo.lang;
          const svgIconName = answer === null || answer === void 0 || (_answer$resources2 = answer.resources) === null || _answer$resources2 === void 0 ? void 0 : _answer$resources2.icon;
          const content = type == "add" ? void 0 : (_answer$content = answer.content) === null || _answer$content === void 0 || (_answer$content = _answer$content["label"]) === null || _answer$content === void 0 ? void 0 : _answer$content[lang];
          type == "add" ? void 0 : answer.icon;
          const isRtl = rtlLanguage.includes(lang);
          const mainContent = type == "add" ? void 0 : (_answer$content2 = answer.content) === null || _answer$content2 === void 0 || (_answer$content2 = _answer$content2["label"]) === null || _answer$content2 === void 0 ? void 0 : _answer$content2[langInfo.mainLang];
          const onDelete = () => {
            if (window.confirm(`Are you sure?`)) {
              dispatch(removeAnswer(qualifiedCode));
            }
          };
          const dragType = parentCode + "icon-drag";
          const getRowByIndex = index2 => {
            return Math.round(index2 / columnNumber);
          };
          const getColByIndex = index2 => {
            return index2 % columnNumber;
          };
          const uploadAsResource = svgContent => {
            const svgBlob = new Blob([svgContent], {
              type: "image/svg+xml"
            });
            const svgFile = new File([svgBlob], "file.svg", {
              type: "image/svg+xml"
            });
            designService.uploadResource(svgFile).then(response => {
              dispatch(changeResources({
                code: qualifiedCode,
                key: "icon",
                value: response.name
              }));
            }).catch(error => {
              console.error(error.message);
            });
          };
          const colIndex = getColByIndex(index);
          const rowIndex = getRowByIndex(index);
          const _useDrag9 = useDrag({
              type: dragType,
              item: {
                index,
                colIndex,
                rowIndex,
                draggableId: qualifiedCode,
                parentCode,
                type: dragType,
                itemType: dragType
              },
              collect: monitor => monitor.isDragging()
            }, [index]),
            _useDrag10 = _slicedToArray2(_useDrag9, 3),
            isDragging = _useDrag10[0],
            drag = _useDrag10[1],
            preview = _useDrag10[2];
          const _useDrop9 = useDrop({
              accept: dragType,
              collect(monitor) {
                return {
                  handlerId: monitor.getHandlerId()
                };
              },
              hover(item, monitor) {
                var _ref$current5;
                if (!ref.current || !monitor.isOver({
                  shallow: true
                }) || !item) {
                  return;
                }
                const dragIndex = item.index;
                const hoverIndex = index;
                const dragRowIndex = item.rowIndex;
                const hoverRowIndex = rowIndex;
                const dragColIndex = item.colIndex;
                const hoverColIndex = colIndex;
                if (dragIndex === hoverIndex) {
                  return;
                }
                const hoverBoundingRect = (_ref$current5 = ref.current) === null || _ref$current5 === void 0 ? void 0 : _ref$current5.getBoundingClientRect();
                const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
                const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;
                const clientOffset = monitor.getClientOffset();
                const hoverClientY = clientOffset.y - hoverBoundingRect.top;
                const hoverClientX = clientOffset.x - hoverBoundingRect.left;
                if (dragRowIndex < hoverRowIndex && hoverClientY < hoverMiddleY && dragColIndex < hoverColIndex && hoverClientX < hoverMiddleX) {
                  return;
                }
                if (dragRowIndex > hoverRowIndex && hoverClientY > hoverMiddleY && dragColIndex > hoverColIndex && hoverClientX > hoverMiddleX) {
                  return;
                }
                {
                  dispatch(onDrag({
                    type: "reorder_answers",
                    id: item.draggableId,
                    fromIndex: dragIndex,
                    toIndex: hoverIndex
                  }));
                  item.index = hoverIndex;
                  item.rowIndex = hoverRowIndex;
                  item.colIndex = hoverColIndex;
                }
              }
            }),
            _useDrop10 = _slicedToArray2(_useDrop9, 2),
            handlerId = _useDrop10[0].handlerId,
            drop = _useDrop10[1];
          drop(preview(ref));
          return type == "add" ? /* @__PURE__ */jsxRuntimeExports.jsx(Grid$1, {
            item: true,
            xs: 12 / columnNumber,
            height: "100%",
            children: /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
              className: styles$m.addAnswerButton,
              style: {
                minHeight: "100px",
                borderRadius: "4px",
                backgroundColor: theme.palette.background.default,
                height: "100%",
                width: "100%"
              },
              children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                sx: {
                  color: theme.textStyles.text.color
                },
                className: styles$m.addAnswerIcon,
                onClick: () => {
                  addAnswer();
                },
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$c, {})
              })
            })
          }, "add") : /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Grid$1, {
              style: {
                opacity: isDragging ? "0.2" : "1"
              },
              item: true,
              xs: 12 / columnNumber,
              children: /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                ref,
                "data-handler-id": handlerId,
                children: [inDesign(designMode) && /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                  className: styles$m.buttonContainers,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                    sx: {
                      color: theme.textStyles.text.color
                    },
                    className: styles$m.imageIconButton,
                    onClick: () => {
                      onDelete();
                    },
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$d, {})
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                    sx: {
                      color: theme.textStyles.text.color
                    },
                    component: "label",
                    className: styles$m.imageIconButton,
                    onClick: () => setIconSelectorOpen(true),
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$f, {})
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                    sx: {
                      color: theme.textStyles.text.color
                    },
                    ref: drag,
                    className: styles$m.imageIconButton,
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$h, {})
                  })]
                }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  style: {
                    width: "100%",
                    display: "flex",
                    justifyContent: "center"
                  },
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(DynamicSvg, {
                    imageHeight: imageHeight + "px",
                    svgUrl: svgIconName ? buildResourceUrl(svgIconName) : void 0
                  })
                }), !hideText && /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
                  dir: isRtl ? "rtl" : "ltr",
                  variant: "standard",
                  disabled: !contentEditable(designMode),
                  value: content || "",
                  onChange: e => dispatch(changeContent({
                    code: qualifiedCode,
                    key: "label",
                    lang,
                    value: e.target.value
                  })),
                  placeholder: onMainLang ? t("content_editor_placeholder_option") : mainContent || t("content_editor_placeholder_option"),
                  inputProps: {
                    style: {
                      textAlign: "center"
                    }
                  },
                  InputProps: {
                    sx: {
                      fontFamily: theme.textStyles.text.font,
                      color: theme.textStyles.text.color,
                      fontSize: theme.textStyles.text.size
                    }
                  }
                })]
              })
            }, qualifiedCode), iconSelectoOpen && /* @__PURE__ */jsxRuntimeExports.jsx(IconSelector, {
              currentIcon: "",
              onIconSelected: icon2 => {
                uploadAsResource(icon2);
                setIconSelectorOpen(false);
              }
            })]
          });
        }
        function ImageChoiceQuestion(props) {
          const state = useSelector(state2 => {
            return state2.designState[props.code];
          });
          const children = state.children || [];
          const imageAspectRatio = useSelector(state2 => {
            return state2.designState[props.code].imageAspectRatio || 1;
          });
          const questionType = state.type;
          const childrenWithAdd = inDesign(props.designMode) ? [...children, {
            type: "add",
            code: "add"
          }] : children;
          const columnNumber = state.columns || 2;
          const hideText = state.hideText || false;
          const spacing = state.spacing || 8;
          const imageHeight = state.iconSize ? +state.iconSize : 64;
          const itemWidth = `calc(${100 / columnNumber}% - ${spacing}px)`;
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles$o.questionItem,
            children: imageHeight && /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
              id: "items-" + props.code,
              sx: {
                display: "flex",
                flexWrap: "wrap",
                gap: `${spacing}px`
              },
              children: childrenWithAdd.map((item, index) => props.icon ? /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                sx: {
                  flex: `0 1 ${itemWidth}`,
                  maxWidth: itemWidth
                },
                children: /* @__PURE__ */jsxRuntimeExports.jsx(IconChoiceItemDesign, {
                  parentCode: props.code,
                  index,
                  columnNumber,
                  designMode: props.designMode,
                  hideText,
                  imageHeight,
                  t: props.t,
                  addAnswer: () => props.addNewAnswer(props.code, questionType),
                  type: item.type,
                  qualifiedCode: item.qualifiedCode
                }, item.code)
              }, item.code) : /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                sx: {
                  flex: `0 1 ${itemWidth}`,
                  maxWidth: itemWidth
                },
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ImageChoiceItemDesign, {
                  parentCode: props.code,
                  index,
                  imageAspectRatio,
                  columnNumber,
                  hideText,
                  designMode: props.designMode,
                  imageHeight,
                  t: props.t,
                  addAnswer: () => props.addNewAnswer(props.code, questionType),
                  type: item.type,
                  qualifiedCode: item.qualifiedCode
                }, item.code)
              }, item.code))
            })
          });
        }
        const ImageChoiceQuestion$1 = React.memo(ImageChoiceQuestion);
        var AddBox = {};
        var _interopRequireDefault$j = interopRequireDefaultExports;
        Object.defineProperty(AddBox, "__esModule", {
          value: true
        });
        var default_1$b = AddBox.default = void 0;
        var _createSvgIcon$b = _interopRequireDefault$j(requireCreateSvgIcon());
        var _jsxRuntime$b = jsxRuntimeExports;
        default_1$b = AddBox.default = (0, _createSvgIcon$b.default)(/*#__PURE__*/(0, _jsxRuntime$b.jsx)("path", {
          d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4z"
        }), 'AddBox');
        function SCQIconArrayDesign(props) {
          const theme = useTheme();
          const t = props.t;
          const langInfo = useSelector(state => {
            return state.designState.langInfo;
          });
          const inDesgin = props.designMode == DESIGN_SURVEY_MODE.DESIGN;
          const children = useSelector(state => {
            return state.designState[props.code].children;
          });
          const rows = (children === null || children === void 0 ? void 0 : children.filter(el => el.type == "row")) || [];
          const columns = (children === null || children === void 0 ? void 0 : children.filter(el => el.type == "column")) || [];
          const icons = useSelector(state => columns.map(col => {
            var _state$designState$co9;
            return (_state$designState$co9 = state.designState[col.qualifiedCode].resources) === null || _state$designState$co9 === void 0 ? void 0 : _state$designState$co9.icon;
          }));
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [inDesgin && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$L.addColumn,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  fontSize: theme.textStyles.text.size,
                  color: theme.textStyles.question.color
                },
                size: "small",
                onClick: e => props.addNewAnswer(props.code, props.type, "column"),
                children: t("add_column")
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(TableContainer, {
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(Table, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(TableHead, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsxs(TableRow, {
                    children: [inDesgin && /* @__PURE__ */jsxRuntimeExports.jsx(TableCell, {
                      sx: {
                        padding: "0"
                      }
                    }, "move"), /* @__PURE__ */jsxRuntimeExports.jsx(TableCell, {}, "content"), columns.map((item, index) => {
                      return /* @__PURE__ */jsxRuntimeExports.jsx(SCQArrayHeaderDesign, {
                        parentQualifiedCode: props.qualifiedCode,
                        langInfo,
                        t: props.t,
                        item,
                        inDesgin,
                        icons,
                        styles: styles$L,
                        index
                      }, item.qualifiedCode);
                    }), inDesgin && /* @__PURE__ */jsxRuntimeExports.jsx(TableCell, {
                      sx: {
                        padding: "0"
                      }
                    }, "remove")]
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx(TableBody, {
                  children: rows.map((item, index) => {
                    return /* @__PURE__ */jsxRuntimeExports.jsx(SCQArrayRowDesign, {
                      parentQualifiedCode: props.qualifiedCode,
                      langInfo,
                      t: props.t,
                      item,
                      inDesgin,
                      columns,
                      icons,
                      index
                    }, item.qualifiedCode);
                  })
                })]
              })
            }), props.inDesgin && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$L.addRow,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  fontSize: theme.textStyles.text.size,
                  color: theme.textStyles.question.color
                },
                size: "small",
                onClick: e => props.addNewAnswer(props.code, props.type, "row"),
                children: t("add_row")
              })
            })]
          });
        }
        const SCQIconArrayDesign$1 = React.memo(SCQIconArrayDesign);
        function SCQArrayRowDesign({
          item,
          index,
          columns,
          icons,
          inDesgin,
          t,
          langInfo,
          parentQualifiedCode
        }) {
          const dispatch = useDispatch();
          const theme = useTheme();
          const ref = reactExports.useRef();
          const onMainLang = langInfo.lang === langInfo.mainLang;
          const content = useSelector(state => {
            var _state$designState$it5;
            return (_state$designState$it5 = state.designState[item.qualifiedCode].content) === null || _state$designState$it5 === void 0 || (_state$designState$it5 = _state$designState$it5["label"]) === null || _state$designState$it5 === void 0 ? void 0 : _state$designState$it5[langInfo.lang];
          });
          const mainContent = useSelector(state => {
            var _state$designState$it6;
            return (_state$designState$it6 = state.designState[item.qualifiedCode].content) === null || _state$designState$it6 === void 0 || (_state$designState$it6 = _state$designState$it6["label"]) === null || _state$designState$it6 === void 0 ? void 0 : _state$designState$it6[langInfo.mainLang];
          });
          const itemType = `col-${parentQualifiedCode}`;
          const _useDrag11 = useDrag({
              type: itemType,
              item: {
                qualifiedCode: item.qualifiedCode,
                index
              },
              collect: monitor => monitor.isDragging()
            }, [index]),
            _useDrag12 = _slicedToArray2(_useDrag11, 3),
            isDragging = _useDrag12[0],
            drag = _useDrag12[1],
            preview = _useDrag12[2];
          const _useDrop11 = useDrop({
              accept: itemType,
              collect(monitor) {
                return {
                  handlerId: monitor.getHandlerId()
                };
              },
              hover(item2, monitor) {
                var _ref$current6;
                if (!ref.current || !monitor.isOver({
                  shallow: true
                }) || !item2) {
                  return;
                }
                const dragIndex = item2.index;
                const hoverIndex = index;
                if (dragIndex === hoverIndex) {
                  return;
                }
                const hoverBoundingRect = (_ref$current6 = ref.current) === null || _ref$current6 === void 0 ? void 0 : _ref$current6.getBoundingClientRect();
                const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
                const clientOffset = monitor.getClientOffset();
                const hoverClientY = clientOffset.y - hoverBoundingRect.top;
                if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {
                  return;
                }
                if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {
                  return;
                }
                dispatch(onDrag({
                  type: "reorder_answers_by_type",
                  id: item2.qualifiedCode,
                  fromIndex: item2.index,
                  toIndex: hoverIndex
                }));
                item2.index = hoverIndex;
              }
            }),
            _useDrop12 = _slicedToArray2(_useDrop11, 2),
            handlerId = _useDrop12[0].handlerId,
            drop = _useDrop12[1];
          drop(preview(ref));
          return /* @__PURE__ */jsxRuntimeExports.jsxs(TableRow, {
            style: {
              opacity: isDragging ? "0.2" : "1"
            },
            ref,
            "data-handler-id": handlerId,
            children: [inDesgin && /* @__PURE__ */jsxRuntimeExports.jsx(TableCell, {
              ref: drag,
              sx: {
                padding: "0",
                color: theme.textStyles.text.color
              },
              children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$h, {})
            }, "move"), /* @__PURE__ */jsxRuntimeExports.jsx(TableCell, {
              sx: {
                fontFamily: theme.textStyles.text.font,
                color: theme.textStyles.text.color,
                fontSize: theme.textStyles.text.size,
                padding: "4px"
              },
              children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
                variant: "standard",
                value: content || "",
                onChange: e => {
                  dispatch(changeContent({
                    code: item.qualifiedCode,
                    key: "label",
                    lang: langInfo.lang,
                    value: e.target.value
                  }));
                },
                placeholder: onMainLang ? t("content_editor_placeholder_option") : mainContent || t("content_editor_placeholder_option"),
                InputProps: {
                  disableUnderline: true,
                  sx: {
                    fontFamily: theme.textStyles.text.font,
                    color: theme.textStyles.text.color,
                    fontSize: theme.textStyles.text.size
                  }
                }
              })
            }), columns.map((option, index2) => {
              return /* @__PURE__ */jsxRuntimeExports.jsx(TableCell, {
                scope: "row",
                align: "center",
                sx: {
                  padding: "4px"
                },
                children: icons[index2] && /* @__PURE__ */jsxRuntimeExports.jsx(DynamicSvg, {
                  opacity: 0.2,
                  iconColor: theme.textStyles.text.color,
                  onIconClick: () => {},
                  imageHeight: "64px",
                  svgUrl: icons[index2] ? buildResourceUrl(icons[index2]) : void 0
                })
              }, index2);
            }), inDesgin && /* @__PURE__ */jsxRuntimeExports.jsx(TableCell, {
              onClick: e => dispatch(removeAnswer(item.qualifiedCode)),
              sx: {
                padding: "0",
                color: theme.textStyles.text.color
              },
              children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$o, {})
            }, "remove")]
          }, item.code);
        }
        function SCQArrayHeaderDesign({
          item,
          index,
          icons,
          inDesgin,
          t,
          langInfo,
          parentQualifiedCode,
          styles: styles2
        }) {
          const designService = useService("design");
          const icon = icons[index];
          const _reactExports$useStat43 = reactExports.useState(false),
            _reactExports$useStat44 = _slicedToArray2(_reactExports$useStat43, 2),
            iconSelectoOpen = _reactExports$useStat44[0],
            setIconSelectorOpen = _reactExports$useStat44[1];
          const dispatch = useDispatch();
          const theme = useTheme();
          const ref = reactExports.useRef();
          const isRtl = rtlLanguage.includes(langInfo.lang);
          const isLtr = !isRtl;
          const itemType = `row-${parentQualifiedCode}`;
          const _useDrag13 = useDrag({
              type: itemType,
              item: {
                qualifiedCode: item.qualifiedCode,
                index
              },
              collect: monitor => monitor.isDragging()
            }, [index]),
            _useDrag14 = _slicedToArray2(_useDrag13, 3),
            isDragging = _useDrag14[0],
            drag = _useDrag14[1],
            preview = _useDrag14[2];
          const _useDrop13 = useDrop({
              accept: itemType,
              collect(monitor) {
                return {
                  handlerId: monitor.getHandlerId()
                };
              },
              hover(item2, monitor) {
                var _ref$current7;
                if (!ref.current || !monitor.isOver({
                  shallow: true
                }) || !item2) {
                  return;
                }
                const dragIndex = item2.index;
                const hoverIndex = index;
                if (dragIndex === hoverIndex) {
                  return;
                }
                const hoverBoundingRect = (_ref$current7 = ref.current) === null || _ref$current7 === void 0 ? void 0 : _ref$current7.getBoundingClientRect();
                const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;
                const clientOffset = monitor.getClientOffset();
                const hoverClientX = clientOffset.x - hoverBoundingRect.left;
                if (isLtr && dragIndex < hoverIndex && hoverClientX < hoverMiddleX) {
                  return;
                }
                if (isLtr && dragIndex > hoverIndex && hoverClientX > hoverMiddleX) {
                  return;
                }
                if (isRtl && dragIndex < hoverIndex && hoverClientX > hoverMiddleX) {
                  return;
                }
                if (isRtl && dragIndex > hoverIndex && hoverClientX < hoverMiddleX) {
                  return;
                }
                dispatch(onDrag({
                  type: "reorder_answers_by_type",
                  id: item2.qualifiedCode,
                  fromIndex: item2.index,
                  toIndex: hoverIndex
                }));
                item2.index = hoverIndex;
              }
            }),
            _useDrop14 = _slicedToArray2(_useDrop13, 2),
            handlerId = _useDrop14[0].handlerId,
            drop = _useDrop14[1];
          const uploadAsResource = svgContent => {
            const svgBlob = new Blob([svgContent], {
              type: "image/svg+xml"
            });
            const svgFile = new File([svgBlob], "file.svg", {
              type: "image/svg+xml"
            });
            designService.uploadResource(svgFile).then(response => {
              dispatch(changeResources({
                code: item.qualifiedCode,
                key: "icon",
                value: response.name
              }));
            }).catch(error => {
              console.error(error.message);
            });
          };
          drop(preview(ref));
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs(TableCell, {
              ref,
              "data-handler-id": handlerId,
              align: "center",
              sx: {
                opacity: isDragging ? "0.2" : "1",
                fontFamily: theme.textStyles.text.font,
                color: theme.textStyles.text.color,
                fontSize: theme.textStyles.text.size,
                padding: "4px"
              },
              children: [inDesgin && /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                style: {
                  display: "inline-flex"
                },
                children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  ref: drag,
                  sx: {
                    padding: "0"
                  },
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$h, {})
                }, "move"), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  sx: {
                    padding: "0",
                    color: theme.textStyles.text.color
                  },
                  onClick: e => dispatch(removeAnswer(item.qualifiedCode)),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$o, {})
                })]
              }), icon ? /* @__PURE__ */jsxRuntimeExports.jsx(DynamicSvg, {
                onIconClick: () => setIconSelectorOpen(true),
                imageHeight: "64px",
                svgUrl: icon ? buildResourceUrl(icon) : void 0
              }) : /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx("br", {}), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                  onClick: () => setIconSelectorOpen(true),
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$b, {
                    sx: {
                      width: "64px",
                      height: "64px"
                    }
                  }), /* @__PURE__ */jsxRuntimeExports.jsx("br", {}), /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                    children: "Click to add icon"
                  })]
                })]
              })]
            }, item.qualifiedCode), iconSelectoOpen && /* @__PURE__ */jsxRuntimeExports.jsx(IconSelector, {
              currentIcon: "",
              onIconSelected: icon2 => {
                uploadAsResource(icon2);
                setIconSelectorOpen(false);
              }
            })]
          });
        }
        function QuestionDesignBody({
          code,
          type,
          t,
          onMainLang,
          addAnswer,
          designMode
        }) {
          switch (type) {
            case "video_display":
              return /* @__PURE__ */jsxRuntimeExports.jsx(VideoDisplayDesign, {
                code,
                t,
                onMainLang
              }, code);
            case "image_display":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ImageDisplayDesign$1, {
                code,
                t,
                onMainLang
              }, code);
            case "signature":
              return /* @__PURE__ */jsxRuntimeExports.jsx(SignatureDesign$1, {});
            case "photo_capture":
              return /* @__PURE__ */jsxRuntimeExports.jsx(PhotoCaptureDesign$1, {
                code
              });
            case "video_capture":
              return /* @__PURE__ */jsxRuntimeExports.jsx(VideoCaptureDesign$1, {
                code
              });
            case "date_time":
              return /* @__PURE__ */jsxRuntimeExports.jsx(DateTimeQuestionDesign$1, {
                code
              }, code);
            case "date":
              return /* @__PURE__ */jsxRuntimeExports.jsx(DateTimeQuestionDesign$1, {
                code
              }, code);
            case "time":
              return /* @__PURE__ */jsxRuntimeExports.jsx(TimeQuestionDesign$1, {
                code
              }, code);
            case "scq":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ChoiceQuestion$1, {
                t,
                designMode,
                onMainLang,
                addNewAnswer: addAnswer,
                code,
                type: "radio"
              }, code);
            case "image_mcq":
            case "image_scq":
            case "image_ranking":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ImageChoiceQuestion$1, {
                t,
                onMainLang,
                designMode,
                addNewAnswer: addAnswer,
                code
              }, code);
            case "icon_scq":
            case "icon_mcq":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ImageChoiceQuestion$1, {
                icon: true,
                t,
                onMainLang,
                designMode,
                addNewAnswer: addAnswer,
                code
              }, code);
            case "scq_icon_array":
              return /* @__PURE__ */jsxRuntimeExports.jsx(SCQIconArrayDesign$1, {
                onMainLang,
                type,
                designMode,
                addNewAnswer: addAnswer,
                code,
                t
              }, code);
            case "scq_array":
              return /* @__PURE__ */jsxRuntimeExports.jsx(SCQArray$1, {
                onMainLang,
                type,
                designMode,
                addNewAnswer: addAnswer,
                code,
                t
              }, code);
            case "file_upload":
              return /* @__PURE__ */jsxRuntimeExports.jsx(FileUploadQuestionDesign$1, {
                code
              }, code);
            case "mcq":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ChoiceQuestion$1, {
                designMode,
                addNewAnswer: addAnswer,
                code,
                onMainLang,
                t,
                type: "checkbox"
              }, code);
            case "ranking":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ChoiceQuestion$1, {
                designMode,
                onMainLang,
                addNewAnswer: addAnswer,
                code,
                t,
                type: "ranking"
              }, code);
            case "nps":
              return /* @__PURE__ */jsxRuntimeExports.jsx(NPSDesign$1, {
                code
              }, code);
            case "number":
              return /* @__PURE__ */jsxRuntimeExports.jsx(NumberQuestionDesign$1, {
                code
              }, code);
            case "text":
              return /* @__PURE__ */jsxRuntimeExports.jsx(TextQuestionDesign$1, {
                code
              }, code);
            case "paragraph":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ParagraphQuestionDesign$1, {
                t,
                code
              }, code);
            case "barcode":
              return /* @__PURE__ */jsxRuntimeExports.jsx(BarcodeDesign$1, {
                t,
                code
              }, code);
            case "email":
              return /* @__PURE__ */jsxRuntimeExports.jsx(EmailQuestionDesign$1, {
                code
              }, code);
            default:
              return "";
          }
        }
        const QuestionDesignBody$1 = React.memo(QuestionDesignBody);
        function QuestionDesign({
          code,
          type,
          isLast,
          parentCode,
          index,
          t,
          designMode,
          onMainLang,
          parentIndex
        }) {
          console.debug(code + ": " + index);
          const _reactExports$useStat45 = reactExports.useState(false),
            _reactExports$useStat46 = _slicedToArray2(_reactExports$useStat45, 2),
            hovered = _reactExports$useStat46[0],
            setHovered = _reactExports$useStat46[1];
          const containerRef = reactExports.useRef();
          const dispatch = useDispatch();
          const theme = useTheme();
          const isInSetup = useSelector(state => {
            var _state$designState$se3;
            return ((_state$designState$se3 = state.designState.setup) === null || _state$designState$se3 === void 0 ? void 0 : _state$designState$se3.code) == code;
          });
          const question = useSelector(state => {
            return state.designState[code];
          });
          const children = question.children;
          const collapsed = useSelector(state => {
            var _state$designState$gl;
            return ((_state$designState$gl = state.designState["globalSetup"]) === null || _state$designState$gl === void 0 ? void 0 : _state$designState$gl.reorder_setup) === "collapse_questions";
          });
          useSelector(state => !hasMajorSetup(state.designState.setup));
          const onDelete = reactExports.useCallback(() => dispatch(deleteQuestion(code)), []);
          const onClone = reactExports.useCallback(() => dispatch(cloneQuestion(code)), []);
          const _useDrag15 = useDrag({
              type: "questions",
              item: {
                index,
                draggableId: code,
                droppableId: parentCode,
                parentIndex,
                isLast,
                type: "questions",
                itemType: type
              },
              collect: monitor => {
                var _monitor$getItem;
                return ((_monitor$getItem = monitor.getItem()) === null || _monitor$getItem === void 0 ? void 0 : _monitor$getItem.draggableId) === code;
              }
            }),
            _useDrag16 = _slicedToArray2(_useDrag15, 3),
            isDragging = _useDrag16[0],
            drag = _useDrag16[1],
            preview = _useDrag16[2];
          const _useDrop15 = useDrop({
              accept: "questions",
              hover(item, monitor) {
                var _containerRef$current;
                if (!containerRef.current || !monitor.isOver({
                  shallow: true
                }) || !item || !item.droppableId.startsWith("G")) {
                  return;
                }
                const dragIndex = item.index;
                const hoverIndex = index;
                if (dragIndex === hoverIndex || (item === null || item === void 0 ? void 0 : item.droppableId) !== parentCode) {
                  return;
                }
                const hoverBoundingRect = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.getBoundingClientRect();
                const clientOffset = monitor.getClientOffset();
                if (dragIndex < hoverIndex && clientOffset.y < hoverBoundingRect.top + 20) {
                  return;
                }
                if (dragIndex > hoverIndex && clientOffset.y > hoverBoundingRect.bottom - 20) {
                  return;
                }
                dispatch(onDrag({
                  type: "reorder_questions",
                  source: item.droppableId,
                  destination: parentCode,
                  id: item.draggableId,
                  fromIndex: dragIndex,
                  toIndex: hoverIndex + 1
                }));
                item.index = hoverIndex;
                item.isLast = isLast;
              }
            }),
            _useDrop16 = _slicedToArray2(_useDrop15, 2),
            collectedProps = _useDrop16[0],
            drop = _useDrop16[1];
          drop(preview(containerRef));
          const addAnswer = React.useCallback((questionCode, questionType, type2) => {
            const answers = children || [];
            let nextAnswerIndex = 1;
            let code2 = "";
            let qualifiedCode = "";
            let label = "";
            const valueInstruction = {
              code: "value",
              isActive: false,
              returnType: {
                name: questionType == "ranking" || questionType == "nps" || questionType == "image_ranking" ? "Int" : questionType == "scq_array" || questionType == "scq_icon_array" ? "String" : "Boolean"
              },
              text: ""
            };
            switch (type2) {
              case "column":
                nextAnswerIndex = nextId(answers.filter(el => el.type === "column"));
                label = "Col" + nextAnswerIndex;
                code2 = "Ac" + nextAnswerIndex;
                qualifiedCode = questionCode + code2;
                dispatch(addNewAnswer({
                  label,
                  answer: {
                    code: code2,
                    qualifiedCode,
                    type: type2
                  }
                }));
                break;
              case "row":
                nextAnswerIndex = nextId(answers.filter(el => el.type === "row"));
                code2 = "A" + nextAnswerIndex;
                label = "Row" + nextAnswerIndex;
                qualifiedCode = questionCode + code2;
                dispatch(addNewAnswer({
                  label,
                  instructionList: [valueInstruction],
                  answer: {
                    code: code2,
                    qualifiedCode,
                    type: type2
                  }
                }));
                break;
              case "other":
                code2 = "Aother";
                label = "Other";
                qualifiedCode = questionCode + code2;
                const instructionListForText = [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "String"
                  },
                  text: ""
                }, {
                  code: "conditional_relevance",
                  isActive: true,
                  returnType: {
                    name: "Boolean"
                  },
                  text: questionType === "scq" ? `${questionCode}.value === 'Aother'` : `${questionCode}Aother.value === true`
                }];
                dispatch(addNewAnswer({
                  label,
                  answer: {
                    code: code2,
                    qualifiedCode,
                    type: type2
                  },
                  instructionList: questionType == "mcq" ? [valueInstruction] : []
                }));
                dispatch(addNewAnswer({
                  instructionList: instructionListForText,
                  answer: {
                    code: "Atext",
                    qualifiedCode: qualifiedCode + "Atext",
                    type: "other_text"
                  }
                }));
                break;
              default:
                nextAnswerIndex = nextId(answers);
                code2 = "A" + nextAnswerIndex;
                label = "Option" + nextAnswerIndex;
                qualifiedCode = questionCode + code2;
                dispatch(addNewAnswer({
                  label,
                  answer: {
                    code: code2,
                    qualifiedCode
                  },
                  instructionList: questionType == "mcq" || questionType == "image_mcq" || questionType == "icon_mcq" || questionType == "ranking" || questionType == "image_ranking" ? [valueInstruction] : []
                }));
                break;
            }
          }, [children]);
          const contrastColor = getContrastColor(theme.palette.background.paper);
          const textColor = theme.textStyles.question.color;
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            ref: containerRef,
            onMouseEnter: () => {
              setHovered(true);
            },
            onMouseLeave: () => {
              setHovered(false);
            },
            style: isInSetup ? {
              border: `0.5px solid ${textColor}`,
              backgroundColor: contrastColor,
              color: textColor
            } : {
              opacity: isDragging ? "0.2" : "1",
              border: isDragging ? "dotted 1px " + contrastColor : "0"
            },
            className: `question ${styles$H.groupQuestion}`,
            "data-code": code,
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              className: styles$H.contentContainer,
              children: [collapsed && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: styles$H.moveBox,
                ref: drag,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$m, {
                  style: {
                    color: textColor
                  }
                })
              }), designMode == DESIGN_SURVEY_MODE.DESIGN && (isInSetup || hovered) && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: styles$H.actionToolbarVisible,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ActionToolbar$1, {
                  t,
                  isGroup: false,
                  isInSetup,
                  code,
                  parentCode,
                  onClone,
                  onDelete,
                  disableDelete: false
                })
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              className: styles$H.titleContainer,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                className: styles$H.iconBox,
                children: questionIconByType(`${type}`, void 0, textColor)
              }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: styles$H.titleQuestion,
                style: {
                  fontFamily: theme.textStyles.question.font,
                  color: theme.textStyles.question.color,
                  fontSize: theme.textStyles.question.size
                },
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ContentEditor$2, {
                  code,
                  editable: designMode == DESIGN_SURVEY_MODE.DESIGN || designMode == DESIGN_SURVEY_MODE.LANGUAGES,
                  extended: false,
                  placeholder: t("content_editor_placeholder_title"),
                  contentKey: "label"
                })
              })]
            }), question.showDescription && /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
              className: styles$H.textDescriptionContent,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(ContentEditor$2, {
                code,
                editable: designMode == DESIGN_SURVEY_MODE.DESIGN || designMode == DESIGN_SURVEY_MODE.LANGUAGES,
                extended: true,
                placeholder: t("content_editor_placeholder_description"),
                contentKey: "description"
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Collapse, {
              in: collapsed !== true,
              timeout: "auto",
              unmountOnExit: true,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(QuestionDesignBody$1, {
                code,
                type,
                t,
                addAnswer,
                designMode,
                onMainLang,
                addNewAnswer: addAnswer
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(ErrorDisplay$1, {
              code
            })]
          });
        }
        const QuestionDesign$1 = React.memo(QuestionDesign);
        const textHeader = "_textHeader_17ofz_1";
        const textDescription = "_textDescription_17ofz_5";
        const groupCard = "_groupCard_17ofz_11";
        const type = "_type_17ofz_18";
        const groupType = "_groupType_17ofz_25";
        const questionsOuterContainer = "_questionsOuterContainer_17ofz_33";
        const questionsInnerContainer = "_questionsInnerContainer_17ofz_37";
        const groupDesignError = "_groupDesignError_17ofz_43";
        const groupHeader = "_groupHeader_17ofz_48";
        const inputGroupTitle = "_inputGroupTitle_17ofz_52";
        const inputGroupDescription = "_inputGroupDescription_17ofz_57";
        const moveBox = "_moveBox_17ofz_62";
        const topLevel = "_topLevel_17ofz_71";
        const groupText = "_groupText_17ofz_83";
        const actionToolbarVisible = "_actionToolbarVisible_17ofz_101";
        const fadeInMoveRight = "_fadeInMoveRight_17ofz_1";
        const contentContainer = "_contentContainer_17ofz_105";
        const headerContent = "_headerContent_17ofz_116";
        const styles$k = {
          textHeader: textHeader,
          textDescription: textDescription,
          groupCard: groupCard,
          type: type,
          groupType: groupType,
          questionsOuterContainer: questionsOuterContainer,
          questionsInnerContainer: questionsInnerContainer,
          groupDesignError: groupDesignError,
          groupHeader: groupHeader,
          inputGroupTitle: inputGroupTitle,
          inputGroupDescription: inputGroupDescription,
          moveBox: moveBox,
          topLevel: topLevel,
          groupText: groupText,
          actionToolbarVisible: actionToolbarVisible,
          fadeInMoveRight: fadeInMoveRight,
          contentContainer: contentContainer,
          headerContent: headerContent
        };
        const groupDropArea = "_groupDropArea_1m6hh_1";
        const groupDragging = "_groupDragging_1m6hh_24";
        const questionDropArea = "_questionDropArea_1m6hh_45";
        const groupDropAreaWrapper = "_groupDropAreaWrapper_1m6hh_72";
        const hide = "_hide_1m6hh_79";
        const hidden = "_hidden_1m6hh_83";
        const isDragging = "_isDragging_1m6hh_92";
        const groupHidden = "_groupHidden_1m6hh_104";
        const groupEmptyHint = "_groupEmptyHint_1m6hh_111";
        const groupEmptyHintHover = "_groupEmptyHintHover_1m6hh_130";
        const dropText = "_dropText_1m6hh_134";
        const styles$j = {
          groupDropArea: groupDropArea,
          groupDragging: groupDragging,
          questionDropArea: questionDropArea,
          groupDropAreaWrapper: groupDropAreaWrapper,
          hide: hide,
          hidden: hidden,
          isDragging: isDragging,
          groupHidden: groupHidden,
          groupEmptyHint: groupEmptyHint,
          groupEmptyHintHover: groupEmptyHintHover,
          dropText: dropText
        };

        // src/observe.ts
        var observerMap = /* @__PURE__ */new Map();
        var RootIds = /* @__PURE__ */new WeakMap();
        var rootId = 0;
        var unsupportedValue = void 0;
        function getRootId(root) {
          if (!root) return "0";
          if (RootIds.has(root)) return RootIds.get(root);
          rootId += 1;
          RootIds.set(root, rootId.toString());
          return RootIds.get(root);
        }
        function optionsToId(options) {
          return Object.keys(options).sort().filter(key => options[key] !== void 0).map(key => {
            return `${key}_${key === "root" ? getRootId(options.root) : options[key]}`;
          }).toString();
        }
        function createObserver(options) {
          const id = optionsToId(options);
          let instance = observerMap.get(id);
          if (!instance) {
            const elements = /* @__PURE__ */new Map();
            let thresholds;
            const observer = new IntersectionObserver(entries => {
              entries.forEach(entry => {
                var _a;
                const inView = entry.isIntersecting && thresholds.some(threshold => entry.intersectionRatio >= threshold);
                if (options.trackVisibility && typeof entry.isVisible === "undefined") {
                  entry.isVisible = inView;
                }
                (_a = elements.get(entry.target)) == null ? void 0 : _a.forEach(callback => {
                  callback(inView, entry);
                });
              });
            }, options);
            thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
            instance = {
              id,
              observer,
              elements
            };
            observerMap.set(id, instance);
          }
          return instance;
        }
        function observe(element, callback, options = {}, fallbackInView = unsupportedValue) {
          if (typeof window.IntersectionObserver === "undefined" && fallbackInView !== void 0) {
            const bounds = element.getBoundingClientRect();
            callback(fallbackInView, {
              isIntersecting: fallbackInView,
              target: element,
              intersectionRatio: typeof options.threshold === "number" ? options.threshold : 0,
              time: 0,
              boundingClientRect: bounds,
              intersectionRect: bounds,
              rootBounds: bounds
            });
            return () => {};
          }
          const _createObserver = createObserver(options),
            id = _createObserver.id,
            observer = _createObserver.observer,
            elements = _createObserver.elements;
          const callbacks = elements.get(element) || [];
          if (!elements.has(element)) {
            elements.set(element, callbacks);
          }
          callbacks.push(callback);
          observer.observe(element);
          return function unobserve() {
            callbacks.splice(callbacks.indexOf(callback), 1);
            if (callbacks.length === 0) {
              elements.delete(element);
              observer.unobserve(element);
            }
            if (elements.size === 0) {
              observer.disconnect();
              observerMap.delete(id);
            }
          };
        }
        function useInView({
          threshold,
          delay,
          trackVisibility,
          rootMargin,
          root,
          triggerOnce,
          skip,
          initialInView,
          fallbackInView,
          onChange
        } = {}) {
          var _a;
          const _reactExports$useStat47 = reactExports.useState(null),
            _reactExports$useStat48 = _slicedToArray2(_reactExports$useStat47, 2),
            ref = _reactExports$useStat48[0],
            setRef = _reactExports$useStat48[1];
          const callback = reactExports.useRef();
          const _reactExports$useStat49 = reactExports.useState({
              inView: !!initialInView,
              entry: void 0
            }),
            _reactExports$useStat50 = _slicedToArray2(_reactExports$useStat49, 2),
            state = _reactExports$useStat50[0],
            setState = _reactExports$useStat50[1];
          callback.current = onChange;
          reactExports.useEffect(() => {
            if (skip || !ref) return;
            let unobserve;
            unobserve = observe(ref, (inView, entry) => {
              setState({
                inView,
                entry
              });
              if (callback.current) callback.current(inView, entry);
              if (entry.isIntersecting && triggerOnce && unobserve) {
                unobserve();
                unobserve = void 0;
              }
            }, {
              root,
              rootMargin,
              threshold,
              // @ts-ignore
              trackVisibility,
              // @ts-ignore
              delay
            }, fallbackInView);
            return () => {
              if (unobserve) {
                unobserve();
              }
            };
          },
          // We break the rule here, because we aren't including the actual `threshold` variable
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [
          // If the threshold is an array, convert it to a string, so it won't change between renders.
          Array.isArray(threshold) ? threshold.toString() : threshold, ref, root, rootMargin, triggerOnce, skip, trackVisibility, fallbackInView, delay]);
          const entryTarget = (_a = state.entry) == null ? void 0 : _a.target;
          const previousEntryTarget = reactExports.useRef();
          if (!ref && entryTarget && !triggerOnce && !skip && previousEntryTarget.current !== entryTarget) {
            previousEntryTarget.current = entryTarget;
            setState({
              inView: !!initialInView,
              entry: void 0
            });
          }
          const result = [setRef, state.inView, state.entry];
          result.ref = result[0];
          result.inView = result[1];
          result.entry = result[2];
          return result;
        }
        function GroupDropArea({
          index,
          groupsCount,
          t,
          emptySurvey
        }) {
          const dispatch = useDispatch();
          const _useDrop17 = useDrop(() => ({
              accept: "groups",
              drop: item2 => {
                dispatch(onDrag({
                  type: "new_group",
                  groupType: item2.draggableId,
                  toIndex: index
                }));
              },
              collect: monitor => ({
                isOver: monitor.isOver(),
                item: monitor.getItem()
              })
            }), [index]),
            _useDrop18 = _slicedToArray2(_useDrop17, 2),
            _useDrop18$ = _useDrop18[0],
            isOver = _useDrop18$.isOver,
            item = _useDrop18$.item,
            drop = _useDrop18[1];
          const isDraggingGroup = item != null && item.draggableId == "group";
          const canDrop = item && item.droppableId == "new-groups" && canDropWelcomeGroup(item, index) && canDropEndGroup(item, index, groupsCount) && canSortGroup(item, index);
          const theme = useTheme$1();
          const contrastColor = getContrastColor(theme.palette.background.paper);
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            ref: drop,
            style: {
              backgroundColor: isDraggingGroup && contrastColor,
              color: theme.palette.text.primary
            },
            className: "" + (emptySurvey ? styles$j.groupEmptyHint + (isOver ? " " + styles$j.groupEmptyHintHover : "") : isOver && canDrop ? styles$j.groupDropArea : isDraggingGroup ? styles$j.groupDragging : styles$j.groupHidden),
            children: [isDraggingGroup && !emptySurvey && /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
              children: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                className: styles$j.dropText,
                children: t("empty_survey_hint")
              })
            }), emptySurvey && /* @__PURE__ */jsxRuntimeExports.jsx("span", {
              children: t("empty_survey_hint")
            })]
          });
        }
        function QuestionDropArea({
          index,
          isLast = false,
          parentCode,
          parentType,
          parentIndex,
          emptyGroup = false,
          t
        }) {
          const theme = useTheme$1();
          const dispatch = useDispatch();
          const reorderRefreshCode = useSelector(state => {
            return state.designState["reorder_refresh_code"];
          });
          const _useDrop19 = useDrop(() => ({
              accept: ["new-questions", "questions"],
              hover(item) {
                if (item.type !== "questions" || item.droppableId === parentCode) {
                  return;
                }
                if (parentType === "end" && !isDisplay(item.itemType)) {
                  return;
                }
                dispatch(onDrag({
                  type: "reparent_question",
                  source: item.droppableId,
                  destination: parentCode,
                  id: item.draggableId
                }));
                item.index = index;
                item.parentIndex = parentIndex;
                item.isLast = isLast;
                item.droppableId = parentCode;
              },
              drop: item => {
                if (item.type !== "new-questions") {
                  return;
                }
                dispatch(onDrag({
                  type: "new_question",
                  questionType: item.draggableId,
                  destination: parentCode,
                  toIndex: index
                }));
              },
              collect: monitor => {
                var _monitor$getItem2, _monitor$getItem3, _monitor$getItem4, _monitor$getItem5, _monitor$getItem6;
                return {
                  isOver: ((_monitor$getItem2 = monitor.getItem()) === null || _monitor$getItem2 === void 0 ? void 0 : _monitor$getItem2.type) == "new-questions" && monitor.isOver() && (parentType !== "end" || isDisplay((_monitor$getItem3 = monitor.getItem()) === null || _monitor$getItem3 === void 0 ? void 0 : _monitor$getItem3.itemType)),
                  isDragging: parentType === "end" && !isDisplay((_monitor$getItem4 = monitor.getItem()) === null || _monitor$getItem4 === void 0 ? void 0 : _monitor$getItem4.itemType) ? false : ((_monitor$getItem5 = monitor.getItem()) === null || _monitor$getItem5 === void 0 ? void 0 : _monitor$getItem5.droppableId) === "new-questions" || ((_monitor$getItem6 = monitor.getItem()) === null || _monitor$getItem6 === void 0 ? void 0 : _monitor$getItem6.type) === "questions" && monitor.getItem().droppableId !== parentCode && (index == 0 && monitor.getItem().isLast && monitor.getItem().parentIndex + 1 === parentIndex || isLast && monitor.getItem().index == 0 && monitor.getItem().parentIndex - 1 === parentIndex)
                };
              }
            }), [reorderRefreshCode, index]),
            _useDrop20 = _slicedToArray2(_useDrop19, 2),
            _useDrop20$ = _useDrop20[0],
            isOver = _useDrop20$.isOver,
            isDragging = _useDrop20$.isDragging,
            drop = _useDrop20[1];
          const _useInView = useInView({
              /* Optional options */
              threshold: 0,
              trackVisibility: isDragging,
              delay: isDragging ? 100 : 0
            }),
            ref = _useInView.ref,
            inView = _useInView.inView,
            entry = _useInView.entry;
          const textContrast = theme.palette.text.primary;
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            ref,
            children: [" ", /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              ref: drop,
              style: {
                marginTop: !isDragging && !isOver ? "0rem" : "inherit",
                marginBottom: !isDragging && !isOver ? "0rem" : "inherit"
              },
              className: "question-drop-area " + (emptyGroup ? isOver ? styles$j.questionDropArea : isDragging && inView ? styles$j.isDragging : styles$j.groupEmptyHint : isOver ? styles$j.questionDropArea : isDragging && inView ? styles$j.isDragging : styles$j.hidden) + " ",
              children: [isDragging && !emptyGroup && /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(HelpOutline, {
                  sx: {
                    marginRight: "8px",
                    color: textContrast
                  }
                }), /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                  className: styles$j.dropText,
                  style: {
                    color: textContrast
                  },
                  children: t("empty_group_hint")
                })]
              }), emptyGroup && /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(HelpOutline, {
                  sx: {
                    marginRight: "8px",
                    color: textContrast
                  }
                }), /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                  className: styles$j.dropText,
                  style: {
                    color: textContrast
                  },
                  children: t("empty_group_hint")
                })]
              })]
            })]
          });
        }
        const canSortGroup = (item, index) => {
          if ((item === null || item === void 0 ? void 0 : item.index) === index || index - 1 === (item === null || item === void 0 ? void 0 : item.index)) {
            if ((item === null || item === void 0 ? void 0 : item.droppableId) !== "new-groups") {
              return false;
            }
          }
          return true;
        };
        const canDropWelcomeGroup = (item, index) => {
          if ((item === null || item === void 0 ? void 0 : item.draggableId) !== "welcome") {
            return true;
          }
          return index === 0;
        };
        const canDropEndGroup = (item, index, groupsCount) => {
          if ((item === null || item === void 0 ? void 0 : item.draggableId) !== "end") {
            return true;
          }
          return index === groupsCount;
        };
        function GroupHeader({
          t,
          code,
          children,
          designMode
        }) {
          console.debug("Group Header: " + code);
          const dispatch = useDispatch();
          const langInfo = useSelector(state => {
            return state.designState.langInfo;
          });
          const onMainLang = langInfo.onMainLang;
          const group = useSelector(state => {
            return state.designState[code];
          });
          const theme = useTheme();
          const inDesgin = designMode == DESIGN_SURVEY_MODE.DESIGN;
          const onDelete = reactExports.useCallback(() => dispatch(deleteGroup(code)), [code]);
          return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
            className: styles$k.headerContent,
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              className: styles$k.groupHeader,
              "data-code": code,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                className: styles$k.contentContainer,
                children: inDesgin && onMainLang && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  className: styles$k.actionToolbarVisible,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(ActionToolbar$1, {
                    code,
                    t,
                    isGroup: true,
                    onDelete,
                    disableDelete: children && children.length > 0
                  })
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: styles$k.textHeader,
                style: {
                  fontFamily: theme.textStyles.group.font,
                  color: theme.textStyles.group.color,
                  fontSize: theme.textStyles.group.size
                },
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ContentEditor$2, {
                  editable: designMode == DESIGN_SURVEY_MODE.DESIGN || designMode == DESIGN_SURVEY_MODE.LANGUAGES,
                  code,
                  extended: false,
                  contentKey: "label",
                  placeholder: t("content_editor_placeholder_title")
                })
              }), group.showDescription && /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                className: styles$k.textDescription,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ContentEditor$2, {
                  editable: designMode == DESIGN_SURVEY_MODE.DESIGN || designMode == DESIGN_SURVEY_MODE.LANGUAGES,
                  code,
                  extended: true,
                  contentKey: "description",
                  placeholder: t("content_editor_placeholder_description")
                })
              }), onMainLang && /* @__PURE__ */jsxRuntimeExports.jsx(ErrorDisplay$1, {
                type: "group",
                code
              })]
            })
          });
        }
        const GroupHeader$1 = React.memo(GroupHeader);
        function GroupDesign({
          t,
          code,
          index,
          designMode
        }) {
          const dispatch = useDispatch();
          const group = useSelector(state => {
            return state.designState[code];
          });
          const inDesign = designMode == DESIGN_SURVEY_MODE.DESIGN;
          const collapsed = useSelector(state => {
            var _state$designState$gl2;
            return ((_state$designState$gl2 = state.designState["globalSetup"]) === null || _state$designState$gl2 === void 0 ? void 0 : _state$designState$gl2.reorder_setup) === "collapse_groups";
          });
          const langInfo = useSelector(state => {
            return state.designState.langInfo;
          });
          const isInSetup = useSelector(state => {
            var _state$designState$se4;
            return ((_state$designState$se4 = state.designState.setup) === null || _state$designState$se4 === void 0 ? void 0 : _state$designState$se4.code) == code;
          });
          const theme = useTheme$1();
          const containerRef = reactExports.useRef();
          const _useDrag17 = useDrag({
              type: "groups",
              item: () => {
                return {
                  index,
                  draggableId: code,
                  droppableId: "groups",
                  type: "groups"
                };
              },
              collect: monitor => {
                var _monitor$getItem7;
                return ((_monitor$getItem7 = monitor.getItem()) === null || _monitor$getItem7 === void 0 ? void 0 : _monitor$getItem7.draggableId) === code;
              }
            }),
            _useDrag18 = _slicedToArray2(_useDrag17, 3),
            isDragging = _useDrag18[0],
            drag = _useDrag18[1],
            preview = _useDrag18[2];
          const _useDrop21 = useDrop({
              accept: "groups",
              hover(item, monitor) {
                var _containerRef$current2;
                if (!containerRef.current || type == "welcome" || type == "end" || !monitor.isOver({
                  shallow: true
                }) || !item || item.droppableId != "groups") {
                  return;
                }
                const dragIndex = item.index;
                const hoverIndex = index;
                if (dragIndex === hoverIndex) {
                  return;
                }
                const hoverBoundingRect = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.getBoundingClientRect();
                const clientOffset = monitor.getClientOffset();
                if (dragIndex < hoverIndex && clientOffset.y < hoverBoundingRect.top + 50) {
                  return;
                }
                if (dragIndex > hoverIndex && clientOffset.y > hoverBoundingRect.bottom - 50) {
                  return;
                }
                dispatch(onDrag({
                  type: "reorder_groups",
                  id: item.draggableId,
                  fromIndex: dragIndex,
                  toIndex: hoverIndex
                }));
                item.index = hoverIndex;
              }
            }),
            _useDrop22 = _slicedToArray2(_useDrop21, 2),
            collectedProps = _useDrop22[0],
            drop = _useDrop22[1];
          langInfo.onMainLang;
          const type = group === null || group === void 0 ? void 0 : group.groupType.toLowerCase();
          const children = group === null || group === void 0 ? void 0 : group.children;
          const getStyles = isDragging2 => {
            const styles2 = {
              transition: "all 500ms"
            };
            if (isDragging2) {
              styles2.opacity = 0.2;
            }
            return styles2;
          };
          drop(preview(containerRef));
          const contrastColor = getContrastColor(theme.palette.background.paper);
          const textColor = theme.textStyles.question.color;
          if (!group) {
            return null;
          }
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            sx: isInSetup ? {
              border: `0.5px solid ${textColor}`,
              color: textColor,
              backgroundColor: contrastColor
            } : {
              backgroundColor: "background.paper"
            },
            className: styles$k.topLevel,
            ref: containerRef,
            style: getStyles(isDragging),
            children: [collapsed == true && type !== "welcome" && type !== "end" ? /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$k.moveBox,
              ref: drag,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$m, {
                style: {
                  color: textColor
                }
              })
            }) : /* @__PURE__ */jsxRuntimeExports.jsx("br", {}), /* @__PURE__ */jsxRuntimeExports.jsx(GroupHeader$1, {
              t,
              code,
              index,
              designMode,
              children
            }), collapsed !== true && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [children && children.length > 0 && /* @__PURE__ */jsxRuntimeExports.jsx(QuestionDropArea, {
                index: 0,
                parentCode: code,
                parentType: type,
                parentIndex: index,
                t
              }), children === null || children === void 0 ? void 0 : children.map((quest, childIndex) => {
                return /* @__PURE__ */jsxRuntimeExports.jsxs(React.Fragment, {
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(QuestionDesign$1, {
                    t,
                    parentCode: code,
                    parentIndex: index,
                    index: childIndex,
                    isLast: children.length == childIndex + 1,
                    type: quest.type,
                    code: quest.code,
                    designMode,
                    onMainLang: inDesign
                  }, quest.code), /* @__PURE__ */jsxRuntimeExports.jsx(QuestionDropArea, {
                    isLast: children.length == childIndex + 1,
                    index: childIndex + 1,
                    parentIndex: index,
                    parentCode: code,
                    parentType: type,
                    t
                  })]
                }, quest.code);
              }), (!children || !children.length) && inDesign && /* @__PURE__ */jsxRuntimeExports.jsx(QuestionDropArea, {
                t,
                index: 0,
                parentCode: code,
                parentType: type,
                emptyGroup: true
              })]
            })]
          });
        }
        const GroupDesign$1 = React.memo(GroupDesign);
        const PUBLISH = 0;
        const SUBSCRIBE = 1;
        const RESET = 2;
        const VALUE = 4;
        function compose(a, b) {
          return arg => a(b(arg));
        }
        function thrush(arg, proc) {
          return proc(arg);
        }
        function curry2to1(proc, arg1) {
          return arg2 => proc(arg1, arg2);
        }
        function curry1to0(proc, arg) {
          return () => proc(arg);
        }
        function tap(arg, proc) {
          proc(arg);
          return arg;
        }
        function tup(...args) {
          return args;
        }
        function call(proc) {
          proc();
        }
        function always(value) {
          return () => value;
        }
        function joinProc(...procs) {
          return () => {
            procs.map(call);
          };
        }
        function isDefined(arg) {
          return arg !== void 0;
        }
        function noop$1() {}
        function subscribe(emitter, subscription) {
          return emitter(SUBSCRIBE, subscription);
        }
        function publish(publisher, value) {
          publisher(PUBLISH, value);
        }
        function reset(emitter) {
          emitter(RESET);
        }
        function getValue$1(depot) {
          return depot(VALUE);
        }
        function connect(emitter, publisher) {
          return subscribe(emitter, curry2to1(publisher, PUBLISH));
        }
        function handleNext(emitter, subscription) {
          const unsub = emitter(SUBSCRIBE, value => {
            unsub();
            subscription(value);
          });
          return unsub;
        }
        function stream() {
          const subscriptions = [];
          return (action, arg) => {
            switch (action) {
              case RESET:
                subscriptions.splice(0, subscriptions.length);
                return;
              case SUBSCRIBE:
                subscriptions.push(arg);
                return () => {
                  const indexOf = subscriptions.indexOf(arg);
                  if (indexOf > -1) {
                    subscriptions.splice(indexOf, 1);
                  }
                };
              case PUBLISH:
                subscriptions.slice().forEach(subscription => {
                  subscription(arg);
                });
                return;
              default:
                throw new Error(`unrecognized action ${action}`);
            }
          };
        }
        function statefulStream(initial) {
          let value = initial;
          const innerSubject = stream();
          return (action, arg) => {
            switch (action) {
              case SUBSCRIBE:
                const subscription = arg;
                subscription(value);
                break;
              case PUBLISH:
                value = arg;
                break;
              case VALUE:
                return value;
            }
            return innerSubject(action, arg);
          };
        }
        function eventHandler(emitter) {
          let unsub;
          let currentSubscription;
          const cleanup = () => unsub && unsub();
          return function (action, subscription) {
            switch (action) {
              case SUBSCRIBE:
                if (subscription) {
                  if (currentSubscription === subscription) {
                    return;
                  }
                  cleanup();
                  currentSubscription = subscription;
                  unsub = subscribe(emitter, subscription);
                  return unsub;
                } else {
                  cleanup();
                  return noop$1;
                }
              case RESET:
                cleanup();
                currentSubscription = null;
                return;
              default:
                throw new Error(`unrecognized action ${action}`);
            }
          };
        }
        function streamFromEmitter(emitter) {
          return tap(stream(), stream2 => connect(emitter, stream2));
        }
        function statefulStreamFromEmitter(emitter, initial) {
          return tap(statefulStream(initial), stream2 => connect(emitter, stream2));
        }
        function combineOperators(...operators) {
          return subscriber => {
            return operators.reduceRight(thrush, subscriber);
          };
        }
        function pipe(source, ...operators) {
          const project = combineOperators(...operators);
          return (action, subscription) => {
            switch (action) {
              case SUBSCRIBE:
                return subscribe(source, project(subscription));
              case RESET:
                reset(source);
                return;
            }
          };
        }
        function defaultComparator$1(previous, next) {
          return previous === next;
        }
        function distinctUntilChanged(comparator = defaultComparator$1) {
          let current;
          return done => next => {
            if (!comparator(current, next)) {
              current = next;
              done(next);
            }
          };
        }
        function filter(predicate) {
          return done => value => {
            predicate(value) && done(value);
          };
        }
        function map$3(project) {
          return done => compose(done, project);
        }
        function mapTo(value) {
          return done => () => done(value);
        }
        function scan(scanner, initial) {
          return done => value => done(initial = scanner(initial, value));
        }
        function skip(times) {
          return done => value => {
            times > 0 ? times-- : done(value);
          };
        }
        function throttleTime(interval) {
          let currentValue = null;
          let timeout;
          return done => value => {
            currentValue = value;
            if (timeout) {
              return;
            }
            timeout = setTimeout(() => {
              timeout = void 0;
              done(currentValue);
            }, interval);
          };
        }
        function debounceTime(interval) {
          let currentValue;
          let timeout;
          return done => value => {
            currentValue = value;
            if (timeout) {
              clearTimeout(timeout);
            }
            timeout = setTimeout(() => {
              done(currentValue);
            }, interval);
          };
        }
        function withLatestFrom(...sources) {
          const values = new Array(sources.length);
          let called = 0;
          let pendingCall = null;
          const allCalled = Math.pow(2, sources.length) - 1;
          sources.forEach((source, index) => {
            const bit = Math.pow(2, index);
            subscribe(source, value => {
              const prevCalled = called;
              called = called | bit;
              values[index] = value;
              if (prevCalled !== allCalled && called === allCalled && pendingCall) {
                pendingCall();
                pendingCall = null;
              }
            });
          });
          return done => value => {
            const call2 = () => done([value].concat(values));
            if (called === allCalled) {
              call2();
            } else {
              pendingCall = call2;
            }
          };
        }
        function merge$4(...sources) {
          return function (action, subscription) {
            switch (action) {
              case SUBSCRIBE:
                return joinProc(...sources.map(source => subscribe(source, subscription)));
              case RESET:
                return;
              default:
                throw new Error(`unrecognized action ${action}`);
            }
          };
        }
        function duc(source, comparator = defaultComparator$1) {
          return pipe(source, distinctUntilChanged(comparator));
        }
        function combineLatest(...emitters) {
          const innerSubject = stream();
          const values = new Array(emitters.length);
          let called = 0;
          const allCalled = Math.pow(2, emitters.length) - 1;
          emitters.forEach((source, index) => {
            const bit = Math.pow(2, index);
            subscribe(source, value => {
              values[index] = value;
              called = called | bit;
              if (called === allCalled) {
                publish(innerSubject, values);
              }
            });
          });
          return function (action, subscription) {
            switch (action) {
              case SUBSCRIBE:
                if (called === allCalled) {
                  subscription(values);
                }
                return subscribe(innerSubject, subscription);
              case RESET:
                return reset(innerSubject);
              default:
                throw new Error(`unrecognized action ${action}`);
            }
          };
        }
        function system(constructor, dependencies = [], {
          singleton
        } = {
          singleton: true
        }) {
          return {
            id: id(),
            constructor,
            dependencies,
            singleton
          };
        }
        const id = () => Symbol();
        function init(systemSpec) {
          const singletons = /* @__PURE__ */new Map();
          const _init = ({
            id: id2,
            constructor,
            dependencies,
            singleton
          }) => {
            if (singleton && singletons.has(id2)) {
              return singletons.get(id2);
            }
            const system2 = constructor(dependencies.map(e => _init(e)));
            if (singleton) {
              singletons.set(id2, system2);
            }
            return system2;
          };
          return _init(systemSpec);
        }
        function omit$3(keys, obj) {
          const result = {};
          const index = {};
          let idx = 0;
          const len = keys.length;
          while (idx < len) {
            index[keys[idx]] = 1;
            idx += 1;
          }
          for (const prop in obj) {
            if (!index.hasOwnProperty(prop)) {
              result[prop] = obj[prop];
            }
          }
          return result;
        }
        const useIsomorphicLayoutEffect$1 = typeof document !== "undefined" ? React.useLayoutEffect : React.useEffect;
        function systemToComponent(systemSpec, map2, Root) {
          const requiredPropNames = Object.keys(map2.required || {});
          const optionalPropNames = Object.keys(map2.optional || {});
          const methodNames = Object.keys(map2.methods || {});
          const eventNames = Object.keys(map2.events || {});
          const Context = React.createContext({});
          function applyPropsToSystem(system2, props) {
            if (system2["propsReady"]) {
              publish(system2["propsReady"], false);
            }
            for (var _i6 = 0, _requiredPropNames = requiredPropNames; _i6 < _requiredPropNames.length; _i6++) {
              const requiredPropName = _requiredPropNames[_i6];
              const stream2 = system2[map2.required[requiredPropName]];
              publish(stream2, props[requiredPropName]);
            }
            for (var _i7 = 0, _optionalPropNames = optionalPropNames; _i7 < _optionalPropNames.length; _i7++) {
              const optionalPropName = _optionalPropNames[_i7];
              if (optionalPropName in props) {
                const stream2 = system2[map2.optional[optionalPropName]];
                publish(stream2, props[optionalPropName]);
              }
            }
            if (system2["propsReady"]) {
              publish(system2["propsReady"], true);
            }
          }
          function buildMethods(system2) {
            return methodNames.reduce((acc, methodName) => {
              acc[methodName] = value => {
                const stream2 = system2[map2.methods[methodName]];
                publish(stream2, value);
              };
              return acc;
            }, {});
          }
          function buildEventHandlers(system2) {
            return eventNames.reduce((handlers, eventName) => {
              handlers[eventName] = eventHandler(system2[map2.events[eventName]]);
              return handlers;
            }, {});
          }
          const Component = React.forwardRef((propsWithChildren, ref) => {
            const children = propsWithChildren.children,
              props = _objectWithoutProperties2(propsWithChildren, _excluded5);
            const _React$useState13 = React.useState(() => {
                return tap(init(systemSpec), system22 => applyPropsToSystem(system22, props));
              }),
              _React$useState14 = _slicedToArray2(_React$useState13, 1),
              system2 = _React$useState14[0];
            const _React$useState15 = React.useState(curry1to0(buildEventHandlers, system2)),
              _React$useState16 = _slicedToArray2(_React$useState15, 1),
              handlers = _React$useState16[0];
            useIsomorphicLayoutEffect$1(() => {
              for (var _i8 = 0, _eventNames = eventNames; _i8 < _eventNames.length; _i8++) {
                const eventName = _eventNames[_i8];
                if (eventName in props) {
                  subscribe(handlers[eventName], props[eventName]);
                }
              }
              return () => {
                Object.values(handlers).map(reset);
              };
            }, [props, handlers, system2]);
            useIsomorphicLayoutEffect$1(() => {
              applyPropsToSystem(system2, props);
            });
            React.useImperativeHandle(ref, always(buildMethods(system2)));
            const RootComponent = Root;
            return /* @__PURE__ */jsxRuntimeExports.jsx(Context.Provider, {
              value: system2,
              children: Root ? /* @__PURE__ */jsxRuntimeExports.jsx(RootComponent, _objectSpread3(_objectSpread3({}, omit$3([...requiredPropNames, ...optionalPropNames, ...eventNames], props)), {}, {
                children
              })) : children
            });
          });
          const usePublisher2 = key => {
            return React.useCallback(curry2to1(publish, React.useContext(Context)[key]), [key]);
          };
          const useEmitterValue18 = key => {
            const system2 = React.useContext(Context);
            const source = system2[key];
            const cb = React.useCallback(c => {
              return subscribe(source, c);
            }, [source]);
            return React.useSyncExternalStore(cb, () => getValue$1(source), () => getValue$1(source));
          };
          const useEmitterValueLegacy = key => {
            const system2 = React.useContext(Context);
            const source = system2[key];
            const _React$useState17 = React.useState(curry1to0(getValue$1, source)),
              _React$useState18 = _slicedToArray2(_React$useState17, 2),
              value = _React$useState18[0],
              setValue = _React$useState18[1];
            useIsomorphicLayoutEffect$1(() => subscribe(source, next => {
              if (next !== value) {
                setValue(always(next));
              }
            }), [source, value]);
            return value;
          };
          const useEmitterValue2 = React.version.startsWith("18") ? useEmitterValue18 : useEmitterValueLegacy;
          const useEmitter2 = (key, callback) => {
            const context = React.useContext(Context);
            const source = context[key];
            useIsomorphicLayoutEffect$1(() => subscribe(source, callback), [callback, source]);
          };
          return {
            Component,
            usePublisher: usePublisher2,
            useEmitterValue: useEmitterValue2,
            useEmitter: useEmitter2
          };
        }
        const useIsomorphicLayoutEffect = typeof document !== "undefined" ? React.useLayoutEffect : React.useEffect;
        var LogLevel = /* @__PURE__ */(LogLevel2 => {
          LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
          LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
          LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
          LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
          return LogLevel2;
        })(LogLevel || {});
        const CONSOLE_METHOD_MAP = {
          [0
          /* DEBUG */]: "debug",
          [1
          /* INFO */]: "log",
          [2
          /* WARN */]: "warn",
          [3
          /* ERROR */]: "error"
        };
        const getGlobalThis = () => typeof globalThis === "undefined" ? window : globalThis;
        const loggerSystem = system(() => {
          const logLevel = statefulStream(3
          /* ERROR */);
          const log = statefulStream((label, message, level = 1) => {
            var _a;
            const currentLevel = (_a = getGlobalThis()["VIRTUOSO_LOG_LEVEL"]) != null ? _a : getValue$1(logLevel);
            if (level >= currentLevel) {
              console[CONSOLE_METHOD_MAP[level]]("%creact-virtuoso: %c%s %o", "color: #0253b3; font-weight: bold", "color: initial", label, message);
            }
          });
          return {
            log,
            logLevel
          };
        }, [], {
          singleton: true
        });
        function useSizeWithElRef(callback, enabled, skipAnimationFrame) {
          const ref = React.useRef(null);
          let callbackRef = _el => {};
          if (typeof ResizeObserver !== "undefined") {
            const observer = React.useMemo(() => {
              return new ResizeObserver(entries => {
                const code = () => {
                  const element = entries[0].target;
                  if (element.offsetParent !== null) {
                    callback(element);
                  }
                };
                skipAnimationFrame ? code() : requestAnimationFrame(code);
              });
            }, [callback]);
            callbackRef = elRef => {
              if (elRef && enabled) {
                observer.observe(elRef);
                ref.current = elRef;
              } else {
                if (ref.current) {
                  observer.unobserve(ref.current);
                }
                ref.current = null;
              }
            };
          }
          return {
            ref,
            callbackRef
          };
        }
        function useSize(callback, enabled, skipAnimationFrame) {
          return useSizeWithElRef(callback, enabled, skipAnimationFrame).callbackRef;
        }
        function useChangedListContentsSizes(callback, itemSize, enabled, scrollContainerStateCallback, log, gap, customScrollParent, horizontalDirection, skipAnimationFrame) {
          const memoedCallback = React.useCallback(el => {
            const ranges = getChangedChildSizes(el.children, itemSize, horizontalDirection ? "offsetWidth" : "offsetHeight", log);
            let scrollableElement = el.parentElement;
            while (!scrollableElement.dataset["virtuosoScroller"]) {
              scrollableElement = scrollableElement.parentElement;
            }
            const windowScrolling = scrollableElement.lastElementChild.dataset["viewportType"] === "window";
            const scrollTop = customScrollParent ? horizontalDirection ? customScrollParent.scrollLeft : customScrollParent.scrollTop : windowScrolling ? horizontalDirection ? window.pageXOffset || document.documentElement.scrollLeft : window.pageYOffset || document.documentElement.scrollTop : horizontalDirection ? scrollableElement.scrollLeft : scrollableElement.scrollTop;
            const scrollHeight = customScrollParent ? horizontalDirection ? customScrollParent.scrollWidth : customScrollParent.scrollHeight : windowScrolling ? horizontalDirection ? document.documentElement.scrollWidth : document.documentElement.scrollHeight : horizontalDirection ? scrollableElement.scrollWidth : scrollableElement.scrollHeight;
            const viewportHeight = customScrollParent ? horizontalDirection ? customScrollParent.offsetWidth : customScrollParent.offsetHeight : windowScrolling ? horizontalDirection ? window.innerWidth : window.innerHeight : horizontalDirection ? scrollableElement.offsetWidth : scrollableElement.offsetHeight;
            scrollContainerStateCallback({
              scrollTop: Math.max(scrollTop, 0),
              scrollHeight,
              viewportHeight
            });
            gap == null ? void 0 : gap(horizontalDirection ? resolveGapValue$1("column-gap", getComputedStyle(el).columnGap, log) : resolveGapValue$1("row-gap", getComputedStyle(el).rowGap, log));
            if (ranges !== null) {
              callback(ranges);
            }
          }, [callback, itemSize, log, gap, customScrollParent, scrollContainerStateCallback]);
          return useSizeWithElRef(memoedCallback, enabled, skipAnimationFrame);
        }
        function getChangedChildSizes(children, itemSize, field, log) {
          const length = children.length;
          if (length === 0) {
            return null;
          }
          const results = [];
          for (let i = 0; i < length; i++) {
            const child = children.item(i);
            if (!child || child.dataset.index === void 0) {
              continue;
            }
            const index = parseInt(child.dataset.index);
            const knownSize = parseFloat(child.dataset.knownSize);
            const size = itemSize(child, field);
            if (size === 0) {
              log("Zero-sized element, this should not happen", {
                child
              }, LogLevel.ERROR);
            }
            if (size === knownSize) {
              continue;
            }
            const lastResult = results[results.length - 1];
            if (results.length === 0 || lastResult.size !== size || lastResult.endIndex !== index - 1) {
              results.push({
                startIndex: index,
                endIndex: index,
                size
              });
            } else {
              results[results.length - 1].endIndex++;
            }
          }
          return results;
        }
        function resolveGapValue$1(property, value, log) {
          if (value !== "normal" && !(value == null ? void 0 : value.endsWith("px"))) {
            log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);
          }
          if (value === "normal") {
            return 0;
          }
          return parseInt(value != null ? value : "0", 10);
        }
        function correctItemSize(el, dimension) {
          return Math.round(el.getBoundingClientRect()[dimension]);
        }
        function approximatelyEqual(num1, num2) {
          return Math.abs(num1 - num2) < 1.01;
        }
        function useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, scrollerElement, scrollerRefCallback = noop$1, customScrollParent, horizontalDirection) {
          const scrollerRef = React.useRef(null);
          const scrollTopTarget = React.useRef(null);
          const timeoutRef = React.useRef(null);
          const handler = React.useCallback(ev => {
            const el = ev.target;
            const windowScroll = el === window || el === document;
            const scrollTop = horizontalDirection ? windowScroll ? window.pageXOffset || document.documentElement.scrollLeft : el.scrollLeft : windowScroll ? window.pageYOffset || document.documentElement.scrollTop : el.scrollTop;
            const scrollHeight = horizontalDirection ? windowScroll ? document.documentElement.scrollWidth : el.scrollWidth : windowScroll ? document.documentElement.scrollHeight : el.scrollHeight;
            const viewportHeight = horizontalDirection ? windowScroll ? window.innerWidth : el.offsetWidth : windowScroll ? window.innerHeight : el.offsetHeight;
            const call2 = () => {
              scrollContainerStateCallback({
                scrollTop: Math.max(scrollTop, 0),
                scrollHeight,
                viewportHeight
              });
            };
            if (ev.suppressFlushSync) {
              call2();
            } else {
              ReactDOM.flushSync(call2);
            }
            if (scrollTopTarget.current !== null) {
              if (scrollTop === scrollTopTarget.current || scrollTop <= 0 || scrollTop === scrollHeight - viewportHeight) {
                scrollTopTarget.current = null;
                smoothScrollTargetReached(true);
                if (timeoutRef.current) {
                  clearTimeout(timeoutRef.current);
                  timeoutRef.current = null;
                }
              }
            }
          }, [scrollContainerStateCallback, smoothScrollTargetReached]);
          React.useEffect(() => {
            const localRef = customScrollParent ? customScrollParent : scrollerRef.current;
            scrollerRefCallback(customScrollParent ? customScrollParent : scrollerRef.current);
            handler({
              target: localRef,
              suppressFlushSync: true
            });
            localRef.addEventListener("scroll", handler, {
              passive: true
            });
            return () => {
              scrollerRefCallback(null);
              localRef.removeEventListener("scroll", handler);
            };
          }, [scrollerRef, handler, scrollerElement, scrollerRefCallback, customScrollParent]);
          function scrollToCallback(location) {
            const scrollerElement2 = scrollerRef.current;
            if (!scrollerElement2 || (horizontalDirection ? "offsetWidth" in scrollerElement2 && scrollerElement2.offsetWidth === 0 : "offsetHeight" in scrollerElement2 && scrollerElement2.offsetHeight === 0)) {
              return;
            }
            const isSmooth = location.behavior === "smooth";
            let offsetHeight;
            let scrollHeight;
            let scrollTop;
            if (scrollerElement2 === window) {
              scrollHeight = Math.max(correctItemSize(document.documentElement, horizontalDirection ? "width" : "height"), horizontalDirection ? document.documentElement.scrollWidth : document.documentElement.scrollHeight);
              offsetHeight = horizontalDirection ? window.innerWidth : window.innerHeight;
              scrollTop = horizontalDirection ? document.documentElement.scrollLeft : document.documentElement.scrollTop;
            } else {
              scrollHeight = scrollerElement2[horizontalDirection ? "scrollWidth" : "scrollHeight"];
              offsetHeight = correctItemSize(scrollerElement2, horizontalDirection ? "width" : "height");
              scrollTop = scrollerElement2[horizontalDirection ? "scrollLeft" : "scrollTop"];
            }
            const maxScrollTop = scrollHeight - offsetHeight;
            location.top = Math.ceil(Math.max(Math.min(maxScrollTop, location.top), 0));
            if (approximatelyEqual(offsetHeight, scrollHeight) || location.top === scrollTop) {
              scrollContainerStateCallback({
                scrollTop,
                scrollHeight,
                viewportHeight: offsetHeight
              });
              if (isSmooth) {
                smoothScrollTargetReached(true);
              }
              return;
            }
            if (isSmooth) {
              scrollTopTarget.current = location.top;
              if (timeoutRef.current) {
                clearTimeout(timeoutRef.current);
              }
              timeoutRef.current = setTimeout(() => {
                timeoutRef.current = null;
                scrollTopTarget.current = null;
                smoothScrollTargetReached(true);
              }, 1e3);
            } else {
              scrollTopTarget.current = null;
            }
            if (horizontalDirection) {
              location = {
                left: location.top,
                behavior: location.behavior
              };
            }
            scrollerElement2.scrollTo(location);
          }
          function scrollByCallback(location) {
            if (horizontalDirection) {
              location = {
                left: location.top,
                behavior: location.behavior
              };
            }
            scrollerRef.current.scrollBy(location);
          }
          return {
            scrollerRef,
            scrollByCallback,
            scrollToCallback
          };
        }
        const domIOSystem = system(() => {
          const scrollContainerState = stream();
          const scrollTop = stream();
          const deviation = statefulStream(0);
          const smoothScrollTargetReached = stream();
          const statefulScrollTop = statefulStream(0);
          const viewportHeight = stream();
          const scrollHeight = stream();
          const headerHeight = statefulStream(0);
          const fixedHeaderHeight = statefulStream(0);
          const fixedFooterHeight = statefulStream(0);
          const footerHeight = statefulStream(0);
          const scrollTo = stream();
          const scrollBy = stream();
          const scrollingInProgress = statefulStream(false);
          const horizontalDirection = statefulStream(false);
          const skipAnimationFrameInResizeObserver = statefulStream(false);
          connect(pipe(scrollContainerState, map$3(({
            scrollTop: scrollTop2
          }) => scrollTop2)), scrollTop);
          connect(pipe(scrollContainerState, map$3(({
            scrollHeight: scrollHeight2
          }) => scrollHeight2)), scrollHeight);
          connect(scrollTop, statefulScrollTop);
          return {
            // input
            scrollContainerState,
            scrollTop,
            viewportHeight,
            headerHeight,
            fixedHeaderHeight,
            fixedFooterHeight,
            footerHeight,
            scrollHeight,
            smoothScrollTargetReached,
            horizontalDirection,
            skipAnimationFrameInResizeObserver,
            // signals
            scrollTo,
            scrollBy,
            // state
            statefulScrollTop,
            deviation,
            scrollingInProgress
          };
        }, [], {
          singleton: true
        });
        const NIL_NODE = {
          lvl: 0
        };
        function newAANode(k, v, lvl, l = NIL_NODE, r = NIL_NODE) {
          return {
            k,
            v,
            lvl,
            l,
            r
          };
        }
        function empty(node) {
          return node === NIL_NODE;
        }
        function newTree() {
          return NIL_NODE;
        }
        function remove$1(node, key) {
          if (empty(node)) return NIL_NODE;
          const k = node.k,
            l = node.l,
            r = node.r;
          if (key === k) {
            if (empty(l)) {
              return r;
            } else if (empty(r)) {
              return l;
            } else {
              const _last$ = last$3(l),
                _last$2 = _slicedToArray2(_last$, 2),
                lastKey = _last$2[0],
                lastValue = _last$2[1];
              return adjust(clone$6(node, {
                k: lastKey,
                v: lastValue,
                l: deleteLast(l)
              }));
            }
          } else if (key < k) {
            return adjust(clone$6(node, {
              l: remove$1(l, key)
            }));
          } else {
            return adjust(clone$6(node, {
              r: remove$1(r, key)
            }));
          }
        }
        function find(node, key) {
          if (empty(node)) {
            return;
          }
          if (key === node.k) {
            return node.v;
          } else if (key < node.k) {
            return find(node.l, key);
          } else {
            return find(node.r, key);
          }
        }
        function findMaxKeyValue(node, value, field = "k") {
          if (empty(node)) {
            return [-Infinity, void 0];
          }
          if (Number(node[field]) === value) {
            return [node.k, node.v];
          }
          if (Number(node[field]) < value) {
            const r = findMaxKeyValue(node.r, value, field);
            if (r[0] === -Infinity) {
              return [node.k, node.v];
            } else {
              return r;
            }
          }
          return findMaxKeyValue(node.l, value, field);
        }
        function insert(node, k, v) {
          if (empty(node)) {
            return newAANode(k, v, 1);
          }
          if (k === node.k) {
            return clone$6(node, {
              k,
              v
            });
          } else if (k < node.k) {
            return rebalance(clone$6(node, {
              l: insert(node.l, k, v)
            }));
          } else {
            return rebalance(clone$6(node, {
              r: insert(node.r, k, v)
            }));
          }
        }
        function walkWithin(node, start, end) {
          if (empty(node)) {
            return [];
          }
          const k = node.k,
            v = node.v,
            l = node.l,
            r = node.r;
          let result = [];
          if (k > start) {
            result = result.concat(walkWithin(l, start, end));
          }
          if (k >= start && k <= end) {
            result.push({
              k,
              v
            });
          }
          if (k <= end) {
            result = result.concat(walkWithin(r, start, end));
          }
          return result;
        }
        function walk(node) {
          if (empty(node)) {
            return [];
          }
          return [...walk(node.l), {
            k: node.k,
            v: node.v
          }, ...walk(node.r)];
        }
        function last$3(node) {
          return empty(node.r) ? [node.k, node.v] : last$3(node.r);
        }
        function deleteLast(node) {
          return empty(node.r) ? node.l : adjust(clone$6(node, {
            r: deleteLast(node.r)
          }));
        }
        function clone$6(node, args) {
          return newAANode(args.k !== void 0 ? args.k : node.k, args.v !== void 0 ? args.v : node.v, args.lvl !== void 0 ? args.lvl : node.lvl, args.l !== void 0 ? args.l : node.l, args.r !== void 0 ? args.r : node.r);
        }
        function isSingle(node) {
          return empty(node) || node.lvl > node.r.lvl;
        }
        function rebalance(node) {
          return split(skew(node));
        }
        function adjust(node) {
          const l = node.l,
            r = node.r,
            lvl = node.lvl;
          if (r.lvl >= lvl - 1 && l.lvl >= lvl - 1) {
            return node;
          } else if (lvl > r.lvl + 1) {
            if (isSingle(l)) {
              return skew(clone$6(node, {
                lvl: lvl - 1
              }));
            } else {
              if (!empty(l) && !empty(l.r)) {
                return clone$6(l.r, {
                  l: clone$6(l, {
                    r: l.r.l
                  }),
                  r: clone$6(node, {
                    l: l.r.r,
                    lvl: lvl - 1
                  }),
                  lvl
                });
              } else {
                throw new Error("Unexpected empty nodes");
              }
            }
          } else {
            if (isSingle(node)) {
              return split(clone$6(node, {
                lvl: lvl - 1
              }));
            } else {
              if (!empty(r) && !empty(r.l)) {
                const rl = r.l;
                const rlvl = isSingle(rl) ? r.lvl - 1 : r.lvl;
                return clone$6(rl, {
                  l: clone$6(node, {
                    r: rl.l,
                    lvl: lvl - 1
                  }),
                  r: split(clone$6(r, {
                    l: rl.r,
                    lvl: rlvl
                  })),
                  lvl: rl.lvl + 1
                });
              } else {
                throw new Error("Unexpected empty nodes");
              }
            }
          }
        }
        function rangesWithin(node, startIndex, endIndex) {
          if (empty(node)) {
            return [];
          }
          const adjustedStart = findMaxKeyValue(node, startIndex)[0];
          return toRanges(walkWithin(node, adjustedStart, endIndex));
        }
        function arrayToRanges(items, parser) {
          const length = items.length;
          if (length === 0) {
            return [];
          }
          let _parser = parser(items[0]),
            start = _parser.index,
            value = _parser.value;
          const result = [];
          for (let i = 1; i < length; i++) {
            const _parser2 = parser(items[i]),
              nextIndex = _parser2.index,
              nextValue = _parser2.value;
            result.push({
              start,
              end: nextIndex - 1,
              value
            });
            start = nextIndex;
            value = nextValue;
          }
          result.push({
            start,
            end: Infinity,
            value
          });
          return result;
        }
        function toRanges(nodes) {
          return arrayToRanges(nodes, ({
            k: index,
            v: value
          }) => ({
            index,
            value
          }));
        }
        function split(node) {
          const r = node.r,
            lvl = node.lvl;
          return !empty(r) && !empty(r.r) && r.lvl === lvl && r.r.lvl === lvl ? clone$6(r, {
            l: clone$6(node, {
              r: r.l
            }),
            lvl: lvl + 1
          }) : node;
        }
        function skew(node) {
          const l = node.l;
          return !empty(l) && l.lvl === node.lvl ? clone$6(l, {
            r: clone$6(node, {
              l: l.r
            })
          }) : node;
        }
        function findIndexOfClosestSmallerOrEqual(items, value, comparator, start = 0) {
          let end = items.length - 1;
          while (start <= end) {
            const index = Math.floor((start + end) / 2);
            const item = items[index];
            const match = comparator(item, value);
            if (match === 0) {
              return index;
            }
            if (match === -1) {
              if (end - start < 2) {
                return index - 1;
              }
              end = index - 1;
            } else {
              if (end === start) {
                return index;
              }
              start = index + 1;
            }
          }
          throw new Error(`Failed binary finding record in array - ${items.join(",")}, searched for ${value}`);
        }
        function findClosestSmallerOrEqual(items, value, comparator) {
          return items[findIndexOfClosestSmallerOrEqual(items, value, comparator)];
        }
        function findRange(items, startValue, endValue, comparator) {
          const startIndex = findIndexOfClosestSmallerOrEqual(items, startValue, comparator);
          const endIndex = findIndexOfClosestSmallerOrEqual(items, endValue, comparator, startIndex);
          return items.slice(startIndex, endIndex + 1);
        }
        const recalcSystem = system(() => {
          const recalcInProgress = statefulStream(false);
          return {
            recalcInProgress
          };
        }, [], {
          singleton: true
        });
        function rangeIncludes(refRange) {
          const size = refRange.size,
            startIndex = refRange.startIndex,
            endIndex = refRange.endIndex;
          return range => {
            return range.start === startIndex && (range.end === endIndex || range.end === Infinity) && range.value === size;
          };
        }
        function affectedGroupCount(offset, groupIndices) {
          let recognizedOffsetItems = 0;
          let groupIndex = 0;
          while (recognizedOffsetItems < offset) {
            recognizedOffsetItems += groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;
            groupIndex++;
          }
          const offsetIsExact = recognizedOffsetItems === offset;
          return groupIndex - (offsetIsExact ? 0 : 1);
        }
        function insertRanges(sizeTree, ranges) {
          let syncStart = empty(sizeTree) ? 0 : Infinity;
          var _iterator11 = _createForOfIteratorHelper2(ranges),
            _step11;
          try {
            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
              const range = _step11.value;
              const size = range.size,
                startIndex = range.startIndex,
                endIndex = range.endIndex;
              syncStart = Math.min(syncStart, startIndex);
              if (empty(sizeTree)) {
                sizeTree = insert(sizeTree, 0, size);
                continue;
              }
              const overlappingRanges = rangesWithin(sizeTree, startIndex - 1, endIndex + 1);
              if (overlappingRanges.some(rangeIncludes(range))) {
                continue;
              }
              let firstPassDone = false;
              let shouldInsert = false;
              var _iterator12 = _createForOfIteratorHelper2(overlappingRanges),
                _step12;
              try {
                for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                  const _step12$value = _step12.value,
                    rangeStart = _step12$value.start,
                    rangeEnd = _step12$value.end,
                    rangeValue = _step12$value.value;
                  if (!firstPassDone) {
                    shouldInsert = rangeValue !== size;
                    firstPassDone = true;
                  } else {
                    if (endIndex >= rangeStart || size === rangeValue) {
                      sizeTree = remove$1(sizeTree, rangeStart);
                    }
                  }
                  if (rangeEnd > endIndex && endIndex >= rangeStart) {
                    if (rangeValue !== size) {
                      sizeTree = insert(sizeTree, endIndex + 1, rangeValue);
                    }
                  }
                }
              } catch (err) {
                _iterator12.e(err);
              } finally {
                _iterator12.f();
              }
              if (shouldInsert) {
                sizeTree = insert(sizeTree, startIndex, size);
              }
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }
          return [sizeTree, syncStart];
        }
        function initialSizeState() {
          return {
            offsetTree: [],
            sizeTree: newTree(),
            groupOffsetTree: newTree(),
            lastIndex: 0,
            lastOffset: 0,
            lastSize: 0,
            groupIndices: []
          };
        }
        function indexComparator({
          index: itemIndex
        }, index) {
          return index === itemIndex ? 0 : index < itemIndex ? -1 : 1;
        }
        function offsetComparator({
          offset: itemOffset
        }, offset) {
          return offset === itemOffset ? 0 : offset < itemOffset ? -1 : 1;
        }
        function offsetPointParser(point) {
          return {
            index: point.index,
            value: point
          };
        }
        function rangesWithinOffsets(tree, startOffset, endOffset, minStartIndex = 0) {
          if (minStartIndex > 0) {
            startOffset = Math.max(startOffset, findClosestSmallerOrEqual(tree, minStartIndex, indexComparator).offset);
          }
          return arrayToRanges(findRange(tree, startOffset, endOffset, offsetComparator), offsetPointParser);
        }
        function createOffsetTree(prevOffsetTree, syncStart, sizeTree, gap) {
          let offsetTree = prevOffsetTree;
          let prevIndex = 0;
          let prevSize = 0;
          let prevOffset = 0;
          let startIndex = 0;
          if (syncStart !== 0) {
            startIndex = findIndexOfClosestSmallerOrEqual(offsetTree, syncStart - 1, indexComparator);
            const offsetInfo = offsetTree[startIndex];
            prevOffset = offsetInfo.offset;
            const kv = findMaxKeyValue(sizeTree, syncStart - 1);
            prevIndex = kv[0];
            prevSize = kv[1];
            if (offsetTree.length && offsetTree[startIndex].size === findMaxKeyValue(sizeTree, syncStart)[1]) {
              startIndex -= 1;
            }
            offsetTree = offsetTree.slice(0, startIndex + 1);
          } else {
            offsetTree = [];
          }
          var _iterator13 = _createForOfIteratorHelper2(rangesWithin(sizeTree, syncStart, Infinity)),
            _step13;
          try {
            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
              const _step13$value = _step13.value,
                startIndex2 = _step13$value.start,
                value = _step13$value.value;
              const indexOffset = startIndex2 - prevIndex;
              const aOffset = indexOffset * prevSize + prevOffset + indexOffset * gap;
              offsetTree.push({
                offset: aOffset,
                size: value,
                index: startIndex2
              });
              prevIndex = startIndex2;
              prevOffset = aOffset;
              prevSize = value;
            }
          } catch (err) {
            _iterator13.e(err);
          } finally {
            _iterator13.f();
          }
          return {
            offsetTree,
            lastIndex: prevIndex,
            lastOffset: prevOffset,
            lastSize: prevSize
          };
        }
        function sizeStateReducer(state, [ranges, groupIndices, log, gap]) {
          if (ranges.length > 0) {
            log("received item sizes", ranges, LogLevel.DEBUG);
          }
          const sizeTree = state.sizeTree;
          let newSizeTree = sizeTree;
          let syncStart = 0;
          if (groupIndices.length > 0 && empty(sizeTree) && ranges.length === 2) {
            const groupSize = ranges[0].size;
            const itemSize = ranges[1].size;
            newSizeTree = groupIndices.reduce((tree, groupIndex) => {
              return insert(insert(tree, groupIndex, groupSize), groupIndex + 1, itemSize);
            }, newSizeTree);
          } else {
            var _insertRanges = insertRanges(newSizeTree, ranges);
            var _insertRanges2 = _slicedToArray2(_insertRanges, 2);
            newSizeTree = _insertRanges2[0];
            syncStart = _insertRanges2[1];
          }
          if (newSizeTree === sizeTree) {
            return state;
          }
          const _createOffsetTree = createOffsetTree(state.offsetTree, syncStart, newSizeTree, gap),
            newOffsetTree = _createOffsetTree.offsetTree,
            lastIndex = _createOffsetTree.lastIndex,
            lastSize = _createOffsetTree.lastSize,
            lastOffset = _createOffsetTree.lastOffset;
          return {
            sizeTree: newSizeTree,
            offsetTree: newOffsetTree,
            lastIndex,
            lastOffset,
            lastSize,
            groupOffsetTree: groupIndices.reduce((tree, index) => {
              return insert(tree, index, offsetOf(index, newOffsetTree, gap));
            }, newTree()),
            groupIndices
          };
        }
        function offsetOf(index, tree, gap) {
          if (tree.length === 0) {
            return 0;
          }
          const _findClosestSmallerOr = findClosestSmallerOrEqual(tree, index, indexComparator),
            offset = _findClosestSmallerOr.offset,
            startIndex = _findClosestSmallerOr.index,
            size = _findClosestSmallerOr.size;
          const itemCount = index - startIndex;
          const top = size * itemCount + (itemCount - 1) * gap + offset;
          return top > 0 ? top + gap : top;
        }
        function isGroupLocation(location) {
          return typeof location.groupIndex !== "undefined";
        }
        function originalIndexFromLocation(location, sizes, lastIndex) {
          if (isGroupLocation(location)) {
            return sizes.groupIndices[location.groupIndex] + 1;
          } else {
            const numericIndex = location.index === "LAST" ? lastIndex : location.index;
            let result = originalIndexFromItemIndex(numericIndex, sizes);
            result = Math.max(0, result, Math.min(lastIndex, result));
            return result;
          }
        }
        function originalIndexFromItemIndex(itemIndex, sizes) {
          if (!hasGroups(sizes)) {
            return itemIndex;
          }
          let groupOffset = 0;
          while (sizes.groupIndices[groupOffset] <= itemIndex + groupOffset) {
            groupOffset++;
          }
          return itemIndex + groupOffset;
        }
        function hasGroups(sizes) {
          return !empty(sizes.groupOffsetTree);
        }
        function sizeTreeToRanges(sizeTree) {
          return walk(sizeTree).map(({
            k: startIndex,
            v: size
          }, index, sizeArray) => {
            const nextSize = sizeArray[index + 1];
            const endIndex = nextSize ? nextSize.k - 1 : Infinity;
            return {
              startIndex,
              endIndex,
              size
            };
          });
        }
        const SIZE_MAP = {
          offsetHeight: "height",
          offsetWidth: "width"
        };
        const sizeSystem = system(([{
          log
        }, {
          recalcInProgress
        }]) => {
          const sizeRanges = stream();
          const totalCount = stream();
          const statefulTotalCount = statefulStreamFromEmitter(totalCount, 0);
          const unshiftWith = stream();
          const shiftWith = stream();
          const firstItemIndex = statefulStream(0);
          const groupIndices = statefulStream([]);
          const fixedItemSize = statefulStream(void 0);
          const defaultItemSize = statefulStream(void 0);
          const itemSize = statefulStream((el, field) => correctItemSize(el, SIZE_MAP[field]));
          const data = statefulStream(void 0);
          const gap = statefulStream(0);
          const initial = initialSizeState();
          const sizes = statefulStreamFromEmitter(pipe(sizeRanges, withLatestFrom(groupIndices, log, gap), scan(sizeStateReducer, initial), distinctUntilChanged()), initial);
          const prevGroupIndices = statefulStreamFromEmitter(pipe(groupIndices, distinctUntilChanged(), scan((prev, curr) => ({
            prev: prev.current,
            current: curr
          }), {
            prev: [],
            current: []
          }), map$3(({
            prev
          }) => prev)), []);
          connect(pipe(groupIndices, filter(indexes => indexes.length > 0), withLatestFrom(sizes, gap), map$3(([groupIndices2, sizes2, gap2]) => {
            const groupOffsetTree = groupIndices2.reduce((tree, index, idx) => {
              return insert(tree, index, offsetOf(index, sizes2.offsetTree, gap2) || idx);
            }, newTree());
            return _objectSpread3(_objectSpread3({}, sizes2), {}, {
              groupIndices: groupIndices2,
              groupOffsetTree
            });
          })), sizes);
          connect(pipe(totalCount, withLatestFrom(sizes), filter(([totalCount2, {
            lastIndex
          }]) => {
            return totalCount2 < lastIndex;
          }), map$3(([totalCount2, {
            lastIndex,
            lastSize
          }]) => {
            return [{
              startIndex: totalCount2,
              endIndex: lastIndex,
              size: lastSize
            }];
          })), sizeRanges);
          connect(fixedItemSize, defaultItemSize);
          const trackItemSizes = statefulStreamFromEmitter(pipe(fixedItemSize, map$3(size => size === void 0)), true);
          connect(pipe(defaultItemSize, filter(value => {
            return value !== void 0 && empty(getValue$1(sizes).sizeTree);
          }), map$3(size => [{
            startIndex: 0,
            endIndex: 0,
            size
          }])), sizeRanges);
          const listRefresh = streamFromEmitter(pipe(sizeRanges, withLatestFrom(sizes), scan(({
            sizes: oldSizes
          }, [_, newSizes]) => {
            return {
              changed: newSizes !== oldSizes,
              sizes: newSizes
            };
          }, {
            changed: false,
            sizes: initial
          }), map$3(value => value.changed)));
          subscribe(pipe(firstItemIndex, scan((prev, next) => {
            return {
              diff: prev.prev - next,
              prev: next
            };
          }, {
            diff: 0,
            prev: 0
          }), map$3(val => val.diff)), offset => {
            const _getValue$ = getValue$1(sizes),
              groupIndices2 = _getValue$.groupIndices;
            if (offset > 0) {
              publish(recalcInProgress, true);
              publish(unshiftWith, offset + affectedGroupCount(offset, groupIndices2));
            } else if (offset < 0) {
              const prevGroupIndicesValue = getValue$1(prevGroupIndices);
              if (prevGroupIndicesValue.length > 0) {
                offset -= affectedGroupCount(-offset, prevGroupIndicesValue);
              }
              publish(shiftWith, offset);
            }
          });
          subscribe(pipe(firstItemIndex, withLatestFrom(log)), ([index, log2]) => {
            if (index < 0) {
              log2("`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value", {
                firstItemIndex
              }, LogLevel.ERROR);
            }
          });
          const beforeUnshiftWith = streamFromEmitter(unshiftWith);
          connect(pipe(unshiftWith, withLatestFrom(sizes), map$3(([unshiftWith2, sizes2]) => {
            const groupedMode = sizes2.groupIndices.length > 0;
            const initialRanges = [];
            const defaultSize = sizes2.lastSize;
            if (groupedMode) {
              const firstGroupSize = find(sizes2.sizeTree, 0);
              let prependedGroupItemsCount = 0;
              let groupIndex = 0;
              while (prependedGroupItemsCount < unshiftWith2) {
                const theGroupIndex = sizes2.groupIndices[groupIndex];
                const groupItemCount = sizes2.groupIndices.length === groupIndex + 1 ? Infinity : sizes2.groupIndices[groupIndex + 1] - theGroupIndex - 1;
                initialRanges.push({
                  startIndex: theGroupIndex,
                  endIndex: theGroupIndex,
                  size: firstGroupSize
                });
                initialRanges.push({
                  startIndex: theGroupIndex + 1,
                  endIndex: theGroupIndex + 1 + groupItemCount - 1,
                  size: defaultSize
                });
                groupIndex++;
                prependedGroupItemsCount += groupItemCount + 1;
              }
              const sizeTreeKV = walk(sizes2.sizeTree);
              const firstGroupIsExpanded = prependedGroupItemsCount !== unshiftWith2;
              if (firstGroupIsExpanded) {
                sizeTreeKV.shift();
              }
              return sizeTreeKV.reduce((acc, {
                k: index,
                v: size
              }) => {
                let ranges = acc.ranges;
                if (acc.prevSize !== 0) {
                  ranges = [...acc.ranges, {
                    startIndex: acc.prevIndex,
                    endIndex: index + unshiftWith2 - 1,
                    size: acc.prevSize
                  }];
                }
                return {
                  ranges,
                  prevIndex: index + unshiftWith2,
                  prevSize: size
                };
              }, {
                ranges: initialRanges,
                prevIndex: unshiftWith2,
                prevSize: 0
              }).ranges;
            }
            return walk(sizes2.sizeTree).reduce((acc, {
              k: index,
              v: size
            }) => {
              return {
                ranges: [...acc.ranges, {
                  startIndex: acc.prevIndex,
                  endIndex: index + unshiftWith2 - 1,
                  size: acc.prevSize
                }],
                prevIndex: index + unshiftWith2,
                prevSize: size
              };
            }, {
              ranges: [],
              prevIndex: 0,
              prevSize: defaultSize
            }).ranges;
          })), sizeRanges);
          const shiftWithOffset = streamFromEmitter(pipe(shiftWith, withLatestFrom(sizes, gap), map$3(([shiftWith2, {
            offsetTree
          }, gap2]) => {
            const newFirstItemIndex = -shiftWith2;
            return offsetOf(newFirstItemIndex, offsetTree, gap2);
          })));
          connect(pipe(shiftWith, withLatestFrom(sizes, gap), map$3(([shiftWith2, sizes2, gap2]) => {
            const groupedMode = sizes2.groupIndices.length > 0;
            if (groupedMode) {
              if (empty(sizes2.sizeTree)) {
                return sizes2;
              }
              let newSizeTree = newTree();
              const prevGroupIndicesValue = getValue$1(prevGroupIndices);
              let removedItemsCount = 0;
              let groupIndex = 0;
              let groupOffset = 0;
              while (removedItemsCount < -shiftWith2) {
                groupOffset = prevGroupIndicesValue[groupIndex];
                const groupItemCount = prevGroupIndicesValue[groupIndex + 1] - groupOffset - 1;
                groupIndex++;
                removedItemsCount += groupItemCount + 1;
              }
              newSizeTree = walk(sizes2.sizeTree).reduce((acc, {
                k,
                v
              }) => {
                return insert(acc, Math.max(0, k + shiftWith2), v);
              }, newSizeTree);
              const aGroupIsShrunk = removedItemsCount !== -shiftWith2;
              if (aGroupIsShrunk) {
                const firstGroupSize = find(sizes2.sizeTree, groupOffset);
                newSizeTree = insert(newSizeTree, 0, firstGroupSize);
                const nextItemSize = findMaxKeyValue(sizes2.sizeTree, -shiftWith2 + 1)[1];
                newSizeTree = insert(newSizeTree, 1, nextItemSize);
              }
              return _objectSpread3(_objectSpread3({}, sizes2), {}, {
                sizeTree: newSizeTree
              }, createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2));
            } else {
              const newSizeTree = walk(sizes2.sizeTree).reduce((acc, {
                k,
                v
              }) => {
                return insert(acc, Math.max(0, k + shiftWith2), v);
              }, newTree());
              return _objectSpread3(_objectSpread3({}, sizes2), {}, {
                sizeTree: newSizeTree
              }, createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2));
            }
          })), sizes);
          return {
            // input
            data,
            totalCount,
            sizeRanges,
            groupIndices,
            defaultItemSize,
            fixedItemSize,
            unshiftWith,
            shiftWith,
            shiftWithOffset,
            beforeUnshiftWith,
            firstItemIndex,
            gap,
            // output
            sizes,
            listRefresh,
            statefulTotalCount,
            trackItemSizes,
            itemSize
          };
        }, tup(loggerSystem, recalcSystem), {
          singleton: true
        });
        const SUPPORTS_SCROLL_TO_OPTIONS = typeof document !== "undefined" && "scrollBehavior" in document.documentElement.style;
        function normalizeIndexLocation(location) {
          const result = typeof location === "number" ? {
            index: location
          } : location;
          if (!result.align) {
            result.align = "start";
          }
          if (!result.behavior || !SUPPORTS_SCROLL_TO_OPTIONS) {
            result.behavior = "auto";
          }
          if (!result.offset) {
            result.offset = 0;
          }
          return result;
        }
        const scrollToIndexSystem = system(([{
          sizes,
          totalCount,
          listRefresh,
          gap
        }, {
          scrollingInProgress,
          viewportHeight,
          scrollTo,
          smoothScrollTargetReached,
          headerHeight,
          footerHeight,
          fixedHeaderHeight,
          fixedFooterHeight
        }, {
          log
        }]) => {
          const scrollToIndex = stream();
          const scrollTargetReached = stream();
          const topListHeight = statefulStream(0);
          let unsubscribeNextListRefresh = null;
          let cleartTimeoutRef = null;
          let unsubscribeListRefresh = null;
          function cleanup() {
            if (unsubscribeNextListRefresh) {
              unsubscribeNextListRefresh();
              unsubscribeNextListRefresh = null;
            }
            if (unsubscribeListRefresh) {
              unsubscribeListRefresh();
              unsubscribeListRefresh = null;
            }
            if (cleartTimeoutRef) {
              clearTimeout(cleartTimeoutRef);
              cleartTimeoutRef = null;
            }
            publish(scrollingInProgress, false);
          }
          connect(pipe(scrollToIndex, withLatestFrom(sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight, log), withLatestFrom(gap, fixedHeaderHeight, fixedFooterHeight), map$3(([[location, sizes2, viewportHeight2, totalCount2, topListHeight2, headerHeight2, footerHeight2, log2], gap2, fixedHeaderHeight2, fixedFooterHeight2]) => {
            const normalLocation = normalizeIndexLocation(location);
            const align = normalLocation.align,
              behavior = normalLocation.behavior,
              offset = normalLocation.offset;
            const lastIndex = totalCount2 - 1;
            const index = originalIndexFromLocation(normalLocation, sizes2, lastIndex);
            let top = offsetOf(index, sizes2.offsetTree, gap2) + headerHeight2;
            if (align === "end") {
              top += fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2;
              if (index === lastIndex) {
                top += footerHeight2;
              }
            } else if (align === "center") {
              top += (fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2) / 2;
            } else {
              top -= topListHeight2;
            }
            if (offset) {
              top += offset;
            }
            const retry = listChanged => {
              cleanup();
              if (listChanged) {
                log2("retrying to scroll to", {
                  location
                }, LogLevel.DEBUG);
                publish(scrollToIndex, location);
              } else {
                publish(scrollTargetReached, true);
                log2("list did not change, scroll successful", {}, LogLevel.DEBUG);
              }
            };
            cleanup();
            if (behavior === "smooth") {
              let listChanged = false;
              unsubscribeListRefresh = subscribe(listRefresh, changed => {
                listChanged = listChanged || changed;
              });
              unsubscribeNextListRefresh = handleNext(smoothScrollTargetReached, () => {
                retry(listChanged);
              });
            } else {
              unsubscribeNextListRefresh = handleNext(pipe(listRefresh, watchChangesFor(150)), retry);
            }
            cleartTimeoutRef = setTimeout(() => {
              cleanup();
            }, 1200);
            publish(scrollingInProgress, true);
            log2("scrolling from index to", {
              index,
              top,
              behavior
            }, LogLevel.DEBUG);
            return {
              top,
              behavior
            };
          })), scrollTo);
          return {
            scrollToIndex,
            scrollTargetReached,
            topListHeight
          };
        }, tup(sizeSystem, domIOSystem, loggerSystem), {
          singleton: true
        });
        function watchChangesFor(limit) {
          return done => {
            const timeoutRef = setTimeout(() => {
              done(false);
            }, limit);
            return value => {
              if (value) {
                done(true);
                clearTimeout(timeoutRef);
              }
            };
          };
        }
        const UP = "up";
        const DOWN = "down";
        const NONE$1 = "none";
        const INITIAL_BOTTOM_STATE = {
          atBottom: false,
          notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
          state: {
            offsetBottom: 0,
            scrollTop: 0,
            viewportHeight: 0,
            scrollHeight: 0
          }
        };
        const DEFAULT_AT_TOP_THRESHOLD = 0;
        const stateFlagsSystem = system(([{
          scrollContainerState,
          scrollTop,
          viewportHeight,
          headerHeight,
          footerHeight,
          scrollBy
        }]) => {
          const isAtBottom = statefulStream(false);
          const isAtTop = statefulStream(true);
          const atBottomStateChange = stream();
          const atTopStateChange = stream();
          const atBottomThreshold = statefulStream(4);
          const atTopThreshold = statefulStream(DEFAULT_AT_TOP_THRESHOLD);
          const isScrolling = statefulStreamFromEmitter(pipe(merge$4(pipe(duc(scrollTop), skip(1), mapTo(true)), pipe(duc(scrollTop), skip(1), mapTo(false), debounceTime(100))), distinctUntilChanged()), false);
          const isScrollingBy = statefulStreamFromEmitter(pipe(merge$4(pipe(scrollBy, mapTo(true)), pipe(scrollBy, mapTo(false), debounceTime(200))), distinctUntilChanged()), false);
          connect(pipe(combineLatest(duc(scrollTop), duc(atTopThreshold)), map$3(([top, atTopThreshold2]) => top <= atTopThreshold2), distinctUntilChanged()), isAtTop);
          connect(pipe(isAtTop, throttleTime(50)), atTopStateChange);
          const atBottomState = streamFromEmitter(pipe(combineLatest(scrollContainerState, duc(viewportHeight), duc(headerHeight), duc(footerHeight), duc(atBottomThreshold)), scan((current, [{
            scrollTop: scrollTop2,
            scrollHeight
          }, viewportHeight2, _headerHeight, _footerHeight, atBottomThreshold2]) => {
            const isAtBottom2 = scrollTop2 + viewportHeight2 - scrollHeight > -atBottomThreshold2;
            const state = {
              viewportHeight: viewportHeight2,
              scrollTop: scrollTop2,
              scrollHeight
            };
            if (isAtBottom2) {
              let atBottomBecause;
              let scrollTopDelta;
              if (scrollTop2 > current.state.scrollTop) {
                atBottomBecause = "SCROLLED_DOWN";
                scrollTopDelta = current.state.scrollTop - scrollTop2;
              } else {
                atBottomBecause = "SIZE_DECREASED";
                scrollTopDelta = current.state.scrollTop - scrollTop2 || current.scrollTopDelta;
              }
              return {
                atBottom: true,
                state,
                atBottomBecause,
                scrollTopDelta
              };
            }
            let notAtBottomBecause;
            if (state.scrollHeight > current.state.scrollHeight) {
              notAtBottomBecause = "SIZE_INCREASED";
            } else if (viewportHeight2 < current.state.viewportHeight) {
              notAtBottomBecause = "VIEWPORT_HEIGHT_DECREASING";
            } else if (scrollTop2 < current.state.scrollTop) {
              notAtBottomBecause = "SCROLLING_UPWARDS";
            } else {
              notAtBottomBecause = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM";
            }
            return {
              atBottom: false,
              notAtBottomBecause,
              state
            };
          }, INITIAL_BOTTOM_STATE), distinctUntilChanged((prev, next) => {
            return prev && prev.atBottom === next.atBottom;
          })));
          const lastJumpDueToItemResize = statefulStreamFromEmitter(pipe(scrollContainerState, scan((current, {
            scrollTop: scrollTop2,
            scrollHeight,
            viewportHeight: viewportHeight2
          }) => {
            if (!approximatelyEqual(current.scrollHeight, scrollHeight)) {
              const atBottom = scrollHeight - (scrollTop2 + viewportHeight2) < 1;
              if (current.scrollTop !== scrollTop2 && atBottom) {
                return {
                  scrollHeight,
                  scrollTop: scrollTop2,
                  jump: current.scrollTop - scrollTop2,
                  changed: true
                };
              } else {
                return {
                  scrollHeight,
                  scrollTop: scrollTop2,
                  jump: 0,
                  changed: true
                };
              }
            } else {
              return {
                scrollTop: scrollTop2,
                scrollHeight,
                jump: 0,
                changed: false
              };
            }
          }, {
            scrollHeight: 0,
            jump: 0,
            scrollTop: 0,
            changed: false
          }), filter(value => value.changed), map$3(value => value.jump)), 0);
          connect(pipe(atBottomState, map$3(state => state.atBottom)), isAtBottom);
          connect(pipe(isAtBottom, throttleTime(50)), atBottomStateChange);
          const scrollDirection = statefulStream(DOWN);
          connect(pipe(scrollContainerState, map$3(({
            scrollTop: scrollTop2
          }) => scrollTop2), distinctUntilChanged(), scan((acc, scrollTop2) => {
            if (getValue$1(isScrollingBy)) {
              return {
                direction: acc.direction,
                prevScrollTop: scrollTop2
              };
            }
            return {
              direction: scrollTop2 < acc.prevScrollTop ? UP : DOWN,
              prevScrollTop: scrollTop2
            };
          }, {
            direction: DOWN,
            prevScrollTop: 0
          }), map$3(value => value.direction)), scrollDirection);
          connect(pipe(scrollContainerState, throttleTime(50), mapTo(NONE$1)), scrollDirection);
          const scrollVelocity = statefulStream(0);
          connect(pipe(isScrolling, filter(value => !value),
          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
          mapTo(0)), scrollVelocity);
          connect(pipe(scrollTop, throttleTime(100), withLatestFrom(isScrolling), filter(([_, isScrolling2]) => !!isScrolling2), scan(([_, prev], [next]) => [prev, next], [0, 0]), map$3(([prev, next]) => next - prev)), scrollVelocity);
          return {
            isScrolling,
            isAtTop,
            isAtBottom,
            atBottomState,
            atTopStateChange,
            atBottomStateChange,
            scrollDirection,
            atBottomThreshold,
            atTopThreshold,
            scrollVelocity,
            lastJumpDueToItemResize
          };
        }, tup(domIOSystem));
        const propsReadySystem = system(([{
          log
        }]) => {
          const propsReady = statefulStream(false);
          const didMount = streamFromEmitter(pipe(propsReady, filter(ready => ready), distinctUntilChanged()));
          subscribe(propsReady, value => {
            value && getValue$1(log)("props updated", {}, LogLevel.DEBUG);
          });
          return {
            propsReady,
            didMount
          };
        }, tup(loggerSystem), {
          singleton: true
        });
        function skipFrames(frameCount, callback) {
          if (frameCount == 0) {
            callback();
          } else {
            requestAnimationFrame(() => skipFrames(frameCount - 1, callback));
          }
        }
        function getInitialTopMostItemIndexNumber(location, totalCount) {
          const lastIndex = totalCount - 1;
          const index = typeof location === "number" ? location : location.index === "LAST" ? lastIndex : location.index;
          return index;
        }
        const initialTopMostItemIndexSystem = system(([{
          sizes,
          listRefresh,
          defaultItemSize
        }, {
          scrollTop
        }, {
          scrollToIndex,
          scrollTargetReached
        }, {
          didMount
        }]) => {
          const scrolledToInitialItem = statefulStream(true);
          const initialTopMostItemIndex = statefulStream(0);
          const initialItemFinalLocationReached = statefulStream(true);
          connect(pipe(didMount, withLatestFrom(initialTopMostItemIndex), filter(([_, location]) => !!location), mapTo(false)), scrolledToInitialItem);
          connect(pipe(didMount, withLatestFrom(initialTopMostItemIndex), filter(([_, location]) => !!location), mapTo(false)), initialItemFinalLocationReached);
          subscribe(pipe(combineLatest(listRefresh, didMount), withLatestFrom(scrolledToInitialItem, sizes, defaultItemSize, initialItemFinalLocationReached), filter(([[, didMount2], scrolledToInitialItem2, {
            sizeTree
          }, defaultItemSize2, scrollScheduled]) => {
            return didMount2 && (!empty(sizeTree) || isDefined(defaultItemSize2)) && !scrolledToInitialItem2 && !scrollScheduled;
          }), withLatestFrom(initialTopMostItemIndex)), ([, initialTopMostItemIndex2]) => {
            handleNext(scrollTargetReached, () => {
              publish(initialItemFinalLocationReached, true);
            });
            skipFrames(4, () => {
              handleNext(scrollTop, () => {
                publish(scrolledToInitialItem, true);
              });
              publish(scrollToIndex, initialTopMostItemIndex2);
            });
          });
          return {
            scrolledToInitialItem,
            initialTopMostItemIndex,
            initialItemFinalLocationReached
          };
        }, tup(sizeSystem, domIOSystem, scrollToIndexSystem, propsReadySystem), {
          singleton: true
        });
        function normalizeFollowOutput(follow) {
          if (!follow) {
            return false;
          }
          return follow === "smooth" ? "smooth" : "auto";
        }
        const behaviorFromFollowOutput = (follow, isAtBottom) => {
          if (typeof follow === "function") {
            return normalizeFollowOutput(follow(isAtBottom));
          }
          return isAtBottom && normalizeFollowOutput(follow);
        };
        const followOutputSystem = system(([{
          totalCount,
          listRefresh
        }, {
          isAtBottom,
          atBottomState
        }, {
          scrollToIndex
        }, {
          scrolledToInitialItem
        }, {
          propsReady,
          didMount
        }, {
          log
        }, {
          scrollingInProgress
        }]) => {
          const followOutput = statefulStream(false);
          const autoscrollToBottom = stream();
          let pendingScrollHandle = null;
          function scrollToBottom(followOutputBehavior) {
            publish(scrollToIndex, {
              index: "LAST",
              align: "end",
              behavior: followOutputBehavior
            });
          }
          subscribe(pipe(combineLatest(pipe(duc(totalCount), skip(1)), didMount), withLatestFrom(duc(followOutput), isAtBottom, scrolledToInitialItem, scrollingInProgress), map$3(([[totalCount2, didMount2], followOutput2, isAtBottom2, scrolledToInitialItem2, scrollingInProgress2]) => {
            let shouldFollow = didMount2 && scrolledToInitialItem2;
            let followOutputBehavior = "auto";
            if (shouldFollow) {
              followOutputBehavior = behaviorFromFollowOutput(followOutput2, isAtBottom2 || scrollingInProgress2);
              shouldFollow = shouldFollow && !!followOutputBehavior;
            }
            return {
              totalCount: totalCount2,
              shouldFollow,
              followOutputBehavior
            };
          }), filter(({
            shouldFollow
          }) => shouldFollow)), ({
            totalCount: totalCount2,
            followOutputBehavior
          }) => {
            if (pendingScrollHandle) {
              pendingScrollHandle();
              pendingScrollHandle = null;
            }
            pendingScrollHandle = handleNext(listRefresh, () => {
              getValue$1(log)("following output to ", {
                totalCount: totalCount2
              }, LogLevel.DEBUG);
              scrollToBottom(followOutputBehavior);
              pendingScrollHandle = null;
            });
          });
          function trapNextSizeIncrease(followOutput2) {
            const cancel = handleNext(atBottomState, state => {
              if (followOutput2 && !state.atBottom && state.notAtBottomBecause === "SIZE_INCREASED" && !pendingScrollHandle) {
                getValue$1(log)("scrolling to bottom due to increased size", {}, LogLevel.DEBUG);
                scrollToBottom("auto");
              }
            });
            setTimeout(cancel, 100);
          }
          subscribe(pipe(combineLatest(duc(followOutput), totalCount, propsReady), filter(([follow,, ready]) => follow && ready), scan(({
            value
          }, [, next]) => {
            return {
              refreshed: value === next,
              value: next
            };
          }, {
            refreshed: false,
            value: 0
          }), filter(({
            refreshed
          }) => refreshed), withLatestFrom(followOutput, totalCount)), ([, followOutput2]) => {
            if (getValue$1(scrolledToInitialItem)) {
              trapNextSizeIncrease(followOutput2 !== false);
            }
          });
          subscribe(autoscrollToBottom, () => {
            trapNextSizeIncrease(getValue$1(followOutput) !== false);
          });
          subscribe(combineLatest(duc(followOutput), atBottomState), ([followOutput2, state]) => {
            if (followOutput2 && !state.atBottom && state.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING") {
              scrollToBottom("auto");
            }
          });
          return {
            followOutput,
            autoscrollToBottom
          };
        }, tup(sizeSystem, stateFlagsSystem, scrollToIndexSystem, initialTopMostItemIndexSystem, propsReadySystem, loggerSystem, domIOSystem));
        function groupCountsToIndicesAndCount(counts) {
          return counts.reduce((acc, groupCount) => {
            acc.groupIndices.push(acc.totalCount);
            acc.totalCount += groupCount + 1;
            return acc;
          }, {
            totalCount: 0,
            groupIndices: []
          });
        }
        const groupedListSystem = system(([{
          totalCount,
          groupIndices,
          sizes
        }, {
          scrollTop,
          headerHeight
        }]) => {
          const groupCounts = stream();
          const topItemsIndexes = stream();
          const groupIndicesAndCount = streamFromEmitter(pipe(groupCounts, map$3(groupCountsToIndicesAndCount)));
          connect(pipe(groupIndicesAndCount, map$3(value => value.totalCount)), totalCount);
          connect(pipe(groupIndicesAndCount, map$3(value => value.groupIndices)), groupIndices);
          connect(pipe(combineLatest(scrollTop, sizes, headerHeight), filter(([_, sizes2]) => hasGroups(sizes2)), map$3(([scrollTop2, state, headerHeight2]) => findMaxKeyValue(state.groupOffsetTree, Math.max(scrollTop2 - headerHeight2, 0), "v")[0]), distinctUntilChanged(), map$3(index => [index])), topItemsIndexes);
          return {
            groupCounts,
            topItemsIndexes
          };
        }, tup(sizeSystem, domIOSystem));
        function tupleComparator(prev, current) {
          return !!(prev && prev[0] === current[0] && prev[1] === current[1]);
        }
        function rangeComparator(prev, next) {
          return !!(prev && prev.startIndex === next.startIndex && prev.endIndex === next.endIndex);
        }
        const TOP = "top";
        const BOTTOM = "bottom";
        const NONE = "none";
        function getOverscan(overscan, end, direction) {
          if (typeof overscan === "number") {
            return direction === UP && end === TOP || direction === DOWN && end === BOTTOM ? overscan : 0;
          } else {
            if (direction === UP) {
              return end === TOP ? overscan.main : overscan.reverse;
            } else {
              return end === BOTTOM ? overscan.main : overscan.reverse;
            }
          }
        }
        function getViewportIncrease(value, end) {
          return typeof value === "number" ? value : value[end] || 0;
        }
        const sizeRangeSystem = system(([{
          scrollTop,
          viewportHeight,
          deviation,
          headerHeight,
          fixedHeaderHeight
        }]) => {
          const listBoundary = stream();
          const topListHeight = statefulStream(0);
          const increaseViewportBy = statefulStream(0);
          const overscan = statefulStream(0);
          const visibleRange = statefulStreamFromEmitter(pipe(combineLatest(duc(scrollTop), duc(viewportHeight), duc(headerHeight), duc(listBoundary, tupleComparator), duc(overscan), duc(topListHeight), duc(fixedHeaderHeight), duc(deviation), duc(increaseViewportBy)), map$3(([scrollTop2, viewportHeight2, headerHeight2, [listTop, listBottom], overscan2, topListHeight2, fixedHeaderHeight2, deviation2, increaseViewportBy2]) => {
            const top = scrollTop2 - deviation2;
            const stickyHeaderHeight = topListHeight2 + fixedHeaderHeight2;
            const headerVisible = Math.max(headerHeight2 - top, 0);
            let direction = NONE;
            const topViewportAddition = getViewportIncrease(increaseViewportBy2, TOP);
            const bottomViewportAddition = getViewportIncrease(increaseViewportBy2, BOTTOM);
            listTop -= deviation2;
            listTop += headerHeight2 + fixedHeaderHeight2;
            listBottom += headerHeight2 + fixedHeaderHeight2;
            listBottom -= deviation2;
            if (listTop > scrollTop2 + stickyHeaderHeight - topViewportAddition) {
              direction = UP;
            }
            if (listBottom < scrollTop2 - headerVisible + viewportHeight2 + bottomViewportAddition) {
              direction = DOWN;
            }
            if (direction !== NONE) {
              return [Math.max(top - headerHeight2 - getOverscan(overscan2, TOP, direction) - topViewportAddition, 0), top - headerVisible - fixedHeaderHeight2 + viewportHeight2 + getOverscan(overscan2, BOTTOM, direction) + bottomViewportAddition];
            }
            return null;
          }), filter(value => value != null), distinctUntilChanged(tupleComparator)), [0, 0]);
          return {
            // input
            listBoundary,
            overscan,
            topListHeight,
            increaseViewportBy,
            // output
            visibleRange
          };
        }, tup(domIOSystem), {
          singleton: true
        });
        function probeItemSet(index, sizes, data) {
          if (hasGroups(sizes)) {
            const itemIndex = originalIndexFromItemIndex(index, sizes);
            const groupIndex = findMaxKeyValue(sizes.groupOffsetTree, itemIndex)[0];
            return [{
              index: groupIndex,
              size: 0,
              offset: 0
            }, {
              index: itemIndex,
              size: 0,
              offset: 0,
              data: data && data[0]
            }];
          }
          return [{
            index,
            size: 0,
            offset: 0,
            data: data && data[0]
          }];
        }
        const EMPTY_LIST_STATE = {
          items: [],
          topItems: [],
          offsetTop: 0,
          offsetBottom: 0,
          top: 0,
          bottom: 0,
          topListHeight: 0,
          totalCount: 0,
          firstItemIndex: 0
        };
        function transposeItems(items, sizes, firstItemIndex) {
          if (items.length === 0) {
            return [];
          }
          if (!hasGroups(sizes)) {
            return items.map(item => _objectSpread3(_objectSpread3({}, item), {}, {
              index: item.index + firstItemIndex,
              originalIndex: item.index
            }));
          }
          const startIndex = items[0].index;
          const endIndex = items[items.length - 1].index;
          const transposedItems = [];
          const groupRanges = rangesWithin(sizes.groupOffsetTree, startIndex, endIndex);
          let currentRange = void 0;
          let currentGroupIndex = 0;
          var _iterator14 = _createForOfIteratorHelper2(items),
            _step14;
          try {
            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
              const item = _step14.value;
              if (!currentRange || currentRange.end < item.index) {
                currentRange = groupRanges.shift();
                currentGroupIndex = sizes.groupIndices.indexOf(currentRange.start);
              }
              let transposedItem;
              if (item.index === currentRange.start) {
                transposedItem = {
                  type: "group",
                  index: currentGroupIndex
                };
              } else {
                transposedItem = {
                  index: item.index - (currentGroupIndex + 1) + firstItemIndex,
                  groupIndex: currentGroupIndex
                };
              }
              transposedItems.push(_objectSpread3(_objectSpread3({}, transposedItem), {}, {
                size: item.size,
                offset: item.offset,
                originalIndex: item.index,
                data: item.data
              }));
            }
          } catch (err) {
            _iterator14.e(err);
          } finally {
            _iterator14.f();
          }
          return transposedItems;
        }
        function buildListState(items, topItems, totalCount, gap, sizes, firstItemIndex) {
          const lastSize = sizes.lastSize,
            lastOffset = sizes.lastOffset,
            lastIndex = sizes.lastIndex;
          let offsetTop = 0;
          let bottom = 0;
          if (items.length > 0) {
            offsetTop = items[0].offset;
            const lastItem = items[items.length - 1];
            bottom = lastItem.offset + lastItem.size;
          }
          const itemCount = totalCount - lastIndex;
          const total = lastOffset + itemCount * lastSize + (itemCount - 1) * gap;
          const top = offsetTop;
          const offsetBottom = total - bottom;
          return {
            items: transposeItems(items, sizes, firstItemIndex),
            topItems: transposeItems(topItems, sizes, firstItemIndex),
            topListHeight: topItems.reduce((height, item) => item.size + height, 0),
            offsetTop,
            offsetBottom,
            top,
            bottom,
            totalCount,
            firstItemIndex
          };
        }
        function buildListStateFromItemCount(itemCount, initialTopMostItemIndex, sizes, firstItemIndex, gap, data) {
          let includedGroupsCount = 0;
          if (sizes.groupIndices.length > 0) {
            var _iterator15 = _createForOfIteratorHelper2(sizes.groupIndices),
              _step15;
            try {
              for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                const index = _step15.value;
                if (index - includedGroupsCount >= itemCount) {
                  break;
                }
                includedGroupsCount++;
              }
            } catch (err) {
              _iterator15.e(err);
            } finally {
              _iterator15.f();
            }
          }
          const adjustedCount = itemCount + includedGroupsCount;
          const initialTopMostItemIndexNumber = getInitialTopMostItemIndexNumber(initialTopMostItemIndex, adjustedCount);
          const items = Array.from({
            length: adjustedCount
          }).map((_, index) => ({
            index: index + initialTopMostItemIndexNumber,
            size: 0,
            offset: 0,
            data: data[index + initialTopMostItemIndexNumber]
          }));
          return buildListState(items, [], adjustedCount, gap, sizes, firstItemIndex);
        }
        const listStateSystem = system(([{
          sizes,
          totalCount,
          data,
          firstItemIndex,
          gap
        }, groupedListSystem2, {
          visibleRange,
          listBoundary,
          topListHeight: rangeTopListHeight
        }, {
          scrolledToInitialItem,
          initialTopMostItemIndex
        }, {
          topListHeight
        }, stateFlags, {
          didMount
        }, {
          recalcInProgress
        }]) => {
          const topItemsIndexes = statefulStream([]);
          const initialItemCount = statefulStream(0);
          const itemsRendered = stream();
          connect(groupedListSystem2.topItemsIndexes, topItemsIndexes);
          const listState = statefulStreamFromEmitter(pipe(combineLatest(didMount, recalcInProgress, duc(visibleRange, tupleComparator), duc(totalCount), duc(sizes), duc(initialTopMostItemIndex), scrolledToInitialItem, duc(topItemsIndexes), duc(firstItemIndex), duc(gap), data), filter(([mount, recalcInProgress2,, totalCount2,,,,,,, data2]) => {
            const dataChangeInProgress = data2 && data2.length !== totalCount2;
            return mount && !recalcInProgress2 && !dataChangeInProgress;
          }), map$3(([,, [startOffset, endOffset], totalCount2, sizes2, initialTopMostItemIndex2, scrolledToInitialItem2, topItemsIndexes2, firstItemIndex2, gap2, data2]) => {
            const sizesValue = sizes2;
            const sizeTree = sizesValue.sizeTree,
              offsetTree = sizesValue.offsetTree;
            const initialItemCountValue = getValue$1(initialItemCount);
            if (totalCount2 === 0) {
              return _objectSpread3(_objectSpread3({}, EMPTY_LIST_STATE), {}, {
                totalCount: totalCount2
              });
            }
            if (startOffset === 0 && endOffset === 0) {
              if (initialItemCountValue === 0) {
                return _objectSpread3(_objectSpread3({}, EMPTY_LIST_STATE), {}, {
                  totalCount: totalCount2
                });
              } else {
                return buildListStateFromItemCount(initialItemCountValue, initialTopMostItemIndex2, sizes2, firstItemIndex2, gap2, data2 || []);
              }
            }
            if (empty(sizeTree)) {
              if (initialItemCountValue > 0) {
                return null;
              }
              const state = buildListState(probeItemSet(getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2), sizesValue, data2), [], totalCount2, gap2, sizesValue, firstItemIndex2);
              return state;
            }
            const topItems = [];
            if (topItemsIndexes2.length > 0) {
              const startIndex = topItemsIndexes2[0];
              const endIndex = topItemsIndexes2[topItemsIndexes2.length - 1];
              let offset = 0;
              var _iterator16 = _createForOfIteratorHelper2(rangesWithin(sizeTree, startIndex, endIndex)),
                _step16;
              try {
                for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                  const range = _step16.value;
                  const size = range.value;
                  const rangeStartIndex = Math.max(range.start, startIndex);
                  const rangeEndIndex = Math.min(range.end, endIndex);
                  for (let i = rangeStartIndex; i <= rangeEndIndex; i++) {
                    topItems.push({
                      index: i,
                      size,
                      offset,
                      data: data2 && data2[i]
                    });
                    offset += size;
                  }
                }
              } catch (err) {
                _iterator16.e(err);
              } finally {
                _iterator16.f();
              }
            }
            if (!scrolledToInitialItem2) {
              return buildListState([], topItems, totalCount2, gap2, sizesValue, firstItemIndex2);
            }
            const minStartIndex = topItemsIndexes2.length > 0 ? topItemsIndexes2[topItemsIndexes2.length - 1] + 1 : 0;
            const offsetPointRanges = rangesWithinOffsets(offsetTree, startOffset, endOffset, minStartIndex);
            if (offsetPointRanges.length === 0) {
              return null;
            }
            const maxIndex = totalCount2 - 1;
            const items = tap([], result => {
              var _iterator17 = _createForOfIteratorHelper2(offsetPointRanges),
                _step17;
              try {
                for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                  const range = _step17.value;
                  const point = range.value;
                  let offset = point.offset;
                  let rangeStartIndex = range.start;
                  const size = point.size;
                  if (point.offset < startOffset) {
                    rangeStartIndex += Math.floor((startOffset - point.offset + gap2) / (size + gap2));
                    const itemCount = rangeStartIndex - range.start;
                    offset += itemCount * size + itemCount * gap2;
                  }
                  if (rangeStartIndex < minStartIndex) {
                    offset += (minStartIndex - rangeStartIndex) * size;
                    rangeStartIndex = minStartIndex;
                  }
                  const endIndex = Math.min(range.end, maxIndex);
                  for (let i = rangeStartIndex; i <= endIndex; i++) {
                    if (offset >= endOffset) {
                      break;
                    }
                    result.push({
                      index: i,
                      size,
                      offset,
                      data: data2 && data2[i]
                    });
                    offset += size + gap2;
                  }
                }
              } catch (err) {
                _iterator17.e(err);
              } finally {
                _iterator17.f();
              }
            });
            return buildListState(items, topItems, totalCount2, gap2, sizesValue, firstItemIndex2);
          }),
          //@ts-expect-error filter needs to be fixed
          filter(value => value !== null), distinctUntilChanged()), EMPTY_LIST_STATE);
          connect(pipe(data, filter(isDefined), map$3(data2 => data2 == null ? void 0 : data2.length)), totalCount);
          connect(pipe(listState, map$3(value => value.topListHeight)), topListHeight);
          connect(topListHeight, rangeTopListHeight);
          connect(pipe(listState, map$3(state => [state.top, state.bottom])), listBoundary);
          connect(pipe(listState, map$3(state => state.items)), itemsRendered);
          const endReached = streamFromEmitter(pipe(listState, filter(({
            items
          }) => items.length > 0), withLatestFrom(totalCount, data), filter(([{
            items
          }, totalCount2]) => items[items.length - 1].originalIndex === totalCount2 - 1), map$3(([, totalCount2, data2]) => [totalCount2 - 1, data2]), distinctUntilChanged(tupleComparator), map$3(([count]) => count)));
          const startReached = streamFromEmitter(pipe(listState, throttleTime(200), filter(({
            items,
            topItems
          }) => {
            return items.length > 0 && items[0].originalIndex === topItems.length;
          }), map$3(({
            items
          }) => items[0].index), distinctUntilChanged()));
          const rangeChanged = streamFromEmitter(pipe(listState, filter(({
            items
          }) => items.length > 0), map$3(({
            items
          }) => {
            let startIndex = 0;
            let endIndex = items.length - 1;
            while (items[startIndex].type === "group" && startIndex < endIndex) {
              startIndex++;
            }
            while (items[endIndex].type === "group" && endIndex > startIndex) {
              endIndex--;
            }
            return {
              startIndex: items[startIndex].index,
              endIndex: items[endIndex].index
            };
          }), distinctUntilChanged(rangeComparator)));
          return _objectSpread3({
            listState,
            topItemsIndexes,
            endReached,
            startReached,
            rangeChanged,
            itemsRendered,
            initialItemCount
          }, stateFlags);
        }, tup(sizeSystem, groupedListSystem, sizeRangeSystem, initialTopMostItemIndexSystem, scrollToIndexSystem, stateFlagsSystem, propsReadySystem, recalcSystem), {
          singleton: true
        });
        const initialItemCountSystem = system(([{
          sizes,
          firstItemIndex,
          data,
          gap
        }, {
          initialTopMostItemIndex
        }, {
          initialItemCount,
          listState
        }, {
          didMount
        }]) => {
          connect(pipe(didMount, withLatestFrom(initialItemCount), filter(([, count]) => count !== 0), withLatestFrom(initialTopMostItemIndex, sizes, firstItemIndex, gap, data), map$3(([[, count], initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap2, data2 = []]) => {
            return buildListStateFromItemCount(count, initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap2, data2);
          })), listState);
          return {};
        }, tup(sizeSystem, initialTopMostItemIndexSystem, listStateSystem, propsReadySystem), {
          singleton: true
        });
        const scrollSeekSystem = system(([{
          scrollVelocity
        }]) => {
          const isSeeking = statefulStream(false);
          const rangeChanged = stream();
          const scrollSeekConfiguration = statefulStream(false);
          connect(pipe(scrollVelocity, withLatestFrom(scrollSeekConfiguration, isSeeking, rangeChanged), filter(([_, config]) => !!config), map$3(([speed, config, isSeeking2, range]) => {
            const exit = config.exit,
              enter = config.enter;
            if (isSeeking2) {
              if (exit(speed, range)) {
                return false;
              }
            } else {
              if (enter(speed, range)) {
                return true;
              }
            }
            return isSeeking2;
          }), distinctUntilChanged()), isSeeking);
          subscribe(pipe(combineLatest(isSeeking, scrollVelocity, rangeChanged), withLatestFrom(scrollSeekConfiguration)), ([[isSeeking2, velocity, range], config]) => isSeeking2 && config && config.change && config.change(velocity, range));
          return {
            isSeeking,
            scrollSeekConfiguration,
            scrollVelocity,
            scrollSeekRangeChanged: rangeChanged
          };
        }, tup(stateFlagsSystem), {
          singleton: true
        });
        const topItemCountSystem = system(([{
          topItemsIndexes
        }]) => {
          const topItemCount = statefulStream(0);
          connect(pipe(topItemCount, filter(length => length > 0), map$3(length => Array.from({
            length
          }).map((_, index) => index))), topItemsIndexes);
          return {
            topItemCount
          };
        }, tup(listStateSystem));
        const totalListHeightSystem = system(([{
          footerHeight,
          headerHeight,
          fixedHeaderHeight,
          fixedFooterHeight
        }, {
          listState
        }]) => {
          const totalListHeightChanged = stream();
          const totalListHeight = statefulStreamFromEmitter(pipe(combineLatest(footerHeight, fixedFooterHeight, headerHeight, fixedHeaderHeight, listState), map$3(([footerHeight2, fixedFooterHeight2, headerHeight2, fixedHeaderHeight2, listState2]) => {
            return footerHeight2 + fixedFooterHeight2 + headerHeight2 + fixedHeaderHeight2 + listState2.offsetBottom + listState2.bottom;
          })), 0);
          connect(duc(totalListHeight), totalListHeightChanged);
          return {
            totalListHeight,
            totalListHeightChanged
          };
        }, tup(domIOSystem, listStateSystem), {
          singleton: true
        });
        function simpleMemoize(func) {
          let called = false;
          let result;
          return () => {
            if (!called) {
              called = true;
              result = func();
            }
            return result;
          };
        }
        const isMobileSafari = simpleMemoize(() => {
          return /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);
        });
        const upwardScrollFixSystem = system(([{
          scrollBy,
          scrollTop,
          deviation,
          scrollingInProgress
        }, {
          isScrolling,
          isAtBottom,
          scrollDirection,
          lastJumpDueToItemResize
        }, {
          listState
        }, {
          beforeUnshiftWith,
          shiftWithOffset,
          sizes,
          gap
        }, {
          log
        }, {
          recalcInProgress
        }]) => {
          const deviationOffset = streamFromEmitter(pipe(listState, withLatestFrom(lastJumpDueToItemResize), scan(([, prevItems, prevTotalCount, prevTotalHeight], [{
            items,
            totalCount,
            bottom,
            offsetBottom
          }, lastJumpDueToItemResize2]) => {
            const totalHeight = bottom + offsetBottom;
            let newDev = 0;
            if (prevTotalCount === totalCount) {
              if (prevItems.length > 0 && items.length > 0) {
                const atStart = items[0].originalIndex === 0 && prevItems[0].originalIndex === 0;
                if (!atStart) {
                  newDev = totalHeight - prevTotalHeight;
                  if (newDev !== 0) {
                    newDev += lastJumpDueToItemResize2;
                  }
                }
              }
            }
            return [newDev, items, totalCount, totalHeight];
          }, [0, [], 0, 0]), filter(([amount]) => amount !== 0), withLatestFrom(scrollTop, scrollDirection, scrollingInProgress, isAtBottom, log, recalcInProgress), filter(([, scrollTop2, scrollDirection2, scrollingInProgress2,,, recalcInProgress2]) => {
            return !recalcInProgress2 && !scrollingInProgress2 && scrollTop2 !== 0 && scrollDirection2 === UP;
          }), map$3(([[amount],,,,, log2]) => {
            log2("Upward scrolling compensation", {
              amount
            }, LogLevel.DEBUG);
            return amount;
          })));
          function scrollByWith(offset) {
            if (offset > 0) {
              publish(scrollBy, {
                top: -offset,
                behavior: "auto"
              });
              publish(deviation, 0);
            } else {
              publish(deviation, 0);
              publish(scrollBy, {
                top: -offset,
                behavior: "auto"
              });
            }
          }
          subscribe(pipe(deviationOffset, withLatestFrom(deviation, isScrolling)), ([offset, deviationAmount, isScrolling2]) => {
            if (isScrolling2 && isMobileSafari()) {
              publish(deviation, deviationAmount - offset);
            } else {
              scrollByWith(-offset);
            }
          });
          subscribe(pipe(combineLatest(statefulStreamFromEmitter(isScrolling, false), deviation, recalcInProgress), filter(([is, deviation2, recalc]) => !is && !recalc && deviation2 !== 0), map$3(([_, deviation2]) => deviation2), throttleTime(1)), scrollByWith);
          connect(pipe(shiftWithOffset, map$3(offset => {
            return {
              top: -offset
            };
          })), scrollBy);
          subscribe(pipe(beforeUnshiftWith, withLatestFrom(sizes, gap), map$3(([offset, {
            lastSize: defaultItemSize,
            groupIndices,
            sizeTree
          }, gap2]) => {
            function getItemOffset(itemCount) {
              return itemCount * (defaultItemSize + gap2);
            }
            if (groupIndices.length === 0) {
              return getItemOffset(offset);
            } else {
              let amount = 0;
              const defaultGroupSize = find(sizeTree, 0);
              let recognizedOffsetItems = 0;
              let groupIndex = 0;
              while (recognizedOffsetItems < offset) {
                recognizedOffsetItems++;
                amount += defaultGroupSize;
                let groupItemCount = groupIndices.length === groupIndex + 1 ? Infinity : groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;
                if (recognizedOffsetItems + groupItemCount > offset) {
                  amount -= defaultGroupSize;
                  groupItemCount = offset - recognizedOffsetItems + 1;
                }
                recognizedOffsetItems += groupItemCount;
                amount += getItemOffset(groupItemCount);
                groupIndex++;
              }
              return amount;
            }
          })), offset => {
            publish(deviation, offset);
            requestAnimationFrame(() => {
              publish(scrollBy, {
                top: offset
              });
              requestAnimationFrame(() => {
                publish(deviation, 0);
                publish(recalcInProgress, false);
              });
            });
          });
          return {
            deviation
          };
        }, tup(domIOSystem, stateFlagsSystem, listStateSystem, sizeSystem, loggerSystem, recalcSystem));
        const initialScrollTopSystem = system(([{
          didMount
        }, {
          scrollTo
        }, {
          listState
        }]) => {
          const initialScrollTop = statefulStream(0);
          subscribe(pipe(didMount, withLatestFrom(initialScrollTop), filter(([, offset]) => offset !== 0), map$3(([, offset]) => ({
            top: offset
          }))), location => {
            handleNext(pipe(listState, skip(1), filter(state => state.items.length > 1)), () => {
              requestAnimationFrame(() => {
                publish(scrollTo, location);
              });
            });
          });
          return {
            initialScrollTop
          };
        }, tup(propsReadySystem, domIOSystem, listStateSystem), {
          singleton: true
        });
        const alignToBottomSystem = system(([{
          viewportHeight
        }, {
          totalListHeight
        }]) => {
          const alignToBottom = statefulStream(false);
          const paddingTopAddition = statefulStreamFromEmitter(pipe(combineLatest(alignToBottom, viewportHeight, totalListHeight), filter(([enabled]) => enabled), map$3(([, viewportHeight2, totalListHeight2]) => {
            return Math.max(0, viewportHeight2 - totalListHeight2);
          }), throttleTime(0), distinctUntilChanged()), 0);
          return {
            alignToBottom,
            paddingTopAddition
          };
        }, tup(domIOSystem, totalListHeightSystem), {
          singleton: true
        });
        const windowScrollerSystem = system(([{
          scrollTo,
          scrollContainerState
        }]) => {
          const windowScrollContainerState = stream();
          const windowViewportRect = stream();
          const windowScrollTo = stream();
          const useWindowScroll = statefulStream(false);
          const customScrollParent = statefulStream(void 0);
          connect(pipe(combineLatest(windowScrollContainerState, windowViewportRect), map$3(([{
            viewportHeight,
            scrollTop: windowScrollTop,
            scrollHeight
          }, {
            offsetTop
          }]) => {
            return {
              scrollTop: Math.max(0, windowScrollTop - offsetTop),
              scrollHeight,
              viewportHeight
            };
          })), scrollContainerState);
          connect(pipe(scrollTo, withLatestFrom(windowViewportRect), map$3(([scrollTo2, {
            offsetTop
          }]) => {
            return _objectSpread3(_objectSpread3({}, scrollTo2), {}, {
              top: scrollTo2.top + offsetTop
            });
          })), windowScrollTo);
          return {
            // config
            useWindowScroll,
            customScrollParent,
            // input
            windowScrollContainerState,
            windowViewportRect,
            // signals
            windowScrollTo
          };
        }, tup(domIOSystem));
        const defaultCalculateViewLocation = _ref30 => {
          let itemTop2 = _ref30.itemTop,
            itemBottom = _ref30.itemBottom,
            viewportTop = _ref30.viewportTop,
            viewportBottom = _ref30.viewportBottom,
            _ref30$locationParams = _ref30.locationParams,
            behavior = _ref30$locationParams.behavior,
            align = _ref30$locationParams.align,
            rest = _objectWithoutProperties2(_ref30$locationParams, _excluded6);
          if (itemTop2 < viewportTop) {
            return _objectSpread3(_objectSpread3({}, rest), {}, {
              behavior,
              align: align != null ? align : "start"
            });
          }
          if (itemBottom > viewportBottom) {
            return _objectSpread3(_objectSpread3({}, rest), {}, {
              behavior,
              align: align != null ? align : "end"
            });
          }
          return null;
        };
        const scrollIntoViewSystem = system(([{
          sizes,
          totalCount,
          gap
        }, {
          scrollTop,
          viewportHeight,
          headerHeight,
          fixedHeaderHeight,
          fixedFooterHeight,
          scrollingInProgress
        }, {
          scrollToIndex
        }]) => {
          const scrollIntoView = stream();
          connect(pipe(scrollIntoView, withLatestFrom(sizes, viewportHeight, totalCount, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollTop), withLatestFrom(gap), map$3(([[viewLocation, sizes2, viewportHeight2, totalCount2, headerHeight2, fixedHeaderHeight2, fixedFooterHeight2, scrollTop2], gap2]) => {
            const done = viewLocation.done,
              behavior = viewLocation.behavior,
              align = viewLocation.align,
              _viewLocation$calcula = viewLocation.calculateViewLocation,
              calculateViewLocation = _viewLocation$calcula === void 0 ? defaultCalculateViewLocation : _viewLocation$calcula,
              rest = _objectWithoutProperties2(viewLocation, _excluded7);
            const actualIndex = originalIndexFromLocation(viewLocation, sizes2, totalCount2 - 1);
            const itemTop2 = offsetOf(actualIndex, sizes2.offsetTree, gap2) + headerHeight2 + fixedHeaderHeight2;
            const itemBottom = itemTop2 + findMaxKeyValue(sizes2.sizeTree, actualIndex)[1];
            const viewportTop = scrollTop2 + fixedHeaderHeight2;
            const viewportBottom = scrollTop2 + viewportHeight2 - fixedFooterHeight2;
            const location = calculateViewLocation({
              itemTop: itemTop2,
              itemBottom,
              viewportTop,
              viewportBottom,
              locationParams: _objectSpread3({
                behavior,
                align
              }, rest)
            });
            if (location) {
              done && handleNext(pipe(scrollingInProgress, filter(value => value === false),
              // skips the initial publish of false, and the cleanup call.
              // but if scrollingInProgress is true, we skip the initial publish.
              skip(getValue$1(scrollingInProgress) ? 1 : 2)), done);
            } else {
              done && done();
            }
            return location;
          }), filter(value => value !== null)), scrollToIndex);
          return {
            scrollIntoView
          };
        }, tup(sizeSystem, domIOSystem, scrollToIndexSystem, listStateSystem, loggerSystem), {
          singleton: true
        });
        const stateLoadSystem = system(([{
          sizes,
          sizeRanges
        }, {
          scrollTop,
          headerHeight
        }, {
          initialTopMostItemIndex
        }, {
          didMount
        }, {
          useWindowScroll,
          windowScrollContainerState,
          windowViewportRect
        }]) => {
          const getState = stream();
          const restoreStateFrom = statefulStream(void 0);
          const statefulWindowScrollContainerState = statefulStream(null);
          const statefulWindowViewportRect = statefulStream(null);
          connect(windowScrollContainerState, statefulWindowScrollContainerState);
          connect(windowViewportRect, statefulWindowViewportRect);
          subscribe(pipe(getState, withLatestFrom(sizes, scrollTop, useWindowScroll, statefulWindowScrollContainerState, statefulWindowViewportRect, headerHeight)), ([callback, sizes2, scrollTop2, useWindowScroll2, windowScrollContainerState2, windowViewportRect2, headerHeight2]) => {
            const ranges = sizeTreeToRanges(sizes2.sizeTree);
            if (useWindowScroll2 && windowScrollContainerState2 !== null && windowViewportRect2 !== null) {
              scrollTop2 = windowScrollContainerState2.scrollTop - windowViewportRect2.offsetTop;
            }
            scrollTop2 -= headerHeight2;
            callback({
              ranges,
              scrollTop: scrollTop2
            });
          });
          connect(pipe(restoreStateFrom, filter(isDefined), map$3(locationFromSnapshot)), initialTopMostItemIndex);
          connect(pipe(didMount, withLatestFrom(restoreStateFrom), filter(([, state]) => state !== void 0), distinctUntilChanged(), map$3(([, snapshot]) => {
            return snapshot.ranges;
          })), sizeRanges);
          return {
            getState,
            restoreStateFrom
          };
        }, tup(sizeSystem, domIOSystem, initialTopMostItemIndexSystem, propsReadySystem, windowScrollerSystem));
        function locationFromSnapshot(snapshot) {
          return {
            offset: snapshot.scrollTop,
            index: 0,
            align: "start"
          };
        }
        const featureGroup1System = system(([sizeRange, initialItemCount, propsReady, scrollSeek, totalListHeight, initialScrollTopSystem2, alignToBottom, windowScroller, scrollIntoView, logger]) => {
          return _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, sizeRange), initialItemCount), propsReady), scrollSeek), totalListHeight), initialScrollTopSystem2), alignToBottom), windowScroller), scrollIntoView), logger);
        }, tup(sizeRangeSystem, initialItemCountSystem, propsReadySystem, scrollSeekSystem, totalListHeightSystem, initialScrollTopSystem, alignToBottomSystem, windowScrollerSystem, scrollIntoViewSystem, loggerSystem));
        const listSystem = system(([{
          totalCount,
          sizeRanges,
          fixedItemSize,
          defaultItemSize,
          trackItemSizes,
          itemSize,
          data,
          firstItemIndex,
          groupIndices,
          statefulTotalCount,
          gap,
          sizes
        }, {
          initialTopMostItemIndex,
          scrolledToInitialItem,
          initialItemFinalLocationReached
        }, domIO, stateLoad, followOutput, _ref31, {
          scrollToIndex
        }, _, {
          topItemCount
        }, {
          groupCounts
        }, featureGroup1]) => {
          let listState = _ref31.listState,
            topItemsIndexes = _ref31.topItemsIndexes,
            flags = _objectWithoutProperties2(_ref31, _excluded8);
          connect(flags.rangeChanged, featureGroup1.scrollSeekRangeChanged);
          connect(pipe(featureGroup1.windowViewportRect, map$3(value => value.visibleHeight)), domIO.viewportHeight);
          return _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({
            // input
            totalCount,
            data,
            firstItemIndex,
            sizeRanges,
            initialTopMostItemIndex,
            scrolledToInitialItem,
            initialItemFinalLocationReached,
            topItemsIndexes,
            topItemCount,
            groupCounts,
            fixedItemHeight: fixedItemSize,
            defaultItemHeight: defaultItemSize,
            gap
          }, followOutput), {}, {
            // output
            statefulTotalCount,
            listState,
            scrollToIndex,
            trackItemSizes,
            itemSize,
            groupIndices
          }, flags), featureGroup1), domIO), {}, {
            sizes
          }, stateLoad);
        }, tup(sizeSystem, initialTopMostItemIndexSystem, domIOSystem, stateLoadSystem, followOutputSystem, listStateSystem, scrollToIndexSystem, upwardScrollFixSystem, topItemCountSystem, groupedListSystem, featureGroup1System));
        const WEBKIT_STICKY = "-webkit-sticky";
        const STICKY = "sticky";
        const positionStickyCssValue = simpleMemoize(() => {
          if (typeof document === "undefined") {
            return STICKY;
          }
          const node = document.createElement("div");
          node.style.position = WEBKIT_STICKY;
          return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY;
        });
        function useWindowViewportRectRef(callback, customScrollParent, skipAnimationFrame) {
          const viewportInfo = React.useRef(null);
          const calculateInfo = React.useCallback(element => {
            if (element === null || !element.offsetParent) {
              return;
            }
            const rect = element.getBoundingClientRect();
            const visibleWidth = rect.width;
            let visibleHeight, offsetTop;
            if (customScrollParent) {
              const customScrollParentRect = customScrollParent.getBoundingClientRect();
              const deltaTop = rect.top - customScrollParentRect.top;
              visibleHeight = customScrollParentRect.height - Math.max(0, deltaTop);
              offsetTop = deltaTop + customScrollParent.scrollTop;
            } else {
              visibleHeight = window.innerHeight - Math.max(0, rect.top);
              offsetTop = rect.top + window.pageYOffset;
            }
            viewportInfo.current = {
              offsetTop,
              visibleHeight,
              visibleWidth
            };
            callback(viewportInfo.current);
          }, [callback, customScrollParent]);
          const _useSizeWithElRef = useSizeWithElRef(calculateInfo, true, skipAnimationFrame),
            callbackRef = _useSizeWithElRef.callbackRef,
            ref = _useSizeWithElRef.ref;
          const scrollAndResizeEventHandler = React.useCallback(() => {
            calculateInfo(ref.current);
          }, [calculateInfo, ref]);
          React.useEffect(() => {
            if (customScrollParent) {
              customScrollParent.addEventListener("scroll", scrollAndResizeEventHandler);
              const observer = new ResizeObserver(() => {
                requestAnimationFrame(scrollAndResizeEventHandler);
              });
              observer.observe(customScrollParent);
              return () => {
                customScrollParent.removeEventListener("scroll", scrollAndResizeEventHandler);
                observer.unobserve(customScrollParent);
              };
            } else {
              window.addEventListener("scroll", scrollAndResizeEventHandler);
              window.addEventListener("resize", scrollAndResizeEventHandler);
              return () => {
                window.removeEventListener("scroll", scrollAndResizeEventHandler);
                window.removeEventListener("resize", scrollAndResizeEventHandler);
              };
            }
          }, [scrollAndResizeEventHandler, customScrollParent]);
          return callbackRef;
        }
        const VirtuosoMockContext = React.createContext(void 0);
        const VirtuosoGridMockContext = React.createContext(void 0);
        function identity$6(value) {
          return value;
        }
        const listComponentPropsSystem = /* @__PURE__ */system(() => {
          const itemContent = statefulStream(index => `Item ${index}`);
          const context = statefulStream(null);
          const groupContent = statefulStream(index => `Group ${index}`);
          const components = statefulStream({});
          const computeItemKey = statefulStream(identity$6);
          const HeaderFooterTag = statefulStream("div");
          const scrollerRef = statefulStream(noop$1);
          const distinctProp = (propName, defaultValue = null) => {
            return statefulStreamFromEmitter(pipe(components, map$3(components2 => components2[propName]), distinctUntilChanged()), defaultValue);
          };
          return {
            context,
            itemContent,
            groupContent,
            components,
            computeItemKey,
            HeaderFooterTag,
            scrollerRef,
            FooterComponent: distinctProp("Footer"),
            HeaderComponent: distinctProp("Header"),
            TopItemListComponent: distinctProp("TopItemList"),
            ListComponent: distinctProp("List", "div"),
            ItemComponent: distinctProp("Item", "div"),
            GroupComponent: distinctProp("Group", "div"),
            ScrollerComponent: distinctProp("Scroller", "div"),
            EmptyPlaceholder: distinctProp("EmptyPlaceholder"),
            ScrollSeekPlaceholder: distinctProp("ScrollSeekPlaceholder")
          };
        });
        const combinedSystem$2 = /* @__PURE__ */system(([listSystem2, propsSystem]) => {
          return _objectSpread3(_objectSpread3({}, listSystem2), propsSystem);
        }, tup(listSystem, listComponentPropsSystem));
        const DefaultScrollSeekPlaceholder$1 = ({
          height
        }) => /* @__PURE__ */jsxRuntimeExports.jsx("div", {
          style: {
            height
          }
        });
        const GROUP_STYLE = {
          position: positionStickyCssValue(),
          zIndex: 1,
          overflowAnchor: "none"
        };
        const ITEM_STYLE$1 = {
          overflowAnchor: "none"
        };
        const HORIZONTAL_ITEM_STYLE = _objectSpread3(_objectSpread3({}, ITEM_STYLE$1), {}, {
          display: "inline-block",
          height: "100%"
        });
        const Items$1 = /* @__PURE__ */React.memo(function VirtuosoItems({
          showTopList = false
        }) {
          const listState = useEmitterValue$2("listState");
          const sizeRanges = usePublisher$2("sizeRanges");
          const useWindowScroll = useEmitterValue$2("useWindowScroll");
          const customScrollParent = useEmitterValue$2("customScrollParent");
          const windowScrollContainerStateCallback = usePublisher$2("windowScrollContainerState");
          const _scrollContainerStateCallback = usePublisher$2("scrollContainerState");
          const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;
          const itemContent = useEmitterValue$2("itemContent");
          const context = useEmitterValue$2("context");
          const groupContent = useEmitterValue$2("groupContent");
          const trackItemSizes = useEmitterValue$2("trackItemSizes");
          const itemSize = useEmitterValue$2("itemSize");
          const log = useEmitterValue$2("log");
          const listGap = usePublisher$2("gap");
          const horizontalDirection = useEmitterValue$2("horizontalDirection");
          const _useChangedListConten = useChangedListContentsSizes(sizeRanges, itemSize, trackItemSizes, showTopList ? noop$1 : scrollContainerStateCallback, log, listGap, customScrollParent, horizontalDirection, useEmitterValue$2("skipAnimationFrameInResizeObserver")),
            callbackRef = _useChangedListConten.callbackRef;
          const _React$useState19 = React.useState(0),
            _React$useState20 = _slicedToArray2(_React$useState19, 2),
            deviation = _React$useState20[0],
            setDeviation = _React$useState20[1];
          useEmitter$2("deviation", value => {
            if (deviation !== value) {
              setDeviation(value);
            }
          });
          const EmptyPlaceholder = useEmitterValue$2("EmptyPlaceholder");
          const ScrollSeekPlaceholder = useEmitterValue$2("ScrollSeekPlaceholder") || DefaultScrollSeekPlaceholder$1;
          const ListComponent = useEmitterValue$2("ListComponent");
          const ItemComponent = useEmitterValue$2("ItemComponent");
          const GroupComponent = useEmitterValue$2("GroupComponent");
          const computeItemKey = useEmitterValue$2("computeItemKey");
          const isSeeking = useEmitterValue$2("isSeeking");
          const hasGroups2 = useEmitterValue$2("groupIndices").length > 0;
          const alignToBottom = useEmitterValue$2("alignToBottom");
          const initialItemFinalLocationReached = useEmitterValue$2("initialItemFinalLocationReached");
          const containerStyle = showTopList ? {} : _objectSpread3(_objectSpread3({
            boxSizing: "border-box"
          }, horizontalDirection ? {
            whiteSpace: "nowrap",
            display: "inline-block",
            height: "100%",
            paddingLeft: listState.offsetTop,
            paddingRight: listState.offsetBottom,
            marginLeft: deviation !== 0 ? deviation : alignToBottom ? "auto" : 0
          } : {
            marginTop: deviation !== 0 ? deviation : alignToBottom ? "auto" : 0,
            paddingTop: listState.offsetTop,
            paddingBottom: listState.offsetBottom
          }), initialItemFinalLocationReached ? {} : {
            visibility: "hidden"
          });
          if (!showTopList && listState.totalCount === 0 && EmptyPlaceholder) {
            return /* @__PURE__ */jsxRuntimeExports.jsx(EmptyPlaceholder, _objectSpread3({}, contextPropIfNotDomElement(EmptyPlaceholder, context)));
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(ListComponent, _objectSpread3(_objectSpread3({}, contextPropIfNotDomElement(ListComponent, context)), {}, {
            ref: callbackRef,
            style: containerStyle,
            "data-testid": showTopList ? "virtuoso-top-item-list" : "virtuoso-item-list",
            children: (showTopList ? listState.topItems : listState.items).map(item => {
              const index = item.originalIndex;
              const key = computeItemKey(index + listState.firstItemIndex, item.data, context);
              if (isSeeking) {
                return /* @__PURE__ */reactExports.createElement(ScrollSeekPlaceholder, _objectSpread3(_objectSpread3({}, contextPropIfNotDomElement(ScrollSeekPlaceholder, context)), {}, {
                  key,
                  index: item.index,
                  height: item.size,
                  type: item.type || "item"
                }, item.type === "group" ? {} : {
                  groupIndex: item.groupIndex
                }));
              }
              if (item.type === "group") {
                return /* @__PURE__ */reactExports.createElement(GroupComponent, _objectSpread3(_objectSpread3({}, contextPropIfNotDomElement(GroupComponent, context)), {}, {
                  key,
                  "data-index": index,
                  "data-known-size": item.size,
                  "data-item-index": item.index,
                  style: GROUP_STYLE
                }), groupContent(item.index, context));
              } else {
                return /* @__PURE__ */reactExports.createElement(ItemComponent, _objectSpread3(_objectSpread3(_objectSpread3({}, contextPropIfNotDomElement(ItemComponent, context)), itemPropIfNotDomElement(ItemComponent, item.data)), {}, {
                  key,
                  "data-index": index,
                  "data-known-size": item.size,
                  "data-item-index": item.index,
                  "data-item-group-index": item.groupIndex,
                  style: horizontalDirection ? HORIZONTAL_ITEM_STYLE : ITEM_STYLE$1
                }), hasGroups2 ? itemContent(item.index, item.groupIndex, item.data, context) : itemContent(item.index, item.data, context));
              }
            })
          }));
        });
        const scrollerStyle = {
          height: "100%",
          outline: "none",
          overflowY: "auto",
          position: "relative",
          WebkitOverflowScrolling: "touch"
        };
        const horizontalScrollerStyle = {
          outline: "none",
          overflowX: "auto",
          position: "relative"
        };
        const viewportStyle = alignToBottom => _objectSpread3({
          width: "100%",
          height: "100%",
          position: "absolute",
          top: 0
        }, alignToBottom ? {
          display: "flex",
          flexDirection: "column"
        } : {});
        const topItemListStyle = {
          width: "100%",
          position: positionStickyCssValue(),
          top: 0,
          zIndex: 1
        };
        function contextPropIfNotDomElement(element, context) {
          if (typeof element === "string") {
            return void 0;
          }
          return {
            context
          };
        }
        function itemPropIfNotDomElement(element, item) {
          return {
            item: typeof element === "string" ? void 0 : item
          };
        }
        const Header$1 = /* @__PURE__ */React.memo(function VirtuosoHeader() {
          const Header2 = useEmitterValue$2("HeaderComponent");
          const headerHeight = usePublisher$2("headerHeight");
          const HeaderFooterTag = useEmitterValue$2("HeaderFooterTag");
          const ref = useSize(React.useMemo(() => el => headerHeight(correctItemSize(el, "height")), [headerHeight]), true, useEmitterValue$2("skipAnimationFrameInResizeObserver"));
          const context = useEmitterValue$2("context");
          return Header2 ? /* @__PURE__ */jsxRuntimeExports.jsx(HeaderFooterTag, {
            ref,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(Header2, _objectSpread3({}, contextPropIfNotDomElement(Header2, context)))
          }) : null;
        });
        const Footer$1 = /* @__PURE__ */React.memo(function VirtuosoFooter() {
          const Footer2 = useEmitterValue$2("FooterComponent");
          const footerHeight = usePublisher$2("footerHeight");
          const HeaderFooterTag = useEmitterValue$2("HeaderFooterTag");
          const ref = useSize(React.useMemo(() => el => footerHeight(correctItemSize(el, "height")), [footerHeight]), true, useEmitterValue$2("skipAnimationFrameInResizeObserver"));
          const context = useEmitterValue$2("context");
          return Footer2 ? /* @__PURE__ */jsxRuntimeExports.jsx(HeaderFooterTag, {
            ref,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(Footer2, _objectSpread3({}, contextPropIfNotDomElement(Footer2, context)))
          }) : null;
        });
        function buildScroller({
          usePublisher: usePublisher2,
          useEmitter: useEmitter2,
          useEmitterValue: useEmitterValue2
        }) {
          const Scroller2 = React.memo(function VirtuosoScroller(_ref32) {
            let style = _ref32.style,
              children = _ref32.children,
              props = _objectWithoutProperties2(_ref32, _excluded9);
            const scrollContainerStateCallback = usePublisher2("scrollContainerState");
            const ScrollerComponent = useEmitterValue2("ScrollerComponent");
            const smoothScrollTargetReached = usePublisher2("smoothScrollTargetReached");
            const scrollerRefCallback = useEmitterValue2("scrollerRef");
            const context = useEmitterValue2("context");
            const horizontalDirection = useEmitterValue2("horizontalDirection") || false;
            const _useScrollTop = useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, ScrollerComponent, scrollerRefCallback, void 0, horizontalDirection),
              scrollerRef = _useScrollTop.scrollerRef,
              scrollByCallback = _useScrollTop.scrollByCallback,
              scrollToCallback = _useScrollTop.scrollToCallback;
            useEmitter2("scrollTo", scrollToCallback);
            useEmitter2("scrollBy", scrollByCallback);
            const defaultStyle = horizontalDirection ? horizontalScrollerStyle : scrollerStyle;
            return /* @__PURE__ */jsxRuntimeExports.jsx(ScrollerComponent, _objectSpread3(_objectSpread3(_objectSpread3({
              ref: scrollerRef,
              style: _objectSpread3(_objectSpread3({}, defaultStyle), style),
              "data-testid": "virtuoso-scroller",
              "data-virtuoso-scroller": true,
              tabIndex: 0
            }, props), contextPropIfNotDomElement(ScrollerComponent, context)), {}, {
              children
            }));
          });
          return Scroller2;
        }
        function buildWindowScroller({
          usePublisher: usePublisher2,
          useEmitter: useEmitter2,
          useEmitterValue: useEmitterValue2
        }) {
          const Scroller2 = React.memo(function VirtuosoWindowScroller(_ref33) {
            let style = _ref33.style,
              children = _ref33.children,
              props = _objectWithoutProperties2(_ref33, _excluded10);
            const scrollContainerStateCallback = usePublisher2("windowScrollContainerState");
            const ScrollerComponent = useEmitterValue2("ScrollerComponent");
            const smoothScrollTargetReached = usePublisher2("smoothScrollTargetReached");
            const totalListHeight = useEmitterValue2("totalListHeight");
            const deviation = useEmitterValue2("deviation");
            const customScrollParent = useEmitterValue2("customScrollParent");
            const context = useEmitterValue2("context");
            const _useScrollTop2 = useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, ScrollerComponent, noop$1, customScrollParent),
              scrollerRef = _useScrollTop2.scrollerRef,
              scrollByCallback = _useScrollTop2.scrollByCallback,
              scrollToCallback = _useScrollTop2.scrollToCallback;
            useIsomorphicLayoutEffect(() => {
              scrollerRef.current = customScrollParent ? customScrollParent : window;
              return () => {
                scrollerRef.current = null;
              };
            }, [scrollerRef, customScrollParent]);
            useEmitter2("windowScrollTo", scrollToCallback);
            useEmitter2("scrollBy", scrollByCallback);
            return /* @__PURE__ */jsxRuntimeExports.jsx(ScrollerComponent, _objectSpread3(_objectSpread3(_objectSpread3({
              style: _objectSpread3(_objectSpread3({
                position: "relative"
              }, style), totalListHeight !== 0 ? {
                height: totalListHeight + deviation
              } : {}),
              "data-virtuoso-scroller": true
            }, props), contextPropIfNotDomElement(ScrollerComponent, context)), {}, {
              children
            }));
          });
          return Scroller2;
        }
        const Viewport$2 = ({
          children
        }) => {
          const ctx = React.useContext(VirtuosoMockContext);
          const viewportHeight = usePublisher$2("viewportHeight");
          const fixedItemHeight = usePublisher$2("fixedItemHeight");
          const alignToBottom = useEmitterValue$2("alignToBottom");
          const horizontalDirection = useEmitterValue$2("horizontalDirection");
          const viewportSizeCallbackMemo = React.useMemo(() => compose(viewportHeight, el => correctItemSize(el, horizontalDirection ? "width" : "height")), [viewportHeight, horizontalDirection]);
          const viewportRef = useSize(viewportSizeCallbackMemo, true, useEmitterValue$2("skipAnimationFrameInResizeObserver"));
          React.useEffect(() => {
            if (ctx) {
              viewportHeight(ctx.viewportHeight);
              fixedItemHeight(ctx.itemHeight);
            }
          }, [ctx, viewportHeight, fixedItemHeight]);
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            style: viewportStyle(alignToBottom),
            ref: viewportRef,
            "data-viewport-type": "element",
            children
          });
        };
        const WindowViewport$2 = ({
          children
        }) => {
          const ctx = React.useContext(VirtuosoMockContext);
          const windowViewportRect = usePublisher$2("windowViewportRect");
          const fixedItemHeight = usePublisher$2("fixedItemHeight");
          const customScrollParent = useEmitterValue$2("customScrollParent");
          const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent, useEmitterValue$2("skipAnimationFrameInResizeObserver"));
          const alignToBottom = useEmitterValue$2("alignToBottom");
          React.useEffect(() => {
            if (ctx) {
              fixedItemHeight(ctx.itemHeight);
              windowViewportRect({
                offsetTop: 0,
                visibleHeight: ctx.viewportHeight,
                visibleWidth: 100
              });
            }
          }, [ctx, windowViewportRect, fixedItemHeight]);
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            ref: viewportRef,
            style: viewportStyle(alignToBottom),
            "data-viewport-type": "window",
            children
          });
        };
        const TopItemListContainer = ({
          children
        }) => {
          const TopItemList = useEmitterValue$2("TopItemListComponent") || "div";
          const headerHeight = useEmitterValue$2("headerHeight");
          const style = _objectSpread3(_objectSpread3({}, topItemListStyle), {}, {
            marginTop: `${headerHeight}px`
          });
          const context = useEmitterValue$2("context");
          return /* @__PURE__ */jsxRuntimeExports.jsx(TopItemList, _objectSpread3(_objectSpread3({
            style
          }, contextPropIfNotDomElement(TopItemList, context)), {}, {
            children
          }));
        };
        const ListRoot = /* @__PURE__ */React.memo(function VirtuosoRoot(props) {
          const useWindowScroll = useEmitterValue$2("useWindowScroll");
          const showTopList = useEmitterValue$2("topItemsIndexes").length > 0;
          const customScrollParent = useEmitterValue$2("customScrollParent");
          const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$2 : Scroller$2;
          const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$2 : Viewport$2;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(TheScroller, _objectSpread3(_objectSpread3({}, props), {}, {
            children: [showTopList && /* @__PURE__ */jsxRuntimeExports.jsx(TopItemListContainer, {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Items$1, {
                showTopList: true
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(TheViewport, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Header$1, {}), /* @__PURE__ */jsxRuntimeExports.jsx(Items$1, {}), /* @__PURE__ */jsxRuntimeExports.jsx(Footer$1, {})]
            })]
          }));
        });
        const _systemToComponent = /* @__PURE__ */systemToComponent(combinedSystem$2, {
            required: {},
            optional: {
              restoreStateFrom: "restoreStateFrom",
              context: "context",
              followOutput: "followOutput",
              itemContent: "itemContent",
              groupContent: "groupContent",
              overscan: "overscan",
              increaseViewportBy: "increaseViewportBy",
              totalCount: "totalCount",
              groupCounts: "groupCounts",
              topItemCount: "topItemCount",
              firstItemIndex: "firstItemIndex",
              initialTopMostItemIndex: "initialTopMostItemIndex",
              components: "components",
              atBottomThreshold: "atBottomThreshold",
              atTopThreshold: "atTopThreshold",
              computeItemKey: "computeItemKey",
              defaultItemHeight: "defaultItemHeight",
              fixedItemHeight: "fixedItemHeight",
              itemSize: "itemSize",
              scrollSeekConfiguration: "scrollSeekConfiguration",
              headerFooterTag: "HeaderFooterTag",
              data: "data",
              initialItemCount: "initialItemCount",
              initialScrollTop: "initialScrollTop",
              alignToBottom: "alignToBottom",
              useWindowScroll: "useWindowScroll",
              customScrollParent: "customScrollParent",
              scrollerRef: "scrollerRef",
              logLevel: "logLevel",
              horizontalDirection: "horizontalDirection",
              skipAnimationFrameInResizeObserver: "skipAnimationFrameInResizeObserver"
            },
            methods: {
              scrollToIndex: "scrollToIndex",
              scrollIntoView: "scrollIntoView",
              scrollTo: "scrollTo",
              scrollBy: "scrollBy",
              autoscrollToBottom: "autoscrollToBottom",
              getState: "getState"
            },
            events: {
              isScrolling: "isScrolling",
              endReached: "endReached",
              startReached: "startReached",
              rangeChanged: "rangeChanged",
              atBottomStateChange: "atBottomStateChange",
              atTopStateChange: "atTopStateChange",
              totalListHeightChanged: "totalListHeightChanged",
              itemsRendered: "itemsRendered",
              groupIndices: "groupIndices"
            }
          }, ListRoot),
          List$1 = _systemToComponent.Component,
          usePublisher$2 = _systemToComponent.usePublisher,
          useEmitterValue$2 = _systemToComponent.useEmitterValue,
          useEmitter$2 = _systemToComponent.useEmitter;
        const Scroller$2 = /* @__PURE__ */buildScroller({
          usePublisher: usePublisher$2,
          useEmitterValue: useEmitterValue$2,
          useEmitter: useEmitter$2
        });
        const WindowScroller$2 = /* @__PURE__ */buildWindowScroller({
          usePublisher: usePublisher$2,
          useEmitterValue: useEmitterValue$2,
          useEmitter: useEmitter$2
        });
        const Virtuoso = List$1;
        const INITIAL_GRID_STATE = {
          items: [],
          offsetBottom: 0,
          offsetTop: 0,
          top: 0,
          bottom: 0,
          itemHeight: 0,
          itemWidth: 0
        };
        const PROBE_GRID_STATE = {
          items: [{
            index: 0
          }],
          offsetBottom: 0,
          offsetTop: 0,
          top: 0,
          bottom: 0,
          itemHeight: 0,
          itemWidth: 0
        };
        const round$1 = Math.round,
          ceil = Math.ceil,
          floor = Math.floor,
          min$1 = Math.min,
          max$1 = Math.max;
        function buildProbeGridState(items) {
          return _objectSpread3(_objectSpread3({}, PROBE_GRID_STATE), {}, {
            items
          });
        }
        function buildItems(startIndex, endIndex, data) {
          return Array.from({
            length: endIndex - startIndex + 1
          }).map((_, i) => {
            const dataItem = data === null ? null : data[i + startIndex];
            return {
              index: i + startIndex,
              data: dataItem
            };
          });
        }
        function gapComparator(prev, next) {
          return prev && prev.column === next.column && prev.row === next.row;
        }
        function dimensionComparator(prev, next) {
          return prev && prev.width === next.width && prev.height === next.height;
        }
        const gridSystem = /* @__PURE__ */system(([{
          overscan,
          visibleRange,
          listBoundary,
          increaseViewportBy
        }, {
          scrollTop,
          viewportHeight,
          scrollBy,
          scrollTo,
          smoothScrollTargetReached,
          scrollContainerState,
          footerHeight,
          headerHeight
        }, stateFlags, scrollSeek, {
          propsReady,
          didMount
        }, {
          windowViewportRect,
          useWindowScroll,
          customScrollParent,
          windowScrollContainerState,
          windowScrollTo
        }, log]) => {
          const totalCount = statefulStream(0);
          const initialItemCount = statefulStream(0);
          const gridState = statefulStream(INITIAL_GRID_STATE);
          const viewportDimensions = statefulStream({
            height: 0,
            width: 0
          });
          const itemDimensions = statefulStream({
            height: 0,
            width: 0
          });
          const scrollToIndex = stream();
          const scrollHeight = stream();
          const deviation = statefulStream(0);
          const data = statefulStream(null);
          const gap = statefulStream({
            row: 0,
            column: 0
          });
          const stateChanged = stream();
          const restoreStateFrom = stream();
          const stateRestoreInProgress = statefulStream(false);
          const initialTopMostItemIndex = statefulStream(0);
          const scrolledToInitialItem = statefulStream(true);
          const scrollScheduled = statefulStream(false);
          const horizontalDirection = statefulStream(false);
          subscribe(pipe(didMount, withLatestFrom(initialTopMostItemIndex), filter(([_, location]) => !!location)), () => {
            publish(scrolledToInitialItem, false);
          });
          subscribe(pipe(combineLatest(didMount, scrolledToInitialItem, itemDimensions, viewportDimensions, initialTopMostItemIndex, scrollScheduled), filter(([didMount2, scrolledToInitialItem2, itemDimensions2, viewportDimensions2,, scrollScheduled2]) => {
            return didMount2 && !scrolledToInitialItem2 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0 && !scrollScheduled2;
          })), ([,,,, initialTopMostItemIndex2]) => {
            publish(scrollScheduled, true);
            skipFrames(1, () => {
              publish(scrollToIndex, initialTopMostItemIndex2);
            });
            handleNext(pipe(scrollTop), () => {
              publish(listBoundary, [0, 0]);
              publish(scrolledToInitialItem, true);
            });
          });
          connect(pipe(restoreStateFrom, filter(value => value !== void 0 && value !== null && value.scrollTop > 0), mapTo(0)), initialItemCount);
          subscribe(pipe(didMount, withLatestFrom(restoreStateFrom), filter(([, snapshot]) => snapshot !== void 0 && snapshot !== null)), ([, snapshot]) => {
            if (!snapshot) {
              return;
            }
            publish(viewportDimensions, snapshot.viewport), publish(itemDimensions, snapshot == null ? void 0 : snapshot.item);
            publish(gap, snapshot.gap);
            if (snapshot.scrollTop > 0) {
              publish(stateRestoreInProgress, true);
              handleNext(pipe(scrollTop, skip(1)), _value => {
                publish(stateRestoreInProgress, false);
              });
              publish(scrollTo, {
                top: snapshot.scrollTop
              });
            }
          });
          connect(pipe(viewportDimensions, map$3(({
            height
          }) => height)), viewportHeight);
          connect(pipe(combineLatest(duc(viewportDimensions, dimensionComparator), duc(itemDimensions, dimensionComparator), duc(gap, (prev, next) => prev && prev.column === next.column && prev.row === next.row), duc(scrollTop)), map$3(([viewport, item, gap2, scrollTop2]) => ({
            viewport,
            item,
            gap: gap2,
            scrollTop: scrollTop2
          }))), stateChanged);
          connect(pipe(combineLatest(duc(totalCount), visibleRange, duc(gap, gapComparator), duc(itemDimensions, dimensionComparator), duc(viewportDimensions, dimensionComparator), duc(data), duc(initialItemCount), duc(stateRestoreInProgress), duc(scrolledToInitialItem), duc(initialTopMostItemIndex)), filter(([,,,,,,, stateRestoreInProgress2]) => {
            return !stateRestoreInProgress2;
          }), map$3(([totalCount2, [startOffset, endOffset], gap2, item, viewport, data2, initialItemCount2,, scrolledToInitialItem2, initialTopMostItemIndex2]) => {
            const rowGap = gap2.row,
              columnGap = gap2.column;
            const itemHeight = item.height,
              itemWidth = item.width;
            const viewportWidth = viewport.width;
            if (initialItemCount2 === 0 && (totalCount2 === 0 || viewportWidth === 0)) {
              return INITIAL_GRID_STATE;
            }
            if (itemWidth === 0) {
              const startIndex2 = getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2);
              const endIndex2 = Math.max(startIndex2 + initialItemCount2 - 1, 0);
              return buildProbeGridState(buildItems(startIndex2, endIndex2, data2));
            }
            const perRow = itemsPerRow(viewportWidth, itemWidth, columnGap);
            let startIndex;
            let endIndex;
            if (!scrolledToInitialItem2) {
              startIndex = 0;
              endIndex = -1;
            } else if (startOffset === 0 && endOffset === 0 && initialItemCount2 > 0) {
              startIndex = 0;
              endIndex = initialItemCount2 - 1;
            } else {
              startIndex = perRow * floor((startOffset + rowGap) / (itemHeight + rowGap));
              endIndex = perRow * ceil((endOffset + rowGap) / (itemHeight + rowGap)) - 1;
              endIndex = min$1(totalCount2 - 1, max$1(endIndex, perRow - 1));
              startIndex = min$1(endIndex, max$1(0, startIndex));
            }
            const items = buildItems(startIndex, endIndex, data2);
            const _gridLayout = gridLayout(viewport, gap2, item, items),
              top = _gridLayout.top,
              bottom = _gridLayout.bottom;
            const rowCount = ceil(totalCount2 / perRow);
            const totalHeight = rowCount * itemHeight + (rowCount - 1) * rowGap;
            const offsetBottom = totalHeight - bottom;
            return {
              items,
              offsetTop: top,
              offsetBottom,
              top,
              bottom,
              itemHeight,
              itemWidth
            };
          })), gridState);
          connect(pipe(data, filter(data2 => data2 !== null), map$3(data2 => data2.length)), totalCount);
          connect(pipe(combineLatest(viewportDimensions, itemDimensions, gridState, gap), filter(([viewportDimensions2, itemDimensions2, {
            items
          }]) => {
            return items.length > 0 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0;
          }), map$3(([viewportDimensions2, itemDimensions2, {
            items
          }, gap2]) => {
            const _gridLayout2 = gridLayout(viewportDimensions2, gap2, itemDimensions2, items),
              top = _gridLayout2.top,
              bottom = _gridLayout2.bottom;
            return [top, bottom];
          }), distinctUntilChanged(tupleComparator)), listBoundary);
          const hasScrolled = statefulStream(false);
          connect(pipe(scrollTop, withLatestFrom(hasScrolled), map$3(([scrollTop2, hasScrolled2]) => {
            return hasScrolled2 || scrollTop2 !== 0;
          })), hasScrolled);
          const endReached = streamFromEmitter(pipe(duc(gridState), filter(({
            items
          }) => items.length > 0), withLatestFrom(totalCount, hasScrolled), filter(([{
            items
          }, totalCount2, hasScrolled2]) => hasScrolled2 && items[items.length - 1].index === totalCount2 - 1), map$3(([, totalCount2]) => totalCount2 - 1), distinctUntilChanged()));
          const startReached = streamFromEmitter(pipe(duc(gridState), filter(({
            items
          }) => {
            return items.length > 0 && items[0].index === 0;
          }),
          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
          mapTo(0), distinctUntilChanged()));
          const rangeChanged = streamFromEmitter(pipe(duc(gridState), withLatestFrom(stateRestoreInProgress), filter(([{
            items
          }, stateRestoreInProgress2]) => items.length > 0 && !stateRestoreInProgress2), map$3(([{
            items
          }]) => {
            return {
              startIndex: items[0].index,
              endIndex: items[items.length - 1].index
            };
          }), distinctUntilChanged(rangeComparator), throttleTime(0)));
          connect(rangeChanged, scrollSeek.scrollSeekRangeChanged);
          connect(pipe(scrollToIndex, withLatestFrom(viewportDimensions, itemDimensions, totalCount, gap), map$3(([location, viewportDimensions2, itemDimensions2, totalCount2, gap2]) => {
            const normalLocation = normalizeIndexLocation(location);
            const align = normalLocation.align,
              behavior = normalLocation.behavior,
              offset = normalLocation.offset;
            let index = normalLocation.index;
            if (index === "LAST") {
              index = totalCount2 - 1;
            }
            index = max$1(0, index, min$1(totalCount2 - 1, index));
            let top = itemTop(viewportDimensions2, gap2, itemDimensions2, index);
            if (align === "end") {
              top = round$1(top - viewportDimensions2.height + itemDimensions2.height);
            } else if (align === "center") {
              top = round$1(top - viewportDimensions2.height / 2 + itemDimensions2.height / 2);
            }
            if (offset) {
              top += offset;
            }
            return {
              top,
              behavior
            };
          })), scrollTo);
          const totalListHeight = statefulStreamFromEmitter(pipe(gridState, map$3(gridState2 => {
            return gridState2.offsetBottom + gridState2.bottom;
          })), 0);
          connect(pipe(windowViewportRect, map$3(viewportInfo => ({
            width: viewportInfo.visibleWidth,
            height: viewportInfo.visibleHeight
          }))), viewportDimensions);
          return _objectSpread3(_objectSpread3(_objectSpread3({
            // input
            data,
            totalCount,
            viewportDimensions,
            itemDimensions,
            scrollTop,
            scrollHeight,
            overscan,
            increaseViewportBy,
            scrollBy,
            scrollTo,
            scrollToIndex,
            smoothScrollTargetReached,
            windowViewportRect,
            windowScrollTo,
            useWindowScroll,
            customScrollParent,
            windowScrollContainerState,
            deviation,
            scrollContainerState,
            footerHeight,
            headerHeight,
            initialItemCount,
            gap,
            restoreStateFrom
          }, scrollSeek), {}, {
            initialTopMostItemIndex,
            horizontalDirection,
            // output
            gridState,
            totalListHeight
          }, stateFlags), {}, {
            startReached,
            endReached,
            rangeChanged,
            stateChanged,
            propsReady,
            stateRestoreInProgress
          }, log);
        }, tup(sizeRangeSystem, domIOSystem, stateFlagsSystem, scrollSeekSystem, propsReadySystem, windowScrollerSystem, loggerSystem));
        function gridLayout(viewport, gap, item, items) {
          const itemHeight = item.height;
          if (itemHeight === void 0 || items.length === 0) {
            return {
              top: 0,
              bottom: 0
            };
          }
          const top = itemTop(viewport, gap, item, items[0].index);
          const bottom = itemTop(viewport, gap, item, items[items.length - 1].index) + itemHeight;
          return {
            top,
            bottom
          };
        }
        function itemTop(viewport, gap, item, index) {
          const perRow = itemsPerRow(viewport.width, item.width, gap.column);
          const rowCount = floor(index / perRow);
          const top = rowCount * item.height + max$1(0, rowCount - 1) * gap.row;
          return top > 0 ? top + gap.row : top;
        }
        function itemsPerRow(viewportWidth, itemWidth, gap) {
          return max$1(1, floor((viewportWidth + gap) / (floor(itemWidth) + gap)));
        }
        const gridComponentPropsSystem = /* @__PURE__ */system(() => {
          const itemContent = statefulStream(index => `Item ${index}`);
          const components = statefulStream({});
          const context = statefulStream(null);
          const itemClassName = statefulStream("virtuoso-grid-item");
          const listClassName = statefulStream("virtuoso-grid-list");
          const computeItemKey = statefulStream(identity$6);
          const headerFooterTag = statefulStream("div");
          const scrollerRef = statefulStream(noop$1);
          const distinctProp = (propName, defaultValue = null) => {
            return statefulStreamFromEmitter(pipe(components, map$3(components2 => components2[propName]), distinctUntilChanged()), defaultValue);
          };
          const readyStateChanged = statefulStream(false);
          const reportReadyState = statefulStream(false);
          connect(duc(reportReadyState), readyStateChanged);
          return {
            readyStateChanged,
            reportReadyState,
            context,
            itemContent,
            components,
            computeItemKey,
            itemClassName,
            listClassName,
            headerFooterTag,
            scrollerRef,
            FooterComponent: distinctProp("Footer"),
            HeaderComponent: distinctProp("Header"),
            ListComponent: distinctProp("List", "div"),
            ItemComponent: distinctProp("Item", "div"),
            ScrollerComponent: distinctProp("Scroller", "div"),
            ScrollSeekPlaceholder: distinctProp("ScrollSeekPlaceholder", "div")
          };
        });
        const combinedSystem$1 = /* @__PURE__ */system(([gridSystem2, gridComponentPropsSystem2]) => {
          return _objectSpread3(_objectSpread3({}, gridSystem2), gridComponentPropsSystem2);
        }, tup(gridSystem, gridComponentPropsSystem));
        const GridItems = /* @__PURE__ */React.memo(function GridItems2() {
          const gridState = useEmitterValue$1("gridState");
          const listClassName = useEmitterValue$1("listClassName");
          const itemClassName = useEmitterValue$1("itemClassName");
          const itemContent = useEmitterValue$1("itemContent");
          const computeItemKey = useEmitterValue$1("computeItemKey");
          const isSeeking = useEmitterValue$1("isSeeking");
          const scrollHeightCallback = usePublisher$1("scrollHeight");
          const ItemComponent = useEmitterValue$1("ItemComponent");
          const ListComponent = useEmitterValue$1("ListComponent");
          const ScrollSeekPlaceholder = useEmitterValue$1("ScrollSeekPlaceholder");
          const context = useEmitterValue$1("context");
          const itemDimensions = usePublisher$1("itemDimensions");
          const gridGap = usePublisher$1("gap");
          const log = useEmitterValue$1("log");
          const stateRestoreInProgress = useEmitterValue$1("stateRestoreInProgress");
          const reportReadyState = usePublisher$1("reportReadyState");
          const listRef = useSize(React.useMemo(() => el => {
            const scrollHeight = el.parentElement.parentElement.scrollHeight;
            scrollHeightCallback(scrollHeight);
            const firstItem = el.firstChild;
            if (firstItem) {
              const _firstItem$getBoundin = firstItem.getBoundingClientRect(),
                width = _firstItem$getBoundin.width,
                height = _firstItem$getBoundin.height;
              itemDimensions({
                width,
                height
              });
            }
            gridGap({
              row: resolveGapValue("row-gap", getComputedStyle(el).rowGap, log),
              column: resolveGapValue("column-gap", getComputedStyle(el).columnGap, log)
            });
          }, [scrollHeightCallback, itemDimensions, gridGap, log]), true, false);
          useIsomorphicLayoutEffect(() => {
            if (gridState.itemHeight > 0 && gridState.itemWidth > 0) {
              reportReadyState(true);
            }
          }, [gridState]);
          if (stateRestoreInProgress) {
            return null;
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(ListComponent, _objectSpread3(_objectSpread3({
            ref: listRef,
            className: listClassName
          }, contextPropIfNotDomElement(ListComponent, context)), {}, {
            style: {
              paddingTop: gridState.offsetTop,
              paddingBottom: gridState.offsetBottom
            },
            "data-testid": "virtuoso-item-list",
            children: gridState.items.map(item => {
              const key = computeItemKey(item.index, item.data, context);
              return isSeeking ? /* @__PURE__ */jsxRuntimeExports.jsx(ScrollSeekPlaceholder, _objectSpread3(_objectSpread3({}, contextPropIfNotDomElement(ScrollSeekPlaceholder, context)), {}, {
                index: item.index,
                height: gridState.itemHeight,
                width: gridState.itemWidth
              }), key) : /* @__PURE__ */reactExports.createElement(ItemComponent, _objectSpread3(_objectSpread3({}, contextPropIfNotDomElement(ItemComponent, context)), {}, {
                className: itemClassName,
                "data-index": item.index,
                key
              }), itemContent(item.index, item.data, context));
            })
          }));
        });
        const Header = React.memo(function VirtuosoHeader2() {
          const Header2 = useEmitterValue$1("HeaderComponent");
          const headerHeight = usePublisher$1("headerHeight");
          const HeaderFooterTag = useEmitterValue$1("headerFooterTag");
          const ref = useSize(React.useMemo(() => el => headerHeight(correctItemSize(el, "height")), [headerHeight]), true, false);
          const context = useEmitterValue$1("context");
          return Header2 ? /* @__PURE__ */jsxRuntimeExports.jsx(HeaderFooterTag, {
            ref,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(Header2, _objectSpread3({}, contextPropIfNotDomElement(Header2, context)))
          }) : null;
        });
        const Footer = React.memo(function VirtuosoGridFooter() {
          const Footer2 = useEmitterValue$1("FooterComponent");
          const footerHeight = usePublisher$1("footerHeight");
          const HeaderFooterTag = useEmitterValue$1("headerFooterTag");
          const ref = useSize(React.useMemo(() => el => footerHeight(correctItemSize(el, "height")), [footerHeight]), true, false);
          const context = useEmitterValue$1("context");
          return Footer2 ? /* @__PURE__ */jsxRuntimeExports.jsx(HeaderFooterTag, {
            ref,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(Footer2, _objectSpread3({}, contextPropIfNotDomElement(Footer2, context)))
          }) : null;
        });
        const Viewport$1 = ({
          children
        }) => {
          const ctx = React.useContext(VirtuosoGridMockContext);
          const itemDimensions = usePublisher$1("itemDimensions");
          const viewportDimensions = usePublisher$1("viewportDimensions");
          const viewportRef = useSize(React.useMemo(() => el => {
            viewportDimensions(el.getBoundingClientRect());
          }, [viewportDimensions]), true, false);
          React.useEffect(() => {
            if (ctx) {
              viewportDimensions({
                height: ctx.viewportHeight,
                width: ctx.viewportWidth
              });
              itemDimensions({
                height: ctx.itemHeight,
                width: ctx.itemWidth
              });
            }
          }, [ctx, viewportDimensions, itemDimensions]);
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            style: viewportStyle(false),
            ref: viewportRef,
            children
          });
        };
        const WindowViewport$1 = ({
          children
        }) => {
          const ctx = React.useContext(VirtuosoGridMockContext);
          const windowViewportRect = usePublisher$1("windowViewportRect");
          const itemDimensions = usePublisher$1("itemDimensions");
          const customScrollParent = useEmitterValue$1("customScrollParent");
          const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent, false);
          React.useEffect(() => {
            if (ctx) {
              itemDimensions({
                height: ctx.itemHeight,
                width: ctx.itemWidth
              });
              windowViewportRect({
                offsetTop: 0,
                visibleHeight: ctx.viewportHeight,
                visibleWidth: ctx.viewportWidth
              });
            }
          }, [ctx, windowViewportRect, itemDimensions]);
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            ref: viewportRef,
            style: viewportStyle(false),
            children
          });
        };
        const GridRoot = /* @__PURE__ */React.memo(function GridRoot2(_ref34) {
          let props = Object.assign({}, (_objectDestructuringEmpty(_ref34), _ref34));
          const useWindowScroll = useEmitterValue$1("useWindowScroll");
          const customScrollParent = useEmitterValue$1("customScrollParent");
          const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$1 : Scroller$1;
          const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$1 : Viewport$1;
          return /* @__PURE__ */jsxRuntimeExports.jsx(TheScroller, _objectSpread3(_objectSpread3({}, props), {}, {
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(TheViewport, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Header, {}), /* @__PURE__ */jsxRuntimeExports.jsx(GridItems, {}), /* @__PURE__ */jsxRuntimeExports.jsx(Footer, {})]
            })
          }));
        });
        const _systemToComponent2 = /* @__PURE__ */systemToComponent(combinedSystem$1, {
            optional: {
              context: "context",
              totalCount: "totalCount",
              overscan: "overscan",
              itemContent: "itemContent",
              components: "components",
              computeItemKey: "computeItemKey",
              data: "data",
              initialItemCount: "initialItemCount",
              scrollSeekConfiguration: "scrollSeekConfiguration",
              headerFooterTag: "headerFooterTag",
              listClassName: "listClassName",
              itemClassName: "itemClassName",
              useWindowScroll: "useWindowScroll",
              customScrollParent: "customScrollParent",
              scrollerRef: "scrollerRef",
              logLevel: "logLevel",
              restoreStateFrom: "restoreStateFrom",
              initialTopMostItemIndex: "initialTopMostItemIndex",
              increaseViewportBy: "increaseViewportBy"
            },
            methods: {
              scrollTo: "scrollTo",
              scrollBy: "scrollBy",
              scrollToIndex: "scrollToIndex"
            },
            events: {
              isScrolling: "isScrolling",
              endReached: "endReached",
              startReached: "startReached",
              rangeChanged: "rangeChanged",
              atBottomStateChange: "atBottomStateChange",
              atTopStateChange: "atTopStateChange",
              stateChanged: "stateChanged",
              readyStateChanged: "readyStateChanged"
            }
          }, GridRoot),
          Grid = _systemToComponent2.Component,
          usePublisher$1 = _systemToComponent2.usePublisher,
          useEmitterValue$1 = _systemToComponent2.useEmitterValue,
          useEmitter$1 = _systemToComponent2.useEmitter;
        const Scroller$1 = /* @__PURE__ */buildScroller({
          usePublisher: usePublisher$1,
          useEmitterValue: useEmitterValue$1,
          useEmitter: useEmitter$1
        });
        const WindowScroller$1 = /* @__PURE__ */buildWindowScroller({
          usePublisher: usePublisher$1,
          useEmitterValue: useEmitterValue$1,
          useEmitter: useEmitter$1
        });
        function resolveGapValue(property, value, log) {
          if (value !== "normal" && !(value == null ? void 0 : value.endsWith("px"))) {
            log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);
          }
          if (value === "normal") {
            return 0;
          }
          return parseInt(value != null ? value : "0", 10);
        }
        function useDragNearViewportEdge(virtuosoWrapperRef) {
          const _reactExports$useStat51 = reactExports.useState(false),
            _reactExports$useStat52 = _slicedToArray2(_reactExports$useStat51, 2),
            isNearTop = _reactExports$useStat52[0],
            setIsNearTop = _reactExports$useStat52[1];
          const _reactExports$useStat53 = reactExports.useState(false),
            _reactExports$useStat54 = _slicedToArray2(_reactExports$useStat53, 2),
            isNearBottom = _reactExports$useStat54[0],
            setIsNearBottom = _reactExports$useStat54[1];
          const threshold = 50;
          const updateViewportEdgeProximity = (currentOffset, panelWidth) => {
            if (!currentOffset || !virtuosoWrapperRef.current) return;
            const wrapperBounds = virtuosoWrapperRef.current.getBoundingClientRect();
            const adjustedLeft = wrapperBounds.left + panelWidth;
            const adjustedRight = wrapperBounds.right + panelWidth;
            const isInVirtuoso = currentOffset.x >= adjustedLeft && currentOffset.x <= adjustedRight && currentOffset.y >= wrapperBounds.top && currentOffset.y <= wrapperBounds.bottom;
            if (!isInVirtuoso) {
              setIsNearTop(false);
              setIsNearBottom(false);
              return;
            }
            const distanceFromTop = currentOffset.y - wrapperBounds.top;
            const distanceFromBottom = wrapperBounds.bottom - currentOffset.y;
            setIsNearTop(distanceFromTop <= threshold);
            setIsNearBottom(distanceFromBottom <= threshold);
          };
          const _useDragLayer = useDragLayer(monitor => ({
              isDragging: monitor.isDragging(),
              currentOffset: monitor.getClientOffset()
            })),
            isDragging = _useDragLayer.isDragging,
            currentOffset = _useDragLayer.currentOffset;
          reactExports.useEffect(() => {
            const screenWidth = window.innerWidth;
            let panelWidth;
            if (screenWidth >= 1200) {
              panelWidth = 450;
            } else if (screenWidth >= 768) {
              panelWidth = 400;
            } else {
              panelWidth = 400;
            }
            if (isDragging) {
              updateViewportEdgeProximity(currentOffset, panelWidth);
            } else {
              setIsNearTop(false);
              setIsNearBottom(false);
            }
          }, [isDragging, currentOffset]);
          return {
            isNearTop,
            isNearBottom
          };
        }
        function ContentPanel({
          designMode
        }, ref) {
          const _useTranslation3 = useTranslation(["design", "run"]),
            t = _useTranslation3.t;
          const theme = useTheme();
          const inDesgin = designMode == DESIGN_SURVEY_MODE.DESIGN;
          const groups = useSelector(state => {
            var _state$designState$Su;
            return ((_state$designState$Su = state.designState["Survey"]) === null || _state$designState$Su === void 0 ? void 0 : _state$designState$Su.children) || [];
          });
          const headerImage = useSelector(state => {
            var _state$designState$Su2;
            return (_state$designState$Su2 = state.designState["Survey"]) === null || _state$designState$Su2 === void 0 || (_state$designState$Su2 = _state$designState$Su2.resources) === null || _state$designState$Su2 === void 0 ? void 0 : _state$designState$Su2.headerImage;
          });
          useSelector(state => {
            var _state$designState$Su3;
            return (_state$designState$Su3 = state.designState["Survey"]) === null || _state$designState$Su3 === void 0 || (_state$designState$Su3 = _state$designState$Su3.resources) === null || _state$designState$Su3 === void 0 ? void 0 : _state$designState$Su3.backgroundImage;
          });
          const groupsEmpty = !groups.length;
          const welcomeGroupExists = reactExports.useMemo(() => {
            let returnResult = false;
            groups === null || groups === void 0 || groups.forEach(group => {
              var _group$groupType;
              if ((group === null || group === void 0 ? void 0 : group.type) === "welcome" || ((_group$groupType = group.groupType) === null || _group$groupType === void 0 ? void 0 : _group$groupType.toLowerCase()) === "welcome") {
                returnResult = true;
              }
            });
            return returnResult;
          }, [groups]);
          const items = reactExports.useMemo(() => {
            const list = [];
            if (headerImage) {
              list.push({
                name: ELEMENTS.IMAGE
              });
            }
            if (!welcomeGroupExists) {
              list.push({
                name: ELEMENTS.DROP_AREA,
                index: 0
              });
            }
            for (let i = 0; i < groups.length; i++) {
              var _groups$i$groupType;
              list.push({
                name: ELEMENTS.GROUP,
                group: groups[i],
                index: i
              });
              if (groups[i].type !== "end" && ((_groups$i$groupType = groups[i].groupType) === null || _groups$i$groupType === void 0 ? void 0 : _groups$i$groupType.toLowerCase()) !== "end") {
                list.push({
                  name: ELEMENTS.DROP_AREA,
                  group: groups[i],
                  index: i + 1
                });
              }
            }
            list.push({
              name: ELEMENTS.FOOTER
            });
            return list;
          }, [groups, t, headerImage]);
          const virtuosoRef = reactExports.useRef(null);
          const virtuosoWrapperRef = reactExports.useRef(null);
          const _useDragNearViewportE = useDragNearViewportEdge(virtuosoWrapperRef),
            isNearBottom = _useDragNearViewportE.isNearBottom,
            isNearTop = _useDragNearViewportE.isNearTop;
          reactExports.useEffect(() => {
            let animationFrameId;
            const performScroll = () => {
              if (virtuosoRef.current) {
                if (isNearBottom) {
                  virtuosoRef.current.scrollBy({
                    top: 6,
                    behavior: "auto"
                  });
                } else if (isNearTop) {
                  virtuosoRef.current.scrollBy({
                    top: -6,
                    behavior: "auto"
                  });
                }
                animationFrameId = requestAnimationFrame(performScroll);
              }
            };
            if (isNearTop || isNearBottom) {
              animationFrameId = requestAnimationFrame(performScroll);
            }
            return () => {
              if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
              }
            };
          }, [isNearTop, isNearBottom]);
          return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
            ref,
            className: `content-panel ${styles$J.contentPanel}`,
            style: {
              backgroundColor: theme.palette.background.default,
              fontFamily: theme.textStyles.text.font,
              color: theme.textStyles.text.color,
              fontSize: theme.textStyles.text.size
            },
            children: /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
              ref: virtuosoWrapperRef,
              width: "100%",
              height: "100%",
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Virtuoso, {
                ref: virtuosoRef,
                data: items,
                className: styles$J.virtuosoStyle,
                itemContent: (index, item) => {
                  switch (item.name) {
                    case ELEMENTS.IMAGE:
                      return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                        className: styles$J.cardMediaContent,
                        children: [/* @__PURE__ */jsxRuntimeExports.jsx(CardMedia, {
                          className: styles$J.cardImage,
                          component: "img",
                          image: buildResourceUrl(headerImage),
                          height: "140"
                        }), inDesgin && /* @__PURE__ */jsxRuntimeExports.jsx(ErrorDisplay$1, {
                          code: "Survey"
                        })]
                      });
                    case ELEMENTS.DROP_AREA:
                      return /* @__PURE__ */jsxRuntimeExports.jsx(GroupDropArea, {
                        emptySurvey: groupsEmpty,
                        t,
                        index: item.index,
                        groupsCount: groups.length
                      });
                    case ELEMENTS.GROUP:
                      return /* @__PURE__ */jsxRuntimeExports.jsx(GroupDesign$1, {
                        t,
                        designMode,
                        code: item.group.code,
                        index: item.index
                      });
                    case ELEMENTS.FOOTER:
                      return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                        className: styles$J.footer
                      });
                  }
                }
              })
            })
          });
        }
        const ContentPanel$1 = React.forwardRef(ContentPanel);
        const ELEMENTS = {
          IMAGE: "IMAGE",
          GROUP: "GROUP",
          DROP_AREA: "DROP_AREA",
          FOOTER: "FOOTER"
        };
        function FieldSize({
          label,
          rule,
          t,
          defaultValue,
          code,
          lowerBound,
          upperBound
        }) {
          const dispatch = useDispatch();
          const stateValue = useSelector(state => {
            return state.designState[code][rule] || defaultValue;
          });
          const _reactExports$useStat55 = reactExports.useState(stateValue),
            _reactExports$useStat56 = _slicedToArray2(_reactExports$useStat55, 2),
            value = _reactExports$useStat56[0],
            setValue = _reactExports$useStat56[1];
          const onValueChange = event => {
            setValue(event.target.value);
            if (value >= lowerBound && value <= upperBound) {
              dispatch(changeAttribute({
                code,
                key: rule,
                value: Math.max(lowerBound, Math.min(upperBound, event.target.value))
              }));
            }
          };
          const isError = value != stateValue;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("h4", {
              children: [label, ":"]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              label,
              error: isError,
              variant: "outlined",
              type: "number",
              helperText: isError ? /* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
                t,
                values: {
                  lower_bound: lowerBound,
                  upper_bound: upperBound,
                  setup_value: stateValue,
                  label
                },
                i18nKey: "value_beyond_bounds"
              }) : null,
              size: "small",
              style: {
                maxWidth: "200px"
              },
              value,
              onChange: event => onValueChange(event)
            })]
          });
        }
        const FieldSize$1 = React.memo(FieldSize);
        const showHint = "_showHint_9iocv_1";
        const inputValue$1 = "_inputValue_9iocv_9";
        const styles$i = {
          showHint: showHint,
          inputValue: inputValue$1
        };
        function ShowHint({
          code,
          t
        }) {
          const dispatch = useDispatch();
          const showHint = useSelector(state => {
            return state.designState[code].showHint || false;
          });
          const setCheckedHint = value => {
            dispatch(changeAttribute({
              code,
              key: "showHint",
              value
            }));
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$i.showHint,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
                children: t("show_question_hint")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Switch, {
                checked: showHint,
                onChange: event => setCheckedHint(event.target.checked)
              })]
            }), showHint && /* @__PURE__ */jsxRuntimeExports.jsx(ContentEditor, {
              code,
              objectName: "hint"
            })]
          });
        }
        function ContentEditor({
          code,
          objectName,
          title
        }) {
          const dispatch = useDispatch();
          const setContentValue = (lang, value) => {
            dispatch(changeContent({
              code,
              key: objectName,
              lang,
              value
            }));
          };
          const languagesList = useSelector(state => {
            return state.designState.langInfo.languagesList;
          });
          const hintObj = useSelector(state => {
            var _state$designState$co10;
            return (_state$designState$co10 = state.designState[code].content) === null || _state$designState$co10 === void 0 ? void 0 : _state$designState$co10[objectName];
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [title && /* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              children: title
            }), languagesList.map(lang => {
              return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: styles$i.inputValue,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
                  label: lang.name,
                  variant: "standard",
                  type: "text",
                  value: (hintObj === null || hintObj === void 0 ? void 0 : hintObj[lang.code]) || "",
                  onChange: event => setContentValue(lang.code, event.target.value)
                })
              }, lang.code);
            })]
          });
        }
        const boxContainer$1 = "_boxContainer_182us_1";
        const mt10$1 = "_mt10_182us_10";
        const uppercase$1 = "_uppercase_182us_14";
        const title$5 = "_title_182us_18";
        const styles$h = {
          boxContainer: boxContainer$1,
          mt10: mt10$1,
          uppercase: uppercase$1,
          title: title$5
        };
        const boxContainer = "_boxContainer_1vhs4_1";
        const mt10 = "_mt10_1vhs4_9";
        const uppercase = "_uppercase_1vhs4_13";
        const title$4 = "_title_1vhs4_18";
        const titleContent = "_titleContent_1vhs4_28";
        const standardError = "_standardError_1vhs4_33";
        const errorWrapper = "_errorWrapper_1vhs4_44";
        const errorLabelWrapper = "_errorLabelWrapper_1vhs4_48";
        const errorItem = "_errorItem_1vhs4_52";
        const errorItemContainer = "_errorItemContainer_1vhs4_58";
        const styles$g = {
          boxContainer: boxContainer,
          mt10: mt10,
          uppercase: uppercase,
          title: title$4,
          titleContent: titleContent,
          standardError: standardError,
          errorWrapper: errorWrapper,
          errorLabelWrapper: errorLabelWrapper,
          errorItem: errorItem,
          errorItemContainer: errorItemContainer
        };
        function ValidationSetupMessage({
          validationRule,
          code,
          rule,
          t
        }) {
          const dispatch = useDispatch();
          const isCustomErrorActive = validationRule.isCustomErrorActive || false;
          const languagesList = useSelector(state => {
            return state.designState.langInfo.languagesList;
          });
          let content = validationRule.content || {};
          const checkedCustomError = checked => {
            dispatch(changeValidationValue({
              code,
              rule,
              key: "isCustomErrorActive",
              value: checked
            }));
          };
          const onContentUpdate = (key, value) => {
            const newContent = _objectSpread3(_objectSpread3({}, content), {}, {
              [key]: value
            });
            dispatch(changeValidationValue({
              code,
              rule,
              key: "content",
              value: newContent
            }));
          };
          const label = {
            inputProps: {
              "aria-label": "Switch validation"
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              children: t("standard_error")
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$g.errorWrapper,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: styles$g.errorLabelWrapper,
                children: languagesList.map(l => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                  className: `${styles$g.errorItem} ${styles$g.uppercase}`,
                  children: [l.code, ":"]
                }, l.code))
              }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                children: languagesList.map(l => /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  className: styles$g.errorItem,
                  children: t(rule, _objectSpread3({
                    ns: "run",
                    lng: l.code
                  }, validationRule))
                }, l.code))
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$g.title,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
                className: styles$g.mt10,
                children: t("custom_error")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Switch, _objectSpread3(_objectSpread3({}, label), {}, {
                checked: isCustomErrorActive,
                onChange: event => checkedCustomError(event.target.checked)
              }))]
            }), isCustomErrorActive ? /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$g.errorWrapper,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: styles$g.errorLabelWrapper,
                children: languagesList.map(l => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                  className: `${styles$g.errorItem} ${styles$g.uppercase}`,
                  children: [l.code, ":"]
                }, l.code))
              }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: styles$g.errorItemContainer,
                children: languagesList.map(l => /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  className: styles$g.errorItem,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
                    size: "small",
                    variant: "standard",
                    value: content[l.code] || "",
                    onChange: event => onContentUpdate(l.code, event.target.value)
                  })
                }, l.code))
              })]
            }) : ""]
          });
        }
        const valueValidationItems = "_valueValidationItems_1hupk_1";
        const valueValidationItemsContainer = "_valueValidationItemsContainer_1hupk_6";
        const error = "_error_1hupk_11";
        const styles$f = {
          valueValidationItems: valueValidationItems,
          valueValidationItemsContainer: valueValidationItemsContainer,
          error: error
        };
        function FileType({
          value,
          onValueChanged
        }) {
          const _useTranslation4 = useTranslation("design"),
            t = _useTranslation4.t;
          const onFileTypeChanged = e => {
            let finalValue = [...value];
            if (!e.target.checked) {
              finalValue = value.filter(el => el != e.target.name);
            } else {
              finalValue.push(e.target.name);
            }
            onValueChanged(finalValue);
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
              id: "file-type-label",
              children: t("file_type")
            }), /* @__PURE__ */jsxRuntimeExports.jsx(FormControlLabel, {
              control: /* @__PURE__ */jsxRuntimeExports.jsx(Checkbox, {
                checked: value.indexOf("presentation") > -1,
                onChange: onFileTypeChanged,
                name: "presentation"
              }),
              label: t("file_types.presentation")
            }), /* @__PURE__ */jsxRuntimeExports.jsx(FormControlLabel, {
              control: /* @__PURE__ */jsxRuntimeExports.jsx(Checkbox, {
                checked: value.indexOf("document") > -1,
                onChange: onFileTypeChanged,
                name: "document"
              }),
              label: t("file_types.document")
            }), /* @__PURE__ */jsxRuntimeExports.jsx(FormControlLabel, {
              control: /* @__PURE__ */jsxRuntimeExports.jsx(Checkbox, {
                checked: value.indexOf("spreadsheet") > -1,
                onChange: onFileTypeChanged,
                name: "spreadsheet"
              }),
              label: t("file_types.spreadsheet")
            }), /* @__PURE__ */jsxRuntimeExports.jsx(FormControlLabel, {
              control: /* @__PURE__ */jsxRuntimeExports.jsx(Checkbox, {
                checked: value.indexOf("pdf") > -1,
                onChange: onFileTypeChanged,
                name: "pdf"
              }),
              label: t("file_types.pdf")
            }), /* @__PURE__ */jsxRuntimeExports.jsx(FormControlLabel, {
              control: /* @__PURE__ */jsxRuntimeExports.jsx(Checkbox, {
                checked: value.indexOf("image") > -1,
                onChange: onFileTypeChanged,
                name: "image"
              }),
              label: t("file_types.image")
            }), /* @__PURE__ */jsxRuntimeExports.jsx(FormControlLabel, {
              control: /* @__PURE__ */jsxRuntimeExports.jsx(Checkbox, {
                checked: value.indexOf("video") > -1,
                onChange: onFileTypeChanged,
                name: "video"
              }),
              label: t("file_types.video")
            }), /* @__PURE__ */jsxRuntimeExports.jsx(FormControlLabel, {
              control: /* @__PURE__ */jsxRuntimeExports.jsx(Checkbox, {
                checked: value.indexOf("audio") > -1,
                onChange: onFileTypeChanged,
                name: "audio"
              }),
              label: t("file_types.audio")
            })]
          });
        }
        const FileType$1 = React.memo(FileType);
        function ValidationSetupValue({
          code,
          validation,
          rule,
          t
        }) {
          const childCount = useSelector(state => {
            var _state$designState$co11;
            return ((_state$designState$co11 = state.designState[code].children) === null || _state$designState$co11 === void 0 ? void 0 : _state$designState$co11.length) || 0;
          });
          const bounds = React.useMemo(() => {
            switch (rule) {
              case "validation_min_char_length":
                return [1, Number.MAX_VALUE];
              case "validation_max_file_size":
                return [1, Number.MAX_VALUE];
              case "validation_max_char_length":
                return [1, Number.MAX_VALUE];
              case "validation_max_word_count":
                return [1, Number.MAX_VALUE];
              case "validation_min_word_count":
                return [1, Number.MAX_VALUE];
              case "validation_min_ranking_count":
              case "validation_min_option_count":
              case "validation_max_ranking_count":
              case "validation_max_option_count":
              case "validation_ranking_count":
              case "validation_option_count":
                return [1, childCount];
              default:
                return void 0;
            }
          }, [childCount]);
          const dispatch = useDispatch();
          const onChange = (key, value) => {
            dispatch(changeValidationValue({
              rule,
              code,
              key,
              value
            }));
          };
          const onValuesUpdate = (key, value) => {
            onChange(key, typeof bounds === "undefined" ? value : Math.max(bounds[0], Math.min(bounds[1], value)));
          };
          let keys = validationAttributes(validation);
          const hasSubtitle = rule != "validation_required" && rule != "validation_one_response_per_col" && rule != "validation_pattern_email" && rule != "validation_file_types";
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$f.valueValidationItemsContainer,
            children: [keys && hasSubtitle && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              children: t(rule + "_subtitle")
            }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$f.valueValidationItems,
              children: rule == "validation_file_types" ? /* @__PURE__ */jsxRuntimeExports.jsx(FileType$1, {
                value: validation.fileTypes,
                onValueChanged: value => onValuesUpdate("fileTypes", value)
              }) : keys.map(i => {
                const isInError = typeof bounds !== "undefined" && (validation[i] < bounds[0] || validation[i] > bounds[1]);
                return /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
                  error: isInError,
                  value: validation[i],
                  variant: "outlined",
                  size: "small",
                  type: typeof validation[i] === "number" ? "number" : "text",
                  onChange: event => onValuesUpdate(i, typeof validation[i] === "number" ? parseInt(event.target.value) : event.target.value),
                  style: {
                    maxWidth: "150px",
                    marginLeft: "8px"
                  }
                }, i);
              })
            })]
          });
        }
        const validationAttributes = validation => {
          return Object.keys(validation).filter(el => !["content", "isActive", "isCustomErrorActive", "bounds", "fileTypes"].includes(el));
        };
        function ValidationSetupItem({
          rule,
          t,
          code
        }) {
          console.debug("ValidationSetupItem: " + code);
          const dispatch = useDispatch();
          const validationRule = useSelector(state => {
            var _state$designState$co12;
            return (_state$designState$co12 = state.designState[code]) === null || _state$designState$co12 === void 0 || (_state$designState$co12 = _state$designState$co12.validation) === null || _state$designState$co12 === void 0 ? void 0 : _state$designState$co12[rule];
          });
          const label = {
            inputProps: {
              "aria-label": "Switch validation"
            }
          };
          const isActive = (validationRule === null || validationRule === void 0 ? void 0 : validationRule.isActive) || false;
          const checkedValidationItem = checked => {
            dispatch(changeValidationValue({
              code,
              rule,
              key: "isActive",
              value: checked
            }));
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$h.title,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
                children: t(rule + "_title")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Switch, _objectSpread3(_objectSpread3({}, label), {}, {
                checked: isActive,
                onChange: event => checkedValidationItem(event.target.checked)
              }))]
            }), isActive && /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              className: styles$h.boxContainer,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(ValidationSetupValue, {
                code,
                validation: validationRule,
                rule,
                t
              }), /* @__PURE__ */jsxRuntimeExports.jsx(ValidationSetupMessage, {
                code,
                validationRule,
                rule,
                t
              })]
            })]
          });
        }
        const ValidationSetupItem$1 = React.memo(ValidationSetupItem);
        const toggleValue = "_toggleValue_1d9zg_1";
        const inputValue = "_inputValue_1d9zg_8";
        const styles$e = {
          toggleValue: toggleValue,
          inputValue: inputValue
        };
        function ToggleValue({
          label,
          code,
          rule
        }) {
          const dispatch = useDispatch();
          const value = useSelector(state => {
            return state.designState[code][rule] || false;
          });
          const _onChange = value2 => {
            dispatch(changeAttribute({
              code,
              key: rule,
              value: value2
            }));
          };
          const swithLabel = {
            inputProps: {
              "aria-label": "Switch demo"
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$e.toggleValue,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              children: label
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Switch, _objectSpread3(_objectSpread3({}, swithLabel), {}, {
              checked: value,
              onChange: event => {
                _onChange(event.target.checked);
              }
            }))]
          });
        }
        const selectValue$1 = "_selectValue_9m4tq_1";
        const styles$d = {
          selectValue: selectValue$1
        };
        function SelectValue({
          label,
          rule,
          defaultValue,
          code,
          values,
          labels
        }) {
          const dispatch = useDispatch();
          const value = useSelector(state => {
            var _state$designState$co13;
            return ((_state$designState$co13 = state.designState[code]) === null || _state$designState$co13 === void 0 ? void 0 : _state$designState$co13[rule]) || defaultValue;
          });
          const _onChange2 = value2 => {
            dispatch(changeAttribute({
              code,
              key: rule,
              value: value2
            }));
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$d.selectDate,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              children: label
            }), /* @__PURE__ */jsxRuntimeExports.jsx(FormControl, {
              variant: "standard",
              fullWidth: true,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Select, {
                id: "select-value",
                value,
                label: "Select Value",
                onChange: e => {
                  _onChange2(e.target.value);
                },
                children: values.map((element, index) => {
                  return /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                    value: element,
                    children: labels ? labels[index] : element
                  }, element);
                })
              })
            })]
          });
        }
        const selectDate = "_selectDate_1qp3e_1";
        const selectDateField = "_selectDateField_1qp3e_8";
        const styles$c = {
          selectDate: selectDate,
          selectDateField: selectDateField
        };
        function SelectDate({
          label,
          rule,
          code
        }) {
          const dispatch = useDispatch();
          const value = useSelector(state => {
            return state.designState[code][rule] || "";
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$c.selectDate,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              children: label
            }), /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              className: styles$c.selectDateField,
              variant: "standard",
              value,
              type: "date",
              onChange: event => {
                dispatch(changeAttribute({
                  code,
                  key: rule,
                  value: event.target.value
                }));
              }
            })]
          });
        }
        function _arrayLikeToArray$f(r, a) {
          (null == a || a > r.length) && (a = r.length);
          for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
          return n;
        }
        function _arrayWithHoles(r) {
          if (Array.isArray(r)) return r;
        }
        function _defineProperty$2(e, r, t) {
          return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
            value: t,
            enumerable: !0,
            configurable: !0,
            writable: !0
          }) : e[r] = t, e;
        }
        function _extends$f() {
          return _extends$f = Object.assign ? Object.assign.bind() : function (n) {
            for (var e = 1; e < arguments.length; e++) {
              var t = arguments[e];
              for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
            }
            return n;
          }, _extends$f.apply(null, arguments);
        }
        function _iterableToArrayLimit(r, l) {
          var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
          if (null != t) {
            var e,
              n,
              i,
              u,
              a = [],
              f = !0,
              o = !1;
            try {
              if (i = (t = t.call(r)).next, 0 === l) ;else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
            } catch (r) {
              o = !0, n = r;
            } finally {
              try {
                if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
              } finally {
                if (o) throw n;
              }
            }
            return a;
          }
        }
        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function ownKeys$E(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread2(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$E(Object(t), !0).forEach(function (r) {
              _defineProperty$2(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$E(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _slicedToArray(r, e) {
          return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray$f(r, e) || _nonIterableRest();
        }
        function _toPrimitive(t, r) {
          if ("object" != typeof t || !t) return t;
          var e = t[Symbol.toPrimitive];
          if (void 0 !== e) {
            var i = e.call(t, r || "default");
            if ("object" != typeof i) return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r ? String : Number)(t);
        }
        function _toPropertyKey(t) {
          var i = _toPrimitive(t, "string");
          return "symbol" == typeof i ? i : i + "";
        }
        function _unsupportedIterableToArray$f(r, a) {
          if (r) {
            if ("string" == typeof r) return _arrayLikeToArray$f(r, a);
            var t = {}.toString.call(r).slice(8, -1);
            return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$f(r, a) : void 0;
          }
        }
        var ConfirmContext = /*#__PURE__*/reactExports.createContext({
          confirmBase: function confirmBase() {
            throw new Error("Missing ConfirmProvider");
          },
          closeOnParentUnmount: function closeOnParentUnmount() {}
        });
        var ConfirmationDialog = function ConfirmationDialog(_ref) {
          var open = _ref.open,
            options = _ref.options,
            onCancel = _ref.onCancel,
            onConfirm = _ref.onConfirm,
            onClose = _ref.onClose;
          var title = options.title,
            description = options.description,
            content = options.content,
            confirmationText = options.confirmationText,
            cancellationText = options.cancellationText,
            dialogProps = options.dialogProps,
            dialogActionsProps = options.dialogActionsProps,
            confirmationButtonProps = options.confirmationButtonProps,
            cancellationButtonProps = options.cancellationButtonProps,
            titleProps = options.titleProps,
            contentProps = options.contentProps,
            allowClose = options.allowClose,
            confirmationKeyword = options.confirmationKeyword,
            confirmationKeywordTextFieldProps = options.confirmationKeywordTextFieldProps,
            hideCancelButton = options.hideCancelButton,
            buttonOrder = options.buttonOrder,
            acknowledgement = options.acknowledgement,
            acknowledgementFormControlLabelProps = options.acknowledgementFormControlLabelProps,
            acknowledgementCheckboxProps = options.acknowledgementCheckboxProps;
          var _React$useState = React.useState(""),
            _React$useState2 = _slicedToArray(_React$useState, 2),
            confirmationKeywordValue = _React$useState2[0],
            setConfirmationKeywordValue = _React$useState2[1];
          var _React$useState3 = React.useState(false),
            _React$useState4 = _slicedToArray(_React$useState3, 2),
            isAcknowledged = _React$useState4[0],
            setIsAcknowledged = _React$useState4[1];
          var confirmationButtonDisabled = Boolean(confirmationKeyword && confirmationKeywordValue !== confirmationKeyword || acknowledgement && !isAcknowledged);
          var acknowledgeCheckbox = /*#__PURE__*/React.createElement(React.Fragment, null, acknowledgement && /*#__PURE__*/React.createElement(FormControlLabel, _extends$f({}, acknowledgementFormControlLabelProps, {
            control: /*#__PURE__*/React.createElement(Checkbox, _extends$f({}, acknowledgementCheckboxProps, {
              value: isAcknowledged,
              onChange: function onChange(_, value) {
                return setIsAcknowledged(value);
              }
            })),
            label: acknowledgement
          })));
          var confirmationContent = /*#__PURE__*/React.createElement(React.Fragment, null, confirmationKeyword && /*#__PURE__*/React.createElement(TextField, _extends$f({
            onChange: function onChange(e) {
              return setConfirmationKeywordValue(e.target.value);
            },
            value: confirmationKeywordValue,
            fullWidth: true
          }, confirmationKeywordTextFieldProps)));
          var dialogActions = buttonOrder.map(function (buttonType) {
            if (buttonType === "cancel") {
              return !hideCancelButton && /*#__PURE__*/React.createElement(Button, _extends$f({
                key: "cancel"
              }, cancellationButtonProps, {
                onClick: onCancel
              }), cancellationText);
            }
            if (buttonType === "confirm") {
              return /*#__PURE__*/React.createElement(Button, _extends$f({
                key: "confirm",
                color: "primary",
                disabled: confirmationButtonDisabled
              }, confirmationButtonProps, {
                onClick: onConfirm
              }), confirmationText);
            }
            throw new Error("Supported button types are only \"confirm\" and \"cancel\", got: ".concat(buttonType));
          });
          return /*#__PURE__*/React.createElement(Dialog, _extends$f({
            fullWidth: true
          }, dialogProps, {
            open: open,
            onClose: allowClose ? onClose : null
          }), title && /*#__PURE__*/React.createElement(DialogTitle, titleProps, title), content ? /*#__PURE__*/React.createElement(DialogContent, contentProps, content, confirmationContent, acknowledgeCheckbox) : description ? /*#__PURE__*/React.createElement(DialogContent, contentProps, /*#__PURE__*/React.createElement(DialogContentText, null, description), confirmationContent, acknowledgeCheckbox) : (confirmationKeyword || acknowledgeCheckbox) && /*#__PURE__*/React.createElement(DialogContent, contentProps, confirmationContent, acknowledgeCheckbox), /*#__PURE__*/React.createElement(DialogActions, dialogActionsProps, dialogActions));
        };
        var DEFAULT_OPTIONS = {
          title: "Are you sure?",
          description: "",
          content: null,
          confirmationText: "Ok",
          cancellationText: "Cancel",
          dialogProps: {},
          dialogActionsProps: {},
          confirmationButtonProps: {},
          cancellationButtonProps: {},
          titleProps: {},
          contentProps: {},
          allowClose: true,
          confirmationKeywordTextFieldProps: {},
          hideCancelButton: false,
          buttonOrder: ["cancel", "confirm"],
          acknowledgement: false,
          acknowledgementFormControlLabelProps: {},
          acknowledgementCheckboxProps: {}
        };
        var buildOptions = function buildOptions(defaultOptions, options) {
          var dialogProps = _objectSpread2(_objectSpread2({}, defaultOptions.dialogProps || DEFAULT_OPTIONS.dialogProps), options.dialogProps || {});
          var dialogActionsProps = _objectSpread2(_objectSpread2({}, defaultOptions.dialogActionsProps || DEFAULT_OPTIONS.dialogActionsProps), options.dialogActionsProps || {});
          var confirmationButtonProps = _objectSpread2(_objectSpread2({}, defaultOptions.confirmationButtonProps || DEFAULT_OPTIONS.confirmationButtonProps), options.confirmationButtonProps || {});
          var cancellationButtonProps = _objectSpread2(_objectSpread2({}, defaultOptions.cancellationButtonProps || DEFAULT_OPTIONS.cancellationButtonProps), options.cancellationButtonProps || {});
          var titleProps = _objectSpread2(_objectSpread2({}, defaultOptions.titleProps || DEFAULT_OPTIONS.titleProps), options.titleProps || {});
          var contentProps = _objectSpread2(_objectSpread2({}, defaultOptions.contentProps || DEFAULT_OPTIONS.contentProps), options.contentProps || {});
          var confirmationKeywordTextFieldProps = _objectSpread2(_objectSpread2({}, defaultOptions.confirmationKeywordTextFieldProps || DEFAULT_OPTIONS.confirmationKeywordTextFieldProps), options.confirmationKeywordTextFieldProps || {});
          var acknowledgementFormControlLabelProps = _objectSpread2(_objectSpread2({}, defaultOptions.acknowledgementFormControlLabelProps || DEFAULT_OPTIONS.acknowledgementFormControlLabelProps), options.acknowledgementFormControlLabelProps || {});
          var acknowledgementCheckboxProps = _objectSpread2(_objectSpread2({}, defaultOptions.acknowledgementCheckboxProps || DEFAULT_OPTIONS.acknowledgementCheckboxProps), options.acknowledgementCheckboxProps || {});
          return _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_OPTIONS), defaultOptions), options), {}, {
            dialogProps: dialogProps,
            dialogActionsProps: dialogActionsProps,
            confirmationButtonProps: confirmationButtonProps,
            cancellationButtonProps: cancellationButtonProps,
            titleProps: titleProps,
            contentProps: contentProps,
            confirmationKeywordTextFieldProps: confirmationKeywordTextFieldProps,
            acknowledgementFormControlLabelProps: acknowledgementFormControlLabelProps,
            acknowledgementCheckboxProps: acknowledgementCheckboxProps
          });
        };
        var ConfirmProvider = function ConfirmProvider(_ref) {
          var children = _ref.children,
            _ref$defaultOptions = _ref.defaultOptions,
            defaultOptions = _ref$defaultOptions === void 0 ? {} : _ref$defaultOptions;
          // State that we clear on close (to avoid dangling references to resolve and
          // reject). If this is null, the dialog is closed.
          var _useState = reactExports.useState(null),
            _useState2 = _slicedToArray(_useState, 2),
            state = _useState2[0],
            setState = _useState2[1];
          // Options for rendering the dialog, which aren't reset on close so that we
          // keep rendering the same modal during close animation
          var _useState3 = reactExports.useState({}),
            _useState4 = _slicedToArray(_useState3, 2),
            options = _useState4[0],
            setOptions = _useState4[1];
          var _useState5 = reactExports.useState(0),
            _useState6 = _slicedToArray(_useState5, 2),
            key = _useState6[0],
            setKey = _useState6[1];
          var confirmBase = reactExports.useCallback(function (parentId) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            return new Promise(function (resolve, reject) {
              setKey(function (key) {
                return key + 1;
              });
              setOptions(options);
              setState({
                resolve: resolve,
                reject: reject,
                parentId: parentId
              });
            });
          }, []);
          var closeOnParentUnmount = reactExports.useCallback(function (parentId) {
            setState(function (state) {
              if (state && state.parentId === parentId) {
                return null;
              } else {
                return state;
              }
            });
          }, []);
          var handleClose = reactExports.useCallback(function () {
            setState(null);
          }, []);
          var handleCancel = reactExports.useCallback(function () {
            setState(function (state) {
              state && state.reject();
              return null;
            });
          }, []);
          var handleConfirm = reactExports.useCallback(function () {
            setState(function (state) {
              state && state.resolve();
              return null;
            });
          }, []);
          reactExports.useCallback(function (options) {
            return confirmBase("global", options);
          });
          return /*#__PURE__*/React.createElement(reactExports.Fragment, null, /*#__PURE__*/React.createElement(ConfirmContext.Provider, {
            value: {
              confirmBase: confirmBase,
              closeOnParentUnmount: closeOnParentUnmount
            }
          }, children), /*#__PURE__*/React.createElement(ConfirmationDialog, {
            key: key,
            open: state !== null,
            options: buildOptions(defaultOptions, options !== null && options !== void 0 ? options : {}),
            onClose: handleClose,
            onCancel: handleCancel,
            onConfirm: handleConfirm
          }));
        };
        var idCounter$1 = 0;
        var useConfirmId = function useConfirmId() {
          var id = reactExports.useMemo(function () {
            return idCounter$1++;
          }, []);
          return "confirm-".concat(id);
        };
        var useConfirm = function useConfirm() {
          var parentId = useConfirmId();
          var _useContext = reactExports.useContext(ConfirmContext),
            confirmBase = _useContext.confirmBase,
            closeOnParentUnmount = _useContext.closeOnParentUnmount;
          var confirm = reactExports.useCallback(function (options) {
            return confirmBase(parentId, options);
          }, [parentId]);

          // When the component calling useConfirm is unmounted, we automatically
          // close the associated confirmation dialog. Note that we use a
          // unique id per each useConfirm usage, so that we don't close the
          // dialog when an unrelated component unmounts
          reactExports.useEffect(function () {
            return function () {
              closeOnParentUnmount(parentId);
            };
          }, [parentId]);
          return confirm;
        };

        //! moment.js
        //! version : 2.30.1
        //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
        //! license : MIT
        //! momentjs.com

        var hookCallback;
        function hooks() {
          return hookCallback.apply(null, arguments);
        }

        // This is done to register the method called with moment()
        // without creating circular dependencies.
        function setHookCallback(callback) {
          hookCallback = callback;
        }
        function isArray$b(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
        }
        function isObject$h(input) {
          // IE8 will treat undefined and null as object if it wasn't for
          // input != null
          return input != null && Object.prototype.toString.call(input) === '[object Object]';
        }
        function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }
        function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
          } else {
            var k;
            for (k in obj) {
              if (hasOwnProp(obj, k)) {
                return false;
              }
            }
            return true;
          }
        }
        function isUndefined$1(input) {
          return input === void 0;
        }
        function isNumber(input) {
          return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
        }
        function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
        }
        function map$2(arr, fn) {
          var res = [],
            i,
            arrLen = arr.length;
          for (i = 0; i < arrLen; ++i) {
            res.push(fn(arr[i], i));
          }
          return res;
        }
        function extend(a, b) {
          for (var i in b) {
            if (hasOwnProp(b, i)) {
              a[i] = b[i];
            }
          }
          if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
          }
          if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
          }
          return a;
        }
        function createUTC(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, true).utc();
        }
        function defaultParsingFlags() {
          // We need to deep clone this object.
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }
        function getParsingFlags(m) {
          if (m._pf == null) {
            m._pf = defaultParsingFlags();
          }
          return m._pf;
        }
        var some;
        if (Array.prototype.some) {
          some = Array.prototype.some;
        } else {
          some = function some(fun) {
            var t = Object(this),
              len = t.length >>> 0,
              i;
            for (i = 0; i < len; i++) {
              if (i in t && fun.call(this, t[i], i, t)) {
                return true;
              }
            }
            return false;
          };
        }
        function isValid(m) {
          var flags = null,
            parsedParts = false,
            isNowValid = m._d && !isNaN(m._d.getTime());
          if (isNowValid) {
            flags = getParsingFlags(m);
            parsedParts = some.call(flags.parsedDateParts, function (i) {
              return i != null;
            });
            isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
            }
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
          return m._isValid;
        }
        function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
            extend(getParsingFlags(m), flags);
          } else {
            getParsingFlags(m).userInvalidated = true;
          }
          return m;
        }

        // Plugins that add properties should also add the key here (null value),
        // so we can properly clone ourselves.
        var momentProperties = hooks.momentProperties = [],
          updateInProgress = false;
        function copyConfig(to, from) {
          var i,
            prop,
            val,
            momentPropertiesLen = momentProperties.length;
          if (!isUndefined$1(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
          }
          if (!isUndefined$1(from._i)) {
            to._i = from._i;
          }
          if (!isUndefined$1(from._f)) {
            to._f = from._f;
          }
          if (!isUndefined$1(from._l)) {
            to._l = from._l;
          }
          if (!isUndefined$1(from._strict)) {
            to._strict = from._strict;
          }
          if (!isUndefined$1(from._tzm)) {
            to._tzm = from._tzm;
          }
          if (!isUndefined$1(from._isUTC)) {
            to._isUTC = from._isUTC;
          }
          if (!isUndefined$1(from._offset)) {
            to._offset = from._offset;
          }
          if (!isUndefined$1(from._pf)) {
            to._pf = getParsingFlags(from);
          }
          if (!isUndefined$1(from._locale)) {
            to._locale = from._locale;
          }
          if (momentPropertiesLen > 0) {
            for (i = 0; i < momentPropertiesLen; i++) {
              prop = momentProperties[i];
              val = from[prop];
              if (!isUndefined$1(val)) {
                to[prop] = val;
              }
            }
          }
          return to;
        }

        // Moment prototype object
        function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
            this._d = new Date(NaN);
          }
          // Prevent infinite loop in case updateOffset creates new moment
          // objects.
          if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
          }
        }
        function isMoment(obj) {
          return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
        }
        function warn(msg) {
          if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
          }
        }
        function deprecate(msg, fn) {
          var firstTime = true;
          return extend(function () {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
              var args = [],
                arg,
                i,
                key,
                argLen = arguments.length;
              for (i = 0; i < argLen; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                  arg += '\n[' + i + '] ';
                  for (key in arguments[0]) {
                    if (hasOwnProp(arguments[0], key)) {
                      arg += key + ': ' + arguments[0][key] + ', ';
                    }
                  }
                  arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                  arg = arguments[i];
                }
                args.push(arg);
              }
              warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
              firstTime = false;
            }
            return fn.apply(this, arguments);
          }, fn);
        }
        var deprecations = {};
        function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
          }
        }
        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;
        function isFunction$2(input) {
          return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
        }
        function set$1(config) {
          var prop, i;
          for (i in config) {
            if (hasOwnProp(config, i)) {
              prop = config[i];
              if (isFunction$2(prop)) {
                this[i] = prop;
              } else {
                this['_' + i] = prop;
              }
            }
          }
          this._config = config;
          // Lenient ordinal parsing accepts just a number in addition to
          // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
          // TODO: Remove "ordinalParse" fallback in next major release.
          this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
        }
        function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig),
            prop;
          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject$h(parentConfig[prop]) && isObject$h(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }
          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject$h(parentConfig[prop])) {
              // make sure changes to properties don't modify parent config
              res[prop] = extend({}, res[prop]);
            }
          }
          return res;
        }
        function Locale(config) {
          if (config != null) {
            this.set(config);
          }
        }
        var keys$5;
        if (Object.keys) {
          keys$5 = Object.keys;
        } else {
          keys$5 = function keys$5(obj) {
            var i,
              res = [];
            for (i in obj) {
              if (hasOwnProp(obj, i)) {
                res.push(i);
              }
            }
            return res;
          };
        }
        var defaultCalendar = {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L'
        };
        function calendar(key, mom, now) {
          var output = this._calendar[key] || this._calendar['sameElse'];
          return isFunction$2(output) ? output.call(mom, now) : output;
        }
        function zeroFill(number, targetLength, forceSign) {
          var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
          return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }
        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
          localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
          formatFunctions = {},
          formatTokenFunctions = {};

        // token:    'M'
        // padded:   ['MM', 2]
        // ordinal:  'Mo'
        // callback: function () { this.month() + 1 }
        function addFormatToken(token, padded, ordinal, callback) {
          var func = callback;
          if (typeof callback === 'string') {
            func = function func() {
              return this[callback]();
            };
          }
          if (token) {
            formatTokenFunctions[token] = func;
          }
          if (padded) {
            formatTokenFunctions[padded[0]] = function () {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }
          if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
              return this.localeData().ordinal(func.apply(this, arguments), token);
            };
          }
        }
        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
          }
          return input.replace(/\\/g, '');
        }
        function makeFormatFunction(format) {
          var array = format.match(formattingTokens),
            i,
            length;
          for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
              array[i] = formatTokenFunctions[array[i]];
            } else {
              array[i] = removeFormattingTokens(array[i]);
            }
          }
          return function (mom) {
            var output = '',
              i;
            for (i = 0; i < length; i++) {
              output += isFunction$2(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
          };
        }

        // format date using native date object
        function formatMoment(m, format) {
          if (!m.isValid()) {
            return m.localeData().invalidDate();
          }
          format = expandFormat(format, m.localeData());
          formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
          return formatFunctions[format](m);
        }
        function expandFormat(format, locale) {
          var i = 5;
          function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
          }
          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
          }
          return format;
        }
        var defaultLongDateFormat = {
          LTS: 'h:mm:ss A',
          LT: 'h:mm A',
          L: 'MM/DD/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A'
        };
        function longDateFormat(key) {
          var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];
          if (format || !formatUpper) {
            return format;
          }
          this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function (tok) {
            if (tok === 'MMMM' || tok === 'MM' || tok === 'DD' || tok === 'dddd') {
              return tok.slice(1);
            }
            return tok;
          }).join('');
          return this._longDateFormat[key];
        }
        var defaultInvalidDate = 'Invalid date';
        function invalidDate() {
          return this._invalidDate;
        }
        var defaultOrdinal = '%d',
          defaultDayOfMonthOrdinalParse = /\d{1,2}/;
        function ordinal(number) {
          return this._ordinal.replace('%d', number);
        }
        var defaultRelativeTime = {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          w: 'a week',
          ww: '%d weeks',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years'
        };
        function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction$2(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        }
        function pastFuture(diff, output) {
          var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
          return isFunction$2(format) ? format(output) : format.replace(/%s/i, output);
        }
        var aliases = {
          D: 'date',
          dates: 'date',
          date: 'date',
          d: 'day',
          days: 'day',
          day: 'day',
          e: 'weekday',
          weekdays: 'weekday',
          weekday: 'weekday',
          E: 'isoWeekday',
          isoweekdays: 'isoWeekday',
          isoweekday: 'isoWeekday',
          DDD: 'dayOfYear',
          dayofyears: 'dayOfYear',
          dayofyear: 'dayOfYear',
          h: 'hour',
          hours: 'hour',
          hour: 'hour',
          ms: 'millisecond',
          milliseconds: 'millisecond',
          millisecond: 'millisecond',
          m: 'minute',
          minutes: 'minute',
          minute: 'minute',
          M: 'month',
          months: 'month',
          month: 'month',
          Q: 'quarter',
          quarters: 'quarter',
          quarter: 'quarter',
          s: 'second',
          seconds: 'second',
          second: 'second',
          gg: 'weekYear',
          weekyears: 'weekYear',
          weekyear: 'weekYear',
          GG: 'isoWeekYear',
          isoweekyears: 'isoWeekYear',
          isoweekyear: 'isoWeekYear',
          w: 'week',
          weeks: 'week',
          week: 'week',
          W: 'isoWeek',
          isoweeks: 'isoWeek',
          isoweek: 'isoWeek',
          y: 'year',
          years: 'year',
          year: 'year'
        };
        function normalizeUnits(units) {
          return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
        }
        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {},
            normalizedProp,
            prop;
          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }
          return normalizedInput;
        }
        var priorities = {
          date: 9,
          day: 11,
          weekday: 11,
          isoWeekday: 11,
          dayOfYear: 4,
          hour: 13,
          millisecond: 16,
          minute: 14,
          month: 8,
          quarter: 7,
          second: 15,
          weekYear: 1,
          isoWeekYear: 1,
          week: 5,
          isoWeek: 5,
          year: 1
        };
        function getPrioritizedUnits(unitsObj) {
          var units = [],
            u;
          for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
              units.push({
                unit: u,
                priority: priorities[u]
              });
            }
          }
          units.sort(function (a, b) {
            return a.priority - b.priority;
          });
          return units;
        }
        var match1 = /\d/,
          //       0 - 9
          match2 = /\d\d/,
          //      00 - 99
          match3 = /\d{3}/,
          //     000 - 999
          match4 = /\d{4}/,
          //    0000 - 9999
          match6 = /[+-]?\d{6}/,
          // -999999 - 999999
          match1to2 = /\d\d?/,
          //       0 - 99
          match3to4 = /\d\d\d\d?/,
          //     999 - 9999
          match5to6 = /\d\d\d\d\d\d?/,
          //   99999 - 999999
          match1to3 = /\d{1,3}/,
          //       0 - 999
          match1to4 = /\d{1,4}/,
          //       0 - 9999
          match1to6 = /[+-]?\d{1,6}/,
          // -999999 - 999999
          matchUnsigned = /\d+/,
          //       0 - inf
          matchSigned = /[+-]?\d+/,
          //    -inf - inf
          matchOffset = /Z|[+-]\d\d:?\d\d/gi,
          // +00:00 -00:00 +0000 -0000 or Z
          matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
          // +00 -00 +00:00 -00:00 +0000 -0000 or Z
          matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
          // 123456789 123456789.123
          // any word (or two) characters or numbers including two/three word month in arabic.
          // includes scottish gaelic two word and hyphenated months
          matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
          match1to2NoLeadingZero = /^[1-9]\d?/,
          //         1-99
          match1to2HasZero = /^([1-9]\d|\d)/,
          //           0-99
          regexes;
        regexes = {};
        function addRegexToken(token, regex, strictRegex) {
          regexes[token] = isFunction$2(regex) ? regex : function (isStrict, localeData) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }
        function getParseRegexForToken(token, config) {
          if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
          }
          return regexes[token](config._strict, config._locale);
        }

        // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
        function unescapeFormat(s) {
          return regexEscape$1(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }));
        }
        function regexEscape$1(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        }
        function absFloor(number) {
          if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
          } else {
            return Math.floor(number);
          }
        }
        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion,
            value = 0;
          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
          }
          return value;
        }
        var tokens = {};
        function addParseToken(token, callback) {
          var i,
            func = callback,
            tokenLen;
          if (typeof token === 'string') {
            token = [token];
          }
          if (isNumber(callback)) {
            func = function func(input, array) {
              array[callback] = toInt(input);
            };
          }
          tokenLen = token.length;
          for (i = 0; i < tokenLen; i++) {
            tokens[token[i]] = func;
          }
        }
        function addWeekParseToken(token, callback) {
          addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
          });
        }
        function addTimeToArrayFromToken(token, input, config) {
          if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
          }
        }
        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        var YEAR = 0,
          MONTH = 1,
          DATE = 2,
          HOUR = 3,
          MINUTE = 4,
          SECOND = 5,
          MILLISECOND = 6,
          WEEK = 7,
          WEEKDAY = 8;

        // FORMATTING

        addFormatToken('Y', 0, 0, function () {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : '+' + y;
        });
        addFormatToken(0, ['YY', 2], 0, function () {
          return this.year() % 100;
        });
        addFormatToken(0, ['YYYY', 4], 0, 'year');
        addFormatToken(0, ['YYYYY', 5], 0, 'year');
        addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

        // PARSING

        addRegexToken('Y', matchSigned);
        addRegexToken('YY', match1to2, match2);
        addRegexToken('YYYY', match1to4, match4);
        addRegexToken('YYYYY', match1to6, match6);
        addRegexToken('YYYYYY', match1to6, match6);
        addParseToken(['YYYYY', 'YYYYYY'], YEAR);
        addParseToken('YYYY', function (input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken('YY', function (input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken('Y', function (input, array) {
          array[YEAR] = parseInt(input, 10);
        });

        // HELPERS

        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        }

        // HOOKS

        hooks.parseTwoDigitYear = function (input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
        };

        // MOMENTS

        var getSetYear = makeGetSet('FullYear', true);
        function getIsLeapYear() {
          return isLeapYear(this.year());
        }
        function makeGetSet(unit, keepTime) {
          return function (value) {
            if (value != null) {
              set$1$1(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
            } else {
              return get$6(this, unit);
            }
          };
        }
        function get$6(mom, unit) {
          if (!mom.isValid()) {
            return NaN;
          }
          var d = mom._d,
            isUTC = mom._isUTC;
          switch (unit) {
            case 'Milliseconds':
              return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
            case 'Seconds':
              return isUTC ? d.getUTCSeconds() : d.getSeconds();
            case 'Minutes':
              return isUTC ? d.getUTCMinutes() : d.getMinutes();
            case 'Hours':
              return isUTC ? d.getUTCHours() : d.getHours();
            case 'Date':
              return isUTC ? d.getUTCDate() : d.getDate();
            case 'Day':
              return isUTC ? d.getUTCDay() : d.getDay();
            case 'Month':
              return isUTC ? d.getUTCMonth() : d.getMonth();
            case 'FullYear':
              return isUTC ? d.getUTCFullYear() : d.getFullYear();
            default:
              return NaN;
            // Just in case
          }
        }
        function set$1$1(mom, unit, value) {
          var d, isUTC, year, month, date;
          if (!mom.isValid() || isNaN(value)) {
            return;
          }
          d = mom._d;
          isUTC = mom._isUTC;
          switch (unit) {
            case 'Milliseconds':
              return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
            case 'Seconds':
              return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
            case 'Minutes':
              return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
            case 'Hours':
              return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
            case 'Date':
              return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
            // case 'Day': // Not real
            //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
            // case 'Month': // Not used because we need to pass two variables
            //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
            case 'FullYear':
              break;
            // See below ...
            default:
              return;
            // Just in case
          }
          year = value;
          month = mom.month();
          date = mom.date();
          date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
          void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
        }

        // MOMENTS

        function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction$2(this[units])) {
            return this[units]();
          }
          return this;
        }
        function stringSet(units, value) {
          if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
              i,
              prioritizedLen = prioritized.length;
            for (i = 0; i < prioritizedLen; i++) {
              this[prioritized[i].unit](units[prioritized[i].unit]);
            }
          } else {
            units = normalizeUnits(units);
            if (isFunction$2(this[units])) {
              return this[units](value);
            }
          }
          return this;
        }
        function mod(n, x) {
          return (n % x + x) % x;
        }
        var indexOf;
        if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
        } else {
          indexOf = function indexOf(o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
              if (this[i] === o) {
                return i;
              }
            }
            return -1;
          };
        }
        function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
            return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
        }

        // FORMATTING

        addFormatToken('M', ['MM', 2], 'Mo', function () {
          return this.month() + 1;
        });
        addFormatToken('MMM', 0, 0, function (format) {
          return this.localeData().monthsShort(this, format);
        });
        addFormatToken('MMMM', 0, 0, function (format) {
          return this.localeData().months(this, format);
        });

        // PARSING

        addRegexToken('M', match1to2, match1to2NoLeadingZero);
        addRegexToken('MM', match1to2, match2);
        addRegexToken('MMM', function (isStrict, locale) {
          return locale.monthsShortRegex(isStrict);
        });
        addRegexToken('MMMM', function (isStrict, locale) {
          return locale.monthsRegex(isStrict);
        });
        addParseToken(['M', 'MM'], function (input, array) {
          array[MONTH] = toInt(input) - 1;
        });
        addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
          var month = config._locale.monthsParse(input, token, config._strict);
          // if we didn't find a month name, mark the date as invalid.
          if (month != null) {
            array[MONTH] = month;
          } else {
            getParsingFlags(config).invalidMonth = input;
          }
        });

        // LOCALES

        var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
          defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
          MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
          defaultMonthsShortRegex = matchWord,
          defaultMonthsRegex = matchWord;
        function localeMonths(m, format) {
          if (!m) {
            return isArray$b(this._months) ? this._months : this._months['standalone'];
          }
          return isArray$b(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
        }
        function localeMonthsShort(m, format) {
          if (!m) {
            return isArray$b(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
          }
          return isArray$b(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
        }
        function handleStrictParse(monthName, format, strict) {
          var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
              mom = createUTC([2000, i]);
              this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
              this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format === 'MMM') {
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format === 'MMM') {
              ii = indexOf.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeMonthsParse(monthName, format, strict) {
          var i, mom, regex;
          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
          }
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          }

          // TODO: add sorting
          // Sorting makes sure if one month (or abbr) is a prefix of another
          // see sorting in computeMonthsParse
          for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
              this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
              regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
              this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
              return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
              return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
            }
          }
        }

        // MOMENTS

        function setMonth(mom, value) {
          if (!mom.isValid()) {
            // No op
            return mom;
          }
          if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
              value = toInt(value);
            } else {
              value = mom.localeData().monthsParse(value);
              // TODO: Another silent failure?
              if (!isNumber(value)) {
                return mom;
              }
            }
          }
          var month = value,
            date = mom.date();
          date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
          void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
          return mom;
        }
        function getSetMonth(value) {
          if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
          } else {
            return get$6(this, 'Month');
          }
        }
        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }
        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }
        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
              this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }
        function computeMonthsParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            shortP,
            longP;
          for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortP = regexEscape$1(this.monthsShort(mom, ''));
            longP = regexEscape$1(this.months(mom, ''));
            shortPieces.push(shortP);
            longPieces.push(longP);
            mixedPieces.push(longP);
            mixedPieces.push(shortP);
          }
          // Sorting makes sure if one month (or abbr) is a prefix of another it
          // will match the longer piece.
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        }
        function createDate(y, m, d, h, M, s, ms) {
          // can't just apply() to create a date:
          // https://stackoverflow.com/q/181348
          var date;
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
            }
          } else {
            date = new Date(y, m, d, h, M, s, ms);
          }
          return date;
        }
        function createUTCDate(y) {
          var date, args;
          // the Date.UTC function remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
            }
          } else {
            date = new Date(Date.UTC.apply(null, arguments));
          }
          return date;
        }

        // start-of-first-week - start-of-year
        function firstWeekOffset(year, dow, doy) {
          var
            // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        }

        // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;
          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }
          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }
        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;
          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }
          return {
            week: resWeek,
            year: resYear
          };
        }
        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }

        // FORMATTING

        addFormatToken('w', ['ww', 2], 'wo', 'week');
        addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

        // PARSING

        addRegexToken('w', match1to2, match1to2NoLeadingZero);
        addRegexToken('ww', match1to2, match2);
        addRegexToken('W', match1to2, match1to2NoLeadingZero);
        addRegexToken('WW', match1to2, match2);
        addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
          week[token.substr(0, 1)] = toInt(input);
        });

        // HELPERS

        // LOCALES

        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }
        var defaultLocaleWeek = {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 6th is the first week of the year.
        };
        function localeFirstDayOfWeek() {
          return this._week.dow;
        }
        function localeFirstDayOfYear() {
          return this._week.doy;
        }

        // MOMENTS

        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, 'd');
        }
        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, 'd');
        }

        // FORMATTING

        addFormatToken('d', 0, 'do', 'day');
        addFormatToken('dd', 0, 0, function (format) {
          return this.localeData().weekdaysMin(this, format);
        });
        addFormatToken('ddd', 0, 0, function (format) {
          return this.localeData().weekdaysShort(this, format);
        });
        addFormatToken('dddd', 0, 0, function (format) {
          return this.localeData().weekdays(this, format);
        });
        addFormatToken('e', 0, 0, 'weekday');
        addFormatToken('E', 0, 0, 'isoWeekday');

        // PARSING

        addRegexToken('d', match1to2);
        addRegexToken('e', match1to2);
        addRegexToken('E', match1to2);
        addRegexToken('dd', function (isStrict, locale) {
          return locale.weekdaysMinRegex(isStrict);
        });
        addRegexToken('ddd', function (isStrict, locale) {
          return locale.weekdaysShortRegex(isStrict);
        });
        addRegexToken('dddd', function (isStrict, locale) {
          return locale.weekdaysRegex(isStrict);
        });
        addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
          var weekday = config._locale.weekdaysParse(input, token, config._strict);
          // if we didn't get a weekday name, mark the date as invalid
          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config).invalidWeekday = input;
          }
        });
        addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
          week[token] = toInt(input);
        });

        // HELPERS

        function parseWeekday(input, locale) {
          if (typeof input !== 'string') {
            return input;
          }
          if (!isNaN(input)) {
            return parseInt(input, 10);
          }
          input = locale.weekdaysParse(input);
          if (typeof input === 'number') {
            return input;
          }
          return null;
        }
        function parseIsoWeekday(input, locale) {
          if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
        }

        // LOCALES
        function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
        }
        var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
          defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          defaultWeekdaysRegex = matchWord,
          defaultWeekdaysShortRegex = matchWord,
          defaultWeekdaysMinRegex = matchWord;
        function localeWeekdays(m, format) {
          var weekdays = isArray$b(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
          return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
        }
        function localeWeekdaysShort(m) {
          return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
        }
        function localeWeekdaysMin(m) {
          return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
        }
        function handleStrictParse$1(weekdayName, format, strict) {
          var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
              mom = createUTC([2000, 1]).day(i);
              this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
              this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
              this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format === 'dddd') {
              ii = indexOf.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format === 'dddd') {
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeWeekdaysParse(weekdayName, format, strict) {
          var i, mom, regex;
          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
          }
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }
          for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
              this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
              this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
              this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
              regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
              this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
              return i;
            }
          }
        }

        // MOMENTS

        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var day = get$6(this, 'Day');
          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
          } else {
            return day;
          }
        }
        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, 'd');
        }
        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }

          // behaves the same as moment#day except
          // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
          // as a setter, sunday should belong to the previous week.

          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }
        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }
        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }
        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }
        function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
          for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape$1(this.weekdaysMin(mom, ''));
            shortp = regexEscape$1(this.weekdaysShort(mom, ''));
            longp = regexEscape$1(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          }
          // Sorting makes sure if one weekday (or abbr) is a prefix of another it
          // will match the longer piece.
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
          this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
        }

        // FORMATTING

        function hFormat() {
          return this.hours() % 12 || 12;
        }
        function kFormat() {
          return this.hours() || 24;
        }
        addFormatToken('H', ['HH', 2], 0, 'hour');
        addFormatToken('h', ['hh', 2], 0, hFormat);
        addFormatToken('k', ['kk', 2], 0, kFormat);
        addFormatToken('hmm', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken('hmmss', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken('Hmm', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken('Hmmss', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        function meridiem(token, lowercase) {
          addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
          });
        }
        meridiem('a', true);
        meridiem('A', false);

        // PARSING

        function matchMeridiem(isStrict, locale) {
          return locale._meridiemParse;
        }
        addRegexToken('a', matchMeridiem);
        addRegexToken('A', matchMeridiem);
        addRegexToken('H', match1to2, match1to2HasZero);
        addRegexToken('h', match1to2, match1to2NoLeadingZero);
        addRegexToken('k', match1to2, match1to2NoLeadingZero);
        addRegexToken('HH', match1to2, match2);
        addRegexToken('hh', match1to2, match2);
        addRegexToken('kk', match1to2, match2);
        addRegexToken('hmm', match3to4);
        addRegexToken('hmmss', match5to6);
        addRegexToken('Hmm', match3to4);
        addRegexToken('Hmmss', match5to6);
        addParseToken(['H', 'HH'], HOUR);
        addParseToken(['k', 'kk'], function (input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(['a', 'A'], function (input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
        });
        addParseToken(['h', 'hh'], function (input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
            pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('Hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken('Hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
            pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
        });

        // LOCALES

        function localeIsPM(input) {
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
          // Using charAt should be more compatible.
          return (input + '').toLowerCase().charAt(0) === 'p';
        }
        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
          // Setting the hour should keep the time, because the user explicitly
          // specified which hour they want. So trying to maintain the same hour (in
          // a new timezone) makes sense. Adding/subtracting hours does not follow
          // this rule.
          getSetHour = makeGetSet('Hours', true);
        function localeMeridiem(hours, minutes, isLower) {
          if (hours > 11) {
            return isLower ? 'pm' : 'PM';
          } else {
            return isLower ? 'am' : 'AM';
          }
        }
        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        };

        // internal storage for locale config files
        var locales = {},
          localeFamilies = {},
          globalLocale;
        function commonPrefix(arr1, arr2) {
          var i,
            minl = Math.min(arr1.length, arr2.length);
          for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
              return i;
            }
          }
          return minl;
        }
        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace('_', '-') : key;
        }

        // pick the locale from the array
        // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        function chooseLocale(names) {
          var i = 0,
            j,
            next,
            locale,
            split;
          while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
              locale = loadLocale(split.slice(0, j).join('-'));
              if (locale) {
                return locale;
              }
              if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
              }
              j--;
            }
            i++;
          }
          return globalLocale;
        }
        function isLocaleNameSane(name) {
          // Prevent names that look like filesystem paths, i.e contain '/' or '\'
          // Ensure name is available and function returns boolean
          return !!(name && name.match('^[^/\\\\]*$'));
        }
        function loadLocale(name) {
          var oldLocale = null,
            aliasedRequire;
          // TODO: Find a better way to register and load all the locales in Node
          if (locales[name] === undefined && typeof module !== 'undefined' && module && module.exports && isLocaleNameSane(name)) {
            try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = require;
              aliasedRequire('./locale/' + name);
              getSetGlobalLocale(oldLocale);
            } catch (e) {
              // mark as not found to avoid repeating expensive file require call causing high CPU
              // when trying to find en-US, en_US, en-us for every format call
              locales[name] = null; // null means not found
            }
          }
          return locales[name];
        }

        // This function will load locale and then set the global locale.  If
        // no arguments are passed in, it will simply return the current global
        // locale key.
        function getSetGlobalLocale(key, values) {
          var data;
          if (key) {
            if (isUndefined$1(values)) {
              data = getLocale(key);
            } else {
              data = defineLocale(key, values);
            }
            if (data) {
              // moment.duration._locale = moment._locale = data;
              globalLocale = data;
            } else {
              if (typeof console !== 'undefined' && console.warn) {
                //warn user if arguments are passed but the locale could not be set
                console.warn('Locale ' + key + ' not found. Did you forget to load it?');
              }
            }
          }
          return globalLocale._abbr;
        }
        function defineLocale(name, config) {
          if (config !== null) {
            var locale,
              parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
              deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
              parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
              } else {
                locale = loadLocale(config.parentLocale);
                if (locale != null) {
                  parentConfig = locale._config;
                } else {
                  if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                  }
                  localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                  });
                  return null;
                }
              }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
              });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);
            return locales[name];
          } else {
            // useful for testing
            delete locales[name];
            return null;
          }
        }
        function updateLocale(name, config) {
          if (config != null) {
            var locale,
              tmpLocale,
              parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
              // Update existing child locale in-place to avoid memory-leaks
              locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
              // MERGE
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              if (tmpLocale == null) {
                // updateLocale is called for creating a new locale
                // Set abbr so it will have a name (getters return
                // undefined otherwise).
                config.abbr = name;
              }
              locale = new Locale(config);
              locale.parentLocale = locales[name];
              locales[name] = locale;
            }

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
          } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                  getSetGlobalLocale(name);
                }
              } else if (locales[name] != null) {
                delete locales[name];
              }
            }
          }
          return locales[name];
        }

        // returns locale data
        function getLocale(key) {
          var locale;
          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }
          if (!key) {
            return globalLocale;
          }
          if (!isArray$b(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
              return locale;
            }
            key = [key];
          }
          return chooseLocale(key);
        }
        function listLocales() {
          return keys$5(locales);
        }
        function checkOverflow(m) {
          var overflow,
            a = m._a;
          if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
          }
          return m;
        }

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
          isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/], ['YYYYMM', /\d{6}/, false], ['YYYY', /\d{4}/, false]],
          // iso time formats and regexes
          isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]],
          aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
          // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
          rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
          obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60
          };

        // date from iso format
        function configFromISO(config) {
          var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat,
            isoDatesLen = isoDates.length,
            isoTimesLen = isoTimes.length;
          if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
              if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
              }
            }
            if (dateFormat == null) {
              config._isValid = false;
              return;
            }
            if (match[3]) {
              for (i = 0, l = isoTimesLen; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                  // match[2] should be 'T' or space
                  timeFormat = (match[2] || ' ') + isoTimes[i][0];
                  break;
                }
              }
              if (timeFormat == null) {
                config._isValid = false;
                return;
              }
            }
            if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
            }
            if (match[4]) {
              if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
              } else {
                config._isValid = false;
                return;
              }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
          } else {
            config._isValid = false;
          }
        }
        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];
          if (secondStr) {
            result.push(parseInt(secondStr, 10));
          }
          return result;
        }
        function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
            return 2000 + year;
          } else if (year <= 999) {
            return 1900 + year;
          }
          return year;
        }
        function preprocessRFC2822(s) {
          // Remove comments and folding whitespace and replace multiple-spaces with a single space
          return s.replace(/\([^()]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
        }
        function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
              weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
            }
          }
          return true;
        }
        function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
            return obsOffsets[obsOffset];
          } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
          } else {
            var hm = parseInt(numOffset, 10),
              m = hm % 100,
              h = (hm - m) / 100;
            return h * 60 + m;
          }
        }

        // date and time from ref 2822 format
        function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
          if (match) {
            parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
              return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
          } else {
            config._isValid = false;
          }
        }

        // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
        function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
          }
          configFromISO(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          configFromRFC2822(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          if (config._strict) {
            config._isValid = false;
          } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
          }
        }
        hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
          config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        });

        // Pick the first defined of two or three arguments.
        function defaults(a, b, c) {
          if (a != null) {
            return a;
          }
          if (b != null) {
            return b;
          }
          return c;
        }
        function currentDateArray(config) {
          // hooks is actually the exported moment object
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }

        // convert an array to a date.
        // the array should mirror the parameters below
        // note: all values past the year are optional and will default to the lowest possible value.
        // [year, month, day , hour, minute, second, millisecond]
        function configFromArray(config) {
          var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;
          if (config._d) {
            return;
          }
          currentDate = currentDateArray(config);

          //compute day of the year from weeks and weekdays
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
          }

          //if the day of the year is set, figure out what it is
          if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
          }

          // Default to current date.
          // * if no year, month, day of month are given, default to today
          // * if day of month is given, default month and year
          // * if month is given, default only year
          // * if year is given, don't default anything
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
          }

          // Zero out whatever was not defaulted, including time
          for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
          }

          // Check for 24:00:00.000
          if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
          }
          config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

          // Apply timezone offset from input. The actual utcOffset can be changed
          // with parseZone.
          if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }
          if (config._nextDay) {
            config._a[HOUR] = 24;
          }

          // check for mismatching day of week
          if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
          }
        }
        function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);
            if (w.d != null) {
              // weekday -- low day numbers are considered next week
              weekday = w.d;
              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w.e != null) {
              // local weekday -- counting starts from beginning of week
              weekday = w.e + dow;
              if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              // default to beginning of week
              weekday = dow;
            }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
          }
        }

        // constant that refers to the ISO standard
        hooks.ISO_8601 = function () {};

        // constant that refers to the RFC 2822 form
        hooks.RFC_2822 = function () {};

        // date from string and format string
        function configFromStringAndFormat(config) {
          // TODO: Move this to another part of the creation flow to prevent circular deps
          if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
          }
          if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;

          // This array is used to make a Date, either with `new Date` or `Date.UTC`
          var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era,
            tokenLen;
          tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
          tokenLen = tokens.length;
          for (i = 0; i < tokenLen; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));
              if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
              }
              string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
              totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
              if (parsedInput) {
                getParsingFlags(config).empty = false;
              } else {
                getParsingFlags(config).unusedTokens.push(token);
              }
              addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token);
            }
          }

          // add remaining unparsed input length to the string
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
          }

          // clear _12h flag if hour is <= 12
          if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
          }
          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          // handle meridiem
          config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

          // handle era
          era = getParsingFlags(config).era;
          if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }
          configFromArray(config);
          checkOverflow(config);
        }
        function meridiemFixWrap(locale, hour, meridiem) {
          var isPm;
          if (meridiem == null) {
            // nothing to do
            return hour;
          }
          if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
          } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
              hour += 12;
            }
            if (!isPm && hour === 12) {
              hour = 0;
            }
            return hour;
          } else {
            // this is not supposed to happen
            return hour;
          }
        }

        // date from string and array of format strings
        function configFromStringAndArray(config) {
          var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false,
            configfLen = config._f.length;
          if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
          }
          for (i = 0; i < configfLen; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
              validFormatFound = true;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
              if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
                if (validFormatFound) {
                  bestFormatIsValid = true;
                }
              }
            } else {
              if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }
          }
          extend(config, bestMoment || tempConfig);
        }
        function configFromObject(config) {
          if (config._d) {
            return;
          }
          var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
          config._a = map$2([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
          });
          configFromArray(config);
        }
        function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
          }
          return res;
        }
        function prepareConfig(config) {
          var input = config._i,
            format = config._f;
          config._locale = config._locale || getLocale(config._l);
          if (input === null || format === undefined && input === '') {
            return createInvalid({
              nullInput: true
            });
          }
          if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
          }
          if (isMoment(input)) {
            return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
            config._d = input;
          } else if (isArray$b(format)) {
            configFromStringAndArray(config);
          } else if (format) {
            configFromStringAndFormat(config);
          } else {
            configFromInput(config);
          }
          if (!isValid(config)) {
            config._d = null;
          }
          return config;
        }
        function configFromInput(config) {
          var input = config._i;
          if (isUndefined$1(input)) {
            config._d = new Date(hooks.now());
          } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
          } else if (typeof input === 'string') {
            configFromString(config);
          } else if (isArray$b(input)) {
            config._a = map$2(input.slice(0), function (obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config);
          } else if (isObject$h(input)) {
            configFromObject(config);
          } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        function createLocalOrUTC(input, format, locale, strict, isUTC) {
          var c = {};
          if (format === true || format === false) {
            strict = format;
            format = undefined;
          }
          if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
          }
          if (isObject$h(input) && isObjectEmpty(input) || isArray$b(input) && input.length === 0) {
            input = undefined;
          }
          // object construction must be done this way.
          // https://github.com/moment/moment/issues/1423
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale;
          c._i = input;
          c._f = format;
          c._strict = strict;
          return createFromConfig(c);
        }
        function createLocal(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, false);
        }
        var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other < this ? this : other;
            } else {
              return createInvalid();
            }
          }),
          prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other > this ? this : other;
            } else {
              return createInvalid();
            }
          });

        // Pick a moment m from moments so that m[fn](other) is true for all
        // other. This relies on the function fn to be transitive.
        //
        // moments should either be an array of moment objects or an array, whose
        // first element is an array of moment objects.
        function pickBy$2(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray$b(moments[0])) {
            moments = moments[0];
          }
          if (!moments.length) {
            return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
              res = moments[i];
            }
          }
          return res;
        }

        // TODO: Use [].sort instead?
        function min() {
          var args = [].slice.call(arguments, 0);
          return pickBy$2('isBefore', args);
        }
        function max() {
          var args = [].slice.call(arguments, 0);
          return pickBy$2('isAfter', args);
        }
        var now$3 = function now$3() {
          return Date.now ? Date.now() : +new Date();
        };
        var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
        function isDurationValid(m) {
          var key,
            unitHasDecimal = false,
            i,
            orderLen = ordering.length;
          for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
            }
          }
          for (i = 0; i < orderLen; ++i) {
            if (m[ordering[i]]) {
              if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
              }
              if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
              }
            }
          }
          return true;
        }
        function isValid$1() {
          return this._isValid;
        }
        function createInvalid$1() {
          return createDuration(NaN);
        }
        function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput);

          // representation for dateAddRemove
          this._milliseconds = +milliseconds + seconds * 1e3 +
          // 1000
          minutes * 6e4 +
          // 1000 * 60
          hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
          // Because of dateAddRemove treats 24 hours as different from a
          // day when working around DST, we need to store them separately
          this._days = +days + weeks * 7;
          // It is impossible to translate months into days without knowing
          // which months you are are talking about, so we have to store
          // it separately.
          this._months = +months + quarters * 3 + years * 12;
          this._data = {};
          this._locale = getLocale();
          this._bubble();
        }
        function isDuration(obj) {
          return obj instanceof Duration;
        }
        function absRound(number) {
          if (number < 0) {
            return Math.round(-1 * number) * -1;
          } else {
            return Math.round(number);
          }
        }

        // compare two arrays, return the number of differences
        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
          for (i = 0; i < len; i++) {
            if (toInt(array1[i]) !== toInt(array2[i])) {
              diffs++;
            }
          }
          return diffs + lengthDiff;
        }

        // FORMATTING

        function offset(token, separator) {
          addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
              sign = '+';
            if (offset < 0) {
              offset = -offset;
              sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
          });
        }
        offset('Z', ':');
        offset('ZZ', '');

        // PARSING

        addRegexToken('Z', matchShortOffset);
        addRegexToken('ZZ', matchShortOffset);
        addParseToken(['Z', 'ZZ'], function (input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
        });

        // HELPERS

        // timezone chunker
        // '+10:00' > ['10',  '00']
        // '-1530'  > ['-15', '30']
        var chunkOffset = /([\+\-]|\d\d)/gi;
        function offsetFromString(matcher, string) {
          var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;
          if (matches === null) {
            return null;
          }
          chunk = matches[matches.length - 1] || [];
          parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
          minutes = +(parts[1] * 60) + toInt(parts[2]);
          return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
        }

        // Return a moment from input, that is local/utc/zone equivalent to model.
        function cloneWithOffset(input, model) {
          var res, diff;
          if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }
        function getDateOffset(m) {
          // On Firefox.24 Date#getTimezoneOffset returns a floating point.
          // https://github.com/moment/moment/pull/1871
          return -Math.round(m._d.getTimezoneOffset());
        }

        // HOOKS

        // This function will be called whenever a moment is mutated.
        // It is intended to keep the offset in sync with the timezone.
        hooks.updateOffset = function () {};

        // MOMENTS

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset = this._offset || 0,
            localAdjust;
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            if (typeof input === 'string') {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
              this.add(localAdjust, 'm');
            }
            if (offset !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }
            return this;
          } else {
            return this._isUTC ? offset : getDateOffset(this);
          }
        }
        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== 'string') {
              input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }
        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }
        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
              this.subtract(getDateOffset(this), 'm');
            }
          }
          return this;
        }
        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }
          return this;
        }
        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }
        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }
        function isDaylightSavingTimeShifted() {
          if (!isUndefined$1(this._isDSTShifted)) {
            return this._isDSTShifted;
          }
          var c = {},
            other;
          copyConfig(c, this);
          c = prepareConfig(c);
          if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }
          return this._isDSTShifted;
        }
        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }
        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }
        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }

        // ASP.NET json date format regex
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
          // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
          // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
          // and further modified to allow for strings containing both week and day
          isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        function createDuration(input, key) {
          var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;
          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
              duration[key] = +input;
            } else {
              duration.milliseconds = +input;
            }
          } else if (match = aspNetRegex.exec(input)) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match[DATE]) * sign,
              h: toInt(match[HOUR]) * sign,
              m: toInt(match[MINUTE]) * sign,
              s: toInt(match[SECOND]) * sign,
              ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
          } else if (match = isoRegex.exec(input)) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
              y: parseIso(match[2], sign),
              M: parseIso(match[3], sign),
              w: parseIso(match[4], sign),
              d: parseIso(match[5], sign),
              h: parseIso(match[6], sign),
              m: parseIso(match[7], sign),
              s: parseIso(match[8], sign)
            };
          } else if (duration == null) {
            // checks for null or undefined
            duration = {};
          } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }
          ret = new Duration(duration);
          if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
          }
          if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
          }
          return ret;
        }
        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;
        function parseIso(inp, sign) {
          // We'd normally use ~~inp for this, but unfortunately it also
          // converts floats to ints.
          // inp may be undefined, so careful calling replace on it.
          var res = inp && parseFloat(inp.replace(',', '.'));
          // apply sign while we're at it
          return (isNaN(res) ? 0 : res) * sign;
        }
        function positiveMomentsDifference(base, other) {
          var res = {};
          res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
          }
          res.milliseconds = +other - +base.clone().add(res.months, 'M');
          return res;
        }
        function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
            return {
              milliseconds: 0,
              months: 0
            };
          }
          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
          } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }
          return res;
        }

        // TODO: remove 'name' arg after deprecation is removed
        function createAdder(direction, name) {
          return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
              deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
              tmp = val;
              val = period;
              period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }
        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);
          if (!mom.isValid()) {
            // No op
            return;
          }
          updateOffset = updateOffset == null ? true : updateOffset;
          if (months) {
            setMonth(mom, get$6(mom, 'Month') + months * isAdding);
          }
          if (days) {
            set$1$1(mom, 'Date', get$6(mom, 'Date') + days * isAdding);
          }
          if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
          }
          if (updateOffset) {
            hooks.updateOffset(mom, days || months);
          }
        }
        var add = createAdder(1, 'add'),
          subtract = createAdder(-1, 'subtract');
        function isString$2(input) {
          return typeof input === 'string' || input instanceof String;
        }

        // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
        function isMomentInput(input) {
          return isMoment(input) || isDate(input) || isString$2(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;
        }
        function isMomentInputObject(input) {
          var objectTest = isObject$h(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = ['years', 'year', 'y', 'months', 'month', 'M', 'days', 'day', 'd', 'dates', 'date', 'D', 'hours', 'hour', 'h', 'minutes', 'minute', 'm', 'seconds', 'second', 's', 'milliseconds', 'millisecond', 'ms'],
            i,
            property,
            propertyLen = properties.length;
          for (i = 0; i < propertyLen; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function isNumberOrStringArray(input) {
          var arrayTest = isArray$b(input),
            dataTypeTest = false;
          if (arrayTest) {
            dataTypeTest = input.filter(function (item) {
              return !isNumber(item) && isString$2(input);
            }).length === 0;
          }
          return arrayTest && dataTypeTest;
        }
        function isCalendarSpec(input) {
          var objectTest = isObject$h(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = ['sameDay', 'nextDay', 'lastDay', 'nextWeek', 'lastWeek', 'sameElse'],
            i,
            property;
          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function getCalendarFormat(myMoment, now) {
          var diff = myMoment.diff(now, 'days', true);
          return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
        }
        function calendar$1(time, formats) {
          // Support for single parameter, formats only overload to the calendar function
          if (arguments.length === 1) {
            if (!arguments[0]) {
              time = undefined;
              formats = undefined;
            } else if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = undefined;
            }
          }
          // We want to compare the start of today, vs this.
          // Getting start-of-today depends on whether we're local/utc/offset or not.
          var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output = formats && (isFunction$2(formats[format]) ? formats[format].call(this, now) : formats[format]);
          return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
        }
        function clone$5() {
          return new Moment(this);
        }
        function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }
        function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }
        function isBetween(from, to, units, inclusivity) {
          var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
          }
          inclusivity = inclusivity || '()';
          return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
        }
        function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }
        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }
        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }
        function diff(input, units, asFloat) {
          var that, zoneDelta, output;
          if (!this.isValid()) {
            return NaN;
          }
          that = cloneWithOffset(input, this);
          if (!that.isValid()) {
            return NaN;
          }
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);
          switch (units) {
            case 'year':
              output = monthDiff(this, that) / 12;
              break;
            case 'month':
              output = monthDiff(this, that);
              break;
            case 'quarter':
              output = monthDiff(this, that) / 3;
              break;
            case 'second':
              output = (this - that) / 1e3;
              break;
            // 1000
            case 'minute':
              output = (this - that) / 6e4;
              break;
            // 1000 * 60
            case 'hour':
              output = (this - that) / 36e5;
              break;
            // 1000 * 60 * 60
            case 'day':
              output = (this - that - zoneDelta) / 864e5;
              break;
            // 1000 * 60 * 60 * 24, negate dst
            case 'week':
              output = (this - that - zoneDelta) / 6048e5;
              break;
            // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
              output = this - that;
          }
          return asFloat ? output : absFloor(output);
        }
        function monthDiff(a, b) {
          if (a.date() < b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
          }
          // difference in months
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;
          if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
          }

          //check for negative zero, return zero if negative zero
          return -(wholeMonthDiff + adjust) || 0;
        }
        hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
        hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
        function toString$5() {
          return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        }
        function toISOString(keepOffset) {
          if (!this.isValid()) {
            return null;
          }
          var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
          }
          if (isFunction$2(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
              return this.toDate().toISOString();
            } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
          }
          return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }

        /**
         * Return a human readable representation of a moment that can
         * also be evaluated to get a new moment which is the same
         *
         * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
         */
        function inspect() {
          if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
          }
          var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
          }
          prefix = '[' + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
          datetime = '-MM-DD[T]HH:mm:ss.SSS';
          suffix = zone + '[")]';
          return this.format(prefix + year + datetime + suffix);
        }
        function format(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }
        function from(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
              to: this,
              from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }
        function to(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
              from: this,
              to: time
            }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        }

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        function locale(key) {
          var newLocaleData;
          if (key === undefined) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }
            return this;
          }
        }
        var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
          if (key === undefined) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        });
        function localeData() {
          return this._locale;
        }
        var MS_PER_SECOND = 1000,
          MS_PER_MINUTE = 60 * MS_PER_SECOND,
          MS_PER_HOUR = 60 * MS_PER_MINUTE,
          MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

        // actual modulo - handles negative numbers (for dates before 1970):
        function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
        }
        function localStartOfDate(y, m, d) {
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return new Date(y, m, d).valueOf();
          }
        }
        function utcStartOfDate(y, m, d) {
          // Date.UTC remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return Date.UTC(y, m, d);
          }
        }
        function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case 'year':
              time = startOfDate(this.year(), 0, 1);
              break;
            case 'quarter':
              time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
              break;
            case 'month':
              time = startOfDate(this.year(), this.month(), 1);
              break;
            case 'week':
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
              break;
            case 'isoWeek':
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
              break;
            case 'day':
            case 'date':
              time = startOfDate(this.year(), this.month(), this.date());
              break;
            case 'hour':
              time = this._d.valueOf();
              time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
              break;
            case 'minute':
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
            case 'second':
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case 'year':
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
            case 'quarter':
              time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
              break;
            case 'month':
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
            case 'week':
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
              break;
            case 'isoWeek':
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
              break;
            case 'day':
            case 'date':
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
            case 'hour':
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
              break;
            case 'minute':
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
            case 'second':
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function valueOf$1() {
          return this._d.valueOf() - (this._offset || 0) * 60000;
        }
        function unix() {
          return Math.floor(this.valueOf() / 1000);
        }
        function toDate() {
          return new Date(this.valueOf());
        }
        function toArray() {
          var m = this;
          return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
        }
        function toObject$1() {
          var m = this;
          return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
          };
        }
        function toJSON() {
          // new Date(NaN).toJSON() === null
          return this.isValid() ? this.toISOString() : null;
        }
        function isValid$2() {
          return isValid(this);
        }
        function parsingFlags() {
          return extend({}, getParsingFlags(this));
        }
        function invalidAt() {
          return getParsingFlags(this).overflow;
        }
        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        }
        addFormatToken('N', 0, 0, 'eraAbbr');
        addFormatToken('NN', 0, 0, 'eraAbbr');
        addFormatToken('NNN', 0, 0, 'eraAbbr');
        addFormatToken('NNNN', 0, 0, 'eraName');
        addFormatToken('NNNNN', 0, 0, 'eraNarrow');
        addFormatToken('y', ['y', 1], 'yo', 'eraYear');
        addFormatToken('y', ['yy', 2], 0, 'eraYear');
        addFormatToken('y', ['yyy', 3], 0, 'eraYear');
        addFormatToken('y', ['yyyy', 4], 0, 'eraYear');
        addRegexToken('N', matchEraAbbr);
        addRegexToken('NN', matchEraAbbr);
        addRegexToken('NNN', matchEraAbbr);
        addRegexToken('NNNN', matchEraName);
        addRegexToken('NNNNN', matchEraNarrow);
        addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (input, array, config, token) {
          var era = config._locale.erasParse(input, token, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        });
        addRegexToken('y', matchUnsigned);
        addRegexToken('yy', matchUnsigned);
        addRegexToken('yyy', matchUnsigned);
        addRegexToken('yyyy', matchUnsigned);
        addRegexToken('yo', matchEraYearOrdinal);
        addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
        addParseToken(['yo'], function (input, array, config, token) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
          }
          if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
            array[YEAR] = parseInt(input, 10);
          }
        });
        function localeEras(m, format) {
          var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
          for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
              case 'string':
                // truncate time
                date = hooks(eras[i].since).startOf('day');
                eras[i].since = date.valueOf();
                break;
            }
            switch (typeof eras[i].until) {
              case 'undefined':
                eras[i].until = +Infinity;
                break;
              case 'string':
                // truncate time
                date = hooks(eras[i].until).startOf('day').valueOf();
                eras[i].until = date.valueOf();
                break;
            }
          }
          return eras;
        }
        function localeErasParse(eraName, format, strict) {
          var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
          eraName = eraName.toUpperCase();
          for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();
            if (strict) {
              switch (format) {
                case 'N':
                case 'NN':
                case 'NNN':
                  if (abbr === eraName) {
                    return eras[i];
                  }
                  break;
                case 'NNNN':
                  if (name === eraName) {
                    return eras[i];
                  }
                  break;
                case 'NNNNN':
                  if (narrow === eraName) {
                    return eras[i];
                  }
                  break;
              }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i];
            }
          }
        }
        function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? +1 : -1;
          if (year === undefined) {
            return hooks(era.since).year();
          } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
          }
        }
        function getEraName() {
          var i,
            l,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].name;
            }
          }
          return '';
        }
        function getEraNarrow() {
          var i,
            l,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].narrow;
            }
          }
          return '';
        }
        function getEraAbbr() {
          var i,
            l,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].abbr;
            }
          }
          return '';
        }
        function getEraYear() {
          var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;

            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
              return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
            }
          }
          return this.year();
        }
        function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
        }
        function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }
        function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }
        function matchEraAbbr(isStrict, locale) {
          return locale.erasAbbrRegex(isStrict);
        }
        function matchEraName(isStrict, locale) {
          return locale.erasNameRegex(isStrict);
        }
        function matchEraNarrow(isStrict, locale) {
          return locale.erasNarrowRegex(isStrict);
        }
        function matchEraYearOrdinal(isStrict, locale) {
          return locale._eraYearOrdinalRegex || matchUnsigned;
        }
        function computeErasParse() {
          var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            erasName,
            erasAbbr,
            erasNarrow,
            eras = this.eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            erasName = regexEscape$1(eras[i].name);
            erasAbbr = regexEscape$1(eras[i].abbr);
            erasNarrow = regexEscape$1(eras[i].narrow);
            namePieces.push(erasName);
            abbrPieces.push(erasAbbr);
            narrowPieces.push(erasNarrow);
            mixedPieces.push(erasName);
            mixedPieces.push(erasAbbr);
            mixedPieces.push(erasNarrow);
          }
          this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
          this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
          this._erasNarrowRegex = new RegExp('^(' + narrowPieces.join('|') + ')', 'i');
        }

        // FORMATTING

        addFormatToken(0, ['gg', 2], 0, function () {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ['GG', 2], 0, function () {
          return this.isoWeekYear() % 100;
        });
        function addWeekYearFormatToken(token, getter) {
          addFormatToken(0, [token, token.length], 0, getter);
        }
        addWeekYearFormatToken('gggg', 'weekYear');
        addWeekYearFormatToken('ggggg', 'weekYear');
        addWeekYearFormatToken('GGGG', 'isoWeekYear');
        addWeekYearFormatToken('GGGGG', 'isoWeekYear');

        // ALIASES

        // PARSING

        addRegexToken('G', matchSigned);
        addRegexToken('g', matchSigned);
        addRegexToken('GG', match1to2, match2);
        addRegexToken('gg', match1to2, match2);
        addRegexToken('GGGG', match1to4, match4);
        addRegexToken('gggg', match1to4, match4);
        addRegexToken('GGGGG', match1to6, match6);
        addRegexToken('ggggg', match1to6, match6);
        addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
          week[token.substr(0, 2)] = toInt(input);
        });
        addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
          week[token] = hooks.parseTwoDigitYear(input);
        });

        // MOMENTS

        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.week(), this.weekday() + this.localeData()._week.dow, this.localeData()._week.dow, this.localeData()._week.doy);
        }
        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
        }
        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }
        function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
        }
        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }
        function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }
        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
              week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }
        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        }

        // FORMATTING

        addFormatToken('Q', 0, 'Qo', 'quarter');

        // PARSING

        addRegexToken('Q', match1);
        addParseToken('Q', function (input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
        });

        // MOMENTS

        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        }

        // FORMATTING

        addFormatToken('D', ['DD', 2], 'Do', 'date');

        // PARSING

        addRegexToken('D', match1to2, match1to2NoLeadingZero);
        addRegexToken('DD', match1to2, match2);
        addRegexToken('Do', function (isStrict, locale) {
          // TODO: Remove "ordinalParse" fallback in next major release.
          return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(['D', 'DD'], DATE);
        addParseToken('Do', function (input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
        });

        // MOMENTS

        var getSetDayOfMonth = makeGetSet('Date', true);

        // FORMATTING

        addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

        // PARSING

        addRegexToken('DDD', match1to3);
        addRegexToken('DDDD', match3);
        addParseToken(['DDD', 'DDDD'], function (input, array, config) {
          config._dayOfYear = toInt(input);
        });

        // HELPERS

        // MOMENTS

        function getSetDayOfYear(input) {
          var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
        }

        // FORMATTING

        addFormatToken('m', ['mm', 2], 0, 'minute');

        // PARSING

        addRegexToken('m', match1to2, match1to2HasZero);
        addRegexToken('mm', match1to2, match2);
        addParseToken(['m', 'mm'], MINUTE);

        // MOMENTS

        var getSetMinute = makeGetSet('Minutes', false);

        // FORMATTING

        addFormatToken('s', ['ss', 2], 0, 'second');

        // PARSING

        addRegexToken('s', match1to2, match1to2HasZero);
        addRegexToken('ss', match1to2, match2);
        addParseToken(['s', 'ss'], SECOND);

        // MOMENTS

        var getSetSecond = makeGetSet('Seconds', false);

        // FORMATTING

        addFormatToken('S', 0, 0, function () {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ['SSS', 3], 0, 'millisecond');
        addFormatToken(0, ['SSSS', 4], 0, function () {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ['SSSSS', 5], 0, function () {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return this.millisecond() * 1000;
        });
        addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return this.millisecond() * 10000;
        });
        addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return this.millisecond() * 100000;
        });
        addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return this.millisecond() * 1000000;
        });

        // PARSING

        addRegexToken('S', match1to3, match1);
        addRegexToken('SS', match1to3, match2);
        addRegexToken('SSS', match1to3, match3);
        var token, getSetMillisecond;
        for (token = 'SSSS'; token.length <= 9; token += 'S') {
          addRegexToken(token, matchUnsigned);
        }
        function parseMs(input, array) {
          array[MILLISECOND] = toInt(('0.' + input) * 1000);
        }
        for (token = 'S'; token.length <= 9; token += 'S') {
          addParseToken(token, parseMs);
        }
        getSetMillisecond = makeGetSet('Milliseconds', false);

        // FORMATTING

        addFormatToken('z', 0, 0, 'zoneAbbr');
        addFormatToken('zz', 0, 0, 'zoneName');

        // MOMENTS

        function getZoneAbbr() {
          return this._isUTC ? 'UTC' : '';
        }
        function getZoneName() {
          return this._isUTC ? 'Coordinated Universal Time' : '';
        }
        var proto = Moment.prototype;
        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone$5;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject$1;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== 'undefined' && Symbol.for != null) {
          proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
          };
        }
        proto.toJSON = toJSON;
        proto.toString = toString$5;
        proto.unix = unix;
        proto.valueOf = valueOf$1;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
        proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
        proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
        proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
        proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
        function createUnix(input) {
          return createLocal(input * 1000);
        }
        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }
        function preParsePostFormat(string) {
          return string;
        }
        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set$1;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;
        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;
        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;
        function get$1$1(format, index, field, setter) {
          var locale = getLocale(),
            utc = createUTC().set(setter, index);
          return locale[field](utc, format);
        }
        function listMonthsImpl(format, index, field) {
          if (isNumber(format)) {
            index = format;
            format = undefined;
          }
          format = format || '';
          if (index != null) {
            return get$1$1(format, index, field, 'month');
          }
          var i,
            out = [];
          for (i = 0; i < 12; i++) {
            out[i] = get$1$1(format, i, field, 'month');
          }
          return out;
        }

        // ()
        // (5)
        // (fmt, 5)
        // (fmt)
        // (true)
        // (true, 5)
        // (true, fmt, 5)
        // (true, fmt)
        function listWeekdaysImpl(localeSorted, format, index, field) {
          if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
              index = format;
              format = undefined;
            }
            format = format || '';
          } else {
            format = localeSorted;
            index = format;
            localeSorted = false;
            if (isNumber(format)) {
              index = format;
              format = undefined;
            }
            format = format || '';
          }
          var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];
          if (index != null) {
            return get$1$1(format, (index + shift) % 7, field, 'day');
          }
          for (i = 0; i < 7; i++) {
            out[i] = get$1$1(format, (i + shift) % 7, field, 'day');
          }
          return out;
        }
        function listMonths(format, index) {
          return listMonthsImpl(format, index, 'months');
        }
        function listMonthsShort(format, index) {
          return listMonthsImpl(format, index, 'monthsShort');
        }
        function listWeekdays(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
        }
        function listWeekdaysShort(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
        }
        function listWeekdaysMin(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
        }
        getSetGlobalLocale('en', {
          eras: [{
            since: '0001-01-01',
            until: +Infinity,
            offset: 1,
            name: 'Anno Domini',
            narrow: 'AD',
            abbr: 'AD'
          }, {
            since: '0000-12-31',
            until: -Infinity,
            offset: 1,
            name: 'Before Christ',
            narrow: 'BC',
            abbr: 'BC'
          }],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function ordinal(number) {
            var b = number % 10,
              output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
          }
        });

        // Side effect imports

        hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
        hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
        var mathAbs = Math.abs;
        function abs() {
          var data = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);
          return this;
        }
        function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        }

        // supports only 2.0-style add(1, 's') or add(duration)
        function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
        }

        // supports only 2.0-style subtract(1, 's') or subtract(duration)
        function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
        }
        function absCeil(number) {
          if (number < 0) {
            return Math.floor(number);
          } else {
            return Math.ceil(number);
          }
        }
        function bubble() {
          var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;

          // if we have a mix of positive and negative values, bubble down first
          // check: https://github.com/moment/moment/issues/2166
          if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
          }

          // The following code bubbles up values, see the tests for
          // examples of what that means.
          data.milliseconds = milliseconds % 1000;
          seconds = absFloor(milliseconds / 1000);
          data.seconds = seconds % 60;
          minutes = absFloor(seconds / 60);
          data.minutes = minutes % 60;
          hours = absFloor(minutes / 60);
          data.hours = hours % 24;
          days += absFloor(hours / 24);

          // convert days to months
          monthsFromDays = absFloor(daysToMonths(days));
          months += monthsFromDays;
          days -= absCeil(monthsToDays(monthsFromDays));

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;
          data.days = days;
          data.months = months;
          data.years = years;
          return this;
        }
        function daysToMonths(days) {
          // 400 years have 146097 days (taking into account leap year rules)
          // 400 years have 12 months === 4800
          return days * 4800 / 146097;
        }
        function monthsToDays(months) {
          // the reverse of daysToMonths
          return months * 146097 / 4800;
        }
        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }
          var days,
            months,
            milliseconds = this._milliseconds;
          units = normalizeUnits(units);
          if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
              case 'month':
                return months;
              case 'quarter':
                return months / 3;
              case 'year':
                return months / 12;
            }
          } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case 'week':
                return days / 7 + milliseconds / 6048e5;
              case 'day':
                return days + milliseconds / 864e5;
              case 'hour':
                return days * 24 + milliseconds / 36e5;
              case 'minute':
                return days * 1440 + milliseconds / 6e4;
              case 'second':
                return days * 86400 + milliseconds / 1000;
              // Math.floor prevents floating point math errors here
              case 'millisecond':
                return Math.floor(days * 864e5) + milliseconds;
              default:
                throw new Error('Unknown unit ' + units);
            }
          }
        }
        function makeAs(alias) {
          return function () {
            return this.as(alias);
          };
        }
        var asMilliseconds = makeAs('ms'),
          asSeconds = makeAs('s'),
          asMinutes = makeAs('m'),
          asHours = makeAs('h'),
          asDays = makeAs('d'),
          asWeeks = makeAs('w'),
          asMonths = makeAs('M'),
          asQuarters = makeAs('Q'),
          asYears = makeAs('y'),
          valueOf$1$1 = asMilliseconds;
        function clone$1$1() {
          return createDuration(this);
        }
        function get$2$1(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + 's']() : NaN;
        }
        function makeGetter(name) {
          return function () {
            return this.isValid() ? this._data[name] : NaN;
          };
        }
        var milliseconds = makeGetter('milliseconds'),
          seconds = makeGetter('seconds'),
          minutes = makeGetter('minutes'),
          hours = makeGetter('hours'),
          days = makeGetter('days'),
          months = makeGetter('months'),
          years = makeGetter('years');
        function weeks() {
          return absFloor(this.days() / 7);
        }
        var round = Math.round,
          thresholds = {
            ss: 44,
            // a few seconds to seconds
            s: 45,
            // seconds to minute
            m: 45,
            // minutes to hour
            h: 22,
            // hours to day
            d: 26,
            // days to month/week
            w: null,
            // weeks to month
            M: 11 // months to year
          };

        // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
          return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }
        function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
          var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days];
          if (thresholds.w != null) {
            a = a || weeks <= 1 && ['w'] || weeks < thresholds.w && ['ww', weeks];
          }
          a = a || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale;
          return substituteTimeAgo.apply(null, a);
        }

        // This function allows you to set the rounding function for relative time strings
        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === undefined) {
            return round;
          }
          if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
          }
          return false;
        }

        // This function allows you to set a threshold for relative time strings
        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === undefined) {
            return false;
          }
          if (limit === undefined) {
            return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === 's') {
            thresholds.ss = limit - 1;
          }
          return true;
        }
        function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var withSuffix = false,
            th = thresholds,
            locale,
            output;
          if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
          }
          if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
            }
          }
          locale = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale);
          if (withSuffix) {
            output = locale.pastFuture(+this, output);
          }
          return locale.postformat(output);
        }
        var abs$1 = Math.abs;
        function sign(x) {
          return (x > 0) - (x < 0) || +x;
        }
        function toISOString$1() {
          // for ISO strings we do not use the normal bubbling rules:
          //  * milliseconds bubble up until they become hours
          //  * days do not bubble at all
          //  * months bubble up until they become years
          // This is because there is no context-free conversion between hours and days
          // (think of clock changes)
          // and also not between days and months (28-31 days per month)
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;
          if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
          }

          // 3600 seconds -> 60 minutes -> 1 hour
          minutes = absFloor(seconds / 60);
          hours = absFloor(minutes / 60);
          seconds %= 60;
          minutes %= 60;

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
          s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
          totalSign = total < 0 ? '-' : '';
          ymSign = sign(this._months) !== sign(total) ? '-' : '';
          daysSign = sign(this._days) !== sign(total) ? '-' : '';
          hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
          return totalSign + 'P' + (years ? ymSign + years + 'Y' : '') + (months ? ymSign + months + 'M' : '') + (days ? daysSign + days + 'D' : '') + (hours || minutes || seconds ? 'T' : '') + (hours ? hmsSign + hours + 'H' : '') + (minutes ? hmsSign + minutes + 'M' : '') + (seconds ? hmsSign + s + 'S' : '');
        }
        var proto$2 = Duration.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1$1;
        proto$2.get = get$2$1;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;
        proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
        proto$2.lang = lang;

        // FORMATTING

        addFormatToken('X', 0, 0, 'unix');
        addFormatToken('x', 0, 0, 'valueOf');

        // PARSING

        addRegexToken('x', matchSigned);
        addRegexToken('X', matchTimestamp);
        addParseToken('X', function (input, array, config) {
          config._d = new Date(parseFloat(input) * 1000);
        });
        addParseToken('x', function (input, array, config) {
          config._d = new Date(toInt(input));
        });

        //! moment.js

        hooks.version = '2.30.1';
        setHookCallback(createLocal);
        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now$3;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;

        // currently HTML5 input type only supports 24-hour formats
        hooks.HTML5_FMT = {
          DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
          // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
          // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
          // <input type="datetime-local" step="0.001" />
          DATE: 'YYYY-MM-DD',
          // <input type="date" />
          TIME: 'HH:mm',
          // <input type="time" />
          TIME_SECONDS: 'HH:mm:ss',
          // <input type="time" step="1" />
          TIME_MS: 'HH:mm:ss.SSS',
          // <input type="time" step="0.001" />
          WEEK: 'GGGG-[W]WW',
          // <input type="week" />
          MONTH: 'YYYY-MM' // <input type="month" />
        };
        const defaultFormats = {
          normalDateWithWeekday: "ddd, MMM D",
          normalDate: "D MMMM",
          shortDate: "MMM D",
          monthAndDate: "MMMM D",
          dayOfMonth: "D",
          year: "YYYY",
          month: "MMMM",
          monthShort: "MMM",
          monthAndYear: "MMMM YYYY",
          weekday: "dddd",
          weekdayShort: "ddd",
          minutes: "mm",
          hours12h: "hh",
          hours24h: "HH",
          seconds: "ss",
          fullTime: "LT",
          fullTime12h: "hh:mm A",
          fullTime24h: "HH:mm",
          fullDate: "ll",
          fullDateWithWeekday: "dddd, LL",
          fullDateTime: "lll",
          fullDateTime12h: "ll hh:mm A",
          fullDateTime24h: "ll HH:mm",
          keyboardDate: "L",
          keyboardDateTime: "L LT",
          keyboardDateTime12h: "L hh:mm A",
          keyboardDateTime24h: "L HH:mm"
        };
        class MomentUtils {
          constructor({
            locale,
            formats,
            instance
          } = {}) {
            this.lib = "moment";
            this.is12HourCycleInCurrentLocale = () => {
              return /A|a/.test(this.moment.localeData(this.getCurrentLocaleCode()).longDateFormat("LT"));
            };
            this.getFormatHelperText = format => {
              var _a, _b;
              // @see https://github.com/moment/moment/blob/develop/src/lib/format/format.js#L6
              const localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})|./g;
              return (_b = (_a = format.match(localFormattingTokens)) === null || _a === void 0 ? void 0 : _a.map(token => {
                const firstCharacter = token[0];
                if (firstCharacter === "L" || firstCharacter === ";") {
                  return this.moment.localeData(this.getCurrentLocaleCode()).longDateFormat(token);
                }
                return token;
              }).join("").replace(/a/gi, "(a|p)m").toLocaleLowerCase()) !== null && _b !== void 0 ? _b : format;
            };
            this.getCurrentLocaleCode = () => {
              return this.locale || this.moment.locale();
            };
            this.parseISO = isoString => {
              return this.moment(isoString, true);
            };
            this.toISO = value => {
              return value.toISOString();
            };
            this.parse = (value, format) => {
              if (value === "") {
                return null;
              }
              if (this.locale) {
                return this.moment(value, format, this.locale, true);
              }
              return this.moment(value, format, true);
            };
            this.date = value => {
              if (value === null) {
                return null;
              }
              const moment = this.moment(value);
              if (this.locale) {
                moment.locale(this.locale);
              }
              return moment;
            };
            this.toJsDate = value => {
              return value.toDate();
            };
            this.isValid = value => {
              return this.moment(value).isValid();
            };
            this.isNull = date => {
              return date === null;
            };
            this.getDiff = (date, comparing, unit) => {
              if (!this.moment(comparing).isValid()) {
                return 0;
              }
              return date.diff(comparing, unit);
            };
            this.isAfter = (date, value) => {
              return date.isAfter(value);
            };
            this.isBefore = (date, value) => {
              return date.isBefore(value);
            };
            this.isAfterDay = (date, value) => {
              return date.isAfter(value, "day");
            };
            this.isBeforeDay = (date, value) => {
              return date.isBefore(value, "day");
            };
            this.isBeforeMonth = (date, value) => {
              return date.isBefore(value, "month");
            };
            this.isAfterMonth = (date, value) => {
              return date.isAfter(value, "month");
            };
            this.isBeforeYear = (date, value) => {
              return date.isBefore(value, "year");
            };
            this.isAfterYear = (date, value) => {
              return date.isAfter(value, "year");
            };
            this.startOfDay = date => {
              return date.clone().startOf("day");
            };
            this.endOfDay = date => {
              return date.clone().endOf("day");
            };
            this.format = (date, formatKey) => {
              return this.formatByString(date, this.formats[formatKey]);
            };
            this.formatByString = (date, formatString) => {
              const clonedDate = date.clone();
              if (this.locale) {
                clonedDate.locale(this.locale);
              }
              return clonedDate.format(formatString);
            };
            this.formatNumber = numberToFormat => {
              return numberToFormat;
            };
            this.getHours = date => {
              return date.get("hours");
            };
            this.addSeconds = (date, count) => {
              return count < 0 ? date.clone().subtract(Math.abs(count), "seconds") : date.clone().add(count, "seconds");
            };
            this.addMinutes = (date, count) => {
              return count < 0 ? date.clone().subtract(Math.abs(count), "minutes") : date.clone().add(count, "minutes");
            };
            this.addHours = (date, count) => {
              return count < 0 ? date.clone().subtract(Math.abs(count), "hours") : date.clone().add(count, "hours");
            };
            this.addDays = (date, count) => {
              return count < 0 ? date.clone().subtract(Math.abs(count), "days") : date.clone().add(count, "days");
            };
            this.addWeeks = (date, count) => {
              return count < 0 ? date.clone().subtract(Math.abs(count), "weeks") : date.clone().add(count, "weeks");
            };
            this.addMonths = (date, count) => {
              return count < 0 ? date.clone().subtract(Math.abs(count), "months") : date.clone().add(count, "months");
            };
            this.addYears = (date, count) => {
              return count < 0 ? date.clone().subtract(Math.abs(count), "years") : date.clone().add(count, "years");
            };
            this.setHours = (date, count) => {
              return date.clone().hours(count);
            };
            this.getMinutes = date => {
              return date.get("minutes");
            };
            this.setMinutes = (date, count) => {
              return date.clone().minutes(count);
            };
            this.getSeconds = date => {
              return date.get("seconds");
            };
            this.setSeconds = (date, count) => {
              return date.clone().seconds(count);
            };
            this.getMonth = date => {
              return date.get("month");
            };
            this.getDaysInMonth = date => {
              return date.daysInMonth();
            };
            this.isSameDay = (date, comparing) => {
              return date.isSame(comparing, "day");
            };
            this.isSameMonth = (date, comparing) => {
              return date.isSame(comparing, "month");
            };
            this.isSameYear = (date, comparing) => {
              return date.isSame(comparing, "year");
            };
            this.isSameHour = (date, comparing) => {
              return date.isSame(comparing, "hour");
            };
            this.setMonth = (date, count) => {
              return date.clone().month(count);
            };
            this.getMeridiemText = ampm => {
              if (this.is12HourCycleInCurrentLocale()) {
                // AM/PM translation only possible in those who have 12 hour cycle in locale.
                return this.moment.localeData(this.getCurrentLocaleCode()).meridiem(ampm === "am" ? 0 : 13, 0, false);
              }
              return ampm === "am" ? "AM" : "PM"; // fallback for de, ru, ...etc
            };
            this.startOfYear = date => {
              return date.clone().startOf("year");
            };
            this.endOfYear = date => {
              return date.clone().endOf("year");
            };
            this.startOfMonth = date => {
              return date.clone().startOf("month");
            };
            this.endOfMonth = date => {
              return date.clone().endOf("month");
            };
            this.startOfWeek = date => {
              return date.clone().startOf("week");
            };
            this.endOfWeek = date => {
              return date.clone().endOf("week");
            };
            this.getNextMonth = date => {
              return date.clone().add(1, "month");
            };
            this.getPreviousMonth = date => {
              return date.clone().subtract(1, "month");
            };
            this.getMonthArray = date => {
              const firstMonth = date.clone().startOf("year");
              const monthArray = [firstMonth];
              while (monthArray.length < 12) {
                const prevMonth = monthArray[monthArray.length - 1];
                monthArray.push(this.getNextMonth(prevMonth));
              }
              return monthArray;
            };
            this.getYear = date => {
              return date.get("year");
            };
            this.setYear = (date, year) => {
              return date.clone().set("year", year);
            };
            this.getDate = date => {
              return date.get("date");
            };
            this.setDate = (date, year) => {
              return date.clone().set("date", year);
            };
            this.mergeDateAndTime = (date, time) => {
              return date.hour(time.hour()).minute(time.minute()).second(time.second());
            };
            this.getWeekdays = () => {
              return this.moment.weekdaysShort(true);
            };
            this.isEqual = (value, comparing) => {
              if (value === null && comparing === null) {
                return true;
              }
              return this.moment(value).isSame(comparing);
            };
            this.getWeekArray = date => {
              const start = date.clone().startOf("month").startOf("week");
              const end = date.clone().endOf("month").endOf("week");
              let count = 0;
              let current = start;
              const nestedWeeks = [];
              while (current.isBefore(end)) {
                const weekNumber = Math.floor(count / 7);
                nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
                nestedWeeks[weekNumber].push(current);
                current = current.clone().add(1, "day");
                count += 1;
              }
              return nestedWeeks;
            };
            this.getYearRange = (start, end) => {
              const startDate = this.moment(start).startOf("year");
              const endDate = this.moment(end).endOf("year");
              const years = [];
              let current = startDate;
              while (current.isBefore(endDate)) {
                years.push(current);
                current = current.clone().add(1, "year");
              }
              return years;
            };
            this.isWithinRange = (date, [start, end]) => {
              return date.isBetween(start, end, null, "[]");
            };
            this.moment = instance || hooks;
            this.locale = locale;
            this.formats = Object.assign({}, defaultFormats, formats);
          }
        }
        const name = "@mui/x-date-pickers";
        const version$1 = "5.0.20";
        const description = "The community edition of the date picker components (MUI X).";
        const author = "MUI Team";
        const main = "./node/index.js";
        const license = "MIT";
        const bugs = {
          url: "https://github.com/mui/mui-x/issues"
        };
        const homepage = "https://mui.com/x/react-date-pickers/getting-started/";
        const funding = {
          type: "opencollective",
          url: "https://opencollective.com/mui"
        };
        const sideEffects = false;
        const publishConfig = {
          access: "public"
        };
        const keywords = ["react", "react-component", "mui", "material-ui", "material design", "datepicker", "timepicker", "datetimepicker"];
        const repository = {
          type: "git",
          url: "https://github.com/mui/mui-x.git",
          directory: "packages/x-date-pickers"
        };
        const dependencies = {
          "@babel/runtime": "^7.18.9",
          "@date-io/core": "^2.15.0",
          "@date-io/date-fns": "^2.15.0",
          "@date-io/dayjs": "^2.15.0",
          "@date-io/luxon": "^2.15.0",
          "@date-io/moment": "^2.15.0",
          "@mui/utils": "^5.10.3",
          "@types/react-transition-group": "^4.4.5",
          clsx: "^1.2.1",
          "prop-types": "^15.7.2",
          "react-transition-group": "^4.4.5",
          rifm: "^0.12.1"
        };
        const peerDependencies = {
          "@emotion/react": "^11.9.0",
          "@emotion/styled": "^11.8.1",
          "@mui/material": "^5.4.1",
          "@mui/system": "^5.4.1",
          "date-fns": "^2.25.0",
          dayjs: "^1.10.7",
          luxon: "^1.28.0 || ^2.0.0 || ^3.0.0",
          moment: "^2.29.1",
          react: "^17.0.2 || ^18.0.0",
          "react-dom": "^17.0.2 || ^18.0.0"
        };
        const peerDependenciesMeta = {
          "date-fns": {
            optional: true
          },
          dayjs: {
            optional: true
          },
          "@emotion/react": {
            optional: true
          },
          "@emotion/styled": {
            optional: true
          },
          luxon: {
            optional: true
          },
          moment: {
            optional: true
          }
        };
        const setupFiles = ["<rootDir>/src/setupTests.js"];
        const engines = {
          node: ">=12.0.0"
        };
        const module$1 = "./index.js";
        const types$5 = "./index.d.ts";
        const xdpPackage = {
          name: name,
          version: version$1,
          description: description,
          author: author,
          main: main,
          license: license,
          bugs: bugs,
          homepage: homepage,
          funding: funding,
          sideEffects: sideEffects,
          publishConfig: publishConfig,
          keywords: keywords,
          repository: repository,
          dependencies: dependencies,
          peerDependencies: peerDependencies,
          peerDependenciesMeta: peerDependenciesMeta,
          setupFiles: setupFiles,
          engines: engines,
          "private": false,
          module: module$1,
          types: types$5
        };
        const MuiTextWidget = function MuiTextWidget(props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var readonly = props.readonly,
            placeholder = props.placeholder,
            customProps = props.customProps,
            maxLength = props.maxLength;
          props.errorMessage;
          var onChange = reactExports.useCallback(function (e) {
            var val = e.target.value;
            if (val === "") val = undefined; // don't allow empty value

            setValue(val);
          }, [setValue]);
          var textValue = value || "";
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(TextField, _extends$h({
            variant: "standard",
            value: textValue,
            placeholder: !readonly ? placeholder : "",
            InputProps: {
              readOnly: readonly
            },
            inputProps: {
              maxLength: maxLength
            },
            disabled: readonly,
            onChange: onChange,
            size: "small"
          }, customProps)));
        };
        const MuiTextAreaWidget = function MuiTextAreaWidget(props) {
          var value = props.value,
            setValue = props.setValue,
            config = props.config,
            readonly = props.readonly,
            placeholder = props.placeholder,
            customProps = props.customProps,
            maxLength = props.maxLength,
            maxRows = props.maxRows,
            fullWidth = props.fullWidth;
          var defaultMaxRows = config.settings.defaultMaxRows;
          var onChange = function onChange(e) {
            var val = e.target.value;
            if (val === "") val = undefined; // don't allow empty value
            setValue(val);
          };
          var textValue = value || "";
          return /*#__PURE__*/React.createElement(FormControl, {
            fullWidth: fullWidth
          }, /*#__PURE__*/React.createElement(TextField, _extends$h({
            variant: "standard",
            fullWidth: fullWidth,
            maxRows: maxRows || defaultMaxRows,
            multiline: true,
            value: textValue,
            placeholder: !readonly ? placeholder : "",
            InputProps: {
              readOnly: readonly
            },
            inputProps: {
              maxLength: maxLength
            },
            disabled: readonly,
            onChange: onChange,
            size: "small"
          }, customProps)));
        };
        function _arrayWithoutHoles(r) {
          if (Array.isArray(r)) return _arrayLikeToArray$h(r);
        }
        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _toConsumableArray(r) {
          return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray$h(r) || _nonIterableSpread();
        }

        /**
         * MIT License
         * 
         * Copyright (c) 2014-present, Lee Byron and other contributors.
         * 
         * Permission is hereby granted, free of charge, to any person obtaining a copy
         * of this software and associated documentation files (the "Software"), to deal
         * in the Software without restriction, including without limitation the rights
         * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
         * copies of the Software, and to permit persons to whom the Software is
         * furnished to do so, subject to the following conditions:
         * 
         * The above copyright notice and this permission notice shall be included in all
         * copies or substantial portions of the Software.
         * 
         * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
         * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
         * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
         * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
         * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
         * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
         * SOFTWARE.
         */
        var DELETE = 'delete';

        // Constants describing the size of trie nodes.
        var SHIFT = 5; // Resulted in best performance after ______?
        var SIZE = 1 << SHIFT;
        var MASK = SIZE - 1;

        // A consistent shared value representing "not set" which equals nothing other
        // than itself, and nothing that could be provided externally.
        var NOT_SET = {};

        // Boolean references, Rough equivalent of `bool &`.
        function MakeRef() {
          return {
            value: false
          };
        }
        function SetRef(ref) {
          if (ref) {
            ref.value = true;
          }
        }

        // A function which returns a value representing an "owner" for transient writes
        // to tries. The return value will only ever equal itself, and will not equal
        // the return of any subsequent call of this function.
        function OwnerID() {}
        function ensureSize(iter) {
          if (iter.size === undefined) {
            iter.size = iter.__iterate(returnTrue);
          }
          return iter.size;
        }
        function wrapIndex(iter, index) {
          // This implements "is array index" which the ECMAString spec defines as:
          //
          //     A String property name P is an array index if and only if
          //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
          //     to 2^32−1.
          //
          // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
          if (typeof index !== 'number') {
            var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
            if ('' + uint32Index !== index || uint32Index === 4294967295) {
              return NaN;
            }
            index = uint32Index;
          }
          return index < 0 ? ensureSize(iter) + index : index;
        }
        function returnTrue() {
          return true;
        }
        function wholeSlice(begin, end, size) {
          return (begin === 0 && !isNeg(begin) || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);
        }
        function resolveBegin(begin, size) {
          return resolveIndex(begin, size, 0);
        }
        function resolveEnd(end, size) {
          return resolveIndex(end, size, size);
        }
        function resolveIndex(index, size, defaultIndex) {
          // Sanitize indices using this shorthand for ToInt32(argument)
          // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
          return index === undefined ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === undefined || size === index ? index : Math.min(size, index) | 0;
        }
        function isNeg(value) {
          // Account for -0 which is negative, but not less than 0.
          return value < 0 || value === 0 && 1 / value === -Infinity;
        }
        var IS_COLLECTION_SYMBOL = '@@__IMMUTABLE_ITERABLE__@@';
        function isCollection(maybeCollection) {
          return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
        }
        var IS_KEYED_SYMBOL = '@@__IMMUTABLE_KEYED__@@';
        function isKeyed(maybeKeyed) {
          return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
        }
        var IS_INDEXED_SYMBOL = '@@__IMMUTABLE_INDEXED__@@';
        function isIndexed(maybeIndexed) {
          return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
        }
        function isAssociative(maybeAssociative) {
          return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
        }
        var Collection = function Collection(value) {
          // eslint-disable-next-line no-constructor-return
          return isCollection(value) ? value : Seq(value);
        };
        var KeyedCollection = /*@__PURE__*/function (Collection) {
          function KeyedCollection(value) {
            // eslint-disable-next-line no-constructor-return
            return isKeyed(value) ? value : KeyedSeq(value);
          }
          if (Collection) KeyedCollection.__proto__ = Collection;
          KeyedCollection.prototype = Object.create(Collection && Collection.prototype);
          KeyedCollection.prototype.constructor = KeyedCollection;
          return KeyedCollection;
        }(Collection);
        var IndexedCollection = /*@__PURE__*/function (Collection) {
          function IndexedCollection(value) {
            // eslint-disable-next-line no-constructor-return
            return isIndexed(value) ? value : IndexedSeq(value);
          }
          if (Collection) IndexedCollection.__proto__ = Collection;
          IndexedCollection.prototype = Object.create(Collection && Collection.prototype);
          IndexedCollection.prototype.constructor = IndexedCollection;
          return IndexedCollection;
        }(Collection);
        var SetCollection = /*@__PURE__*/function (Collection) {
          function SetCollection(value) {
            // eslint-disable-next-line no-constructor-return
            return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
          }
          if (Collection) SetCollection.__proto__ = Collection;
          SetCollection.prototype = Object.create(Collection && Collection.prototype);
          SetCollection.prototype.constructor = SetCollection;
          return SetCollection;
        }(Collection);
        Collection.Keyed = KeyedCollection;
        Collection.Indexed = IndexedCollection;
        Collection.Set = SetCollection;
        var IS_SEQ_SYMBOL = '@@__IMMUTABLE_SEQ__@@';
        function isSeq(maybeSeq) {
          return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
        }
        var IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';
        function isRecord(maybeRecord) {
          return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
        }
        function isImmutable$2(maybeImmutable) {
          return isCollection(maybeImmutable) || isRecord(maybeImmutable);
        }
        var IS_ORDERED_SYMBOL = '@@__IMMUTABLE_ORDERED__@@';
        function isOrdered(maybeOrdered) {
          return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
        }
        var ITERATE_KEYS = 0;
        var ITERATE_VALUES = 1;
        var ITERATE_ENTRIES = 2;
        var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
        var Iterator = function Iterator(next) {
          this.next = next;
        };
        Iterator.prototype.toString = function toString() {
          return '[Iterator]';
        };
        Iterator.KEYS = ITERATE_KEYS;
        Iterator.VALUES = ITERATE_VALUES;
        Iterator.ENTRIES = ITERATE_ENTRIES;
        Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
          return this.toString();
        };
        Iterator.prototype[ITERATOR_SYMBOL] = function () {
          return this;
        };
        function iteratorValue(type, k, v, iteratorResult) {
          var value = type === 0 ? k : type === 1 ? v : [k, v];
          iteratorResult ? iteratorResult.value = value : iteratorResult = {
            value: value,
            done: false
          };
          return iteratorResult;
        }
        function iteratorDone() {
          return {
            value: undefined,
            done: true
          };
        }
        function hasIterator(maybeIterable) {
          if (Array.isArray(maybeIterable)) {
            // IE11 trick as it does not support `Symbol.iterator`
            return true;
          }
          return !!getIteratorFn(maybeIterable);
        }
        function isIterator(maybeIterator) {
          return maybeIterator && typeof maybeIterator.next === 'function';
        }
        function getIterator(iterable) {
          var iteratorFn = getIteratorFn(iterable);
          return iteratorFn && iteratorFn.call(iterable);
        }
        function getIteratorFn(iterable) {
          var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === 'function') {
            return iteratorFn;
          }
        }
        function isEntriesIterable(maybeIterable) {
          var iteratorFn = getIteratorFn(maybeIterable);
          return iteratorFn && iteratorFn === maybeIterable.entries;
        }
        function isKeysIterable(maybeIterable) {
          var iteratorFn = getIteratorFn(maybeIterable);
          return iteratorFn && iteratorFn === maybeIterable.keys;
        }
        var hasOwnProperty$g = Object.prototype.hasOwnProperty;
        function isArrayLike$6(value) {
          if (Array.isArray(value) || typeof value === 'string') {
            return true;
          }
          return value && typeof value === 'object' && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ?
          // Only {length: 0} is considered Array-like.
          Object.keys(value).length === 1 :
          // An object is only Array-like if it has a property where the last value
          // in the array-like may be found (which could be undefined).
          value.hasOwnProperty(value.length - 1));
        }
        var Seq = /*@__PURE__*/function (Collection) {
          function Seq(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptySequence() : isImmutable$2(value) ? value.toSeq() : seqFromValue(value);
          }
          if (Collection) Seq.__proto__ = Collection;
          Seq.prototype = Object.create(Collection && Collection.prototype);
          Seq.prototype.constructor = Seq;
          Seq.prototype.toSeq = function toSeq() {
            return this;
          };
          Seq.prototype.toString = function toString() {
            return this.__toString('Seq {', '}');
          };
          Seq.prototype.cacheResult = function cacheResult() {
            if (!this._cache && this.__iterateUncached) {
              this._cache = this.entrySeq().toArray();
              this.size = this._cache.length;
            }
            return this;
          };

          // abstract __iterateUncached(fn, reverse)

          Seq.prototype.__iterate = function __iterate(fn, reverse) {
            var cache = this._cache;
            if (cache) {
              var size = cache.length;
              var i = 0;
              while (i !== size) {
                var entry = cache[reverse ? size - ++i : i++];
                if (fn(entry[1], entry[0], this) === false) {
                  break;
                }
              }
              return i;
            }
            return this.__iterateUncached(fn, reverse);
          };

          // abstract __iteratorUncached(type, reverse)

          Seq.prototype.__iterator = function __iterator(type, reverse) {
            var cache = this._cache;
            if (cache) {
              var size = cache.length;
              var i = 0;
              return new Iterator(function () {
                if (i === size) {
                  return iteratorDone();
                }
                var entry = cache[reverse ? size - ++i : i++];
                return iteratorValue(type, entry[0], entry[1]);
              });
            }
            return this.__iteratorUncached(type, reverse);
          };
          return Seq;
        }(Collection);
        var KeyedSeq = /*@__PURE__*/function (Seq) {
          function KeyedSeq(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
          }
          if (Seq) KeyedSeq.__proto__ = Seq;
          KeyedSeq.prototype = Object.create(Seq && Seq.prototype);
          KeyedSeq.prototype.constructor = KeyedSeq;
          KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq() {
            return this;
          };
          return KeyedSeq;
        }(Seq);
        var IndexedSeq = /*@__PURE__*/function (Seq) {
          function IndexedSeq(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
          }
          if (Seq) IndexedSeq.__proto__ = Seq;
          IndexedSeq.prototype = Object.create(Seq && Seq.prototype);
          IndexedSeq.prototype.constructor = IndexedSeq;
          IndexedSeq.of = function of(/*...values*/
          ) {
            return IndexedSeq(arguments);
          };
          IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq() {
            return this;
          };
          IndexedSeq.prototype.toString = function toString() {
            return this.__toString('Seq [', ']');
          };
          return IndexedSeq;
        }(Seq);
        var SetSeq = /*@__PURE__*/function (Seq) {
          function SetSeq(value) {
            // eslint-disable-next-line no-constructor-return
            return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
          }
          if (Seq) SetSeq.__proto__ = Seq;
          SetSeq.prototype = Object.create(Seq && Seq.prototype);
          SetSeq.prototype.constructor = SetSeq;
          SetSeq.of = function of(/*...values*/
          ) {
            return SetSeq(arguments);
          };
          SetSeq.prototype.toSetSeq = function toSetSeq() {
            return this;
          };
          return SetSeq;
        }(Seq);
        Seq.isSeq = isSeq;
        Seq.Keyed = KeyedSeq;
        Seq.Set = SetSeq;
        Seq.Indexed = IndexedSeq;
        Seq.prototype[IS_SEQ_SYMBOL] = true;

        // #pragma Root Sequences

        var ArraySeq = /*@__PURE__*/function (IndexedSeq) {
          function ArraySeq(array) {
            this._array = array;
            this.size = array.length;
          }
          if (IndexedSeq) ArraySeq.__proto__ = IndexedSeq;
          ArraySeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
          ArraySeq.prototype.constructor = ArraySeq;
          ArraySeq.prototype.get = function get(index, notSetValue) {
            return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
          };
          ArraySeq.prototype.__iterate = function __iterate(fn, reverse) {
            var array = this._array;
            var size = array.length;
            var i = 0;
            while (i !== size) {
              var ii = reverse ? size - ++i : i++;
              if (fn(array[ii], ii, this) === false) {
                break;
              }
            }
            return i;
          };
          ArraySeq.prototype.__iterator = function __iterator(type, reverse) {
            var array = this._array;
            var size = array.length;
            var i = 0;
            return new Iterator(function () {
              if (i === size) {
                return iteratorDone();
              }
              var ii = reverse ? size - ++i : i++;
              return iteratorValue(type, ii, array[ii]);
            });
          };
          return ArraySeq;
        }(IndexedSeq);
        var ObjectSeq = /*@__PURE__*/function (KeyedSeq) {
          function ObjectSeq(object) {
            var keys = Object.keys(object).concat(Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : []);
            this._object = object;
            this._keys = keys;
            this.size = keys.length;
          }
          if (KeyedSeq) ObjectSeq.__proto__ = KeyedSeq;
          ObjectSeq.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);
          ObjectSeq.prototype.constructor = ObjectSeq;
          ObjectSeq.prototype.get = function get(key, notSetValue) {
            if (notSetValue !== undefined && !this.has(key)) {
              return notSetValue;
            }
            return this._object[key];
          };
          ObjectSeq.prototype.has = function has(key) {
            return hasOwnProperty$g.call(this._object, key);
          };
          ObjectSeq.prototype.__iterate = function __iterate(fn, reverse) {
            var object = this._object;
            var keys = this._keys;
            var size = keys.length;
            var i = 0;
            while (i !== size) {
              var key = keys[reverse ? size - ++i : i++];
              if (fn(object[key], key, this) === false) {
                break;
              }
            }
            return i;
          };
          ObjectSeq.prototype.__iterator = function __iterator(type, reverse) {
            var object = this._object;
            var keys = this._keys;
            var size = keys.length;
            var i = 0;
            return new Iterator(function () {
              if (i === size) {
                return iteratorDone();
              }
              var key = keys[reverse ? size - ++i : i++];
              return iteratorValue(type, key, object[key]);
            });
          };
          return ObjectSeq;
        }(KeyedSeq);
        ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;
        var CollectionSeq = /*@__PURE__*/function (IndexedSeq) {
          function CollectionSeq(collection) {
            this._collection = collection;
            this.size = collection.length || collection.size;
          }
          if (IndexedSeq) CollectionSeq.__proto__ = IndexedSeq;
          CollectionSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
          CollectionSeq.prototype.constructor = CollectionSeq;
          CollectionSeq.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {
            if (reverse) {
              return this.cacheResult().__iterate(fn, reverse);
            }
            var collection = this._collection;
            var iterator = getIterator(collection);
            var iterations = 0;
            if (isIterator(iterator)) {
              var step;
              while (!(step = iterator.next()).done) {
                if (fn(step.value, iterations++, this) === false) {
                  break;
                }
              }
            }
            return iterations;
          };
          CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached(type, reverse) {
            if (reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            var collection = this._collection;
            var iterator = getIterator(collection);
            if (!isIterator(iterator)) {
              return new Iterator(iteratorDone);
            }
            var iterations = 0;
            return new Iterator(function () {
              var step = iterator.next();
              return step.done ? step : iteratorValue(type, iterations++, step.value);
            });
          };
          return CollectionSeq;
        }(IndexedSeq);

        // # pragma Helper functions

        var EMPTY_SEQ;
        function emptySequence() {
          return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
        }
        function keyedSeqFromValue(value) {
          var seq = maybeIndexedSeqFromValue(value);
          if (seq) {
            return seq.fromEntrySeq();
          }
          if (typeof value === 'object') {
            return new ObjectSeq(value);
          }
          throw new TypeError('Expected Array or collection object of [k, v] entries, or keyed object: ' + value);
        }
        function indexedSeqFromValue(value) {
          var seq = maybeIndexedSeqFromValue(value);
          if (seq) {
            return seq;
          }
          throw new TypeError('Expected Array or collection object of values: ' + value);
        }
        function seqFromValue(value) {
          var seq = maybeIndexedSeqFromValue(value);
          if (seq) {
            return isEntriesIterable(value) ? seq.fromEntrySeq() : isKeysIterable(value) ? seq.toSetSeq() : seq;
          }
          if (typeof value === 'object') {
            return new ObjectSeq(value);
          }
          throw new TypeError('Expected Array or collection object of values, or keyed object: ' + value);
        }
        function maybeIndexedSeqFromValue(value) {
          return isArrayLike$6(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;
        }
        var IS_MAP_SYMBOL = '@@__IMMUTABLE_MAP__@@';
        function isMap$2(maybeMap) {
          return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
        }
        function isOrderedMap(maybeOrderedMap) {
          return isMap$2(maybeOrderedMap) && isOrdered(maybeOrderedMap);
        }
        function isValueObject(maybeValue) {
          return Boolean(maybeValue && typeof maybeValue.equals === 'function' && typeof maybeValue.hashCode === 'function');
        }

        /**
         * An extension of the "same-value" algorithm as [described for use by ES6 Map
         * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
         *
         * NaN is considered the same as NaN, however -0 and 0 are considered the same
         * value, which is different from the algorithm described by
         * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
         *
         * This is extended further to allow Objects to describe the values they
         * represent, by way of `valueOf` or `equals` (and `hashCode`).
         *
         * Note: because of this extension, the key equality of Immutable.Map and the
         * value equality of Immutable.Set will differ from ES6 Map and Set.
         *
         * ### Defining custom values
         *
         * The easiest way to describe the value an object represents is by implementing
         * `valueOf`. For example, `Date` represents a value by returning a unix
         * timestamp for `valueOf`:
         *
         *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
         *     var date2 = new Date(1234567890000);
         *     date1.valueOf(); // 1234567890000
         *     assert( date1 !== date2 );
         *     assert( Immutable.is( date1, date2 ) );
         *
         * Note: overriding `valueOf` may have other implications if you use this object
         * where JavaScript expects a primitive, such as implicit string coercion.
         *
         * For more complex types, especially collections, implementing `valueOf` may
         * not be performant. An alternative is to implement `equals` and `hashCode`.
         *
         * `equals` takes another object, presumably of similar type, and returns true
         * if it is equal. Equality is symmetrical, so the same result should be
         * returned if this and the argument are flipped.
         *
         *     assert( a.equals(b) === b.equals(a) );
         *
         * `hashCode` returns a 32bit integer number representing the object which will
         * be used to determine how to store the value object in a Map or Set. You must
         * provide both or neither methods, one must not exist without the other.
         *
         * Also, an important relationship between these methods must be upheld: if two
         * values are equal, they *must* return the same hashCode. If the values are not
         * equal, they might have the same hashCode; this is called a hash collision,
         * and while undesirable for performance reasons, it is acceptable.
         *
         *     if (a.equals(b)) {
         *       assert( a.hashCode() === b.hashCode() );
         *     }
         *
         * All Immutable collections are Value Objects: they implement `equals()`
         * and `hashCode()`.
         */
        function is(valueA, valueB) {
          if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
            return true;
          }
          if (!valueA || !valueB) {
            return false;
          }
          if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {
            valueA = valueA.valueOf();
            valueB = valueB.valueOf();
            if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
              return true;
            }
            if (!valueA || !valueB) {
              return false;
            }
          }
          return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
        }
        var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {
          a |= 0; // int
          b |= 0; // int
          var c = a & 0xffff;
          var d = b & 0xffff;
          // Shift by 0 fixes the sign on the high part.
          return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int
        };

        // v8 has an optimization for storing 31-bit signed numbers.
        // Values which have either 00 or 11 as the high order bits qualify.
        // This function drops the highest order bit in a signed number, maintaining
        // the sign bit.
        function smi(i32) {
          return i32 >>> 1 & 0x40000000 | i32 & 0xbfffffff;
        }
        var defaultValueOf = Object.prototype.valueOf;
        function hash(o) {
          if (o == null) {
            return hashNullish(o);
          }
          if (typeof o.hashCode === 'function') {
            // Drop any high bits from accidentally long hash codes.
            return smi(o.hashCode(o));
          }
          var v = valueOf(o);
          if (v == null) {
            return hashNullish(v);
          }
          switch (typeof v) {
            case 'boolean':
              // The hash values for built-in constants are a 1 value for each 5-byte
              // shift region expect for the first, which encodes the value. This
              // reduces the odds of a hash collision for these common values.
              return v ? 0x42108421 : 0x42108420;
            case 'number':
              return hashNumber(v);
            case 'string':
              return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);
            case 'object':
            case 'function':
              return hashJSObj(v);
            case 'symbol':
              return hashSymbol(v);
            default:
              if (typeof v.toString === 'function') {
                return hashString(v.toString());
              }
              throw new Error('Value type ' + typeof v + ' cannot be hashed.');
          }
        }
        function hashNullish(nullish) {
          return nullish === null ? 0x42108422 : /* undefined */0x42108423;
        }

        // Compress arbitrarily large numbers into smi hashes.
        function hashNumber(n) {
          if (n !== n || n === Infinity) {
            return 0;
          }
          var hash = n | 0;
          if (hash !== n) {
            hash ^= n * 0xffffffff;
          }
          while (n > 0xffffffff) {
            n /= 0xffffffff;
            hash ^= n;
          }
          return smi(hash);
        }
        function cachedHashString(string) {
          var hashed = stringHashCache[string];
          if (hashed === undefined) {
            hashed = hashString(string);
            if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
              STRING_HASH_CACHE_SIZE = 0;
              stringHashCache = {};
            }
            STRING_HASH_CACHE_SIZE++;
            stringHashCache[string] = hashed;
          }
          return hashed;
        }

        // http://jsperf.com/hashing-strings
        function hashString(string) {
          // This is the hash from JVM
          // The hash code for a string is computed as
          // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
          // where s[i] is the ith character of the string and n is the length of
          // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
          // (exclusive) by dropping high bits.
          var hashed = 0;
          for (var ii = 0; ii < string.length; ii++) {
            hashed = 31 * hashed + string.charCodeAt(ii) | 0;
          }
          return smi(hashed);
        }
        function hashSymbol(sym) {
          var hashed = symbolMap[sym];
          if (hashed !== undefined) {
            return hashed;
          }
          hashed = nextHash();
          symbolMap[sym] = hashed;
          return hashed;
        }
        function hashJSObj(obj) {
          var hashed;
          if (usingWeakMap) {
            hashed = weakMap.get(obj);
            if (hashed !== undefined) {
              return hashed;
            }
          }
          hashed = obj[UID_HASH_KEY];
          if (hashed !== undefined) {
            return hashed;
          }
          if (!canDefineProperty) {
            hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
            if (hashed !== undefined) {
              return hashed;
            }
            hashed = getIENodeHash(obj);
            if (hashed !== undefined) {
              return hashed;
            }
          }
          hashed = nextHash();
          if (usingWeakMap) {
            weakMap.set(obj, hashed);
          } else if (isExtensible !== undefined && isExtensible(obj) === false) {
            throw new Error('Non-extensible objects are not allowed as keys.');
          } else if (canDefineProperty) {
            Object.defineProperty(obj, UID_HASH_KEY, {
              enumerable: false,
              configurable: false,
              writable: false,
              value: hashed
            });
          } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
            // Since we can't define a non-enumerable property on the object
            // we'll hijack one of the less-used non-enumerable properties to
            // save our hash on it. Since this is a function it will not show up in
            // `JSON.stringify` which is what we want.
            obj.propertyIsEnumerable = function () {
              return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
            };
            obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
          } else if (obj.nodeType !== undefined) {
            // At this point we couldn't get the IE `uniqueID` to use as a hash
            // and we couldn't use a non-enumerable property to exploit the
            // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
            // itself.
            obj[UID_HASH_KEY] = hashed;
          } else {
            throw new Error('Unable to set a non-enumerable property on object.');
          }
          return hashed;
        }

        // Get references to ES5 object methods.
        var isExtensible = Object.isExtensible;

        // True if Object.defineProperty works as expected. IE8 fails this test.
        var canDefineProperty = function () {
          try {
            Object.defineProperty({}, '@', {});
            return true;
          } catch (e) {
            return false;
          }
        }();

        // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
        // and avoid memory leaks from the IE cloneNode bug.
        function getIENodeHash(node) {
          if (node && node.nodeType > 0) {
            switch (node.nodeType) {
              case 1:
                // Element
                return node.uniqueID;
              case 9:
                // Document
                return node.documentElement && node.documentElement.uniqueID;
            }
          }
        }
        function valueOf(obj) {
          return obj.valueOf !== defaultValueOf && typeof obj.valueOf === 'function' ? obj.valueOf(obj) : obj;
        }
        function nextHash() {
          var nextHash = ++_objHashUID;
          if (_objHashUID & 0x40000000) {
            _objHashUID = 0;
          }
          return nextHash;
        }

        // If possible, use a WeakMap.
        var usingWeakMap = typeof WeakMap === 'function';
        var weakMap;
        if (usingWeakMap) {
          weakMap = new WeakMap();
        }
        var symbolMap = Object.create(null);
        var _objHashUID = 0;
        var UID_HASH_KEY = '__immutablehash__';
        if (typeof Symbol === 'function') {
          UID_HASH_KEY = Symbol(UID_HASH_KEY);
        }
        var STRING_HASH_CACHE_MIN_STRLEN = 16;
        var STRING_HASH_CACHE_MAX_SIZE = 255;
        var STRING_HASH_CACHE_SIZE = 0;
        var stringHashCache = {};
        var ToKeyedSequence = /*@__PURE__*/function (KeyedSeq) {
          function ToKeyedSequence(indexed, useKeys) {
            this._iter = indexed;
            this._useKeys = useKeys;
            this.size = indexed.size;
          }
          if (KeyedSeq) ToKeyedSequence.__proto__ = KeyedSeq;
          ToKeyedSequence.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);
          ToKeyedSequence.prototype.constructor = ToKeyedSequence;
          ToKeyedSequence.prototype.get = function get(key, notSetValue) {
            return this._iter.get(key, notSetValue);
          };
          ToKeyedSequence.prototype.has = function has(key) {
            return this._iter.has(key);
          };
          ToKeyedSequence.prototype.valueSeq = function valueSeq() {
            return this._iter.valueSeq();
          };
          ToKeyedSequence.prototype.reverse = function reverse() {
            var this$1$1 = this;
            var reversedSequence = reverseFactory(this, true);
            if (!this._useKeys) {
              reversedSequence.valueSeq = function () {
                return this$1$1._iter.toSeq().reverse();
              };
            }
            return reversedSequence;
          };
          ToKeyedSequence.prototype.map = function map(mapper, context) {
            var this$1$1 = this;
            var mappedSequence = mapFactory(this, mapper, context);
            if (!this._useKeys) {
              mappedSequence.valueSeq = function () {
                return this$1$1._iter.toSeq().map(mapper, context);
              };
            }
            return mappedSequence;
          };
          ToKeyedSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            return this._iter.__iterate(function (v, k) {
              return fn(v, k, this$1$1);
            }, reverse);
          };
          ToKeyedSequence.prototype.__iterator = function __iterator(type, reverse) {
            return this._iter.__iterator(type, reverse);
          };
          return ToKeyedSequence;
        }(KeyedSeq);
        ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;
        var ToIndexedSequence = /*@__PURE__*/function (IndexedSeq) {
          function ToIndexedSequence(iter) {
            this._iter = iter;
            this.size = iter.size;
          }
          if (IndexedSeq) ToIndexedSequence.__proto__ = IndexedSeq;
          ToIndexedSequence.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
          ToIndexedSequence.prototype.constructor = ToIndexedSequence;
          ToIndexedSequence.prototype.includes = function includes(value) {
            return this._iter.includes(value);
          };
          ToIndexedSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            var i = 0;
            reverse && ensureSize(this);
            return this._iter.__iterate(function (v) {
              return fn(v, reverse ? this$1$1.size - ++i : i++, this$1$1);
            }, reverse);
          };
          ToIndexedSequence.prototype.__iterator = function __iterator(type, reverse) {
            var this$1$1 = this;
            var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
            var i = 0;
            reverse && ensureSize(this);
            return new Iterator(function () {
              var step = iterator.next();
              return step.done ? step : iteratorValue(type, reverse ? this$1$1.size - ++i : i++, step.value, step);
            });
          };
          return ToIndexedSequence;
        }(IndexedSeq);
        var ToSetSequence = /*@__PURE__*/function (SetSeq) {
          function ToSetSequence(iter) {
            this._iter = iter;
            this.size = iter.size;
          }
          if (SetSeq) ToSetSequence.__proto__ = SetSeq;
          ToSetSequence.prototype = Object.create(SetSeq && SetSeq.prototype);
          ToSetSequence.prototype.constructor = ToSetSequence;
          ToSetSequence.prototype.has = function has(key) {
            return this._iter.includes(key);
          };
          ToSetSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            return this._iter.__iterate(function (v) {
              return fn(v, v, this$1$1);
            }, reverse);
          };
          ToSetSequence.prototype.__iterator = function __iterator(type, reverse) {
            var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
            return new Iterator(function () {
              var step = iterator.next();
              return step.done ? step : iteratorValue(type, step.value, step.value, step);
            });
          };
          return ToSetSequence;
        }(SetSeq);
        var FromEntriesSequence = /*@__PURE__*/function (KeyedSeq) {
          function FromEntriesSequence(entries) {
            this._iter = entries;
            this.size = entries.size;
          }
          if (KeyedSeq) FromEntriesSequence.__proto__ = KeyedSeq;
          FromEntriesSequence.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);
          FromEntriesSequence.prototype.constructor = FromEntriesSequence;
          FromEntriesSequence.prototype.entrySeq = function entrySeq() {
            return this._iter.toSeq();
          };
          FromEntriesSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            return this._iter.__iterate(function (entry) {
              // Check if entry exists first so array access doesn't throw for holes
              // in the parent iteration.
              if (entry) {
                validateEntry(entry);
                var indexedCollection = isCollection(entry);
                return fn(indexedCollection ? entry.get(1) : entry[1], indexedCollection ? entry.get(0) : entry[0], this$1$1);
              }
            }, reverse);
          };
          FromEntriesSequence.prototype.__iterator = function __iterator(type, reverse) {
            var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
            return new Iterator(function () {
              while (true) {
                var step = iterator.next();
                if (step.done) {
                  return step;
                }
                var entry = step.value;
                // Check if entry exists first so array access doesn't throw for holes
                // in the parent iteration.
                if (entry) {
                  validateEntry(entry);
                  var indexedCollection = isCollection(entry);
                  return iteratorValue(type, indexedCollection ? entry.get(0) : entry[0], indexedCollection ? entry.get(1) : entry[1], step);
                }
              }
            });
          };
          return FromEntriesSequence;
        }(KeyedSeq);
        ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
        function flipFactory(collection) {
          var flipSequence = makeSequence(collection);
          flipSequence._iter = collection;
          flipSequence.size = collection.size;
          flipSequence.flip = function () {
            return collection;
          };
          flipSequence.reverse = function () {
            var reversedSequence = collection.reverse.apply(this); // super.reverse()
            reversedSequence.flip = function () {
              return collection.reverse();
            };
            return reversedSequence;
          };
          flipSequence.has = function (key) {
            return collection.includes(key);
          };
          flipSequence.includes = function (key) {
            return collection.has(key);
          };
          flipSequence.cacheResult = cacheResultThrough;
          flipSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this;
            return collection.__iterate(function (v, k) {
              return fn(k, v, this$1$1) !== false;
            }, reverse);
          };
          flipSequence.__iteratorUncached = function (type, reverse) {
            if (type === ITERATE_ENTRIES) {
              var iterator = collection.__iterator(type, reverse);
              return new Iterator(function () {
                var step = iterator.next();
                if (!step.done) {
                  var k = step.value[0];
                  step.value[0] = step.value[1];
                  step.value[1] = k;
                }
                return step;
              });
            }
            return collection.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
          };
          return flipSequence;
        }
        function mapFactory(collection, mapper, context) {
          var mappedSequence = makeSequence(collection);
          mappedSequence.size = collection.size;
          mappedSequence.has = function (key) {
            return collection.has(key);
          };
          mappedSequence.get = function (key, notSetValue) {
            var v = collection.get(key, NOT_SET);
            return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);
          };
          mappedSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this;
            return collection.__iterate(function (v, k, c) {
              return fn(mapper.call(context, v, k, c), k, this$1$1) !== false;
            }, reverse);
          };
          mappedSequence.__iteratorUncached = function (type, reverse) {
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            return new Iterator(function () {
              var step = iterator.next();
              if (step.done) {
                return step;
              }
              var entry = step.value;
              var key = entry[0];
              return iteratorValue(type, key, mapper.call(context, entry[1], key, collection), step);
            });
          };
          return mappedSequence;
        }
        function reverseFactory(collection, useKeys) {
          var this$1$1 = this;
          var reversedSequence = makeSequence(collection);
          reversedSequence._iter = collection;
          reversedSequence.size = collection.size;
          reversedSequence.reverse = function () {
            return collection;
          };
          if (collection.flip) {
            reversedSequence.flip = function () {
              var flipSequence = flipFactory(collection);
              flipSequence.reverse = function () {
                return collection.flip();
              };
              return flipSequence;
            };
          }
          reversedSequence.get = function (key, notSetValue) {
            return collection.get(useKeys ? key : -1 - key, notSetValue);
          };
          reversedSequence.has = function (key) {
            return collection.has(useKeys ? key : -1 - key);
          };
          reversedSequence.includes = function (value) {
            return collection.includes(value);
          };
          reversedSequence.cacheResult = cacheResultThrough;
          reversedSequence.__iterate = function (fn, reverse) {
            var this$1$1 = this;
            var i = 0;
            reverse && ensureSize(collection);
            return collection.__iterate(function (v, k) {
              return fn(v, useKeys ? k : reverse ? this$1$1.size - ++i : i++, this$1$1);
            }, !reverse);
          };
          reversedSequence.__iterator = function (type, reverse) {
            var i = 0;
            reverse && ensureSize(collection);
            var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);
            return new Iterator(function () {
              var step = iterator.next();
              if (step.done) {
                return step;
              }
              var entry = step.value;
              return iteratorValue(type, useKeys ? entry[0] : reverse ? this$1$1.size - ++i : i++, entry[1], step);
            });
          };
          return reversedSequence;
        }
        function filterFactory(collection, predicate, context, useKeys) {
          var filterSequence = makeSequence(collection);
          if (useKeys) {
            filterSequence.has = function (key) {
              var v = collection.get(key, NOT_SET);
              return v !== NOT_SET && !!predicate.call(context, v, key, collection);
            };
            filterSequence.get = function (key, notSetValue) {
              var v = collection.get(key, NOT_SET);
              return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;
            };
          }
          filterSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this;
            var iterations = 0;
            collection.__iterate(function (v, k, c) {
              if (predicate.call(context, v, k, c)) {
                iterations++;
                return fn(v, useKeys ? k : iterations - 1, this$1$1);
              }
            }, reverse);
            return iterations;
          };
          filterSequence.__iteratorUncached = function (type, reverse) {
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            var iterations = 0;
            return new Iterator(function () {
              while (true) {
                var step = iterator.next();
                if (step.done) {
                  return step;
                }
                var entry = step.value;
                var key = entry[0];
                var value = entry[1];
                if (predicate.call(context, value, key, collection)) {
                  return iteratorValue(type, useKeys ? key : iterations++, value, step);
                }
              }
            });
          };
          return filterSequence;
        }
        function countByFactory(collection, grouper, context) {
          var groups = Map$2().asMutable();
          collection.__iterate(function (v, k) {
            groups.update(grouper.call(context, v, k, collection), 0, function (a) {
              return a + 1;
            });
          });
          return groups.asImmutable();
        }
        function groupByFactory(collection, grouper, context) {
          var isKeyedIter = isKeyed(collection);
          var groups = (isOrdered(collection) ? OrderedMap() : Map$2()).asMutable();
          collection.__iterate(function (v, k) {
            groups.update(grouper.call(context, v, k, collection), function (a) {
              return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
            });
          });
          var coerce = collectionClass(collection);
          return groups.map(function (arr) {
            return reify(collection, coerce(arr));
          }).asImmutable();
        }
        function partitionFactory(collection, predicate, context) {
          var isKeyedIter = isKeyed(collection);
          var groups = [[], []];
          collection.__iterate(function (v, k) {
            groups[predicate.call(context, v, k, collection) ? 1 : 0].push(isKeyedIter ? [k, v] : v);
          });
          var coerce = collectionClass(collection);
          return groups.map(function (arr) {
            return reify(collection, coerce(arr));
          });
        }
        function sliceFactory(collection, begin, end, useKeys) {
          var originalSize = collection.size;
          if (wholeSlice(begin, end, originalSize)) {
            return collection;
          }

          // begin or end can not be resolved if they were provided as negative numbers and
          // this collection's size is unknown. In that case, cache first so there is
          // a known size and these do not resolve to NaN.
          if (typeof originalSize === 'undefined' && (begin < 0 || end < 0)) {
            return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
          }
          var resolvedBegin = resolveBegin(begin, originalSize);
          var resolvedEnd = resolveEnd(end, originalSize);

          // Note: resolvedEnd is undefined when the original sequence's length is
          // unknown and this slice did not supply an end and should contain all
          // elements after resolvedBegin.
          // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
          var resolvedSize = resolvedEnd - resolvedBegin;
          var sliceSize;
          if (resolvedSize === resolvedSize) {
            sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
          }
          var sliceSeq = makeSequence(collection);

          // If collection.size is undefined, the size of the realized sliceSeq is
          // unknown at this point unless the number of items to slice is 0
          sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || undefined;
          if (!useKeys && isSeq(collection) && sliceSize >= 0) {
            sliceSeq.get = function (index, notSetValue) {
              index = wrapIndex(this, index);
              return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;
            };
          }
          sliceSeq.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this;
            if (sliceSize === 0) {
              return 0;
            }
            if (reverse) {
              return this.cacheResult().__iterate(fn, reverse);
            }
            var skipped = 0;
            var isSkipping = true;
            var iterations = 0;
            collection.__iterate(function (v, k) {
              if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
                iterations++;
                return fn(v, useKeys ? k : iterations - 1, this$1$1) !== false && iterations !== sliceSize;
              }
            });
            return iterations;
          };
          sliceSeq.__iteratorUncached = function (type, reverse) {
            if (sliceSize !== 0 && reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            // Don't bother instantiating parent iterator if taking 0.
            if (sliceSize === 0) {
              return new Iterator(iteratorDone);
            }
            var iterator = collection.__iterator(type, reverse);
            var skipped = 0;
            var iterations = 0;
            return new Iterator(function () {
              while (skipped++ < resolvedBegin) {
                iterator.next();
              }
              if (++iterations > sliceSize) {
                return iteratorDone();
              }
              var step = iterator.next();
              if (useKeys || type === ITERATE_VALUES || step.done) {
                return step;
              }
              if (type === ITERATE_KEYS) {
                return iteratorValue(type, iterations - 1, undefined, step);
              }
              return iteratorValue(type, iterations - 1, step.value[1], step);
            });
          };
          return sliceSeq;
        }
        function takeWhileFactory(collection, predicate, context) {
          var takeSequence = makeSequence(collection);
          takeSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this;
            if (reverse) {
              return this.cacheResult().__iterate(fn, reverse);
            }
            var iterations = 0;
            collection.__iterate(function (v, k, c) {
              return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1$1);
            });
            return iterations;
          };
          takeSequence.__iteratorUncached = function (type, reverse) {
            var this$1$1 = this;
            if (reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            var iterating = true;
            return new Iterator(function () {
              if (!iterating) {
                return iteratorDone();
              }
              var step = iterator.next();
              if (step.done) {
                return step;
              }
              var entry = step.value;
              var k = entry[0];
              var v = entry[1];
              if (!predicate.call(context, v, k, this$1$1)) {
                iterating = false;
                return iteratorDone();
              }
              return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
            });
          };
          return takeSequence;
        }
        function skipWhileFactory(collection, predicate, context, useKeys) {
          var skipSequence = makeSequence(collection);
          skipSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this;
            if (reverse) {
              return this.cacheResult().__iterate(fn, reverse);
            }
            var isSkipping = true;
            var iterations = 0;
            collection.__iterate(function (v, k, c) {
              if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
                iterations++;
                return fn(v, useKeys ? k : iterations - 1, this$1$1);
              }
            });
            return iterations;
          };
          skipSequence.__iteratorUncached = function (type, reverse) {
            var this$1$1 = this;
            if (reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            var skipping = true;
            var iterations = 0;
            return new Iterator(function () {
              var step;
              var k;
              var v;
              do {
                step = iterator.next();
                if (step.done) {
                  if (useKeys || type === ITERATE_VALUES) {
                    return step;
                  }
                  if (type === ITERATE_KEYS) {
                    return iteratorValue(type, iterations++, undefined, step);
                  }
                  return iteratorValue(type, iterations++, step.value[1], step);
                }
                var entry = step.value;
                k = entry[0];
                v = entry[1];
                skipping && (skipping = predicate.call(context, v, k, this$1$1));
              } while (skipping);
              return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
            });
          };
          return skipSequence;
        }
        function concatFactory(collection, values) {
          var isKeyedCollection = isKeyed(collection);
          var iters = [collection].concat(values).map(function (v) {
            if (!isCollection(v)) {
              v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
            } else if (isKeyedCollection) {
              v = KeyedCollection(v);
            }
            return v;
          }).filter(function (v) {
            return v.size !== 0;
          });
          if (iters.length === 0) {
            return collection;
          }
          if (iters.length === 1) {
            var singleton = iters[0];
            if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
              return singleton;
            }
          }
          var concatSeq = new ArraySeq(iters);
          if (isKeyedCollection) {
            concatSeq = concatSeq.toKeyedSeq();
          } else if (!isIndexed(collection)) {
            concatSeq = concatSeq.toSetSeq();
          }
          concatSeq = concatSeq.flatten(true);
          concatSeq.size = iters.reduce(function (sum, seq) {
            if (sum !== undefined) {
              var size = seq.size;
              if (size !== undefined) {
                return sum + size;
              }
            }
          }, 0);
          return concatSeq;
        }
        function flattenFactory(collection, depth, useKeys) {
          var flatSequence = makeSequence(collection);
          flatSequence.__iterateUncached = function (fn, reverse) {
            if (reverse) {
              return this.cacheResult().__iterate(fn, reverse);
            }
            var iterations = 0;
            var stopped = false;
            function flatDeep(iter, currentDepth) {
              iter.__iterate(function (v, k) {
                if ((!depth || currentDepth < depth) && isCollection(v)) {
                  flatDeep(v, currentDepth + 1);
                } else {
                  iterations++;
                  if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
                    stopped = true;
                  }
                }
                return !stopped;
              }, reverse);
            }
            flatDeep(collection, 0);
            return iterations;
          };
          flatSequence.__iteratorUncached = function (type, reverse) {
            if (reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            var iterator = collection.__iterator(type, reverse);
            var stack = [];
            var iterations = 0;
            return new Iterator(function () {
              while (iterator) {
                var step = iterator.next();
                if (step.done !== false) {
                  iterator = stack.pop();
                  continue;
                }
                var v = step.value;
                if (type === ITERATE_ENTRIES) {
                  v = v[1];
                }
                if ((!depth || stack.length < depth) && isCollection(v)) {
                  stack.push(iterator);
                  iterator = v.__iterator(type, reverse);
                } else {
                  return useKeys ? step : iteratorValue(type, iterations++, v, step);
                }
              }
              return iteratorDone();
            });
          };
          return flatSequence;
        }
        function flatMapFactory(collection, mapper, context) {
          var coerce = collectionClass(collection);
          return collection.toSeq().map(function (v, k) {
            return coerce(mapper.call(context, v, k, collection));
          }).flatten(true);
        }
        function interposeFactory(collection, separator) {
          var interposedSequence = makeSequence(collection);
          interposedSequence.size = collection.size && collection.size * 2 - 1;
          interposedSequence.__iterateUncached = function (fn, reverse) {
            var this$1$1 = this;
            var iterations = 0;
            collection.__iterate(function (v) {
              return (!iterations || fn(separator, iterations++, this$1$1) !== false) && fn(v, iterations++, this$1$1) !== false;
            }, reverse);
            return iterations;
          };
          interposedSequence.__iteratorUncached = function (type, reverse) {
            var iterator = collection.__iterator(ITERATE_VALUES, reverse);
            var iterations = 0;
            var step;
            return new Iterator(function () {
              if (!step || iterations % 2) {
                step = iterator.next();
                if (step.done) {
                  return step;
                }
              }
              return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
            });
          };
          return interposedSequence;
        }
        function sortFactory(collection, comparator, mapper) {
          if (!comparator) {
            comparator = defaultComparator;
          }
          var isKeyedCollection = isKeyed(collection);
          var index = 0;
          var entries = collection.toSeq().map(function (v, k) {
            return [k, v, index++, mapper ? mapper(v, k, collection) : v];
          }).valueSeq().toArray();
          entries.sort(function (a, b) {
            return comparator(a[3], b[3]) || a[2] - b[2];
          }).forEach(isKeyedCollection ? function (v, i) {
            entries[i].length = 2;
          } : function (v, i) {
            entries[i] = v[1];
          });
          return isKeyedCollection ? KeyedSeq(entries) : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);
        }
        function maxFactory(collection, comparator, mapper) {
          if (!comparator) {
            comparator = defaultComparator;
          }
          if (mapper) {
            var entry = collection.toSeq().map(function (v, k) {
              return [v, mapper(v, k, collection)];
            }).reduce(function (a, b) {
              return maxCompare(comparator, a[1], b[1]) ? b : a;
            });
            return entry && entry[0];
          }
          return collection.reduce(function (a, b) {
            return maxCompare(comparator, a, b) ? b : a;
          });
        }
        function maxCompare(comparator, a, b) {
          var comp = comparator(b, a);
          // b is considered the new max if the comparator declares them equal, but
          // they are not equal and b is in fact a nullish value.
          return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;
        }
        function zipWithFactory(keyIter, zipper, iters, zipAll) {
          var zipSequence = makeSequence(keyIter);
          var sizes = new ArraySeq(iters).map(function (i) {
            return i.size;
          });
          zipSequence.size = zipAll ? sizes.max() : sizes.min();
          // Note: this a generic base implementation of __iterate in terms of
          // __iterator which may be more generically useful in the future.
          zipSequence.__iterate = function (fn, reverse) {
            /* generic:
            var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
            var step;
            var iterations = 0;
            while (!(step = iterator.next()).done) {
              iterations++;
              if (fn(step.value[1], step.value[0], this) === false) {
                break;
              }
            }
            return iterations;
            */
            // indexed:
            var iterator = this.__iterator(ITERATE_VALUES, reverse);
            var step;
            var iterations = 0;
            while (!(step = iterator.next()).done) {
              if (fn(step.value, iterations++, this) === false) {
                break;
              }
            }
            return iterations;
          };
          zipSequence.__iteratorUncached = function (type, reverse) {
            var iterators = iters.map(function (i) {
              return i = Collection(i), getIterator(reverse ? i.reverse() : i);
            });
            var iterations = 0;
            var isDone = false;
            return new Iterator(function () {
              var steps;
              if (!isDone) {
                steps = iterators.map(function (i) {
                  return i.next();
                });
                isDone = zipAll ? steps.every(function (s) {
                  return s.done;
                }) : steps.some(function (s) {
                  return s.done;
                });
              }
              if (isDone) {
                return iteratorDone();
              }
              return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {
                return s.value;
              })));
            });
          };
          return zipSequence;
        }

        // #pragma Helper Functions

        function reify(iter, seq) {
          return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
        }
        function validateEntry(entry) {
          if (entry !== Object(entry)) {
            throw new TypeError('Expected [K, V] tuple: ' + entry);
          }
        }
        function collectionClass(collection) {
          return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
        }
        function makeSequence(collection) {
          return Object.create((isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype);
        }
        function cacheResultThrough() {
          if (this._iter.cacheResult) {
            this._iter.cacheResult();
            this.size = this._iter.size;
            return this;
          }
          return Seq.prototype.cacheResult.call(this);
        }
        function defaultComparator(a, b) {
          if (a === undefined && b === undefined) {
            return 0;
          }
          if (a === undefined) {
            return 1;
          }
          if (b === undefined) {
            return -1;
          }
          return a > b ? 1 : a < b ? -1 : 0;
        }
        function arrCopy(arr, offset) {
          offset = offset || 0;
          var len = Math.max(0, arr.length - offset);
          var newArr = new Array(len);
          for (var ii = 0; ii < len; ii++) {
            newArr[ii] = arr[ii + offset];
          }
          return newArr;
        }
        function invariant(condition, error) {
          if (!condition) {
            throw new Error(error);
          }
        }
        function assertNotInfinite(size) {
          invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');
        }
        function coerceKeyPath(keyPath) {
          if (isArrayLike$6(keyPath) && typeof keyPath !== 'string') {
            return keyPath;
          }
          if (isOrdered(keyPath)) {
            return keyPath.toArray();
          }
          throw new TypeError('Invalid keyPath: expected Ordered Collection or Array: ' + keyPath);
        }
        var toString$4 = Object.prototype.toString;
        function isPlainObject$4(value) {
          // The base prototype's toString deals with Argument objects and native namespaces like Math
          if (!value || typeof value !== 'object' || toString$4.call(value) !== '[object Object]') {
            return false;
          }
          var proto = Object.getPrototypeOf(value);
          if (proto === null) {
            return true;
          }

          // Iteratively going up the prototype chain is needed for cross-realm environments (differing contexts, iframes, etc)
          var parentProto = proto;
          var nextProto = Object.getPrototypeOf(proto);
          while (nextProto !== null) {
            parentProto = nextProto;
            nextProto = Object.getPrototypeOf(parentProto);
          }
          return parentProto === proto;
        }

        /**
         * Returns true if the value is a potentially-persistent data structure, either
         * provided by Immutable.js or a plain Array or Object.
         */
        function isDataStructure(value) {
          return typeof value === 'object' && (isImmutable$2(value) || Array.isArray(value) || isPlainObject$4(value));
        }
        function quoteString(value) {
          try {
            return typeof value === 'string' ? JSON.stringify(value) : String(value);
          } catch (_ignoreError) {
            return JSON.stringify(value);
          }
        }
        function has(collection, key) {
          return isImmutable$2(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty$g.call(collection, key);
        }
        function get$5(collection, key, notSetValue) {
          return isImmutable$2(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === 'function' ? collection.get(key) : collection[key];
        }
        function shallowCopy$1(from) {
          if (Array.isArray(from)) {
            return arrCopy(from);
          }
          var to = {};
          for (var key in from) {
            if (hasOwnProperty$g.call(from, key)) {
              to[key] = from[key];
            }
          }
          return to;
        }
        function remove(collection, key) {
          if (!isDataStructure(collection)) {
            throw new TypeError('Cannot update non-data-structure value: ' + collection);
          }
          if (isImmutable$2(collection)) {
            if (!collection.remove) {
              throw new TypeError('Cannot update immutable value without .remove() method: ' + collection);
            }
            return collection.remove(key);
          }
          if (!hasOwnProperty$g.call(collection, key)) {
            return collection;
          }
          var collectionCopy = shallowCopy$1(collection);
          if (Array.isArray(collectionCopy)) {
            collectionCopy.splice(key, 1);
          } else {
            delete collectionCopy[key];
          }
          return collectionCopy;
        }
        function set(collection, key, value) {
          if (!isDataStructure(collection)) {
            throw new TypeError('Cannot update non-data-structure value: ' + collection);
          }
          if (isImmutable$2(collection)) {
            if (!collection.set) {
              throw new TypeError('Cannot update immutable value without .set() method: ' + collection);
            }
            return collection.set(key, value);
          }
          if (hasOwnProperty$g.call(collection, key) && value === collection[key]) {
            return collection;
          }
          var collectionCopy = shallowCopy$1(collection);
          collectionCopy[key] = value;
          return collectionCopy;
        }
        function updateIn$1(collection, keyPath, notSetValue, updater) {
          if (!updater) {
            updater = notSetValue;
            notSetValue = undefined;
          }
          var updatedValue = updateInDeeply(isImmutable$2(collection), collection, coerceKeyPath(keyPath), 0, notSetValue, updater);
          return updatedValue === NOT_SET ? notSetValue : updatedValue;
        }
        function updateInDeeply(inImmutable, existing, keyPath, i, notSetValue, updater) {
          var wasNotSet = existing === NOT_SET;
          if (i === keyPath.length) {
            var existingValue = wasNotSet ? notSetValue : existing;
            var newValue = updater(existingValue);
            return newValue === existingValue ? existing : newValue;
          }
          if (!wasNotSet && !isDataStructure(existing)) {
            throw new TypeError('Cannot update within non-data-structure value in path [' + keyPath.slice(0, i).map(quoteString) + ']: ' + existing);
          }
          var key = keyPath[i];
          var nextExisting = wasNotSet ? NOT_SET : get$5(existing, key, NOT_SET);
          var nextUpdated = updateInDeeply(nextExisting === NOT_SET ? inImmutable : isImmutable$2(nextExisting), nextExisting, keyPath, i + 1, notSetValue, updater);
          return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key) : set(wasNotSet ? inImmutable ? emptyMap() : {} : existing, key, nextUpdated);
        }
        function setIn$1(collection, keyPath, value) {
          return updateIn$1(collection, keyPath, NOT_SET, function () {
            return value;
          });
        }
        function setIn(keyPath, v) {
          return setIn$1(this, keyPath, v);
        }
        function removeIn(collection, keyPath) {
          return updateIn$1(collection, keyPath, function () {
            return NOT_SET;
          });
        }
        function deleteIn(keyPath) {
          return removeIn(this, keyPath);
        }
        function update$1(collection, key, notSetValue, updater) {
          return updateIn$1(collection, [key], notSetValue, updater);
        }
        function update(key, notSetValue, updater) {
          return arguments.length === 1 ? key(this) : update$1(this, key, notSetValue, updater);
        }
        function updateIn(keyPath, notSetValue, updater) {
          return updateIn$1(this, keyPath, notSetValue, updater);
        }
        function merge$1$1() {
          var iters = [],
            len = arguments.length;
          while (len--) iters[len] = arguments[len];
          return mergeIntoKeyedWith(this, iters);
        }
        function mergeWith$1$1(merger) {
          var iters = [],
            len = arguments.length - 1;
          while (len-- > 0) iters[len] = arguments[len + 1];
          if (typeof merger !== 'function') {
            throw new TypeError('Invalid merger function: ' + merger);
          }
          return mergeIntoKeyedWith(this, iters, merger);
        }
        function mergeIntoKeyedWith(collection, collections, merger) {
          var iters = [];
          for (var ii = 0; ii < collections.length; ii++) {
            var collection$1 = KeyedCollection(collections[ii]);
            if (collection$1.size !== 0) {
              iters.push(collection$1);
            }
          }
          if (iters.length === 0) {
            return collection;
          }
          if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {
            return collection.constructor(iters[0]);
          }
          return collection.withMutations(function (collection) {
            var mergeIntoCollection = merger ? function (value, key) {
              update$1(collection, key, NOT_SET, function (oldVal) {
                return oldVal === NOT_SET ? value : merger(oldVal, value, key);
              });
            } : function (value, key) {
              collection.set(key, value);
            };
            for (var ii = 0; ii < iters.length; ii++) {
              iters[ii].forEach(mergeIntoCollection);
            }
          });
        }
        function merge$3(collection) {
          var sources = [],
            len = arguments.length - 1;
          while (len-- > 0) sources[len] = arguments[len + 1];
          return mergeWithSources(collection, sources);
        }
        function mergeWith$2(merger, collection) {
          var sources = [],
            len = arguments.length - 2;
          while (len-- > 0) sources[len] = arguments[len + 2];
          return mergeWithSources(collection, sources, merger);
        }
        function mergeDeep$1(collection) {
          var sources = [],
            len = arguments.length - 1;
          while (len-- > 0) sources[len] = arguments[len + 1];
          return mergeDeepWithSources(collection, sources);
        }
        function mergeDeepWith$1(merger, collection) {
          var sources = [],
            len = arguments.length - 2;
          while (len-- > 0) sources[len] = arguments[len + 2];
          return mergeDeepWithSources(collection, sources, merger);
        }
        function mergeDeepWithSources(collection, sources, merger) {
          return mergeWithSources(collection, sources, deepMergerWith(merger));
        }
        function mergeWithSources(collection, sources, merger) {
          if (!isDataStructure(collection)) {
            throw new TypeError('Cannot merge into non-data-structure value: ' + collection);
          }
          if (isImmutable$2(collection)) {
            return typeof merger === 'function' && collection.mergeWith ? collection.mergeWith.apply(collection, [merger].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);
          }
          var isArray = Array.isArray(collection);
          var merged = collection;
          var Collection = isArray ? IndexedCollection : KeyedCollection;
          var mergeItem = isArray ? function (value) {
            // Copy on write
            if (merged === collection) {
              merged = shallowCopy$1(merged);
            }
            merged.push(value);
          } : function (value, key) {
            var hasVal = hasOwnProperty$g.call(merged, key);
            var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;
            if (!hasVal || nextVal !== merged[key]) {
              // Copy on write
              if (merged === collection) {
                merged = shallowCopy$1(merged);
              }
              merged[key] = nextVal;
            }
          };
          for (var i = 0; i < sources.length; i++) {
            Collection(sources[i]).forEach(mergeItem);
          }
          return merged;
        }
        function deepMergerWith(merger) {
          function deepMerger(oldValue, newValue, key) {
            return isDataStructure(oldValue) && isDataStructure(newValue) && areMergeable(oldValue, newValue) ? mergeWithSources(oldValue, [newValue], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;
          }
          return deepMerger;
        }

        /**
         * It's unclear what the desired behavior is for merging two collections that
         * fall into separate categories between keyed, indexed, or set-like, so we only
         * consider them mergeable if they fall into the same category.
         */
        function areMergeable(oldDataStructure, newDataStructure) {
          var oldSeq = Seq(oldDataStructure);
          var newSeq = Seq(newDataStructure);
          // This logic assumes that a sequence can only fall into one of the three
          // categories mentioned above (since there's no `isSetLike()` method).
          return isIndexed(oldSeq) === isIndexed(newSeq) && isKeyed(oldSeq) === isKeyed(newSeq);
        }
        function mergeDeep() {
          var iters = [],
            len = arguments.length;
          while (len--) iters[len] = arguments[len];
          return mergeDeepWithSources(this, iters);
        }
        function mergeDeepWith(merger) {
          var iters = [],
            len = arguments.length - 1;
          while (len-- > 0) iters[len] = arguments[len + 1];
          return mergeDeepWithSources(this, iters, merger);
        }
        function mergeIn(keyPath) {
          var iters = [],
            len = arguments.length - 1;
          while (len-- > 0) iters[len] = arguments[len + 1];
          return updateIn$1(this, keyPath, emptyMap(), function (m) {
            return mergeWithSources(m, iters);
          });
        }
        function mergeDeepIn(keyPath) {
          var iters = [],
            len = arguments.length - 1;
          while (len-- > 0) iters[len] = arguments[len + 1];
          return updateIn$1(this, keyPath, emptyMap(), function (m) {
            return mergeDeepWithSources(m, iters);
          });
        }
        function withMutations(fn) {
          var mutable = this.asMutable();
          fn(mutable);
          return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
        }
        function asMutable() {
          return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
        }
        function asImmutable() {
          return this.__ensureOwner();
        }
        function wasAltered() {
          return this.__altered;
        }
        var Map$2 = /*@__PURE__*/function (KeyedCollection) {
          function Map(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptyMap() : isMap$2(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {
              var iter = KeyedCollection(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v, k) {
                return map.set(k, v);
              });
            });
          }
          if (KeyedCollection) Map.__proto__ = KeyedCollection;
          Map.prototype = Object.create(KeyedCollection && KeyedCollection.prototype);
          Map.prototype.constructor = Map;
          Map.of = function of() {
            var keyValues = [],
              len = arguments.length;
            while (len--) keyValues[len] = arguments[len];
            return emptyMap().withMutations(function (map) {
              for (var i = 0; i < keyValues.length; i += 2) {
                if (i + 1 >= keyValues.length) {
                  throw new Error('Missing value for key: ' + keyValues[i]);
                }
                map.set(keyValues[i], keyValues[i + 1]);
              }
            });
          };
          Map.prototype.toString = function toString() {
            return this.__toString('Map {', '}');
          };

          // @pragma Access

          Map.prototype.get = function get(k, notSetValue) {
            return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;
          };

          // @pragma Modification

          Map.prototype.set = function set(k, v) {
            return updateMap(this, k, v);
          };
          Map.prototype.remove = function remove(k) {
            return updateMap(this, k, NOT_SET);
          };
          Map.prototype.deleteAll = function deleteAll(keys) {
            var collection = Collection(keys);
            if (collection.size === 0) {
              return this;
            }
            return this.withMutations(function (map) {
              collection.forEach(function (key) {
                return map.remove(key);
              });
            });
          };
          Map.prototype.clear = function clear() {
            if (this.size === 0) {
              return this;
            }
            if (this.__ownerID) {
              this.size = 0;
              this._root = null;
              this.__hash = undefined;
              this.__altered = true;
              return this;
            }
            return emptyMap();
          };

          // @pragma Composition

          Map.prototype.sort = function sort(comparator) {
            // Late binding
            return OrderedMap(sortFactory(this, comparator));
          };
          Map.prototype.sortBy = function sortBy(mapper, comparator) {
            // Late binding
            return OrderedMap(sortFactory(this, comparator, mapper));
          };
          Map.prototype.map = function map(mapper, context) {
            var this$1$1 = this;
            return this.withMutations(function (map) {
              map.forEach(function (value, key) {
                map.set(key, mapper.call(context, value, key, this$1$1));
              });
            });
          };

          // @pragma Mutability

          Map.prototype.__iterator = function __iterator(type, reverse) {
            return new MapIterator(this, type, reverse);
          };
          Map.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            var iterations = 0;
            this._root && this._root.iterate(function (entry) {
              iterations++;
              return fn(entry[1], entry[0], this$1$1);
            }, reverse);
            return iterations;
          };
          Map.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
              return this;
            }
            if (!ownerID) {
              if (this.size === 0) {
                return emptyMap();
              }
              this.__ownerID = ownerID;
              this.__altered = false;
              return this;
            }
            return makeMap(this.size, this._root, ownerID, this.__hash);
          };
          return Map;
        }(KeyedCollection);
        Map$2.isMap = isMap$2;
        var MapPrototype = Map$2.prototype;
        MapPrototype[IS_MAP_SYMBOL] = true;
        MapPrototype[DELETE] = MapPrototype.remove;
        MapPrototype.removeAll = MapPrototype.deleteAll;
        MapPrototype.setIn = setIn;
        MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
        MapPrototype.update = update;
        MapPrototype.updateIn = updateIn;
        MapPrototype.merge = MapPrototype.concat = merge$1$1;
        MapPrototype.mergeWith = mergeWith$1$1;
        MapPrototype.mergeDeep = mergeDeep;
        MapPrototype.mergeDeepWith = mergeDeepWith;
        MapPrototype.mergeIn = mergeIn;
        MapPrototype.mergeDeepIn = mergeDeepIn;
        MapPrototype.withMutations = withMutations;
        MapPrototype.wasAltered = wasAltered;
        MapPrototype.asImmutable = asImmutable;
        MapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;
        MapPrototype['@@transducer/step'] = function (result, arr) {
          return result.set(arr[0], arr[1]);
        };
        MapPrototype['@@transducer/result'] = function (obj) {
          return obj.asImmutable();
        };

        // #pragma Trie Nodes

        var ArrayMapNode = function ArrayMapNode(ownerID, entries) {
          this.ownerID = ownerID;
          this.entries = entries;
        };
        ArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
          var entries = this.entries;
          for (var ii = 0, len = entries.length; ii < len; ii++) {
            if (is(key, entries[ii][0])) {
              return entries[ii][1];
            }
          }
          return notSetValue;
        };
        ArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          var removed = value === NOT_SET;
          var entries = this.entries;
          var idx = 0;
          var len = entries.length;
          for (; idx < len; idx++) {
            if (is(key, entries[idx][0])) {
              break;
            }
          }
          var exists = idx < len;
          if (exists ? entries[idx][1] === value : removed) {
            return this;
          }
          SetRef(didAlter);
          (removed || !exists) && SetRef(didChangeSize);
          if (removed && entries.length === 1) {
            return; // undefined
          }
          if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
            return createNodes(ownerID, entries, key, value);
          }
          var isEditable = ownerID && ownerID === this.ownerID;
          var newEntries = isEditable ? entries : arrCopy(entries);
          if (exists) {
            if (removed) {
              idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
            } else {
              newEntries[idx] = [key, value];
            }
          } else {
            newEntries.push([key, value]);
          }
          if (isEditable) {
            this.entries = newEntries;
            return this;
          }
          return new ArrayMapNode(ownerID, newEntries);
        };
        var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {
          this.ownerID = ownerID;
          this.bitmap = bitmap;
          this.nodes = nodes;
        };
        BitmapIndexedNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
          if (keyHash === undefined) {
            keyHash = hash(key);
          }
          var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
          var bitmap = this.bitmap;
          return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
        };
        BitmapIndexedNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (keyHash === undefined) {
            keyHash = hash(key);
          }
          var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var bit = 1 << keyHashFrag;
          var bitmap = this.bitmap;
          var exists = (bitmap & bit) !== 0;
          if (!exists && value === NOT_SET) {
            return this;
          }
          var idx = popCount(bitmap & bit - 1);
          var nodes = this.nodes;
          var node = exists ? nodes[idx] : undefined;
          var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
          if (newNode === node) {
            return this;
          }
          if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
            return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
          }
          if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
            return nodes[idx ^ 1];
          }
          if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
            return newNode;
          }
          var isEditable = ownerID && ownerID === this.ownerID;
          var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
          var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
          if (isEditable) {
            this.bitmap = newBitmap;
            this.nodes = newNodes;
            return this;
          }
          return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
        };
        var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {
          this.ownerID = ownerID;
          this.count = count;
          this.nodes = nodes;
        };
        HashArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
          if (keyHash === undefined) {
            keyHash = hash(key);
          }
          var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var node = this.nodes[idx];
          return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
        };
        HashArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (keyHash === undefined) {
            keyHash = hash(key);
          }
          var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var removed = value === NOT_SET;
          var nodes = this.nodes;
          var node = nodes[idx];
          if (removed && !node) {
            return this;
          }
          var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
          if (newNode === node) {
            return this;
          }
          var newCount = this.count;
          if (!node) {
            newCount++;
          } else if (!newNode) {
            newCount--;
            if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
              return packNodes(ownerID, nodes, newCount, idx);
            }
          }
          var isEditable = ownerID && ownerID === this.ownerID;
          var newNodes = setAt(nodes, idx, newNode, isEditable);
          if (isEditable) {
            this.count = newCount;
            this.nodes = newNodes;
            return this;
          }
          return new HashArrayMapNode(ownerID, newCount, newNodes);
        };
        var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {
          this.ownerID = ownerID;
          this.keyHash = keyHash;
          this.entries = entries;
        };
        HashCollisionNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
          var entries = this.entries;
          for (var ii = 0, len = entries.length; ii < len; ii++) {
            if (is(key, entries[ii][0])) {
              return entries[ii][1];
            }
          }
          return notSetValue;
        };
        HashCollisionNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (keyHash === undefined) {
            keyHash = hash(key);
          }
          var removed = value === NOT_SET;
          if (keyHash !== this.keyHash) {
            if (removed) {
              return this;
            }
            SetRef(didAlter);
            SetRef(didChangeSize);
            return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
          }
          var entries = this.entries;
          var idx = 0;
          var len = entries.length;
          for (; idx < len; idx++) {
            if (is(key, entries[idx][0])) {
              break;
            }
          }
          var exists = idx < len;
          if (exists ? entries[idx][1] === value : removed) {
            return this;
          }
          SetRef(didAlter);
          (removed || !exists) && SetRef(didChangeSize);
          if (removed && len === 2) {
            return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
          }
          var isEditable = ownerID && ownerID === this.ownerID;
          var newEntries = isEditable ? entries : arrCopy(entries);
          if (exists) {
            if (removed) {
              idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
            } else {
              newEntries[idx] = [key, value];
            }
          } else {
            newEntries.push([key, value]);
          }
          if (isEditable) {
            this.entries = newEntries;
            return this;
          }
          return new HashCollisionNode(ownerID, this.keyHash, newEntries);
        };
        var ValueNode = function ValueNode(ownerID, keyHash, entry) {
          this.ownerID = ownerID;
          this.keyHash = keyHash;
          this.entry = entry;
        };
        ValueNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
          return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
        };
        ValueNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          var removed = value === NOT_SET;
          var keyMatch = is(key, this.entry[0]);
          if (keyMatch ? value === this.entry[1] : removed) {
            return this;
          }
          SetRef(didAlter);
          if (removed) {
            SetRef(didChangeSize);
            return; // undefined
          }
          if (keyMatch) {
            if (ownerID && ownerID === this.ownerID) {
              this.entry[1] = value;
              return this;
            }
            return new ValueNode(ownerID, this.keyHash, [key, value]);
          }
          SetRef(didChangeSize);
          return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
        };

        // #pragma Iterators

        ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {
          var entries = this.entries;
          for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
            if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
              return false;
            }
          }
        };
        BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {
          var nodes = this.nodes;
          for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
            var node = nodes[reverse ? maxIndex - ii : ii];
            if (node && node.iterate(fn, reverse) === false) {
              return false;
            }
          }
        };

        // eslint-disable-next-line no-unused-vars
        ValueNode.prototype.iterate = function (fn, reverse) {
          return fn(this.entry);
        };
        var MapIterator = /*@__PURE__*/function (Iterator) {
          function MapIterator(map, type, reverse) {
            this._type = type;
            this._reverse = reverse;
            this._stack = map._root && mapIteratorFrame(map._root);
          }
          if (Iterator) MapIterator.__proto__ = Iterator;
          MapIterator.prototype = Object.create(Iterator && Iterator.prototype);
          MapIterator.prototype.constructor = MapIterator;
          MapIterator.prototype.next = function next() {
            var type = this._type;
            var stack = this._stack;
            while (stack) {
              var node = stack.node;
              var index = stack.index++;
              var maxIndex = void 0;
              if (node.entry) {
                if (index === 0) {
                  return mapIteratorValue(type, node.entry);
                }
              } else if (node.entries) {
                maxIndex = node.entries.length - 1;
                if (index <= maxIndex) {
                  return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
                }
              } else {
                maxIndex = node.nodes.length - 1;
                if (index <= maxIndex) {
                  var subNode = node.nodes[this._reverse ? maxIndex - index : index];
                  if (subNode) {
                    if (subNode.entry) {
                      return mapIteratorValue(type, subNode.entry);
                    }
                    stack = this._stack = mapIteratorFrame(subNode, stack);
                  }
                  continue;
                }
              }
              stack = this._stack = this._stack.__prev;
            }
            return iteratorDone();
          };
          return MapIterator;
        }(Iterator);
        function mapIteratorValue(type, entry) {
          return iteratorValue(type, entry[0], entry[1]);
        }
        function mapIteratorFrame(node, prev) {
          return {
            node: node,
            index: 0,
            __prev: prev
          };
        }
        function makeMap(size, root, ownerID, hash) {
          var map = Object.create(MapPrototype);
          map.size = size;
          map._root = root;
          map.__ownerID = ownerID;
          map.__hash = hash;
          map.__altered = false;
          return map;
        }
        var EMPTY_MAP;
        function emptyMap() {
          return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
        }
        function updateMap(map, k, v) {
          var newRoot;
          var newSize;
          if (!map._root) {
            if (v === NOT_SET) {
              return map;
            }
            newSize = 1;
            newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
          } else {
            var didChangeSize = MakeRef();
            var didAlter = MakeRef();
            newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
            if (!didAlter.value) {
              return map;
            }
            newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
          }
          if (map.__ownerID) {
            map.size = newSize;
            map._root = newRoot;
            map.__hash = undefined;
            map.__altered = true;
            return map;
          }
          return newRoot ? makeMap(newSize, newRoot) : emptyMap();
        }
        function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (!node) {
            if (value === NOT_SET) {
              return node;
            }
            SetRef(didAlter);
            SetRef(didChangeSize);
            return new ValueNode(ownerID, keyHash, [key, value]);
          }
          return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
        }
        function isLeafNode(node) {
          return node.constructor === ValueNode || node.constructor === HashCollisionNode;
        }
        function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
          if (node.keyHash === keyHash) {
            return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
          }
          var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
          var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var newNode;
          var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
          return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
        }
        function createNodes(ownerID, entries, key, value) {
          if (!ownerID) {
            ownerID = new OwnerID();
          }
          var node = new ValueNode(ownerID, hash(key), [key, value]);
          for (var ii = 0; ii < entries.length; ii++) {
            var entry = entries[ii];
            node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
          }
          return node;
        }
        function packNodes(ownerID, nodes, count, excluding) {
          var bitmap = 0;
          var packedII = 0;
          var packedNodes = new Array(count);
          for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
            var node = nodes[ii];
            if (node !== undefined && ii !== excluding) {
              bitmap |= bit;
              packedNodes[packedII++] = node;
            }
          }
          return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
        }
        function expandNodes(ownerID, nodes, bitmap, including, node) {
          var count = 0;
          var expandedNodes = new Array(SIZE);
          for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
            expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
          }
          expandedNodes[including] = node;
          return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
        }
        function popCount(x) {
          x -= x >> 1 & 0x55555555;
          x = (x & 0x33333333) + (x >> 2 & 0x33333333);
          x = x + (x >> 4) & 0x0f0f0f0f;
          x += x >> 8;
          x += x >> 16;
          return x & 0x7f;
        }
        function setAt(array, idx, val, canEdit) {
          var newArray = canEdit ? array : arrCopy(array);
          newArray[idx] = val;
          return newArray;
        }
        function spliceIn(array, idx, val, canEdit) {
          var newLen = array.length + 1;
          if (canEdit && idx + 1 === newLen) {
            array[idx] = val;
            return array;
          }
          var newArray = new Array(newLen);
          var after = 0;
          for (var ii = 0; ii < newLen; ii++) {
            if (ii === idx) {
              newArray[ii] = val;
              after = -1;
            } else {
              newArray[ii] = array[ii + after];
            }
          }
          return newArray;
        }
        function spliceOut(array, idx, canEdit) {
          var newLen = array.length - 1;
          if (canEdit && idx === newLen) {
            array.pop();
            return array;
          }
          var newArray = new Array(newLen);
          var after = 0;
          for (var ii = 0; ii < newLen; ii++) {
            if (ii === idx) {
              after = 1;
            }
            newArray[ii] = array[ii + after];
          }
          return newArray;
        }
        var MAX_ARRAY_MAP_SIZE = SIZE / 4;
        var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
        var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
        var IS_LIST_SYMBOL = '@@__IMMUTABLE_LIST__@@';
        function isList(maybeList) {
          return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
        }
        var List = /*@__PURE__*/function (IndexedCollection) {
          function List(value) {
            var empty = emptyList();
            if (value === undefined || value === null) {
              // eslint-disable-next-line no-constructor-return
              return empty;
            }
            if (isList(value)) {
              // eslint-disable-next-line no-constructor-return
              return value;
            }
            var iter = IndexedCollection(value);
            var size = iter.size;
            if (size === 0) {
              // eslint-disable-next-line no-constructor-return
              return empty;
            }
            assertNotInfinite(size);
            if (size > 0 && size < SIZE) {
              // eslint-disable-next-line no-constructor-return
              return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
            }
            // eslint-disable-next-line no-constructor-return
            return empty.withMutations(function (list) {
              list.setSize(size);
              iter.forEach(function (v, i) {
                return list.set(i, v);
              });
            });
          }
          if (IndexedCollection) List.__proto__ = IndexedCollection;
          List.prototype = Object.create(IndexedCollection && IndexedCollection.prototype);
          List.prototype.constructor = List;
          List.of = function of(/*...values*/
          ) {
            return this(arguments);
          };
          List.prototype.toString = function toString() {
            return this.__toString('List [', ']');
          };

          // @pragma Access

          List.prototype.get = function get(index, notSetValue) {
            index = wrapIndex(this, index);
            if (index >= 0 && index < this.size) {
              index += this._origin;
              var node = listNodeFor(this, index);
              return node && node.array[index & MASK];
            }
            return notSetValue;
          };

          // @pragma Modification

          List.prototype.set = function set(index, value) {
            return updateList(this, index, value);
          };
          List.prototype.remove = function remove(index) {
            return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
          };
          List.prototype.insert = function insert(index, value) {
            return this.splice(index, 0, value);
          };
          List.prototype.clear = function clear() {
            if (this.size === 0) {
              return this;
            }
            if (this.__ownerID) {
              this.size = this._origin = this._capacity = 0;
              this._level = SHIFT;
              this._root = this._tail = this.__hash = undefined;
              this.__altered = true;
              return this;
            }
            return emptyList();
          };
          List.prototype.push = function push(/*...values*/
          ) {
            var values = arguments;
            var oldSize = this.size;
            return this.withMutations(function (list) {
              setListBounds(list, 0, oldSize + values.length);
              for (var ii = 0; ii < values.length; ii++) {
                list.set(oldSize + ii, values[ii]);
              }
            });
          };
          List.prototype.pop = function pop() {
            return setListBounds(this, 0, -1);
          };
          List.prototype.unshift = function unshift(/*...values*/
          ) {
            var values = arguments;
            return this.withMutations(function (list) {
              setListBounds(list, -values.length);
              for (var ii = 0; ii < values.length; ii++) {
                list.set(ii, values[ii]);
              }
            });
          };
          List.prototype.shift = function shift() {
            return setListBounds(this, 1);
          };

          // @pragma Composition

          List.prototype.concat = function concat(/*...collections*/
          ) {
            var arguments$1 = arguments;
            var seqs = [];
            for (var i = 0; i < arguments.length; i++) {
              var argument = arguments$1[i];
              var seq = IndexedCollection(typeof argument !== 'string' && hasIterator(argument) ? argument : [argument]);
              if (seq.size !== 0) {
                seqs.push(seq);
              }
            }
            if (seqs.length === 0) {
              return this;
            }
            if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
              return this.constructor(seqs[0]);
            }
            return this.withMutations(function (list) {
              seqs.forEach(function (seq) {
                return seq.forEach(function (value) {
                  return list.push(value);
                });
              });
            });
          };
          List.prototype.setSize = function setSize(size) {
            return setListBounds(this, 0, size);
          };
          List.prototype.map = function map(mapper, context) {
            var this$1$1 = this;
            return this.withMutations(function (list) {
              for (var i = 0; i < this$1$1.size; i++) {
                list.set(i, mapper.call(context, list.get(i), i, this$1$1));
              }
            });
          };

          // @pragma Iteration

          List.prototype.slice = function slice(begin, end) {
            var size = this.size;
            if (wholeSlice(begin, end, size)) {
              return this;
            }
            return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
          };
          List.prototype.__iterator = function __iterator(type, reverse) {
            var index = reverse ? this.size : 0;
            var values = iterateList(this, reverse);
            return new Iterator(function () {
              var value = values();
              return value === DONE ? iteratorDone() : iteratorValue(type, reverse ? --index : index++, value);
            });
          };
          List.prototype.__iterate = function __iterate(fn, reverse) {
            var index = reverse ? this.size : 0;
            var values = iterateList(this, reverse);
            var value;
            while ((value = values()) !== DONE) {
              if (fn(value, reverse ? --index : index++, this) === false) {
                break;
              }
            }
            return index;
          };
          List.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
              return this;
            }
            if (!ownerID) {
              if (this.size === 0) {
                return emptyList();
              }
              this.__ownerID = ownerID;
              this.__altered = false;
              return this;
            }
            return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
          };
          return List;
        }(IndexedCollection);
        List.isList = isList;
        var ListPrototype = List.prototype;
        ListPrototype[IS_LIST_SYMBOL] = true;
        ListPrototype[DELETE] = ListPrototype.remove;
        ListPrototype.merge = ListPrototype.concat;
        ListPrototype.setIn = setIn;
        ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
        ListPrototype.update = update;
        ListPrototype.updateIn = updateIn;
        ListPrototype.mergeIn = mergeIn;
        ListPrototype.mergeDeepIn = mergeDeepIn;
        ListPrototype.withMutations = withMutations;
        ListPrototype.wasAltered = wasAltered;
        ListPrototype.asImmutable = asImmutable;
        ListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;
        ListPrototype['@@transducer/step'] = function (result, arr) {
          return result.push(arr);
        };
        ListPrototype['@@transducer/result'] = function (obj) {
          return obj.asImmutable();
        };
        var VNode = function VNode(array, ownerID) {
          this.array = array;
          this.ownerID = ownerID;
        };

        // TODO: seems like these methods are very similar

        VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {
          if (index === level ? 1 << level : this.array.length === 0) {
            return this;
          }
          var originIndex = index >>> level & MASK;
          if (originIndex >= this.array.length) {
            return new VNode([], ownerID);
          }
          var removingFirst = originIndex === 0;
          var newChild;
          if (level > 0) {
            var oldChild = this.array[originIndex];
            newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
            if (newChild === oldChild && removingFirst) {
              return this;
            }
          }
          if (removingFirst && !newChild) {
            return this;
          }
          var editable = editableVNode(this, ownerID);
          if (!removingFirst) {
            for (var ii = 0; ii < originIndex; ii++) {
              editable.array[ii] = undefined;
            }
          }
          if (newChild) {
            editable.array[originIndex] = newChild;
          }
          return editable;
        };
        VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {
          if (index === (level ? 1 << level : 0) || this.array.length === 0) {
            return this;
          }
          var sizeIndex = index - 1 >>> level & MASK;
          if (sizeIndex >= this.array.length) {
            return this;
          }
          var newChild;
          if (level > 0) {
            var oldChild = this.array[sizeIndex];
            newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
            if (newChild === oldChild && sizeIndex === this.array.length - 1) {
              return this;
            }
          }
          var editable = editableVNode(this, ownerID);
          editable.array.splice(sizeIndex + 1);
          if (newChild) {
            editable.array[sizeIndex] = newChild;
          }
          return editable;
        };
        var DONE = {};
        function iterateList(list, reverse) {
          var left = list._origin;
          var right = list._capacity;
          var tailPos = getTailOffset(right);
          var tail = list._tail;
          return iterateNodeOrLeaf(list._root, list._level, 0);
          function iterateNodeOrLeaf(node, level, offset) {
            return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
          }
          function iterateLeaf(node, offset) {
            var array = offset === tailPos ? tail && tail.array : node && node.array;
            var from = offset > left ? 0 : left - offset;
            var to = right - offset;
            if (to > SIZE) {
              to = SIZE;
            }
            return function () {
              if (from === to) {
                return DONE;
              }
              var idx = reverse ? --to : from++;
              return array && array[idx];
            };
          }
          function iterateNode(node, level, offset) {
            var values;
            var array = node && node.array;
            var from = offset > left ? 0 : left - offset >> level;
            var to = (right - offset >> level) + 1;
            if (to > SIZE) {
              to = SIZE;
            }
            return function () {
              while (true) {
                if (values) {
                  var value = values();
                  if (value !== DONE) {
                    return value;
                  }
                  values = null;
                }
                if (from === to) {
                  return DONE;
                }
                var idx = reverse ? --to : from++;
                values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
              }
            };
          }
        }
        function makeList(origin, capacity, level, root, tail, ownerID, hash) {
          var list = Object.create(ListPrototype);
          list.size = capacity - origin;
          list._origin = origin;
          list._capacity = capacity;
          list._level = level;
          list._root = root;
          list._tail = tail;
          list.__ownerID = ownerID;
          list.__hash = hash;
          list.__altered = false;
          return list;
        }
        var EMPTY_LIST;
        function emptyList() {
          return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
        }
        function updateList(list, index, value) {
          index = wrapIndex(list, index);
          if (index !== index) {
            return list;
          }
          if (index >= list.size || index < 0) {
            return list.withMutations(function (list) {
              index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);
            });
          }
          index += list._origin;
          var newTail = list._tail;
          var newRoot = list._root;
          var didAlter = MakeRef();
          if (index >= getTailOffset(list._capacity)) {
            newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
          } else {
            newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
          }
          if (!didAlter.value) {
            return list;
          }
          if (list.__ownerID) {
            list._root = newRoot;
            list._tail = newTail;
            list.__hash = undefined;
            list.__altered = true;
            return list;
          }
          return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
        }
        function updateVNode(node, ownerID, level, index, value, didAlter) {
          var idx = index >>> level & MASK;
          var nodeHas = node && idx < node.array.length;
          if (!nodeHas && value === undefined) {
            return node;
          }
          var newNode;
          if (level > 0) {
            var lowerNode = node && node.array[idx];
            var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
            if (newLowerNode === lowerNode) {
              return node;
            }
            newNode = editableVNode(node, ownerID);
            newNode.array[idx] = newLowerNode;
            return newNode;
          }
          if (nodeHas && node.array[idx] === value) {
            return node;
          }
          if (didAlter) {
            SetRef(didAlter);
          }
          newNode = editableVNode(node, ownerID);
          if (value === undefined && idx === newNode.array.length - 1) {
            newNode.array.pop();
          } else {
            newNode.array[idx] = value;
          }
          return newNode;
        }
        function editableVNode(node, ownerID) {
          if (ownerID && node && ownerID === node.ownerID) {
            return node;
          }
          return new VNode(node ? node.array.slice() : [], ownerID);
        }
        function listNodeFor(list, rawIndex) {
          if (rawIndex >= getTailOffset(list._capacity)) {
            return list._tail;
          }
          if (rawIndex < 1 << list._level + SHIFT) {
            var node = list._root;
            var level = list._level;
            while (node && level > 0) {
              node = node.array[rawIndex >>> level & MASK];
              level -= SHIFT;
            }
            return node;
          }
        }
        function setListBounds(list, begin, end) {
          // Sanitize begin & end using this shorthand for ToInt32(argument)
          // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
          if (begin !== undefined) {
            begin |= 0;
          }
          if (end !== undefined) {
            end |= 0;
          }
          var owner = list.__ownerID || new OwnerID();
          var oldOrigin = list._origin;
          var oldCapacity = list._capacity;
          var newOrigin = oldOrigin + begin;
          var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
          if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
            return list;
          }

          // If it's going to end after it starts, it's empty.
          if (newOrigin >= newCapacity) {
            return list.clear();
          }
          var newLevel = list._level;
          var newRoot = list._root;

          // New origin might need creating a higher root.
          var offsetShift = 0;
          while (newOrigin + offsetShift < 0) {
            newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
            newLevel += SHIFT;
            offsetShift += 1 << newLevel;
          }
          if (offsetShift) {
            newOrigin += offsetShift;
            oldOrigin += offsetShift;
            newCapacity += offsetShift;
            oldCapacity += offsetShift;
          }
          var oldTailOffset = getTailOffset(oldCapacity);
          var newTailOffset = getTailOffset(newCapacity);

          // New size might need creating a higher root.
          while (newTailOffset >= 1 << newLevel + SHIFT) {
            newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
            newLevel += SHIFT;
          }

          // Locate or create the new tail.
          var oldTail = list._tail;
          var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

          // Merge Tail into tree.
          if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
            newRoot = editableVNode(newRoot, owner);
            var node = newRoot;
            for (var level = newLevel; level > SHIFT; level -= SHIFT) {
              var idx = oldTailOffset >>> level & MASK;
              node = node.array[idx] = editableVNode(node.array[idx], owner);
            }
            node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
          }

          // If the size has been reduced, there's a chance the tail needs to be trimmed.
          if (newCapacity < oldCapacity) {
            newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
          }

          // If the new origin is within the tail, then we do not need a root.
          if (newOrigin >= newTailOffset) {
            newOrigin -= newTailOffset;
            newCapacity -= newTailOffset;
            newLevel = SHIFT;
            newRoot = null;
            newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

            // Otherwise, if the root has been trimmed, garbage collect.
          } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
            offsetShift = 0;

            // Identify the new top root node of the subtree of the old root.
            while (newRoot) {
              var beginIndex = newOrigin >>> newLevel & MASK;
              if (beginIndex !== newTailOffset >>> newLevel & MASK) {
                break;
              }
              if (beginIndex) {
                offsetShift += (1 << newLevel) * beginIndex;
              }
              newLevel -= SHIFT;
              newRoot = newRoot.array[beginIndex];
            }

            // Trim the new sides of the new root.
            if (newRoot && newOrigin > oldOrigin) {
              newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
            }
            if (newRoot && newTailOffset < oldTailOffset) {
              newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
            }
            if (offsetShift) {
              newOrigin -= offsetShift;
              newCapacity -= offsetShift;
            }
          }
          if (list.__ownerID) {
            list.size = newCapacity - newOrigin;
            list._origin = newOrigin;
            list._capacity = newCapacity;
            list._level = newLevel;
            list._root = newRoot;
            list._tail = newTail;
            list.__hash = undefined;
            list.__altered = true;
            return list;
          }
          return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
        }
        function getTailOffset(size) {
          return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
        }
        var OrderedMap = /*@__PURE__*/function (Map) {
          function OrderedMap(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {
              var iter = KeyedCollection(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v, k) {
                return map.set(k, v);
              });
            });
          }
          if (Map) OrderedMap.__proto__ = Map;
          OrderedMap.prototype = Object.create(Map && Map.prototype);
          OrderedMap.prototype.constructor = OrderedMap;
          OrderedMap.of = function of(/*...values*/
          ) {
            return this(arguments);
          };
          OrderedMap.prototype.toString = function toString() {
            return this.__toString('OrderedMap {', '}');
          };

          // @pragma Access

          OrderedMap.prototype.get = function get(k, notSetValue) {
            var index = this._map.get(k);
            return index !== undefined ? this._list.get(index)[1] : notSetValue;
          };

          // @pragma Modification

          OrderedMap.prototype.clear = function clear() {
            if (this.size === 0) {
              return this;
            }
            if (this.__ownerID) {
              this.size = 0;
              this._map.clear();
              this._list.clear();
              this.__altered = true;
              return this;
            }
            return emptyOrderedMap();
          };
          OrderedMap.prototype.set = function set(k, v) {
            return updateOrderedMap(this, k, v);
          };
          OrderedMap.prototype.remove = function remove(k) {
            return updateOrderedMap(this, k, NOT_SET);
          };
          OrderedMap.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            return this._list.__iterate(function (entry) {
              return entry && fn(entry[1], entry[0], this$1$1);
            }, reverse);
          };
          OrderedMap.prototype.__iterator = function __iterator(type, reverse) {
            return this._list.fromEntrySeq().__iterator(type, reverse);
          };
          OrderedMap.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
              return this;
            }
            var newMap = this._map.__ensureOwner(ownerID);
            var newList = this._list.__ensureOwner(ownerID);
            if (!ownerID) {
              if (this.size === 0) {
                return emptyOrderedMap();
              }
              this.__ownerID = ownerID;
              this.__altered = false;
              this._map = newMap;
              this._list = newList;
              return this;
            }
            return makeOrderedMap(newMap, newList, ownerID, this.__hash);
          };
          return OrderedMap;
        }(Map$2);
        OrderedMap.isOrderedMap = isOrderedMap;
        OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
        OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
        function makeOrderedMap(map, list, ownerID, hash) {
          var omap = Object.create(OrderedMap.prototype);
          omap.size = map ? map.size : 0;
          omap._map = map;
          omap._list = list;
          omap.__ownerID = ownerID;
          omap.__hash = hash;
          omap.__altered = false;
          return omap;
        }
        var EMPTY_ORDERED_MAP;
        function emptyOrderedMap() {
          return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
        }
        function updateOrderedMap(omap, k, v) {
          var map = omap._map;
          var list = omap._list;
          var i = map.get(k);
          var has = i !== undefined;
          var newMap;
          var newList;
          if (v === NOT_SET) {
            // removed
            if (!has) {
              return omap;
            }
            if (list.size >= SIZE && list.size >= map.size * 2) {
              newList = list.filter(function (entry, idx) {
                return entry !== undefined && i !== idx;
              });
              newMap = newList.toKeyedSeq().map(function (entry) {
                return entry[0];
              }).flip().toMap();
              if (omap.__ownerID) {
                newMap.__ownerID = newList.__ownerID = omap.__ownerID;
              }
            } else {
              newMap = map.remove(k);
              newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
            }
          } else if (has) {
            if (v === list.get(i)[1]) {
              return omap;
            }
            newMap = map;
            newList = list.set(i, [k, v]);
          } else {
            newMap = map.set(k, list.size);
            newList = list.set(list.size, [k, v]);
          }
          if (omap.__ownerID) {
            omap.size = newMap.size;
            omap._map = newMap;
            omap._list = newList;
            omap.__hash = undefined;
            omap.__altered = true;
            return omap;
          }
          return makeOrderedMap(newMap, newList);
        }
        var IS_STACK_SYMBOL = '@@__IMMUTABLE_STACK__@@';
        function isStack(maybeStack) {
          return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
        }
        var Stack$4 = /*@__PURE__*/function (IndexedCollection) {
          function Stack(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
          }
          if (IndexedCollection) Stack.__proto__ = IndexedCollection;
          Stack.prototype = Object.create(IndexedCollection && IndexedCollection.prototype);
          Stack.prototype.constructor = Stack;
          Stack.of = function of(/*...values*/
          ) {
            return this(arguments);
          };
          Stack.prototype.toString = function toString() {
            return this.__toString('Stack [', ']');
          };

          // @pragma Access

          Stack.prototype.get = function get(index, notSetValue) {
            var head = this._head;
            index = wrapIndex(this, index);
            while (head && index--) {
              head = head.next;
            }
            return head ? head.value : notSetValue;
          };
          Stack.prototype.peek = function peek() {
            return this._head && this._head.value;
          };

          // @pragma Modification

          Stack.prototype.push = function push(/*...values*/
          ) {
            var arguments$1 = arguments;
            if (arguments.length === 0) {
              return this;
            }
            var newSize = this.size + arguments.length;
            var head = this._head;
            for (var ii = arguments.length - 1; ii >= 0; ii--) {
              head = {
                value: arguments$1[ii],
                next: head
              };
            }
            if (this.__ownerID) {
              this.size = newSize;
              this._head = head;
              this.__hash = undefined;
              this.__altered = true;
              return this;
            }
            return makeStack(newSize, head);
          };
          Stack.prototype.pushAll = function pushAll(iter) {
            iter = IndexedCollection(iter);
            if (iter.size === 0) {
              return this;
            }
            if (this.size === 0 && isStack(iter)) {
              return iter;
            }
            assertNotInfinite(iter.size);
            var newSize = this.size;
            var head = this._head;
            iter.__iterate(function (value) {
              newSize++;
              head = {
                value: value,
                next: head
              };
            }, /* reverse */true);
            if (this.__ownerID) {
              this.size = newSize;
              this._head = head;
              this.__hash = undefined;
              this.__altered = true;
              return this;
            }
            return makeStack(newSize, head);
          };
          Stack.prototype.pop = function pop() {
            return this.slice(1);
          };
          Stack.prototype.clear = function clear() {
            if (this.size === 0) {
              return this;
            }
            if (this.__ownerID) {
              this.size = 0;
              this._head = undefined;
              this.__hash = undefined;
              this.__altered = true;
              return this;
            }
            return emptyStack();
          };
          Stack.prototype.slice = function slice(begin, end) {
            if (wholeSlice(begin, end, this.size)) {
              return this;
            }
            var resolvedBegin = resolveBegin(begin, this.size);
            var resolvedEnd = resolveEnd(end, this.size);
            if (resolvedEnd !== this.size) {
              // super.slice(begin, end);
              return IndexedCollection.prototype.slice.call(this, begin, end);
            }
            var newSize = this.size - resolvedBegin;
            var head = this._head;
            while (resolvedBegin--) {
              head = head.next;
            }
            if (this.__ownerID) {
              this.size = newSize;
              this._head = head;
              this.__hash = undefined;
              this.__altered = true;
              return this;
            }
            return makeStack(newSize, head);
          };

          // @pragma Mutability

          Stack.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
              return this;
            }
            if (!ownerID) {
              if (this.size === 0) {
                return emptyStack();
              }
              this.__ownerID = ownerID;
              this.__altered = false;
              return this;
            }
            return makeStack(this.size, this._head, ownerID, this.__hash);
          };

          // @pragma Iteration

          Stack.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            if (reverse) {
              return new ArraySeq(this.toArray()).__iterate(function (v, k) {
                return fn(v, k, this$1$1);
              }, reverse);
            }
            var iterations = 0;
            var node = this._head;
            while (node) {
              if (fn(node.value, iterations++, this) === false) {
                break;
              }
              node = node.next;
            }
            return iterations;
          };
          Stack.prototype.__iterator = function __iterator(type, reverse) {
            if (reverse) {
              return new ArraySeq(this.toArray()).__iterator(type, reverse);
            }
            var iterations = 0;
            var node = this._head;
            return new Iterator(function () {
              if (node) {
                var value = node.value;
                node = node.next;
                return iteratorValue(type, iterations++, value);
              }
              return iteratorDone();
            });
          };
          return Stack;
        }(IndexedCollection);
        Stack$4.isStack = isStack;
        var StackPrototype = Stack$4.prototype;
        StackPrototype[IS_STACK_SYMBOL] = true;
        StackPrototype.shift = StackPrototype.pop;
        StackPrototype.unshift = StackPrototype.push;
        StackPrototype.unshiftAll = StackPrototype.pushAll;
        StackPrototype.withMutations = withMutations;
        StackPrototype.wasAltered = wasAltered;
        StackPrototype.asImmutable = asImmutable;
        StackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;
        StackPrototype['@@transducer/step'] = function (result, arr) {
          return result.unshift(arr);
        };
        StackPrototype['@@transducer/result'] = function (obj) {
          return obj.asImmutable();
        };
        function makeStack(size, head, ownerID, hash) {
          var map = Object.create(StackPrototype);
          map.size = size;
          map._head = head;
          map.__ownerID = ownerID;
          map.__hash = hash;
          map.__altered = false;
          return map;
        }
        var EMPTY_STACK;
        function emptyStack() {
          return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
        }
        var IS_SET_SYMBOL = '@@__IMMUTABLE_SET__@@';
        function isSet$2(maybeSet) {
          return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
        }
        function isOrderedSet(maybeOrderedSet) {
          return isSet$2(maybeOrderedSet) && isOrdered(maybeOrderedSet);
        }
        function deepEqual$1(a, b) {
          if (a === b) {
            return true;
          }
          if (!isCollection(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
            return false;
          }
          if (a.size === 0 && b.size === 0) {
            return true;
          }
          var notAssociative = !isAssociative(a);
          if (isOrdered(a)) {
            var entries = a.entries();
            return b.every(function (v, k) {
              var entry = entries.next().value;
              return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
            }) && entries.next().done;
          }
          var flipped = false;
          if (a.size === undefined) {
            if (b.size === undefined) {
              if (typeof a.cacheResult === 'function') {
                a.cacheResult();
              }
            } else {
              flipped = true;
              var _ = a;
              a = b;
              b = _;
            }
          }
          var allEqual = true;
          var bSize = b.__iterate(function (v, k) {
            if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
              allEqual = false;
              return false;
            }
          });
          return allEqual && a.size === bSize;
        }
        function mixin(ctor, methods) {
          var keyCopier = function keyCopier(key) {
            ctor.prototype[key] = methods[key];
          };
          Object.keys(methods).forEach(keyCopier);
          Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
          return ctor;
        }
        function toJS(value) {
          if (!value || typeof value !== 'object') {
            return value;
          }
          if (!isCollection(value)) {
            if (!isDataStructure(value)) {
              return value;
            }
            value = Seq(value);
          }
          if (isKeyed(value)) {
            var result$1 = {};
            value.__iterate(function (v, k) {
              result$1[k] = toJS(v);
            });
            return result$1;
          }
          var result = [];
          value.__iterate(function (v) {
            result.push(toJS(v));
          });
          return result;
        }
        var Set$2 = /*@__PURE__*/function (SetCollection) {
          function Set(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptySet() : isSet$2(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {
              var iter = SetCollection(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v) {
                return set.add(v);
              });
            });
          }
          if (SetCollection) Set.__proto__ = SetCollection;
          Set.prototype = Object.create(SetCollection && SetCollection.prototype);
          Set.prototype.constructor = Set;
          Set.of = function of(/*...values*/
          ) {
            return this(arguments);
          };
          Set.fromKeys = function fromKeys(value) {
            return this(KeyedCollection(value).keySeq());
          };
          Set.intersect = function intersect(sets) {
            sets = Collection(sets).toArray();
            return sets.length ? SetPrototype.intersect.apply(Set(sets.pop()), sets) : emptySet();
          };
          Set.union = function union(sets) {
            sets = Collection(sets).toArray();
            return sets.length ? SetPrototype.union.apply(Set(sets.pop()), sets) : emptySet();
          };
          Set.prototype.toString = function toString() {
            return this.__toString('Set {', '}');
          };

          // @pragma Access

          Set.prototype.has = function has(value) {
            return this._map.has(value);
          };

          // @pragma Modification

          Set.prototype.add = function add(value) {
            return updateSet(this, this._map.set(value, value));
          };
          Set.prototype.remove = function remove(value) {
            return updateSet(this, this._map.remove(value));
          };
          Set.prototype.clear = function clear() {
            return updateSet(this, this._map.clear());
          };

          // @pragma Composition

          Set.prototype.map = function map(mapper, context) {
            var this$1$1 = this;

            // keep track if the set is altered by the map function
            var didChanges = false;
            var newMap = updateSet(this, this._map.mapEntries(function (ref) {
              var v = ref[1];
              var mapped = mapper.call(context, v, v, this$1$1);
              if (mapped !== v) {
                didChanges = true;
              }
              return [mapped, mapped];
            }, context));
            return didChanges ? newMap : this;
          };
          Set.prototype.union = function union() {
            var iters = [],
              len = arguments.length;
            while (len--) iters[len] = arguments[len];
            iters = iters.filter(function (x) {
              return x.size !== 0;
            });
            if (iters.length === 0) {
              return this;
            }
            if (this.size === 0 && !this.__ownerID && iters.length === 1) {
              return this.constructor(iters[0]);
            }
            return this.withMutations(function (set) {
              for (var ii = 0; ii < iters.length; ii++) {
                if (typeof iters[ii] === 'string') {
                  set.add(iters[ii]);
                } else {
                  SetCollection(iters[ii]).forEach(function (value) {
                    return set.add(value);
                  });
                }
              }
            });
          };
          Set.prototype.intersect = function intersect() {
            var iters = [],
              len = arguments.length;
            while (len--) iters[len] = arguments[len];
            if (iters.length === 0) {
              return this;
            }
            iters = iters.map(function (iter) {
              return SetCollection(iter);
            });
            var toRemove = [];
            this.forEach(function (value) {
              if (!iters.every(function (iter) {
                return iter.includes(value);
              })) {
                toRemove.push(value);
              }
            });
            return this.withMutations(function (set) {
              toRemove.forEach(function (value) {
                set.remove(value);
              });
            });
          };
          Set.prototype.subtract = function subtract() {
            var iters = [],
              len = arguments.length;
            while (len--) iters[len] = arguments[len];
            if (iters.length === 0) {
              return this;
            }
            iters = iters.map(function (iter) {
              return SetCollection(iter);
            });
            var toRemove = [];
            this.forEach(function (value) {
              if (iters.some(function (iter) {
                return iter.includes(value);
              })) {
                toRemove.push(value);
              }
            });
            return this.withMutations(function (set) {
              toRemove.forEach(function (value) {
                set.remove(value);
              });
            });
          };
          Set.prototype.sort = function sort(comparator) {
            // Late binding
            return OrderedSet(sortFactory(this, comparator));
          };
          Set.prototype.sortBy = function sortBy(mapper, comparator) {
            // Late binding
            return OrderedSet(sortFactory(this, comparator, mapper));
          };
          Set.prototype.wasAltered = function wasAltered() {
            return this._map.wasAltered();
          };
          Set.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            return this._map.__iterate(function (k) {
              return fn(k, k, this$1$1);
            }, reverse);
          };
          Set.prototype.__iterator = function __iterator(type, reverse) {
            return this._map.__iterator(type, reverse);
          };
          Set.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
              return this;
            }
            var newMap = this._map.__ensureOwner(ownerID);
            if (!ownerID) {
              if (this.size === 0) {
                return this.__empty();
              }
              this.__ownerID = ownerID;
              this._map = newMap;
              return this;
            }
            return this.__make(newMap, ownerID);
          };
          return Set;
        }(SetCollection);
        Set$2.isSet = isSet$2;
        var SetPrototype = Set$2.prototype;
        SetPrototype[IS_SET_SYMBOL] = true;
        SetPrototype[DELETE] = SetPrototype.remove;
        SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
        SetPrototype.withMutations = withMutations;
        SetPrototype.asImmutable = asImmutable;
        SetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;
        SetPrototype['@@transducer/step'] = function (result, arr) {
          return result.add(arr);
        };
        SetPrototype['@@transducer/result'] = function (obj) {
          return obj.asImmutable();
        };
        SetPrototype.__empty = emptySet;
        SetPrototype.__make = makeSet;
        function updateSet(set, newMap) {
          if (set.__ownerID) {
            set.size = newMap.size;
            set._map = newMap;
            return set;
          }
          return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);
        }
        function makeSet(map, ownerID) {
          var set = Object.create(SetPrototype);
          set.size = map ? map.size : 0;
          set._map = map;
          set.__ownerID = ownerID;
          return set;
        }
        var EMPTY_SET;
        function emptySet() {
          return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
        }

        /**
         * Returns a lazy seq of nums from start (inclusive) to end
         * (exclusive), by step, where start defaults to 0, step to 1, and end to
         * infinity. When start is equal to end, returns empty list.
         */
        var Range = /*@__PURE__*/function (IndexedSeq) {
          function Range(start, end, step) {
            if (!(this instanceof Range)) {
              // eslint-disable-next-line no-constructor-return
              return new Range(start, end, step);
            }
            invariant(step !== 0, 'Cannot step a Range by 0');
            start = start || 0;
            if (end === undefined) {
              end = Infinity;
            }
            step = step === undefined ? 1 : Math.abs(step);
            if (end < start) {
              step = -step;
            }
            this._start = start;
            this._end = end;
            this._step = step;
            this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
            if (this.size === 0) {
              if (EMPTY_RANGE) {
                // eslint-disable-next-line no-constructor-return
                return EMPTY_RANGE;
              }
              EMPTY_RANGE = this;
            }
          }
          if (IndexedSeq) Range.__proto__ = IndexedSeq;
          Range.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
          Range.prototype.constructor = Range;
          Range.prototype.toString = function toString() {
            if (this.size === 0) {
              return 'Range []';
            }
            return 'Range [ ' + this._start + '...' + this._end + (this._step !== 1 ? ' by ' + this._step : '') + ' ]';
          };
          Range.prototype.get = function get(index, notSetValue) {
            return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
          };
          Range.prototype.includes = function includes(searchValue) {
            var possibleIndex = (searchValue - this._start) / this._step;
            return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
          };
          Range.prototype.slice = function slice(begin, end) {
            if (wholeSlice(begin, end, this.size)) {
              return this;
            }
            begin = resolveBegin(begin, this.size);
            end = resolveEnd(end, this.size);
            if (end <= begin) {
              return new Range(0, 0);
            }
            return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
          };
          Range.prototype.indexOf = function indexOf(searchValue) {
            var offsetValue = searchValue - this._start;
            if (offsetValue % this._step === 0) {
              var index = offsetValue / this._step;
              if (index >= 0 && index < this.size) {
                return index;
              }
            }
            return -1;
          };
          Range.prototype.lastIndexOf = function lastIndexOf(searchValue) {
            return this.indexOf(searchValue);
          };
          Range.prototype.__iterate = function __iterate(fn, reverse) {
            var size = this.size;
            var step = this._step;
            var value = reverse ? this._start + (size - 1) * step : this._start;
            var i = 0;
            while (i !== size) {
              if (fn(value, reverse ? size - ++i : i++, this) === false) {
                break;
              }
              value += reverse ? -step : step;
            }
            return i;
          };
          Range.prototype.__iterator = function __iterator(type, reverse) {
            var size = this.size;
            var step = this._step;
            var value = reverse ? this._start + (size - 1) * step : this._start;
            var i = 0;
            return new Iterator(function () {
              if (i === size) {
                return iteratorDone();
              }
              var v = value;
              value += reverse ? -step : step;
              return iteratorValue(type, reverse ? size - ++i : i++, v);
            });
          };
          Range.prototype.equals = function equals(other) {
            return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual$1(this, other);
          };
          return Range;
        }(IndexedSeq);
        var EMPTY_RANGE;
        function getIn$1(collection, searchKeyPath, notSetValue) {
          var keyPath = coerceKeyPath(searchKeyPath);
          var i = 0;
          while (i !== keyPath.length) {
            collection = get$5(collection, keyPath[i++], NOT_SET);
            if (collection === NOT_SET) {
              return notSetValue;
            }
          }
          return collection;
        }
        function getIn(searchKeyPath, notSetValue) {
          return getIn$1(this, searchKeyPath, notSetValue);
        }
        function hasIn$1$1(collection, keyPath) {
          return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;
        }
        function hasIn$4(searchKeyPath) {
          return hasIn$1$1(this, searchKeyPath);
        }
        function toObject() {
          assertNotInfinite(this.size);
          var object = {};
          this.__iterate(function (v, k) {
            object[k] = v;
          });
          return object;
        }

        // Note: all of these methods are deprecated.
        Collection.isIterable = isCollection;
        Collection.isKeyed = isKeyed;
        Collection.isIndexed = isIndexed;
        Collection.isAssociative = isAssociative;
        Collection.isOrdered = isOrdered;
        Collection.Iterator = Iterator;
        mixin(Collection, {
          // ### Conversion to other types

          toArray: function toArray() {
            assertNotInfinite(this.size);
            var array = new Array(this.size || 0);
            var useTuples = isKeyed(this);
            var i = 0;
            this.__iterate(function (v, k) {
              // Keyed collections produce an array of tuples.
              array[i++] = useTuples ? [k, v] : v;
            });
            return array;
          },
          toIndexedSeq: function toIndexedSeq() {
            return new ToIndexedSequence(this);
          },
          toJS: function toJS$1() {
            return toJS(this);
          },
          toKeyedSeq: function toKeyedSeq() {
            return new ToKeyedSequence(this, true);
          },
          toMap: function toMap() {
            // Use Late Binding here to solve the circular dependency.
            return Map$2(this.toKeyedSeq());
          },
          toObject: toObject,
          toOrderedMap: function toOrderedMap() {
            // Use Late Binding here to solve the circular dependency.
            return OrderedMap(this.toKeyedSeq());
          },
          toOrderedSet: function toOrderedSet() {
            // Use Late Binding here to solve the circular dependency.
            return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
          },
          toSet: function toSet() {
            // Use Late Binding here to solve the circular dependency.
            return Set$2(isKeyed(this) ? this.valueSeq() : this);
          },
          toSetSeq: function toSetSeq() {
            return new ToSetSequence(this);
          },
          toSeq: function toSeq() {
            return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
          },
          toStack: function toStack() {
            // Use Late Binding here to solve the circular dependency.
            return Stack$4(isKeyed(this) ? this.valueSeq() : this);
          },
          toList: function toList() {
            // Use Late Binding here to solve the circular dependency.
            return List(isKeyed(this) ? this.valueSeq() : this);
          },
          // ### Common JavaScript methods and properties

          toString: function toString() {
            return '[Collection]';
          },
          __toString: function __toString(head, tail) {
            if (this.size === 0) {
              return head + tail;
            }
            return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
          },
          // ### ES6 Collection methods (ES6 Array and Map)

          concat: function concat() {
            var values = [],
              len = arguments.length;
            while (len--) values[len] = arguments[len];
            return reify(this, concatFactory(this, values));
          },
          includes: function includes(searchValue) {
            return this.some(function (value) {
              return is(value, searchValue);
            });
          },
          entries: function entries() {
            return this.__iterator(ITERATE_ENTRIES);
          },
          every: function every(predicate, context) {
            assertNotInfinite(this.size);
            var returnValue = true;
            this.__iterate(function (v, k, c) {
              if (!predicate.call(context, v, k, c)) {
                returnValue = false;
                return false;
              }
            });
            return returnValue;
          },
          filter: function filter(predicate, context) {
            return reify(this, filterFactory(this, predicate, context, true));
          },
          partition: function partition(predicate, context) {
            return partitionFactory(this, predicate, context);
          },
          find: function find(predicate, context, notSetValue) {
            var entry = this.findEntry(predicate, context);
            return entry ? entry[1] : notSetValue;
          },
          forEach: function forEach(sideEffect, context) {
            assertNotInfinite(this.size);
            return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
          },
          join: function join(separator) {
            assertNotInfinite(this.size);
            separator = separator !== undefined ? '' + separator : ',';
            var joined = '';
            var isFirst = true;
            this.__iterate(function (v) {
              isFirst ? isFirst = false : joined += separator;
              joined += v !== null && v !== undefined ? v.toString() : '';
            });
            return joined;
          },
          keys: function keys() {
            return this.__iterator(ITERATE_KEYS);
          },
          map: function map(mapper, context) {
            return reify(this, mapFactory(this, mapper, context));
          },
          reduce: function reduce$1(reducer, initialReduction, context) {
            return reduce(this, reducer, initialReduction, context, arguments.length < 2, false);
          },
          reduceRight: function reduceRight(reducer, initialReduction, context) {
            return reduce(this, reducer, initialReduction, context, arguments.length < 2, true);
          },
          reverse: function reverse() {
            return reify(this, reverseFactory(this, true));
          },
          slice: function slice(begin, end) {
            return reify(this, sliceFactory(this, begin, end, true));
          },
          some: function some(predicate, context) {
            assertNotInfinite(this.size);
            var returnValue = false;
            this.__iterate(function (v, k, c) {
              if (predicate.call(context, v, k, c)) {
                returnValue = true;
                return false;
              }
            });
            return returnValue;
          },
          sort: function sort(comparator) {
            return reify(this, sortFactory(this, comparator));
          },
          values: function values() {
            return this.__iterator(ITERATE_VALUES);
          },
          // ### More sequential methods

          butLast: function butLast() {
            return this.slice(0, -1);
          },
          isEmpty: function isEmpty() {
            return this.size !== undefined ? this.size === 0 : !this.some(function () {
              return true;
            });
          },
          count: function count(predicate, context) {
            return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
          },
          countBy: function countBy(grouper, context) {
            return countByFactory(this, grouper, context);
          },
          equals: function equals(other) {
            return deepEqual$1(this, other);
          },
          entrySeq: function entrySeq() {
            var collection = this;
            if (collection._cache) {
              // We cache as an entries array, so we can just return the cache!
              return new ArraySeq(collection._cache);
            }
            var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
            entriesSequence.fromEntrySeq = function () {
              return collection.toSeq();
            };
            return entriesSequence;
          },
          filterNot: function filterNot(predicate, context) {
            return this.filter(not(predicate), context);
          },
          findEntry: function findEntry(predicate, context, notSetValue) {
            var found = notSetValue;
            this.__iterate(function (v, k, c) {
              if (predicate.call(context, v, k, c)) {
                found = [k, v];
                return false;
              }
            });
            return found;
          },
          findKey: function findKey(predicate, context) {
            var entry = this.findEntry(predicate, context);
            return entry && entry[0];
          },
          findLast: function findLast(predicate, context, notSetValue) {
            return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
          },
          findLastEntry: function findLastEntry(predicate, context, notSetValue) {
            return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
          },
          findLastKey: function findLastKey(predicate, context) {
            return this.toKeyedSeq().reverse().findKey(predicate, context);
          },
          first: function first(notSetValue) {
            return this.find(returnTrue, null, notSetValue);
          },
          flatMap: function flatMap(mapper, context) {
            return reify(this, flatMapFactory(this, mapper, context));
          },
          flatten: function flatten(depth) {
            return reify(this, flattenFactory(this, depth, true));
          },
          fromEntrySeq: function fromEntrySeq() {
            return new FromEntriesSequence(this);
          },
          get: function get(searchKey, notSetValue) {
            return this.find(function (_, key) {
              return is(key, searchKey);
            }, undefined, notSetValue);
          },
          getIn: getIn,
          groupBy: function groupBy(grouper, context) {
            return groupByFactory(this, grouper, context);
          },
          has: function has(searchKey) {
            return this.get(searchKey, NOT_SET) !== NOT_SET;
          },
          hasIn: hasIn$4,
          isSubset: function isSubset(iter) {
            iter = typeof iter.includes === 'function' ? iter : Collection(iter);
            return this.every(function (value) {
              return iter.includes(value);
            });
          },
          isSuperset: function isSuperset(iter) {
            iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);
            return iter.isSubset(this);
          },
          keyOf: function keyOf(searchValue) {
            return this.findKey(function (value) {
              return is(value, searchValue);
            });
          },
          keySeq: function keySeq() {
            return this.toSeq().map(keyMapper).toIndexedSeq();
          },
          last: function last(notSetValue) {
            return this.toSeq().reverse().first(notSetValue);
          },
          lastKeyOf: function lastKeyOf(searchValue) {
            return this.toKeyedSeq().reverse().keyOf(searchValue);
          },
          max: function max(comparator) {
            return maxFactory(this, comparator);
          },
          maxBy: function maxBy(mapper, comparator) {
            return maxFactory(this, comparator, mapper);
          },
          min: function min(comparator) {
            return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
          },
          minBy: function minBy(mapper, comparator) {
            return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
          },
          rest: function rest() {
            return this.slice(1);
          },
          skip: function skip(amount) {
            return amount === 0 ? this : this.slice(Math.max(0, amount));
          },
          skipLast: function skipLast(amount) {
            return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
          },
          skipWhile: function skipWhile(predicate, context) {
            return reify(this, skipWhileFactory(this, predicate, context, true));
          },
          skipUntil: function skipUntil(predicate, context) {
            return this.skipWhile(not(predicate), context);
          },
          sortBy: function sortBy(mapper, comparator) {
            return reify(this, sortFactory(this, comparator, mapper));
          },
          take: function take(amount) {
            return this.slice(0, Math.max(0, amount));
          },
          takeLast: function takeLast(amount) {
            return this.slice(-Math.max(0, amount));
          },
          takeWhile: function takeWhile(predicate, context) {
            return reify(this, takeWhileFactory(this, predicate, context));
          },
          takeUntil: function takeUntil(predicate, context) {
            return this.takeWhile(not(predicate), context);
          },
          update: function update(fn) {
            return fn(this);
          },
          valueSeq: function valueSeq() {
            return this.toIndexedSeq();
          },
          // ### Hashable Object

          hashCode: function hashCode() {
            return this.__hash || (this.__hash = hashCollection(this));
          }

          // ### Internal

          // abstract __iterate(fn, reverse)

          // abstract __iterator(type, reverse)
        });
        var CollectionPrototype = Collection.prototype;
        CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
        CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
        CollectionPrototype.toJSON = CollectionPrototype.toArray;
        CollectionPrototype.__toStringMapper = quoteString;
        CollectionPrototype.inspect = CollectionPrototype.toSource = function () {
          return this.toString();
        };
        CollectionPrototype.chain = CollectionPrototype.flatMap;
        CollectionPrototype.contains = CollectionPrototype.includes;
        mixin(KeyedCollection, {
          // ### More sequential methods

          flip: function flip() {
            return reify(this, flipFactory(this));
          },
          mapEntries: function mapEntries(mapper, context) {
            var this$1$1 = this;
            var iterations = 0;
            return reify(this, this.toSeq().map(function (v, k) {
              return mapper.call(context, [k, v], iterations++, this$1$1);
            }).fromEntrySeq());
          },
          mapKeys: function mapKeys(mapper, context) {
            var this$1$1 = this;
            return reify(this, this.toSeq().flip().map(function (k, v) {
              return mapper.call(context, k, v, this$1$1);
            }).flip());
          }
        });
        var KeyedCollectionPrototype = KeyedCollection.prototype;
        KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
        KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
        KeyedCollectionPrototype.toJSON = toObject;
        KeyedCollectionPrototype.__toStringMapper = function (v, k) {
          return quoteString(k) + ': ' + quoteString(v);
        };
        mixin(IndexedCollection, {
          // ### Conversion to other types

          toKeyedSeq: function toKeyedSeq() {
            return new ToKeyedSequence(this, false);
          },
          // ### ES6 Collection methods (ES6 Array and Map)

          filter: function filter(predicate, context) {
            return reify(this, filterFactory(this, predicate, context, false));
          },
          findIndex: function findIndex(predicate, context) {
            var entry = this.findEntry(predicate, context);
            return entry ? entry[0] : -1;
          },
          indexOf: function indexOf(searchValue) {
            var key = this.keyOf(searchValue);
            return key === undefined ? -1 : key;
          },
          lastIndexOf: function lastIndexOf(searchValue) {
            var key = this.lastKeyOf(searchValue);
            return key === undefined ? -1 : key;
          },
          reverse: function reverse() {
            return reify(this, reverseFactory(this, false));
          },
          slice: function slice(begin, end) {
            return reify(this, sliceFactory(this, begin, end, false));
          },
          splice: function splice(index, removeNum /*, ...values*/) {
            var numArgs = arguments.length;
            removeNum = Math.max(removeNum || 0, 0);
            if (numArgs === 0 || numArgs === 2 && !removeNum) {
              return this;
            }
            // If index is negative, it should resolve relative to the size of the
            // collection. However size may be expensive to compute if not cached, so
            // only call count() if the number is in fact negative.
            index = resolveBegin(index, index < 0 ? this.count() : this.size);
            var spliced = this.slice(0, index);
            return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
          },
          // ### More collection methods

          findLastIndex: function findLastIndex(predicate, context) {
            var entry = this.findLastEntry(predicate, context);
            return entry ? entry[0] : -1;
          },
          first: function first(notSetValue) {
            return this.get(0, notSetValue);
          },
          flatten: function flatten(depth) {
            return reify(this, flattenFactory(this, depth, false));
          },
          get: function get(index, notSetValue) {
            index = wrapIndex(this, index);
            return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function (_, key) {
              return key === index;
            }, undefined, notSetValue);
          },
          has: function has(index) {
            index = wrapIndex(this, index);
            return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
          },
          interpose: function interpose(separator) {
            return reify(this, interposeFactory(this, separator));
          },
          interleave: function interleave(/*...collections*/
          ) {
            var collections = [this].concat(arrCopy(arguments));
            var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
            var interleaved = zipped.flatten(true);
            if (zipped.size) {
              interleaved.size = zipped.size * collections.length;
            }
            return reify(this, interleaved);
          },
          keySeq: function keySeq() {
            return Range(0, this.size);
          },
          last: function last(notSetValue) {
            return this.get(-1, notSetValue);
          },
          skipWhile: function skipWhile(predicate, context) {
            return reify(this, skipWhileFactory(this, predicate, context, false));
          },
          zip: function zip(/*, ...collections */
          ) {
            var collections = [this].concat(arrCopy(arguments));
            return reify(this, zipWithFactory(this, defaultZipper, collections));
          },
          zipAll: function zipAll(/*, ...collections */
          ) {
            var collections = [this].concat(arrCopy(arguments));
            return reify(this, zipWithFactory(this, defaultZipper, collections, true));
          },
          zipWith: function zipWith(zipper /*, ...collections */) {
            var collections = arrCopy(arguments);
            collections[0] = this;
            return reify(this, zipWithFactory(this, zipper, collections));
          }
        });
        var IndexedCollectionPrototype = IndexedCollection.prototype;
        IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
        IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
        mixin(SetCollection, {
          // ### ES6 Collection methods (ES6 Array and Map)

          get: function get(value, notSetValue) {
            return this.has(value) ? value : notSetValue;
          },
          includes: function includes(value) {
            return this.has(value);
          },
          // ### More sequential methods

          keySeq: function keySeq() {
            return this.valueSeq();
          }
        });
        var SetCollectionPrototype = SetCollection.prototype;
        SetCollectionPrototype.has = CollectionPrototype.includes;
        SetCollectionPrototype.contains = SetCollectionPrototype.includes;
        SetCollectionPrototype.keys = SetCollectionPrototype.values;

        // Mixin subclasses

        mixin(KeyedSeq, KeyedCollectionPrototype);
        mixin(IndexedSeq, IndexedCollectionPrototype);
        mixin(SetSeq, SetCollectionPrototype);

        // #pragma Helper functions

        function reduce(collection, reducer, reduction, context, useFirst, reverse) {
          assertNotInfinite(collection.size);
          collection.__iterate(function (v, k, c) {
            if (useFirst) {
              useFirst = false;
              reduction = v;
            } else {
              reduction = reducer.call(context, reduction, v, k, c);
            }
          }, reverse);
          return reduction;
        }
        function keyMapper(v, k) {
          return k;
        }
        function entryMapper(v, k) {
          return [k, v];
        }
        function not(predicate) {
          return function () {
            return !predicate.apply(this, arguments);
          };
        }
        function neg(predicate) {
          return function () {
            return -predicate.apply(this, arguments);
          };
        }
        function defaultZipper() {
          return arrCopy(arguments);
        }
        function defaultNegComparator(a, b) {
          return a < b ? 1 : a > b ? -1 : 0;
        }
        function hashCollection(collection) {
          if (collection.size === Infinity) {
            return 0;
          }
          var ordered = isOrdered(collection);
          var keyed = isKeyed(collection);
          var h = ordered ? 1 : 0;
          var size = collection.__iterate(keyed ? ordered ? function (v, k) {
            h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
          } : function (v, k) {
            h = h + hashMerge(hash(v), hash(k)) | 0;
          } : ordered ? function (v) {
            h = 31 * h + hash(v) | 0;
          } : function (v) {
            h = h + hash(v) | 0;
          });
          return murmurHashOfSize(size, h);
        }
        function murmurHashOfSize(size, h) {
          h = imul(h, 0xcc9e2d51);
          h = imul(h << 15 | h >>> -15, 0x1b873593);
          h = imul(h << 13 | h >>> -13, 5);
          h = (h + 0xe6546b64 | 0) ^ size;
          h = imul(h ^ h >>> 16, 0x85ebca6b);
          h = imul(h ^ h >>> 13, 0xc2b2ae35);
          h = smi(h ^ h >>> 16);
          return h;
        }
        function hashMerge(a, b) {
          return a ^ b + 0x9e3779b9 + (a << 6) + (a >> 2) | 0; // int
        }
        var OrderedSet = /*@__PURE__*/function (Set) {
          function OrderedSet(value) {
            // eslint-disable-next-line no-constructor-return
            return value === undefined || value === null ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {
              var iter = SetCollection(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v) {
                return set.add(v);
              });
            });
          }
          if (Set) OrderedSet.__proto__ = Set;
          OrderedSet.prototype = Object.create(Set && Set.prototype);
          OrderedSet.prototype.constructor = OrderedSet;
          OrderedSet.of = function of(/*...values*/
          ) {
            return this(arguments);
          };
          OrderedSet.fromKeys = function fromKeys(value) {
            return this(KeyedCollection(value).keySeq());
          };
          OrderedSet.prototype.toString = function toString() {
            return this.__toString('OrderedSet {', '}');
          };
          return OrderedSet;
        }(Set$2);
        OrderedSet.isOrderedSet = isOrderedSet;
        var OrderedSetPrototype = OrderedSet.prototype;
        OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
        OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
        OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
        OrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;
        OrderedSetPrototype.__empty = emptyOrderedSet;
        OrderedSetPrototype.__make = makeOrderedSet;
        function makeOrderedSet(map, ownerID) {
          var set = Object.create(OrderedSetPrototype);
          set.size = map ? map.size : 0;
          set._map = map;
          set.__ownerID = ownerID;
          return set;
        }
        var EMPTY_ORDERED_SET;
        function emptyOrderedSet() {
          return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
        }
        var PairSorting = {
          LeftThenRight: -1,
          RightThenLeft: +1
        };
        function throwOnInvalidDefaultValues(defaultValues) {
          if (isRecord(defaultValues)) {
            throw new Error('Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead.');
          }
          if (isImmutable$2(defaultValues)) {
            throw new Error('Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead.');
          }
          if (defaultValues === null || typeof defaultValues !== 'object') {
            throw new Error('Can not call `Record` with a non-object as default values. Use a plain javascript object instead.');
          }
        }
        var Record = function Record(defaultValues, name) {
          var hasInitialized;
          throwOnInvalidDefaultValues(defaultValues);
          var RecordType = function Record(values) {
            var this$1$1 = this;
            if (values instanceof RecordType) {
              return values;
            }
            if (!(this instanceof RecordType)) {
              return new RecordType(values);
            }
            if (!hasInitialized) {
              hasInitialized = true;
              var keys = Object.keys(defaultValues);
              var indices = RecordTypePrototype._indices = {};
              // Deprecated: left to attempt not to break any external code which
              // relies on a ._name property existing on record instances.
              // Use Record.getDescriptiveName() instead
              RecordTypePrototype._name = name;
              RecordTypePrototype._keys = keys;
              RecordTypePrototype._defaultValues = defaultValues;
              for (var i = 0; i < keys.length; i++) {
                var propName = keys[i];
                indices[propName] = i;
                if (RecordTypePrototype[propName]) {
                  /* eslint-disable no-console */
                  typeof console === 'object' && console.warn && console.warn('Cannot define ' + recordName(this) + ' with property "' + propName + '" since that property name is part of the Record API.');
                  /* eslint-enable no-console */
                } else {
                  setProp(RecordTypePrototype, propName);
                }
              }
            }
            this.__ownerID = undefined;
            this._values = List().withMutations(function (l) {
              l.setSize(this$1$1._keys.length);
              KeyedCollection(values).forEach(function (v, k) {
                l.set(this$1$1._indices[k], v === this$1$1._defaultValues[k] ? undefined : v);
              });
            });
            return this;
          };
          var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
          RecordTypePrototype.constructor = RecordType;
          if (name) {
            RecordType.displayName = name;
          }

          // eslint-disable-next-line no-constructor-return
          return RecordType;
        };
        Record.prototype.toString = function toString() {
          var str = recordName(this) + ' { ';
          var keys = this._keys;
          var k;
          for (var i = 0, l = keys.length; i !== l; i++) {
            k = keys[i];
            str += (i ? ', ' : '') + k + ': ' + quoteString(this.get(k));
          }
          return str + ' }';
        };
        Record.prototype.equals = function equals(other) {
          return this === other || isRecord(other) && recordSeq(this).equals(recordSeq(other));
        };
        Record.prototype.hashCode = function hashCode() {
          return recordSeq(this).hashCode();
        };

        // @pragma Access

        Record.prototype.has = function has(k) {
          return this._indices.hasOwnProperty(k);
        };
        Record.prototype.get = function get(k, notSetValue) {
          if (!this.has(k)) {
            return notSetValue;
          }
          var index = this._indices[k];
          var value = this._values.get(index);
          return value === undefined ? this._defaultValues[k] : value;
        };

        // @pragma Modification

        Record.prototype.set = function set(k, v) {
          if (this.has(k)) {
            var newValues = this._values.set(this._indices[k], v === this._defaultValues[k] ? undefined : v);
            if (newValues !== this._values && !this.__ownerID) {
              return makeRecord(this, newValues);
            }
          }
          return this;
        };
        Record.prototype.remove = function remove(k) {
          return this.set(k);
        };
        Record.prototype.clear = function clear() {
          var newValues = this._values.clear().setSize(this._keys.length);
          return this.__ownerID ? this : makeRecord(this, newValues);
        };
        Record.prototype.wasAltered = function wasAltered() {
          return this._values.wasAltered();
        };
        Record.prototype.toSeq = function toSeq() {
          return recordSeq(this);
        };
        Record.prototype.toJS = function toJS$1() {
          return toJS(this);
        };
        Record.prototype.entries = function entries() {
          return this.__iterator(ITERATE_ENTRIES);
        };
        Record.prototype.__iterator = function __iterator(type, reverse) {
          return recordSeq(this).__iterator(type, reverse);
        };
        Record.prototype.__iterate = function __iterate(fn, reverse) {
          return recordSeq(this).__iterate(fn, reverse);
        };
        Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
          if (ownerID === this.__ownerID) {
            return this;
          }
          var newValues = this._values.__ensureOwner(ownerID);
          if (!ownerID) {
            this.__ownerID = ownerID;
            this._values = newValues;
            return this;
          }
          return makeRecord(this, newValues, ownerID);
        };
        Record.isRecord = isRecord;
        Record.getDescriptiveName = recordName;
        var RecordPrototype = Record.prototype;
        RecordPrototype[IS_RECORD_SYMBOL] = true;
        RecordPrototype[DELETE] = RecordPrototype.remove;
        RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
        RecordPrototype.getIn = getIn;
        RecordPrototype.hasIn = CollectionPrototype.hasIn;
        RecordPrototype.merge = merge$1$1;
        RecordPrototype.mergeWith = mergeWith$1$1;
        RecordPrototype.mergeIn = mergeIn;
        RecordPrototype.mergeDeep = mergeDeep;
        RecordPrototype.mergeDeepWith = mergeDeepWith;
        RecordPrototype.mergeDeepIn = mergeDeepIn;
        RecordPrototype.setIn = setIn;
        RecordPrototype.update = update;
        RecordPrototype.updateIn = updateIn;
        RecordPrototype.withMutations = withMutations;
        RecordPrototype.asMutable = asMutable;
        RecordPrototype.asImmutable = asImmutable;
        RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
        RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;
        RecordPrototype.inspect = RecordPrototype.toSource = function () {
          return this.toString();
        };
        function makeRecord(likeRecord, values, ownerID) {
          var record = Object.create(Object.getPrototypeOf(likeRecord));
          record._values = values;
          record.__ownerID = ownerID;
          return record;
        }
        function recordName(record) {
          return record.constructor.displayName || record.constructor.name || 'Record';
        }
        function recordSeq(record) {
          return keyedSeqFromValue(record._keys.map(function (k) {
            return [k, record.get(k)];
          }));
        }
        function setProp(prototype, name) {
          try {
            Object.defineProperty(prototype, name, {
              get: function get() {
                return this.get(name);
              },
              set: function set(value) {
                invariant(this.__ownerID, 'Cannot set on an immutable record.');
                this.set(name, value);
              }
            });
          } catch (error) {
            // Object.defineProperty failed. Probably IE8.
          }
        }

        /**
         * Returns a lazy Seq of `value` repeated `times` times. When `times` is
         * undefined, returns an infinite sequence of `value`.
         */
        var Repeat = /*@__PURE__*/function (IndexedSeq) {
          function Repeat(value, times) {
            if (!(this instanceof Repeat)) {
              // eslint-disable-next-line no-constructor-return
              return new Repeat(value, times);
            }
            this._value = value;
            this.size = times === undefined ? Infinity : Math.max(0, times);
            if (this.size === 0) {
              if (EMPTY_REPEAT) {
                // eslint-disable-next-line no-constructor-return
                return EMPTY_REPEAT;
              }
              EMPTY_REPEAT = this;
            }
          }
          if (IndexedSeq) Repeat.__proto__ = IndexedSeq;
          Repeat.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
          Repeat.prototype.constructor = Repeat;
          Repeat.prototype.toString = function toString() {
            if (this.size === 0) {
              return 'Repeat []';
            }
            return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
          };
          Repeat.prototype.get = function get(index, notSetValue) {
            return this.has(index) ? this._value : notSetValue;
          };
          Repeat.prototype.includes = function includes(searchValue) {
            return is(this._value, searchValue);
          };
          Repeat.prototype.slice = function slice(begin, end) {
            var size = this.size;
            return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
          };
          Repeat.prototype.reverse = function reverse() {
            return this;
          };
          Repeat.prototype.indexOf = function indexOf(searchValue) {
            if (is(this._value, searchValue)) {
              return 0;
            }
            return -1;
          };
          Repeat.prototype.lastIndexOf = function lastIndexOf(searchValue) {
            if (is(this._value, searchValue)) {
              return this.size;
            }
            return -1;
          };
          Repeat.prototype.__iterate = function __iterate(fn, reverse) {
            var size = this.size;
            var i = 0;
            while (i !== size) {
              if (fn(this._value, reverse ? size - ++i : i++, this) === false) {
                break;
              }
            }
            return i;
          };
          Repeat.prototype.__iterator = function __iterator(type, reverse) {
            var this$1$1 = this;
            var size = this.size;
            var i = 0;
            return new Iterator(function () {
              return i === size ? iteratorDone() : iteratorValue(type, reverse ? size - ++i : i++, this$1$1._value);
            });
          };
          Repeat.prototype.equals = function equals(other) {
            return other instanceof Repeat ? is(this._value, other._value) : deepEqual$1(this, other);
          };
          return Repeat;
        }(IndexedSeq);
        var EMPTY_REPEAT;
        function fromJS(value, converter) {
          return fromJSWith([], converter || defaultConverter, value, '', converter && converter.length > 2 ? [] : undefined, {
            '': value
          });
        }
        function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
          if (typeof value !== 'string' && !isImmutable$2(value) && (isArrayLike$6(value) || hasIterator(value) || isPlainObject$4(value))) {
            if (~stack.indexOf(value)) {
              throw new TypeError('Cannot convert circular structure to Immutable');
            }
            stack.push(value);
            keyPath && key !== '' && keyPath.push(key);
            var converted = converter.call(parentValue, key, Seq(value).map(function (v, k) {
              return fromJSWith(stack, converter, v, k, keyPath, value);
            }), keyPath && keyPath.slice());
            stack.pop();
            keyPath && keyPath.pop();
            return converted;
          }
          return value;
        }
        function defaultConverter(k, v) {
          // Effectively the opposite of "Collection.toSeq()"
          return isIndexed(v) ? v.toList() : isKeyed(v) ? v.toMap() : v.toSet();
        }
        var version = "4.3.7";
        var Immutable = {
          version: version,
          Collection: Collection,
          // Note: Iterable is deprecated
          Iterable: Collection,
          Seq: Seq,
          Map: Map$2,
          OrderedMap: OrderedMap,
          List: List,
          Stack: Stack$4,
          Set: Set$2,
          OrderedSet: OrderedSet,
          PairSorting: PairSorting,
          Record: Record,
          Range: Range,
          Repeat: Repeat,
          is: is,
          fromJS: fromJS,
          hash: hash,
          isImmutable: isImmutable$2,
          isCollection: isCollection,
          isKeyed: isKeyed,
          isIndexed: isIndexed,
          isAssociative: isAssociative,
          isOrdered: isOrdered,
          isValueObject: isValueObject,
          isPlainObject: isPlainObject$4,
          isSeq: isSeq,
          isList: isList,
          isMap: isMap$2,
          isOrderedMap: isOrderedMap,
          isStack: isStack,
          isSet: isSet$2,
          isOrderedSet: isOrderedSet,
          isRecord: isRecord,
          get: get$5,
          getIn: getIn$1,
          has: has,
          hasIn: hasIn$1$1,
          merge: merge$3,
          mergeDeep: mergeDeep$1,
          mergeWith: mergeWith$2,
          mergeDeepWith: mergeDeepWith$1,
          remove: remove,
          removeIn: removeIn,
          set: set,
          setIn: setIn$1,
          update: update$1,
          updateIn: updateIn$1
        };

        // Had to make uuid use a constant seed so it would generate same sequence across runs. This was needed
        // so server side rendering and client side rendering yield same results (e.g. the uuid is used when rendering
        // the concunctions with their name and id)
        var query_builder_seed = 0;
        const uuid = function uuid() {
          // Generate a random GUID http://stackoverflow.com/a/2117523.
          var timePart = (new Date().getTime().toString(16) + "FF").substr(0, 11);
          var s = "ssssssss-xxxx-4xxx-yxxx-x".replace(/[xys]/g, function (c) {
            var r = c === "s" ? Math.floor(Math.random() * 16) : query_builder_seed++ & 0xf;
            var v = c === "x" ? r : r & 0x3 | 0x8;
            return v.toString(16);
          });
          return s + timePart;
        };
        var define_process_env_default$1 = {};
        function ownKeys$D(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r2) {
              return Object.getOwnPropertyDescriptor(e, r2).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$D(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$D(Object(t), true).forEach(function (r2) {
              _defineProperty$4(e, r2, t[r2]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$D(Object(t)).forEach(function (r2) {
              Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
            });
          }
          return e;
        }
        var widgetDefKeysToOmit = ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue", "spelImportFuncs", "spelImportValue"];
        var opDefKeysToOmit = ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"];
        var isObject$g = function isObject2(v) {
          return _typeof$3(v) === "object" && v !== null && Object.prototype.toString.call(v) === "[object Object]";
        };
        var shallowCopy = function shallowCopy2(v) {
          if (_typeof$3(v) === "object" && v !== null) {
            if (Array.isArray(v)) {
              return _toConsumableArray(v);
            } else if (isObject$g(v)) {
              return _objectSpread$D({}, v);
            }
          }
          return v;
        };
        var omit$2 = function omit2(obj, keys) {
          return Object.fromEntries(Object.entries(obj).filter(function (_ref) {
            var _ref2 = _slicedToArray$1(_ref, 1),
              k = _ref2[0];
            return !keys.includes(k);
          }));
        };
        var getOpCardinality$1 = function getOpCardinality2(opDef) {
          var _opDef$cardinality;
          return (_opDef$cardinality = opDef === null || opDef === void 0 ? void 0 : opDef.cardinality) !== null && _opDef$cardinality !== void 0 ? _opDef$cardinality : 1;
        };
        var deepEqual = function deepEqual2(v1, v2) {
          if (v1 === v2) {
            return true;
          } else if (Map$2.isMap(v1)) {
            return v1.equals(v2);
          } else {
            return JSON.stringify(v1) == JSON.stringify(v2);
          }
        };
        var shallowEqual$4 = function shallowEqual2(a, b) {
          var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (a === b) {
            return true;
          } else if (Array.isArray(a)) return shallowEqualArrays$1(a, b, deep);else if (Map$2.isMap(a)) return a.equals(b);else if (_typeof$3(a) == "object") return shallowEqualObjects$1(a, b, deep);else return a === b;
        };
        function shallowEqualArrays$1(arrA, arrB) {
          var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (arrA === arrB) {
            return true;
          }
          if (!arrA || !arrB) {
            return false;
          }
          var len = arrA.length;
          if (arrB.length !== len) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            var isEqual = deep ? shallowEqual$4(arrA[i], arrB[i], deep) : arrA[i] === arrB[i];
            if (!isEqual) {
              return false;
            }
          }
          return true;
        }
        function shallowEqualObjects$1(objA, objB) {
          var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (objA === objB) {
            return true;
          }
          if (!objA || !objB) {
            return false;
          }
          var aKeys = Object.keys(objA);
          var bKeys = Object.keys(objB);
          var len = aKeys.length;
          if (bKeys.length !== len) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            var key = aKeys[i];
            var isEqual = deep ? shallowEqual$4(objA[key], objB[key], deep) : objA[key] === objB[key];
            if (!isEqual) {
              return false;
            }
          }
          return true;
        }
        var isImmutable$1 = function isImmutable2(v) {
          return _typeof$3(v) === "object" && v !== null && typeof v.toJS === "function";
        };
        var isImmutableList = function isImmutableList2(v) {
          return isImmutable$1(v) && Immutable.isList(v);
        };
        function toImmutableList(v) {
          return isImmutableList(v) ? v : new Immutable.List(v);
        }
        function applyToJS(v) {
          return isImmutable$1(v) ? v.toJS() : v;
        }
        var escapeRegExp = function escapeRegExp2(string) {
          return string.replace(/[.*+?^${}()|[\]\\/]/g, "\\$&");
        };
        var mergeCustomizerNoArrays = function mergeCustomizerNoArrays2(objValue, srcValue, _key, _object, _source, _stack) {
          if (Array.isArray(objValue)) {
            return srcValue;
          }
        };
        var cleanJSX = function cleanJSX2(jsx) {
          var jsxKeys = ["$$typeof", "_owner", "_store", "ref", "key"];
          var getName = function getName2(val) {
            if (typeof val === "string") {
              return val;
            } else if (typeof val === "function") {
              return val.name;
            }
            return val;
          };
          if (jsx instanceof Array) {
            return jsx.map(function (el, _i) {
              return cleanJSX2(el);
            });
          } else if (_typeof$3(jsx) === "object" && jsx !== null) {
            if (isDirtyJSX(jsx)) {
              var _cleaned$props;
              var cleaned = omit$2(jsx, jsxKeys);
              if (cleaned.type) {
                cleaned.type = getName(cleaned.type);
              }
              if (cleaned !== null && cleaned !== void 0 && (_cleaned$props = cleaned.props) !== null && _cleaned$props !== void 0 && _cleaned$props.children) {
                cleaned.props.children = cleanJSX2(cleaned.props.children);
              }
              return cleaned;
            }
          }
          return jsx;
        };
        var isDirtyJSX = function isDirtyJSX2(jsx) {
          return _typeof$3(jsx) === "object" && jsx !== null && !Array.isArray(jsx) && Object.keys(jsx).includes("type") && Object.keys(jsx).includes("props") && Object.keys(jsx).includes("key") && Object.keys(jsx).includes("ref") && Object.keys(jsx).includes("$$typeof");
        };
        var isJSX = function isJSX2(jsx) {
          return _typeof$3(jsx) === "object" && jsx !== null && !Array.isArray(jsx) && typeof jsx["type"] === "string" && Object.keys(jsx).includes("props");
        };
        var isJsonLogic = function isJsonLogic2(logic) {
          var isJL = _typeof$3(logic) === "object" && logic !== null && !Array.isArray(logic) && Object.keys(logic).length === 1;
          return isJL;
        };
        function sleep$1(delay) {
          return new Promise(function (resolve) {
            setTimeout(resolve, delay);
          });
        }
        function mergeArraysSmart(arr1, arr2) {
          if (!arr1) arr1 = [];
          if (!arr2) arr2 = [];
          return arr2.map(function (op) {
            return [op, arr1.indexOf(op)];
          }).map(function (_ref3, i, orig) {
            var _ref4 = _slicedToArray$1(_ref3, 2),
              op = _ref4[0],
              ind = _ref4[1];
            if (ind == -1) {
              var next = orig.slice(i + 1);
              var prev = orig.slice(0, i);
              var after = prev.reverse().find(function (_ref5) {
                var _ref6 = _slicedToArray$1(_ref5, 2);
                _ref6[0];
                var ci = _ref6[1];
                return ci != -1;
              });
              var before = next.find(function (_ref7) {
                var _ref8 = _slicedToArray$1(_ref7, 2);
                _ref8[0];
                var ci = _ref8[1];
                return ci != -1;
              });
              if (before) return [op, "before", before[0]];else if (after) return [op, "after", after[0]];else return [op, "append", null];
            } else {
              return null;
            }
          }).filter(function (x) {
            return x !== null;
          }).reduce(function (acc, _ref9) {
            var _ref10 = _slicedToArray$1(_ref9, 3),
              newOp = _ref10[0],
              rel = _ref10[1],
              relOp = _ref10[2];
            var ind = acc.indexOf(relOp);
            if (acc.indexOf(newOp) == -1) {
              if (ind > -1) {
                acc.splice(ind + (rel == "after" ? 1 : 0), 0, newOp);
              } else {
                acc.splice(rel == "append" ? Infinity : 0, 0, newOp);
              }
            }
            return acc;
          }, arr1.slice());
        }
        var deepFreeze = function deepFreeze2(obj) {
          if (_typeof$3(obj) === "object" && obj !== null && !isDirtyJSX(obj)) {
            Object.keys(obj).forEach(function (prop) {
              if (prop !== "__cache") {
                deepFreeze2(obj[prop]);
              }
            });
            Object.freeze(obj);
          }
        };
        var isJsonCompatible = function isJsonCompatible2(tpl, obj) {
          var bag = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
          if (isObject$g(tpl)) {
            if (tpl["var"]) {
              bag[tpl["var"]] = obj;
              return true;
            }
            if (!isObject$g(obj)) return false;
            for (var k in tpl) {
              var tv = tpl[k];
              var ov = obj[k];
              if (!isJsonCompatible2(tv, ov, bag, [].concat(_toConsumableArray(path), [k]))) return false;
            }
            return true;
          } else if (Array.isArray(tpl)) {
            if (!Array.isArray(obj)) return false;
            for (var i = 0; i < tpl.length; i++) {
              var _tv = tpl[i];
              var _ov = obj[i];
              if (!isJsonCompatible2(_tv, _ov, bag, [].concat(_toConsumableArray(path), [i]))) return false;
            }
            return true;
          } else {
            return tpl === obj;
          }
        };
        var isDev$1 = function isDev2() {
          return typeof process !== "undefined" && define_process_env_default$1 && false;
        };
        var getLogger$1 = function getLogger2() {
          var devMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          var verbose = devMode != void 0 ? devMode : isDev$1();
          return verbose ? console : {
            error: function error() {},
            log: function log() {},
            warn: function warn() {},
            debug: function debug() {},
            info: function info() {}
          };
        };
        var getFirstDefined = function getFirstDefined2() {
          var arr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          var ret;
          for (var i = 0; i < arr.length; i++) {
            var v = arr[i];
            if (v !== void 0) {
              ret = v;
              break;
            }
          }
          return ret;
        };
        var logger$1 = getLogger$1();
        const stuff = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          applyToJS,
          cleanJSX,
          deepEqual,
          deepFreeze,
          escapeRegExp,
          getFirstDefined,
          getLogger: getLogger$1,
          getOpCardinality: getOpCardinality$1,
          isDirtyJSX,
          isImmutable: isImmutable$1,
          isImmutableList,
          isJSX,
          isJsonCompatible,
          isJsonLogic,
          isObject: isObject$g,
          logger: logger$1,
          mergeArraysSmart,
          mergeCustomizerNoArrays,
          omit: omit$2,
          opDefKeysToOmit,
          shallowCopy,
          shallowEqual: shallowEqual$4,
          sleep: sleep$1,
          toImmutableList,
          uuid,
          widgetDefKeysToOmit
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        var regeneratorRuntime$1 = {
          exports: {}
        };
        var _typeof$1 = {
          exports: {}
        };
        (function (module) {
          function _typeof(o) {
            "@babel/helpers - typeof";

            return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
              return typeof o;
            } : function (o) {
              return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
            }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
          }
          module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(_typeof$1);
        var _typeofExports = _typeof$1.exports;
        (function (module) {
          var _typeof = _typeofExports["default"];
          function _regeneratorRuntime() {
            module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
              return e;
            }, module.exports.__esModule = true, module.exports["default"] = module.exports;
            var t,
              e = {},
              r = Object.prototype,
              n = r.hasOwnProperty,
              o = Object.defineProperty || function (t, e, r) {
                t[e] = r.value;
              },
              i = "function" == typeof Symbol ? Symbol : {},
              a = i.iterator || "@@iterator",
              c = i.asyncIterator || "@@asyncIterator",
              u = i.toStringTag || "@@toStringTag";
            function define(t, e, r) {
              return Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
              }), t[e];
            }
            try {
              define({}, "");
            } catch (t) {
              define = function define(t, e, r) {
                return t[e] = r;
              };
            }
            function wrap(t, e, r, n) {
              var i = e && e.prototype instanceof Generator ? e : Generator,
                a = Object.create(i.prototype),
                c = new Context(n || []);
              return o(a, "_invoke", {
                value: makeInvokeMethod(t, r, c)
              }), a;
            }
            function tryCatch(t, e, r) {
              try {
                return {
                  type: "normal",
                  arg: t.call(e, r)
                };
              } catch (t) {
                return {
                  type: "throw",
                  arg: t
                };
              }
            }
            e.wrap = wrap;
            var h = "suspendedStart",
              l = "suspendedYield",
              f = "executing",
              s = "completed",
              y = {};
            function Generator() {}
            function GeneratorFunction() {}
            function GeneratorFunctionPrototype() {}
            var p = {};
            define(p, a, function () {
              return this;
            });
            var d = Object.getPrototypeOf,
              v = d && d(d(values([])));
            v && v !== r && n.call(v, a) && (p = v);
            var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
            function defineIteratorMethods(t) {
              ["next", "throw", "return"].forEach(function (e) {
                define(t, e, function (t) {
                  return this._invoke(e, t);
                });
              });
            }
            function AsyncIterator(t, e) {
              function invoke(r, o, i, a) {
                var c = tryCatch(t[r], t, o);
                if ("throw" !== c.type) {
                  var u = c.arg,
                    h = u.value;
                  return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
                    invoke("next", t, i, a);
                  }, function (t) {
                    invoke("throw", t, i, a);
                  }) : e.resolve(h).then(function (t) {
                    u.value = t, i(u);
                  }, function (t) {
                    return invoke("throw", t, i, a);
                  });
                }
                a(c.arg);
              }
              var r;
              o(this, "_invoke", {
                value: function value(t, n) {
                  function callInvokeWithMethodAndArg() {
                    return new e(function (e, r) {
                      invoke(t, n, e, r);
                    });
                  }
                  return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
                }
              });
            }
            function makeInvokeMethod(e, r, n) {
              var o = h;
              return function (i, a) {
                if (o === f) throw Error("Generator is already running");
                if (o === s) {
                  if ("throw" === i) throw a;
                  return {
                    value: t,
                    done: !0
                  };
                }
                for (n.method = i, n.arg = a;;) {
                  var c = n.delegate;
                  if (c) {
                    var u = maybeInvokeDelegate(c, n);
                    if (u) {
                      if (u === y) continue;
                      return u;
                    }
                  }
                  if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
                    if (o === h) throw o = s, n.arg;
                    n.dispatchException(n.arg);
                  } else "return" === n.method && n.abrupt("return", n.arg);
                  o = f;
                  var p = tryCatch(e, r, n);
                  if ("normal" === p.type) {
                    if (o = n.done ? s : l, p.arg === y) continue;
                    return {
                      value: p.arg,
                      done: n.done
                    };
                  }
                  "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
                }
              };
            }
            function maybeInvokeDelegate(e, r) {
              var n = r.method,
                o = e.iterator[n];
              if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
              var i = tryCatch(o, e.iterator, r.arg);
              if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
              var a = i.arg;
              return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
            }
            function pushTryEntry(t) {
              var e = {
                tryLoc: t[0]
              };
              1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
            }
            function resetTryEntry(t) {
              var e = t.completion || {};
              e.type = "normal", delete e.arg, t.completion = e;
            }
            function Context(t) {
              this.tryEntries = [{
                tryLoc: "root"
              }], t.forEach(pushTryEntry, this), this.reset(!0);
            }
            function values(e) {
              if (e || "" === e) {
                var r = e[a];
                if (r) return r.call(e);
                if ("function" == typeof e.next) return e;
                if (!isNaN(e.length)) {
                  var o = -1,
                    i = function next() {
                      for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
                      return next.value = t, next.done = !0, next;
                    };
                  return i.next = i;
                }
              }
              throw new TypeError(_typeof(e) + " is not iterable");
            }
            return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
              value: GeneratorFunctionPrototype,
              configurable: !0
            }), o(GeneratorFunctionPrototype, "constructor", {
              value: GeneratorFunction,
              configurable: !0
            }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
              var e = "function" == typeof t && t.constructor;
              return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
            }, e.mark = function (t) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
            }, e.awrap = function (t) {
              return {
                __await: t
              };
            }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
              return this;
            }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
              void 0 === i && (i = Promise);
              var a = new AsyncIterator(wrap(t, r, n, o), i);
              return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
                return t.done ? t.value : a.next();
              });
            }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
              return this;
            }), define(g, "toString", function () {
              return "[object Generator]";
            }), e.keys = function (t) {
              var e = Object(t),
                r = [];
              for (var n in e) r.push(n);
              return r.reverse(), function next() {
                for (; r.length;) {
                  var t = r.pop();
                  if (t in e) return next.value = t, next.done = !1, next;
                }
                return next.done = !0, next;
              };
            }, e.values = values, Context.prototype = {
              constructor: Context,
              reset: function reset(e) {
                if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
              },
              stop: function stop() {
                this.done = !0;
                var t = this.tryEntries[0].completion;
                if ("throw" === t.type) throw t.arg;
                return this.rval;
              },
              dispatchException: function dispatchException(e) {
                if (this.done) throw e;
                var r = this;
                function handle(n, o) {
                  return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
                }
                for (var o = this.tryEntries.length - 1; o >= 0; --o) {
                  var i = this.tryEntries[o],
                    a = i.completion;
                  if ("root" === i.tryLoc) return handle("end");
                  if (i.tryLoc <= this.prev) {
                    var c = n.call(i, "catchLoc"),
                      u = n.call(i, "finallyLoc");
                    if (c && u) {
                      if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
                      if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
                    } else if (c) {
                      if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
                    } else {
                      if (!u) throw Error("try statement without catch or finally");
                      if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
                    }
                  }
                }
              },
              abrupt: function abrupt(t, e) {
                for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                  var o = this.tryEntries[r];
                  if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
                    var i = o;
                    break;
                  }
                }
                i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
                var a = i ? i.completion : {};
                return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
              },
              complete: function complete(t, e) {
                if ("throw" === t.type) throw t.arg;
                return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
              },
              finish: function finish(t) {
                for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                  var r = this.tryEntries[e];
                  if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
                }
              },
              "catch": function _catch(t) {
                for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                  var r = this.tryEntries[e];
                  if (r.tryLoc === t) {
                    var n = r.completion;
                    if ("throw" === n.type) {
                      var o = n.arg;
                      resetTryEntry(r);
                    }
                    return o;
                  }
                }
                throw Error("illegal catch attempt");
              },
              delegateYield: function delegateYield(e, r, n) {
                return this.delegate = {
                  iterator: values(e),
                  resultName: r,
                  nextLoc: n
                }, "next" === this.method && (this.arg = t), y;
              }
            }, e;
          }
          module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(regeneratorRuntime$1);
        var regeneratorRuntimeExports = regeneratorRuntime$1.exports;

        // TODO(Babel 8): Remove this file.

        var runtime = regeneratorRuntimeExports();
        var regenerator = runtime;

        // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
        try {
          regeneratorRuntime = runtime;
        } catch (accidentalStrictMode) {
          if (typeof globalThis === "object") {
            globalThis.regeneratorRuntime = runtime;
          } else {
            Function("r", "regeneratorRuntime = r")(runtime);
          }
        }
        const _regeneratorRuntime = /*@__PURE__*/getDefaultExportFromCjs(regenerator);
        var baseGetTag$3 = _baseGetTag,
          isObjectLike$6 = isObjectLike_1;

        /** `Object#toString` result references. */
        var symbolTag$4 = '[object Symbol]';

        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */
        function isSymbol$5(value) {
          return typeof value == 'symbol' || isObjectLike$6(value) && baseGetTag$3(value) == symbolTag$4;
        }
        var isSymbol_1 = isSymbol$5;
        var isArray$a = isArray_1,
          isSymbol$4 = isSymbol_1;

        /** Used to match property names within property paths. */
        var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp$1 = /^\w*$/;

        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey$4(value, object) {
          if (isArray$a(value)) {
            return false;
          }
          var type = typeof value;
          if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol$4(value)) {
            return true;
          }
          return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) || object != null && value in Object(object);
        }
        var _isKey = isKey$4;
        var MapCache$1 = _MapCache;

        /** Error message constants. */
        var FUNC_ERROR_TEXT$4 = 'Expected a function';

        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided, it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is used as the map cache key. The `func`
         * is invoked with the `this` binding of the memoized function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the
         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `clear`, `delete`, `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoized function.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         * var other = { 'c': 3, 'd': 4 };
         *
         * var values = _.memoize(_.values);
         * values(object);
         * // => [1, 2]
         *
         * values(other);
         * // => [3, 4]
         *
         * object.a = 2;
         * values(object);
         * // => [1, 2]
         *
         * // Modify the result cache.
         * values.cache.set(object, ['a', 'b']);
         * values(object);
         * // => ['a', 'b']
         *
         * // Replace `_.memoize.Cache`.
         * _.memoize.Cache = WeakMap;
         */
        function memoize$2(func, resolver) {
          if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT$4);
          }
          var _memoized = function memoized() {
            var args = arguments,
              key = resolver ? resolver.apply(this, args) : args[0],
              cache = _memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            _memoized.cache = cache.set(key, result) || cache;
            return result;
          };
          _memoized.cache = new (memoize$2.Cache || MapCache$1)();
          return _memoized;
        }

        // Expose `MapCache`.
        memoize$2.Cache = MapCache$1;
        var memoize_1 = memoize$2;
        var memoize$1 = memoize_1;

        /** Used as the maximum memoize cache size. */
        var MAX_MEMOIZE_SIZE$1 = 500;

        /**
         * A specialized version of `_.memoize` which clears the memoized function's
         * cache when it exceeds `MAX_MEMOIZE_SIZE`.
         *
         * @private
         * @param {Function} func The function to have its output memoized.
         * @returns {Function} Returns the new memoized function.
         */
        function memoizeCapped$2(func) {
          var result = memoize$1(func, function (key) {
            if (cache.size === MAX_MEMOIZE_SIZE$1) {
              cache.clear();
            }
            return key;
          });
          var cache = result.cache;
          return result;
        }
        var _memoizeCapped = memoizeCapped$2;
        var memoizeCapped$1 = _memoizeCapped;

        /** Used to match property names within property paths. */
        var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

        /** Used to match backslashes in property paths. */
        var reEscapeChar$1 = /\\(\\)?/g;

        /**
         * Converts `string` to a property path array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the property path array.
         */
        var stringToPath$2 = memoizeCapped$1(function (string) {
          var result = [];
          if (string.charCodeAt(0) === 46 /* . */) {
            result.push('');
          }
          string.replace(rePropName$1, function (match, number, quote, subString) {
            result.push(quote ? subString.replace(reEscapeChar$1, '$1') : number || match);
          });
          return result;
        });
        var _stringToPath = stringToPath$2;

        /**
         * A specialized version of `_.map` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */

        function arrayMap$5(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        var _arrayMap = arrayMap$5;
        var Symbol$4 = _Symbol,
          arrayMap$4 = _arrayMap,
          isArray$9 = isArray_1,
          isSymbol$3 = isSymbol_1;

        /** Used as references for various `Number` constants. */
        var INFINITY$4 = 1 / 0;

        /** Used to convert symbols to primitives and strings. */
        var symbolProto$3 = Symbol$4 ? Symbol$4.prototype : undefined,
          symbolToString$1 = symbolProto$3 ? symbolProto$3.toString : undefined;

        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString$3(value) {
          // Exit early for strings to avoid a performance hit in some environments.
          if (typeof value == 'string') {
            return value;
          }
          if (isArray$9(value)) {
            // Recursively convert values (susceptible to call stack limits).
            return arrayMap$4(value, baseToString$3) + '';
          }
          if (isSymbol$3(value)) {
            return symbolToString$1 ? symbolToString$1.call(value) : '';
          }
          var result = value + '';
          return result == '0' && 1 / value == -INFINITY$4 ? '-0' : result;
        }
        var _baseToString = baseToString$3;
        var baseToString$2 = _baseToString;

        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */
        function toString$3(value) {
          return value == null ? '' : baseToString$2(value);
        }
        var toString_1 = toString$3;
        var isArray$8 = isArray_1,
          isKey$3 = _isKey,
          stringToPath$1 = _stringToPath,
          toString$2 = toString_1;

        /**
         * Casts `value` to a path array if it's not one.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {Object} [object] The object to query keys on.
         * @returns {Array} Returns the cast property path array.
         */
        function castPath$7(value, object) {
          if (isArray$8(value)) {
            return value;
          }
          return isKey$3(value, object) ? [value] : stringToPath$1(toString$2(value));
        }
        var _castPath = castPath$7;
        var isSymbol$2 = isSymbol_1;

        /** Used as references for various `Number` constants. */
        var INFINITY$3 = 1 / 0;

        /**
         * Converts `value` to a string key if it's not a string or symbol.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {string|symbol} Returns the key.
         */
        function toKey$7(value) {
          if (typeof value == 'string' || isSymbol$2(value)) {
            return value;
          }
          var result = value + '';
          return result == '0' && 1 / value == -INFINITY$3 ? '-0' : result;
        }
        var _toKey = toKey$7;
        var castPath$6 = _castPath,
          toKey$6 = _toKey;

        /**
         * The base implementation of `_.get` without support for default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @returns {*} Returns the resolved value.
         */
        function baseGet$5(object, path) {
          path = castPath$6(path, object);
          var index = 0,
            length = path.length;
          while (object != null && index < length) {
            object = object[toKey$6(path[index++])];
          }
          return index && index == length ? object : undefined;
        }
        var _baseGet = baseGet$5;
        var getNative$1 = _getNative;
        var defineProperty$3 = function () {
          try {
            var func = getNative$1(Object, 'defineProperty');
            func({}, '', {});
            return func;
          } catch (e) {}
        }();
        var _defineProperty$1 = defineProperty$3;
        var defineProperty$2 = _defineProperty$1;

        /**
         * The base implementation of `assignValue` and `assignMergeValue` without
         * value checks.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function baseAssignValue$5(object, key, value) {
          if (key == '__proto__' && defineProperty$2) {
            defineProperty$2(object, key, {
              'configurable': true,
              'enumerable': true,
              'value': value,
              'writable': true
            });
          } else {
            object[key] = value;
          }
        }
        var _baseAssignValue = baseAssignValue$5;
        var baseAssignValue$4 = _baseAssignValue,
          eq$3 = eq_1;

        /** Used for built-in method references. */
        var objectProto$i = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$f = objectProto$i.hasOwnProperty;

        /**
         * Assigns `value` to `key` of `object` if the existing value is not equivalent
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignValue$4(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty$f.call(object, key) && eq$3(objValue, value)) || value === undefined && !(key in object)) {
            baseAssignValue$4(object, key, value);
          }
        }
        var _assignValue = assignValue$4;
        var assignValue$3 = _assignValue,
          castPath$5 = _castPath,
          isIndex$3 = _isIndex,
          isObject$f = isObject_1,
          toKey$5 = _toKey;

        /**
         * The base implementation of `_.set`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseSet$1(object, path, value, customizer) {
          if (!isObject$f(object)) {
            return object;
          }
          path = castPath$5(path, object);
          var index = -1,
            length = path.length,
            lastIndex = length - 1,
            nested = object;
          while (nested != null && ++index < length) {
            var key = toKey$5(path[index]),
              newValue = value;
            if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined;
              if (newValue === undefined) {
                newValue = isObject$f(objValue) ? objValue : isIndex$3(path[index + 1]) ? [] : {};
              }
            }
            assignValue$3(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var _baseSet = baseSet$1;
        var baseGet$4 = _baseGet,
          baseSet = _baseSet,
          castPath$4 = _castPath;

        /**
         * The base implementation of  `_.pickBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @param {Function} predicate The function invoked per property.
         * @returns {Object} Returns the new object.
         */
        function basePickBy$2(object, paths, predicate) {
          var index = -1,
            length = paths.length,
            result = {};
          while (++index < length) {
            var path = paths[index],
              value = baseGet$4(object, path);
            if (predicate(value, path)) {
              baseSet(result, castPath$4(path, object), value);
            }
          }
          return result;
        }
        var _basePickBy = basePickBy$2;

        /**
         * The base implementation of `_.hasIn` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */

        function baseHasIn$2(object, key) {
          return object != null && key in Object(object);
        }
        var _baseHasIn = baseHasIn$2;
        var castPath$3 = _castPath,
          isArguments$3 = isArguments_1,
          isArray$7 = isArray_1,
          isIndex$2 = _isIndex,
          isLength$1 = isLength_1,
          toKey$4 = _toKey;

        /**
         * Checks if `path` exists on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @param {Function} hasFunc The function to check properties.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         */
        function hasPath$2(object, path, hasFunc) {
          path = castPath$3(path, object);
          var index = -1,
            length = path.length,
            result = false;
          while (++index < length) {
            var key = toKey$4(path[index]);
            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result || ++index != length) {
            return result;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength$1(length) && isIndex$2(key, length) && (isArray$7(object) || isArguments$3(object));
        }
        var _hasPath = hasPath$2;
        var baseHasIn$1 = _baseHasIn,
          hasPath$1 = _hasPath;

        /**
         * Checks if `path` is a direct or inherited property of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.hasIn(object, 'a');
         * // => true
         *
         * _.hasIn(object, 'a.b');
         * // => true
         *
         * _.hasIn(object, ['a', 'b']);
         * // => true
         *
         * _.hasIn(object, 'b');
         * // => false
         */
        function hasIn$3(object, path) {
          return object != null && hasPath$1(object, path, baseHasIn$1);
        }
        var hasIn_1 = hasIn$3;
        var basePickBy$1 = _basePickBy,
          hasIn$2 = hasIn_1;

        /**
         * The base implementation of `_.pick` without support for individual
         * property identifiers.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @returns {Object} Returns the new object.
         */
        function basePick$1(object, paths) {
          return basePickBy$1(object, paths, function (value, path) {
            return hasIn$2(object, path);
          });
        }
        var _basePick = basePick$1;
        var Symbol$3 = _Symbol,
          isArguments$2 = isArguments_1,
          isArray$6 = isArray_1;

        /** Built-in value references. */
        var spreadableSymbol = Symbol$3 ? Symbol$3.isConcatSpreadable : undefined;

        /**
         * Checks if `value` is a flattenable `arguments` object or array.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
         */
        function isFlattenable$1(value) {
          return isArray$6(value) || isArguments$2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        var _isFlattenable = isFlattenable$1;
        var arrayPush$2 = _arrayPush,
          isFlattenable = _isFlattenable;

        /**
         * The base implementation of `_.flatten` with support for restricting flattening.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {number} depth The maximum recursion depth.
         * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
         * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */
        function baseFlatten$1(array, depth, predicate, isStrict, result) {
          var index = -1,
            length = array.length;
          predicate || (predicate = isFlattenable);
          result || (result = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten$1(value, depth - 1, predicate, isStrict, result);
              } else {
                arrayPush$2(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }
        var _baseFlatten = baseFlatten$1;
        var baseFlatten = _baseFlatten;

        /**
         * Flattens `array` a single level deep.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, [3, [4]], 5]]);
         * // => [1, 2, [3, [4]], 5]
         */
        function flatten$1(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        var flatten_1 = flatten$1;

        /**
         * A faster alternative to `Function#apply`, this function invokes `func`
         * with the `this` binding of `thisArg` and the arguments of `args`.
         *
         * @private
         * @param {Function} func The function to invoke.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} args The arguments to invoke `func` with.
         * @returns {*} Returns the result of `func`.
         */

        function apply$2(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        var _apply = apply$2;
        var apply$1 = _apply;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeMax$4 = Math.max;

        /**
         * A specialized version of `baseRest` which transforms the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @param {Function} transform The rest array transform.
         * @returns {Function} Returns the new function.
         */
        function overRest$3(func, start, transform) {
          start = nativeMax$4(start === undefined ? func.length - 1 : start, 0);
          return function () {
            var args = arguments,
              index = -1,
              length = nativeMax$4(args.length - start, 0),
              array = Array(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform(array);
            return apply$1(func, this, otherArgs);
          };
        }
        var _overRest = overRest$3;

        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new constant function.
         * @example
         *
         * var objects = _.times(2, _.constant({ 'a': 1 }));
         *
         * console.log(objects);
         * // => [{ 'a': 1 }, { 'a': 1 }]
         *
         * console.log(objects[0] === objects[1]);
         * // => true
         */

        function constant$2(value) {
          return function () {
            return value;
          };
        }
        var constant_1 = constant$2;

        /**
         * This method returns the first argument it receives.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'a': 1 };
         *
         * console.log(_.identity(object) === object);
         * // => true
         */

        function identity$5(value) {
          return value;
        }
        var identity_1 = identity$5;
        var constant$1 = constant_1,
          defineProperty$1 = _defineProperty$1,
          identity$4 = identity_1;

        /**
         * The base implementation of `setToString` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var baseSetToString$2 = !defineProperty$1 ? identity$4 : function (func, string) {
          return defineProperty$1(func, 'toString', {
            'configurable': true,
            'enumerable': false,
            'value': constant$1(string),
            'writable': true
          });
        };
        var _baseSetToString = baseSetToString$2;

        /** Used to detect hot functions by number of calls within a span of milliseconds. */

        var HOT_COUNT$1 = 800,
          HOT_SPAN$1 = 16;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeNow$1 = Date.now;

        /**
         * Creates a function that'll short out and invoke `identity` instead
         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
         * milliseconds.
         *
         * @private
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new shortable function.
         */
        function shortOut$2(func) {
          var count = 0,
            lastCalled = 0;
          return function () {
            var stamp = nativeNow$1(),
              remaining = HOT_SPAN$1 - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT$1) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined, arguments);
          };
        }
        var _shortOut = shortOut$2;
        var baseSetToString$1 = _baseSetToString,
          shortOut$1 = _shortOut;

        /**
         * Sets the `toString` method of `func` to return `string`.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var setToString$3 = shortOut$1(baseSetToString$1);
        var _setToString = setToString$3;
        var flatten = flatten_1,
          overRest$2 = _overRest,
          setToString$2 = _setToString;

        /**
         * A specialized version of `baseRest` which flattens the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */
        function flatRest$2(func) {
          return setToString$2(overRest$2(func, undefined, flatten), func + '');
        }
        var _flatRest = flatRest$2;
        var basePick = _basePick,
          flatRest$1 = _flatRest;

        /**
         * Creates an object composed of the picked `object` properties.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pick(object, ['a', 'c']);
         * // => { 'a': 1, 'c': 3 }
         */
        var pick = flatRest$1(function (object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        var pick_1 = pick;
        const pick$1 = /*@__PURE__*/getDefaultExportFromCjs(pick_1);

        /**
         * Gets the last element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the last element of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         */

        function last$1(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined;
        }
        var last_1 = last$1;
        const last$2 = /*@__PURE__*/getDefaultExportFromCjs(last_1);

        /**
         * A specialized version of `_.forEach` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */

        function arrayEach$2(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        var _arrayEach = arrayEach$2;
        var assignValue$2 = _assignValue,
          baseAssignValue$3 = _baseAssignValue;

        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property identifiers to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @param {Function} [customizer] The function to customize copied values.
         * @returns {Object} Returns `object`.
         */
        function copyObject$7(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1,
            length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
            if (newValue === undefined) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue$3(object, key, newValue);
            } else {
              assignValue$2(object, key, newValue);
            }
          }
          return object;
        }
        var _copyObject = copyObject$7;
        var copyObject$6 = _copyObject,
          keys$4 = keys_1;

        /**
         * The base implementation of `_.assign` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssign$1(object, source) {
          return object && copyObject$6(source, keys$4(source), object);
        }
        var _baseAssign = baseAssign$1;

        /**
         * This function is like
         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * except that it includes inherited enumerable properties.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */

        function nativeKeysIn$2(object) {
          var result = [];
          if (object != null) {
            for (var key in Object(object)) {
              result.push(key);
            }
          }
          return result;
        }
        var _nativeKeysIn = nativeKeysIn$2;
        var isObject$e = isObject_1,
          isPrototype$2 = _isPrototype,
          nativeKeysIn$1 = _nativeKeysIn;

        /** Used for built-in method references. */
        var objectProto$h = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$e = objectProto$h.hasOwnProperty;

        /**
         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeysIn$2(object) {
          if (!isObject$e(object)) {
            return nativeKeysIn$1(object);
          }
          var isProto = isPrototype$2(object),
            result = [];
          for (var key in object) {
            if (!(key == 'constructor' && (isProto || !hasOwnProperty$e.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        var _baseKeysIn = baseKeysIn$2;
        var arrayLikeKeys$1 = _arrayLikeKeys,
          baseKeysIn$1 = _baseKeysIn,
          isArrayLike$5 = isArrayLike_1;

        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn$6(object) {
          return isArrayLike$5(object) ? arrayLikeKeys$1(object, true) : baseKeysIn$1(object);
        }
        var keysIn_1 = keysIn$6;
        var copyObject$5 = _copyObject,
          keysIn$5 = keysIn_1;

        /**
         * The base implementation of `_.assignIn` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssignIn$1(object, source) {
          return object && copyObject$5(source, keysIn$5(source), object);
        }
        var _baseAssignIn = baseAssignIn$1;
        var _cloneBuffer = {
          exports: {}
        };
        _cloneBuffer.exports;
        (function (module, exports) {
          var root = _root;

          /** Detect free variable `exports`. */
          var freeExports = exports && !exports.nodeType && exports;

          /** Detect free variable `module`. */
          var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

          /** Detect the popular CommonJS extension `module.exports`. */
          var moduleExports = freeModule && freeModule.exports === freeExports;

          /** Built-in value references. */
          var Buffer = moduleExports ? root.Buffer : undefined,
            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

          /**
           * Creates a clone of  `buffer`.
           *
           * @private
           * @param {Buffer} buffer The buffer to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Buffer} Returns the cloned buffer.
           */
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length,
              result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result);
            return result;
          }
          module.exports = cloneBuffer;
        })(_cloneBuffer, _cloneBuffer.exports);
        var _cloneBufferExports = _cloneBuffer.exports;

        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */

        function copyArray$3(source, array) {
          var index = -1,
            length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        var _copyArray = copyArray$3;
        var copyObject$4 = _copyObject,
          getSymbols$2 = _getSymbols;

        /**
         * Copies own symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbols$1(source, object) {
          return copyObject$4(source, getSymbols$2(source), object);
        }
        var _copySymbols = copySymbols$1;
        var overArg$1 = _overArg;

        /** Built-in value references. */
        var getPrototype$4 = overArg$1(Object.getPrototypeOf, Object);
        var _getPrototype = getPrototype$4;
        var arrayPush$1 = _arrayPush,
          getPrototype$3 = _getPrototype,
          getSymbols$1 = _getSymbols,
          stubArray$1 = stubArray_1;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

        /**
         * Creates an array of the own and inherited enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbolsIn$2 = !nativeGetSymbols$1 ? stubArray$1 : function (object) {
          var result = [];
          while (object) {
            arrayPush$1(result, getSymbols$1(object));
            object = getPrototype$3(object);
          }
          return result;
        };
        var _getSymbolsIn = getSymbolsIn$2;
        var copyObject$3 = _copyObject,
          getSymbolsIn$1 = _getSymbolsIn;

        /**
         * Copies own and inherited symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbolsIn$1(source, object) {
          return copyObject$3(source, getSymbolsIn$1(source), object);
        }
        var _copySymbolsIn = copySymbolsIn$1;
        var baseGetAllKeys$1 = _baseGetAllKeys,
          getSymbolsIn = _getSymbolsIn,
          keysIn$4 = keysIn_1;

        /**
         * Creates an array of own and inherited enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeysIn$3(object) {
          return baseGetAllKeys$1(object, keysIn$4, getSymbolsIn);
        }
        var _getAllKeysIn = getAllKeysIn$3;

        /** Used for built-in method references. */

        var objectProto$g = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$d = objectProto$g.hasOwnProperty;

        /**
         * Initializes an array clone.
         *
         * @private
         * @param {Array} array The array to clone.
         * @returns {Array} Returns the initialized clone.
         */
        function initCloneArray$1(array) {
          var length = array.length,
            result = new array.constructor(length);

          // Add properties assigned by `RegExp#exec`.
          if (length && typeof array[0] == 'string' && hasOwnProperty$d.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        var _initCloneArray = initCloneArray$1;
        var Uint8Array$2 = _Uint8Array;

        /**
         * Creates a clone of `arrayBuffer`.
         *
         * @private
         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */
        function cloneArrayBuffer$4(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
          return result;
        }
        var _cloneArrayBuffer = cloneArrayBuffer$4;
        var cloneArrayBuffer$3 = _cloneArrayBuffer;

        /**
         * Creates a clone of `dataView`.
         *
         * @private
         * @param {Object} dataView The data view to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned data view.
         */
        function cloneDataView$1(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer$3(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        var _cloneDataView = cloneDataView$1;

        /** Used to match `RegExp` flags from their coerced string values. */

        var reFlags = /\w*$/;

        /**
         * Creates a clone of `regexp`.
         *
         * @private
         * @param {Object} regexp The regexp to clone.
         * @returns {Object} Returns the cloned regexp.
         */
        function cloneRegExp$1(regexp) {
          var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result.lastIndex = regexp.lastIndex;
          return result;
        }
        var _cloneRegExp = cloneRegExp$1;
        var Symbol$2 = _Symbol;

        /** Used to convert symbols to primitives and strings. */
        var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : undefined,
          symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

        /**
         * Creates a clone of the `symbol` object.
         *
         * @private
         * @param {Object} symbol The symbol object to clone.
         * @returns {Object} Returns the cloned symbol object.
         */
        function cloneSymbol$1(symbol) {
          return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
        }
        var _cloneSymbol = cloneSymbol$1;
        var cloneArrayBuffer$2 = _cloneArrayBuffer;

        /**
         * Creates a clone of `typedArray`.
         *
         * @private
         * @param {Object} typedArray The typed array to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned typed array.
         */
        function cloneTypedArray$3(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer$2(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        var _cloneTypedArray = cloneTypedArray$3;
        var cloneArrayBuffer$1 = _cloneArrayBuffer,
          cloneDataView = _cloneDataView,
          cloneRegExp = _cloneRegExp,
          cloneSymbol = _cloneSymbol,
          cloneTypedArray$2 = _cloneTypedArray;

        /** `Object#toString` result references. */
        var boolTag$3 = '[object Boolean]',
          dateTag$3 = '[object Date]',
          mapTag$5 = '[object Map]',
          numberTag$3 = '[object Number]',
          regexpTag$3 = '[object RegExp]',
          setTag$5 = '[object Set]',
          stringTag$4 = '[object String]',
          symbolTag$3 = '[object Symbol]';
        var arrayBufferTag$3 = '[object ArrayBuffer]',
          dataViewTag$4 = '[object DataView]',
          float32Tag$2 = '[object Float32Array]',
          float64Tag$2 = '[object Float64Array]',
          int8Tag$2 = '[object Int8Array]',
          int16Tag$2 = '[object Int16Array]',
          int32Tag$2 = '[object Int32Array]',
          uint8Tag$2 = '[object Uint8Array]',
          uint8ClampedTag$2 = '[object Uint8ClampedArray]',
          uint16Tag$2 = '[object Uint16Array]',
          uint32Tag$2 = '[object Uint32Array]';

        /**
         * Initializes an object clone based on its `toStringTag`.
         *
         * **Note:** This function only supports cloning values with tags of
         * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
         *
         * @private
         * @param {Object} object The object to clone.
         * @param {string} tag The `toStringTag` of the object to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneByTag$1(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag$3:
              return cloneArrayBuffer$1(object);
            case boolTag$3:
            case dateTag$3:
              return new Ctor(+object);
            case dataViewTag$4:
              return cloneDataView(object, isDeep);
            case float32Tag$2:
            case float64Tag$2:
            case int8Tag$2:
            case int16Tag$2:
            case int32Tag$2:
            case uint8Tag$2:
            case uint8ClampedTag$2:
            case uint16Tag$2:
            case uint32Tag$2:
              return cloneTypedArray$2(object, isDeep);
            case mapTag$5:
              return new Ctor();
            case numberTag$3:
            case stringTag$4:
              return new Ctor(object);
            case regexpTag$3:
              return cloneRegExp(object);
            case setTag$5:
              return new Ctor();
            case symbolTag$3:
              return cloneSymbol(object);
          }
        }
        var _initCloneByTag = initCloneByTag$1;
        var isObject$d = isObject_1;

        /** Built-in value references. */
        var objectCreate$1 = Object.create;

        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} proto The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        var baseCreate$2 = function () {
          function object() {}
          return function (proto) {
            if (!isObject$d(proto)) {
              return {};
            }
            if (objectCreate$1) {
              return objectCreate$1(proto);
            }
            object.prototype = proto;
            var result = new object();
            object.prototype = undefined;
            return result;
          };
        }();
        var _baseCreate = baseCreate$2;
        var baseCreate$1 = _baseCreate,
          getPrototype$2 = _getPrototype,
          isPrototype$1 = _isPrototype;

        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneObject$3(object) {
          return typeof object.constructor == 'function' && !isPrototype$1(object) ? baseCreate$1(getPrototype$2(object)) : {};
        }
        var _initCloneObject = initCloneObject$3;
        var getTag$3 = _getTag,
          isObjectLike$5 = isObjectLike_1;

        /** `Object#toString` result references. */
        var mapTag$4 = '[object Map]';

        /**
         * The base implementation of `_.isMap` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         */
        function baseIsMap$1(value) {
          return isObjectLike$5(value) && getTag$3(value) == mapTag$4;
        }
        var _baseIsMap = baseIsMap$1;
        var baseIsMap = _baseIsMap,
          baseUnary$2 = _baseUnary,
          nodeUtil$2 = _nodeUtilExports;

        /* Node.js helper references. */
        var nodeIsMap = nodeUtil$2 && nodeUtil$2.isMap;

        /**
         * Checks if `value` is classified as a `Map` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         * @example
         *
         * _.isMap(new Map);
         * // => true
         *
         * _.isMap(new WeakMap);
         * // => false
         */
        var isMap$1 = nodeIsMap ? baseUnary$2(nodeIsMap) : baseIsMap;
        var isMap_1 = isMap$1;
        var getTag$2 = _getTag,
          isObjectLike$4 = isObjectLike_1;

        /** `Object#toString` result references. */
        var setTag$4 = '[object Set]';

        /**
         * The base implementation of `_.isSet` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         */
        function baseIsSet$1(value) {
          return isObjectLike$4(value) && getTag$2(value) == setTag$4;
        }
        var _baseIsSet = baseIsSet$1;
        var baseIsSet = _baseIsSet,
          baseUnary$1 = _baseUnary,
          nodeUtil$1 = _nodeUtilExports;

        /* Node.js helper references. */
        var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;

        /**
         * Checks if `value` is classified as a `Set` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         * @example
         *
         * _.isSet(new Set);
         * // => true
         *
         * _.isSet(new WeakSet);
         * // => false
         */
        var isSet$1 = nodeIsSet ? baseUnary$1(nodeIsSet) : baseIsSet;
        var isSet_1 = isSet$1;
        var Stack$3 = _Stack,
          arrayEach$1 = _arrayEach,
          assignValue$1 = _assignValue,
          baseAssign = _baseAssign,
          baseAssignIn = _baseAssignIn,
          cloneBuffer$2 = _cloneBufferExports,
          copyArray$2 = _copyArray,
          copySymbols = _copySymbols,
          copySymbolsIn = _copySymbolsIn,
          getAllKeys$1 = _getAllKeys,
          getAllKeysIn$2 = _getAllKeysIn,
          getTag$1 = _getTag,
          initCloneArray = _initCloneArray,
          initCloneByTag = _initCloneByTag,
          initCloneObject$2 = _initCloneObject,
          isArray$5 = isArray_1,
          isBuffer$2 = isBufferExports,
          isMap = isMap_1,
          isObject$c = isObject_1,
          isSet = isSet_1,
          keys$3 = keys_1,
          keysIn$3 = keysIn_1;

        /** Used to compose bitmasks for cloning. */
        var CLONE_DEEP_FLAG$2 = 1,
          CLONE_FLAT_FLAG$1 = 2,
          CLONE_SYMBOLS_FLAG$2 = 4;

        /** `Object#toString` result references. */
        var argsTag$3 = '[object Arguments]',
          arrayTag$2 = '[object Array]',
          boolTag$2 = '[object Boolean]',
          dateTag$2 = '[object Date]',
          errorTag$2 = '[object Error]',
          funcTag$2 = '[object Function]',
          genTag$1 = '[object GeneratorFunction]',
          mapTag$3 = '[object Map]',
          numberTag$2 = '[object Number]',
          objectTag$5 = '[object Object]',
          regexpTag$2 = '[object RegExp]',
          setTag$3 = '[object Set]',
          stringTag$3 = '[object String]',
          symbolTag$2 = '[object Symbol]',
          weakMapTag$2 = '[object WeakMap]';
        var arrayBufferTag$2 = '[object ArrayBuffer]',
          dataViewTag$3 = '[object DataView]',
          float32Tag$1 = '[object Float32Array]',
          float64Tag$1 = '[object Float64Array]',
          int8Tag$1 = '[object Int8Array]',
          int16Tag$1 = '[object Int16Array]',
          int32Tag$1 = '[object Int32Array]',
          uint8Tag$1 = '[object Uint8Array]',
          uint8ClampedTag$1 = '[object Uint8ClampedArray]',
          uint16Tag$1 = '[object Uint16Array]',
          uint32Tag$1 = '[object Uint32Array]';

        /** Used to identify `toStringTag` values supported by `_.clone`. */
        var cloneableTags = {};
        cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag$1] = cloneableTags[float64Tag$1] = cloneableTags[int8Tag$1] = cloneableTags[int16Tag$1] = cloneableTags[int32Tag$1] = cloneableTags[mapTag$3] = cloneableTags[numberTag$2] = cloneableTags[objectTag$5] = cloneableTags[regexpTag$2] = cloneableTags[setTag$3] = cloneableTags[stringTag$3] = cloneableTags[symbolTag$2] = cloneableTags[uint8Tag$1] = cloneableTags[uint8ClampedTag$1] = cloneableTags[uint16Tag$1] = cloneableTags[uint32Tag$1] = true;
        cloneableTags[errorTag$2] = cloneableTags[funcTag$2] = cloneableTags[weakMapTag$2] = false;

        /**
         * The base implementation of `_.clone` and `_.cloneDeep` which tracks
         * traversed objects.
         *
         * @private
         * @param {*} value The value to clone.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Deep clone
         *  2 - Flatten inherited properties
         *  4 - Clone symbols
         * @param {Function} [customizer] The function to customize cloning.
         * @param {string} [key] The key of `value`.
         * @param {Object} [object] The parent object of `value`.
         * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
         * @returns {*} Returns the cloned value.
         */
        function baseClone$2(value, bitmask, customizer, key, object, stack) {
          var result,
            isDeep = bitmask & CLONE_DEEP_FLAG$2,
            isFlat = bitmask & CLONE_FLAT_FLAG$1,
            isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
          if (customizer) {
            result = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result !== undefined) {
            return result;
          }
          if (!isObject$c(value)) {
            return value;
          }
          var isArr = isArray$5(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return copyArray$2(value, result);
            }
          } else {
            var tag = getTag$1(value),
              isFunc = tag == funcTag$2 || tag == genTag$1;
            if (isBuffer$2(value)) {
              return cloneBuffer$2(value, isDeep);
            }
            if (tag == objectTag$5 || tag == argsTag$3 || isFunc && !object) {
              result = isFlat || isFunc ? {} : initCloneObject$2(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result = initCloneByTag(value, tag, isDeep);
            }
          }
          // Check for circular references and return its corresponding clone.
          stack || (stack = new Stack$3());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result);
          if (isSet(value)) {
            value.forEach(function (subValue) {
              result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function (subValue, key) {
              result.set(key, baseClone$2(subValue, bitmask, customizer, key, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn$2 : getAllKeys$1 : isFlat ? keysIn$3 : keys$3;
          var props = isArr ? undefined : keysFunc(value);
          arrayEach$1(props || value, function (subValue, key) {
            if (props) {
              key = subValue;
              subValue = value[key];
            }
            // Recursively populate clone (susceptible to call stack limits).
            assignValue$1(result, key, baseClone$2(subValue, bitmask, customizer, key, value, stack));
          });
          return result;
        }
        var _baseClone = baseClone$2;

        /**
         * The base implementation of `_.slice` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */

        function baseSlice$1(array, start, end) {
          var index = -1,
            length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
        var _baseSlice = baseSlice$1;
        var baseGet$3 = _baseGet,
          baseSlice = _baseSlice;

        /**
         * Gets the parent value at `path` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} path The path to get the parent value of.
         * @returns {*} Returns the parent value.
         */
        function parent$2(object, path) {
          return path.length < 2 ? object : baseGet$3(object, baseSlice(path, 0, -1));
        }
        var _parent = parent$2;
        var castPath$2 = _castPath,
          last = last_1,
          parent$1 = _parent,
          toKey$3 = _toKey;

        /**
         * The base implementation of `_.unset`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The property path to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         */
        function baseUnset$1(object, path) {
          path = castPath$2(path, object);
          object = parent$1(object, path);
          return object == null || delete object[toKey$3(last(path))];
        }
        var _baseUnset = baseUnset$1;
        var baseGetTag$2 = _baseGetTag,
          getPrototype$1 = _getPrototype,
          isObjectLike$3 = isObjectLike_1;

        /** `Object#toString` result references. */
        var objectTag$4 = '[object Object]';

        /** Used for built-in method references. */
        var funcProto$3 = Function.prototype,
          objectProto$f = Object.prototype;

        /** Used to resolve the decompiled source of functions. */
        var funcToString$3 = funcProto$3.toString;

        /** Used to check objects for own properties. */
        var hasOwnProperty$c = objectProto$f.hasOwnProperty;

        /** Used to infer the `Object` constructor. */
        var objectCtorString$1 = funcToString$3.call(Object);

        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * @static
         * @memberOf _
         * @since 0.8.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject$3(value) {
          if (!isObjectLike$3(value) || baseGetTag$2(value) != objectTag$4) {
            return false;
          }
          var proto = getPrototype$1(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty$c.call(proto, 'constructor') && proto.constructor;
          return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$3.call(Ctor) == objectCtorString$1;
        }
        var isPlainObject_1 = isPlainObject$3;
        var isPlainObject$2 = isPlainObject_1;

        /**
         * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
         * objects.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {string} key The key of the property to inspect.
         * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
         */
        function customOmitClone$1(value) {
          return isPlainObject$2(value) ? undefined : value;
        }
        var _customOmitClone = customOmitClone$1;
        var arrayMap$3 = _arrayMap,
          baseClone$1 = _baseClone,
          baseUnset = _baseUnset,
          castPath$1 = _castPath,
          copyObject$2 = _copyObject,
          customOmitClone = _customOmitClone,
          flatRest = _flatRest,
          getAllKeysIn$1 = _getAllKeysIn;

        /** Used to compose bitmasks for cloning. */
        var CLONE_DEEP_FLAG$1 = 1,
          CLONE_FLAT_FLAG = 2,
          CLONE_SYMBOLS_FLAG$1 = 4;

        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable property paths of `object` that are not omitted.
         *
         * **Note:** This method is considerably slower than `_.pick`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to omit.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omit(object, ['a', 'c']);
         * // => { 'b': '2' }
         */
        var omit = flatRest(function (object, paths) {
          var result = {};
          if (object == null) {
            return result;
          }
          var isDeep = false;
          paths = arrayMap$3(paths, function (path) {
            path = castPath$1(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject$2(object, getAllKeysIn$1(object), result);
          if (isDeep) {
            result = baseClone$1(result, CLONE_DEEP_FLAG$1 | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG$1, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result, paths[length]);
          }
          return result;
        });
        var omit_1 = omit;
        const omit$1 = /*@__PURE__*/getDefaultExportFromCjs(omit_1);
        function _createForOfIteratorHelper$e(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$e(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$e(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$e(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$e(o, minLen);
        }
        function _arrayLikeToArray$e(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function ownKeys$C(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$C(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$C(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$C(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        var isObject$b = function isObject(v) {
          return _typeof$3(v) == "object" && v !== null && !Array.isArray(v);
        };
        var toListValue = function toListValue(v, title) {
          if (v == null || v == "") {
            return undefined;
          } else if (isObject$b(v)) {
            return _objectSpread$C(_objectSpread$C({}, v), {}, {
              title: v.title || v.value // fallback to value
            });
          } else {
            return {
              value: v,
              title: title !== undefined ? title : "" + v
            };
          }
        };
        var makeCustomListValue$1 = function makeCustomListValue(v) {
          var lv = toListValue(v);
          if (isObject$b(lv)) {
            return _objectSpread$C(_objectSpread$C({}, toListValue(v)), {}, {
              isCustom: true
            });
          } else {
            // only if undefined
            return lv;
          }
        };

        // convert {<value>: <title>, ..} or [value, ..] to normal [{value, title}, ..]
        var listValuesToArray$1 = function listValuesToArray(listValuesObj) {
          if (Array.isArray(listValuesObj)) return listValuesObj.map(function (v) {
            return toListValue(v);
          });
          if (!isObject$b(listValuesObj)) return listValuesObj;
          var listValuesArr = [];
          for (var v in listValuesObj) {
            var title = listValuesObj[v];
            listValuesArr.push(toListValue(v, title));
          }
          return listValuesArr;
        };

        // listValues can be {<value>: <title>, ..} or [{value, title}, ..] or [value, ..]
        // todo: same as getListValue() (but args are switched)
        var getItemInListValues = function getItemInListValues(listValues, value) {
          if (Array.isArray(listValues)) {
            var values = listValues.map(function (v) {
              return toListValue(v);
            });
            return values.find(function (v) {
              return "" + v.value === "" + value;
            });
          } else {
            return listValues[value] !== undefined ? toListValue(value, listValues[value]) : undefined;
          }
        };
        var getTitleInListValues$1 = function getTitleInListValues(listValues, value) {
          if (listValues == undefined) return value;
          var it = getItemInListValues(listValues, value);
          return it !== undefined ? it.title : value;
        };
        var getValueInListValues = function getValueInListValues(listValues, value) {
          if (listValues == undefined) return value;
          var it = getItemInListValues(listValues, value);
          return it !== undefined ? it.value : value;
        };
        var mapListValues$5 = function mapListValues(listValues, mapFn) {
          var ret = [];
          if (Array.isArray(listValues)) {
            var _iterator = _createForOfIteratorHelper$e(listValues),
              _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var v = _step.value;
                var lv = mapFn(toListValue(v));
                if (lv != null) ret.push(lv);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          } else {
            for (var value in listValues) {
              var _lv = mapFn(toListValue(value, listValues[value]));
              if (_lv != null) ret.push(_lv);
            }
          }
          return ret;
        };
        var searchListValue$1 = function searchListValue(search, listValues) {
          return mapListValues$5(listValues, function (lv) {
            return "".concat(lv.value).indexOf(search) != -1 || lv.title.indexOf(search) != -1 ? lv : null;
          }).filter(function (v) {
            return v !== null;
          }).shift();
        };
        var getListValue$1 = function getListValue(selectedValue, listValues) {
          return mapListValues$5(listValues, function (lv) {
            return "" + lv.value === "" + selectedValue ? lv : null;
          }).filter(function (v) {
            return v !== null;
          }).shift();
        };
        const listValues = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          getItemInListValues,
          getListValue: getListValue$1,
          getTitleInListValues: getTitleInListValues$1,
          getValueInListValues,
          listValuesToArray: listValuesToArray$1,
          makeCustomListValue: makeCustomListValue$1,
          mapListValues: mapListValues$5,
          searchListValue: searchListValue$1,
          toListValue
        }, Symbol.toStringTag, {
          value: 'Module'
        }));

        /**
         * @param {Immutable.List} path
         * @param {...string} suffix
         * @return {Immutable.List}
         */
        var expandTreePath = function expandTreePath(path) {
          for (var _len = arguments.length, suffix = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            suffix[_key - 1] = arguments[_key];
          }
          return path.interpose("children1").withMutations(function (list) {
            list.skip(1);
            list.push.apply(list, suffix);
            return list;
          });
        };

        /**
         * @param {Immutable.List} path
         * @param {...string} suffix
         * @return {Immutable.List}
         */
        var expandTreeSubpath = function expandTreeSubpath(path) {
          for (var _len2 = arguments.length, suffix = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            suffix[_key2 - 1] = arguments[_key2];
          }
          return path.interpose("children1").withMutations(function (list) {
            list.push.apply(list, suffix);
            return list;
          });
        };

        /**
         * @param {Immutable.Map} tree
         * @param {Immutable.List} path
         * @return {Immutable.Map}
         */
        var getItemByPath = function getItemByPath(tree, path) {
          var children = new Immutable.OrderedMap(_defineProperty$4({}, tree.get("id"), tree));
          var res = tree;
          path.forEach(function (id) {
            var _res;
            res = children.get(id);
            children = (_res = res) === null || _res === void 0 ? void 0 : _res.get("children1");
          });
          return res;
        };

        /**
         * Remove `path` in every item
         * @param {Immutable.Map} tree
         * @return {Immutable.Map} tree
         */
        // export const removePathsInTree = (tree) => {
        //   let newTree = tree;

        //   function _processNode (item, path) {
        //     const itemPath = path.push(item.get("id"));
        //     if (item.get("path")) {
        //       newTree = newTree.removeIn(expandTreePath(itemPath, "path"));
        //     }

        //     const children = item.get("children1");
        //     if (children) {
        //       children.map((child, _childId) => {
        //         _processNode(child, itemPath);
        //       });
        //     }
        //   }

        //   _processNode(tree, new Immutable.List());

        //   return newTree;
        // };

        /**
         * Remove `isLocked` in items that inherit parent's `isLocked`
         * @param {Immutable.Map} tree
         * @return {Immutable.Map} tree
         */
        var removeIsLockedInTree = function removeIsLockedInTree(tree) {
          var newTree = tree;
          function _processNode(item, path) {
            var isParentLocked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var itemPath = path.push(item.get("id"));
            var isLocked = item.getIn(["properties", "isLocked"]);
            if (isParentLocked && isLocked) {
              newTree = newTree.deleteIn(expandTreePath(itemPath, "properties", "isLocked"));
            }
            var children = item.get("children1");
            if (children) {
              children.map(function (child, _childId) {
                _processNode(child, itemPath, isLocked || isParentLocked);
              });
            }
          }
          _processNode(tree, new Immutable.List());
          return newTree;
        };

        /**
         * Set correct `path` and `id` in every item
         * @param {Immutable.Map} tree
         * @return {Immutable.Map} tree
         */
        var fixPathsInTree = function fixPathsInTree(tree) {
          var newTree = tree;
          function _processNode(item, path, lev, nodeId) {
            if (!item) return;
            var currPath = item.get("path");
            var currId = item.get("id");
            var itemId = currId || nodeId || uuid();
            var itemPath = path.push(itemId);
            if (!currPath || !currPath.equals(itemPath)) {
              newTree = newTree.setIn(expandTreePath(itemPath, "path"), itemPath);
            }
            if (!currId) {
              newTree = newTree.setIn(expandTreePath(itemPath, "id"), itemId);
            }
            var children = item.get("children1");
            if (children) {
              if (children.constructor.name === "Map") {
                // protect: should be OrderedMap, not Map (issue #501)
                newTree = newTree.setIn(expandTreePath(itemPath, "children1"), new Immutable.OrderedMap(children));
              }
              children.map(function (child, childId) {
                _processNode(child, itemPath, lev + 1, childId);
              });
            }
          }
          _processNode(tree, new Immutable.List(), 0);
          return newTree;
        };
        var fixEmptyGroupsInTree = function fixEmptyGroupsInTree(tree) {
          var newTree = tree;
          function _processNode(item, path, lev, nodeId) {
            if (!item) return false;
            var itemId = item.get("id") || nodeId;
            var itemPath = path.push(itemId);
            var children = item.get("children1");
            if (children) {
              var allChildrenGone = children.map(function (child, childId) {
                return _processNode(child, itemPath, lev + 1, childId);
              }).reduce(function (curr, v) {
                return curr && v;
              }, true);
              if ((children.size == 0 || allChildrenGone) && lev > 0) {
                newTree = newTree.deleteIn(expandTreePath(itemPath));
                return true;
              }
            }
            return false;
          }
          _processNode(tree, new Immutable.List(), 0);
          return newTree;
        };

        /**
         * @param {Immutable.Map} tree
         * @return {Object} {flat, items}
         */
        var getFlatTree$1 = function getFlatTree(tree) {
          var flat = [];
          var items = {};
          var cases = [];
          var visibleHeight = 0; // number of non-collapsed nodes
          var globalLeafCount = 0;
          var globalGroupCount = 0;
          var globalCountByType = {};
          // rule_group_ext can be counted as group  (group #x)
          // or by similars (rule-group #x) (NOT both _ext and no ext)

          function _flatizeTree(item, path, insideCollapsed, insideLocked, insideRuleGroup, lev, caseId, childNo) {
            var isRoot = item === tree;
            var type = item.get("type");
            var collapsed = item.get("collapsed");
            var id = item.get("id");
            var children = item.get("children1");
            var isLocked = item.getIn(["properties", "isLocked"]);
            var childrenIds = children ? children.map(function (_child, childId) {
              return childId;
            }).valueSeq().toArray() : null;
            var isRuleGroup = type === "rule_group";
            var isRule = type === "rule";
            var isGroup = type === "group";
            var isCaseGroup = type === "case_group";
            // tip: count rule_group as 1 atomic rule
            var isAtomicRule = !insideRuleGroup && (!children || isRuleGroup);
            var hasChildren = (childrenIds === null || childrenIds === void 0 ? void 0 : childrenIds.length) > 0;
            var parentId = path.length ? path[path.length - 1] : null;
            var currentCaseId = isCaseGroup ? id : caseId;

            // Calculations before
            if (isCaseGroup) {
              cases.push(id);
              // reset counters
              globalLeafCount = 0;
              globalGroupCount = 0;
              globalCountByType = {};
            }
            var caseNo = currentCaseId ? cases.indexOf(currentCaseId) : null;
            var itemsBefore = flat.length;
            var top = visibleHeight;
            var position;
            if (!isRoot) {
              position = {};
              position.caseNo = caseNo;
              position.globalNoByType = isCaseGroup ? caseNo : globalCountByType[type] || 0;
              position.indexPath = [].concat(_toConsumableArray(path.slice(1).map(function (id) {
                return items[id].childNo;
              })), [childNo]);
              if (isRule) {
                position.globalLeafNo = globalLeafCount;
              } else if (isGroup) {
                position.globalGroupNo = globalGroupCount;
              }
            }
            flat.push(id);
            items[id] = {
              node: item,
              index: itemsBefore,
              // index in `flat`
              id: id,
              type: type,
              parent: parentId,
              parentType: parentId ? items[parentId].type : null,
              children: childrenIds,
              childNo: childNo,
              caseId: currentCaseId,
              caseNo: caseNo,
              path: path.concat(id),
              lev: lev,
              // depth level (0 for root node)
              isLeaf: !children,
              // is atomic rule OR rule inside rule_group
              isAtomicRule: isAtomicRule,
              // is atomic (rule or rule_group, but not rules inside rule_group)
              isLocked: isLocked || insideLocked,
              // vertical
              top: insideCollapsed ? null : top,
              // for case
              isDefaultCase: isCaseGroup ? !children : undefined,
              atomicRulesCountInCase: isCaseGroup ? 0 : undefined,
              // object with numbers indicating # of item in tree
              position: position,
              // unused
              collapsed: collapsed,
              _top: itemsBefore,
              // @deprecated use isLeaf instead
              leaf: !children

              // will be added later:
              //  prev
              //  next
              //  depth  - for any group (children of rule_group are not counted, collapsed are not counted)
              //  height  - visible height
              //  bottom = (insideCollapsed ? null : top + height)
              //  _height = (itemsAfter - itemsBefore)  - real height (incl. collapsed)
            };

            // Calculations before traversing children
            var height = 0;
            var depth = 0;
            if (!insideCollapsed) {
              visibleHeight += 1;
              height += 1;
              if (hasChildren && !collapsed && !isRuleGroup) {
                // tip: don't count children of rule_group
                depth += 1;
              }
              if (!isRoot && !isCaseGroup) {
                isGroup && globalGroupCount++;
                isRule && globalLeafCount++;
                globalCountByType[type] = (globalCountByType[type] || 0) + 1;
              }
            }
            if (caseId && isAtomicRule) {
              items[caseId].atomicRulesCountInCase++;
            }

            // Traverse children deeply
            var maxChildDepth = 0;
            var sumHeight = 0;
            if (hasChildren) {
              var childCount = 0;
              children.map(function (child, childId) {
                if (child) {
                  _flatizeTree(child, path.concat(id), insideCollapsed || collapsed, insideLocked || isLocked, insideRuleGroup || isRuleGroup, lev + 1, currentCaseId, childCount);
                  var childItem = items[childId];
                  // Calculations after deep traversing 1 child
                  maxChildDepth = Math.max(maxChildDepth, childItem.depth || 0);
                  sumHeight += childItem.height;
                  childCount++;
                }
              });
            }

            // Calculations after deep traversing ALL children
            height += sumHeight;
            depth += maxChildDepth;
            var itemsAfter = flat.length;
            var _height = itemsAfter - itemsBefore;
            var bottom = insideCollapsed ? null : top + height;
            Object.assign(items[id], {
              depth: children ? depth : undefined,
              _height: _height,
              height: height,
              bottom: bottom
            });
          }

          // Start recursion
          _flatizeTree(tree, [], false, false, false, 0, null, null);

          // Calc after recursion
          for (var i = 0; i < flat.length; i++) {
            var prevId = i > 0 ? flat[i - 1] : null;
            var nextId = i < flat.length - 1 ? flat[i + 1] : null;
            var item = items[flat[i]];
            item.prev = prevId;
            item.next = nextId;
          }
          return {
            flat: flat,
            items: items,
            cases: cases
          };
        };

        /**
         * Returns count of reorderable(!) nodes
         * @param {Immutable.Map} tree
         * @return {Integer}
         */
        var getTotalReordableNodesCountInTree$2 = function getTotalReordableNodesCountInTree(tree) {
          if (!tree) return -1;
          var cnt = 0;
          function _processNode(item, path, lev) {
            var id, children, type;
            if (typeof item.get === "function") {
              id = item.get("id");
              children = item.get("children1");
              type = item.get("type");
            } else {
              id = item.id;
              children = item.children1;
              type = item.type;
            }
            var isRuleGroup = type == "rule_group";
            cnt++;
            //tip: rules in rule-group can be reordered only inside
            if (children && !isRuleGroup) {
              children.map(function (child, _childId) {
                if (child) {
                  _processNode(child, path.concat(id));
                }
              });
            }
          }
          _processNode(tree, []);
          return cnt - 1; // -1 for root
        };

        /**
         * Returns count of atomic rules (i.e. don't count groups; count rule_group as 1 atomic rule)
         * @param {Immutable.Map} tree
         * @return {Integer}
         */
        var getTotalRulesCountInTree$2 = function getTotalRulesCountInTree(tree) {
          if (!tree) return -1;
          var cnt = 0;
          function _processNode(item, path, lev) {
            var id, children, type;
            if (typeof item.get === "function") {
              id = item.get("id");
              children = item.get("children1");
              type = item.get("type");
            } else {
              id = item.id;
              children = item.children1;
              type = item.type;
            }
            if (type == "rule" || type == "rule_group") {
              // tip: count rule_group as 1 rule
              cnt++;
            } else if (children) {
              children.map(function (child, _childId) {
                if (child) {
                  _processNode(child, path.concat(id));
                }
              });
            }
          }
          _processNode(tree, []);
          return cnt;
        };

        // Remove fields that can be calced: "id", "path"
        // Remove empty fields: "operatorOptions"
        var getLightTree = function getLightTree(tree) {
          var deleteExcess = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var children1AsArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          var newTree = tree;
          function _processNode(item, itemId) {
            if (deleteExcess && item.path) {
              delete item.path;
            }
            if (deleteExcess && !children1AsArray && itemId) {
              delete item.id;
            }
            var properties = item.properties;
            if (properties) {
              if (properties.operatorOptions == null) {
                delete properties.operatorOptions;
              }
            }
            var children = item.children1;
            if (children) {
              for (var id in children) {
                if (children[id]) {
                  _processNode(children[id], id);
                }
              }
              if (children1AsArray) {
                item.children1 = Object.values(children);
              }
            }
          }
          _processNode(tree, null);
          return newTree;
        };
        var getSwitchValues = function getSwitchValues(tree) {
          var vals = [];
          var children = tree.get("children1");
          if (children) {
            children.map(function (child) {
              var value = child.getIn(["properties", "value"]);
              var caseValue;
              if (value && value.size == 1) {
                caseValue = value.get(0);
                if (Array.isArray(caseValue) && caseValue.length == 0) {
                  caseValue = null;
                }
              } else {
                caseValue = null;
              }
              vals = [].concat(_toConsumableArray(vals), [caseValue]);
            });
          }
          return vals;
        };
        var isEmptyTree = function isEmptyTree(tree) {
          return !tree.get("children1") || tree.get("children1").size == 0;
        };
        var hasChildren = function hasChildren(tree, path) {
          return tree.getIn(expandTreePath(path, "children1")).size > 0;
        };
        var _fixImmutableValue$1 = function _fixImmutableValue(v) {
          if (v !== null && v !== void 0 && v.toJS) {
            var _v$toJS;
            var vJs = v === null || v === void 0 || (_v$toJS = v.toJS) === null || _v$toJS === void 0 ? void 0 : _v$toJS.call(v);
            if (vJs !== null && vJs !== void 0 && vJs.func) {
              // `v` is a func, keep Immutable
              return v.toOrderedMap();
            } else {
              // for values of multiselect use Array instead of List
              return vJs;
            }
          } else {
            return v;
          }
        };
        const treeUtils = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          _fixImmutableValue: _fixImmutableValue$1,
          expandTreePath,
          expandTreeSubpath,
          fixEmptyGroupsInTree,
          fixPathsInTree,
          getFlatTree: getFlatTree$1,
          getItemByPath,
          getLightTree,
          getSwitchValues,
          getTotalReordableNodesCountInTree: getTotalReordableNodesCountInTree$2,
          getTotalRulesCountInTree: getTotalRulesCountInTree$2,
          hasChildren,
          immutableToJs: applyToJS,
          isEmptyTree,
          isImmutable: isImmutable$1,
          jsToImmutable,
          removeIsLockedInTree,
          toImmutableList
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        var getTree = function getTree(immutableTree) {
          var light = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var children1AsArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          if (!immutableTree) return undefined;
          var tree = immutableTree;
          tree = tree.toJS();
          tree = getLightTree(tree, light, children1AsArray);
          return tree;
        };
        var loadTree = function loadTree(serTree) {
          if (isImmutableTree(serTree)) {
            return serTree;
          } else if (isTree(serTree)) {
            return fixPathsInTree(jsToImmutable(serTree));
          } else if (typeof serTree == "string" && serTree.startsWith('["~#iM"')) {
            //tip: old versions of RAQB were saving tree with `transit.toJSON()`
            // https://github.com/ukrbublik/react-awesome-query-builder/issues/69
            throw new Error("You are trying to load query in obsolete serialization format (Immutable string) which is not supported in versions starting from 2.1.17");
          } else if (typeof serTree === "string") {
            return fixPathsInTree(jsToImmutable(JSON.parse(serTree)));
          } else throw new Error("Can't load tree!");
        };
        var isImmutableTree = function isImmutableTree(tree) {
          return Map$2.isMap(tree);
        };
        var isTree = function isTree(tree) {
          return _typeof$3(tree) == "object" && (tree.type == "group" || tree.type == "switch_group");
        };
        function jsToImmutable(tree) {
          var imm = fromJS(tree, function (key, value, path) {
            var isFuncArg = path && path.length > 3 && path[path.length - 1] === "value" && path[path.length - 3] === "args";
            var isRuleValue = path && path.length > 3 && path[path.length - 1] === "value" && path[path.length - 2] === "properties";
            var outValue;
            if (key == "properties") {
              outValue = value.toOrderedMap();

              // `value` should be undefined instead of null
              // JSON doesn't support undefined and replaces undefined -> null
              // So fix: null -> undefined
              for (var i = 0; i < 2; i++) {
                var _outValue$get, _outValue$get$get, _outValue$get2;
                if (((_outValue$get = outValue.get("value")) === null || _outValue$get === void 0 || (_outValue$get$get = (_outValue$get2 = _outValue$get).get) === null || _outValue$get$get === void 0 ? void 0 : _outValue$get$get.call(_outValue$get2, i)) === null) {
                  outValue = outValue.setIn(["value", i], undefined);
                }
              }
            } else if (isFuncArg) {
              outValue = _fixImmutableValue$1(value);
            } else if ((path ? isRuleValue : key == "value") && Immutable.Iterable.isIndexed(value)) {
              outValue = value.map(_fixImmutableValue$1).toList();
            } else if (key == "asyncListValues") {
              // keep in JS format
              outValue = value.toJS();
            } else if (key == "children1" && Immutable.Iterable.isIndexed(value)) {
              outValue = new Immutable.OrderedMap(value.map(function (child) {
                return [(child === null || child === void 0 ? void 0 : child.get("id")) || uuid(), child];
              }));
            } else {
              outValue = Immutable.Iterable.isIndexed(value) ? value.toList() : value.toOrderedMap();
            }
            return outValue;
          });
          return imm;
        }
        function ownKeys$B(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$B(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$B(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$B(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _createForOfIteratorHelper$d(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$d(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e2) {
                  throw _e2;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e3) {
              didErr = true;
              err = _e3;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$d(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$d(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$d(o, minLen);
        }
        function _arrayLikeToArray$d(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }

        // http://jsonlogic.com/

        // helpers
        var arrayUniq = function arrayUniq(arr) {
          return Array.from(new Set(arr));
        };

        // constants
        var jlFieldMarker = "jlField";
        var jlArgsMarker = "jlArgs";
        var jlEqOps = ["==", "!="];
        var jlRangeOps = ["<", "<=", ">", ">="];
        var multiselectOps = ["multiselect_equals", "multiselect_not_equals", "multiselect_contains", "multiselect_not_contains"];
        var createMeta = function createMeta(parentMeta) {
          return {
            errors: [],
            settings: parentMeta === null || parentMeta === void 0 ? void 0 : parentMeta.settings
          };
        };
        var loadFromJsonLogic = function loadFromJsonLogic(logicTree, config) {
          return _loadFromJsonLogic(logicTree, config, false);
        };
        var _loadFromJsonLogic = function _loadFromJsonLogic(logicTree, config) {
          var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          //meta is mutable
          var meta = createMeta();
          meta.settings = {
            allowUnknownFields: false,
            returnErrors: returnErrors
          };
          var extendedConfig = extendConfig(config, undefined, false);
          var conv = buildConv$1(extendedConfig);
          var jsTree = logicTree ? convertFromLogic(logicTree, conv, extendedConfig, ["rule", "group", "switch"], meta) : undefined;
          var immTree = jsTree ? loadTree(jsTree) : undefined;
          if (returnErrors) {
            return [immTree, meta.errors];
          } else {
            if (meta.errors.length) console.warn("Errors while importing from JsonLogic:", meta.errors);
            return immTree;
          }
        };
        var buildConv$1 = function buildConv(config) {
          var operators = {};
          var combinationOperators = {};
          for (var opKey in config.operators) {
            var opConfig = config.operators[opKey];
            if (typeof opConfig.jsonLogic == "string") {
              // example: "</2", "#in/1"
              var opk = opConfig.jsonLogic + "/" + getOpCardinality$1(opConfig);
              if (!operators[opk]) operators[opk] = [];
              operators[opk].push(opKey);
            } else if (typeof opConfig.jsonLogic2 == "string") {
              // example: all-in/1"
              var _opk = opConfig.jsonLogic2 + "/" + getOpCardinality$1(opConfig);
              if (!operators[_opk]) operators[_opk] = [];
              operators[_opk].push(opKey);
              if (!combinationOperators[opKey]) combinationOperators[opKey] = {};
              combinationOperators[opKey] = {
                "template": opConfig.jsonLogic(jlFieldMarker, opKey, jlArgsMarker),
                "jsonLogic2": opConfig.jsonLogic2,
                "_jsonLogicIsExclamationOp": !!opConfig._jsonLogicIsExclamationOp
              };
            }
          }
          var conjunctions = {};
          for (var conjKey in config.conjunctions) {
            var conjunctionDefinition = config.conjunctions[conjKey];
            var ck = conjunctionDefinition.jsonLogicConj || conjKey.toLowerCase();
            conjunctions[ck] = conjKey;
          }
          var funcs = {};
          var _iterator = _createForOfIteratorHelper$d(iterateFuncs(config)),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _slicedToArray$1(_step.value, 2),
                funcPath = _step$value[0],
                funcConfig = _step$value[1];
              var fk = void 0;
              if (funcConfig.jsonLogicIsMethod) {
                fk = "#" + funcConfig.jsonLogic;
              } else if (typeof funcConfig.jsonLogic == "string") {
                fk = funcConfig.jsonLogic;
              }
              if (fk) {
                if (!funcs[fk]) funcs[fk] = [];
                funcs[fk].push(funcPath);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          var _config$settings$json = config.settings.jsonLogic,
            groupVarKey = _config$settings$json.groupVarKey,
            altVarKey = _config$settings$json.altVarKey;
          return {
            operators: operators,
            conjunctions: conjunctions,
            funcs: funcs,
            varKeys: ["var", groupVarKey, altVarKey],
            combinationOperators: combinationOperators
          };
        };

        /**
         * This function checks a given jsonlogic object against a set of templates defined in 'conv'. 
         * It determines if the jsonlogic object matches any of the specified templates.
         * 
         * @param {*} jsonlogic The jsonlogic object to be matched against the templates.
         * @param {*} conv The object containing all potential templates and their associated logic for matching. 
         * It is expected to have a 'combinationOperators' property that houses the templates.
         * @param {*} meta An object where any errors or metadata during the processing are stored. It's modified by reference.
         * @param {*} operatorsToCheck An optional array of operator keys that limits which operators in 'conv' are checked. 
         * If null, all operators in 'conv' are considered.
         * @returns {Object|null} The response object containing the match result, and any relevant matched fields and 
         * arguments if a match is found. Returns null if no match is found.
         */
        var matchAgainstTemplates = function matchAgainstTemplates(jsonlogic, conv, meta) {
          var operatorsToCheck = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var response;
          if (conv !== null && conv !== void 0 && conv.combinationOperators) {
            for (var _i = 0, _Object$entries = Object.entries(conv.combinationOperators); _i < _Object$entries.length; _i++) {
              var _Object$entries$_i = _slicedToArray$1(_Object$entries[_i], 2),
                key = _Object$entries$_i[0],
                value = _Object$entries$_i[1];
              if (operatorsToCheck == null || operatorsToCheck.includes(key)) {
                var tempResponse = isTemplateMatch(value.template, jsonlogic);
                // Found a match
                if (tempResponse.match) {
                  if (!response) response = tempResponse;
                  // Templates should be spesific enough that only one match can be found. This should not happen
                  else meta.errors.push("Operator matched against 2 templates: ".concat(response.newOp, " and ").concat(key));
                  // New op that is used to represent operator that is combosed of multiple operators
                  response["newOp"] = value.jsonLogic2;
                }
              }
            }
          }
          // Returns undefined if no matches found
          return response;
        };

        /**
         * This function recursively compares a jsonlogic object against a template to determine if they match structurally and content-wise.
         * It is used to support complex template matching where the template can include special markers indicating variable fields and arguments.
         *
         * @param {*} template The template object to match against, which can include special markers to denote fields and arguments.
         * @param {*} jsonlogic The jsonlogic object to test against the template.
         * @param {*} response An object to accumulate results such as whether a match is found, and to collect any fields or arguments identified 
         * by the template markers. Default is initialized to a match state with empty fields and arguments.
         * @returns {Object} The updated response object after checking the current template level. It includes whether the current level 
         * matches (match: true/false), any identified fields (jlField), and any arguments (jlArgs).
         */
        var isTemplateMatch = function isTemplateMatch(template, jsonlogic) {
          var response = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
            "match": true,
            "jlField": null,
            "jlArgs": []
          };
          if (template == undefined || jsonlogic == undefined) {
            response.match = false;
            return response;
          }
          // This lets us compare order easily
          var tKeys = Object.keys(template);
          var jKeys = Object.keys(jsonlogic);
          if (tKeys.length !== jKeys.length) {
            // Both have same length
            response.match = false;
            return response;
          }
          for (var index = 0; index < tKeys.length; index++) {
            var key = tKeys[index];
            var value = template[key];
            if (key !== jKeys[index]) {
              // Checks that both have exact same key at exact same place. Kind of pointless for arrays but whatever
              response.match = false;
              return response;
            } else if (value === jlFieldMarker && isJsonLogic(jsonlogic[key])) {
              // If jlFieldMarker is found in template AND it's field or func we take the value from corresponding place in jsonlogic
              response.jlField = jsonlogic[key];
            } else if (value === jlArgsMarker) {
              // If jlArgsMarker is found in template we take the value from corresponding place in jsonlogic
              response.jlArgs.push(jsonlogic[key]);
            } else if (_typeof$3(value) === "object" && value !== null || Array.isArray(value)) {
              // Here we recurse thru objects and arrays of template until we have gone thru it completely
              response = isTemplateMatch(value, jsonlogic[key], response);
            } else if (value !== jsonlogic[key]) {
              // This is for cases of {var: ""}, which should be only case in default config that leads here
              response.match = false;
              return response;
            }
          }
          return response;
        };

        // expectedTypes - "val", "rule", "group", "switch", "case_val"
        var convertFromLogic = function convertFromLogic(logic, conv, config, expectedTypes, meta) {
          var not = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
          var fieldConfig = arguments.length > 6 ? arguments[6] : undefined;
          var widget = arguments.length > 7 ? arguments[7] : undefined;
          var parentField = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
          var op, vals;
          if (isJsonLogic(logic)) {
            op = Object.keys(logic)[0];
            vals = logic[op];
            if (!Array.isArray(vals)) vals = [vals];
          }
          var ret;
          var beforeErrorsCnt = meta.errors.length;
          var lockedOp = config.settings.jsonLogic.lockedOp;
          var isEmptyOp = op == "!" && vals.length == 1 && vals[0] && isJsonLogic(vals[0]) && conv.varKeys.includes(Object.keys(vals[0])[0]);
          // If matchAgainstTemplates returns match then op is replaced with special jsonlogic2 value
          var match = matchAgainstTemplates(logic, conv, meta);
          if (match) {
            // We reset vals if match found
            vals = [];
            vals[0] = match.jlField;
            match.jlArgs.forEach(function (arg) {
              return vals.push(arg);
            });
            // We reset op to new op that represents multiple jsonlogic operators
            op = match.newOp;
          }
          var isNot = op == "!" && !isEmptyOp;
          var isLocked = lockedOp && op == lockedOp;
          var isSwitch = expectedTypes.includes("switch");
          var isRoot = isSwitch;
          if (isLocked) {
            ret = convertFromLogic(vals[0], conv, config, expectedTypes, meta, not, fieldConfig, widget, parentField, true);
          } else if (isNot) {
            // apply not
            ret = convertFromLogic(vals[0], conv, config, expectedTypes, meta, !not, fieldConfig, widget, parentField);
          } else if (expectedTypes.includes("val")) {
            // not is not used here
            ret = convertFieldRhs(op, vals, conv, config, not, meta, parentField) || convertFuncRhs(op, vals, conv, config, not, fieldConfig, meta, parentField) || convertValRhs(logic, fieldConfig, widget, config, meta);
          } else {
            if (expectedTypes.includes("switch")) {
              ret = convertIf(op, vals, conv, config, not, meta, parentField);
            }
            if (ret == undefined && expectedTypes.includes("group")) {
              ret = convertConj(op, vals, conv, config, not, meta, parentField, false);
            }
            if (ret == undefined && expectedTypes.includes("rule")) {
              ret = convertOp$1(op, vals, conv, config, not, meta, parentField);
            }
            if (ret) {
              if (isRoot && !["group", "switch_group"].includes(ret.type)) {
                ret = wrapInDefaultConj$1(ret, config);
              }
            }
          }
          var afterErrorsCnt = meta.errors.length;
          if (op != "!" && ret === undefined && afterErrorsCnt == beforeErrorsCnt) {
            meta.errors.push("Can't parse logic ".concat(JSON.stringify(logic)));
          }
          if (isLocked) {
            ret.properties.isLocked = true;
          }
          return ret;
        };
        var convertValRhs = function convertValRhs(val, fieldConfig, widget, config, meta) {
          var _fieldConfig$fieldSet;
          if (val === undefined) val = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.defaultValue;
          if (val === undefined) return undefined;
          widget = widget || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mainWidget);
          var widgetConfig = config.widgets[widget];
          var fieldType = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type;
          if (fieldType && !widgetConfig) {
            meta.errors.push("No widget for type ".concat(fieldType));
            return undefined;
          }
          if (isJsonLogic(val)) {
            meta.errors.push("Unexpected logic in value: ".concat(JSON.stringify(val)));
            return undefined;
          }

          // number of seconds -> time string
          if (fieldType === "time" && typeof val === "number") {
            var h = Math.floor(val / 60 / 60) % 24,
              m = Math.floor(val / 60) % 60,
              s = val % 60;
            var valueFormat = widgetConfig.valueFormat;
            if (valueFormat) {
              var dateVal = new Date(val);
              dateVal.setMilliseconds(0);
              dateVal.setHours(h);
              dateVal.setMinutes(m);
              dateVal.setSeconds(s);
              val = hooks(dateVal).format(valueFormat);
            } else {
              val = "".concat(h, ":").concat(m, ":").concat(s);
            }
          }

          // "2020-01-08T22:00:00.000Z" -> Date object
          if (["date", "datetime"].includes(fieldType) && val && !(val instanceof Date)) {
            try {
              var _dateVal = new Date(val);
              if (_dateVal instanceof Date && _dateVal.toISOString() === val) {
                val = _dateVal;
              }
            } catch (e) {
              meta.errors.push("Can't convert value ".concat(val, " as Date"));
              val = undefined;
            }
          }

          // Date object -> formatted string
          if (val instanceof Date && fieldConfig) {
            var _valueFormat = widgetConfig.valueFormat;
            if (_valueFormat) {
              val = hooks(val).format(_valueFormat);
            }
          }
          var asyncListValues;
          if (val && fieldConfig !== null && fieldConfig !== void 0 && (_fieldConfig$fieldSet = fieldConfig.fieldSettings) !== null && _fieldConfig$fieldSet !== void 0 && _fieldConfig$fieldSet.asyncFetch) {
            var vals = Array.isArray(val) ? val : [val];
            asyncListValues = vals;
          }
          if (widgetConfig !== null && widgetConfig !== void 0 && widgetConfig.jsonLogicImport) {
            try {
              val = widgetConfig.jsonLogicImport.call(config.ctx, val);
            } catch (e) {
              var _e$message;
              meta.errors.push("Can't import value ".concat(val, " using import func of widget ").concat(widget, ": ").concat((_e$message = e === null || e === void 0 ? void 0 : e.message) !== null && _e$message !== void 0 ? _e$message : e));
              val = undefined;
            }
          }
          return {
            valueSrc: "value",
            value: val,
            valueType: widgetConfig === null || widgetConfig === void 0 ? void 0 : widgetConfig.type,
            asyncListValues: asyncListValues
          };
        };
        var convertFieldRhs = function convertFieldRhs(op, vals, conv, config, not, meta) {
          var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          if (conv.varKeys.includes(op) && typeof vals[0] == "string") {
            var _meta$settings;
            var field = normalizeField(config, vals[0], parentField);
            var fieldConfig = getFieldConfig$8(config, field);
            if (!fieldConfig && !((_meta$settings = meta.settings) !== null && _meta$settings !== void 0 && _meta$settings.allowUnknownFields)) {
              meta.errors.push("No config for field ".concat(field));
              return undefined;
            }
            return {
              valueSrc: "field",
              value: field,
              valueType: fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type
            };
          }
          return undefined;
        };
        var convertLhs = function convertLhs(isGroup0, jlField, args, conv, config) {
          var not = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          var fieldConfig = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          var meta = arguments.length > 7 ? arguments[7] : undefined;
          var parentField = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
          var k = Object.keys(jlField)[0];
          var v = Object.values(jlField)[0];
          var _parse = function _parse(k, v) {
            return convertFieldLhs(k, v, conv, config, not, meta, parentField) || convertFuncLhs(k, v, conv, config, not, fieldConfig, meta, parentField);
          };
          var beforeErrorsCnt = meta.errors.length;
          var field, fieldSrc, having, isGroup;
          var parsed = _parse(k, v);
          if (parsed) {
            field = parsed.field;
            fieldSrc = parsed.fieldSrc;
          }
          if (isGroup0) {
            isGroup = true;
            having = args[0];
            args = [];
          }
          // reduce/filter for group ext
          if (k == "reduce" && Array.isArray(v) && v.length == 3) {
            var _v = v,
              _v2 = _slicedToArray$1(_v, 3),
              filter = _v2[0],
              acc = _v2[1],
              init = _v2[2];
            if (isJsonLogic(filter) && init == 0 && isJsonLogic(acc) && Array.isArray(acc["+"]) && acc["+"][0] == 1 && isJsonLogic(acc["+"][1]) && acc["+"][1]["var"] == "accumulator") {
              k = Object.keys(filter)[0];
              v = Object.values(filter)[0];
              if (k == "filter") {
                var _v3 = v,
                  _v4 = _slicedToArray$1(_v3, 2),
                  group = _v4[0],
                  _filter = _v4[1];
                if (isJsonLogic(group)) {
                  k = Object.keys(group)[0];
                  v = Object.values(group)[0];
                  var parsedGroup = _parse(k, v);
                  if (parsedGroup) {
                    field = parsedGroup.field;
                    fieldSrc = parsedGroup.fieldSrc;
                    having = _filter;
                    isGroup = true;
                  }
                }
              } else {
                var _parsedGroup = _parse(k, v);
                if (_parsedGroup) {
                  field = _parsedGroup.field;
                  fieldSrc = _parsedGroup.fieldSrc;
                  isGroup = true;
                }
              }
            }
          }
          var afterErrorsCnt = meta.errors.length;
          if (!field && afterErrorsCnt == beforeErrorsCnt) {
            meta.errors.push("Unknown LHS ".concat(JSON.stringify(jlField)));
          }
          if (!field) return;
          return {
            field: field,
            fieldSrc: fieldSrc,
            having: having,
            isGroup: isGroup,
            args: args
          };
        };
        var convertFieldLhs = function convertFieldLhs(op, vals, conv, config, not, meta) {
          var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          if (!Array.isArray(vals)) vals = [vals];
          var parsed = convertFieldRhs(op, vals, conv, config, not, meta, parentField);
          if (parsed) {
            return {
              fieldSrc: "field",
              field: parsed.value
            };
          }
          return undefined;
        };
        var convertFuncLhs = function convertFuncLhs(op, vals, conv, config, not) {
          var fieldConfig = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          var meta = arguments.length > 6 ? arguments[6] : undefined;
          var parentField = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
          var parsed = convertFuncRhs(op, vals, conv, config, not, fieldConfig, meta, parentField);
          if (parsed) {
            return {
              fieldSrc: "func",
              field: parsed.value
            };
          }
          return undefined;
        };
        var convertFuncRhs = function convertFuncRhs(op, vals, conv, config, not) {
          var fieldConfig = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          var meta = arguments.length > 6 ? arguments[6] : undefined;
          var parentField = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
          if (!op) return undefined;
          var func, argsArr, funcKey;
          var jsonLogicIsMethod = op == "method";
          if (jsonLogicIsMethod) {
            var obj, opts;
            var _vals = _toArray(vals);
            obj = _vals[0];
            func = _vals[1];
            opts = _vals.slice(2);
            argsArr = [obj].concat(_toConsumableArray(opts));
          } else {
            func = op;
            argsArr = vals;
          }
          var fk = (jsonLogicIsMethod ? "#" : "") + func;
          var returnType = (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.returnType);
          var funcKeys = (conv.funcs[fk] || []).filter(function (k) {
            return fieldConfig ? getFuncConfig$2(config, k).returnType == returnType : true;
          });
          if (funcKeys.length) {
            funcKey = funcKeys[0];
          } else {
            var v = _defineProperty$4({}, op, vals);
            var _iterator2 = _createForOfIteratorHelper$d(iterateFuncs(config)),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var _step2$value = _slicedToArray$1(_step2.value, 2),
                  f = _step2$value[0],
                  fc = _step2$value[1];
                if (fc.jsonLogicImport && (returnType ? fc.returnType == returnType : true)) {
                  var parsed = void 0;
                  try {
                    parsed = fc.jsonLogicImport(v);
                  } catch (_e) {
                    // given expression `v` can't be parsed into function
                  }
                  if (parsed) {
                    funcKey = f;
                    argsArr = parsed;
                  }
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
          if (!funcKey) return undefined;
          if (funcKey) {
            var funcConfig = getFuncConfig$2(config, funcKey);
            var argKeys = Object.keys(funcConfig.args || {});
            var argsObj = argsArr.reduce(function (acc, val, ind) {
              var argKey = argKeys[ind];
              var argConfig = funcConfig.args[argKey];
              var argVal;
              if (argConfig) {
                argVal = convertFromLogic(val, conv, config, ["val"], meta, false, argConfig, null, parentField);
              }
              return argVal !== undefined ? _objectSpread$B(_objectSpread$B({}, acc), {}, _defineProperty$4({}, argKey, argVal)) : acc;
            }, {});
            for (var argKey in funcConfig.args) {
              var argConfig = funcConfig.args[argKey];
              var argVal = argsObj[argKey];
              if (argVal === undefined) {
                argVal = argConfig === null || argConfig === void 0 ? void 0 : argConfig.defaultValue;
                if (argVal !== undefined) {
                  var _argVal;
                  argVal = {
                    value: argVal,
                    valueSrc: (_argVal = argVal) !== null && _argVal !== void 0 && _argVal.func ? "func" : "value",
                    valueType: argConfig.type
                  };
                }
                if (argVal === undefined) {
                  if (argConfig !== null && argConfig !== void 0 && argConfig.isOptional) ;else {
                    meta.errors.push("No value for arg ".concat(argKey, " of func ").concat(funcKey));
                    return undefined;
                  }
                } else {
                  argsObj[argKey] = argVal;
                }
              }
            }
            return {
              valueSrc: "func",
              value: {
                func: funcKey,
                args: argsObj
              },
              valueType: funcConfig.returnType
            };
          }
          return undefined;
        };
        var convertConj = function convertConj(op, vals, conv, config, not, meta) {
          var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          var conjKey = conv.conjunctions[op];
          var fieldSeparator = config.settings.fieldSeparator;
          // const parentFieldConfig = parentField ? getFieldConfig(config, parentField) : null;
          // const isParentGroup = parentFieldConfig?.type == "!group";
          if (conjKey) {
            var type = "group";
            var children = vals.map(function (v) {
              return convertFromLogic(v, conv, config, ["rule", "group"], meta, false, null, null, parentField);
            }).filter(function (r) {
              return r !== undefined;
            }).reduce(function (acc, r) {
              return _objectSpread$B(_objectSpread$B({}, acc), {}, _defineProperty$4({}, r.id, r));
            }, {});
            var complexFields = Object.values(children).map(function (v) {
              var _v$properties, _v$properties2;
              return (v === null || v === void 0 || (_v$properties = v.properties) === null || _v$properties === void 0 ? void 0 : _v$properties.fieldSrc) == "field" && (v === null || v === void 0 || (_v$properties2 = v.properties) === null || _v$properties2 === void 0 ? void 0 : _v$properties2.field);
            }).filter(function (f) {
              var _f$includes;
              return f === null || f === void 0 || (_f$includes = f.includes) === null || _f$includes === void 0 ? void 0 : _f$includes.call(f, fieldSeparator);
            });
            var complexFieldsGroupAncestors = Object.fromEntries(arrayUniq(complexFields).map(function (f) {
              var parts = f.split(fieldSeparator);
              var ancs = Object.fromEntries(parts.slice(0, -1).map(function (f, i, parts) {
                return [].concat(_toConsumableArray(parts.slice(0, i)), [f]);
              }).map(function (fp) {
                return [fp.join(fieldSeparator), getFieldConfig$8(config, fp)];
              }).filter(function (_ref) {
                var _ref2 = _slicedToArray$1(_ref, 2);
                _ref2[0];
                var fc = _ref2[1];
                return (fc === null || fc === void 0 ? void 0 : fc.type) == "!group";
              }));
              return [f, Object.keys(ancs)];
            }));
            // const childrenInRuleGroup = Object.values(children)
            //   .map(v => v?.properties?.fieldSrc == "field" && v?.properties?.field)
            //   .map(f => complexFieldsGroupAncestors[f])
            //   .filter(ancs => ancs && ancs.length);
            // const usedRuleGroups = arrayUniq(Object.values(complexFieldsGroupAncestors).flat());
            // const usedTopRuleGroups = topLevelFieldsFilter(usedRuleGroups);

            var properties = {
              conjunction: conjKey,
              not: not
            };
            var id = uuid();
            var children1 = {};
            var groupToId = {};
            Object.entries(children).map(function (_ref3) {
              var _ref4 = _slicedToArray$1(_ref3, 2),
                k = _ref4[0],
                v = _ref4[1];
              if ((v === null || v === void 0 ? void 0 : v.type) == "group" || (v === null || v === void 0 ? void 0 : v.type) == "rule_group") {
                // put as-is
                children1[k] = v;
              } else {
                var _v$properties3;
                var field = v === null || v === void 0 || (_v$properties3 = v.properties) === null || _v$properties3 === void 0 ? void 0 : _v$properties3.field;
                var groupAncestors = complexFieldsGroupAncestors[field] || [];
                var groupField = groupAncestors[groupAncestors.length - 1];
                if (!groupField) {
                  // not in rule_group (can be simple field or in struct) - put as-is
                  if (v) {
                    children1[k] = v;
                  }
                } else {
                  // wrap field in rule_group (with creating hierarchy if need)
                  var ch = children1;
                  var parentFieldParts = getFieldParts$3(parentField, config);
                  var groupPath = getFieldParts$3(groupField, config);
                  var isInParent = shallowEqual$4(parentFieldParts, groupPath.slice(0, parentFieldParts.length));
                  if (!isInParent) parentFieldParts = []; // should not be
                  var traverseGroupFields = groupField.split(fieldSeparator).slice(parentFieldParts.length).map(function (f, i, parts) {
                    return [].concat(_toConsumableArray(parentFieldParts), _toConsumableArray(parts.slice(0, i)), [f]).join(fieldSeparator);
                  }).map(function (f) {
                    return {
                      f: f,
                      fc: getFieldConfig$8(config, f) || {}
                    };
                  }).filter(function (_ref5) {
                    var fc = _ref5.fc;
                    return fc.type != "!struct";
                  });
                  traverseGroupFields.map(function (_ref6, i) {
                    var gf = _ref6.f,
                      gfc = _ref6.fc;
                    var groupId = groupToId[gf];
                    if (!groupId) {
                      groupId = uuid();
                      groupToId[gf] = groupId;
                      ch[groupId] = {
                        type: "rule_group",
                        id: groupId,
                        children1: {},
                        properties: {
                          conjunction: conjKey,
                          not: false,
                          field: gf,
                          fieldSrc: "field",
                          mode: gfc.mode
                        }
                      };
                    }
                    ch = ch[groupId].children1;
                  });
                  ch[k] = v;
                }
              }
            });

            // tip: for isRuleGroup=true correct type and properties will be set out of this func

            return {
              type: type,
              id: id,
              children1: children1,
              properties: properties
            };
          }
          return undefined;
        };

        // const topLevelFieldsFilter = (fields) => {
        //   let arr = [...fields].sort((a, b) => (a.length - b.length));
        //   for (let i = 0 ; i < arr.length ; i++) {
        //     for (let j = i + 1 ; j < arr.length ; j++) {
        //       if (arr[j].indexOf(arr[i]) == 0) {
        //         // arr[j] is inside arr[i] (eg. "a.b" inside "a")
        //         arr.splice(j, 1);
        //         j--;
        //       }
        //     }
        //   }
        //   return arr;
        // };

        var wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup(rule, parentField, parentFieldConfig, config) {
          var conj = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
          var not = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
          if (!rule) return undefined;
          return {
            type: "rule_group",
            id: uuid(),
            children1: _defineProperty$4({}, rule.id, rule),
            properties: {
              conjunction: conj || defaultGroupConjunction$1(config, parentFieldConfig),
              not: not,
              field: parentField
            }
          };
        };
        var wrapInDefaultConj$1 = function wrapInDefaultConj(rule, config) {
          var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          return {
            type: "group",
            id: uuid(),
            children1: _defineProperty$4({}, rule.id, rule),
            properties: {
              conjunction: defaultConjunction(config),
              not: not
            }
          };
        };
        var parseRule = function parseRule(op, arity, vals, parentField, conv, config, meta) {
          var submeta = createMeta(meta);
          var res = _parseRule(op, arity, vals, parentField, conv, config, submeta);
          if (!res) {
            meta.errors.push(submeta.errors.join("; ") || "Unknown op ".concat(op, "/").concat(arity));
            return undefined;
          }
          return res;
        };
        var _parseRule = function _parseRule(op, arity, vals, parentField, conv, config, meta) {
          var _meta$settings2;
          // config.settings.groupOperators are used for group count (cardinality = 0 is exception)
          // but don't confuse with "all-in" or "some-in" for multiselect
          var isAllOrSomeInForMultiselect = multiselectOps.map(function (opName) {
            var _config$operators$opN;
            return (_config$operators$opN = config.operators[opName]) === null || _config$operators$opN === void 0 ? void 0 : _config$operators$opN.jsonLogic2;
          }).includes(op);
          var isGroup0 = config.settings.groupOperators.includes(op) && !isAllOrSomeInForMultiselect;
          var cardinality = isGroup0 ? 0 : arity - 1;
          if (isGroup0) cardinality = 0;else if (jlEqOps.includes(op) && cardinality == 1 && vals[1] === null) {
            arity = 1;
            cardinality = 0;
            vals = [vals[0]];
          }
          var opk = op + "/" + cardinality;
          var opKeys = conv.operators[opk];
          if (!opKeys) return;
          var jlField,
            jlArgs = [];
          if (jlRangeOps.includes(op) && arity == 3) {
            jlField = vals[1];
            jlArgs = [vals[0], vals[2]];
          } else {
            var _vals2 = vals;
            var _vals3 = _toArray(_vals2);
            jlField = _vals3[0];
            jlArgs = _vals3.slice(1);
          }
          if (!isJsonLogic(jlField)) {
            meta.errors.push("Incorrect operands for ".concat(op, ": ").concat(JSON.stringify(vals)));
            return;
          }
          var lhs = convertLhs(isGroup0, jlField, jlArgs, conv, config, null, null, meta, parentField);
          if (!lhs) return;
          var field = lhs.field,
            fieldSrc = lhs.fieldSrc,
            having = lhs.having;
          lhs.isGroup;
          var args = lhs.args;
          var fieldConfig = getFieldConfig$8(config, field);
          if (!fieldConfig && !((_meta$settings2 = meta.settings) !== null && _meta$settings2 !== void 0 && _meta$settings2.allowUnknownFields)) {
            meta.errors.push("No config for LHS ".concat(field));
            return;
          }
          var opKey = opKeys[0];
          if (opKeys.length > 1 && fieldConfig && fieldConfig.operators) {
            // eg. for "equal" and "select_equals"
            opKeys = opKeys.filter(function (k) {
              return fieldConfig.operators.includes(k);
            });
            if (opKeys.length == 0) {
              meta.errors.push("No corresponding ops for LHS ".concat(field));
              return;
            }
            opKey = opKeys[0];
          }
          return {
            field: field,
            fieldSrc: fieldSrc,
            fieldConfig: fieldConfig,
            opKey: opKey,
            args: args,
            having: having
          };
        };
        var convertOp$1 = function convertOp(op, vals, conv, config, not, meta) {
          var _opConfig;
          var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          var _isOneRuleInRuleGroup = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
          if (!op) return undefined;
          var jlConjs = Object.values(config.conjunctions).map(function (_ref7) {
            var jsonLogicConj = _ref7.jsonLogicConj;
            return jsonLogicConj;
          });
          var arity = vals.length;
          var parseRes = parseRule(op, arity, vals, parentField, conv, config, meta);
          if (!parseRes) return undefined;
          var field = parseRes.field,
            fieldSrc = parseRes.fieldSrc,
            fieldConfig = parseRes.fieldConfig,
            opKey = parseRes.opKey,
            args = parseRes.args,
            having = parseRes.having;
          var parentFieldConfig = getFieldConfig$8(config, parentField);
          var opConfig = config.operators[opKey];
          var reversedOpConfig = config.operators[(_opConfig = opConfig) === null || _opConfig === void 0 ? void 0 : _opConfig.reversedOp];
          var opNeedsReverse = false;
          var opCanReverse = !!reversedOpConfig;

          // Group component in array mode can show NOT checkbox, so do nothing in this case
          // Otherwise try to reverse
          // const showNot = fieldConfig?.showNot !== undefined ? fieldConfig.showNot : config.settings.showNot;
          var isRuleGroup = fieldConfig.type == "!group";
          // const isGroupArray = isRuleGroup && fieldConfig.mode == "array";
          var isInRuleGroup = (parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.type) == "!group";
          var canRev = opCanReverse && (!!config.settings.reverseOperatorsForNot || opNeedsReverse || isRuleGroup && !having // !(count == 2)  ->  count != 2  // because "NOT" is not visible inside rule_group if there are no children
          || !isRuleGroup && isInRuleGroup && !_isOneRuleInRuleGroup // 2+ rules in rule-group should be flat. see inits.with_not_and_in_some in test
          );
          // if (isGroupArray && showNot)
          //   canRev = false;
          var needRev = not && canRev || opNeedsReverse;
          var conj;
          var havingVals;
          var havingNot = false;
          var canRevHaving = !!config.settings.reverseOperatorsForNot;
          if ((fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) == "!group" && having) {
            conj = Object.keys(having)[0];
            havingVals = having[conj];
            if (!Array.isArray(havingVals)) havingVals = [havingVals];

            // Preprocess "!": Try to reverse op in single rule in having
            // Eg. use `not_equal` instead of `not` `equal`
            // We look for template matches here to make sure we dont reverse when "!" is
            // part of operator
            var match = matchAgainstTemplates(having, conv, meta);
            while (conj == "!" && !match) {
              var isEmptyOp = conj == "!" && havingVals.length == 1 && havingVals[0] && isJsonLogic(havingVals[0]) && conv.varKeys.includes(Object.keys(havingVals[0])[0]);
              if (isEmptyOp) {
                break;
              }
              havingNot = !havingNot;
              having = having["!"];
              conj = Object.keys(having)[0];
              havingVals = having[conj];
              // Negation group with single rule is to be treated the same as !
              if (canRevHaving && jlConjs.includes(conj) && havingVals.length == 1) {
                having = having[conj][0];
                conj = Object.keys(having)[0];
                havingVals = having[conj];
              }
              // Another template matching
              var matchTemp = matchAgainstTemplates(having, conv, meta);
              match = matchTemp ? matchTemp : match;
            }
            if (!Array.isArray(havingVals)) {
              havingVals = [havingVals];
            }
            // If template match found we act accordingly
            if (match) {
              // We reset vals if match found
              havingVals = [];
              havingVals[0] = match.jlField;
              match.jlArgs.forEach(function (arg) {
                return havingVals.push(arg);
              });
              // We reset op to new op that represents multiple jsonlogic operators
              conj = match.newOp;
            }
          }

          // Use reversed op
          if (needRev) {
            not = !not;
            opKey = opConfig.reversedOp;
            opConfig = config.operators[opKey];
          }
          var widget = getWidgetForFieldOp$3(config, field, opKey, null);
          var convertedArgs = args.map(function (v) {
            return convertFromLogic(v, conv, config, ["val"], meta, false, fieldConfig, widget, parentField);
          });
          if (convertedArgs.filter(function (v) {
            return v === undefined;
          }).length) {
            //meta.errors.push(`Undefined arg for field ${field} and op ${opKey}`);
            return undefined;
          }
          var res;
          fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type;
          if ((fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) == "!group" && having) {
            if (conv.conjunctions[conj] !== undefined) {
              // group
              res = convertConj(conj, havingVals, conv, config, havingNot, meta, field, true);
            } else {
              // rule, need to be wrapped in `rule_group`
              res = convertOp(conj, havingVals, conv, config, havingNot, meta, field, true);
              if (res) {
                var _res$properties;
                if (res.type === "rule_group" && ((_res$properties = res.properties) === null || _res$properties === void 0 ? void 0 : _res$properties.field) !== field) {
                  res = wrapInDefaultConjRuleGroup(res, field, fieldConfig, config);
                }
                Object.assign(res.properties, {
                  conjunction: defaultGroupConjunction$1(config, fieldConfig)
                });
              }
            }
            if (!res) return undefined;
            res.type = "rule_group";
            Object.assign(res.properties, {
              field: field,
              mode: fieldConfig.mode,
              operator: opKey
            });
            if (fieldConfig.mode == "array") {
              Object.assign(res.properties, {
                value: convertedArgs.map(function (v) {
                  return v.value;
                }),
                valueSrc: convertedArgs.map(function (v) {
                  return v.valueSrc;
                }),
                valueType: convertedArgs.map(function (v) {
                  return v.valueType;
                })
              });
            }
            if (not) {
              // tip: don't set not to properties, only havingNot should affect it
              res = wrapInDefaultConj$1(res, config, not);
            }
          } else if ((fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) == "!group" && !having) {
            res = {
              type: "rule_group",
              id: uuid(),
              children1: {},
              properties: {
                conjunction: defaultGroupConjunction$1(config, fieldConfig),
                // tip: `not: true` have no effect if there are no children! "NOT" is hidden in UI and is ignored during export
                // So it's better to reverse group op (see `canRev =`), or wrap in conj with NOT as a last resort
                not: false,
                mode: fieldConfig.mode,
                field: field,
                operator: opKey
              }
            };
            if (fieldConfig.mode === "array") {
              Object.assign(res.properties, {
                value: convertedArgs.map(function (v) {
                  return v.value;
                }),
                valueSrc: convertedArgs.map(function (v) {
                  return v.valueSrc;
                }),
                valueType: convertedArgs.map(function (v) {
                  return v.valueType;
                })
              });
            }
            if (not) {
              res = wrapInDefaultConj$1(res, config, not);
            }
          } else {
            var asyncListValuesArr = convertedArgs.map(function (v) {
              return v.asyncListValues;
            }).filter(function (v) {
              return v != undefined;
            });
            var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;
            res = {
              type: "rule",
              id: uuid(),
              properties: _objectSpread$B({
                field: field,
                fieldSrc: fieldSrc,
                operator: opKey,
                value: convertedArgs.map(function (v) {
                  return v.value;
                }),
                valueSrc: convertedArgs.map(function (v) {
                  return v.valueSrc;
                }),
                valueType: convertedArgs.map(function (v) {
                  return v.valueType;
                })
              }, asyncListValues ? {
                asyncListValues: asyncListValues
              } : {})
            };
            if (not || _isOneRuleInRuleGroup) {
              res = wrapInDefaultConj$1(res, config, not);
            }
          }
          return res;
        };
        var convertIf = function convertIf(op, vals, conv, config, not, meta) {
          var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          if ((op === null || op === void 0 ? void 0 : op.toLowerCase()) !== "if") return undefined;
          var flat = flatizeTernary$1(vals);
          var cases = flat.map(function (_ref8) {
            var _ref9 = _slicedToArray$1(_ref8, 2),
              cond = _ref9[0],
              val = _ref9[1];
            return [cond ? convertFromLogic(cond, conv, config, ["rule", "group"], meta, false, null, null, parentField) : null, buildCaseValProperties$1(config, meta, conv, val)];
          });
          var children1 = cases.map(function (_ref10) {
            var _ref11 = _slicedToArray$1(_ref10, 2),
              cond = _ref11[0],
              val = _ref11[1];
            return wrapInCase(cond, val, config, meta);
          });
          var switchI = {
            type: "switch_group",
            id: uuid(),
            children1: children1,
            properties: {}
          };
          return switchI;
        };
        var flatizeTernary$1 = function flatizeTernary(children) {
          var flat = [];
          function _processTernaryChildren(tern) {
            var _tern = _slicedToArray$1(tern, 3),
              cond = _tern[0],
              if_val = _tern[1],
              else_val = _tern[2];
            flat.push([cond, if_val]);
            var else_op = isJsonLogic(else_val) ? Object.keys(else_val)[0] : null;
            if ((else_op === null || else_op === void 0 ? void 0 : else_op.toLowerCase()) === "if") {
              _processTernaryChildren(else_val[else_op]);
            } else {
              flat.push([undefined, else_val]);
            }
          }
          _processTernaryChildren(children);
          return flat;
        };
        var wrapInCase = function wrapInCase(cond, valProperties, config, meta) {
          var caseI;
          if (cond) {
            caseI = _objectSpread$B({}, cond);
            if (caseI.type) {
              if (caseI.type != "group") {
                caseI = wrapInDefaultConj$1(caseI, config);
              }
              caseI.type = "case_group";
            } else {
              meta.errors.push("Unexpected case: ".concat(JSON.stringify(caseI)));
              caseI = undefined;
            }
          } else {
            caseI = {
              id: uuid(),
              type: "case_group",
              properties: {}
            };
          }
          if (caseI) {
            caseI.properties = _objectSpread$B(_objectSpread$B({}, caseI.properties), valProperties);
          }
          return caseI;
        };
        var buildCaseValProperties$1 = function buildCaseValProperties(config, meta, conv, val) {
          var caseValueFieldConfig = getFieldConfig$8(config, "!case_value");
          if (!caseValueFieldConfig) {
            meta.errors.push("Missing caseValueField in settings");
            return undefined;
          }
          var widget = caseValueFieldConfig.mainWidget;
          var widgetDef = config.widgets[widget];
          if (!widgetDef) {
            meta.errors.push("No widget ".concat(widget, " for case value"));
            return undefined;
          }
          var convVal = convertFromLogic(val, conv, config, ["val", "case_val"], meta, false, caseValueFieldConfig, widget);
          if (convVal == undefined) {
            return undefined;
          }
          var value = convVal.value,
            valueSrc = convVal.valueSrc,
            valueType = convVal.valueType;
          var valProperties = {
            value: [value],
            valueSrc: [valueSrc !== null && valueSrc !== void 0 ? valueSrc : "value"],
            valueType: [valueType !== null && valueType !== void 0 ? valueType : widgetDef === null || widgetDef === void 0 ? void 0 : widgetDef.type],
            field: "!case_value"
          };
          return valProperties;
        };
        var spel2js = {
          exports: {}
        };

        /*
         * Copyright 2002-2015 the original author or authors.
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *      http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        (function (module, exports) {
          (function webpackUniversalModuleDefinition(root, factory) {
            module.exports = factory();
          })(commonjsGlobal, function () {
            return /******/function (modules) {
              // webpackBootstrap
              /******/ // The module cache
              /******/
              var installedModules = {};
              /******/
              /******/ // The require function
              /******/
              function __webpack_require__(moduleId) {
                /******/
                /******/ // Check if module is in cache
                /******/if (installedModules[moduleId]) {
                  /******/return installedModules[moduleId].exports;
                  /******/
                }
                /******/ // Create a new module (and put it into the cache)
                /******/
                var module = installedModules[moduleId] = {
                  /******/i: moduleId,
                  /******/l: false,
                  /******/exports: {}
                  /******/
                };
                /******/
                /******/ // Execute the module function
                /******/
                modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                /******/
                /******/ // Flag the module as loaded
                /******/
                module.l = true;
                /******/
                /******/ // Return the exports of the module
                /******/
                return module.exports;
                /******/
              }
              /******/
              /******/
              /******/ // expose the modules object (__webpack_modules__)
              /******/
              __webpack_require__.m = modules;
              /******/
              /******/ // expose the module cache
              /******/
              __webpack_require__.c = installedModules;
              /******/
              /******/ // define getter function for harmony exports
              /******/
              __webpack_require__.d = function (exports, name, getter) {
                /******/if (!__webpack_require__.o(exports, name)) {
                  /******/Object.defineProperty(exports, name, {
                    /******/configurable: false,
                    /******/enumerable: true,
                    /******/get: getter
                    /******/
                  });
                  /******/
                }
                /******/
              };
              /******/
              /******/ // getDefaultExport function for compatibility with non-harmony modules
              /******/
              __webpack_require__.n = function (module) {
                /******/var getter = module && module.__esModule ? /******/function getDefault() {
                  return module['default'];
                } : /******/function getModuleExports() {
                  return module;
                };
                /******/
                __webpack_require__.d(getter, 'a', getter);
                /******/
                return getter;
                /******/
              };
              /******/
              /******/ // Object.prototype.hasOwnProperty.call
              /******/
              __webpack_require__.o = function (object, property) {
                return Object.prototype.hasOwnProperty.call(object, property);
              };
              /******/
              /******/ // __webpack_public_path__
              /******/
              __webpack_require__.p = "";
              /******/
              /******/ // Load entry module and return exports
              /******/
              return __webpack_require__(__webpack_require__.s = 3);
              /******/
            }
            /************************************************************************/
            /******/([(/* 0 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              /*
               * Copyright 2002-2015 the original author or authors.
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *      http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */

              /**
               * The common supertype of all AST nodes in a parsed Spring Expression Language
               * format expression.
               *
               * @author Andy Clement
               * @author Ben March
               * @since 0.2.0
               */

              function createSpelNode(nodeType, position) {
                var node = {},
                  type = nodeType || 'Abstract',
                  children = [],
                  parent = null,
                  activeContext;
                node._type = type;
                node.getType = function () {
                  return type;
                };
                node.setType = function (nodeType) {
                  type = nodeType;
                };
                node.getChildren = function () {
                  return children;
                };
                node.addChild = function (childNode) {
                  if (!childNode) {
                    // See OpMinus and OpPlus: right node can be null for unary mode
                    return;
                  }
                  if (!childNode.setParent) {
                    throw {
                      name: 'Error',
                      message: 'Trying to add a child which is not a node: ' + JSON.stringify(childNode)
                    };
                  }
                  childNode.setParent(node);
                  children.push(childNode);
                };
                node.getParent = function () {
                  return parent;
                };
                node.setParent = function (parentNode) {
                  parent = parentNode;
                };
                node.getContext = function (state) {
                  return activeContext || state.activeContext.peek();
                };
                node.setContext = function (nodeContext) {
                  activeContext = nodeContext;
                };
                node.getStartPosition = function () {
                  return position >> 16;
                };
                node.getEndPosition = function () {
                  return position & 0xffff;
                };

                //must override
                node.getValue = function () {
                  throw {
                    name: 'MethodNotImplementedException',
                    message: 'SpelNode#getValue() must be overridden.'
                  };
                };
                node.toString = function () {
                  var s = 'Kind: ' + node.getType();
                  //s += ', Value: ' + node.getValue();
                  s += ', Children: [';
                  for (var i = 0, l = node.getChildren().length; i < l; i += 1) {
                    s += '{' + node.getChildren()[i] + '}, ';
                  }
                  s += ']';
                  return s;
                };

                //constructor
                if (position === 0) {
                  throw {
                    name: 'Error',
                    message: 'Position cannot be 0'
                  };
                }
                for (var _len = arguments.length, operands = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                  operands[_key - 2] = arguments[_key];
                }
                if (operands) {
                  operands.forEach(function (operand) {
                    node.addChild(operand);
                  });
                }
                return node;
              }
              exports.SpelNode = {
                create: createSpelNode
              };

              /***/
            }), (/* 1 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.Stack = Stack;
              /*
               * Copyright 2002-2015 the original author or authors.
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *      http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */

              /**
               * @author Ben March
               * @since 0.2.0
               */

              function Stack(startingElements) {
                this.elements = startingElements || [];
              }
              Stack.prototype.push = function (el) {
                this.elements.push(el);
                return el;
              };
              Stack.prototype.pop = function () {
                return this.elements.pop();
              };
              Stack.prototype.peek = function () {
                return this.elements[this.elements.length - 1];
              };
              Stack.prototype.empty = function () {
                return this.elements.length > 0;
              };
              Stack.prototype.search = function (el) {
                return this.elements.length - this.elements.indexOf(el);
              };

              /***/
            }), (/* 2 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              /*
               * Copyright 2002-2015 the original author or authors.
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *      http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */

              /**
               * @author Andy Clement
               * @author Ben March
               * @since 0.2.0
               */

              var types = {
                LITERAL_INT: 1,
                //tested

                LITERAL_LONG: 2,
                //tested

                LITERAL_HEXINT: 3,
                //tested

                LITERAL_HEXLONG: 4,
                //tested

                LITERAL_STRING: 5,
                //tested

                LITERAL_REAL: 6,
                //tested

                LITERAL_REAL_FLOAT: 7,
                //tested

                LPAREN: '(',
                //tested

                RPAREN: ')',
                //tested

                COMMA: ',',
                //tested

                IDENTIFIER: 0,
                //tested

                COLON: ':',
                //tested

                HASH: '#',
                //tested

                RSQUARE: ']',
                //tested

                LSQUARE: '[',
                //tested

                LCURLY: '{',
                //tested

                RCURLY: '}',
                //tested

                DOT: '.',
                //tested

                PLUS: '+',
                //tested

                STAR: '*',
                //tested

                MINUS: '-',
                //tested

                SELECT_FIRST: '^[',
                //tested

                SELECT_LAST: '$[',
                //tested

                QMARK: '?',
                //tested

                PROJECT: '![',
                //tested

                DIV: '/',
                //tested

                GE: '>=',
                //tested

                GT: '>',
                //tested

                LE: '<=',
                //tested

                LT: '<',
                //tested

                EQ: '==',
                //tested

                NE: '!=',
                //tested

                MOD: '%',
                //tested

                NOT: '!',
                //tested

                ASSIGN: '=',
                //tested

                INSTANCEOF: 'instanceof',
                //test fails

                MATCHES: 'matches',
                //test fails

                BETWEEN: 'between',
                //test fails

                SELECT: '?[',
                //tested

                POWER: '^',
                //tested

                ELVIS: '?:',
                //tested

                SAFE_NAVI: '?.',
                //tested

                BEAN_REF: '@',
                //tested

                SYMBOLIC_OR: '||',
                //tested

                SYMBOLIC_AND: '&&',
                //tested

                INC: '++',
                //tested

                DEC: '--' //tested
              };
              function TokenKind(type) {
                this.type = type;
                this.tokenChars = types[type];
                this._hasPayload = typeof types[type] !== 'string';
                if (typeof types[type] === 'number') {
                  this._ordinal = types[type];
                }
              }

              //create enum
              for (var t in types) {
                if (types.hasOwnProperty(t)) {
                  TokenKind[t] = new TokenKind(t);
                }
              }
              TokenKind.prototype.toString = function () {
                return this.type + (this.tokenChars.length !== 0 ? '(' + this.tokenChars + ')' : '');
              };
              TokenKind.prototype.getLength = function () {
                return this.tokenChars.length;
              };
              TokenKind.prototype.hasPayload = function () {
                return this._hasPayload;
              };
              TokenKind.prototype.valueOf = function (id) {
                for (var t in types) {
                  if (types.hasOwnProperty(t) && types[t] === id) {
                    return TokenKind[t];
                  }
                }
              };
              TokenKind.prototype.ordinal = function () {
                return this._ordinal;
              };
              exports.TokenKind = TokenKind;

              /***/
            }), (/* 3 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.StandardContext = exports.SpelExpressionEvaluator = undefined;
              var _SpelExpressionEvaluator = __webpack_require__(4);
              var _StandardContext = __webpack_require__(50);

              /*
               * Copyright 2002-2015 the original author or authors.
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *      http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */

              /**
               * @author Ben March
               * @since 0.2.0
               */

              exports.SpelExpressionEvaluator = _SpelExpressionEvaluator.SpelExpressionEvaluator;
              exports.StandardContext = _StandardContext.StandardContext;

              /***/
            }), (/* 4 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.SpelExpressionEvaluator = undefined;
              var _SpelExpressionParser = __webpack_require__(5);
              var _Stack = __webpack_require__(1);

              /*
               * Copyright 2002-2015 the original author or authors.
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *      http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */

              /**
               * @author Ben March
               * @since 0.2.0
               */

              var spelExpressionEvaluator = {};
              function evalCompiled(compiledExpression, context, locals) {
                var activeContext = new _Stack.Stack(),
                  state;
                if (!context) {
                  context = {};
                }
                activeContext.push(context);
                state = {
                  rootContext: context,
                  activeContext: activeContext,
                  locals: locals
                };
                return compiledExpression.getValue(state);
              }
              spelExpressionEvaluator.compile = function (expression) {
                var compiledExpression = (0, _SpelExpressionParser.SpelExpressionParser)().parse(expression);
                return {
                  eval: function _eval(context, locals) {
                    return evalCompiled(compiledExpression, context, locals);
                  },
                  _compiledExpression: compiledExpression
                };
              };
              spelExpressionEvaluator.eval = function (expression, context, locals) {
                return spelExpressionEvaluator.compile(expression).eval(context, locals);
              };
              exports.SpelExpressionEvaluator = spelExpressionEvaluator;

              /***/
            }), (/* 5 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.SpelExpressionParser = undefined;
              var _TokenKind = __webpack_require__(2);
              var _Tokenizer = __webpack_require__(6);
              var _BooleanLiteral = __webpack_require__(8);
              var _NumberLiteral = __webpack_require__(9);
              var _StringLiteral = __webpack_require__(10);
              var _NullLiteral = __webpack_require__(11);
              var _FunctionReference = __webpack_require__(12);
              var _MethodReference = __webpack_require__(13);
              var _PropertyReference = __webpack_require__(14);
              var _VariableReference = __webpack_require__(15);
              var _CompoundExpression = __webpack_require__(16);
              var _Indexer = __webpack_require__(17);
              var _Assign = __webpack_require__(18);
              var _OpEQ = __webpack_require__(19);
              var _OpNE = __webpack_require__(20);
              var _OpGE = __webpack_require__(21);
              var _OpGT = __webpack_require__(22);
              var _OpLE = __webpack_require__(23);
              var _OpLT = __webpack_require__(24);
              var _OpPlus = __webpack_require__(25);
              var _OpMinus = __webpack_require__(26);
              var _OpMultiply = __webpack_require__(27);
              var _OpDivide = __webpack_require__(28);
              var _OpModulus = __webpack_require__(29);
              var _OpPower = __webpack_require__(30);
              var _OpInc = __webpack_require__(31);
              var _OpDec = __webpack_require__(32);
              var _OpNot = __webpack_require__(33);
              var _OpAnd = __webpack_require__(34);
              var _OpOr = __webpack_require__(35);
              var _OpMatches = __webpack_require__(36);
              var _Ternary = __webpack_require__(37);
              var _Elvis = __webpack_require__(38);
              var _InlineList = __webpack_require__(39);
              var _InlineMap = __webpack_require__(40);
              var _Selection = __webpack_require__(41);
              var _Projection = __webpack_require__(42);
              var _OpInstanceof = __webpack_require__(43);
              var _OpBetween = __webpack_require__(44);
              var _TypeReference = __webpack_require__(45);
              var _BeanReference = __webpack_require__(46);
              var _Identifier = __webpack_require__(47);
              var _QualifiedIdentifier = __webpack_require__(48);
              var _ConstructorReference = __webpack_require__(49);

              /*
               * Copyright 2002-2015 the original author or authors.
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *      http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */

              /**
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Ben March
               * @since 0.2.0
               *
               */

              exports.SpelExpressionParser = function SpelExpressionParser() {
                var VALID_QUALIFIED_ID_PATTERN = new RegExp('[\\p{L}\\p{N}_$]+');

                // For rules that build nodes, they are stacked here for return
                var constructedNodes = [];

                // The expression being parsed
                var expressionString;

                // The token stream constructed from that expression string
                var tokenStream;

                // length of a populated token stream
                var tokenStreamLength;

                // Current location in the token stream when processing tokens
                var tokenStreamPointer;

                /**
                 * Create a parser with some configured behavior.
                 * @param config custom configuration options
                 */
                function setConfiguration(config) {}
                function parse(expression, context) {
                  try {
                    expressionString = expression;
                    tokenStream = _Tokenizer.Tokenizer.tokenize(expression);
                    tokenStreamLength = tokenStream.length;
                    tokenStreamPointer = 0;
                    constructedNodes = [];
                    var ast = eatExpression();
                    if (moreTokens()) {
                      raiseInternalException(peekToken().startPos, 'MORE_INPUT', nextToken().toString());
                    }
                    //Assert.isTrue(this.constructedNodes.isEmpty());
                    return ast;
                  } catch (e) {
                    throw e.message;
                  }
                }

                //	expression
                //    : logicalOrExpression
                //      ( (ASSIGN^ logicalOrExpression)
                //	    | (DEFAULT^ logicalOrExpression)
                //	    | (QMARK^ expression COLON! expression)
                //      | (ELVIS^ expression))?;
                function eatExpression() {
                  var expr = eatLogicalOrExpression();
                  if (moreTokens()) {
                    var token = peekToken();
                    if (token.getKind() === _TokenKind.TokenKind.ASSIGN) {
                      // a=b
                      if (expr === null) {
                        expr = _NullLiteral.NullLiteral.create(toPosBounds(token.startPos - 1, token.endPos - 1));
                      }
                      nextToken();
                      var assignedValue = eatLogicalOrExpression();
                      return _Assign.Assign.create(toPosToken(token), expr, assignedValue);
                    }
                    if (token.getKind() === _TokenKind.TokenKind.ELVIS) {
                      // a?:b (a if it isn't null, otherwise b)
                      if (expr === null) {
                        expr = _NullLiteral.NullLiteral.create(toPosBounds(token.startPos - 1, token.endPos - 2));
                      }
                      nextToken(); // elvis has left the building
                      var valueIfNull = eatExpression();
                      if (valueIfNull === null) {
                        valueIfNull = _NullLiteral.NullLiteral.create(toPosBounds(token.startPos + 1, token.endPos + 1));
                      }
                      return _Elvis.Elvis.create(toPosToken(token), expr, valueIfNull);
                    }
                    if (token.getKind() === _TokenKind.TokenKind.QMARK) {
                      // a?b:c
                      if (expr === null) {
                        expr = _NullLiteral.NullLiteral.create(toPosBounds(token.startPos - 1, token.endPos - 1));
                      }
                      nextToken();
                      var ifTrueExprValue = eatExpression();
                      eatToken(_TokenKind.TokenKind.COLON);
                      var ifFalseExprValue = eatExpression();
                      return _Ternary.Ternary.create(toPosToken(token), expr, ifTrueExprValue, ifFalseExprValue);
                    }
                  }
                  return expr;
                }

                //logicalOrExpression : logicalAndExpression (OR^ logicalAndExpression)*;
                function eatLogicalOrExpression() {
                  var expr = eatLogicalAndExpression();
                  while (peekIdentifierToken('or') || peekTokenOne(_TokenKind.TokenKind.SYMBOLIC_OR)) {
                    var token = nextToken(); //consume OR
                    var rhExpr = eatLogicalAndExpression();
                    checkOperands(token, expr, rhExpr);
                    expr = _OpOr.OpOr.create(toPosToken(token), expr, rhExpr);
                  }
                  return expr;
                }

                // logicalAndExpression : relationalExpression (AND^ relationalExpression)*;
                function eatLogicalAndExpression() {
                  var expr = eatRelationalExpression();
                  while (peekIdentifierToken('and') || peekTokenOne(_TokenKind.TokenKind.SYMBOLIC_AND)) {
                    var token = nextToken(); // consume 'AND'
                    var rhExpr = eatRelationalExpression();
                    checkOperands(token, expr, rhExpr);
                    expr = _OpAnd.OpAnd.create(toPosToken(token), expr, rhExpr);
                  }
                  return expr;
                }

                // relationalExpression : sumExpression (relationalOperator^ sumExpression)?;
                function eatRelationalExpression() {
                  var expr = eatSumExpression();
                  var relationalOperatorToken = maybeEatRelationalOperator();
                  if (relationalOperatorToken !== null) {
                    var token = nextToken(); // consume relational operator token
                    var rhExpr = eatSumExpression();
                    checkOperands(token, expr, rhExpr);
                    var tk = relationalOperatorToken.kind;
                    if (relationalOperatorToken.isNumericRelationalOperator()) {
                      var pos = toPosToken(token);
                      if (tk === _TokenKind.TokenKind.GT) {
                        return _OpGT.OpGT.create(pos, expr, rhExpr);
                      }
                      if (tk === _TokenKind.TokenKind.LT) {
                        return _OpLT.OpLT.create(pos, expr, rhExpr);
                      }
                      if (tk === _TokenKind.TokenKind.LE) {
                        return _OpLE.OpLE.create(pos, expr, rhExpr);
                      }
                      if (tk === _TokenKind.TokenKind.GE) {
                        return _OpGE.OpGE.create(pos, expr, rhExpr);
                      }
                      if (tk === _TokenKind.TokenKind.EQ) {
                        return _OpEQ.OpEQ.create(pos, expr, rhExpr);
                      }
                      //Assert.isTrue(tk === TokenKind.NE);
                      return _OpNE.OpNE.create(pos, expr, rhExpr);
                    }
                    if (tk === _TokenKind.TokenKind.INSTANCEOF) {
                      return _OpInstanceof.OpInstanceof.create(toPosToken(token), expr, rhExpr);
                    }
                    if (tk === _TokenKind.TokenKind.MATCHES) {
                      return _OpMatches.OpMatches.create(toPosToken(token), expr, rhExpr);
                    }

                    //Assert.isTrue(tk === TokenKind.BETWEEN);
                    return _OpBetween.OpBetween.create(toPosToken(token), expr, rhExpr);
                  }
                  return expr;
                }

                //sumExpression: productExpression ( (PLUS^ | MINUS^) productExpression)*;
                function eatSumExpression() {
                  var expr = eatProductExpression();
                  while (peekTokenAny(_TokenKind.TokenKind.PLUS, _TokenKind.TokenKind.MINUS, _TokenKind.TokenKind.INC)) {
                    var token = nextToken(); //consume PLUS or MINUS or INC
                    var rhExpr = eatProductExpression();
                    checkRightOperand(token, rhExpr);
                    if (token.getKind() === _TokenKind.TokenKind.PLUS) {
                      expr = _OpPlus.OpPlus.create(toPosToken(token), expr, rhExpr);
                    } else if (token.getKind() === _TokenKind.TokenKind.MINUS) {
                      expr = _OpMinus.OpMinus.create(toPosToken(token), expr, rhExpr);
                    }
                  }
                  return expr;
                }

                // productExpression: powerExpr ((STAR^ | DIV^| MOD^) powerExpr)* ;
                function eatProductExpression() {
                  var expr = eatPowerIncDecExpression();
                  while (peekTokenAny(_TokenKind.TokenKind.STAR, _TokenKind.TokenKind.DIV, _TokenKind.TokenKind.MOD)) {
                    var token = nextToken(); // consume STAR/DIV/MOD
                    var rhExpr = eatPowerIncDecExpression();
                    checkOperands(token, expr, rhExpr);
                    if (token.getKind() === _TokenKind.TokenKind.STAR) {
                      expr = _OpMultiply.OpMultiply.create(toPosToken(token), expr, rhExpr);
                    } else if (token.getKind() === _TokenKind.TokenKind.DIV) {
                      expr = _OpDivide.OpDivide.create(toPosToken(token), expr, rhExpr);
                    } else {
                      //Assert.isTrue(token.getKind() === TokenKind.MOD);
                      expr = _OpModulus.OpModulus.create(toPosToken(token), expr, rhExpr);
                    }
                  }
                  return expr;
                }

                // powerExpr  : unaryExpression (POWER^ unaryExpression)? (INC || DEC) ;
                function eatPowerIncDecExpression() {
                  var expr = eatUnaryExpression(),
                    token;
                  if (peekTokenOne(_TokenKind.TokenKind.POWER)) {
                    token = nextToken(); //consume POWER
                    var rhExpr = eatUnaryExpression();
                    checkRightOperand(token, rhExpr);
                    return _OpPower.OpPower.create(toPosToken(token), expr, rhExpr);
                  }
                  if (expr !== null && peekTokenAny(_TokenKind.TokenKind.INC, _TokenKind.TokenKind.DEC)) {
                    token = nextToken(); //consume INC/DEC
                    if (token.getKind() === _TokenKind.TokenKind.INC) {
                      return _OpInc.OpInc.create(toPosToken(token), true, expr);
                    }
                    return _OpDec.OpDec.create(toPosToken(token), true, expr);
                  }
                  return expr;
                }

                // unaryExpression: (PLUS^ | MINUS^ | BANG^ | INC^ | DEC^) unaryExpression | primaryExpression ;
                function eatUnaryExpression() {
                  var token, expr;
                  if (peekTokenAny(_TokenKind.TokenKind.PLUS, _TokenKind.TokenKind.MINUS, _TokenKind.TokenKind.NOT)) {
                    token = nextToken();
                    expr = eatUnaryExpression();
                    if (token.getKind() === _TokenKind.TokenKind.NOT) {
                      return _OpNot.OpNot.create(toPosToken(token), expr);
                    }
                    if (token.getKind() === _TokenKind.TokenKind.PLUS) {
                      return _OpPlus.OpPlus.create(toPosToken(token), expr);
                    }
                    //Assert.isTrue(token.getKind() === TokenKind.MINUS);
                    return _OpMinus.OpMinus.create(toPosToken(token), expr);
                  }
                  if (peekTokenAny(_TokenKind.TokenKind.INC, _TokenKind.TokenKind.DEC)) {
                    token = nextToken();
                    expr = eatUnaryExpression();
                    if (token.getKind() === _TokenKind.TokenKind.INC) {
                      return _OpInc.OpInc.create(toPosToken(token), false, expr);
                    }
                    return _OpDec.OpDec.create(toPosToken(token), false, expr);
                  }
                  return eatPrimaryExpression();
                }

                // primaryExpression : startNode (node)? -> ^(EXPRESSION startNode (node)?);
                function eatPrimaryExpression() {
                  var nodes = [];
                  var start = eatStartNode(); // always a start node
                  nodes.push(start);
                  while (maybeEatNode()) {
                    nodes.push(pop());
                  }
                  if (nodes.length === 1) {
                    return nodes[0];
                  }
                  return _CompoundExpression.CompoundExpression.create(toPosBounds(start.getStartPosition(), nodes[nodes.length - 1].getEndPosition()), nodes);
                }

                // node : ((DOT dottedNode) | (SAFE_NAVI dottedNode) | nonDottedNode)+;
                function maybeEatNode() {
                  var expr = null;
                  if (peekTokenAny(_TokenKind.TokenKind.DOT, _TokenKind.TokenKind.SAFE_NAVI)) {
                    expr = eatDottedNode();
                  } else {
                    expr = maybeEatNonDottedNode();
                  }
                  if (expr === null) {
                    return false;
                  } else {
                    push(expr);
                    return true;
                  }
                }

                // nonDottedNode: indexer;
                function maybeEatNonDottedNode() {
                  if (peekTokenOne(_TokenKind.TokenKind.LSQUARE)) {
                    if (maybeEatIndexer()) {
                      return pop();
                    }
                  }
                  return null;
                }

                //dottedNode
                // : ((methodOrProperty
                //	  | functionOrVar
                //    | projection
                //    | selection
                //    | firstSelection
                //    | lastSelection
                //    ))
                //	;
                function eatDottedNode() {
                  var token = nextToken(); // it was a '.' or a '?.'
                  var nullSafeNavigation = token.getKind() === _TokenKind.TokenKind.SAFE_NAVI;
                  if (maybeEatMethodOrProperty(nullSafeNavigation) || maybeEatFunctionOrVar() || maybeEatProjection(nullSafeNavigation) || maybeEatSelection(nullSafeNavigation)) {
                    return pop();
                  }
                  if (peekToken() === null) {
                    // unexpectedly ran out of data
                    raiseInternalException(token.startPos, 'OOD');
                  } else {
                    raiseInternalException(token.startPos, 'UNEXPECTED_DATA_AFTER_DOT', toString(peekToken()));
                  }
                  return null;
                }

                // functionOrVar
                // : (POUND ID LPAREN) => function
                // | var
                //
                // function : POUND id=ID methodArgs -> ^(FUNCTIONREF[$id] methodArgs);
                // var : POUND id=ID -> ^(VARIABLEREF[$id]);
                function maybeEatFunctionOrVar() {
                  if (!peekTokenOne(_TokenKind.TokenKind.HASH)) {
                    return false;
                  }
                  var token = nextToken();
                  var functionOrVariableName = eatToken(_TokenKind.TokenKind.IDENTIFIER);
                  var args = maybeEatMethodArgs();
                  if (args === null) {
                    push(_VariableReference.VariableReference.create(functionOrVariableName.data, toPosBounds(token.startPos, functionOrVariableName.endPos)));
                    return true;
                  }
                  push(_FunctionReference.FunctionReference.create(functionOrVariableName.data, toPosBounds(token.startPos, functionOrVariableName.endPos), args));
                  return true;
                }

                // methodArgs : LPAREN! (argument (COMMA! argument)* (COMMA!)?)? RPAREN!;
                function maybeEatMethodArgs() {
                  if (!peekTokenOne(_TokenKind.TokenKind.LPAREN)) {
                    return null;
                  }
                  var args = [];
                  consumeArguments(args);
                  eatToken(_TokenKind.TokenKind.RPAREN);
                  return args;
                }
                function eatConstructorArgs(accumulatedArguments) {
                  if (!peekTokenOne(_TokenKind.TokenKind.LPAREN)) {
                    raiseInternalException(toPosToken(peekToken()), 'MISSING_CONSTRUCTOR_ARGS');
                  }
                  consumeArguments(accumulatedArguments);
                  eatToken(_TokenKind.TokenKind.RPAREN);
                }

                /**
                 * Used for consuming arguments for either a method or a constructor call
                 */
                function consumeArguments(accumulatedArguments) {
                  var pos = peekToken().startPos;
                  var next;
                  do {
                    nextToken(); // consume ( (first time through) or comma (subsequent times)
                    var token = peekToken();
                    if (token === null) {
                      raiseInternalException(pos, 'RUN_OUT_OF_ARGUMENTS');
                    }
                    if (token.getKind() !== _TokenKind.TokenKind.RPAREN) {
                      accumulatedArguments.push(eatExpression());
                    }
                    next = peekToken();
                  } while (next !== null && next.kind === _TokenKind.TokenKind.COMMA);
                  if (next === null) {
                    raiseInternalException(pos, 'RUN_OUT_OF_ARGUMENTS');
                  }
                }

                //startNode
                // : parenExpr | literal
                //	    | type
                //	    | methodOrProperty
                //	    | functionOrVar
                //	    | projection
                //	    | selection
                //	    | firstSelection
                //	    | lastSelection
                //	    | indexer
                //	    | constructor
                function eatStartNode() {
                  if (maybeEatLiteral()) {
                    return pop();
                  } else if (maybeEatParenExpression()) {
                    return pop();
                  } else if (maybeEatTypeReference() || maybeEatNullReference() || maybeEatConstructorReference() || maybeEatMethodOrProperty(false) || maybeEatFunctionOrVar()) {
                    return pop();
                  } else if (maybeEatBeanReference()) {
                    return pop();
                  } else if (maybeEatProjection(false) || maybeEatSelection(false) || maybeEatIndexer()) {
                    return pop();
                  } else if (maybeEatInlineListOrMap()) {
                    return pop();
                  } else {
                    return null;
                  }
                }

                // parse: @beanname @'bean.name'
                // quoted if dotted
                function maybeEatBeanReference() {
                  if (peekTokenOne(_TokenKind.TokenKind.BEAN_REF)) {
                    var beanRefToken = nextToken();
                    var beanNameToken = null;
                    var beanName = null;
                    if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                      beanNameToken = eatToken(_TokenKind.TokenKind.IDENTIFIER);
                      beanName = beanNameToken.data;
                    } else if (peekTokenOne(_TokenKind.TokenKind.LITERAL_STRING)) {
                      beanNameToken = eatToken(_TokenKind.TokenKind.LITERAL_STRING);
                      beanName = beanNameToken.stringValue();
                      beanName = beanName.substring(1, beanName.length() - 1);
                    } else {
                      raiseInternalException(beanRefToken.startPos, 'INVALID_BEAN_REFERENCE');
                    }
                    var beanReference = _BeanReference.BeanReference.create(toPosToken(beanNameToken), beanName);
                    push(beanReference);
                    return true;
                  }
                  return false;
                }
                function maybeEatTypeReference() {
                  if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                    var typeName = peekToken();
                    if (typeName.stringValue() !== 'T') {
                      return false;
                    }
                    // It looks like a type reference but is T being used as a map key?
                    var token = nextToken();
                    if (peekTokenOne(_TokenKind.TokenKind.RSQUARE)) {
                      // looks like 'T]' (T is map key)
                      push(_PropertyReference.PropertyReference.create(token.stringValue(), toPosToken(token)));
                      return true;
                    }
                    eatToken(_TokenKind.TokenKind.LPAREN);
                    var node = eatPossiblyQualifiedId();
                    // dotted qualified id
                    // Are there array dimensions?
                    var dims = 0;
                    while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.LSQUARE, true)) {
                      eatToken(_TokenKind.TokenKind.RSQUARE);
                      dims++;
                    }
                    eatToken(_TokenKind.TokenKind.RPAREN);
                    push(_TypeReference.TypeReference.create(toPosToken(typeName), node, dims));
                    return true;
                  }
                  return false;
                }
                function maybeEatNullReference() {
                  if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                    var nullToken = peekToken();
                    if (nullToken.stringValue().toLowerCase() !== 'null') {
                      return false;
                    }
                    nextToken();
                    push(_NullLiteral.NullLiteral.create(toPosToken(nullToken)));
                    return true;
                  }
                  return false;
                }

                //projection: PROJECT^ expression RCURLY!;
                function maybeEatProjection(nullSafeNavigation) {
                  var token = peekToken();
                  if (!peekTokenConsumeIfMatched(_TokenKind.TokenKind.PROJECT, true)) {
                    return false;
                  }
                  var expr = eatExpression();
                  eatToken(_TokenKind.TokenKind.RSQUARE);
                  push(_Projection.Projection.create(nullSafeNavigation, toPosToken(token), expr));
                  return true;
                }

                // list = LCURLY (element (COMMA element)*) RCURLY
                // map  = LCURLY (key ':' value (COMMA key ':' value)*) RCURLY
                function maybeEatInlineListOrMap() {
                  var token = peekToken(),
                    listElements = [];
                  if (!peekTokenConsumeIfMatched(_TokenKind.TokenKind.LCURLY, true)) {
                    return false;
                  }
                  var expr = null;
                  var closingCurly = peekToken();
                  if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.RCURLY, true)) {
                    // empty list '{}'
                    expr = _InlineList.InlineList.create(toPosBounds(token.startPos, closingCurly.endPos));
                  } else if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COLON, true)) {
                    closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                    // empty map '{:}'
                    expr = _InlineMap.InlineMap.create(toPosBounds(token.startPos, closingCurly.endPos));
                  } else {
                    var firstExpression = eatExpression();
                    // Next is either:
                    // '}' - end of list
                    // ',' - more expressions in this list
                    // ':' - this is a map!

                    if (peekTokenOne(_TokenKind.TokenKind.RCURLY)) {
                      // list with one item in it
                      listElements.push(firstExpression);
                      closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                      expr = _InlineList.InlineList.create(toPosBounds(token.startPos, closingCurly.endPos), listElements);
                    } else if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COMMA, true)) {
                      // multi item list
                      listElements.push(firstExpression);
                      do {
                        listElements.push(eatExpression());
                      } while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COMMA, true));
                      closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                      expr = _InlineList.InlineList.create(toPosToken(token.startPos, closingCurly.endPos), listElements);
                    } else if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COLON, true)) {
                      // map!
                      var mapElements = [];
                      mapElements.push(firstExpression);
                      mapElements.push(eatExpression());
                      while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COMMA, true)) {
                        mapElements.push(eatExpression());
                        eatToken(_TokenKind.TokenKind.COLON);
                        mapElements.push(eatExpression());
                      }
                      closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                      expr = _InlineMap.InlineMap.create(toPosBounds(token.startPos, closingCurly.endPos), mapElements);
                    } else {
                      raiseInternalException(token.startPos, 'OOD');
                    }
                  }
                  push(expr);
                  return true;
                }
                function maybeEatIndexer() {
                  var token = peekToken();
                  if (!peekTokenConsumeIfMatched(_TokenKind.TokenKind.LSQUARE, true)) {
                    return false;
                  }
                  var expr = eatExpression();
                  eatToken(_TokenKind.TokenKind.RSQUARE);
                  push(_Indexer.Indexer.create(toPosToken(token), expr));
                  return true;
                }
                function maybeEatSelection(nullSafeNavigation) {
                  var token = peekToken();
                  if (!peekSelectToken()) {
                    return false;
                  }
                  nextToken();
                  var expr = eatExpression();
                  if (expr === null) {
                    raiseInternalException(toPosToken(token), 'MISSING_SELECTION_EXPRESSION');
                  }
                  eatToken(_TokenKind.TokenKind.RSQUARE);
                  if (token.getKind() === _TokenKind.TokenKind.SELECT_FIRST) {
                    push(_Selection.Selection.create(nullSafeNavigation, _Selection.Selection.FIRST, toPosToken(token), expr));
                  } else if (token.getKind() === _TokenKind.TokenKind.SELECT_LAST) {
                    push(_Selection.Selection.create(nullSafeNavigation, _Selection.Selection.LAST, toPosToken(token), expr));
                  } else {
                    push(_Selection.Selection.create(nullSafeNavigation, _Selection.Selection.ALL, toPosToken(token), expr));
                  }
                  return true;
                }

                /**
                 * Eat an identifier, possibly qualified (meaning that it is dotted).
                 * TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c)
                 */
                function eatPossiblyQualifiedId() {
                  var qualifiedIdPieces = [];
                  var node = peekToken();
                  while (isValidQualifiedId(node)) {
                    nextToken();
                    if (node.kind !== _TokenKind.TokenKind.DOT) {
                      qualifiedIdPieces.push(_Identifier.Identifier.create(node.stringValue(), toPosToken(node)));
                    }
                    node = peekToken();
                  }
                  if (!qualifiedIdPieces.length) {
                    if (node === null) {
                      raiseInternalException(expressionString.length(), 'OOD');
                    }
                    raiseInternalException(node.startPos, 'NOT_EXPECTED_TOKEN', 'qualified ID', node.getKind().toString().toLowerCase());
                  }
                  var pos = toPosBounds(qualifiedIdPieces[0].getStartPosition(), qualifiedIdPieces[qualifiedIdPieces.length - 1].getEndPosition());
                  return _QualifiedIdentifier.QualifiedIdentifier.create(pos, qualifiedIdPieces);
                }
                function isValidQualifiedId(node) {
                  if (node === null || node.kind === _TokenKind.TokenKind.LITERAL_STRING) {
                    return false;
                  }
                  if (node.kind === _TokenKind.TokenKind.DOT || node.kind === _TokenKind.TokenKind.IDENTIFIER) {
                    return true;
                  }
                  var value = node.stringValue();
                  return value && value.length && VALID_QUALIFIED_ID_PATTERN.test(value);
                }

                // This is complicated due to the support for dollars in identifiers.  Dollars are normally separate tokens but
                // there we want to combine a series of identifiers and dollars into a single identifier
                function maybeEatMethodOrProperty(nullSafeNavigation) {
                  if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                    var methodOrPropertyName = nextToken();
                    var args = maybeEatMethodArgs();
                    if (args === null) {
                      // property
                      push(_PropertyReference.PropertyReference.create(nullSafeNavigation, methodOrPropertyName.stringValue(), toPosToken(methodOrPropertyName)));
                      return true;
                    }
                    // methodreference
                    push(_MethodReference.MethodReference.create(nullSafeNavigation, methodOrPropertyName.stringValue(), toPosToken(methodOrPropertyName), args));
                    // TODO what is the end position for a method reference? the name or the last arg?
                    return true;
                  }
                  return false;
                }

                //constructor
                //:	('new' qualifiedId LPAREN) => 'new' qualifiedId ctorArgs -> ^(CONSTRUCTOR qualifiedId ctorArgs)
                function maybeEatConstructorReference() {
                  if (peekIdentifierToken('new')) {
                    var newToken = nextToken();
                    // It looks like a constructor reference but is NEW being used as a map key?
                    if (peekTokenOne(_TokenKind.TokenKind.RSQUARE)) {
                      // looks like 'NEW]' (so NEW used as map key)
                      push(_PropertyReference.PropertyReference.create(newToken.stringValue(), toPosToken(newToken)));
                      return true;
                    }
                    var possiblyQualifiedConstructorName = eatPossiblyQualifiedId();
                    var nodes = [];
                    nodes.push(possiblyQualifiedConstructorName);
                    if (peekTokenOne(_TokenKind.TokenKind.LSQUARE)) {
                      // array initializer
                      var dimensions = [];
                      while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.LSQUARE, true)) {
                        if (!peekTokenOne(_TokenKind.TokenKind.RSQUARE)) {
                          dimensions.push(eatExpression());
                        } else {
                          dimensions.push(null);
                        }
                        eatToken(_TokenKind.TokenKind.RSQUARE);
                      }
                      if (maybeEatInlineListOrMap()) {
                        nodes.push(pop());
                      }
                      push(_ConstructorReference.ConstructorReference.create(toPosToken(newToken), dimensions, nodes));
                    } else {
                      // regular constructor invocation
                      eatConstructorArgs(nodes);
                      // TODO correct end position?
                      push(_ConstructorReference.ConstructorReference.create(toPosToken(newToken), nodes));
                    }
                    return true;
                  }
                  return false;
                }
                function push(newNode) {
                  constructedNodes.push(newNode);
                }
                function pop() {
                  return constructedNodes.pop();
                }

                //	literal
                //  : INTEGER_LITERAL
                //	| boolLiteral
                //	| STRING_LITERAL
                //  | HEXADECIMAL_INTEGER_LITERAL
                //  | REAL_LITERAL
                //	| DQ_STRING_LITERAL
                //	| NULL_LITERAL
                function maybeEatLiteral() {
                  var token = peekToken();
                  if (token === null) {
                    return false;
                  }
                  if (token.getKind() === _TokenKind.TokenKind.LITERAL_INT || token.getKind() === _TokenKind.TokenKind.LITERAL_LONG) {
                    push(_NumberLiteral.NumberLiteral.create(parseInt(token.stringValue(), 10), toPosToken(token)));
                  } else if (token.getKind() === _TokenKind.TokenKind.LITERAL_REAL || token.getKind() === _TokenKind.TokenKind.LITERAL_REAL_FLOAT) {
                    push(_NumberLiteral.NumberLiteral.create(parseFloat(token.stringValue()), toPosToken(token)));
                  } else if (token.getKind() === _TokenKind.TokenKind.LITERAL_HEXINT || token.getKind() === _TokenKind.TokenKind.LITERAL_HEXLONG) {
                    push(_NumberLiteral.NumberLiteral.create(parseInt(token.stringValue(), 16), toPosToken(token)));
                  } else if (peekIdentifierToken('true')) {
                    push(_BooleanLiteral.BooleanLiteral.create(true, toPosToken(token)));
                  } else if (peekIdentifierToken('false')) {
                    push(_BooleanLiteral.BooleanLiteral.create(false, toPosToken(token)));
                  } else if (token.getKind() === _TokenKind.TokenKind.LITERAL_STRING) {
                    push(_StringLiteral.StringLiteral.create(token.stringValue(), toPosToken(token)));
                  } else {
                    return false;
                  }
                  nextToken();
                  return true;
                }

                //parenExpr : LPAREN! expression RPAREN!;
                function maybeEatParenExpression() {
                  if (peekTokenOne(_TokenKind.TokenKind.LPAREN)) {
                    nextToken();
                    var expr = eatExpression();
                    eatToken(_TokenKind.TokenKind.RPAREN);
                    push(expr);
                    return true;
                  } else {
                    return false;
                  }
                }

                // relationalOperator
                // : EQUAL | NOT_EQUAL | LESS_THAN | LESS_THAN_OR_EQUAL | GREATER_THAN
                // | GREATER_THAN_OR_EQUAL | INSTANCEOF | BETWEEN | MATCHES
                function maybeEatRelationalOperator() {
                  var token = peekToken();
                  if (token === null) {
                    return null;
                  }
                  if (token.isNumericRelationalOperator()) {
                    return token;
                  }
                  if (token.isIdentifier()) {
                    var idString = token.stringValue();
                    if (idString.toLowerCase() === 'instanceof') {
                      return token.asInstanceOfToken();
                    }
                    if (idString.toLowerCase() === 'matches') {
                      return token.asMatchesToken();
                    }
                    if (idString.toLowerCase() === 'between') {
                      return token.asBetweenToken();
                    }
                  }
                  return null;
                }
                function eatToken(expectedKind) {
                  var token = nextToken();
                  if (token === null) {
                    raiseInternalException(expressionString.length, 'OOD');
                  }
                  if (token.getKind() !== expectedKind) {
                    raiseInternalException(token.startPos, 'NOT_EXPECTED_TOKEN', expectedKind.toString().toLowerCase(), token.getKind().toString().toLowerCase());
                  }
                  return token;
                }
                function peekTokenOne(desiredTokenKind) {
                  return peekTokenConsumeIfMatched(desiredTokenKind, false);
                }
                function peekTokenConsumeIfMatched(desiredTokenKind, consumeIfMatched) {
                  if (!moreTokens()) {
                    return false;
                  }
                  var token = peekToken();
                  if (token.getKind() === desiredTokenKind) {
                    if (consumeIfMatched) {
                      tokenStreamPointer++;
                    }
                    return true;
                  }
                  if (desiredTokenKind === _TokenKind.TokenKind.IDENTIFIER) {
                    // might be one of the textual forms of the operators (e.g. NE for !== ) - in which case we can treat it as an identifier
                    // The list is represented here: Tokenizer.alternativeOperatorNames and those ones are in order in the TokenKind enum
                    if (token.getKind().ordinal() >= _TokenKind.TokenKind.DIV.ordinal() && token.getKind().ordinal() <= _TokenKind.TokenKind.NOT.ordinal() && token.data !== null) {
                      // if token.data were null, we'd know it wasn'token the textual form, it was the symbol form
                      return true;
                    }
                  }
                  return false;
                }
                function peekTokenAny() {
                  if (!moreTokens()) {
                    return false;
                  }
                  var token = peekToken();
                  var args = Array.prototype.slice.call(arguments);
                  for (var i = 0, l = args.length; i < l; i += 1) {
                    if (token.getKind() === args[i]) {
                      return true;
                    }
                  }
                  return false;
                }
                function peekIdentifierToken(identifierString) {
                  if (!moreTokens()) {
                    return false;
                  }
                  var token = peekToken();
                  return token.getKind() === _TokenKind.TokenKind.IDENTIFIER && token.stringValue().toLowerCase() === identifierString.toLowerCase();
                }
                function peekSelectToken() {
                  if (!moreTokens()) {
                    return false;
                  }
                  var token = peekToken();
                  return token.getKind() === _TokenKind.TokenKind.SELECT || token.getKind() === _TokenKind.TokenKind.SELECT_FIRST || token.getKind() === _TokenKind.TokenKind.SELECT_LAST;
                }
                function moreTokens() {
                  return tokenStreamPointer < tokenStream.length;
                }
                function nextToken() {
                  if (tokenStreamPointer >= tokenStreamLength) {
                    return null;
                  }
                  return tokenStream[tokenStreamPointer++];
                }
                function peekToken() {
                  if (tokenStreamPointer >= tokenStreamLength) {
                    return null;
                  }
                  return tokenStream[tokenStreamPointer];
                }
                function raiseInternalException(pos, message, expected, actual) {
                  if (expected) {
                    message += '\nExpected: ' + expected;
                  }
                  if (actual) {
                    message += '\nActual: ' + actual;
                  }
                  throw {
                    name: 'InternalParseException',
                    message: 'Error occurred while attempting to parse expression \'' + expressionString + '\' at position ' + pos + '. Message: ' + message
                  };
                }
                function toString(token) {
                  if (token.getKind().hasPayload()) {
                    return token.stringValue();
                  }
                  return token.getKind().toString().toLowerCase();
                }
                function checkOperands(token, left, right) {
                  checkLeftOperand(token, left);
                  checkRightOperand(token, right);
                }
                function checkLeftOperand(token, operandExpression) {
                  if (operandExpression === null) {
                    raiseInternalException(token.startPos, 'LEFT_OPERAND_PROBLEM');
                  }
                }
                function checkRightOperand(token, operandExpression) {
                  if (operandExpression === null) {
                    raiseInternalException(token.startPos, 'RIGHT_OPERAND_PROBLEM');
                  }
                }

                /**
                 * Compress the start and end of a token into a single int.
                 */
                function toPosToken(token) {
                  return (token.startPos << 16) + token.endPos;
                }
                function toPosBounds(start, end) {
                  return (start << 16) + end;
                }
                return {
                  setConfiguration: setConfiguration,
                  parse: parse
                };
              };

              //not yet implemented

              /***/
            }), (/* 6 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.Tokenizer = undefined;
              var _Token = __webpack_require__(7);
              var _TokenKind = __webpack_require__(2);

              /*
               * Copyright 2002-2015 the original author or authors.
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *      http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */

              /**
               * @author Andy Clement
               * @author Phillip Webb
               * @author Ben March
               * @since 0.2.0
               */

              var ALTERNATIVE_OPERATOR_NAMES = ['DIV', 'EQ', 'GE', 'GT', 'LE', 'LT', 'MOD', 'NE', 'NOT'],
                FLAGS = [],
                IS_DIGIT = 1,
                IS_HEXDIGIT = 2,
                IS_ALPHA = 4;
              function init() {
                var ch;
                for (ch = '0'.charCodeAt(0); ch <= '9'.charCodeAt(0); ch += 1) {
                  FLAGS[ch] |= IS_DIGIT | IS_HEXDIGIT;
                }
                for (ch = 'A'.charCodeAt(0); ch <= 'F'.charCodeAt(0); ch += 1) {
                  FLAGS[ch] |= IS_HEXDIGIT;
                }
                for (ch = 'a'.charCodeAt(0); ch <= 'f'.charCodeAt(0); ch += 1) {
                  FLAGS[ch] |= IS_HEXDIGIT;
                }
                for (ch = 'A'.charCodeAt(0); ch <= 'Z'.charCodeAt(0); ch += 1) {
                  FLAGS[ch] |= IS_ALPHA;
                }
                for (ch = 'a'.charCodeAt(0); ch <= 'z'.charCodeAt(0); ch += 1) {
                  FLAGS[ch] |= IS_ALPHA;
                }
              }
              init();
              function tokenize(inputData) {
                var expressionString = inputData,
                  toProcess = inputData + '\0',
                  max = toProcess.length,
                  pos = 0,
                  tokens = [];
                function process() {
                  var ch;
                  while (pos < max) {
                    ch = toProcess[pos];
                    if (isAlphabetic(ch)) {
                      lexIdentifier();
                    } else {
                      switch (ch) {
                        case '+':
                          if (isTwoCharToken(_TokenKind.TokenKind.INC)) {
                            pushPairToken(_TokenKind.TokenKind.INC);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.PLUS);
                          }
                          break;
                        case '_':
                          // the other way to start an identifier
                          lexIdentifier();
                          break;
                        case '-':
                          if (isTwoCharToken(_TokenKind.TokenKind.DEC)) {
                            pushPairToken(_TokenKind.TokenKind.DEC);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.MINUS);
                          }
                          break;
                        case ':':
                          pushCharToken(_TokenKind.TokenKind.COLON);
                          break;
                        case '.':
                          pushCharToken(_TokenKind.TokenKind.DOT);
                          break;
                        case ',':
                          pushCharToken(_TokenKind.TokenKind.COMMA);
                          break;
                        case '*':
                          pushCharToken(_TokenKind.TokenKind.STAR);
                          break;
                        case '/':
                          pushCharToken(_TokenKind.TokenKind.DIV);
                          break;
                        case '%':
                          pushCharToken(_TokenKind.TokenKind.MOD);
                          break;
                        case '(':
                          pushCharToken(_TokenKind.TokenKind.LPAREN);
                          break;
                        case ')':
                          pushCharToken(_TokenKind.TokenKind.RPAREN);
                          break;
                        case '[':
                          pushCharToken(_TokenKind.TokenKind.LSQUARE);
                          break;
                        case '#':
                          pushCharToken(_TokenKind.TokenKind.HASH);
                          break;
                        case ']':
                          pushCharToken(_TokenKind.TokenKind.RSQUARE);
                          break;
                        case '{':
                          pushCharToken(_TokenKind.TokenKind.LCURLY);
                          break;
                        case '}':
                          pushCharToken(_TokenKind.TokenKind.RCURLY);
                          break;
                        case '@':
                          pushCharToken(_TokenKind.TokenKind.BEAN_REF);
                          break;
                        case '^':
                          if (isTwoCharToken(_TokenKind.TokenKind.SELECT_FIRST)) {
                            pushPairToken(_TokenKind.TokenKind.SELECT_FIRST);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.POWER);
                          }
                          break;
                        case '!':
                          if (isTwoCharToken(_TokenKind.TokenKind.NE)) {
                            pushPairToken(_TokenKind.TokenKind.NE);
                          } else if (isTwoCharToken(_TokenKind.TokenKind.PROJECT)) {
                            pushPairToken(_TokenKind.TokenKind.PROJECT);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.NOT);
                          }
                          break;
                        case '=':
                          if (isTwoCharToken(_TokenKind.TokenKind.EQ)) {
                            pushPairToken(_TokenKind.TokenKind.EQ);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.ASSIGN);
                          }
                          break;
                        case '&':
                          if (!isTwoCharToken(_TokenKind.TokenKind.SYMBOLIC_AND)) {
                            throw {
                              name: 'SpelParseException',
                              message: 'Missing character \'&\' in expression (' + expressionString + ') at position ' + pos
                            };
                          }
                          pushPairToken(_TokenKind.TokenKind.SYMBOLIC_AND);
                          break;
                        case '|':
                          if (!isTwoCharToken(_TokenKind.TokenKind.SYMBOLIC_OR)) {
                            throw {
                              name: 'SpelParseException',
                              message: 'Missing character \'|\' in expression (' + expressionString + ') at position ' + pos
                            };
                          }
                          pushPairToken(_TokenKind.TokenKind.SYMBOLIC_OR);
                          break;
                        case '?':
                          if (isTwoCharToken(_TokenKind.TokenKind.SELECT)) {
                            pushPairToken(_TokenKind.TokenKind.SELECT);
                          } else if (isTwoCharToken(_TokenKind.TokenKind.ELVIS)) {
                            pushPairToken(_TokenKind.TokenKind.ELVIS);
                          } else if (isTwoCharToken(_TokenKind.TokenKind.SAFE_NAVI)) {
                            pushPairToken(_TokenKind.TokenKind.SAFE_NAVI);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.QMARK);
                          }
                          break;
                        case '$':
                          if (isTwoCharToken(_TokenKind.TokenKind.SELECT_LAST)) {
                            pushPairToken(_TokenKind.TokenKind.SELECT_LAST);
                          } else {
                            lexIdentifier();
                          }
                          break;
                        case '>':
                          if (isTwoCharToken(_TokenKind.TokenKind.GE)) {
                            pushPairToken(_TokenKind.TokenKind.GE);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.GT);
                          }
                          break;
                        case '<':
                          if (isTwoCharToken(_TokenKind.TokenKind.LE)) {
                            pushPairToken(_TokenKind.TokenKind.LE);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.LT);
                          }
                          break;
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                          lexNumericLiteral(ch === '0');
                          break;
                        case ' ':
                        case '\t':
                        case '\r':
                        case '\n':
                          // drift over white space
                          pos += 1;
                          break;
                        case '\'':
                          lexQuotedStringLiteral();
                          break;
                        case '"':
                          lexDoubleQuotedStringLiteral();
                          break;
                        case '\0':
                          // hit sentinel at end of value
                          pos += 1; // will take us to the end
                          break;
                        case '\\':
                          throw {
                            name: 'SpelParseException',
                            message: 'Unexpected escape character in expression (' + expressionString + ') at position ' + pos
                          };
                        default:
                          throw {
                            name: 'SpelParseException',
                            message: 'Cannot handle character \'' + ch + '\' in expression (' + expressionString + ') at position ' + pos
                          };
                      }
                    }
                  }
                }
                function lexQuotedStringLiteral() {
                  var start = pos,
                    terminated = false,
                    ch;
                  while (!terminated) {
                    pos += 1;
                    ch = toProcess[pos];
                    if (ch === '\'') {
                      // may not be the end if the char after is also a '
                      if (toProcess[pos + 1] === '\'') {
                        pos += 1; // skip over that too, and continue
                      } else {
                        terminated = true;
                      }
                    }
                    if (ch.charCodeAt(0) === 0) {
                      throw {
                        name: 'SpelParseException',
                        message: 'Non-terminating quoted string in expression (' + expressionString + ') at position ' + pos
                      };
                    }
                  }
                  pos += 1;
                  tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_STRING, subarray(start, pos), start, pos));
                }
                function lexDoubleQuotedStringLiteral() {
                  var start = pos,
                    terminated = false,
                    ch;
                  while (!terminated) {
                    pos += 1;
                    ch = toProcess[pos];
                    if (ch === '"') {
                      // may not be the end if the char after is also a '
                      if (toProcess[pos + 1] === '"') {
                        pos += 1; // skip over that too, and continue
                      } else {
                        terminated = true;
                      }
                    }
                    if (ch.charCodeAt(0) === 0) {
                      throw {
                        name: 'SpelParseException',
                        message: 'Non-terminating double-quoted string in expression (' + expressionString + ') at position ' + pos
                      };
                    }
                  }
                  pos += 1;
                  tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_STRING, subarray(start, pos), start, pos));
                }

                // REAL_LITERAL :
                // ('.' (DECIMAL_DIGIT)+ (EXPONENT_PART)? (REAL_TYPE_SUFFIX)?) |
                // ((DECIMAL_DIGIT)+ '.' (DECIMAL_DIGIT)+ (EXPONENT_PART)? (REAL_TYPE_SUFFIX)?) |
                // ((DECIMAL_DIGIT)+ (EXPONENT_PART) (REAL_TYPE_SUFFIX)?) |
                // ((DECIMAL_DIGIT)+ (REAL_TYPE_SUFFIX));
                // fragment INTEGER_TYPE_SUFFIX : ( 'L' | 'l' );
                // fragment HEX_DIGIT :
                // '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'A'|'B'|'C'|'D'|'E'|'F'|'a'|'b'|'c'|'d'|'e'|'f';
                //
                // fragment EXPONENT_PART : 'e' (SIGN)* (DECIMAL_DIGIT)+ | 'E' (SIGN)*
                // (DECIMAL_DIGIT)+ ;
                // fragment SIGN : '+' | '-' ;
                // fragment REAL_TYPE_SUFFIX : 'F' | 'f' | 'D' | 'd';
                // INTEGER_LITERAL
                // : (DECIMAL_DIGIT)+ (INTEGER_TYPE_SUFFIX)?;

                function lexNumericLiteral(firstCharIsZero) {
                  var isReal = false,
                    start = pos,
                    ch = toProcess[pos + 1],
                    isHex = ch === 'x' || ch === 'X',
                    dotpos,
                    endOfNumber,
                    possibleSign,
                    isFloat;

                  // deal with hexadecimal
                  if (firstCharIsZero && isHex) {
                    pos = pos + 1;
                    do {
                      pos += 1;
                    } while (isHexadecimalDigit(toProcess[pos]));
                    if (isChar('L', 'l')) {
                      pushHexIntToken(subarray(start + 2, pos), true, start, pos);
                      pos += 1;
                    } else {
                      pushHexIntToken(subarray(start + 2, pos), false, start, pos);
                    }
                    return;
                  }

                  // real numbers must have leading digits

                  // Consume first part of number
                  do {
                    pos += 1;
                  } while (isDigit(toProcess[pos]));

                  // a '.' indicates this number is a real
                  ch = toProcess[pos];
                  if (ch === '.') {
                    isReal = true;
                    dotpos = pos;
                    // carry on consuming digits
                    do {
                      pos += 1;
                    } while (isDigit(toProcess[pos]));
                    if (pos === dotpos + 1) {
                      // the number is something like '3.'. It is really an int but may be
                      // part of something like '3.toString()'. In this case process it as
                      // an int and leave the dot as a separate token.
                      pos = dotpos;
                      pushIntToken(subarray(start, pos), false, start, pos);
                      return;
                    }
                  }
                  endOfNumber = pos;

                  // Now there may or may not be an exponent

                  // is it a long ?
                  if (isChar('L', 'l')) {
                    if (isReal) {
                      // 3.4L - not allowed
                      throw {
                        name: 'SpelParseException',
                        message: 'Real cannot be long in expression (' + expressionString + ') at position ' + pos
                      };
                    }
                    pushIntToken(subarray(start, endOfNumber), true, start, endOfNumber);
                    pos += 1;
                  } else if (isExponentChar(toProcess[pos])) {
                    isReal = true; // if it wasn't before, it is now
                    pos += 1;
                    possibleSign = toProcess[pos];
                    if (isSign(possibleSign)) {
                      pos += 1;
                    }

                    // exponent digits
                    do {
                      pos += 1;
                    } while (isDigit(toProcess[pos]));
                    isFloat = false;
                    if (isFloatSuffix(toProcess[pos])) {
                      isFloat = true;
                      pos += 1;
                      endOfNumber = pos;
                    } else if (isDoubleSuffix(toProcess[pos])) {
                      pos += 1;
                      endOfNumber = pos;
                    }
                    pushRealToken(subarray(start, pos), isFloat, start, pos);
                  } else {
                    ch = toProcess[pos];
                    isFloat = false;
                    if (isFloatSuffix(ch)) {
                      isReal = true;
                      isFloat = true;
                      pos += 1;
                      endOfNumber = pos;
                    } else if (isDoubleSuffix(ch)) {
                      isReal = true;
                      pos += 1;
                      endOfNumber = pos;
                    }
                    if (isReal) {
                      pushRealToken(subarray(start, endOfNumber), isFloat, start, endOfNumber);
                    } else {
                      pushIntToken(subarray(start, endOfNumber), false, start, endOfNumber);
                    }
                  }
                }
                function lexIdentifier() {
                  var start = pos,
                    substring,
                    asString,
                    idx;
                  do {
                    pos += 1;
                  } while (isIdentifier(toProcess[pos]));
                  substring = subarray(start, pos);

                  // Check if this is the alternative (textual) representation of an operator (see
                  // alternativeOperatorNames)
                  if (pos - start === 2 || pos - start === 3) {
                    asString = substring.toUpperCase();
                    idx = ALTERNATIVE_OPERATOR_NAMES.indexOf(asString);
                    if (idx >= 0) {
                      pushOneCharOrTwoCharToken(_TokenKind.TokenKind.valueOf(asString), start, substring);
                      return;
                    }
                  }
                  tokens.push(new _Token.Token(_TokenKind.TokenKind.IDENTIFIER, substring.replace('\0', ''), start, pos));
                }
                function pushIntToken(data, isLong, start, end) {
                  if (isLong) {
                    tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_LONG, data, start, end));
                  } else {
                    tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_INT, data, start, end));
                  }
                }
                function pushHexIntToken(data, isLong, start, end) {
                  if (data.length === 0) {
                    if (isLong) {
                      throw {
                        name: 'SpelParseException',
                        message: 'Not a long in expression (' + expressionString + ') at position ' + pos
                      };
                    } else {
                      throw {
                        name: 'SpelParseException',
                        message: 'Not an int in expression (' + expressionString + ') at position ' + pos
                      };
                    }
                  }
                  if (isLong) {
                    tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_HEXLONG, data, start, end));
                  } else {
                    tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_HEXINT, data, start, end));
                  }
                }
                function pushRealToken(data, isFloat, start, end) {
                  if (isFloat) {
                    tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_REAL_FLOAT, data, start, end));
                  } else {
                    tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_REAL, data, start, end));
                  }
                }
                function subarray(start, end) {
                  return toProcess.substring(start, end);
                }

                /**
                 * Check if this might be a two character token.
                 */
                function isTwoCharToken(kind) {
                  if (kind.tokenChars.length === 2 && toProcess[pos] === kind.tokenChars[0]) {
                    return toProcess[pos + 1] === kind.tokenChars[1];
                  }
                  return false;
                }

                /**
                 * Push a token of just one character in length.
                 */
                function pushCharToken(kind) {
                  tokens.push(new _Token.Token(kind, null, pos, pos + 1));
                  pos += 1;
                }

                /**
                 * Push a token of two characters in length.
                 */
                function pushPairToken(kind) {
                  tokens.push(new _Token.Token(kind, null, pos, pos + 2));
                  pos += 2;
                }
                function pushOneCharOrTwoCharToken(kind, pos, data) {
                  tokens.push(new _Token.Token(kind, data, pos, pos + kind.getLength()));
                }

                // ID: ('a'..'z'|'A'..'Z'|'_'|'$') ('a'..'z'|'A'..'Z'|'_'|'$'|'0'..'9'|DOT_ESCAPED)*;
                function isIdentifier(ch) {
                  return isAlphabetic(ch) || isDigit(ch) || ch === '_' || ch === '$';
                }
                function isChar(a, b) {
                  var ch = toProcess[pos];
                  return ch === a || ch === b;
                }
                function isExponentChar(ch) {
                  return ch === 'e' || ch === 'E';
                }
                function isFloatSuffix(ch) {
                  return ch === 'f' || ch === 'F';
                }
                function isDoubleSuffix(ch) {
                  return ch === 'd' || ch === 'D';
                }
                function isSign(ch) {
                  return ch === '+' || ch === '-';
                }
                function isDigit(ch) {
                  if (ch.charCodeAt(0) > 255) {
                    return false;
                  }
                  return (FLAGS[ch.charCodeAt(0)] & IS_DIGIT) !== 0;
                }
                function isAlphabetic(ch) {
                  if (ch.charCodeAt(0) > 255) {
                    return false;
                  }
                  return (FLAGS[ch.charCodeAt(0)] & IS_ALPHA) !== 0;
                }
                function isHexadecimalDigit(ch) {
                  if (ch.charCodeAt(0) > 255) {
                    return false;
                  }
                  return (FLAGS[ch.charCodeAt(0)] & IS_HEXDIGIT) !== 0;
                }
                process();
                return tokens;
              }
              exports.Tokenizer = {
                tokenize: tokenize
              };

              /***/
            }), (/* 7 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.Token = undefined;
              var _TokenKind = __webpack_require__(2);
              function Token(tokenKind, tokenData, startPos, endPos) {
                this.kind = tokenKind;
                this.startPos = startPos;
                this.endPos = endPos;
                if (tokenData) {
                  this.data = tokenData;
                }
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              /**
               * @author Andy Clement
               * @author Ben March
               * @since 0.2.0
               */

              Token.prototype.getKind = function () {
                return this.kind;
              };
              Token.prototype.toString = function () {
                var s = '[';
                s += this.kind.toString();
                if (this.kind.hasPayload()) {
                  s += ':' + this.data;
                }
                s += ']';
                s += '(' + this.startPos + ',' + this.endPos + ')';
                return s;
              };
              Token.prototype.isIdentifier = function () {
                return this.kind === _TokenKind.TokenKind.IDENTIFIER;
              };
              Token.prototype.isNumericRelationalOperator = function () {
                return this.kind === _TokenKind.TokenKind.GT || this.kind === _TokenKind.TokenKind.GE || this.kind === _TokenKind.TokenKind.LT || this.kind === _TokenKind.TokenKind.LE || this.kind === _TokenKind.TokenKind.EQ || this.kind === _TokenKind.TokenKind.NE;
              };
              Token.prototype.stringValue = function () {
                return this.data;
              };
              Token.prototype.asInstanceOfToken = function () {
                return new Token(_TokenKind.TokenKind.INSTANCEOF, this.startPos, this.endPos);
              };
              Token.prototype.asMatchesToken = function () {
                return new Token(_TokenKind.TokenKind.MATCHES, this.startPos, this.endPos);
              };
              Token.prototype.asBetweenToken = function () {
                return new Token(_TokenKind.TokenKind.BETWEEN, this.startPos, this.endPos);
              };
              Token.prototype.getStartPosition = function () {
                return this.startPos;
              };
              Token.prototype.getEndPosition = function () {
                return this.endPos;
              };
              exports.Token = Token;

              /***/
            }), (/* 8 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.BooleanLiteral = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Represents the literal values TRUE and FALSE.
               *
               * @author Andy Clement
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(value, position) {
                var node = _SpelNode.SpelNode.create('boolean', position);
                node.getValue = function () {
                  return value;
                };
                node.setValue = function (newValue) {
                  /*jshint -W093 */
                  return value = newValue;
                  /*jshint +W093 */
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.BooleanLiteral = {
                create: createNode
              };

              /***/
            }), (/* 9 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.NumberLiteral = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Expression language AST node that represents a literal number of any kind (since JavaScript only supports doubles anyway)
               *
               * @author Andy Clement
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(value, position) {
                var node = _SpelNode.SpelNode.create('number', position);
                node.getValue = function () {
                  return value;
                };
                node.setValue = function (newValue) {
                  /*jshint -W093 */
                  return value = newValue;
                  /*jshint +W093 */
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.NumberLiteral = {
                create: createNode
              };

              /***/
            }), (/* 10 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.StringLiteral = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Expression language AST node that represents a string literal.
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(value, position) {
                var node = _SpelNode.SpelNode.create('string', position);
                function stripQuotes(value) {
                  if (value[0] === '\'' && value[value.length - 1] === '\'' || value[0] === '"' && value[value.length - 1] === '"') {
                    value = value.substring(1, value.length - 1);
                  }
                  return value.replace(/''/g, '\'').replace(/""/g, '"');
                }

                //value cannot be null so no check
                value = stripQuotes(value);
                node.getValue = function () {
                  return value;
                };
                node.setValue = function (newValue) {
                  /*jshint -W093 */
                  return value = newValue;
                  /*jshint +W093 */
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.StringLiteral = {
                create: createNode
              };

              /***/
            }), (/* 11 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.NullLiteral = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Expression language AST node that represents null.
               *
               * @author Andy Clement
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(value, position) {
                var node = _SpelNode.SpelNode.create('null', position);
                node.getValue = function () {
                  return null;
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.NullLiteral = {
                create: createNode
              };

              /***/
            }), (/* 12 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.FunctionReference = undefined;
              var _SpelNode = __webpack_require__(0);
              var _Stack = __webpack_require__(1);

              /**
               * A function reference is of the form "#someFunction(a,b,c)". Functions may be defined in
               * the context prior to the expression being evaluated or within the expression itself
               * using a lambda function definition. For example: Lambda function definition in an
               * expression: "(#max = {|x,y|$x>$y?$x:$y};max(2,3))" Calling context defined function:
               * "#isEven(37)". Functions may also be static java methods, registered in the context
               * prior to invocation of the expression.
               *
               * <p>Functions are very simplistic, the arguments are not part of the definition (right
               * now), so the names must be unique.
               *
               * @author Andy Clement
               * @author Ben March
               * @since 0.2.0
               */

              /*
               * Copyright 2002-2015 the original author or authors.
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *      http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */

              function createNode(functionName, position, args) {
                var node = _SpelNode.SpelNode.create('function', position);
                node.getRaw = function () {
                  return {
                    functionName: functionName,
                    args: args
                  };
                };
                node.getValue = function (state) {
                  var locals = state.locals || {},
                    context = state.rootContext,
                    compiledArgs = [];

                  //populate arguments
                  args.forEach(function (arg) {
                    // reset the active context to root context for evaluating argument
                    var currentActiveContext = state.activeContext;
                    state.activeContext = new _Stack.Stack();
                    state.activeContext.push(state.rootContext);

                    // evaluate argument
                    compiledArgs.push(arg.getValue(state));

                    // reset the active context
                    state.activeContext = currentActiveContext;
                  });
                  if (locals[functionName]) {
                    return locals[functionName].apply(context, compiledArgs);
                  }
                  throw {
                    name: 'FunctionDoesNotExistException',
                    message: 'Function \'' + functionName + '\' does not exist.'
                  };
                };
                return node;
              }
              exports.FunctionReference = {
                create: createNode
              };

              /***/
            }), (/* 13 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.MethodReference = undefined;
              var _SpelNode = __webpack_require__(0);
              var _Stack = __webpack_require__(1);

              /**
               * Expression language AST node that represents a method reference.
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Ben March
               * @since 0.2.0
               */

              /*
               * Copyright 2002-2015 the original author or authors.
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *      http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */

              function createNode(nullSafeNavigation, methodName, position, args) {
                var node = _SpelNode.SpelNode.create('method', position);
                node.getRaw = function () {
                  return {
                    methodName: methodName,
                    args: args
                  };
                };
                node.getValue = function (state) {
                  var context = state.activeContext.peek(),
                    compiledArgs = [],
                    method;
                  if (!context) {
                    throw {
                      name: 'ContextDoesNotExistException',
                      message: 'Attempting to look up property \'' + methodName + '\' for an undefined context.'
                    };
                  }

                  //handle safe navigation
                  function maybeHandleNullSafeNavigation(member) {
                    if (member === undefined || member === null) {
                      if (nullSafeNavigation) {
                        return null;
                      }
                      throw {
                        name: 'NullPointerException',
                        message: 'Method ' + methodName + ' does not exist.'
                      };
                    }
                    return member;
                  }

                  //populate arguments
                  args.forEach(function (arg) {
                    // reset the active context to root context for evaluating argument
                    var currentActiveContext = state.activeContext;
                    state.activeContext = new _Stack.Stack();
                    state.activeContext.push(state.rootContext);

                    // evaluate argument
                    compiledArgs.push(arg.getValue(state));

                    // reset the active context
                    state.activeContext = currentActiveContext;
                  });

                  //accessors might not be available
                  if (methodName.substr(0, 3) === 'get' && !context[methodName]) {
                    return maybeHandleNullSafeNavigation(context[methodName.charAt(3).toLowerCase() + methodName.substring(4)]);
                  }
                  if (methodName.substr(0, 3) === 'set' && !context[methodName]) {
                    /*jshint -W093 */
                    return context[methodName.charAt(3).toLowerCase() + methodName.substring(4)] = compiledArgs[0];
                    /*jshint +W093 */
                  }

                  //array methods
                  if (Array.isArray(context)) {
                    //size() -> length
                    if (methodName === 'size') {
                      return context.length;
                    }
                    if (methodName === 'contains') {
                      return context.includes(compiledArgs[0]);
                    }
                  }
                  method = maybeHandleNullSafeNavigation(context[methodName]);
                  if (method) {
                    return method.apply(context, compiledArgs);
                  }
                  return null;
                };
                return node;
              }
              exports.MethodReference = {
                create: createNode
              };

              /***/
            }), (/* 14 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.PropertyReference = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Represents a simple property or field reference.
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Clark Duplichien
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(nullSafeNavigation, propertyName, position) {
                var node = _SpelNode.SpelNode.create('property', position);
                node.getRaw = function () {
                  return propertyName;
                };
                node.getValue = function (state) {
                  var context = state.activeContext.peek();
                  if (!context) {
                    if (nullSafeNavigation) {
                      return null;
                    }
                    throw {
                      name: 'ContextDoesNotExistException',
                      message: 'Attempting to look up property \'' + propertyName + '\' for an undefined context.'
                    };
                  }
                  if (context[propertyName] === undefined || context[propertyName] === null) {
                    //handle safe navigation
                    if (nullSafeNavigation) {
                      return null;
                    }

                    //handle conversion of Java properties to JavaScript properties
                    if (propertyName === 'size' && Array.isArray(context)) {
                      return context.length;
                    }
                    throw {
                      name: 'NullPointerException',
                      message: 'Property \'' + propertyName + '\' does not exist.'
                    };
                  }
                  return context[propertyName];
                };
                node.setValue = function (value, state) {
                  var context = state.activeContext.peek();
                  if (!context) {
                    throw {
                      name: 'ContextDoesNotExistException',
                      message: 'Attempting to assign property \'' + propertyName + '\' for an undefined context.'
                    };
                  }

                  /*jshint -W093 */
                  return context[propertyName] = value;
                  /*jshint +W093 */
                };
                node.getName = function () {
                  return propertyName;
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.PropertyReference = {
                create: createNode
              };

              /***/
            }), (/* 15 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.VariableReference = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Represents a variable reference, eg. #someVar. Note this is different to a *local*
               * variable like $someVar
               *
               * @author Andy Clement
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(variableName, position) {
                var node = _SpelNode.SpelNode.create('variable', position);
                node.getRaw = function () {
                  return variableName;
                };
                node.getValue = function (state) {
                  var context = state.activeContext.peek(),
                    locals = state.locals;
                  if (!context) {
                    throw {
                      name: 'ContextDoesNotExistException',
                      message: 'Attempting to look up variable \'' + variableName + '\' for an undefined context.'
                    };
                  }

                  //there are 2 keywords (root, this) that need to be dealt with
                  if (variableName === 'this') {
                    return context;
                  }
                  if (variableName === 'root') {
                    return state.rootContext;
                  }
                  return locals[variableName];
                };
                node.setValue = function (value, state) {
                  var locals = state.locals;

                  /*jshint -W093 */
                  return locals[variableName] = value;
                  /*jshint +W093 */
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.VariableReference = {
                create: createNode
              };

              /***/
            }), (/* 16 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.CompoundExpression = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Represents a DOT separated expression sequence, such as 'property1.property2.methodOne()'
               *
               * @author Andy Clement
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, expressionComponents) {
                var node = _SpelNode.SpelNode.create.apply(null, ['compound', position].concat(expressionComponents));
                function buildContextStack(state) {
                  var childrenCount = node.getChildren().length,
                    i;
                  for (i = 0; i < childrenCount; i += 1) {
                    if (node.getChildren()[i].getType() === 'indexer') {
                      state.activeContext.push(state.activeContext.peek()[node.getChildren()[i].getValue(state)]);
                    } else {
                      state.activeContext.push(node.getChildren()[i].getValue(state));
                    }
                  }
                  return function unbuildContextStack() {
                    for (i = 0; i < childrenCount; i += 1) {
                      state.activeContext.pop();
                    }
                  };
                }
                node.getValue = function (state) {
                  var context = state.activeContext.peek(),
                    value;
                  if (!context) {
                    throw {
                      name: 'ContextDoesNotExistException',
                      message: 'Attempting to evaluate compound expression with an undefined context.'
                    };
                  }
                  var unbuildContextStack = buildContextStack(state);
                  value = state.activeContext.peek();
                  unbuildContextStack();
                  return value;
                };
                node.setValue = function (value, state) {
                  var unbuildContextStack = buildContextStack(state),
                    childCount = node.getChildren().length;
                  state.activeContext.pop();
                  value = node.getChildren()[childCount - 1].setValue(value, state);
                  state.activeContext.push(null);
                  unbuildContextStack();
                  return value;
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.CompoundExpression = {
                create: createNode
              };

              /***/
            }), (/* 17 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.Indexer = undefined;
              var _SpelNode = __webpack_require__(0);
              var _Stack = __webpack_require__(1);

              /**
               * An Indexer can index into some proceeding structure to access a particular piece of it.
               * Supported structures are: strings / collections (lists/sets) / arrays.
               *
               * @author Andy Clement
               * @author Phillip Webb
               * @author Stephane Nicoll
               * @author Ben March
               * @since 0.2.0
               */

              /*
               * Copyright 2002-2015 the original author or authors.
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *      http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */

              function createNode(position, expressionComponents) {
                var node = _SpelNode.SpelNode.create.apply(null, ['indexer', position].concat(expressionComponents));
                node.getValue = function (state) {
                  var activeContext = state.activeContext,
                    context,
                    childrenCount = node.getChildren().length,
                    i,
                    value;
                  state.activeContext = new _Stack.Stack();
                  state.activeContext.push(state.rootContext);
                  context = state.activeContext.peek();
                  if (!context) {
                    throw {
                      name: 'ContextDoesNotExistException',
                      message: 'Attempting to evaluate compound expression with an undefined context.'
                    };
                  }
                  for (i = 0; i < childrenCount; i += 1) {
                    state.activeContext.push(node.getChildren()[i].getValue(state));
                  }
                  value = state.activeContext.peek();
                  for (i = 0; i < childrenCount; i += 1) {
                    state.activeContext.pop();
                  }
                  state.activeContext = activeContext;
                  return value;
                };

                //node.setContext(node.getValue());

                return node;
              }
              exports.Indexer = {
                create: createNode
              };

              /***/
            }), (/* 18 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.Assign = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Represents assignment. An alternative to calling setValue() for an expression is to use
               * an assign.
               *
               * <p>Example: 'someNumberProperty=42'
               *
               * @author Andy Clement
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, property, assignedValue) {
                var node = _SpelNode.SpelNode.create('assign', position, property, assignedValue);
                node.getValue = function (state) {
                  var context = state.activeContext.peek();
                  if (!context) {
                    throw {
                      name: 'ContextDoesNotExistException',
                      message: 'Attempting to assign property \'' + property.getValue(state) + '\' for an undefined context.'
                    };
                  }
                  return property.setValue(assignedValue.getValue(state), state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.Assign = {
                create: createNode
              };

              /***/
            }), (/* 19 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpEQ = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Implements the equality operator.
               *
               * @author Andy Clement
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('op-eq', position, left, right);
                node.getValue = function (state) {
                  return left.getValue(state) === right.getValue(state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpEQ = {
                create: createNode
              };

              /***/
            }), (/* 20 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpNE = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Implements the not-equal operator.
               *
               * @author Andy Clement
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('op-ne', position, left, right);
                node.getValue = function (state) {
                  return left.getValue(state) !== right.getValue(state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpNE = {
                create: createNode
              };

              /***/
            }), (/* 21 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpGE = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Implements greater-than-or-equal operator.
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Giovanni Dall'Oglio Risso
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('op-ge', position, left, right);
                node.getValue = function (state) {
                  return left.getValue(state) >= right.getValue(state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpGE = {
                create: createNode
              };

              /***/
            }), (/* 22 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpGT = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Implements the greater-than operator.
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Giovanni Dall'Oglio Risso
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('op-gt', position, left, right);
                node.getValue = function (state) {
                  return left.getValue(state) > right.getValue(state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpGT = {
                create: createNode
              };

              /***/
            }), (/* 23 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpLE = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Implements the less-than-or-equal operator.
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Giovanni Dall'Oglio Risso
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('op-le', position, left, right);
                node.getValue = function (state) {
                  return left.getValue(state) <= right.getValue(state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpLE = {
                create: createNode
              };

              /***/
            }), (/* 24 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpLT = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Implements the less-than operator.
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Giovanni Dall'Oglio Risso
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('op-lt', position, left, right);
                node.getValue = function (state) {
                  return left.getValue(state) < right.getValue(state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpLT = {
                create: createNode
              };

              /***/
            }), (/* 25 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpPlus = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * The plus operator will:
               * <ul>
               * <li>add numbers
               * <li>concatenate strings
               * </ul>
               *
               * <p>It can be used as a unary operator for numbers.
               * The standard promotions are performed when the operand types vary (double+int=double).
               * For other options it defers to the registered overloader.
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Ivo Smid
               * @author Giovanni Dall'Oglio Risso
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('op-plus', position, left, right);
                node.getValue = function (state) {
                  if (!right) {
                    return +left.getValue(state);
                  }
                  //javascript will handle string concatenation or addition depending on types
                  return left.getValue(state) + right.getValue(state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpPlus = {
                create: createNode
              };

              /***/
            }), (/* 26 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpMinus = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * The minus operator supports:
               * <ul>
               * <li>subtraction of numbers
               * <li>subtraction of an int from a string of one character
               * (effectively decreasing that character), so 'd'-3='a'
               * </ul>
               *
               * <p>It can be used as a unary operator for numbers.
               * The standard promotions are performed when the operand types vary (double-int=double).
               * For other options it defers to the registered overloader.
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Giovanni Dall'Oglio Risso
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('op-minus', position, left, right);
                node.getValue = function (state) {
                  if (!right) {
                    return -left.getValue(state);
                  }
                  return left.getValue(state) - right.getValue(state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpMinus = {
                create: createNode
              };

              /***/
            }), (/* 27 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpMultiply = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Implements the {@code multiply} operator.
               *
               * <p>Conversions and promotions are handled as defined in
               * <a href="http://java.sun.com/docs/books/jls/third_edition/html/conversions.html">Section 5.6.2 of the
               * Java Language Specification</a>, with the addiction of {@code BigDecimal}/{@code BigInteger} management:
               *
               * <p>If any of the operands is of a reference type, unboxing conversion (Section 5.1.8)
               * is performed. Then:<br>
               * If either operand is of type {@code BigDecimal}, the other is converted to {@code BigDecimal}.<br>
               * If either operand is of type double, the other is converted to double.<br>
               * Otherwise, if either operand is of type float, the other is converted to float.<br>
               * If either operand is of type {@code BigInteger}, the other is converted to {@code BigInteger}.<br>
               * Otherwise, if either operand is of type long, the other is converted to long.<br>
               * Otherwise, both operands are converted to type int.
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Sam Brannen
               * @author Giovanni Dall'Oglio Risso
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('op-multiply', position, left, right);
                node.getValue = function (state) {
                  var leftValue = left.getValue(state),
                    rightValue = right.getValue(state);
                  if (typeof leftValue === 'number' && typeof rightValue === 'number') {
                    return leftValue * rightValue;
                  }

                  //repeats (ex. 'abc' * 2 = 'abcabc')
                  if (typeof leftValue === 'string' && typeof rightValue === 'number') {
                    var s = '',
                      i = 0;
                    for (; i < rightValue; i += 1) {
                      s += leftValue;
                    }
                    return s;
                  }
                  return null;
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpMultiply = {
                create: createNode
              };

              /***/
            }), (/* 28 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpDivide = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Implements division operator.
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Giovanni Dall'Oglio Risso
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('op-divide', position, left, right);
                node.getValue = function (state) {
                  return left.getValue(state) / right.getValue(state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpDivide = {
                create: createNode
              };

              /***/
            }), (/* 29 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpModulus = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Implements the modulus operator.
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Giovanni Dall'Oglio Risso
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('op-modulus', position, left, right);
                node.getValue = function (state) {
                  return left.getValue(state) % right.getValue(state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpModulus = {
                create: createNode
              };

              /***/
            }), (/* 30 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpPower = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * The power operator.
               *
               * @author Andy Clement
               * @author Giovanni Dall'Oglio Risso
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, base, exp) {
                var node = _SpelNode.SpelNode.create('op-power', position, base, exp);
                node.getValue = function (state) {
                  return Math.pow(base.getValue(state), exp.getValue(state));
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpPower = {
                create: createNode
              };

              /***/
            }), (/* 31 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpInc = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Increment operator. Can be used in a prefix or postfix form. This will throw
               * appropriate exceptions if the operand in question does not support increment.
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Giovanni Dall'Oglio Risso
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, postfix, int) {
                var node = _SpelNode.SpelNode.create('op-inc', position, int);
                node.getValue = function (state) {
                  var cur = int.getValue(state);
                  int.setValue(cur + 1, state);
                  if (postfix) {
                    return cur;
                  }
                  return cur + 1;
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpInc = {
                create: createNode
              };

              /***/
            }), (/* 32 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpDec = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Decrement operator.  Can be used in a prefix or postfix form. This will throw
               * appropriate exceptions if the operand in question does not support decrement.
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Giovanni Dall'Oglio Risso
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, postfix, int) {
                var node = _SpelNode.SpelNode.create('op-dec', position, int);
                node.getValue = function (state) {
                  var cur = int.getValue(state);
                  int.setValue(cur - 1, state);
                  if (postfix) {
                    return cur;
                  }
                  return cur - 1;
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpDec = {
                create: createNode
              };

              /***/
            }), (/* 33 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpNot = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Represents a NOT operation.
               *
               * @author Andy Clement
               * @author Mark Fisher
               * @author Oliver Becker
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, expr) {
                var node = _SpelNode.SpelNode.create('op-not', position, expr);
                node.getValue = function (state) {
                  return !expr.getValue(state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpNot = {
                create: createNode
              };

              /***/
            }), (/* 34 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpAnd = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Represents the boolean AND operation.
               *
               * @author Andy Clement
               * @author Mark Fisher
               * @author Oliver Becker
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('op-and', position, left, right);
                node.getValue = function (state) {
                  //double bang for javascript
                  return !!left.getValue(state) && !!right.getValue(state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpAnd = {
                create: createNode
              };

              /***/
            }), (/* 35 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpOr = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Represents the boolean OR operation.
               *
               * @author Andy Clement
               * @author Mark Fisher
               * @author Oliver Becker
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('op-or', position, left, right);
                node.getValue = function (state) {
                  //double bang for javascript
                  return !!left.getValue(state) || !!right.getValue(state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpOr = {
                create: createNode
              };

              /***/
            }), (/* 36 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpMatches = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Implements the matches operator. Matches takes two operands:
               * The first is a String and the second is a Java regex.
               * It will return {@code true} when {@link #getValue} is called
               * if the first operand matches the regex.
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Chris Thielen
               * @since 3.0
               */
              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('matches', position, left, right);

                /**
                 * Check the first operand matches the regex specified as the second operand.
                 * @param state the expression state
                 * @return {@code true} if the first operand matches the regex specified as the
                 * second operand, otherwise {@code false}
                 * @throws EvaluationException if there is a problem evaluating the expression
                 * (e.g. the regex is invalid)
                 */
                node.getValue = function (state) {
                  var data = left.getValue(state);
                  var regexpString = right.getValue(state);
                  try {
                    var regexp = new RegExp(regexpString);
                    return !!regexp.exec(data);
                  } catch (error) {
                    throw {
                      name: 'EvaluationException',
                      message: error.toString()
                    };
                  }
                };
                return node;
              } /*
                 * Copyright 2002-2019 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      https://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpMatches = {
                create: createNode
              };

              /***/
            }), (/* 37 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.Ternary = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Represents a ternary expression, for example: "someCheck()?true:false".
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, expression, ifTrue, ifFalse) {
                var node = _SpelNode.SpelNode.create('ternary', position, expression, ifTrue, ifFalse);
                node.getValue = function (state) {
                  return expression.getValue(state) ? ifTrue.getValue(state) : ifFalse.getValue(state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.Ternary = {
                create: createNode
              };

              /***/
            }), (/* 38 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.Elvis = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Represents the elvis operator ?:. For an expression "a?:b" if a is not null, the value
               * of the expression is "a", if a is null then the value of the expression is "b".
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, expression, ifFalse) {
                var node = _SpelNode.SpelNode.create('elvis', position, expression, ifFalse);
                node.getValue = function (state) {
                  return expression.getValue(state) !== null ? expression.getValue(state) : ifFalse.getValue(state);
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.Elvis = {
                create: createNode
              };

              /***/
            }), (/* 39 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.InlineList = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Represent a list in an expression, e.g. '{1,2,3}'
               *
               * @author Andy Clement
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, elements) {
                var node = _SpelNode.SpelNode.create('list', position),
                  list = [].concat(elements || []);
                node.getRaw = function () {
                  return list;
                };
                node.getValue = function (state) {
                  return list.map(function (element) {
                    return element.getValue(state);
                  });
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.InlineList = {
                create: createNode
              };

              /***/
            }), (/* 40 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.InlineMap = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Represent a map in an expression, e.g. '{name:'foo',age:12}'
               *
               * @author Andy Clement
               * @author Ben March
               * @since 0.2.0
               */

              function createNode(position, elements) {
                var node = _SpelNode.SpelNode.create('map', position),
                  mapPieces = [].concat(elements || []);
                node.getValue = function (state) {
                  var key = true,
                    keyValue = null,
                    map = {};
                  mapPieces.forEach(function (piece) {
                    if (key) {
                      //unquoted property names come as type "property" but should be treated as strings
                      if (piece.getType() === 'property') {
                        keyValue = piece.getName();
                      } else {
                        keyValue = piece.getValue(state);
                      }
                    } else {
                      map[keyValue] = piece.getValue(state);
                    }
                    key = !key;
                  });
                  return map;
                };
                return node;
              } /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.InlineMap = {
                create: createNode
              };

              /***/
            }), (/* 41 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.Selection = undefined;
              var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                return typeof obj;
              } : function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              }; /*
                  * Copyright 2002-2015 the original author or authors.
                  *
                  * Licensed under the Apache License, Version 2.0 (the "License");
                  * you may not use this file except in compliance with the License.
                  * You may obtain a copy of the License at
                  *
                  *      http://www.apache.org/licenses/LICENSE-2.0
                  *
                  * Unless required by applicable law or agreed to in writing, software
                  * distributed under the License is distributed on an "AS IS" BASIS,
                  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                  * See the License for the specific language governing permissions and
                  * limitations under the License.
                  */

              var _SpelNode = __webpack_require__(0);

              /**
               * Represents selection over a map or collection.
               * For example: {1,2,3,4,5,6,7,8,9,10}.?{#isEven(#this) == 'y'} returns [2, 4, 6, 8, 10]
               *
               * <p>Basically a subset of the input data is returned based on the
               * evaluation of the expression supplied as selection criteria.
               *
               * @author Andy Clement
               * @author Mark Fisher
               * @author Sam Brannen
               * @author Ben March
               * @since 0.2.0
               */

              function matches(element, expr, state) {
                var doesMatch = false;
                state.activeContext.push(element);
                doesMatch = expr.getValue(state);
                state.activeContext.pop();
                return doesMatch;
              }
              function selectFromArray(collection, whichElement, expr, state) {
                var newCollection = collection.filter(function (element) {
                  return matches(element, expr, state);
                });
                switch (whichElement) {
                  case 'ALL':
                    return newCollection;
                  case 'FIRST':
                    return newCollection[0] || null;
                  case 'LAST':
                    if (newCollection.length) {
                      return newCollection[newCollection.length - 1];
                    }
                    return null;
                }
              }
              function selectFromMap(collection, whichElement, expr, state) {
                var newCollection = {},
                  entry,
                  key,
                  entries = [],
                  returnValue = {};
                for (key in collection) {
                  if (collection.hasOwnProperty(key)) {
                    entry = {
                      key: key,
                      value: collection[key]
                    };
                    if (matches(entry, expr, state)) {
                      entries.push(entry);
                    }
                  }
                }
                switch (whichElement) {
                  case 'ALL':
                    entries.forEach(function (entry) {
                      newCollection[entry.key] = entry.value;
                    });
                    return newCollection;
                  case 'FIRST':
                    if (entries.length) {
                      returnValue[entries[0].key] = entries[0].value;
                      return returnValue;
                    }
                    return null;
                  case 'LAST':
                    if (entries.length) {
                      returnValue[entries[entries.length - 1].key] = entries[entries.length - 1].value;
                      return returnValue;
                    }
                    return null;
                }
                entries.forEach(function (entry) {
                  newCollection[entry.key] = entry.value;
                });
              }
              function createNode(nullSafeNavigation, whichElement, position, expr) {
                var node = _SpelNode.SpelNode.create('selection', position, expr);
                node.getValue = function (state) {
                  var collection = state.activeContext.peek();
                  if (collection) {
                    if (Array.isArray(collection)) {
                      return selectFromArray(collection, whichElement, expr, state);
                    } else if ((typeof collection === 'undefined' ? 'undefined' : _typeof(collection)) === 'object') {
                      return selectFromMap(collection, whichElement, expr, state);
                    }
                  }
                  return null;
                };
                return node;
              }
              exports.Selection = {
                create: createNode,
                FIRST: 'FIRST',
                LAST: 'LAST',
                ALL: 'ALL'
              };

              /***/
            }), (/* 42 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.Projection = undefined;
              var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                return typeof obj;
              } : function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              }; /*
                  * Copyright 2002-2015 the original author or authors.
                  *
                  * Licensed under the Apache License, Version 2.0 (the "License");
                  * you may not use this file except in compliance with the License.
                  * You may obtain a copy of the License at
                  *
                  *      http://www.apache.org/licenses/LICENSE-2.0
                  *
                  * Unless required by applicable law or agreed to in writing, software
                  * distributed under the License is distributed on an "AS IS" BASIS,
                  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                  * See the License for the specific language governing permissions and
                  * limitations under the License.
                  */

              var _SpelNode = __webpack_require__(0);

              /**
               * Represents projection, where a given operation is performed on all elements in some
               * input sequence, returning a new sequence of the same size. For example:
               * "{1,2,3,4,5,6,7,8,9,10}.!{#isEven(#this)}" returns "[n, y, n, y, n, y, n, y, n, y]"
               *
               * @author Andy Clement
               * @author Mark Fisher
               * @author Ben March
               * @since 0.2.0
               */

              function projectCollection(collection, expr, state) {
                return collection.map(function (element) {
                  var matches;
                  state.activeContext.push(element);
                  matches = expr.getValue(state);
                  state.activeContext.pop();
                  return matches;
                });
              }
              function createNode(nullSafeNavigation, position, expr) {
                var node = _SpelNode.SpelNode.create('projection', position, expr);
                node.getValue = function (state) {
                  var collection = state.activeContext.peek(),
                    entries = [],
                    key;
                  if (Array.isArray(collection)) {
                    return projectCollection(collection, expr, state);
                  } else if ((typeof collection === 'undefined' ? 'undefined' : _typeof(collection)) === 'object') {
                    for (key in collection) {
                      if (collection.hasOwnProperty(key)) {
                        entries.push(collection[key]);
                      }
                    }
                    return projectCollection(entries, expr, state);
                  }
                  return null;
                };
                return node;
              }
              exports.Projection = {
                create: createNode
              };

              /***/
            }), (/* 43 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpInstanceof = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * The operator 'instanceof' checks if an object is of the class specified in the right
               * hand operand, in the same way that {@code instanceof} does in Java.
               *
               * THIS OPERATOR IS NOT IMPLEMENTED AND WILL THROW AN EXCEPTION
               *
               * @author Andy Clement
               * @since 3.0
               */
              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('instanceof', position, left, right);

                /**
                 * Compare the left operand to see it is an instance of the type specified as the
                 * right operand. The right operand must be a class.
                 * @param state the expression state
                 * @return {@code true} if the left operand is an instanceof of the right operand,
                 * otherwise {@code false}
                 * @throws EvaluationException if there is a problem evaluating the expression
                 */
                node.getValue = function (state) {
                  throw {
                    name: 'MethodNotImplementedException',
                    message: 'OpInstanceOf: Not implemented'
                  };
                };
                return node;
              } /*
                 * Copyright 2002-2019 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      https://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpInstanceof = {
                create: createNode
              };

              /***/
            }), (/* 44 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.OpBetween = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Represents the between operator. The left operand to between must be a single value and
               * the right operand must be a list - this operator returns true if the left operand is
               * between (using the registered comparator) the two elements in the list. The definition
               * of between being inclusive follows the SQL BETWEEN definition.
               *
               * @author Andy Clement
               * @since 3.0
               */
              function createNode(position, left, right) {
                var node = _SpelNode.SpelNode.create('between', position, left, right);

                /**
                 * Returns a boolean based on whether a value is in the range expressed. The first
                 * operand is any value whilst the second is a list of two values - those two values
                 * being the bounds allowed for the first operand (inclusive).
                 * @param state the expression state
                 * @return true if the left operand is in the range specified, false otherwise
                 * @throws EvaluationException if there is a problem evaluating the expression
                 */
                node.getValue = function (state) {
                  throw {
                    name: 'MethodNotImplementedException',
                    message: 'OpBetween: Not implemented'
                  };
                };
                return node;
              } /*
                 * Copyright 2002-2019 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      https://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.OpBetween = {
                create: createNode
              };

              /***/
            }), (/* 45 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.TypeReference = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Represents a reference to a type, for example
               * {@code "T(String)" or "T(com.somewhere.Foo)"}.
               *
               * @author Andy Clement
               */
              function createNode(position, node, _dims) {
                var node = _SpelNode.SpelNode.create('typeref', position, node);
                node.getValue = function (state) {
                  throw {
                    name: 'MethodNotImplementedException',
                    message: 'TypeReference: Not implemented'
                  };
                };
                return node;
              } /*
                 * Copyright 2002-2019 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      https://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.TypeReference = {
                create: createNode
              };

              /***/
            }), (/* 46 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.BeanReference = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * Represents a bean reference to a type, for example <tt>@foo</tt> or <tt>@'foo.bar'</tt>.
               * For a FactoryBean the syntax <tt>&foo</tt> can be used to access the factory itself.
               *
               * @author Andy Clement
               */
              function createNode(position, beanName) {
                var node = _SpelNode.SpelNode.create('beanref', position);
                node.getValue = function (state) {
                  throw {
                    name: 'MethodNotImplementedException',
                    message: 'BeanReference: Not implemented'
                  };
                };
                return node;
              } /*
                 * Copyright 2002-2019 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      https://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.BeanReference = {
                create: createNode
              };

              /***/
            }), (/* 47 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.Identifier = undefined;
              var _SpelNode = __webpack_require__(0);

              /**
               * An 'identifier' {@link SpelNode}.
               *
               * @author Andy Clement
               * @since 3.0
               */
              function createNode(identifierName, position) {
                var node = _SpelNode.SpelNode.create('identifier', position);
                node.getRaw = function () {
                  return identifierName;
                };
                node.getValue = function (state) {
                  throw {
                    name: 'MethodNotImplementedException',
                    message: 'Identifier: Not implemented'
                  };
                };
                return node;
              } /*
                 * Copyright 2002-2019 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      https://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              exports.Identifier = {
                create: createNode
              };

              /***/
            }), (/* 48 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.QualifiedIdentifier = undefined;
              var _SpelNode = __webpack_require__(0);
              function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                  for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                } else {
                  return Array.from(arr);
                }
              } /*
                 * Copyright 2002-2019 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      https://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              /**
               * Represents a dot separated sequence of strings that indicate a package qualified type
               * reference.
               *
               * <p>Example: "java.lang.String" as in the expression "new java.lang.String('hello')"
               *
               * @author Andy Clement
               * @since 3.0
               */
              function createNode(position, pieces) {
                var node = _SpelNode.SpelNode.create.apply(_SpelNode.SpelNode, ['qualifiedidentifier', position].concat(_toConsumableArray(pieces)));
                node.getRaw = function () {
                  return pieces.map(function (p) {
                    return p.getRaw();
                  });
                };
                node.getValue = function (state) {
                  throw {
                    name: 'MethodNotImplementedException',
                    message: 'QualifiedIdentifier: Not implemented'
                  };
                };
                return node;
              }
              exports.QualifiedIdentifier = {
                create: createNode
              };

              /***/
            }), (/* 49 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.ConstructorReference = undefined;
              var _SpelNode = __webpack_require__(0);
              var _Stack = __webpack_require__(1);
              function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                  for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                } else {
                  return Array.from(arr);
                }
              }
              function _toArray(arr) {
                return Array.isArray(arr) ? arr : Array.from(arr);
              } /*
                 * Copyright 2002-2019 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      https://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

              /**
               * Represents the invocation of a constructor. Either a constructor on a regular type or
               * construction of an array. When an array is constructed, an initializer can be specified.
               *
               * <p>Examples:<br>
               * new String('hello world')<br>
               * new int[]{1,2,3,4}<br>
               * new int[3] new int[3]{1,2,3}
               *
               * @author Andy Clement
               * @author Juergen Hoeller
               * @since 3.0
               */
              function createNode(position, dimensions, nodes) {
                var isArray = nodes !== undefined;
                var dimension;
                if (isArray) {
                  dimension = dimensions.length && dimensions[0] && dimensions[0].getType() === 'number' ? dimensions[0].getValue() : null;
                } else {
                  nodes = dimensions;
                  dimensions = undefined;
                }
                var _nodes = nodes,
                  _nodes2 = _toArray(_nodes);
                _nodes2[0];
                var args = _nodes2.slice(1);
                var node = _SpelNode.SpelNode.create.apply(_SpelNode.SpelNode, ['constructorref', position].concat(_toConsumableArray(nodes)));
                node.getRaw = function () {
                  return dimension;
                };
                node.getValue = function (state) {
                  if (isArray && args.length <= 1) {
                    var compiledArgs = [];

                    //populate arguments
                    args.forEach(function (arg) {
                      // reset the active context to root context for evaluating argument
                      var currentActiveContext = state.activeContext;
                      state.activeContext = new _Stack.Stack();
                      state.activeContext.push(state.rootContext);

                      // evaluate argument
                      compiledArgs.push(arg.getValue(state));

                      // reset the active context
                      state.activeContext = currentActiveContext;
                    });
                    if (args.length === 1) {
                      return compiledArgs[0];
                    } else {
                      return dimension ? new Array(dimension) : [];
                    }
                  }
                  throw {
                    name: 'MethodNotImplementedException',
                    message: 'ConstructorReference: Not implemented'
                  };
                };
                return node;
              }
              exports.ConstructorReference = {
                create: createNode
              };

              /***/
            }), (/* 50 */
            /***/function (module, exports, __webpack_require__) {
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              /*
               * Copyright 2002-2015 the original author or authors.
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *      http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */

              /**
               * @author Ben March
               * @since 0.2.0
               */

              function create(authentication, principal) {
                var context = {};
                context.authentication = authentication || {};
                context.principal = principal || {};
                context.hasRole = function (role) {
                  var hasRole = false;
                  if (!role) {
                    return false;
                  }
                  if (!context.authentication && !Array.isArray(context.authentication.authorities)) {
                    return false;
                  }
                  context.authentication.authorities.forEach(function (grantedAuthority) {
                    if (grantedAuthority.authority.toLowerCase() === role.toLowerCase()) {
                      hasRole = true;
                    }
                  });
                  return hasRole;
                };
                context.hasPermission = function () /*variable arguments*/{
                  var args = Array.prototype.slice.call(arguments);
                  if (args.length === 1) {
                    return context.hasRole(args[0]);
                  }
                };
                return context;
              }
              exports.StandardContext = {
                create: create
              };

              /***/
            }
            /******/)]);
          });
        })(spel2js);
        var spel2jsExports = spel2js.exports;
        var SqlString$1 = {};
        (function (exports) {
          var SqlString = exports;
          var ID_GLOBAL_REGEXP = /`/g;
          var QUAL_GLOBAL_REGEXP = /\./g;
          var CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g; // eslint-disable-line no-control-regex
          var CHARS_ESCAPE_MAP = {
            '\0': '\\0',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\r': '\\r',
            '\x1a': '\\Z',
            '"': '\\"',
            '\'': '\\\'',
            '\\': '\\\\'
          };
          SqlString.escapeId = function escapeId(val, forbidQualified) {
            if (Array.isArray(val)) {
              var sql = '';
              for (var i = 0; i < val.length; i++) {
                sql += (i === 0 ? '' : ', ') + SqlString.escapeId(val[i], forbidQualified);
              }
              return sql;
            } else if (forbidQualified) {
              return '`' + String(val).replace(ID_GLOBAL_REGEXP, '``') + '`';
            } else {
              return '`' + String(val).replace(ID_GLOBAL_REGEXP, '``').replace(QUAL_GLOBAL_REGEXP, '`.`') + '`';
            }
          };
          SqlString.escape = function escape(val, stringifyObjects, timeZone) {
            if (val === undefined || val === null) {
              return 'NULL';
            }
            switch (typeof val) {
              case 'boolean':
                return val ? 'true' : 'false';
              case 'number':
                return val + '';
              case 'object':
                if (Object.prototype.toString.call(val) === '[object Date]') {
                  return SqlString.dateToString(val, timeZone || 'local');
                } else if (Array.isArray(val)) {
                  return SqlString.arrayToList(val, timeZone);
                } else if (Buffer.isBuffer(val)) {
                  return SqlString.bufferToString(val);
                } else if (typeof val.toSqlString === 'function') {
                  return String(val.toSqlString());
                } else if (stringifyObjects) {
                  return escapeString(val.toString());
                } else {
                  return SqlString.objectToValues(val, timeZone);
                }
              default:
                return escapeString(val);
            }
          };
          SqlString.arrayToList = function arrayToList(array, timeZone) {
            var sql = '';
            for (var i = 0; i < array.length; i++) {
              var val = array[i];
              if (Array.isArray(val)) {
                sql += (i === 0 ? '' : ', ') + '(' + SqlString.arrayToList(val, timeZone) + ')';
              } else {
                sql += (i === 0 ? '' : ', ') + SqlString.escape(val, true, timeZone);
              }
            }
            return sql;
          };
          SqlString.format = function format(sql, values, stringifyObjects, timeZone) {
            if (values == null) {
              return sql;
            }
            if (!Array.isArray(values)) {
              values = [values];
            }
            var chunkIndex = 0;
            var placeholdersRegex = /\?+/g;
            var result = '';
            var valuesIndex = 0;
            var match;
            while (valuesIndex < values.length && (match = placeholdersRegex.exec(sql))) {
              var len = match[0].length;
              if (len > 2) {
                continue;
              }
              var value = len === 2 ? SqlString.escapeId(values[valuesIndex]) : SqlString.escape(values[valuesIndex], stringifyObjects, timeZone);
              result += sql.slice(chunkIndex, match.index) + value;
              chunkIndex = placeholdersRegex.lastIndex;
              valuesIndex++;
            }
            if (chunkIndex === 0) {
              // Nothing was replaced
              return sql;
            }
            if (chunkIndex < sql.length) {
              return result + sql.slice(chunkIndex);
            }
            return result;
          };
          SqlString.dateToString = function dateToString(date, timeZone) {
            var dt = new Date(date);
            if (isNaN(dt.getTime())) {
              return 'NULL';
            }
            var year;
            var month;
            var day;
            var hour;
            var minute;
            var second;
            var millisecond;
            if (timeZone === 'local') {
              year = dt.getFullYear();
              month = dt.getMonth() + 1;
              day = dt.getDate();
              hour = dt.getHours();
              minute = dt.getMinutes();
              second = dt.getSeconds();
              millisecond = dt.getMilliseconds();
            } else {
              var tz = convertTimezone(timeZone);
              if (tz !== false && tz !== 0) {
                dt.setTime(dt.getTime() + tz * 60000);
              }
              year = dt.getUTCFullYear();
              month = dt.getUTCMonth() + 1;
              day = dt.getUTCDate();
              hour = dt.getUTCHours();
              minute = dt.getUTCMinutes();
              second = dt.getUTCSeconds();
              millisecond = dt.getUTCMilliseconds();
            }

            // YYYY-MM-DD HH:mm:ss.mmm
            var str = zeroPad(year, 4) + '-' + zeroPad(month, 2) + '-' + zeroPad(day, 2) + ' ' + zeroPad(hour, 2) + ':' + zeroPad(minute, 2) + ':' + zeroPad(second, 2) + '.' + zeroPad(millisecond, 3);
            return escapeString(str);
          };
          SqlString.bufferToString = function bufferToString(buffer) {
            return 'X' + escapeString(buffer.toString('hex'));
          };
          SqlString.objectToValues = function objectToValues(object, timeZone) {
            var sql = '';
            for (var key in object) {
              var val = object[key];
              if (typeof val === 'function') {
                continue;
              }
              sql += (sql.length === 0 ? '' : ', ') + SqlString.escapeId(key) + ' = ' + SqlString.escape(val, true, timeZone);
            }
            return sql;
          };
          SqlString.raw = function raw(sql) {
            if (typeof sql !== 'string') {
              throw new TypeError('argument sql must be a string');
            }
            return {
              toSqlString: function toSqlString() {
                return sql;
              }
            };
          };
          function escapeString(val) {
            var chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
            var escapedVal = '';
            var match;
            while (match = CHARS_GLOBAL_REGEXP.exec(val)) {
              escapedVal += val.slice(chunkIndex, match.index) + CHARS_ESCAPE_MAP[match[0]];
              chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
            }
            if (chunkIndex === 0) {
              // Nothing was escaped
              return "'" + val + "'";
            }
            if (chunkIndex < val.length) {
              return "'" + escapedVal + val.slice(chunkIndex) + "'";
            }
            return "'" + escapedVal + "'";
          }
          function zeroPad(number, length) {
            number = number.toString();
            while (number.length < length) {
              number = '0' + number;
            }
            return number;
          }
          function convertTimezone(tz) {
            if (tz === 'Z') {
              return 0;
            }
            var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
            if (m) {
              return (m[1] === '-' ? -1 : 1) * (parseInt(m[2], 10) + (m[3] ? parseInt(m[3], 10) : 0) / 60) * 60;
            }
            return false;
          }
        })(SqlString$1);
        var sqlstring = SqlString$1;
        const SqlStringOrig = /*@__PURE__*/getDefaultExportFromCjs(sqlstring);
        var SqlString = SqlStringOrig;
        SqlString.trim = function (val) {
          if (val.charAt(0) == "'") return val.substring(1, val.length - 1);else return val;
        };
        SqlString.escapeLike = function (val) {
          var any_start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var any_end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          // normal escape
          var res = SqlString.escape(val);
          // unwrap ''
          res = SqlString.trim(res);
          // escape % and _
          res = res.replace(/[%_]/g, "\\$&");
          // wrap with % for LIKE
          res = (any_start ? "%" : "") + res + (any_end ? "%" : "");
          // wrap ''
          res = "'" + res + "'";
          return res;
        };
        var sqlEmptyValue = function sqlEmptyValue(fieldDef) {
          var v = "''";
          var type = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.type;
          if (type == "date") {
            //todo: support other SQL dialects?  0001-01-01 for oracle, 1970-01-01 for timestamp
            v = "'0000-00-00'";
          } else if (type == "datetime") {
            v = "'0000-00-00 00:00'";
          } else if (type == "time") {
            v = "'00:00'";
          } else if (type == "number") {
            v = "0";
          }
          return v;
        };
        var mongoEmptyValue = function mongoEmptyValue(fieldDef) {
          var v = "";
          var type = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.type;
          if (type == "number") {
            v = 0;
          }
          return v;
        };
        var spelEscapeString = function spelEscapeString(val) {
          // Strings are delimited by single quotes. To put a single quote itself in a string, use two single quote characters. 
          return "'" + val.replace(/'/g, "''") + "'";
        };
        var spelInlineList = function spelInlineList(vals) {
          var toArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          // find java type of values
          var javaType;
          var jt;
          var numberJavaTypes = ["int", "float"];
          vals.map(function (v) {
            if (v !== undefined && v !== null) {
              if (typeof v === "string") {
                jt = "String";
              } else if (typeof v === "number") {
                jt = Number.isInteger(v) ? "int" : "float";
              } else throw new Error("spelEscape: Can't use value ".concat(v, " in array"));
              if (!javaType) {
                javaType = jt;
              } else if (javaType != jt) {
                if (numberJavaTypes.includes(javaType) && numberJavaTypes.includes(jt)) {
                  // found int and float in collecton - use float
                  javaType = "float";
                } else throw new Error("spelEscape: Can't use different types in array: found ".concat(javaType, " and ").concat(jt));
              }
            }
          });
          if (!javaType) {
            javaType = "String"; //default if empty array
          }

          // for floats we should add 'f' to all items
          var escapedVals;
          if (javaType == "float") {
            escapedVals = vals.map(function (v) {
              return spelEscape(v, true);
            });
          } else {
            escapedVals = vals.map(function (v) {
              return spelEscape(v);
            });
          }

          // build inline list or array
          var res;
          if (toArray) {
            res = "new ".concat(javaType, "[]{").concat(escapedVals.join(", "), "}");
          } else {
            res = "{".concat(escapedVals.join(", "), "}");
          }
          return res;
        };
        var spelFixList = function spelFixList(val) {
          // `{1,2}.contains(1)` NOT works
          // `{1,2}.?[true].contains(1)` works
          return "".concat(val, ".?[true]");
        };
        var spelEscape = function spelEscape(val) {
          var numberToFloat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var arrayToArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          // https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions-ref-literal
          if (val === undefined || val === null) {
            return "null";
          }
          switch (_typeof$3(val)) {
            case "boolean":
              return val ? "true" : "false";
            case "number":
              if (!Number.isFinite(val) || isNaN(val)) return undefined;
              return val + (!Number.isInteger(val) || numberToFloat ? "f" : "");
            case "object":
              if (Array.isArray(val)) {
                return spelInlineList(val, arrayToArray);
              } else {
                // see `spelFormatValue` for Date, LocalTime
                throw new Error("spelEscape: Object is not supported");
              }
            default:
              return spelEscapeString(val);
          }
        };
        var spelFormatConcat = function spelFormatConcat(parts) {
          if (parts && Array.isArray(parts) && parts.length) {
            return parts.map(function (part) {
              if (part.type == "const") {
                return spelEscape(part.value);
              } else if (part.type == "property") {
                return "" + part.value;
              } else if (part.type == "variable") {
                return "#" + part.value;
              }
              return undefined;
            }).filter(function (r) {
              return r != undefined;
            }).join(" + ");
          } else {
            return "null";
          }
        };

        // `val` is {value, valueType, valueSrc}
        // If `valueType` == "case_value", `value` is array of such items (to be considered as concatenation)
        var spelImportConcat = function spelImportConcat(val) {
          if (val == undefined) return [undefined, []];
          var errors = [];
          var value = val.valueType == "case_value" ? val.value : val;
          var valueArr = Array.isArray(value) ? value : [value];
          var res = valueArr.map(function (child) {
            if (child.valueSrc === "value") {
              if (child.value === null) {
                return undefined;
              } else {
                return {
                  type: "const",
                  value: child.value
                };
              }
            } else if (child.valueSrc === "field") {
              return {
                type: child.isVariable ? "variable" : "property",
                value: child.value
              };
            } else {
              errors.push("Unsupported valueSrc ".concat(child.valueSrc, " in concatenation"));
            }
          }).filter(function (v) {
            return v != undefined;
          });
          return [res, errors];
        };
        var stringifyForDisplay = function stringifyForDisplay(v) {
          return v == null ? "NULL" : v.toString();
        };
        var wrapWithBrackets = function wrapWithBrackets(v) {
          if (v == undefined) return v;
          if ((v === null || v === void 0 ? void 0 : v[0]) === "(" && (v === null || v === void 0 ? void 0 : v[(v === null || v === void 0 ? void 0 : v.length) - 1]) === ")") {
            // already wrapped
            return v;
          }
          return "(" + v + ")";
        };
        const _export = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          SqlString,
          mongoEmptyValue,
          spelEscape,
          spelFixList,
          spelFormatConcat,
          spelImportConcat,
          sqlEmptyValue,
          stringifyForDisplay,
          wrapWithBrackets
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function _createForOfIteratorHelper$c(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$c(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$c(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$c(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$c(o, minLen);
        }
        function _arrayLikeToArray$c(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function ownKeys$A(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$A(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$A(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$A(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }

        // https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions

        var compareToSign = "${0}.compareTo(${1})";
        var TypesWithCompareTo = {
          datetime: true,
          time: true,
          date: true
        };
        var spelFormat = function spelFormat(tree, config) {
          return _spelFormat(tree, config, false);
        };
        var _spelFormat = function _spelFormat(tree, config) {
          var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          //meta is mutable
          var meta = {
            errors: []
          };
          var extendedConfig = extendConfig(config, undefined, false);
          var res = formatItem$5(tree, extendedConfig, meta, null);
          if (returnErrors) {
            return [res, meta.errors];
          } else {
            if (meta.errors.length) console.warn("Errors while exporting to SpEL:", meta.errors);
            return res;
          }
        };
        var formatItem$5 = function formatItem(item, config, meta) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          if (!item) return undefined;
          var type = item.get("type");
          if (type === "group" || type === "rule_group") {
            return formatGroup$5(item, config, meta, parentField);
          } else if (type === "rule") {
            return formatRule$5(item, config, meta, parentField);
          } else if (type == "switch_group") {
            return formatSwitch$1(item, config, meta);
          } else if (type == "case_group") {
            return formatCase$1(item, config, meta, parentField);
          }
          return undefined;
        };
        var formatCase$1 = function formatCase(item, config, meta) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var type = item.get("type");
          if (type != "case_group") {
            meta.errors.push("Unexpected child of type ".concat(type, " inside switch"));
            return undefined;
          }
          var properties = item.get("properties") || new Map$2();
          var _formatItemValue = formatItemValue$2(config, properties, meta, null, parentField, "!case_value"),
            _formatItemValue2 = _slicedToArray$1(_formatItemValue, 3),
            formattedValue = _formatItemValue2[0];
          _formatItemValue2[1];
          _formatItemValue2[2];
          var cond = formatGroup$5(item, config, meta, parentField);
          return [cond, formattedValue];
        };
        var formatSwitch$1 = function formatSwitch(item, config, meta) {
          item.get("properties") || new Map$2();
          var children = item.get("children1");
          if (!children) return undefined;
          var cases = children.map(function (currentChild) {
            return formatCase$1(currentChild, config, meta, null);
          }).filter(function (currentChild) {
            return typeof currentChild !== "undefined";
          }).valueSeq().toArray();
          if (!cases.length) return undefined;
          if (cases.length == 1 && !cases[0][0]) {
            // only 1 case without condition
            return cases[0][1];
          }
          var filteredCases = [];
          for (var i = 0; i < cases.length; i++) {
            if (i != cases.length - 1 && !cases[i][0]) {
              meta.errors.push("No condition for case ".concat(i));
            } else {
              filteredCases.push(cases[i]);
              if (i == cases.length - 1 && cases[i][0]) {
                // no default - add null as default
                filteredCases.push([undefined, null]);
              }
            }
          }
          var left = "",
            right = "";
          for (var _i = 0; _i < filteredCases.length; _i++) {
            var _filteredCases$_i = _slicedToArray$1(filteredCases[_i], 2),
              cond = _filteredCases$_i[0],
              value = _filteredCases$_i[1];
            if (value == undefined) value = "null";
            if (cond == undefined) cond = "true";
            if (_i != filteredCases.length - 1) {
              left += "(".concat(cond, " ? ").concat(value, " : ");
              right += ")";
            } else {
              left += "".concat(value);
            }
          }
          return left + right;
        };
        var formatGroup$5 = function formatGroup(item, config, meta) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var type = item.get("type");
          var properties = item.get("properties") || new Map$2();
          var mode = properties.get("mode");
          var children = item.get("children1") || new List();
          var field = properties.get("field");
          var conjunction = properties.get("conjunction");
          if (!conjunction) conjunction = defaultConjunction(config);
          var conjunctionDefinition = config.conjunctions[conjunction];
          var not = properties.get("not");
          var isRuleGroup = type === "rule_group";
          var isRuleGroupArray = isRuleGroup && mode != "struct";
          var groupField = isRuleGroupArray ? field : parentField;
          var groupFieldDef = getFieldConfig$8(config, groupField) || {};
          var isSpelArray = groupFieldDef.isSpelArray;
          var fieldSeparator = config.settings.fieldSeparator;

          // check op for reverse
          var groupOperator = properties.get("operator");
          if (!groupOperator && (!mode || mode == "some")) {
            groupOperator = "some";
          }
          var realGroupOperator = checkOp(config, groupOperator, field);
          var isGroupOpRev = realGroupOperator != groupOperator;
          var realGroupOperatorDefinition = groupOperator && getOperatorConfig$4(config, realGroupOperator, field) || null;
          var isGroup0 = isRuleGroup && (!realGroupOperator || realGroupOperatorDefinition.cardinality == 0);

          // build value for aggregation op
          var _formatItemValue3 = formatItemValue$2(config, properties, meta, realGroupOperator, parentField, null),
            _formatItemValue4 = _slicedToArray$1(_formatItemValue3, 3),
            formattedValue = _formatItemValue4[0],
            valueSrc = _formatItemValue4[1],
            valueType = _formatItemValue4[2];

          // build filter in aggregation
          var list = children.map(function (currentChild) {
            return formatItem$5(currentChild, config, meta, groupField);
          }).filter(function (currentChild) {
            return typeof currentChild !== "undefined";
          });
          if (isRuleGroupArray && !isGroup0) {
            // "count" rule can have no "having" children, but should have number value
            if (formattedValue == undefined) return undefined;
          } else {
            if (!list.size) return undefined;
          }
          var omitBrackets = isRuleGroup;
          var filter = list.size ? conjunctionDefinition.spelFormatConj.call(config.ctx, list, conjunction, not, omitBrackets) : null;

          // build result
          var ret;
          if (isRuleGroupArray) {
            var formattedField = formatField$3(meta, config, field, parentField);
            var sep = fieldSeparator || ".";
            var getSize = sep + (isSpelArray ? "length" : "size()");
            var fullSize = "".concat(formattedField).concat(getSize);
            // https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions-collection-selection
            var filteredSize = filter ? "".concat(formattedField, ".?[").concat(filter, "]").concat(getSize) : fullSize;
            var groupValue = isGroup0 ? fullSize : formattedValue;
            // format expression
            ret = formatExpression(meta, config, properties, filteredSize, groupValue, realGroupOperator, valueSrc, valueType, isGroupOpRev);
          } else {
            ret = filter;
          }
          return ret;
        };
        var buildFnToFormatOp$3 = function buildFnToFormatOp(operator, operatorDefinition, valueType) {
          var spelOp = operatorDefinition.spelOp;
          if (!spelOp) return undefined;
          var isSign = spelOp.includes("${0}");
          var isCompareTo = TypesWithCompareTo[valueType];
          var sop = spelOp;
          var fn;
          var cardinality = getOpCardinality$1(operatorDefinition);
          if (isCompareTo) {
            // date1.compareTo(date2) >= 0
            //   instead of
            // date1 >= date2
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              var compareRes = compareToSign.replace(/\${(\w+)}/g, function (_, k) {
                return k == 0 ? field : cardinality > 1 ? values[k - 1] : values;
              });
              return "".concat(compareRes, " ").concat(sop, " 0");
            };
          } else if (isSign) {
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              return spelOp.replace(/\${(\w+)}/g, function (_, k) {
                return k == 0 ? field : cardinality > 1 ? values[k - 1] : values;
              });
            };
          } else if (cardinality == 0) {
            // should not be
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              return "".concat(field, " ").concat(sop);
            };
          } else if (cardinality == 1) {
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              return "".concat(field, " ").concat(sop, " ").concat(values);
            };
          }
          return fn;
        };
        var formatExpression = function formatExpression(meta, config, properties, formattedField, formattedValue, operator, valueSrc, valueType) {
          var isRev = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
          var field = properties.get("field");
          var opDef = getOperatorConfig$4(config, operator, field) || {};
          var fieldDef = getFieldConfig$8(config, field) || {};
          var operatorOptions = properties.get("operatorOptions");

          //find fn to format expr
          var fn = opDef.spelFormatOp || buildFnToFormatOp$3(operator, opDef, valueType);
          if (!fn) {
            meta.errors.push("Operator ".concat(operator, " is not supported"));
            return undefined;
          }

          //format expr
          var args = [formattedField, operator, formattedValue, valueSrc, valueType, omit$2(opDef, opDefKeysToOmit), operatorOptions, fieldDef];
          var ret;
          ret = fn.call.apply(fn, [config.ctx].concat(args));

          //rev
          if (isRev) {
            ret = config.settings.spelFormatReverse.call(config.ctx, ret);
          }
          if (ret === undefined) {
            meta.errors.push("Operator ".concat(operator, " is not supported for value source ").concat(valueSrc));
          }
          return ret;
        };
        var checkOp = function checkOp(config, operator, field) {
          if (!operator) return undefined;
          var opDef = getOperatorConfig$4(config, operator, field) || {};
          var reversedOp = opDef.reversedOp;
          var revOpDef = getOperatorConfig$4(config, reversedOp, field) || {};
          var canFormatOp = opDef.spelOp || opDef.spelFormatOp;
          var canFormatRevOp = revOpDef.spelOp || revOpDef.spelFormatOp;
          if (!canFormatOp && !canFormatRevOp) {
            return undefined;
          }
          if (!canFormatOp && canFormatRevOp) {
            var _ref = [reversedOp, operator];
            operator = _ref[0];
            reversedOp = _ref[1];
            var _ref2 = [revOpDef, opDef];
            opDef = _ref2[0];
            revOpDef = _ref2[1];
          }
          return operator;
        };
        var formatRule$5 = function formatRule(item, config, meta) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var properties = item.get("properties") || new Map$2();
          var field = properties.get("field");
          var fieldSrc = properties.get("fieldSrc");
          var operator = properties.get("operator");
          if (field == null || operator == null) return undefined;

          // check op for reverse
          var realOp = checkOp(config, operator, field);
          if (!realOp) {
            meta.errors.push("Operator ".concat(operator, " is not supported"));
            return undefined;
          }
          var isRev = realOp != operator;

          //format value
          var _formatItemValue5 = formatItemValue$2(config, properties, meta, realOp, parentField, null),
            _formatItemValue6 = _slicedToArray$1(_formatItemValue5, 3),
            formattedValue = _formatItemValue6[0],
            valueSrc = _formatItemValue6[1],
            valueType = _formatItemValue6[2];
          if (formattedValue === undefined) return undefined;

          //format field
          var formattedField = formatLhs(meta, config, field, fieldSrc, parentField);
          if (formattedField === undefined) return undefined;

          // format expression
          var res = formatExpression(meta, config, properties, formattedField, formattedValue, realOp, valueSrc, valueType, isRev);
          return res;
        };
        var formatLhs = function formatLhs(meta, config, field, fieldSrc) {
          var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          if (fieldSrc === "func") return formatFunc$4(meta, config, field, parentField);else return formatField$3(meta, config, field, parentField);
        };
        var formatItemValue$2 = function formatItemValue(config, properties, meta, operator, parentField) {
          var expectedValueType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          var field = properties.get("field");
          var iValueSrc = properties.get("valueSrc");
          var iValueType = properties.get("valueType");
          if (expectedValueType == "!case_value" || iValueType && iValueType.get(0) == "case_value") {
            field = "!case_value";
          }
          var fieldDef = getFieldConfig$8(config, field) || {};
          var operatorDefinition = getOperatorConfig$4(config, operator, field) || {};
          var cardinality = getOpCardinality$1(operatorDefinition);
          var iValue = properties.get("value");
          var asyncListValues = properties.get("asyncListValues");
          var valueSrcs = [];
          var valueTypes = [];
          var formattedValue;
          if (iValue != undefined) {
            var fvalue = iValue.map(function (currentValue, ind) {
              var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
              var valueType = iValueType ? iValueType.get(ind) : null;
              var cValue = completeValue(currentValue, valueSrc, config);
              var widget = getWidgetForFieldOp$3(config, field, operator, valueSrc);
              var fieldWidgetDef = getFieldWidgetConfig$3(config, field, operator, widget, valueSrc, {
                forExport: true
              });
              var fv = formatValue$4(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDefinition, parentField, asyncListValues);
              if (fv !== undefined) {
                valueSrcs.push(valueSrc);
                valueTypes.push(valueType);
              }
              return fv;
            });
            var hasUndefinedValues = fvalue.filter(function (v) {
              return v === undefined;
            }).size > 0;
            if (!(fvalue.size < cardinality || hasUndefinedValues)) {
              formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;
            }
          }
          return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];
        };
        var formatValue$4 = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {
          var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;
          var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;
          if (currentValue === undefined) return undefined;
          var ret;
          if (valueSrc === "field") {
            ret = formatField$3(meta, config, currentValue, parentField);
          } else if (valueSrc === "func") {
            ret = formatFunc$4(meta, config, currentValue, parentField);
          } else {
            if (typeof (fieldWidgetDef === null || fieldWidgetDef === void 0 ? void 0 : fieldWidgetDef.spelFormatValue) === "function") {
              var fn = fieldWidgetDef.spelFormatValue;
              var args = [currentValue, _objectSpread$A(_objectSpread$A({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
                asyncListValues: asyncListValues
              }),
              //useful options: valueFormat for date/time
              omit$2(fieldWidgetDef, widgetDefKeysToOmit)];
              if (operator) {
                args.push(operator);
                args.push(operatorDef);
              }
              if (valueSrc == "field") {
                var valFieldDefinition = getFieldConfig$8(config, currentValue) || {};
                args.push(valFieldDefinition);
              }
              ret = fn.call.apply(fn, [config.ctx].concat(args));
            } else {
              ret = spelEscape(currentValue);
            }
          }
          return ret;
        };
        var formatField$3 = function formatField(meta, config, field) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          if (!field) return;
          var fieldSeparator = config.settings.fieldSeparator;
          var fieldDefinition = getFieldConfig$8(config, field) || {};
          var fieldParts = getFieldParts$3(field, config);
          var fieldPartsConfigs = getFieldPartsConfigs(field, config, parentField);
          var formatFieldFn = config.settings.formatSpelField;
          var fieldName = formatFieldName(field, config, meta, parentField);
          var fieldPartsMeta = fieldPartsConfigs.map(function (_ref3) {
            var _ref4 = _slicedToArray$1(_ref3, 3),
              key = _ref4[0],
              cnf = _ref4[1],
              parentCnf = _ref4[2];
            var parent;
            if (parentCnf) {
              if (parentCnf.type == "!struct" || parentCnf.type == "!group" && parentCnf.mode == "struct") parent = cnf.isSpelMap ? "map" : "class";else if (parentCnf.type == "!group") parent = cnf.isSpelItemMap ? "[map]" : "[class]";else parent = "class";
            }
            var isSpelVariable = cnf === null || cnf === void 0 ? void 0 : cnf.isSpelVariable;
            return {
              key: key,
              parent: parent,
              isSpelVariable: isSpelVariable,
              fieldSeparator: fieldSeparator
            };
          });
          var formattedField = formatFieldFn.call(config.ctx, fieldName, parentField, fieldParts, fieldPartsMeta, fieldDefinition, config);
          return formattedField;
        };
        var formatFunc$4 = function formatFunc(meta, config, currentValue) {
          var _currentValue$get, _currentValue$get2;
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var funcKey = (_currentValue$get = currentValue.get) === null || _currentValue$get === void 0 ? void 0 : _currentValue$get.call(currentValue, "func");
          var args = (_currentValue$get2 = currentValue.get) === null || _currentValue$get2 === void 0 ? void 0 : _currentValue$get2.call(currentValue, "args");
          var funcConfig = getFuncConfig$2(config, funcKey);
          if (!funcConfig) {
            meta.errors.push("Func ".concat(funcKey, " is not defined in config"));
            return undefined;
          }
          var formattedArgs = {};
          var gaps = [];
          var missingArgKeys = [];
          for (var argKey in funcConfig.args) {
            var _argValue, _argConfig$spelEscape;
            var argConfig = funcConfig.args[argKey];
            var fieldDef = getFieldConfig$8(config, argConfig);
            var defaultValue = argConfig.defaultValue,
              isOptional = argConfig.isOptional;
            var defaultValueSrc = defaultValue !== null && defaultValue !== void 0 && defaultValue.func ? "func" : "value";
            var argVal = args ? args.get(argKey) : undefined;
            var argValue = argVal ? argVal.get("value") : undefined;
            var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
            if (argValueSrc !== "func" && (_argValue = argValue) !== null && _argValue !== void 0 && _argValue.toJS) {
              // value should not be Immutable
              argValue = argValue.toJS();
            }
            var argAsyncListValues = argVal ? argVal.get("asyncListValues") : undefined;
            var doEscape = (_argConfig$spelEscape = argConfig.spelEscapeForFormat) !== null && _argConfig$spelEscape !== void 0 ? _argConfig$spelEscape : true;
            var operator = null;
            var widget = getWidgetForFieldOp$3(config, argConfig, operator, argValueSrc);
            var fieldWidgetDef = getFieldWidgetConfig$3(config, argConfig, operator, widget, argValueSrc, {
              forExport: true
            });
            var formattedArgVal = formatValue$4(meta, config, argValue, argValueSrc, argConfig.type, fieldWidgetDef, fieldDef, null, null, parentField, argAsyncListValues);
            if (argValue != undefined && formattedArgVal === undefined) {
              if (argValueSrc != "func")
                // don't triger error if args value is another incomplete function
                meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
              return undefined;
            }
            var formattedDefaultVal = void 0;
            if (formattedArgVal === undefined && !isOptional && defaultValue != undefined) {
              var defaultWidget = getWidgetForFieldOp$3(config, argConfig, operator, defaultValueSrc);
              var defaultFieldWidgetDef = getFieldWidgetConfig$3(config, argConfig, operator, defaultWidget, defaultValueSrc, {
                forExport: true
              });
              formattedDefaultVal = formatValue$4(meta, config, defaultValue, defaultValueSrc, argConfig.type, defaultFieldWidgetDef, fieldDef, null, null, parentField, argAsyncListValues);
              if (formattedDefaultVal === undefined) {
                if (defaultValueSrc != "func")
                  // don't triger error if args value is another incomplete function
                  meta.errors.push("Can't format default value of arg ".concat(argKey, " for func ").concat(funcKey));
                return undefined;
              }
            }
            var finalFormattedVal = formattedArgVal !== null && formattedArgVal !== void 0 ? formattedArgVal : formattedDefaultVal;
            if (finalFormattedVal !== undefined) {
              var _argValue2;
              if (gaps.length) {
                var _iterator = _createForOfIteratorHelper$c(gaps),
                  _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var missedArgKey = _step.value;
                    formattedArgs[missedArgKey] = undefined;
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                gaps = [];
              }
              formattedArgs[argKey] = doEscape ? finalFormattedVal : (_argValue2 = argValue) !== null && _argValue2 !== void 0 ? _argValue2 : defaultValue;
            } else {
              if (!isOptional) missingArgKeys.push(argKey);
              gaps.push(argKey);
            }
          }
          if (missingArgKeys.length) {
            //meta.errors.push(`Missing vals for args ${missingArgKeys.join(", ")} for func ${funcKey}`);
            return undefined; // incomplete
          }
          var ret;
          if (typeof funcConfig.spelFormatFunc === "function") {
            var fn = funcConfig.spelFormatFunc;
            var _args = [formattedArgs];
            ret = fn.call.apply(fn, [config.ctx].concat(_args));
          } else if (funcConfig.spelFunc) {
            // fill arg values
            ret = funcConfig.spelFunc.replace(/\${(\w+)}/g, function (found, argKey) {
              var _formattedArgs$argKey;
              return (_formattedArgs$argKey = formattedArgs[argKey]) !== null && _formattedArgs$argKey !== void 0 ? _formattedArgs$argKey : found;
            });
            // remove optional args (from end only)
            var optionalArgs = Object.keys(funcConfig.args || {}).reverse().filter(function (argKey) {
              return !!funcConfig.args[argKey].isOptional;
            });
            var _iterator2 = _createForOfIteratorHelper$c(optionalArgs),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var _argKey = _step2.value;
                if (formattedArgs[_argKey] != undefined) break;
                ret = ret.replace(new RegExp("(, )?" + "\\${" + _argKey + "}", "g"), "");
              }
              // missing required arg vals
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            ret = ret.replace(/\${(\w+)}/g, "null");
          } else {
            meta.errors.push("Func ".concat(funcKey, " is not supported"));
          }
          return ret;
        };
        function _createForOfIteratorHelper$b(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$b(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e2) {
                  throw _e2;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e3) {
              didErr = true;
              err = _e3;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$b(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$b(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(o, minLen);
        }
        function _arrayLikeToArray$b(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function ownKeys$z(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$z(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$z(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$z(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }

        // https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions

        // spel type => raqb type
        var SpelPrimitiveTypes = {
          number: "number",
          string: "text",
          "boolean": "boolean",
          "null": "null" // should not be
        };
        // spel class => raqb type
        var SpelPrimitiveClasses = {
          String: "text"
        };
        var ListValueType = "multiselect";
        var isFuncableProperty = function isFuncableProperty(p) {
          return ["length"].includes(p);
        };
        var isObject$a = function isObject(v) {
          return _typeof$3(v) == "object" && v !== null && !Array.isArray(v);
        };
        var loadFromSpel = function loadFromSpel(logicTree, config) {
          return _loadFromSpel(logicTree, config, true);
        };
        var _loadFromSpel = function _loadFromSpel(spelStr, config) {
          var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          //meta is mutable
          var meta = {
            errors: []
          };
          var extendedConfig = extendConfig(config, undefined, false);
          var conv = buildConv(extendedConfig);
          var compiledExpression;
          var convertedObj;
          var jsTree = undefined;
          try {
            var compileRes = spel2jsExports.SpelExpressionEvaluator.compile(spelStr);
            compiledExpression = compileRes._compiledExpression;
          } catch (e) {
            meta.errors.push(e);
          }
          if (compiledExpression) {
            //logger.debug("compiledExpression:", compiledExpression);
            convertedObj = postprocessCompiled(compiledExpression, meta);
            logger$1.debug("convertedObj:", convertedObj, meta);
            jsTree = convertToTree(convertedObj, conv, extendedConfig, meta);
            if (jsTree && jsTree.type != "group" && jsTree.type != "switch_group") {
              jsTree = wrapInDefaultConj(jsTree, extendedConfig, convertedObj["not"]);
            }
            logger$1.debug("jsTree:", jsTree);
          }
          var immTree = jsTree ? loadTree(jsTree) : undefined;
          if (returnErrors) {
            return [immTree, meta.errors];
          } else {
            if (meta.errors.length) console.warn("Errors while importing from SpEL:", meta.errors);
            return immTree;
          }
        };
        var postprocessCompiled = function postprocessCompiled(expr, meta) {
          var parentExpr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var type = expr.getType();
          var children = expr.getChildren().map(function (child) {
            return postprocessCompiled(child, meta, expr);
          });

          // flatize OR/AND
          if (type == "op-or" || type == "op-and") {
            children = children.reduce(function (acc, child) {
              var canFlatize = child.type == type && !child.not;
              var flat = canFlatize ? child.children : [child];
              return [].concat(_toConsumableArray(acc), _toConsumableArray(flat));
            }, []);
          }

          // unwrap NOT
          if (type == "op-not") {
            if (children.length != 1) {
              meta.errors.push("Operator NOT should have 1 child, but got ".concat(children.length, "}"));
            }
            return _objectSpread$z(_objectSpread$z({}, children[0]), {}, {
              not: !(children[0].not || false)
            });
          }
          if (type == "compound") {
            // remove `.?[true]`
            children = children.filter(function (child) {
              var isListFix = child.type == "selection" && child.children.length == 1 && child.children[0].type == "boolean" && child.children[0].val == true;
              return !isListFix;
            });
            // aggregation
            // eg. `results.?[product == 'abc'].length`
            var selection = children.find(function (child) {
              return child.type == "selection";
            });
            if (selection && selection.children.length != 1) {
              meta.errors.push("Selection should have 1 child, but got ".concat(selection.children.length));
            }
            var filter = selection ? selection.children[0] : null;
            var lastChild = children[children.length - 1];
            var isSize = lastChild.type == "method" && lastChild.val.methodName == "size" || lastChild.type == "!func" && lastChild.methodName == "size";
            var isLength = lastChild.type == "property" && lastChild.val == "length";
            var sourceParts = children.filter(function (child) {
              return child !== selection && child !== lastChild;
            });
            var source = {
              type: "compound",
              children: sourceParts
            };
            var isAggr = (isSize || isLength) && convertPath(sourceParts) != null;
            if (isAggr) {
              return {
                type: "!aggr",
                filter: filter,
                source: source
              };
            }
            // remove `#this`, `#root`
            children = children.filter(function (child) {
              var isThis = child.type == "variable" && child.val == "this";
              var isRoot = child.type == "variable" && child.val == "root";
              return !(isThis || isRoot);
            });
            // indexer
            children = children.map(function (child) {
              if (child.type == "indexer" && child.children.length == 1) {
                return {
                  type: "indexer",
                  val: child.children[0].val,
                  itype: child.children[0].type
                };
              } else {
                return child;
              }
            });
            // method
            // if (lastChild.type == "method") {
            //   // seems like obsolete code!
            //   debugger
            //   const obj = children.filter(child => 
            //     child !== lastChild
            //   );
            //   return {
            //     type: "!func",
            //     obj,
            //     methodName: lastChild.val.methodName,
            //     args: lastChild.val.args
            //   };
            // }
            // !func
            if (lastChild.type == "!func") {
              var ret = {};
              var curr = ret;
              do {
                var _lastChild, _lastChild2;
                Object.assign(curr, lastChild);
                children = children.filter(function (child) {
                  return child !== lastChild;
                });
                lastChild = children[children.length - 1];
                if (((_lastChild2 = lastChild) === null || _lastChild2 === void 0 ? void 0 : _lastChild2.type) == "!func") {
                  curr.obj = {};
                  curr = curr.obj;
                } else {
                  if (children.length > 1) {
                    curr.obj = {
                      type: "compound",
                      children: children
                    };
                  } else {
                    curr.obj = lastChild;
                  }
                }
              } while (((_lastChild = lastChild) === null || _lastChild === void 0 ? void 0 : _lastChild.type) == "!func");
              return ret;
            }
          }

          // getRaw || getValue
          var val;
          try {
            if (expr.getRaw) {
              // use my fork
              val = expr.getRaw();
            } else if (expr.getValue.length == 0) {
              // getValue not requires context arg -> can use
              val = expr.getValue();
            }
          } catch (e) {
            logger$1.error("[spel2js] Error in getValue()", e);
          }

          // ternary
          if (type == "ternary") {
            val = flatizeTernary(children);
          }

          // convert method/function args
          if (_typeof$3(val) === "object" && val !== null) {
            if (val.methodName || val.functionName) {
              val.args = val.args.map(function (child) {
                return postprocessCompiled(child, meta, expr);
              });
            }
          }
          // convert list
          if (type == "list") {
            val = val.map(function (item) {
              return postprocessCompiled(item, meta, expr);
            });

            // fix whole expression wrapped in `{}`
            if (!parentExpr && val.length == 1) {
              return val[0];
            }
          }
          // convert constructor
          if (type == "constructorref") {
            var qid = children.find(function (child) {
              return child.type == "qualifiedidentifier";
            });
            var cls = qid === null || qid === void 0 ? void 0 : qid.val;
            if (!cls) {
              meta.errors.push("Can't find qualifiedidentifier in constructorref children: ".concat(JSON.stringify(children)));
              return undefined;
            }
            var args = children.filter(function (child) {
              return child.type != "qualifiedidentifier";
            });
            return {
              type: "!new",
              cls: cls,
              args: args
            };
          }
          // convert type
          if (type == "typeref") {
            var _qid = children.find(function (child) {
              return child.type == "qualifiedidentifier";
            });
            var _cls = _qid === null || _qid === void 0 ? void 0 : _qid.val;
            if (!_cls) {
              meta.errors.push("Can't find qualifiedidentifier in typeref children: ".concat(JSON.stringify(children)));
              return undefined;
            }
            children.filter(function (child) {
              return child.type != "qualifiedidentifier";
            });
            return {
              type: "!type",
              cls: _cls
            };
          }
          // convert function/method
          if (type == "function" || type == "method") {
            // `foo()` is method, `#foo()` is function
            // let's use common property `methodName` and just add `isVar` for function
            var _val = val,
              functionName = _val.functionName,
              methodName = _val.methodName,
              _args2 = _val.args;
            return {
              type: "!func",
              methodName: functionName || methodName,
              isVar: type == "function",
              args: _args2
            };
          }
          return {
            type: type,
            children: children,
            val: val
          };
        };
        var flatizeTernary = function flatizeTernary(children) {
          var flat = [];
          function _processTernaryChildren(tern) {
            var _tern = _slicedToArray$1(tern, 3),
              cond = _tern[0],
              if_val = _tern[1],
              else_val = _tern[2];
            flat.push([cond, if_val]);
            if ((else_val === null || else_val === void 0 ? void 0 : else_val.type) == "ternary") {
              _processTernaryChildren(else_val.children);
            } else {
              flat.push([undefined, else_val]);
            }
          }
          _processTernaryChildren(children);
          return flat;
        };
        var buildConv = function buildConv(config) {
          var operators = {};
          var _loop = function _loop(opKey) {
            var opConfig = config.operators[opKey];
            if (opConfig.spelOps) {
              // examples: "==", "eq", ".contains", "matches" (can be used for starts_with, ends_with)
              opConfig.spelOps.forEach(function (spelOp) {
                var opk = spelOp; // + "/" + getOpCardinality(opConfig);
                if (!operators[opk]) operators[opk] = [];
                operators[opk].push(opKey);
              });
            } else if (opConfig.spelOp) {
              var opk = opConfig.spelOp; // + "/" + getOpCardinality(opConfig);
              if (!operators[opk]) operators[opk] = [];
              operators[opk].push(opKey);
            } else {
              logger$1.log("[spel] No spelOp for operator ".concat(opKey));
            }
          };
          for (var opKey in config.operators) {
            _loop(opKey);
          }
          var conjunctions = {};
          for (var conjKey in config.conjunctions) {
            var conjunctionDefinition = config.conjunctions[conjKey];
            var ck = conjunctionDefinition.spelConj || conjKey.toLowerCase();
            conjunctions[ck] = conjKey;
          }
          var funcs = {};
          var _iterator = _createForOfIteratorHelper$b(iterateFuncs(config)),
            _step;
          try {
            var _loop2 = function _loop2() {
              var _step$value = _slicedToArray$1(_step.value, 2),
                funcPath = _step$value[0],
                funcConfig = _step$value[1];
              var fks = [];
              var spelFunc = funcConfig.spelFunc;
              if (typeof spelFunc === "string") {
                var optionalArgs = Object.keys(funcConfig.args || {}).reverse().filter(function (argKey) {
                  return !!funcConfig.args[argKey].isOptional || funcConfig.args[argKey].defaultValue != undefined;
                });
                var funcSignMain = spelFunc.replace(/\${(\w+)}/g, function (_, _k) {
                  return "?";
                });
                var funcSignsOptional = optionalArgs.reduce(function (acc, argKey) {
                  return [].concat(_toConsumableArray(acc), [[argKey].concat(_toConsumableArray(acc[acc.length - 1] || []))]);
                }, []).map(function (optionalArgKeys) {
                  return spelFunc.replace(/(?:, )?\${(\w+)}/g, function (found, a) {
                    return optionalArgKeys.includes(a) ? "" : found;
                  }).replace(/\${(\w+)}/g, function (_, _k) {
                    return "?";
                  });
                });
                fks = [funcSignMain].concat(_toConsumableArray(funcSignsOptional));
              }
              var _iterator3 = _createForOfIteratorHelper$b(fks),
                _step3;
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var _fk = _step3.value;
                  if (!funcs[_fk]) funcs[_fk] = [];
                  funcs[_fk].push(funcPath);
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            };
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              _loop2();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          var valueFuncs = {};
          for (var w in config.widgets) {
            var widgetDef = config.widgets[w];
            var spelImportFuncs = widgetDef.spelImportFuncs;
            widgetDef.type;
            if (spelImportFuncs) {
              var _iterator2 = _createForOfIteratorHelper$b(spelImportFuncs),
                _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var fk = _step2.value;
                  if (typeof fk === "string") {
                    var fs = fk.replace(/\${(\w+)}/g, function (_, k) {
                      return "?";
                    });
                    var argsOrder = _toConsumableArray(fk.matchAll(/\${(\w+)}/g)).map(function (_ref) {
                      var _ref2 = _slicedToArray$1(_ref, 2),
                        _ = _ref2[0],
                        k = _ref2[1];
                      return k;
                    });
                    if (!valueFuncs[fs]) valueFuncs[fs] = [];
                    valueFuncs[fs].push({
                      w: w,
                      argsOrder: argsOrder
                    });
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
          }
          var opFuncs = {};
          for (var op in config.operators) {
            var opDef = config.operators[op];
            var spelOp = opDef.spelOp;
            if (spelOp !== null && spelOp !== void 0 && spelOp.includes("${0}")) {
              var _fs = spelOp.replace(/\${(\w+)}/g, function (_, k) {
                return "?";
              });
              var _argsOrder = _toConsumableArray(spelOp.matchAll(/\${(\w+)}/g)).map(function (_ref3) {
                var _ref4 = _slicedToArray$1(_ref3, 2);
                _ref4[0];
                var k = _ref4[1];
                return k;
              });
              if (!opFuncs[_fs]) opFuncs[_fs] = [];
              opFuncs[_fs].push({
                op: op,
                argsOrder: _argsOrder
              });
            }
          }
          // Special .compareTo()
          var compareToSS = compareToSign.replace(/\${(\w+)}/g, function (_, k) {
            return "?";
          });
          opFuncs[compareToSS] = [{
            op: "!compare",
            argsOrder: ["0", "1"]
          }];
          return {
            operators: operators,
            conjunctions: conjunctions,
            funcs: funcs,
            valueFuncs: valueFuncs,
            opFuncs: opFuncs
          };
        };
        var convertToTree = function convertToTree(spel, conv, config, meta) {
          var _spel$_groupField;
          var parentSpel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          if (!spel) return undefined;
          spel._groupField = (_spel$_groupField = spel._groupField) !== null && _spel$_groupField !== void 0 ? _spel$_groupField : parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField;
          var res,
            canParseAsArg = true;
          if (spel.type.indexOf("op-") === 0 || spel.type === "matches") {
            res = convertOp(spel, conv, config, meta, parentSpel);
          } else if (spel.type == "!aggr") {
            var _groupFilter;
            var groupFieldValue = convertToTree(spel.source, conv, config, meta, spel);
            spel._groupField = groupFieldValue === null || groupFieldValue === void 0 ? void 0 : groupFieldValue.value;
            var groupFilter = convertToTree(spel.filter, conv, config, meta, spel);
            if (((_groupFilter = groupFilter) === null || _groupFilter === void 0 ? void 0 : _groupFilter.type) == "rule") {
              groupFilter = wrapInDefaultConj(groupFilter, config, spel.filter.not);
            }
            res = {
              groupFilter: groupFilter,
              groupFieldValue: groupFieldValue
            };
            if (!parentSpel) {
              // !aggr can't be in root, it should be compared with something
              res = undefined;
              meta.errors.push("Unexpected !aggr in root");
              canParseAsArg = false;
            }
          } else if (spel.type == "ternary") {
            var children1 = {};
            spel.val.forEach(function (v) {
              var _v = _slicedToArray$1(v, 2),
                cond = _v[0],
                val = _v[1];
              var caseI = buildCase(cond, val, conv, config, meta, spel);
              if (caseI) {
                children1[caseI.id] = caseI;
              }
            });
            res = {
              type: "switch_group",
              id: uuid(),
              children1: children1,
              properties: {}
            };
          }
          if (!res && canParseAsArg) {
            res = convertArg(spel, conv, config, meta, parentSpel);
          }
          if (res && !res.type && !parentSpel) {
            // res is not a rule, it's value at root
            // try to parse whole `"1"` as ternary
            var sw = buildSimpleSwitch(spel, conv, config, meta);
            if (sw) {
              res = sw;
            } else {
              res = undefined;
              meta.errors.push("Can't convert rule of type ".concat(spel.type, ", it looks like var/literal"));
            }
          }
          return res;
        };
        var convertOp = function convertOp(spel, conv, config, meta) {
          var parentSpel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var res;
          var op = spel.type.startsWith("op-") ? spel.type.slice("op-".length) : spel.type;

          // unary
          var isUnary = (op == "minus" || op == "plus") && spel.children.length == 1;
          if (isUnary) {
            var negative = spel.negative;
            if (op == "minus") {
              negative = !negative;
            }
            spel.children[0].negative = negative;
            return convertToTree(spel.children[0], conv, config, meta, parentSpel);
          }

          // between
          var isBetweenNormal = op == "and" && spel.children.length == 2 && spel.children[0].type == "op-ge" && spel.children[1].type == "op-le";
          var isBetweenRev = op == "or" && spel.children.length == 2 && spel.children[0].type == "op-lt" && spel.children[1].type == "op-gt";
          var isBetween = isBetweenNormal || isBetweenRev;
          if (isBetween) {
            var _spel$children$0$chil = _slicedToArray$1(spel.children[0].children, 2),
              left = _spel$children$0$chil[0],
              from = _spel$children$0$chil[1];
            var _spel$children$1$chil = _slicedToArray$1(spel.children[1].children, 2),
              right = _spel$children$1$chil[0],
              to = _spel$children$1$chil[1];
            var isSameSource = compareArgs(left, right, spel, conv, config, meta);
            if (isSameSource) {
              from.val;
              to.val;
              var oneSpel = {
                type: "op-between",
                children: [left, from, to],
                not: isBetweenRev
              };
              oneSpel._groupField = parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField;
              return convertOp(oneSpel, conv, config, meta, parentSpel);
            }
          }

          // find op
          var opKeys = conv.operators[op];
          if (op == "eq" && spel.children[1].type == "null") {
            opKeys = ["is_null"];
          } else if (op == "ne" && spel.children[1].type == "null") {
            opKeys = ["is_not_null"];
          } else if (op == "le" && spel.children[1].type == "string" && spel.children[1].val == "") {
            opKeys = ["is_empty"];
          } else if (op == "gt" && spel.children[1].type == "string" && spel.children[1].val == "") {
            opKeys = ["is_not_empty"];
          } else if (op == "between") {
            opKeys = ["between"];
          }

          // convert children
          var convertChildren = function convertChildren() {
            var _newChildren;
            var newChildren = spel.children.map(function (child) {
              return convertToTree(child, conv, config, meta, spel);
            });
            if (newChildren.length >= 2 && ((_newChildren = newChildren) === null || _newChildren === void 0 || (_newChildren = _newChildren[0]) === null || _newChildren === void 0 ? void 0 : _newChildren.type) == "!compare") {
              newChildren = newChildren[0].children;
            }
            return newChildren;
          };
          if (op == "and" || op == "or") {
            var children1 = {};
            var vals = convertChildren();
            vals.forEach(function (v) {
              if (v) {
                var id = uuid();
                v.id = id;
                if (v.type != undefined) {
                  children1[id] = v;
                } else {
                  meta.errors.push("Bad item in AND/OR: ".concat(JSON.stringify(v)));
                }
              }
            });
            res = {
              type: "group",
              id: uuid(),
              children1: children1,
              properties: {
                conjunction: conv.conjunctions[op],
                not: spel.not
              }
            };
          } else if (opKeys) {
            var _fieldObj$groupFieldV, _convertedArgs, _opConfig;
            var _vals = convertChildren();
            var fieldObj = _vals[0];
            var convertedArgs = _vals.slice(1);
            var groupField = fieldObj === null || fieldObj === void 0 || (_fieldObj$groupFieldV = fieldObj.groupFieldValue) === null || _fieldObj$groupFieldV === void 0 ? void 0 : _fieldObj$groupFieldV.value;
            var opArg = (_convertedArgs = convertedArgs) === null || _convertedArgs === void 0 ? void 0 : _convertedArgs[0];
            var opKey = opKeys[0];
            if (opKeys.length > 1) {
              var _vals$, _vals$2;
              var valueType = ((_vals$ = _vals[0]) === null || _vals$ === void 0 ? void 0 : _vals$.valueType) || ((_vals$2 = _vals[1]) === null || _vals$2 === void 0 ? void 0 : _vals$2.valueType);
              //todo: it's naive, use valueType
              var field = fieldObj === null || fieldObj === void 0 ? void 0 : fieldObj.value;
              var widgets = opKeys.map(function (op) {
                return {
                  op: op,
                  widget: getWidgetForFieldOp$3(config, field, op)
                };
              });
              logger$1.warn("[spel] Spel operator ".concat(op, " can be mapped to ").concat(opKeys, "."), "widgets:", widgets, "vals:", _vals, "valueType=", valueType);
              if (op == "eq" || op == "ne") {
                var ws = widgets.find(function (_ref5) {
                  _ref5.op;
                  var widget = _ref5.widget;
                  return widget && widget != "field";
                });
                if (ws) {
                  opKey = ws.op;
                }
              }
            }

            // some/all/none
            if (fieldObj !== null && fieldObj !== void 0 && fieldObj.groupFieldValue) {
              if (opArg && opArg.groupFieldValue && opArg.groupFieldValue.valueSrc == "field" && opArg.groupFieldValue.value == groupField) {
                // group.?[...].size() == group.size()
                opKey = "all";
                convertedArgs = [];
              } else if (opKey == "equal" && opArg.valueSrc == "value" && opArg.valueType == "number" && opArg.value == 0) {
                opKey = "none";
                convertedArgs = [];
              } else if (opKey == "greater" && opArg.valueSrc == "value" && opArg.valueType == "number" && opArg.value == 0) {
                opKey = "some";
                convertedArgs = [];
              }
            }
            var opConfig = config.operators[opKey];
            var reversedOpConfig = config.operators[(_opConfig = opConfig) === null || _opConfig === void 0 ? void 0 : _opConfig.reversedOp];
            var opNeedsReverse = spel.not && ["between"].includes(opKey);
            var opCanReverse = !!reversedOpConfig;
            var canRev = opCanReverse && (!!config.settings.reverseOperatorsForNot || opNeedsReverse);
            var needRev = spel.not && canRev || opNeedsReverse;
            if (needRev) {
              opKey = opConfig.reversedOp;
              opConfig = config.operators[opKey];
              spel.not = !spel.not;
            }
            var needWrapWithNot = !!spel.not;
            spel.not = false; // handled with needWrapWithNot

            if (!fieldObj) ;else if (fieldObj.groupFieldValue) {
              // 1. group
              if (fieldObj.groupFieldValue.valueSrc != "field") {
                meta.errors.push("Expected group field ".concat(JSON.stringify(fieldObj)));
              }
              res = buildRuleGroup(fieldObj, opKey, convertedArgs, config, meta);
            } else {
              // 2. not group
              if (fieldObj.valueSrc != "field" && fieldObj.valueSrc != "func") {
                meta.errors.push("Expected field/func at LHS, but got ".concat(JSON.stringify(fieldObj)));
              }
              var _field = fieldObj.value;
              res = buildRule(config, meta, _field, opKey, convertedArgs, spel);
            }
            if (needWrapWithNot) {
              if (res.type !== "group") {
                res = wrapInDefaultConj(res, config, true);
              } else {
                res.properties.not = !res.properties.not;
              }
            }
          } else {
            if (!parentSpel) {
              // try to parse whole `"str" + prop + #var` as ternary
              res = buildSimpleSwitch(spel, conv, config, meta);
            }
            // if (!res) {
            //   meta.errors.push(`Can't convert op ${op}`);
            // }
          }
          return res;
        };
        var convertPath = function convertPath(parts) {
          var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var expectingField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var isError = false;
          var res = parts.map(function (c) {
            if (c.type == "variable" || c.type == "property" || c.type == "indexer" && c.itype == "string") {
              return c.val;
            } else {
              var _meta$errors, _meta$errors$push;
              isError = true;
              expectingField && (meta === null || meta === void 0 || (_meta$errors = meta.errors) === null || _meta$errors === void 0 || (_meta$errors$push = _meta$errors.push) === null || _meta$errors$push === void 0 ? void 0 : _meta$errors$push.call(_meta$errors, "Unexpected item in field path compound: ".concat(JSON.stringify(c))));
            }
          });
          return !isError ? res : undefined;
        };
        var convertArg = function convertArg(spel, conv, config, meta) {
          var _spel$_groupField2, _config$settings$case;
          var parentSpel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          if (spel == undefined) return undefined;
          var fieldSeparator = config.settings.fieldSeparator;
          spel._groupField = (_spel$_groupField2 = spel._groupField) !== null && _spel$_groupField2 !== void 0 ? _spel$_groupField2 : parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField;
          if (spel.type == "variable" || spel.type == "property") {
            // normal field
            var field = normalizeField(config, spel.val, spel._groupField);
            var fieldConfig = getFieldConfig$8(config, field);
            var isVariable = spel.type == "variable";
            return {
              valueSrc: "field",
              valueType: fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type,
              isVariable: isVariable,
              value: field
            };
          } else if (spel.type == "compound") {
            // complex field
            var parts = convertPath(spel.children, meta);
            if (parts) {
              var _spel$children;
              var _field2 = normalizeField(config, parts.join(fieldSeparator), spel._groupField);
              var _fieldConfig = getFieldConfig$8(config, _field2);
              var _isVariable = ((_spel$children = spel.children) === null || _spel$children === void 0 || (_spel$children = _spel$children[0]) === null || _spel$children === void 0 ? void 0 : _spel$children.type) == "variable";
              return {
                valueSrc: "field",
                valueType: _fieldConfig === null || _fieldConfig === void 0 ? void 0 : _fieldConfig.type,
                isVariable: _isVariable,
                value: _field2
              };
            }
          } else if (SpelPrimitiveTypes[spel.type]) {
            var value = spel.val;
            var valueType = SpelPrimitiveTypes[spel.type];
            if (spel.negative) {
              value = -value;
            }
            return {
              valueSrc: "value",
              valueType: valueType,
              value: value
            };
          } else if (spel.type == "!new" && SpelPrimitiveClasses[spel.cls.at(-1)]) {
            var args = spel.args.map(function (v) {
              return convertArg(v, conv, config, meta, spel);
            });
            var _value = args === null || args === void 0 ? void 0 : args[0];
            var _valueType = SpelPrimitiveClasses[spel.cls.at(-1)];
            return _objectSpread$z(_objectSpread$z({}, _value), {}, {
              valueType: _valueType
            });
          } else if (spel.type == "list") {
            var _values$;
            var values = spel.val.map(function (v) {
              return convertArg(v, conv, config, meta, spel);
            });
            values.length ? (_values$ = values[0]) === null || _values$ === void 0 ? void 0 : _values$.valueType : null;
            var _value2 = values.map(function (v) {
              return v === null || v === void 0 ? void 0 : v.value;
            });
            var _valueType2 = ListValueType;
            return {
              valueSrc: "value",
              valueType: _valueType2,
              value: _value2
            };
          } else if (spel.type === "op-plus" && (parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel.type) === "ternary" && ((_config$settings$case = config.settings.caseValueField) === null || _config$settings$case === void 0 ? void 0 : _config$settings$case.type) === "case_value") {
            /**
             * @deprecated
             */
            return buildCaseValueConcat(spel, conv, config, meta);
          }
          var maybe = convertFunc(spel, conv, config, meta, parentSpel);
          if (maybe !== undefined) {
            return maybe;
          }
          meta.errors.push("Can't convert arg of type ".concat(spel.type));
          return undefined;
        };
        var buildFuncSignatures = function buildFuncSignatures(spel) {
          // branches
          var brns = [{
            s: "",
            params: [],
            objs: []
          }];
          _buildFuncSignatures(spel, brns);
          return brns.map(function (_ref6) {
            var s = _ref6.s,
              params = _ref6.params;
            return {
              s: s,
              params: params
            };
          }).reverse().filter(function (_ref7) {
            var s = _ref7.s;
            return s !== "" && s !== "?";
          });
        };

        // a.toLower().toUpper()
        // ->
        // ?.toLower().toUpper()
        // ?.toUpper()
        var _buildFuncSignatures = function _buildFuncSignatures(spel, brns) {
          var params = [],
            s = "";
          var type = spel.type,
            methodName = spel.methodName;
          spel.val;
          var obj = spel.obj,
            args = spel.args,
            isVar = spel.isVar,
            cls = spel.cls,
            children = spel.children;
          var lastChild = children === null || children === void 0 ? void 0 : children[children.length - 1];
          var currBrn = brns[brns.length - 1];
          if (type === "!func") {
            // T(DateTimeFormat).forPattern(?).parseDateTime(?)  --  ok
            // T(LocalDateTime).parse(?, T(DateTimeFormatter).ofPattern(?))  --  will not work
            var o = obj;
            while (o) {
              var _currBrn$params;
              var _buildFuncSignatures2 = _buildFuncSignatures(_objectSpread$z(_objectSpread$z({}, o), {}, {
                  obj: null
                }), [{}]),
                _buildFuncSignatures3 = _slicedToArray$1(_buildFuncSignatures2, 2),
                s1 = _buildFuncSignatures3[0],
                params1 = _buildFuncSignatures3[1];
              if (s1 !== "?") {
                // start new branch
                var newBrn = {
                  s: currBrn.s,
                  params: _toConsumableArray(currBrn.params),
                  objs: _toConsumableArray(currBrn.objs)
                };
                // finish old branch
                currBrn.objs.unshift("?");
                currBrn.params.unshift(o);
                // switch
                brns.push(newBrn);
                currBrn = brns[brns.length - 1];
              }
              // step
              currBrn.objs.unshift(s1);
              (_currBrn$params = currBrn.params).unshift.apply(_currBrn$params, _toConsumableArray(params1));
              o = o.type === "!func" ? o.obj : null;
            }
            var _iterator4 = _createForOfIteratorHelper$b(brns),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var _brn$objs;
                var brn = _step4.value;
                params = [].concat(_toConsumableArray((brn === null || brn === void 0 ? void 0 : brn.params) || []), _toConsumableArray(args || []));
                s = "";
                if (brn !== null && brn !== void 0 && (_brn$objs = brn.objs) !== null && _brn$objs !== void 0 && _brn$objs.length) s += brn.objs.join(".") + ".";
                s += (isVar ? "#" : "") + methodName;
                s += "(" + (args || []).map(function (_) {
                  return "?";
                }).join(", ") + ")";
                brn.s = s;
                brn.params = params;
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          } else if (type === "!new") {
            // new java.text.SimpleDateFormat('HH:mm:ss').parse('...')
            params = args || [];
            s = "new ".concat(cls.join("."), "(").concat(params.map(function (_) {
              return "?";
            }).join(", "), ")");
          } else if (type === "!type") {
            // T(java.time.LocalTime).parse('...')
            s = "T(".concat(cls.join("."), ")");
          } else if (type === "compound" && lastChild.type === "property" && isFuncableProperty(lastChild.val)) {
            // {1,2}.length  --  ok
            // 'Hello World'.bytes.length  --  will not work
            s = children.map(function (c) {
              var _params;
              if (c === lastChild) return c.val;
              var _buildFuncSignatures4 = _buildFuncSignatures(_objectSpread$z(_objectSpread$z({}, c), {}, {
                  obj: null
                }), [{}]),
                _buildFuncSignatures5 = _slicedToArray$1(_buildFuncSignatures4, 2),
                s1 = _buildFuncSignatures5[0],
                params1 = _buildFuncSignatures5[1];
              (_params = params).push.apply(_params, _toConsumableArray(params1));
              return s1;
            }).join(".");
          } else {
            params = [spel];
            s = "?";
          }
          if (currBrn) {
            currBrn.s = s;
            currBrn.params = params;
          }
          return [s, params];
        };
        var convertFunc = function convertFunc(spel, conv, config, meta) {
          var _fsigns$;
          var parentSpel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          // Build signatures
          var convertFuncArg = function convertFuncArg(v) {
            return convertToTree(v, conv, config, meta, spel);
          };
          var fsigns = buildFuncSignatures(spel);
          var firstSign = fsigns === null || fsigns === void 0 || (_fsigns$ = fsigns[0]) === null || _fsigns$ === void 0 ? void 0 : _fsigns$.s;
          if (fsigns.length) logger$1.debug("Signatures for ", spel, ":", firstSign, fsigns);

          // 1. Try to parse as value
          var maybeValue = convertFuncToValue(spel, conv, config, meta, parentSpel, fsigns, convertFuncArg);
          if (maybeValue !== undefined) return maybeValue;

          // 2. Try to parse as op
          var maybeOp = convertFuncToOp(spel, conv, config, meta, parentSpel, fsigns, convertFuncArg);
          if (maybeOp !== undefined) return maybeOp;

          // 3. Try to parse as func
          var funcKey, funcConfig, argsObj;
          // try func signature matching
          var _iterator5 = _createForOfIteratorHelper$b(fsigns),
            _step5;
          try {
            var _loop3 = function _loop3() {
              var _step5$value = _step5.value,
                s = _step5$value.s,
                params = _step5$value.params;
              var funcKeys = conv.funcs[s];
              if (funcKeys) {
                // todo: here we can check arg types, if we have function overloading
                funcKey = funcKeys[0];
                funcConfig = getFuncConfig$2(config, funcKey);
                var _funcConfig = funcConfig,
                  spelFunc = _funcConfig.spelFunc;
                var argsArr = params.map(convertFuncArg);
                var argsOrder = _toConsumableArray(spelFunc.matchAll(/\${(\w+)}/g)).map(function (_ref8) {
                  var _ref9 = _slicedToArray$1(_ref8, 2),
                    _ = _ref9[0],
                    k = _ref9[1];
                  return k;
                });
                argsObj = Object.fromEntries(argsOrder.map(function (argKey, i) {
                  return [argKey, argsArr[i]];
                }));
                return 1; // break
              }
            };
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              if (_loop3()) break;
            }
            // try `spelImport`
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
          if (!funcKey) {
            var _iterator6 = _createForOfIteratorHelper$b(iterateFuncs(config)),
              _step6;
            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var _step6$value = _slicedToArray$1(_step6.value, 2),
                  f = _step6$value[0],
                  fc = _step6$value[1];
                if (fc.spelImport) {
                  var parsed = void 0;
                  try {
                    parsed = fc.spelImport(spel);
                  } catch (_e) {
                    // can't be parsed
                  }
                  if (parsed) {
                    funcKey = f;
                    funcConfig = getFuncConfig$2(config, funcKey);
                    argsObj = {};
                    for (var argKey in parsed) {
                      argsObj[argKey] = convertFuncArg(parsed[argKey]);
                    }
                  }
                }
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
          }

          // convert
          if (funcKey) {
            var funcArgs = {};
            for (var _argKey in funcConfig.args) {
              var argConfig = funcConfig.args[_argKey];
              var argVal = argsObj[_argKey];
              if (argVal === undefined) {
                argVal = argConfig === null || argConfig === void 0 ? void 0 : argConfig.defaultValue;
                if (argVal === undefined) {
                  if (argConfig !== null && argConfig !== void 0 && argConfig.isOptional) ;else {
                    meta.errors.push("No value for arg ".concat(_argKey, " of func ").concat(funcKey));
                    return undefined;
                  }
                } else {
                  var _argVal;
                  argVal = {
                    value: argVal,
                    valueSrc: (_argVal = argVal) !== null && _argVal !== void 0 && _argVal.func ? "func" : "value",
                    valueType: argConfig.type
                  };
                }
              }
              if (argVal) funcArgs[_argKey] = argVal;
            }
            return {
              valueSrc: "func",
              value: {
                func: funcKey,
                args: funcArgs
              },
              valueType: funcConfig.returnType
            };
          }
          var methodName = spel.methodName;
          if (methodName) meta.errors.push("Signature ".concat(firstSign, " - failed to convert"));
          return undefined;
        };
        var convertFuncToValue = function convertFuncToValue(spel, conv, config, meta, parentSpel, fsigns, convertFuncArg) {
          var errs, foundSign, foundWidget;
          var candidates = [];
          for (var w in config.widgets) {
            var widgetDef = config.widgets[w];
            var spelImportFuncs = widgetDef.spelImportFuncs;
            if (spelImportFuncs) {
              for (var i = 0; i < spelImportFuncs.length; i++) {
                var fj = spelImportFuncs[i];
                if (isObject$a(fj)) {
                  var bag = {};
                  if (isJsonCompatible(fj, spel, bag)) {
                    for (var k in bag) {
                      bag[k] = convertFuncArg(bag[k]);
                    }
                    candidates.push({
                      s: "widgets.".concat(w, ".spelImportFuncs[").concat(i, "]"),
                      w: w,
                      argsObj: bag
                    });
                  }
                }
              }
            }
          }
          var _iterator7 = _createForOfIteratorHelper$b(fsigns),
            _step7;
          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var _step7$value = _step7.value,
                _s = _step7$value.s,
                params = _step7$value.params;
              var found = conv.valueFuncs[_s] || [];
              var _iterator8 = _createForOfIteratorHelper$b(found),
                _step8;
              try {
                var _loop4 = function _loop4() {
                  var _step8$value = _step8.value,
                    w = _step8$value.w,
                    argsOrder = _step8$value.argsOrder;
                  var argsArr = params.map(convertFuncArg);
                  var argsObj = Object.fromEntries(argsOrder.map(function (argKey, i) {
                    return [argKey, argsArr[i]];
                  }));
                  candidates.push({
                    s: _s,
                    w: w,
                    argsObj: argsObj
                  });
                };
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                  _loop4();
                }
              } catch (err) {
                _iterator8.e(err);
              } finally {
                _iterator8.f();
              }
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
          for (var _i = 0, _candidates = candidates; _i < _candidates.length; _i++) {
            var _candidates$_i = _candidates[_i],
              s = _candidates$_i.s,
              _w = _candidates$_i.w,
              argsObj = _candidates$_i.argsObj;
            var _widgetDef = config.widgets[_w];
            var spelImportValue = _widgetDef.spelImportValue,
              type = _widgetDef.type;
            foundWidget = _w;
            foundSign = s;
            errs = [];
            for (var _k2 in argsObj) {
              if (!["value"].includes(argsObj[_k2].valueSrc)) {
                errs.push("".concat(_k2, " has unsupported value src ").concat(argsObj[_k2].valueSrc));
              }
            }
            var value = argsObj.v.value;
            if (spelImportValue && !errs.length) {
              var _spelImportValue$call = spelImportValue.call(config.ctx, argsObj.v, _widgetDef, argsObj);
              var _spelImportValue$call2 = _slicedToArray$1(_spelImportValue$call, 2);
              value = _spelImportValue$call2[0];
              errs = _spelImportValue$call2[1];
              if (errs && !Array.isArray(errs)) errs = [errs];
            }
            if (!errs.length) {
              return {
                valueSrc: "value",
                valueType: type,
                value: value
              };
            }
          }
          if (foundWidget && errs.length) {
            meta.errors.push("Signature ".concat(foundSign, " - looks like convertable to ").concat(foundWidget, ", but: ").concat(errs.join("; ")));
          }
          return undefined;
        };
        var convertFuncToOp = function convertFuncToOp(spel, conv, config, meta, parentSpel, fsigns, convertFuncArg) {
          var errs, opKey, foundSign;
          var _iterator9 = _createForOfIteratorHelper$b(fsigns),
            _step9;
          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var _step9$value = _step9.value,
                s = _step9$value.s,
                params = _step9$value.params;
              var found = conv.opFuncs[s] || [];
              var _iterator10 = _createForOfIteratorHelper$b(found),
                _step10;
              try {
                var _loop5 = function _loop5() {
                    var _argsArr$filter$find;
                    var _step10$value = _step10.value,
                      op = _step10$value.op,
                      argsOrder = _step10$value.argsOrder;
                    var argsArr = params.map(convertFuncArg);
                    opKey = op;
                    if (op === "!compare") {
                      if (parentSpel.type.startsWith("op-") && parentSpel.children.length == 2 && parentSpel.children[1].type == "number" && parentSpel.children[1].val === 0) {
                        return {
                          v: {
                            type: "!compare",
                            children: argsArr
                          }
                        };
                      } else {
                        errs.push("Result of compareTo() should be compared to 0");
                      }
                    }
                    foundSign = s;
                    errs = [];
                    var opDef = config.operators[opKey];
                    var spelOp = opDef.spelOp,
                      valueTypes = opDef.valueTypes;
                    var argsObj = Object.fromEntries(argsOrder.map(function (argKey, i) {
                      return [argKey, argsArr[i]];
                    }));
                    var field = argsObj["0"];
                    var convertedArgs = Object.keys(argsObj).filter(function (k) {
                      return parseInt(k) > 0;
                    }).map(function (k) {
                      return argsObj[k];
                    });
                    var valueType = (_argsArr$filter$find = argsArr.filter(function (a) {
                      return !!a;
                    }).find(function (_ref10) {
                      var valueSrc = _ref10.valueSrc;
                      return valueSrc === "value";
                    })) === null || _argsArr$filter$find === void 0 ? void 0 : _argsArr$filter$find.valueType;
                    if (valueTypes && valueType && !valueTypes.includes(valueType)) {
                      errs.push("Op supports types ".concat(valueTypes, ", but got ").concat(valueType));
                    }
                    if (!errs.length) {
                      return {
                        v: buildRule(config, meta, field, opKey, convertedArgs, spel)
                      };
                    }
                  },
                  _ret;
                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                  _ret = _loop5();
                  if (_ret) return _ret.v;
                }
              } catch (err) {
                _iterator10.e(err);
              } finally {
                _iterator10.f();
              }
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
          if (opKey && errs.length) {
            meta.errors.push("Signature ".concat(foundSign, " - looks like convertable to ").concat(opKey, ", but: ").concat(errs.join("; ")));
          }
          return undefined;
        };
        var buildRule = function buildRule(config, meta, field, opKey, convertedArgs, spel) {
          var _field3, _opConfig2;
          if (convertedArgs.filter(function (v) {
            return v === undefined;
          }).length) {
            return undefined;
          }
          var fieldSrc = (_field3 = field) !== null && _field3 !== void 0 && _field3.func ? "func" : "field";
          if (isObject$a(field) && field.valueSrc) {
            // if comed from convertFuncToOp()
            fieldSrc = field.valueSrc;
            field = field.value;
          }
          var fieldConfig = getFieldConfig$8(config, field);
          if (!fieldConfig) {
            meta.errors.push("No config for field ".concat(field));
            return undefined;
          }
          var parentFieldConfig = getFieldConfig$8(config, spel === null || spel === void 0 ? void 0 : spel._groupField);
          var isRuleGroup = fieldConfig.type == "!group";
          isRuleGroup && fieldConfig.mode == "array";
          var isInRuleGroup = (parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.type) == "!group";
          var opConfig = config.operators[opKey];
          var reversedOpConfig = config.operators[(_opConfig2 = opConfig) === null || _opConfig2 === void 0 ? void 0 : _opConfig2.reversedOp];
          var opNeedsReverse = (spel === null || spel === void 0 ? void 0 : spel.not) && ["between"].includes(opKey);
          var opCanReverse = !!reversedOpConfig;
          var canRev = opCanReverse && (!!config.settings.reverseOperatorsForNot || opNeedsReverse || !isRuleGroup && isInRuleGroup // 2+ rules in rule-group should be flat. see inits.with_not_and_in_some in test
          );
          var needRev = (spel === null || spel === void 0 ? void 0 : spel.not) && canRev || opNeedsReverse;
          if (needRev) {
            // todo: should be already handled at convertOp ?  or there are special cases to handle here, like rule-group ?
            opKey = opConfig.reversedOp;
            opConfig = config.operators[opKey];
            spel.not = !spel.not;
          }
          var needWrapWithNot = !!(spel !== null && spel !== void 0 && spel.not);
          var widget = getWidgetForFieldOp$3(config, field, opKey);
          var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];
          var asyncListValuesArr = convertedArgs.map(function (v) {
            return v.asyncListValues;
          }).filter(function (v) {
            return v != undefined;
          });
          var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;
          var res = {
            type: "rule",
            id: uuid(),
            properties: _objectSpread$z({
              field: field,
              fieldSrc: fieldSrc,
              operator: opKey,
              value: convertedArgs.map(function (v) {
                return v.value;
              }),
              valueSrc: convertedArgs.map(function (v) {
                return v.valueSrc;
              }),
              valueType: convertedArgs.map(function (v) {
                if (v.valueSrc == "value") {
                  return (widgetConfig === null || widgetConfig === void 0 ? void 0 : widgetConfig.type) || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) || v.valueType;
                }
                return v.valueType;
              })
            }, asyncListValues ? {
              asyncListValues: asyncListValues
            } : {})
          };
          if (needWrapWithNot) {
            res = wrapInDefaultConj(res, config, spel.not);
            // spel.not = !spel.not; // why I added this line?
          }
          return res;
        };
        var buildRuleGroup = function buildRuleGroup(_ref11, opKey, convertedArgs, config, meta) {
          var groupFilter = _ref11.groupFilter,
            groupFieldValue = _ref11.groupFieldValue;
          if (groupFieldValue.valueSrc != "field") throw "Bad groupFieldValue: ".concat(JSON.stringify(groupFieldValue));
          var groupField = groupFieldValue.value;
          var groupOpRule = buildRule(config, meta, groupField, opKey, convertedArgs);
          if (!groupOpRule) return undefined;
          var fieldConfig = getFieldConfig$8(config, groupField);
          var mode = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mode;
          var res;
          if ((groupFilter === null || groupFilter === void 0 ? void 0 : groupFilter.type) === "group") {
            res = _objectSpread$z(_objectSpread$z({}, groupFilter || {}), {}, {
              type: "rule_group",
              properties: _objectSpread$z(_objectSpread$z(_objectSpread$z({}, groupOpRule.properties), (groupFilter === null || groupFilter === void 0 ? void 0 : groupFilter.properties) || {}), {}, {
                mode: mode
              })
            });
          } else if (groupFilter) {
            // rule_group in rule_group
            res = _objectSpread$z(_objectSpread$z({}, groupOpRule || {}), {}, {
              type: "rule_group",
              children1: [groupFilter],
              properties: _objectSpread$z(_objectSpread$z({}, groupOpRule.properties), {}, {
                mode: mode
              })
            });
          } else {
            res = _objectSpread$z(_objectSpread$z({}, groupOpRule || {}), {}, {
              type: "rule_group",
              properties: _objectSpread$z(_objectSpread$z({}, groupOpRule.properties), {}, {
                mode: mode
              })
            });
          }
          if (!res.id) res.id = uuid();
          return res;
        };
        var compareArgs = function compareArgs(left, right, spel, conv, config, meta) {
          if (left.type == right.type) {
            if (left.type == "!aggr") {
              var _map = [left.source, right.source].map(function (v) {
                  return convertArg(v, conv, config, meta, spel);
                }),
                _map2 = _slicedToArray$1(_map, 2),
                leftSource = _map2[0],
                rightSource = _map2[1];
              //todo: check same filter
              return leftSource.value == rightSource.value;
            } else {
              var _map3 = [left, right].map(function (v) {
                  return convertArg(v, conv, config, meta, spel);
                }),
                _map4 = _slicedToArray$1(_map3, 2),
                leftVal = _map4[0],
                rightVal = _map4[1];
              return leftVal.value == rightVal.value;
            }
          }
          return false;
        };
        var buildSimpleSwitch = function buildSimpleSwitch(val, conv, config, meta) {
          var children1 = {};
          var cond = null;
          var caseI = buildCase(cond, val, conv, config, meta);
          if (caseI) {
            children1[caseI.id] = caseI;
          }
          var res = {
            type: "switch_group",
            id: uuid(),
            children1: children1,
            properties: {}
          };
          return res;
        };
        var buildCase = function buildCase(cond, val, conv, config, meta) {
          var spel = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          var valProperties = buildCaseValProperties(config, meta, conv, val, spel);
          var caseI;
          if (cond) {
            caseI = convertToTree(cond, conv, config, meta, spel);
            if (caseI && caseI.type) {
              if (caseI.type != "group") {
                caseI = wrapInDefaultConj(caseI, config);
              }
              caseI.type = "case_group";
            } else {
              meta.errors.push("Unexpected case: ".concat(JSON.stringify(caseI)));
              caseI = undefined;
            }
          } else {
            caseI = {
              id: uuid(),
              type: "case_group",
              properties: {}
            };
          }
          if (caseI) {
            caseI.properties = _objectSpread$z(_objectSpread$z({}, caseI.properties), valProperties);
          }
          return caseI;
        };

        /**
         * @deprecated
         */
        var buildCaseValueConcat = function buildCaseValueConcat(spel, conv, config, meta) {
          var flat = [];
          function _processConcatChildren(children) {
            children.map(function (child) {
              if (child.type === "op-plus") {
                _processConcatChildren(child.children);
              } else {
                var convertedChild = convertArg(child, conv, config, meta, spel);
                if (convertedChild) {
                  flat.push(convertedChild);
                } else {
                  meta.errors.push("Can't convert ".concat(child.type, " in concatenation"));
                }
              }
            });
          }
          _processConcatChildren(spel.children);
          return {
            valueSrc: "value",
            valueType: "case_value",
            value: flat
          };
        };
        var buildCaseValProperties = function buildCaseValProperties(config, meta, conv, val) {
          var _config$settings$case2, _convVal;
          var spel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var valProperties = {};
          var convVal;
          var widget;
          var widgetConfig;
          var caseValueFieldConfig = getFieldConfig$8(config, "!case_value");
          if ((val === null || val === void 0 ? void 0 : val.type) === "op-plus" && ((_config$settings$case2 = config.settings.caseValueField) === null || _config$settings$case2 === void 0 ? void 0 : _config$settings$case2.type) === "case_value") {
            /**
             * @deprecated
             */
            widget = "case_value";
            convVal = buildCaseValueConcat(val, conv, config, meta);
          } else {
            widget = caseValueFieldConfig === null || caseValueFieldConfig === void 0 ? void 0 : caseValueFieldConfig.mainWidget;
            widgetConfig = config.widgets[widget];
            convVal = convertArg(val, conv, config, meta, spel);
            if (convVal && convVal.valueSrc === "value") {
              var _widgetConfig;
              convVal.valueType = ((_widgetConfig = widgetConfig) === null || _widgetConfig === void 0 ? void 0 : _widgetConfig.type) || (caseValueFieldConfig === null || caseValueFieldConfig === void 0 ? void 0 : caseValueFieldConfig.type) || convVal.valueType;
            }
          }
          var widgetDef = config.widgets[widget];
          if (widget === "case_value") {
            /**
             * @deprecated
             */
            var importCaseValue = widgetDef === null || widgetDef === void 0 ? void 0 : widgetDef.spelImportValue;
            if (importCaseValue) {
              var _importCaseValue$call = importCaseValue.call(config.ctx, convVal),
                _importCaseValue$call2 = _slicedToArray$1(_importCaseValue$call, 2),
                normVal = _importCaseValue$call2[0],
                normErrors = _importCaseValue$call2[1];
              normErrors.map(function (e) {
                return meta.errors.push(e);
              });
              if (normVal != undefined) {
                var _widgetDef$type;
                valProperties = {
                  value: [normVal],
                  valueSrc: ["value"],
                  valueType: [(_widgetDef$type = widgetDef === null || widgetDef === void 0 ? void 0 : widgetDef.type) !== null && _widgetDef$type !== void 0 ? _widgetDef$type : "case_value"],
                  field: "!case_value"
                };
              }
            }
          } else if (convVal != undefined && ((_convVal = convVal) === null || _convVal === void 0 ? void 0 : _convVal.value) != undefined) {
            valProperties = {
              value: [convVal.value],
              valueSrc: [convVal.valueSrc],
              valueType: [convVal.valueType],
              field: "!case_value"
            };
          }
          return valProperties;
        };

        // const wrapInDefaultConjRuleGroup = (rule, parentField, parentFieldConfig, config, conj) => {
        //   if (!rule) return undefined;
        //   return {
        //     type: "rule_group",
        //     id: uuid(),
        //     children1: { [rule.id]: rule },
        //     properties: {
        //       conjunction: conj || defaultGroupConjunction(config, parentFieldConfig),
        //       not: false,
        //       field: parentField,
        //     }
        //   };
        // };

        var wrapInDefaultConj = function wrapInDefaultConj(rule, config) {
          var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          return {
            type: "group",
            id: uuid(),
            children1: _defineProperty$4({}, rule.id, rule),
            properties: {
              conjunction: defaultConjunction(config),
              not: not || false
            }
          };
        };
        const Import = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          _loadFromJsonLogic,
          _loadFromSpel,
          getTree,
          isImmutableTree,
          isJsonLogic,
          isTree,
          jsToImmutable,
          loadFromJsonLogic,
          loadFromSpel,
          loadTree
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function ownKeys$y(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$y(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$y(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$y(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        var getDefaultField = function getDefaultField(config) {
          var canGetFirst = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var parentRuleGroupPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var defaultField = config.settings.defaultField;
          var f = (!parentRuleGroupPath ? defaultField : getDefaultSubField(config, parentRuleGroupPath)) || canGetFirst && getFirstField(config, parentRuleGroupPath) || null;
          // if default LHS is func, convert to Immutable
          if (f != null && typeof f !== "string" && !isImmutable$1(f)) {
            f = jsToImmutable(f);
          }
          return f;
        };
        var getDefaultSubField = function getDefaultSubField(config) {
          var _config$settings;
          var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          if (!parentRuleGroupPath) return null;
          var fieldSeparator = (config === null || config === void 0 || (_config$settings = config.settings) === null || _config$settings === void 0 ? void 0 : _config$settings.fieldSeparator) || ".";
          var parentRuleGroupConfig = getFieldConfig$8(config, parentRuleGroupPath);
          var f = parentRuleGroupConfig === null || parentRuleGroupConfig === void 0 ? void 0 : parentRuleGroupConfig.defaultField;
          if (f) {
            f = [].concat(_toConsumableArray(getFieldParts$3(parentRuleGroupPath)), [f]).join(fieldSeparator);
          }
          return f;
        };
        var getDefaultFieldSrc = function getDefaultFieldSrc(config) {
          var _config$settings$fiel;
          var canGetFirst = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          return canGetFirst && ((_config$settings$fiel = config.settings.fieldSources) === null || _config$settings$fiel === void 0 ? void 0 : _config$settings$fiel[0]) || "field";
        };
        var getDefaultOperator = function getDefaultOperator(config, field) {
          var canGetFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          var fieldConfig = getFieldConfig$8(config, field);
          var fieldOperators = (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.operators) || [];
          var globalDefaultOperator = config.settings.defaultOperator;
          if (globalDefaultOperator && !fieldOperators.includes(globalDefaultOperator)) globalDefaultOperator = null;
          var fieldDefaultOperator = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.defaultOperator;
          var fieldOwnDefaultOperator = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.ownDefaultOperator;
          var firstOperator = canGetFirst ? getFirstOperator(config, field) : null;
          var op = fieldOwnDefaultOperator || globalDefaultOperator || fieldDefaultOperator || firstOperator;
          return op;
        };

        //used for complex operators like proximity
        var defaultOperatorOptions = function defaultOperatorOptions(config, operator, field) {
          var operatorConfig = operator ? getOperatorConfig$4(config, operator, field) : null;
          if (!operatorConfig) return null; //new Immutable.Map();
          return operatorConfig.options ? new Immutable.Map(operatorConfig.options && operatorConfig.options.defaults || {}) : null;
        };
        var defaultRuleProperties = function defaultRuleProperties(config) {
          var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var item = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var canUseDefaultFieldAndOp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
          var canGetFirst = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          var field = null,
            operator = null,
            fieldSrc = null;
          var showErrorMessage = config.settings.showErrorMessage;
          if (item) {
            var _item$properties, _item$properties2, _item$properties3;
            fieldSrc = item === null || item === void 0 || (_item$properties = item.properties) === null || _item$properties === void 0 ? void 0 : _item$properties.fieldSrc;
            field = item === null || item === void 0 || (_item$properties2 = item.properties) === null || _item$properties2 === void 0 ? void 0 : _item$properties2.field;
            operator = item === null || item === void 0 || (_item$properties3 = item.properties) === null || _item$properties3 === void 0 ? void 0 : _item$properties3.operator;
          } else if (canUseDefaultFieldAndOp) {
            field = getDefaultField(config, canGetFirst, parentRuleGroupPath);
            if (field) {
              fieldSrc = isImmutable$1(field) ? "func" : "field";
            } else {
              fieldSrc = getDefaultFieldSrc(config);
            }
            operator = getDefaultOperator(config, field, true);
          } else {
            fieldSrc = getDefaultFieldSrc(config);
          }
          var current = new Immutable.Map({
            fieldSrc: fieldSrc,
            field: field,
            operator: operator,
            value: new Immutable.List(),
            valueSrc: new Immutable.List(),
            //used for complex operators like proximity
            operatorOptions: defaultOperatorOptions(config, operator, field)
          });
          if (showErrorMessage) {
            current = current.set("valueError", new Immutable.List());
          }
          if (field && operator) {
            var canFix = false;
            var _getNewValueForFieldO = getNewValueForFieldOp(config, config, current, field, operator, "operator", canFix),
              newValue = _getNewValueForFieldO.newValue,
              newValueSrc = _getNewValueForFieldO.newValueSrc,
              newValueType = _getNewValueForFieldO.newValueType,
              newValueError = _getNewValueForFieldO.newValueError,
              newFieldError = _getNewValueForFieldO.newFieldError;
            current = current.set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType);
            if (showErrorMessage) {
              current = current.set("valueError", newValueError).set("fieldError", newFieldError);
            }
          }
          return current;
        };
        var defaultGroupConjunction$1 = function defaultGroupConjunction(config) {
          var fieldConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          fieldConfig = getFieldConfig$8(config, fieldConfig); // if `fieldConfig` is field name, not config
          var conjs = fieldConfig && fieldConfig.conjunctions || Object.keys(config.conjunctions);
          if (conjs.length == 1) return conjs[0];
          return config.settings.defaultGroupConjunction || config.settings.defaultConjunction || conjs[0];
        };
        var defaultConjunction = function defaultConjunction(config) {
          return config.settings.defaultConjunction || Object.keys(config.conjunctions)[0];
        };
        var defaultGroupProperties = function defaultGroupProperties(config) {
          var fieldConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return new Immutable.Map({
            conjunction: defaultGroupConjunction$1(config, fieldConfig),
            not: false
          });
        };
        var defaultItemProperties = function defaultItemProperties(config, item) {
          var _item$properties4;
          return item && item.type == "group" ? defaultGroupProperties(config, item === null || item === void 0 || (_item$properties4 = item.properties) === null || _item$properties4 === void 0 ? void 0 : _item$properties4.field) : defaultRuleProperties(config, null, item);
        };
        var defaultRule = function defaultRule(id, config) {
          return _defineProperty$4({}, id, new Immutable.Map({
            type: "rule",
            id: id,
            properties: defaultRuleProperties(config)
          }));
        };
        var defaultRoot$1 = function defaultRoot(config) {
          var canAddDefaultRule = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          return new Immutable.Map({
            type: "group",
            id: uuid(),
            children1: new Immutable.OrderedMap(canAddDefaultRule ? _objectSpread$y({}, defaultRule(uuid(), config)) : {}),
            properties: defaultGroupProperties(config)
          });
        };
        var createListWithOneElement$2 = function createListWithOneElement(el) {
          if (isImmutableList(el)) return el; // already Immutable list
          return createListFromArray([el]);
        };
        var createListFromArray = function createListFromArray(arr) {
          if (isImmutableList(arr)) return arr; // already Immutable list
          return new Immutable.List(arr);
        };
        var emptyProperties$1 = function emptyProperties() {
          return new Immutable.Map();
        };
        const defaultUtils = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          createListFromArray,
          createListWithOneElement: createListWithOneElement$2,
          defaultConjunction,
          defaultGroupConjunction: defaultGroupConjunction$1,
          defaultGroupProperties,
          defaultItemProperties,
          defaultOperatorOptions,
          defaultRoot: defaultRoot$1,
          defaultRule,
          defaultRuleProperties,
          emptyProperties: emptyProperties$1,
          getDefaultField,
          getDefaultFieldSrc,
          getDefaultOperator,
          getDefaultSubField
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function _createForOfIteratorHelper$a(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$a(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$a(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$a(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, minLen);
        }
        function _arrayLikeToArray$a(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function ownKeys$x(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$x(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$x(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$x(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        var queryString = function queryString(item, config) {
          var isForDisplay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var isDebugMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          //meta is mutable
          var meta = {
            errors: [],
            settings: {
              isForDisplay: isForDisplay,
              isDebugMode: isDebugMode
            }
          };
          var extendedConfig = extendConfig(config, undefined, false);
          var res = formatItem$4(item, extendedConfig, meta, null);
          if (meta.errors.length) console.warn("Errors while exporting to string:", meta.errors);
          return res;
        };
        var formatItem$4 = function formatItem(item, config, meta) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          if (!item) return undefined;
          var type = item.get("type");
          item.get("children1");
          if (type === "group" || type === "rule_group") {
            return formatGroup$4(item, config, meta, parentField);
          } else if (type === "rule") {
            return formatRule$4(item, config, meta, parentField);
          }
          return undefined;
        };
        var formatGroup$4 = function formatGroup(item, config, meta) {
          var _config$operators$gro, _config$operators$gro2;
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var _meta$settings = meta.settings,
            isForDisplay = _meta$settings.isForDisplay,
            isDebugMode = _meta$settings.isDebugMode;
          var type = item.get("type");
          var properties = item.get("properties") || new Map$2();
          var mode = properties.get("mode");
          var children = item.get("children1") || new List();
          var isRuleGroup = type === "rule_group";
          // TIP: don't cut group for mode == 'struct' and don't do aggr format (maybe later)
          var groupField = isRuleGroup && mode == "array" ? properties.get("field") : null;
          var groupOperator = type === "rule_group" ? properties.get("operator") : null;
          var groupOperatorCardinality = groupOperator ? (_config$operators$gro = (_config$operators$gro2 = config.operators[groupOperator]) === null || _config$operators$gro2 === void 0 ? void 0 : _config$operators$gro2.cardinality) !== null && _config$operators$gro !== void 0 ? _config$operators$gro : 1 : undefined;
          var canHaveEmptyChildren = isRuleGroup && mode === "array" && groupOperatorCardinality >= 1;
          var not = properties.get("not");
          var list = children.map(function (currentChild) {
            return formatItem$4(currentChild, config, meta, groupField);
          }).filter(function (currentChild) {
            return typeof currentChild !== "undefined";
          });
          if (!canHaveEmptyChildren && !list.size && !isDebugMode) {
            return undefined;
          }
          var conjunction = properties.get("conjunction");
          if (!conjunction) conjunction = defaultConjunction(config);
          var conjunctionDefinition = config.conjunctions[conjunction];
          var conjStr = list.size ? conjunctionDefinition.formatConj.call(config.ctx, list, conjunction, not, isForDisplay) : null;
          var ret;
          if (groupField) {
            var aggrArgs = formatRule$4(item, config, meta, parentField, true);
            if (aggrArgs) {
              var _config$settings$form;
              var isRev = aggrArgs.pop();
              var args = [conjStr].concat(_toConsumableArray(aggrArgs));
              ret = (_config$settings$form = config.settings.formatAggr).call.apply(_config$settings$form, [config.ctx].concat(_toConsumableArray(args)));
              if (isRev) {
                ret = config.settings.formatReverse.call(config.ctx, ret, null, null, null, null, isForDisplay);
              }
            }
          } else {
            ret = conjStr;
          }
          if (isDebugMode && ret == null) {
            ret = "?";
          }
          return ret;
        };
        var formatItemValue$1 = function formatItemValue(config, properties, meta, _operator, parentField) {
          var _meta$settings2 = meta.settings;
          _meta$settings2.isForDisplay;
          var isDebugMode = _meta$settings2.isDebugMode;
          var field = properties.get("field");
          var iValueSrc = properties.get("valueSrc");
          var iValueType = properties.get("valueType");
          var fieldDef = getFieldConfig$8(config, field) || {};
          var operator = _operator || properties.get("operator");
          var operatorDef = getOperatorConfig$4(config, operator, field) || {};
          var cardinality = getOpCardinality$1(operatorDef);
          var iValue = properties.get("value");
          var asyncListValues = properties.get("asyncListValues");
          var valueSrcs = [];
          var valueTypes = [];
          var formattedValue;
          var fvalue;
          if (iValue != undefined) {
            fvalue = iValue.map(function (currentValue, ind) {
              var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
              var valueType = iValueType ? iValueType.get(ind) : null;
              var cValue = !isDebugMode ? completeValue(currentValue, valueSrc, config) : currentValue;
              var widget = getWidgetForFieldOp$3(config, field, operator, valueSrc);
              var fieldWidgetDef = getFieldWidgetConfig$3(config, field, operator, widget, valueSrc, {
                forExport: true
              });
              var fv = formatValue$3(config, meta, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, parentField, asyncListValues);
              if (fv !== undefined) {
                valueSrcs.push(valueSrc);
                valueTypes.push(valueType);
              }
              return fv;
            });
            var hasUndefinedValues = fvalue.filter(function (v) {
              return v === undefined;
            }).size > 0;
            var isOK = !hasUndefinedValues && fvalue.size === cardinality;
            if (isOK) {
              formattedValue = cardinality == 1 ? fvalue.first() : fvalue;
            }
          }
          if (isDebugMode && !formattedValue) {
            formattedValue = cardinality > 1 ? new List(Array.from({
              length: cardinality
            }).map(function (_, i) {
              var _fvalue$get, _fvalue;
              return (_fvalue$get = (_fvalue = fvalue) === null || _fvalue === void 0 ? void 0 : _fvalue.get(i)) !== null && _fvalue$get !== void 0 ? _fvalue$get : "?";
            })) : "?";
          }
          return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];
        };
        var buildFnToFormatOp$2 = function buildFnToFormatOp(operator, operatorDefinition, meta) {
          var isDebugMode = meta.settings.isDebugMode;
          var fop = (operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.labelForFormat) || operator;
          var cardinality = getOpCardinality$1(operatorDefinition);
          var fn;
          if (cardinality == 0) {
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              return "".concat(field, " ").concat(fop);
            };
          } else if (cardinality == 1) {
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              if (isDebugMode && op === "?" && values === "?") {
                return field && field !== "?" ? "".concat(field, " ?") : "?";
              }
              return "".concat(field, " ").concat(fop, " ").concat(values);
            };
          } else if (cardinality == 2) {
            // between
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              var _values$first, _values$get;
              var valFrom = values === null || values === void 0 || (_values$first = values.first) === null || _values$first === void 0 ? void 0 : _values$first.call(values);
              var valTo = values === null || values === void 0 || (_values$get = values.get) === null || _values$get === void 0 ? void 0 : _values$get.call(values, 1);
              return "".concat(field, " ").concat(fop, " ").concat(valFrom, " AND ").concat(valTo);
            };
          }
          return fn;
        };
        var formatRule$4 = function formatRule(item, config, meta) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var returnArgs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          var _meta$settings3 = meta.settings,
            isForDisplay = _meta$settings3.isForDisplay,
            isDebugMode = _meta$settings3.isDebugMode;
          var properties = item.get("properties") || new Map$2();
          var field = properties.get("field");
          var fieldSrc = properties.get("fieldSrc");
          var operator = properties.get("operator");
          var operatorOptions = properties.get("operatorOptions");
          if ((field == null || operator == null) && !isDebugMode) return undefined;
          var fieldDef = getFieldConfig$8(config, field) || {};
          var operatorDef = getOperatorConfig$4(config, operator, field) || {};
          var reversedOp = operatorDef.reversedOp;
          var revOperatorDef = getOperatorConfig$4(config, reversedOp, field) || {};

          //check op
          var isRev = false;
          var fn = operatorDef.formatOp;
          if (!fn && reversedOp) {
            fn = revOperatorDef.formatOp;
            if (fn) {
              isRev = true;
              var _ref = [reversedOp, operator];
              operator = _ref[0];
              reversedOp = _ref[1];
              var _ref2 = [revOperatorDef, operatorDef];
              operatorDef = _ref2[0];
              revOperatorDef = _ref2[1];
            }
          }
          if (isDebugMode && !operator) {
            operator = "?";
          }

          //find fn to format expr
          if (!fn) fn = buildFnToFormatOp$2(operator, operatorDef, meta);
          if (!fn) return undefined;

          //format field
          var formattedField = fieldSrc === "func" ? formatFunc$3(config, meta, field, parentField) : formatField$2(config, meta, field, parentField);
          if (formattedField == undefined) return undefined;

          //format value
          var _formatItemValue = formatItemValue$1(config, properties, meta, operator, parentField),
            _formatItemValue2 = _slicedToArray$1(_formatItemValue, 3),
            formattedValue = _formatItemValue2[0],
            valueSrc = _formatItemValue2[1],
            valueType = _formatItemValue2[2];
          if (formattedValue === undefined) {
            return undefined;
          }
          var args = [formattedField, operator, formattedValue, valueSrc, valueType, omit$2(operatorDef, opDefKeysToOmit), operatorOptions, isForDisplay, fieldDef, isRev];
          if (returnArgs) {
            return args;
          } else {
            var _fn;
            //format expr
            var ret = (_fn = fn).call.apply(_fn, [config.ctx].concat(args));

            //rev
            if (isRev) {
              ret = config.settings.formatReverse.call(config.ctx, ret, operator, reversedOp, operatorDef, revOperatorDef, isForDisplay);
            }
            return ret;
          }
        };
        var formatValue$3 = function formatValue(config, meta, value, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, opDef) {
          var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;
          var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;
          var _meta$settings4 = meta.settings,
            isForDisplay = _meta$settings4.isForDisplay,
            isDebugMode = _meta$settings4.isDebugMode;
          if (value === undefined) {
            if (isDebugMode) {
              if ((fieldWidgetDef === null || fieldWidgetDef === void 0 ? void 0 : fieldWidgetDef.jsType) === "array") {
                return [];
              }
              return "?";
            } else {
              return undefined;
            }
          }
          var ret;
          if (valueSrc == "field") {
            ret = formatField$2(config, meta, value, parentField);
          } else if (valueSrc == "func") {
            ret = formatFunc$3(config, meta, value, parentField);
          } else {
            if (typeof (fieldWidgetDef === null || fieldWidgetDef === void 0 ? void 0 : fieldWidgetDef.formatValue) === "function") {
              var fn = fieldWidgetDef.formatValue;
              var args = [value, _objectSpread$x(_objectSpread$x({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
                asyncListValues: asyncListValues
              }),
              //useful options: valueFormat for date/time
              omit$2(fieldWidgetDef, widgetDefKeysToOmit), isForDisplay];
              if (operator) {
                args.push(operator);
                args.push(opDef);
              }
              if (valueSrc == "field") {
                var valFieldDefinition = getFieldConfig$8(config, value) || {};
                args.push(valFieldDefinition);
              }
              ret = fn.call.apply(fn, [config.ctx].concat(args));
            } else {
              ret = value;
            }
          }
          return ret;
        };
        var formatField$2 = function formatField(config, meta, field) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var cutParentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
          var _meta$settings5 = meta.settings,
            isForDisplay = _meta$settings5.isForDisplay,
            isDebugMode = _meta$settings5.isDebugMode;
          var _config$settings = config.settings;
          _config$settings.fieldSeparator;
          var fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay;
          var ret = null;
          if (field) {
            var fieldDefinition = getFieldConfig$8(config, field) || {};
            var fieldParts = getFieldParts$3(field, config);
            var fieldPartsLabels = getFieldPathLabels$2(field, config, cutParentField ? parentField : null);
            var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparatorDisplay) : null;
            var fieldLabel2 = fieldDefinition.label2 || fieldFullLabel;
            var formatFieldFn = config.settings.formatField;
            var fieldName = formatFieldName(field, config, meta, cutParentField ? parentField : null, {
              useTableName: true
            });
            ret = formatFieldFn(fieldName, fieldParts, fieldLabel2, fieldDefinition, config, isForDisplay);
          } else if (isDebugMode) {
            ret = "?";
          }
          return ret;
        };
        var formatFunc$3 = function formatFunc(config, meta, funcValue) {
          var _funcValue$get, _funcValue$get2, _args$keySeq;
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var _meta$settings6 = meta.settings,
            isForDisplay = _meta$settings6.isForDisplay,
            isDebugMode = _meta$settings6.isDebugMode;
          var funcKey = funcValue === null || funcValue === void 0 || (_funcValue$get = funcValue.get) === null || _funcValue$get === void 0 ? void 0 : _funcValue$get.call(funcValue, "func");
          if (!funcKey) {
            return isDebugMode ? "?()" : undefined;
          }
          var args = (_funcValue$get2 = funcValue.get) === null || _funcValue$get2 === void 0 ? void 0 : _funcValue$get2.call(funcValue, "args");
          var funcConfig = getFuncConfig$2(config, funcKey);
          if (!funcConfig) {
            if (!isDebugMode) {
              meta.errors.push("Func ".concat(funcKey, " is not defined in config"));
              return undefined;
            }
          }
          var funcParts = getFieldParts$3(funcKey, config);
          var funcLastKey = funcParts[funcParts.length - 1];
          var funcName = isForDisplay && (funcConfig === null || funcConfig === void 0 ? void 0 : funcConfig.label) || funcLastKey;
          var formattedArgs = {};
          var gaps = [];
          var missingArgKeys = [];
          var formattedArgsWithNames = {};
          var argsKeys = funcConfig ? Object.keys(funcConfig.args || {}) : (args === null || args === void 0 || (_args$keySeq = args.keySeq) === null || _args$keySeq === void 0 ? void 0 : _args$keySeq.call(args).toArray()) || [];
          var _iterator = _createForOfIteratorHelper$a(argsKeys),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _argValue;
              var argKey = _step.value;
              var argConfig = funcConfig === null || funcConfig === void 0 ? void 0 : funcConfig.args[argKey];
              var fieldDef = getFieldConfig$8(config, argConfig);
              var _ref5 = argConfig || {},
                defaultValue = _ref5.defaultValue,
                isOptional = _ref5.isOptional;
              var defaultValueSrc = defaultValue !== null && defaultValue !== void 0 && defaultValue.func ? "func" : "value";
              var argName = isForDisplay && (argConfig === null || argConfig === void 0 ? void 0 : argConfig.label) || argKey;
              var argVal = args ? args.get(argKey) : undefined;
              var argValue = argVal ? argVal.get("value") : undefined;
              var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
              if (argValueSrc !== "func" && (_argValue = argValue) !== null && _argValue !== void 0 && _argValue.toJS) {
                // value should not be Immutable
                argValue = argValue.toJS();
              }
              var argAsyncListValues = argVal ? argVal.get("asyncListValues") : undefined;
              var formattedArgVal = formatValue$3(config, meta, argValue, argValueSrc, argConfig === null || argConfig === void 0 ? void 0 : argConfig.type, fieldDef, argConfig, null, null, parentField, argAsyncListValues);
              if (argValue != undefined && formattedArgVal === undefined) {
                if (argValueSrc != "func")
                  // don't triger error if args value is another incomplete function
                  meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
              }
              var formattedDefaultVal = void 0;
              if (formattedArgVal === undefined && !isOptional && defaultValue != undefined) {
                formattedDefaultVal = formatValue$3(config, meta, defaultValue, defaultValueSrc, argConfig === null || argConfig === void 0 ? void 0 : argConfig.type, fieldDef, argConfig, null, null, parentField, argAsyncListValues);
                if (formattedDefaultVal === undefined) {
                  if (defaultValueSrc != "func")
                    // don't triger error if args value is another incomplete function
                    meta.errors.push("Can't format default value of arg ".concat(argKey, " for func ").concat(funcKey));
                  return undefined;
                }
              }
              var finalFormattedVal = formattedArgVal !== null && formattedArgVal !== void 0 ? formattedArgVal : formattedDefaultVal;
              if (finalFormattedVal !== undefined) {
                if (gaps.length) {
                  var _iterator2 = _createForOfIteratorHelper$a(argKey),
                    _step2;
                  try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                      var _step2$value = _slicedToArray$1(_step2.value, 2),
                        missedArgKey = _step2$value[0],
                        missedArgName = _step2$value[1];
                      formattedArgs[missedArgKey] = undefined;
                      //formattedArgsWithNames[missedArgName] = undefined;
                    }
                  } catch (err) {
                    _iterator2.e(err);
                  } finally {
                    _iterator2.f();
                  }
                  gaps = [];
                }
                formattedArgs[argKey] = finalFormattedVal;
                formattedArgsWithNames[argName] = finalFormattedVal;
              } else {
                if (!isOptional) missingArgKeys.push(argKey);
                gaps.push([argKey, argName]);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          if (missingArgKeys.length) {
            //meta.errors.push(`Missing vals for args ${missingArgKeys.join(", ")} for func ${funcKey}`);
            if (!isDebugMode) {
              return undefined; // incomplete
            }
          }
          var ret = null;
          if (typeof (funcConfig === null || funcConfig === void 0 ? void 0 : funcConfig.formatFunc) === "function") {
            var fn = funcConfig.formatFunc;
            var _args = [formattedArgs, isForDisplay];
            ret = fn.call.apply(fn, [config.ctx].concat(_args));
          } else {
            var argsStr = Object.entries(isForDisplay ? formattedArgsWithNames : formattedArgs).map(function (_ref3) {
              var _ref4 = _slicedToArray$1(_ref3, 2),
                k = _ref4[0],
                v = _ref4[1];
              return isForDisplay ? "".concat(k, ": ").concat(v) : "".concat(v);
            }).join(", ");
            ret = "".concat(funcName, "(").concat(argsStr, ")");
          }
          return ret;
        };

        // Note: Don't use ":" char inside strings, it's reserved as a namespace

        var EMPTY_GROUP = "EMPTY_GROUP";
        var EMPTY_RULE_GROUP = "EMPTY_RULE_GROUP";
        var EMPTY_QUERY = "EMPTY_QUERY";
        var EMPTY_CASE = "EMPTY_CASE";
        var NO_CONFIG_FOR_FIELD = "NO_CONFIG_FOR_FIELD";
        var NO_CONFIG_FOR_OPERATOR = "NO_CONFIG_FOR_OPERATOR";
        var FIXED_OPERATOR = "FIXED_OPERATOR";
        var NO_CONFIG_FOR_FUNCTION = "NO_CONFIG_FOR_FUNCTION";
        var INVALID_VALUE = "INVALID_VALUE";
        var INVALID_FUNC_ARG_VALUE = "INVALID_FUNC_ARG_VALUE";
        var UNSUPPORTED_FIELD_TYPE = "UNSUPPORTED_FIELD_TYPE";
        var UNSUPPORTED_OPERATOR_FOR_FIELD = "UNSUPPORTED_OPERATOR_FOR_FIELD";
        var INVALID_VALUE_SRC = "INVALID_VALUE_SRC";
        var INCOMPLETE_RULE = "INCOMPLETE_RULE";
        var INCOMPLETE_LHS = "INCOMPLETE_LHS";
        var INCOMPLETE_RHS = "INCOMPLETE_RHS";
        var BAD_MULTISELECT_VALUES = "BAD_MULTISELECT_VALUES";
        var BAD_SELECT_VALUE = "BAD_SELECT_VALUE";
        var INCORRECT_VALUE_TYPE = "INCORRECT_VALUE_TYPE";
        var INCORRECT_VALUE_JS_TYPE = "INCORRECT_VALUE_JS_TYPE";
        var VALUE_LENGTH_CONSTRAINT_FAIL = "VALUE_LENGTH_CONSTRAINT_FAIL";
        var VALUE_MIN_CONSTRAINT_FAIL = "VALUE_MIN_CONSTRAINT_FAIL";
        var VALUE_MAX_CONSTRAINT_FAIL = "VALUE_MAX_CONSTRAINT_FAIL";
        var NO_CONFIG_FOR_FIELD_VALUE = "NO_CONFIG_FOR_FIELD_VALUE";
        var CANT_COMPARE_FIELD_WITH_ITSELF = "CANT_COMPARE_FIELD_WITH_ITSELF";
        var CANT_COMPARE_FIELD_WITH_FIELD = "CANT_COMPARE_FIELD_WITH_FIELD";
        var INCORRECT_FIELD_TYPE = "INCORRECT_FIELD_TYPE";
        var UNSUPPORTED_FUNCTION_FOR_FIELD = "UNSUPPORTED_FUNCTION_FOR_FIELD";
        var REQUIRED_FUNCTION_ARG = "REQUIRED_FUNCTION_ARG";
        var INCORRECT_FUNCTION_RETURN_TYPE = "INCORRECT_FUNCTION_RETURN_TYPE";
        var INVALID_RANGE = "INVALID_RANGE";
        var ITEM_POSITION = "ITEM_POSITION";
        var ITEM_POSITION_ROOT = "ITEM_POSITION_ROOT";
        var ITEM_POSITION_WITH_INDEX_PATH = "ITEM_POSITION_WITH_INDEX_PATH";
        var ITEM_POSITION_IN_CASE = "ITEM_POSITION_IN_CASE";
        var _CONTEXT_MIN_MAX = "range";
        const isString$1 = obj => typeof obj === 'string';
        const defer = () => {
          let res;
          let rej;
          const promise = new Promise((resolve, reject) => {
            res = resolve;
            rej = reject;
          });
          promise.resolve = res;
          promise.reject = rej;
          return promise;
        };
        const makeString = object => {
          if (object == null) return '';
          return '' + object;
        };
        const copy = (a, s, t) => {
          a.forEach(m => {
            if (s[m]) t[m] = s[m];
          });
        };
        const lastOfPathSeparatorRegExp = /###/g;
        const cleanKey = key => key && key.indexOf('###') > -1 ? key.replace(lastOfPathSeparatorRegExp, '.') : key;
        const canNotTraverseDeeper = object => !object || isString$1(object);
        const getLastOfPath = (object, path, Empty) => {
          const stack = !isString$1(path) ? path : path.split('.');
          let stackIndex = 0;
          while (stackIndex < stack.length - 1) {
            if (canNotTraverseDeeper(object)) return {};
            const key = cleanKey(stack[stackIndex]);
            if (!object[key] && Empty) object[key] = new Empty();
            if (Object.prototype.hasOwnProperty.call(object, key)) {
              object = object[key];
            } else {
              object = {};
            }
            ++stackIndex;
          }
          if (canNotTraverseDeeper(object)) return {};
          return {
            obj: object,
            k: cleanKey(stack[stackIndex])
          };
        };
        const setPath = (object, path, newValue) => {
          const _getLastOfPath = getLastOfPath(object, path, Object),
            obj = _getLastOfPath.obj,
            k = _getLastOfPath.k;
          if (obj !== undefined || path.length === 1) {
            obj[k] = newValue;
            return;
          }
          let e = path[path.length - 1];
          let p = path.slice(0, path.length - 1);
          let last = getLastOfPath(object, p, Object);
          while (last.obj === undefined && p.length) {
            e = `${p[p.length - 1]}.${e}`;
            p = p.slice(0, p.length - 1);
            last = getLastOfPath(object, p, Object);
            if (last && last.obj && typeof last.obj[`${last.k}.${e}`] !== 'undefined') {
              last.obj = undefined;
            }
          }
          last.obj[`${last.k}.${e}`] = newValue;
        };
        const pushPath = (object, path, newValue, concat) => {
          const _getLastOfPath2 = getLastOfPath(object, path, Object),
            obj = _getLastOfPath2.obj,
            k = _getLastOfPath2.k;
          obj[k] = obj[k] || [];
          obj[k].push(newValue);
        };
        const getPath = (object, path) => {
          const _getLastOfPath3 = getLastOfPath(object, path),
            obj = _getLastOfPath3.obj,
            k = _getLastOfPath3.k;
          if (!obj) return undefined;
          return obj[k];
        };
        const getPathWithDefaults = (data, defaultData, key) => {
          const value = getPath(data, key);
          if (value !== undefined) {
            return value;
          }
          return getPath(defaultData, key);
        };
        const deepExtend = (target, source, overwrite) => {
          for (const prop in source) {
            if (prop !== '__proto__' && prop !== 'constructor') {
              if (prop in target) {
                if (isString$1(target[prop]) || target[prop] instanceof String || isString$1(source[prop]) || source[prop] instanceof String) {
                  if (overwrite) target[prop] = source[prop];
                } else {
                  deepExtend(target[prop], source[prop], overwrite);
                }
              } else {
                target[prop] = source[prop];
              }
            }
          }
          return target;
        };
        const regexEscape = str => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
        var _entityMap = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;',
          '/': '&#x2F;'
        };
        const escape = data => {
          if (isString$1(data)) {
            return data.replace(/[&<>"'\/]/g, s => _entityMap[s]);
          }
          return data;
        };
        class RegExpCache {
          constructor(capacity) {
            this.capacity = capacity;
            this.regExpMap = new Map();
            this.regExpQueue = [];
          }
          getRegExp(pattern) {
            const regExpFromCache = this.regExpMap.get(pattern);
            if (regExpFromCache !== undefined) {
              return regExpFromCache;
            }
            const regExpNew = new RegExp(pattern);
            if (this.regExpQueue.length === this.capacity) {
              this.regExpMap.delete(this.regExpQueue.shift());
            }
            this.regExpMap.set(pattern, regExpNew);
            this.regExpQueue.push(pattern);
            return regExpNew;
          }
        }
        const chars = [' ', ',', '?', '!', ';'];
        const looksLikeObjectPathRegExpCache = new RegExpCache(20);
        const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
          nsSeparator = nsSeparator || '';
          keySeparator = keySeparator || '';
          const possibleChars = chars.filter(c => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
          if (possibleChars.length === 0) return true;
          const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map(c => c === '?' ? '\\?' : c).join('|')})`);
          let matched = !r.test(key);
          if (!matched) {
            const ki = key.indexOf(keySeparator);
            if (ki > 0 && !r.test(key.substring(0, ki))) {
              matched = true;
            }
          }
          return matched;
        };
        const deepFind = function deepFind(obj, path) {
          let keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
          if (!obj) return undefined;
          if (obj[path]) return obj[path];
          const tokens = path.split(keySeparator);
          let current = obj;
          for (let i = 0; i < tokens.length;) {
            if (!current || typeof current !== 'object') {
              return undefined;
            }
            let next;
            let nextPath = '';
            for (let j = i; j < tokens.length; ++j) {
              if (j !== i) {
                nextPath += keySeparator;
              }
              nextPath += tokens[j];
              next = current[nextPath];
              if (next !== undefined) {
                if (['string', 'number', 'boolean'].indexOf(typeof next) > -1 && j < tokens.length - 1) {
                  continue;
                }
                i += j - i + 1;
                break;
              }
            }
            current = next;
          }
          return current;
        };
        const getCleanedCode = code => code && code.replace('_', '-');
        const consoleLogger = {
          type: 'logger',
          log(args) {
            this.output('log', args);
          },
          warn(args) {
            this.output('warn', args);
          },
          error(args) {
            this.output('error', args);
          },
          output(type, args) {
            if (console && console[type]) console[type].apply(console, args);
          }
        };
        class Logger {
          constructor(concreteLogger) {
            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            this.init(concreteLogger, options);
          }
          init(concreteLogger) {
            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            this.prefix = options.prefix || 'i18next:';
            this.logger = concreteLogger || consoleLogger;
            this.options = options;
            this.debug = options.debug;
          }
          log() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return this.forward(args, 'log', '', true);
          }
          warn() {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            return this.forward(args, 'warn', '', true);
          }
          error() {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }
            return this.forward(args, 'error', '');
          }
          deprecate() {
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }
            return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
          }
          forward(args, lvl, prefix, debugOnly) {
            if (debugOnly && !this.debug) return null;
            if (isString$1(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
            return this.logger[lvl](args);
          }
          create(moduleName) {
            return new Logger(this.logger, _objectSpread3(_objectSpread3({}, {
              prefix: `${this.prefix}:${moduleName}:`
            }), this.options));
          }
          clone(options) {
            options = options || this.options;
            options.prefix = options.prefix || this.prefix;
            return new Logger(this.logger, options);
          }
        }
        var baseLogger = new Logger();
        class EventEmitter {
          constructor() {
            this.observers = {};
          }
          on(events, listener) {
            events.split(' ').forEach(event => {
              if (!this.observers[event]) this.observers[event] = new Map();
              const numListeners = this.observers[event].get(listener) || 0;
              this.observers[event].set(listener, numListeners + 1);
            });
            return this;
          }
          off(event, listener) {
            if (!this.observers[event]) return;
            if (!listener) {
              delete this.observers[event];
              return;
            }
            this.observers[event].delete(listener);
          }
          emit(event) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            if (this.observers[event]) {
              const cloned = Array.from(this.observers[event].entries());
              cloned.forEach(_ref => {
                let _ref35 = _slicedToArray2(_ref, 2),
                  observer = _ref35[0],
                  numTimesAdded = _ref35[1];
                for (let i = 0; i < numTimesAdded; i++) {
                  observer(...args);
                }
              });
            }
            if (this.observers['*']) {
              const cloned = Array.from(this.observers['*'].entries());
              cloned.forEach(_ref2 => {
                let _ref36 = _slicedToArray2(_ref2, 2),
                  observer = _ref36[0],
                  numTimesAdded = _ref36[1];
                for (let i = 0; i < numTimesAdded; i++) {
                  observer.apply(observer, [event, ...args]);
                }
              });
            }
          }
        }
        class ResourceStore extends EventEmitter {
          constructor(data) {
            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
              ns: ['translation'],
              defaultNS: 'translation'
            };
            super();
            this.data = data || {};
            this.options = options;
            if (this.options.keySeparator === undefined) {
              this.options.keySeparator = '.';
            }
            if (this.options.ignoreJSONStructure === undefined) {
              this.options.ignoreJSONStructure = true;
            }
          }
          addNamespaces(ns) {
            if (this.options.ns.indexOf(ns) < 0) {
              this.options.ns.push(ns);
            }
          }
          removeNamespaces(ns) {
            const index = this.options.ns.indexOf(ns);
            if (index > -1) {
              this.options.ns.splice(index, 1);
            }
          }
          getResource(lng, ns, key) {
            let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
            const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
            const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
            let path;
            if (lng.indexOf('.') > -1) {
              path = lng.split('.');
            } else {
              path = [lng, ns];
              if (key) {
                if (Array.isArray(key)) {
                  path.push(...key);
                } else if (isString$1(key) && keySeparator) {
                  path.push(...key.split(keySeparator));
                } else {
                  path.push(key);
                }
              }
            }
            const result = getPath(this.data, path);
            if (!result && !ns && !key && lng.indexOf('.') > -1) {
              lng = path[0];
              ns = path[1];
              key = path.slice(2).join('.');
            }
            if (result || !ignoreJSONStructure || !isString$1(key)) return result;
            return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
          }
          addResource(lng, ns, key, value) {
            let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
              silent: false
            };
            const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
            let path = [lng, ns];
            if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
            if (lng.indexOf('.') > -1) {
              path = lng.split('.');
              value = ns;
              ns = path[1];
            }
            this.addNamespaces(ns);
            setPath(this.data, path, value);
            if (!options.silent) this.emit('added', lng, ns, key, value);
          }
          addResources(lng, ns, resources) {
            let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
              silent: false
            };
            for (const m in resources) {
              if (isString$1(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {
                silent: true
              });
            }
            if (!options.silent) this.emit('added', lng, ns, resources);
          }
          addResourceBundle(lng, ns, resources, deep, overwrite) {
            let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
              silent: false,
              skipCopy: false
            };
            let path = [lng, ns];
            if (lng.indexOf('.') > -1) {
              path = lng.split('.');
              deep = resources;
              resources = ns;
              ns = path[1];
            }
            this.addNamespaces(ns);
            let pack = getPath(this.data, path) || {};
            if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));
            if (deep) {
              deepExtend(pack, resources, overwrite);
            } else {
              pack = _objectSpread3(_objectSpread3({}, pack), resources);
            }
            setPath(this.data, path, pack);
            if (!options.silent) this.emit('added', lng, ns, resources);
          }
          removeResourceBundle(lng, ns) {
            if (this.hasResourceBundle(lng, ns)) {
              delete this.data[lng][ns];
            }
            this.removeNamespaces(ns);
            this.emit('removed', lng, ns);
          }
          hasResourceBundle(lng, ns) {
            return this.getResource(lng, ns) !== undefined;
          }
          getResourceBundle(lng, ns) {
            if (!ns) ns = this.options.defaultNS;
            if (this.options.compatibilityAPI === 'v1') return _objectSpread3(_objectSpread3({}, {}), this.getResource(lng, ns));
            return this.getResource(lng, ns);
          }
          getDataByLanguage(lng) {
            return this.data[lng];
          }
          hasLanguageSomeTranslations(lng) {
            const data = this.getDataByLanguage(lng);
            const n = data && Object.keys(data) || [];
            return !!n.find(v => data[v] && Object.keys(data[v]).length > 0);
          }
          toJSON() {
            return this.data;
          }
        }
        var postProcessor = {
          processors: {},
          addPostProcessor(module) {
            this.processors[module.name] = module;
          },
          handle(processors, value, key, options, translator) {
            processors.forEach(processor => {
              if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);
            });
            return value;
          }
        };
        const checkedLoadedFor = {};
        class Translator extends EventEmitter {
          constructor(services) {
            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            super();
            copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, this);
            this.options = options;
            if (this.options.keySeparator === undefined) {
              this.options.keySeparator = '.';
            }
            this.logger = baseLogger.create('translator');
          }
          changeLanguage(lng) {
            if (lng) this.language = lng;
          }
          exists(key) {
            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
              interpolation: {}
            };
            if (key === undefined || key === null) {
              return false;
            }
            const resolved = this.resolve(key, options);
            return resolved && resolved.res !== undefined;
          }
          extractFromKey(key, options) {
            let nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;
            if (nsSeparator === undefined) nsSeparator = ':';
            const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
            let namespaces = options.ns || this.options.defaultNS || [];
            const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
            const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
            if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
              const m = key.match(this.interpolator.nestingRegexp);
              if (m && m.length > 0) {
                return {
                  key,
                  namespaces
                };
              }
              const parts = key.split(nsSeparator);
              if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
              key = parts.join(keySeparator);
            }
            if (isString$1(namespaces)) namespaces = [namespaces];
            return {
              key,
              namespaces
            };
          }
          translate(keys, options, lastKey) {
            if (typeof options !== 'object' && this.options.overloadTranslationOptionHandler) {
              options = this.options.overloadTranslationOptionHandler(arguments);
            }
            if (typeof options === 'object') options = _objectSpread3({}, options);
            if (!options) options = {};
            if (keys === undefined || keys === null) return '';
            if (!Array.isArray(keys)) keys = [String(keys)];
            const returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;
            const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
            const _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
              key = _this$extractFromKey.key,
              namespaces = _this$extractFromKey.namespaces;
            const namespace = namespaces[namespaces.length - 1];
            const lng = options.lng || this.language;
            const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
            if (lng && lng.toLowerCase() === 'cimode') {
              if (appendNamespaceToCIMode) {
                const nsSeparator = options.nsSeparator || this.options.nsSeparator;
                if (returnDetails) {
                  return {
                    res: `${namespace}${nsSeparator}${key}`,
                    usedKey: key,
                    exactUsedKey: key,
                    usedLng: lng,
                    usedNS: namespace,
                    usedParams: this.getUsedParamsDetails(options)
                  };
                }
                return `${namespace}${nsSeparator}${key}`;
              }
              if (returnDetails) {
                return {
                  res: key,
                  usedKey: key,
                  exactUsedKey: key,
                  usedLng: lng,
                  usedNS: namespace,
                  usedParams: this.getUsedParamsDetails(options)
                };
              }
              return key;
            }
            const resolved = this.resolve(keys, options);
            let res = resolved && resolved.res;
            const resUsedKey = resolved && resolved.usedKey || key;
            const resExactUsedKey = resolved && resolved.exactUsedKey || key;
            const resType = Object.prototype.toString.apply(res);
            const noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
            const joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;
            const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
            const handleAsObject = !isString$1(res) && typeof res !== 'boolean' && typeof res !== 'number';
            if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(isString$1(joinArrays) && Array.isArray(res))) {
              if (!options.returnObjects && !this.options.returnObjects) {
                if (!this.options.returnedObjectHandler) {
                  this.logger.warn('accessing an object - but returnObjects options is not enabled!');
                }
                const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread3(_objectSpread3({}, options), {}, {
                  ns: namespaces
                })) : `key '${key} (${this.language})' returned an object instead of string.`;
                if (returnDetails) {
                  resolved.res = r;
                  resolved.usedParams = this.getUsedParamsDetails(options);
                  return resolved;
                }
                return r;
              }
              if (keySeparator) {
                const resTypeIsArray = Array.isArray(res);
                const copy = resTypeIsArray ? [] : {};
                const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
                for (const m in res) {
                  if (Object.prototype.hasOwnProperty.call(res, m)) {
                    const deepKey = `${newKeyToUse}${keySeparator}${m}`;
                    copy[m] = this.translate(deepKey, _objectSpread3(_objectSpread3({}, options), {
                      joinArrays: false,
                      ns: namespaces
                    }));
                    if (copy[m] === deepKey) copy[m] = res[m];
                  }
                }
                res = copy;
              }
            } else if (handleAsObjectInI18nFormat && isString$1(joinArrays) && Array.isArray(res)) {
              res = res.join(joinArrays);
              if (res) res = this.extendTranslation(res, keys, options, lastKey);
            } else {
              let usedDefault = false;
              let usedKey = false;
              const needsPluralHandling = options.count !== undefined && !isString$1(options.count);
              const hasDefaultValue = Translator.hasDefaultValue(options);
              const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : '';
              const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
                ordinal: false
              }) : '';
              const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
              const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
              if (!this.isValidLookup(res) && hasDefaultValue) {
                usedDefault = true;
                res = defaultValue;
              }
              if (!this.isValidLookup(res)) {
                usedKey = true;
                res = key;
              }
              const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
              const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;
              const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
              if (usedKey || usedDefault || updateMissing) {
                this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);
                if (keySeparator) {
                  const fk = this.resolve(key, _objectSpread3(_objectSpread3({}, options), {}, {
                    keySeparator: false
                  }));
                  if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');
                }
                let lngs = [];
                const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
                if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
                  for (let i = 0; i < fallbackLngs.length; i++) {
                    lngs.push(fallbackLngs[i]);
                  }
                } else if (this.options.saveMissingTo === 'all') {
                  lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
                } else {
                  lngs.push(options.lng || this.language);
                }
                const send = (l, k, specificDefaultValue) => {
                  const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
                  if (this.options.missingKeyHandler) {
                    this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
                  } else if (this.backendConnector && this.backendConnector.saveMissing) {
                    this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
                  }
                  this.emit('missingKey', l, namespace, k, res);
                };
                if (this.options.saveMissing) {
                  if (this.options.saveMissingPlurals && needsPluralHandling) {
                    lngs.forEach(language => {
                      const suffixes = this.pluralResolver.getSuffixes(language, options);
                      if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                        suffixes.push(`${this.options.pluralSeparator}zero`);
                      }
                      suffixes.forEach(suffix => {
                        send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
                      });
                    });
                  } else {
                    send(lngs, key, defaultValue);
                  }
                }
              }
              res = this.extendTranslation(res, keys, options, resolved, lastKey);
              if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
              if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
                if (this.options.compatibilityAPI !== 'v1') {
                  res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : undefined);
                } else {
                  res = this.options.parseMissingKeyHandler(res);
                }
              }
            }
            if (returnDetails) {
              resolved.res = res;
              resolved.usedParams = this.getUsedParamsDetails(options);
              return resolved;
            }
            return res;
          }
          extendTranslation(res, key, options, resolved, lastKey) {
            var _this = this;
            if (this.i18nFormat && this.i18nFormat.parse) {
              res = this.i18nFormat.parse(res, _objectSpread3(_objectSpread3({}, this.options.interpolation.defaultVariables), options), options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
                resolved
              });
            } else if (!options.skipInterpolation) {
              if (options.interpolation) this.interpolator.init(_objectSpread3(_objectSpread3({}, options), {
                interpolation: _objectSpread3(_objectSpread3({}, this.options.interpolation), options.interpolation)
              }));
              const skipOnVariables = isString$1(res) && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
              let nestBef;
              if (skipOnVariables) {
                const nb = res.match(this.interpolator.nestingRegexp);
                nestBef = nb && nb.length;
              }
              let data = options.replace && !isString$1(options.replace) ? options.replace : options;
              if (this.options.interpolation.defaultVariables) data = _objectSpread3(_objectSpread3({}, this.options.interpolation.defaultVariables), data);
              res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);
              if (skipOnVariables) {
                const na = res.match(this.interpolator.nestingRegexp);
                const nestAft = na && na.length;
                if (nestBef < nestAft) options.nest = false;
              }
              if (!options.lng && this.options.compatibilityAPI !== 'v1' && resolved && resolved.res) options.lng = this.language || resolved.usedLng;
              if (options.nest !== false) res = this.interpolator.nest(res, function () {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                if (lastKey && lastKey[0] === args[0] && !options.context) {
                  _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
                  return null;
                }
                return _this.translate(...args, key);
              }, options);
              if (options.interpolation) this.interpolator.reset();
            }
            const postProcess = options.postProcess || this.options.postProcess;
            const postProcessorNames = isString$1(postProcess) ? [postProcess] : postProcess;
            if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
              res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread3({
                i18nResolved: _objectSpread3(_objectSpread3({}, resolved), {}, {
                  usedParams: this.getUsedParamsDetails(options)
                })
              }, options) : options, this);
            }
            return res;
          }
          resolve(keys) {
            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            let found;
            let usedKey;
            let exactUsedKey;
            let usedLng;
            let usedNS;
            if (isString$1(keys)) keys = [keys];
            keys.forEach(k => {
              if (this.isValidLookup(found)) return;
              const extracted = this.extractFromKey(k, options);
              const key = extracted.key;
              usedKey = key;
              let namespaces = extracted.namespaces;
              if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
              const needsPluralHandling = options.count !== undefined && !isString$1(options.count);
              const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
              const needsContextHandling = options.context !== undefined && (isString$1(options.context) || typeof options.context === 'number') && options.context !== '';
              const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
              namespaces.forEach(ns => {
                if (this.isValidLookup(found)) return;
                usedNS = ns;
                if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
                  checkedLoadedFor[`${codes[0]}-${ns}`] = true;
                  this.logger.warn(`key "${usedKey}" for languages "${codes.join(', ')}" won't get resolved as namespace "${usedNS}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
                }
                codes.forEach(code => {
                  if (this.isValidLookup(found)) return;
                  usedLng = code;
                  const finalKeys = [key];
                  if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
                    this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
                  } else {
                    let pluralSuffix;
                    if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
                    const zeroSuffix = `${this.options.pluralSeparator}zero`;
                    const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                    if (needsPluralHandling) {
                      finalKeys.push(key + pluralSuffix);
                      if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                        finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                      }
                      if (needsZeroSuffixLookup) {
                        finalKeys.push(key + zeroSuffix);
                      }
                    }
                    if (needsContextHandling) {
                      const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
                      finalKeys.push(contextKey);
                      if (needsPluralHandling) {
                        finalKeys.push(contextKey + pluralSuffix);
                        if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                          finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                        }
                        if (needsZeroSuffixLookup) {
                          finalKeys.push(contextKey + zeroSuffix);
                        }
                      }
                    }
                  }
                  let possibleKey;
                  while (possibleKey = finalKeys.pop()) {
                    if (!this.isValidLookup(found)) {
                      exactUsedKey = possibleKey;
                      found = this.getResource(code, ns, possibleKey, options);
                    }
                  }
                });
              });
            });
            return {
              res: found,
              usedKey,
              exactUsedKey,
              usedLng,
              usedNS
            };
          }
          isValidLookup(res) {
            return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
          }
          getResource(code, ns, key) {
            let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
            if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
            return this.resourceStore.getResource(code, ns, key, options);
          }
          getUsedParamsDetails() {
            let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            const optionsKeys = ['defaultValue', 'ordinal', 'context', 'replace', 'lng', 'lngs', 'fallbackLng', 'ns', 'keySeparator', 'nsSeparator', 'returnObjects', 'returnDetails', 'joinArrays', 'postProcess', 'interpolation'];
            const useOptionsReplaceForData = options.replace && !isString$1(options.replace);
            let data = useOptionsReplaceForData ? options.replace : options;
            if (useOptionsReplaceForData && typeof options.count !== 'undefined') {
              data.count = options.count;
            }
            if (this.options.interpolation.defaultVariables) {
              data = _objectSpread3(_objectSpread3({}, this.options.interpolation.defaultVariables), data);
            }
            if (!useOptionsReplaceForData) {
              data = _objectSpread3({}, data);
              var _iterator18 = _createForOfIteratorHelper2(optionsKeys),
                _step18;
              try {
                for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
                  const key = _step18.value;
                  delete data[key];
                }
              } catch (err) {
                _iterator18.e(err);
              } finally {
                _iterator18.f();
              }
            }
            return data;
          }
          static hasDefaultValue(options) {
            const prefix = 'defaultValue';
            for (const option in options) {
              if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {
                return true;
              }
            }
            return false;
          }
        }
        const capitalize = string => string.charAt(0).toUpperCase() + string.slice(1);
        class LanguageUtil {
          constructor(options) {
            this.options = options;
            this.supportedLngs = this.options.supportedLngs || false;
            this.logger = baseLogger.create('languageUtils');
          }
          getScriptPartFromCode(code) {
            code = getCleanedCode(code);
            if (!code || code.indexOf('-') < 0) return null;
            const p = code.split('-');
            if (p.length === 2) return null;
            p.pop();
            if (p[p.length - 1].toLowerCase() === 'x') return null;
            return this.formatLanguageCode(p.join('-'));
          }
          getLanguagePartFromCode(code) {
            code = getCleanedCode(code);
            if (!code || code.indexOf('-') < 0) return code;
            const p = code.split('-');
            return this.formatLanguageCode(p[0]);
          }
          formatLanguageCode(code) {
            if (isString$1(code) && code.indexOf('-') > -1) {
              if (typeof Intl !== 'undefined' && typeof Intl.getCanonicalLocales !== 'undefined') {
                try {
                  let formattedCode = Intl.getCanonicalLocales(code)[0];
                  if (formattedCode && this.options.lowerCaseLng) {
                    formattedCode = formattedCode.toLowerCase();
                  }
                  if (formattedCode) return formattedCode;
                } catch (e) {}
              }
              const specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
              let p = code.split('-');
              if (this.options.lowerCaseLng) {
                p = p.map(part => part.toLowerCase());
              } else if (p.length === 2) {
                p[0] = p[0].toLowerCase();
                p[1] = p[1].toUpperCase();
                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
              } else if (p.length === 3) {
                p[0] = p[0].toLowerCase();
                if (p[1].length === 2) p[1] = p[1].toUpperCase();
                if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
                if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
              }
              return p.join('-');
            }
            return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
          }
          isSupportedCode(code) {
            if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {
              code = this.getLanguagePartFromCode(code);
            }
            return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
          }
          getBestMatchFromCodes(codes) {
            if (!codes) return null;
            let found;
            codes.forEach(code => {
              if (found) return;
              const cleanedLng = this.formatLanguageCode(code);
              if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
            });
            if (!found && this.options.supportedLngs) {
              codes.forEach(code => {
                if (found) return;
                const lngOnly = this.getLanguagePartFromCode(code);
                if (this.isSupportedCode(lngOnly)) return found = lngOnly;
                found = this.options.supportedLngs.find(supportedLng => {
                  if (supportedLng === lngOnly) return supportedLng;
                  if (supportedLng.indexOf('-') < 0 && lngOnly.indexOf('-') < 0) return;
                  if (supportedLng.indexOf('-') > 0 && lngOnly.indexOf('-') < 0 && supportedLng.substring(0, supportedLng.indexOf('-')) === lngOnly) return supportedLng;
                  if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
                });
              });
            }
            if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
            return found;
          }
          getFallbackCodes(fallbacks, code) {
            if (!fallbacks) return [];
            if (typeof fallbacks === 'function') fallbacks = fallbacks(code);
            if (isString$1(fallbacks)) fallbacks = [fallbacks];
            if (Array.isArray(fallbacks)) return fallbacks;
            if (!code) return fallbacks.default || [];
            let found = fallbacks[code];
            if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
            if (!found) found = fallbacks[this.formatLanguageCode(code)];
            if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
            if (!found) found = fallbacks.default;
            return found || [];
          }
          toResolveHierarchy(code, fallbackCode) {
            const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
            const codes = [];
            const addCode = c => {
              if (!c) return;
              if (this.isSupportedCode(c)) {
                codes.push(c);
              } else {
                this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
              }
            };
            if (isString$1(code) && (code.indexOf('-') > -1 || code.indexOf('_') > -1)) {
              if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
              if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
              if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
            } else if (isString$1(code)) {
              addCode(this.formatLanguageCode(code));
            }
            fallbackCodes.forEach(fc => {
              if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
            });
            return codes;
          }
        }
        let sets = [{
          lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'tl', 'ti', 'tr', 'uz', 'wa'],
          nr: [1, 2],
          fc: 1
        }, {
          lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kk', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],
          nr: [1, 2],
          fc: 2
        }, {
          lngs: ['ay', 'bo', 'cgg', 'fa', 'ht', 'id', 'ja', 'jbo', 'ka', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
          nr: [1],
          fc: 3
        }, {
          lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],
          nr: [1, 2, 5],
          fc: 4
        }, {
          lngs: ['ar'],
          nr: [0, 1, 2, 3, 11, 100],
          fc: 5
        }, {
          lngs: ['cs', 'sk'],
          nr: [1, 2, 5],
          fc: 6
        }, {
          lngs: ['csb', 'pl'],
          nr: [1, 2, 5],
          fc: 7
        }, {
          lngs: ['cy'],
          nr: [1, 2, 3, 8],
          fc: 8
        }, {
          lngs: ['fr'],
          nr: [1, 2],
          fc: 9
        }, {
          lngs: ['ga'],
          nr: [1, 2, 3, 7, 11],
          fc: 10
        }, {
          lngs: ['gd'],
          nr: [1, 2, 3, 20],
          fc: 11
        }, {
          lngs: ['is'],
          nr: [1, 2],
          fc: 12
        }, {
          lngs: ['jv'],
          nr: [0, 1],
          fc: 13
        }, {
          lngs: ['kw'],
          nr: [1, 2, 3, 4],
          fc: 14
        }, {
          lngs: ['lt'],
          nr: [1, 2, 10],
          fc: 15
        }, {
          lngs: ['lv'],
          nr: [1, 2, 0],
          fc: 16
        }, {
          lngs: ['mk'],
          nr: [1, 2],
          fc: 17
        }, {
          lngs: ['mnk'],
          nr: [0, 1, 2],
          fc: 18
        }, {
          lngs: ['mt'],
          nr: [1, 2, 11, 20],
          fc: 19
        }, {
          lngs: ['or'],
          nr: [2, 1],
          fc: 2
        }, {
          lngs: ['ro'],
          nr: [1, 2, 20],
          fc: 20
        }, {
          lngs: ['sl'],
          nr: [5, 1, 2, 3],
          fc: 21
        }, {
          lngs: ['he', 'iw'],
          nr: [1, 2, 20, 21],
          fc: 22
        }];
        let _rulesPluralsTypes = {
          1: n => Number(n > 1),
          2: n => Number(n != 1),
          3: n => 0,
          4: n => Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),
          5: n => Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5),
          6: n => Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2),
          7: n => Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),
          8: n => Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3),
          9: n => Number(n >= 2),
          10: n => Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4),
          11: n => Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3),
          12: n => Number(n % 10 != 1 || n % 100 == 11),
          13: n => Number(n !== 0),
          14: n => Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3),
          15: n => Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),
          16: n => Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2),
          17: n => Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1),
          18: n => Number(n == 0 ? 0 : n == 1 ? 1 : 2),
          19: n => Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3),
          20: n => Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2),
          21: n => Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0),
          22: n => Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3)
        };
        const nonIntlVersions = ['v1', 'v2', 'v3'];
        const intlVersions = ['v4'];
        const suffixesOrder = {
          zero: 0,
          one: 1,
          two: 2,
          few: 3,
          many: 4,
          other: 5
        };
        const createRules = () => {
          const rules = {};
          sets.forEach(set => {
            set.lngs.forEach(l => {
              rules[l] = {
                numbers: set.nr,
                plurals: _rulesPluralsTypes[set.fc]
              };
            });
          });
          return rules;
        };
        class PluralResolver {
          constructor(languageUtils) {
            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            this.languageUtils = languageUtils;
            this.options = options;
            this.logger = baseLogger.create('pluralResolver');
            if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === 'undefined' || !Intl.PluralRules)) {
              this.options.compatibilityJSON = 'v3';
              this.logger.error('Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.');
            }
            this.rules = createRules();
            this.pluralRulesCache = {};
          }
          addRule(lng, obj) {
            this.rules[lng] = obj;
          }
          clearCache() {
            this.pluralRulesCache = {};
          }
          getRule(code) {
            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            if (this.shouldUseIntlApi()) {
              try {
                const cleanedCode = getCleanedCode(code === 'dev' ? 'en' : code);
                const type = options.ordinal ? 'ordinal' : 'cardinal';
                const cacheKey = JSON.stringify({
                  cleanedCode,
                  type
                });
                if (cacheKey in this.pluralRulesCache) {
                  return this.pluralRulesCache[cacheKey];
                }
                const rule = new Intl.PluralRules(cleanedCode, {
                  type
                });
                this.pluralRulesCache[cacheKey] = rule;
                return rule;
              } catch (err) {
                return;
              }
            }
            return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
          }
          needsPlural(code) {
            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            const rule = this.getRule(code, options);
            if (this.shouldUseIntlApi()) {
              return rule && rule.resolvedOptions().pluralCategories.length > 1;
            }
            return rule && rule.numbers.length > 1;
          }
          getPluralFormsOfKey(code, key) {
            let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            return this.getSuffixes(code, options).map(suffix => `${key}${suffix}`);
          }
          getSuffixes(code) {
            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            const rule = this.getRule(code, options);
            if (!rule) {
              return [];
            }
            if (this.shouldUseIntlApi()) {
              return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map(pluralCategory => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ''}${pluralCategory}`);
            }
            return rule.numbers.map(number => this.getSuffix(code, number, options));
          }
          getSuffix(code, count) {
            let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            const rule = this.getRule(code, options);
            if (rule) {
              if (this.shouldUseIntlApi()) {
                return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ''}${rule.select(count)}`;
              }
              return this.getSuffixRetroCompatible(rule, count);
            }
            this.logger.warn(`no plural rule found for: ${code}`);
            return '';
          }
          getSuffixRetroCompatible(rule, count) {
            const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
            let suffix = rule.numbers[idx];
            if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
              if (suffix === 2) {
                suffix = 'plural';
              } else if (suffix === 1) {
                suffix = '';
              }
            }
            const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
            if (this.options.compatibilityJSON === 'v1') {
              if (suffix === 1) return '';
              if (typeof suffix === 'number') return `_plural_${suffix.toString()}`;
              return returnSuffix();
            } else if (this.options.compatibilityJSON === 'v2') {
              return returnSuffix();
            } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
              return returnSuffix();
            }
            return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
          }
          shouldUseIntlApi() {
            return !nonIntlVersions.includes(this.options.compatibilityJSON);
          }
        }
        const deepFindWithDefaults = function deepFindWithDefaults(data, defaultData, key) {
          let keySeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';
          let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
          let path = getPathWithDefaults(data, defaultData, key);
          if (!path && ignoreJSONStructure && isString$1(key)) {
            path = deepFind(data, key, keySeparator);
            if (path === undefined) path = deepFind(defaultData, key, keySeparator);
          }
          return path;
        };
        const regexSafe = val => val.replace(/\$/g, '$$$$');
        class Interpolator {
          constructor() {
            let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            this.logger = baseLogger.create('interpolator');
            this.options = options;
            this.format = options.interpolation && options.interpolation.format || (value => value);
            this.init(options);
          }
          init() {
            let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            if (!options.interpolation) options.interpolation = {
              escapeValue: true
            };
            const _options$interpolatio = options.interpolation,
              escape$1 = _options$interpolatio.escape,
              escapeValue = _options$interpolatio.escapeValue,
              useRawValueToEscape = _options$interpolatio.useRawValueToEscape,
              prefix = _options$interpolatio.prefix,
              prefixEscaped = _options$interpolatio.prefixEscaped,
              suffix = _options$interpolatio.suffix,
              suffixEscaped = _options$interpolatio.suffixEscaped,
              formatSeparator = _options$interpolatio.formatSeparator,
              unescapeSuffix = _options$interpolatio.unescapeSuffix,
              unescapePrefix = _options$interpolatio.unescapePrefix,
              nestingPrefix = _options$interpolatio.nestingPrefix,
              nestingPrefixEscaped = _options$interpolatio.nestingPrefixEscaped,
              nestingSuffix = _options$interpolatio.nestingSuffix,
              nestingSuffixEscaped = _options$interpolatio.nestingSuffixEscaped,
              nestingOptionsSeparator = _options$interpolatio.nestingOptionsSeparator,
              maxReplaces = _options$interpolatio.maxReplaces,
              alwaysFormat = _options$interpolatio.alwaysFormat;
            this.escape = escape$1 !== undefined ? escape$1 : escape;
            this.escapeValue = escapeValue !== undefined ? escapeValue : true;
            this.useRawValueToEscape = useRawValueToEscape !== undefined ? useRawValueToEscape : false;
            this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || '{{';
            this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || '}}';
            this.formatSeparator = formatSeparator || ',';
            this.unescapePrefix = unescapeSuffix ? '' : unescapePrefix || '-';
            this.unescapeSuffix = this.unescapePrefix ? '' : unescapeSuffix || '';
            this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape('$t(');
            this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(')');
            this.nestingOptionsSeparator = nestingOptionsSeparator || ',';
            this.maxReplaces = maxReplaces || 1000;
            this.alwaysFormat = alwaysFormat !== undefined ? alwaysFormat : false;
            this.resetRegExp();
          }
          reset() {
            if (this.options) this.init(this.options);
          }
          resetRegExp() {
            const getOrResetRegExp = (existingRegExp, pattern) => {
              if (existingRegExp && existingRegExp.source === pattern) {
                existingRegExp.lastIndex = 0;
                return existingRegExp;
              }
              return new RegExp(pattern, 'g');
            };
            this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
            this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
            this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
          }
          interpolate(str, data, lng, options) {
            let match;
            let value;
            let replaces;
            const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
            const handleFormat = key => {
              if (key.indexOf(this.formatSeparator) < 0) {
                const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
                return this.alwaysFormat ? this.format(path, undefined, lng, _objectSpread3(_objectSpread3(_objectSpread3({}, options), data), {}, {
                  interpolationkey: key
                })) : path;
              }
              const p = key.split(this.formatSeparator);
              const k = p.shift().trim();
              const f = p.join(this.formatSeparator).trim();
              return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, _objectSpread3(_objectSpread3(_objectSpread3({}, options), data), {}, {
                interpolationkey: k
              }));
            };
            this.resetRegExp();
            const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
            const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
            const todos = [{
              regex: this.regexpUnescape,
              safeValue: val => regexSafe(val)
            }, {
              regex: this.regexp,
              safeValue: val => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
            }];
            todos.forEach(todo => {
              replaces = 0;
              while (match = todo.regex.exec(str)) {
                const matchedVar = match[1].trim();
                value = handleFormat(matchedVar);
                if (value === undefined) {
                  if (typeof missingInterpolationHandler === 'function') {
                    const temp = missingInterpolationHandler(str, match, options);
                    value = isString$1(temp) ? temp : '';
                  } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
                    value = '';
                  } else if (skipOnVariables) {
                    value = match[0];
                    continue;
                  } else {
                    this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
                    value = '';
                  }
                } else if (!isString$1(value) && !this.useRawValueToEscape) {
                  value = makeString(value);
                }
                const safeValue = todo.safeValue(value);
                str = str.replace(match[0], safeValue);
                if (skipOnVariables) {
                  todo.regex.lastIndex += value.length;
                  todo.regex.lastIndex -= match[0].length;
                } else {
                  todo.regex.lastIndex = 0;
                }
                replaces++;
                if (replaces >= this.maxReplaces) {
                  break;
                }
              }
            });
            return str;
          }
          nest(str, fc) {
            let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            let match;
            let value;
            let clonedOptions;
            const handleHasOptions = (key, inheritedOptions) => {
              const sep = this.nestingOptionsSeparator;
              if (key.indexOf(sep) < 0) return key;
              const c = key.split(new RegExp(`${sep}[ ]*{`));
              let optionsString = `{${c[1]}`;
              key = c[0];
              optionsString = this.interpolate(optionsString, clonedOptions);
              const matchedSingleQuotes = optionsString.match(/'/g);
              const matchedDoubleQuotes = optionsString.match(/"/g);
              if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
                optionsString = optionsString.replace(/'/g, '"');
              }
              try {
                clonedOptions = JSON.parse(optionsString);
                if (inheritedOptions) clonedOptions = _objectSpread3(_objectSpread3({}, inheritedOptions), clonedOptions);
              } catch (e) {
                this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
                return `${key}${sep}${optionsString}`;
              }
              if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
              return key;
            };
            while (match = this.nestingRegexp.exec(str)) {
              let formatters = [];
              clonedOptions = _objectSpread3({}, options);
              clonedOptions = clonedOptions.replace && !isString$1(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
              clonedOptions.applyPostProcessor = false;
              delete clonedOptions.defaultValue;
              let doReduce = false;
              if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
                const r = match[1].split(this.formatSeparator).map(elem => elem.trim());
                match[1] = r.shift();
                formatters = r;
                doReduce = true;
              }
              value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
              if (value && match[0] === str && !isString$1(value)) return value;
              if (!isString$1(value)) value = makeString(value);
              if (!value) {
                this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
                value = '';
              }
              if (doReduce) {
                value = formatters.reduce((v, f) => this.format(v, f, options.lng, _objectSpread3(_objectSpread3({}, options), {}, {
                  interpolationkey: match[1].trim()
                })), value.trim());
              }
              str = str.replace(match[0], value);
              this.regexp.lastIndex = 0;
            }
            return str;
          }
        }
        const parseFormatStr = formatStr => {
          let formatName = formatStr.toLowerCase().trim();
          const formatOptions = {};
          if (formatStr.indexOf('(') > -1) {
            const p = formatStr.split('(');
            formatName = p[0].toLowerCase().trim();
            const optStr = p[1].substring(0, p[1].length - 1);
            if (formatName === 'currency' && optStr.indexOf(':') < 0) {
              if (!formatOptions.currency) formatOptions.currency = optStr.trim();
            } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {
              if (!formatOptions.range) formatOptions.range = optStr.trim();
            } else {
              const opts = optStr.split(';');
              opts.forEach(opt => {
                if (opt) {
                  const _opt$split = opt.split(':'),
                    _opt$split2 = _toArray2(_opt$split),
                    key = _opt$split2[0],
                    rest = _opt$split2.slice(1);
                  const val = rest.join(':').trim().replace(/^'+|'+$/g, '');
                  const trimmedKey = key.trim();
                  if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
                  if (val === 'false') formatOptions[trimmedKey] = false;
                  if (val === 'true') formatOptions[trimmedKey] = true;
                  if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
                }
              });
            }
          }
          return {
            formatName,
            formatOptions
          };
        };
        const createCachedFormatter = fn => {
          const cache = {};
          return (val, lng, options) => {
            let optForCache = options;
            if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
              optForCache = _objectSpread3(_objectSpread3({}, optForCache), {}, {
                [options.interpolationkey]: undefined
              });
            }
            const key = lng + JSON.stringify(optForCache);
            let formatter = cache[key];
            if (!formatter) {
              formatter = fn(getCleanedCode(lng), options);
              cache[key] = formatter;
            }
            return formatter(val);
          };
        };
        class Formatter {
          constructor() {
            let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            this.logger = baseLogger.create('formatter');
            this.options = options;
            this.formats = {
              number: createCachedFormatter((lng, opt) => val => new Intl.NumberFormat(lng, _objectSpread3({}, opt)).format(val)),
              currency: createCachedFormatter((lng, opt) => val => new Intl.NumberFormat(lng, _objectSpread3(_objectSpread3({}, opt), {}, {
                style: 'currency'
              })).format(val)),
              datetime: createCachedFormatter((lng, opt) => val => new Intl.DateTimeFormat(lng, _objectSpread3({}, opt)).format(val)),
              relativetime: createCachedFormatter((lng, opt) => val => new Intl.RelativeTimeFormat(lng, _objectSpread3({}, opt)).format(val, opt.range || 'day')),
              list: createCachedFormatter((lng, opt) => val => new Intl.ListFormat(lng, _objectSpread3({}, opt)).format(val))
            };
            this.init(options);
          }
          init(services) {
            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
              interpolation: {}
            };
            this.formatSeparator = options.interpolation.formatSeparator || ',';
          }
          add(name, fc) {
            this.formats[name.toLowerCase().trim()] = fc;
          }
          addCached(name, fc) {
            this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
          }
          format(value, format, lng) {
            let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
            const formats = format.split(this.formatSeparator);
            if (formats.length > 1 && formats[0].indexOf('(') > 1 && formats[0].indexOf(')') < 0 && formats.find(f => f.indexOf(')') > -1)) {
              const lastIndex = formats.findIndex(f => f.indexOf(')') > -1);
              formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
            }
            const result = formats.reduce((mem, f) => {
              const _parseFormatStr = parseFormatStr(f),
                formatName = _parseFormatStr.formatName,
                formatOptions = _parseFormatStr.formatOptions;
              if (this.formats[formatName]) {
                let formatted = mem;
                try {
                  const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
                  const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
                  formatted = this.formats[formatName](mem, l, _objectSpread3(_objectSpread3(_objectSpread3({}, formatOptions), options), valOptions));
                } catch (error) {
                  this.logger.warn(error);
                }
                return formatted;
              } else {
                this.logger.warn(`there was no format function for ${formatName}`);
              }
              return mem;
            }, value);
            return result;
          }
        }
        const removePending = (q, name) => {
          if (q.pending[name] !== undefined) {
            delete q.pending[name];
            q.pendingCount--;
          }
        };
        class Connector extends EventEmitter {
          constructor(backend, store, services) {
            let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
            super();
            this.backend = backend;
            this.store = store;
            this.services = services;
            this.languageUtils = services.languageUtils;
            this.options = options;
            this.logger = baseLogger.create('backendConnector');
            this.waitingReads = [];
            this.maxParallelReads = options.maxParallelReads || 10;
            this.readingCalls = 0;
            this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
            this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
            this.state = {};
            this.queue = [];
            if (this.backend && this.backend.init) {
              this.backend.init(services, options.backend, options);
            }
          }
          queueLoad(languages, namespaces, options, callback) {
            const toLoad = {};
            const pending = {};
            const toLoadLanguages = {};
            const toLoadNamespaces = {};
            languages.forEach(lng => {
              let hasAllNamespaces = true;
              namespaces.forEach(ns => {
                const name = `${lng}|${ns}`;
                if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
                  this.state[name] = 2;
                } else if (this.state[name] < 0) ;else if (this.state[name] === 1) {
                  if (pending[name] === undefined) pending[name] = true;
                } else {
                  this.state[name] = 1;
                  hasAllNamespaces = false;
                  if (pending[name] === undefined) pending[name] = true;
                  if (toLoad[name] === undefined) toLoad[name] = true;
                  if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;
                }
              });
              if (!hasAllNamespaces) toLoadLanguages[lng] = true;
            });
            if (Object.keys(toLoad).length || Object.keys(pending).length) {
              this.queue.push({
                pending,
                pendingCount: Object.keys(pending).length,
                loaded: {},
                errors: [],
                callback
              });
            }
            return {
              toLoad: Object.keys(toLoad),
              pending: Object.keys(pending),
              toLoadLanguages: Object.keys(toLoadLanguages),
              toLoadNamespaces: Object.keys(toLoadNamespaces)
            };
          }
          loaded(name, err, data) {
            const s = name.split('|');
            const lng = s[0];
            const ns = s[1];
            if (err) this.emit('failedLoading', lng, ns, err);
            if (!err && data) {
              this.store.addResourceBundle(lng, ns, data, undefined, undefined, {
                skipCopy: true
              });
            }
            this.state[name] = err ? -1 : 2;
            if (err && data) this.state[name] = 0;
            const loaded = {};
            this.queue.forEach(q => {
              pushPath(q.loaded, [lng], ns);
              removePending(q, name);
              if (err) q.errors.push(err);
              if (q.pendingCount === 0 && !q.done) {
                Object.keys(q.loaded).forEach(l => {
                  if (!loaded[l]) loaded[l] = {};
                  const loadedKeys = q.loaded[l];
                  if (loadedKeys.length) {
                    loadedKeys.forEach(n => {
                      if (loaded[l][n] === undefined) loaded[l][n] = true;
                    });
                  }
                });
                q.done = true;
                if (q.errors.length) {
                  q.callback(q.errors);
                } else {
                  q.callback();
                }
              }
            });
            this.emit('loaded', loaded);
            this.queue = this.queue.filter(q => !q.done);
          }
          read(lng, ns, fcName) {
            let tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            let wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;
            let callback = arguments.length > 5 ? arguments[5] : undefined;
            if (!lng.length) return callback(null, {});
            if (this.readingCalls >= this.maxParallelReads) {
              this.waitingReads.push({
                lng,
                ns,
                fcName,
                tried,
                wait,
                callback
              });
              return;
            }
            this.readingCalls++;
            const resolver = (err, data) => {
              this.readingCalls--;
              if (this.waitingReads.length > 0) {
                const next = this.waitingReads.shift();
                this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
              }
              if (err && data && tried < this.maxRetries) {
                setTimeout(() => {
                  this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
                }, wait);
                return;
              }
              callback(err, data);
            };
            const fc = this.backend[fcName].bind(this.backend);
            if (fc.length === 2) {
              try {
                const r = fc(lng, ns);
                if (r && typeof r.then === 'function') {
                  r.then(data => resolver(null, data)).catch(resolver);
                } else {
                  resolver(null, r);
                }
              } catch (err) {
                resolver(err);
              }
              return;
            }
            return fc(lng, ns, resolver);
          }
          prepareLoading(languages, namespaces) {
            let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            let callback = arguments.length > 3 ? arguments[3] : undefined;
            if (!this.backend) {
              this.logger.warn('No backend was added via i18next.use. Will not load resources.');
              return callback && callback();
            }
            if (isString$1(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
            if (isString$1(namespaces)) namespaces = [namespaces];
            const toLoad = this.queueLoad(languages, namespaces, options, callback);
            if (!toLoad.toLoad.length) {
              if (!toLoad.pending.length) callback();
              return null;
            }
            toLoad.toLoad.forEach(name => {
              this.loadOne(name);
            });
          }
          load(languages, namespaces, callback) {
            this.prepareLoading(languages, namespaces, {}, callback);
          }
          reload(languages, namespaces, callback) {
            this.prepareLoading(languages, namespaces, {
              reload: true
            }, callback);
          }
          loadOne(name) {
            let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
            const s = name.split('|');
            const lng = s[0];
            const ns = s[1];
            this.read(lng, ns, 'read', undefined, undefined, (err, data) => {
              if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
              if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
              this.loaded(name, err, data);
            });
          }
          saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
            let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
            let clb = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : () => {};
            if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
              this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
              return;
            }
            if (key === undefined || key === null || key === '') return;
            if (this.backend && this.backend.create) {
              const opts = _objectSpread3(_objectSpread3({}, options), {}, {
                isUpdate
              });
              const fc = this.backend.create.bind(this.backend);
              if (fc.length < 6) {
                try {
                  let r;
                  if (fc.length === 5) {
                    r = fc(languages, namespace, key, fallbackValue, opts);
                  } else {
                    r = fc(languages, namespace, key, fallbackValue);
                  }
                  if (r && typeof r.then === 'function') {
                    r.then(data => clb(null, data)).catch(clb);
                  } else {
                    clb(null, r);
                  }
                } catch (err) {
                  clb(err);
                }
              } else {
                fc(languages, namespace, key, fallbackValue, clb, opts);
              }
            }
            if (!languages || !languages[0]) return;
            this.store.addResource(languages[0], namespace, key, fallbackValue);
          }
        }
        const get$4 = () => ({
          debug: false,
          initImmediate: true,
          ns: ['translation'],
          defaultNS: ['translation'],
          fallbackLng: ['dev'],
          fallbackNS: false,
          supportedLngs: false,
          nonExplicitSupportedLngs: false,
          load: 'all',
          preload: false,
          simplifyPluralSuffix: true,
          keySeparator: '.',
          nsSeparator: ':',
          pluralSeparator: '_',
          contextSeparator: '_',
          partialBundledLanguages: false,
          saveMissing: false,
          updateMissing: false,
          saveMissingTo: 'fallback',
          saveMissingPlurals: true,
          missingKeyHandler: false,
          missingInterpolationHandler: false,
          postProcess: false,
          postProcessPassResolved: false,
          returnNull: false,
          returnEmptyString: true,
          returnObjects: false,
          joinArrays: false,
          returnedObjectHandler: false,
          parseMissingKeyHandler: false,
          appendNamespaceToMissingKey: false,
          appendNamespaceToCIMode: false,
          overloadTranslationOptionHandler: args => {
            let ret = {};
            if (typeof args[1] === 'object') ret = args[1];
            if (isString$1(args[1])) ret.defaultValue = args[1];
            if (isString$1(args[2])) ret.tDescription = args[2];
            if (typeof args[2] === 'object' || typeof args[3] === 'object') {
              const options = args[3] || args[2];
              Object.keys(options).forEach(key => {
                ret[key] = options[key];
              });
            }
            return ret;
          },
          interpolation: {
            escapeValue: true,
            format: value => value,
            prefix: '{{',
            suffix: '}}',
            formatSeparator: ',',
            unescapePrefix: '-',
            nestingPrefix: '$t(',
            nestingSuffix: ')',
            nestingOptionsSeparator: ',',
            maxReplaces: 1000,
            skipOnVariables: true
          }
        });
        const transformOptions = options => {
          if (isString$1(options.ns)) options.ns = [options.ns];
          if (isString$1(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
          if (isString$1(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
          if (options.supportedLngs && options.supportedLngs.indexOf('cimode') < 0) {
            options.supportedLngs = options.supportedLngs.concat(['cimode']);
          }
          return options;
        };
        const noop = () => {};
        const bindMemberFunctions = inst => {
          const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
          mems.forEach(mem => {
            if (typeof inst[mem] === 'function') {
              inst[mem] = inst[mem].bind(inst);
            }
          });
        };
        class I18n extends EventEmitter {
          constructor() {
            let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            let callback = arguments.length > 1 ? arguments[1] : undefined;
            super();
            this.options = transformOptions(options);
            this.services = {};
            this.logger = baseLogger;
            this.modules = {
              external: []
            };
            bindMemberFunctions(this);
            if (callback && !this.isInitialized && !options.isClone) {
              if (!this.options.initImmediate) {
                this.init(options, callback);
                return this;
              }
              setTimeout(() => {
                this.init(options, callback);
              }, 0);
            }
          }
          init() {
            var _this = this;
            let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            let callback = arguments.length > 1 ? arguments[1] : undefined;
            this.isInitializing = true;
            if (typeof options === 'function') {
              callback = options;
              options = {};
            }
            if (!options.defaultNS && options.defaultNS !== false && options.ns) {
              if (isString$1(options.ns)) {
                options.defaultNS = options.ns;
              } else if (options.ns.indexOf('translation') < 0) {
                options.defaultNS = options.ns[0];
              }
            }
            const defOpts = get$4();
            this.options = _objectSpread3(_objectSpread3(_objectSpread3({}, defOpts), this.options), transformOptions(options));
            if (this.options.compatibilityAPI !== 'v1') {
              this.options.interpolation = _objectSpread3(_objectSpread3({}, defOpts.interpolation), this.options.interpolation);
            }
            if (options.keySeparator !== undefined) {
              this.options.userDefinedKeySeparator = options.keySeparator;
            }
            if (options.nsSeparator !== undefined) {
              this.options.userDefinedNsSeparator = options.nsSeparator;
            }
            const createClassOnDemand = ClassOrObject => {
              if (!ClassOrObject) return null;
              if (typeof ClassOrObject === 'function') return new ClassOrObject();
              return ClassOrObject;
            };
            if (!this.options.isClone) {
              if (this.modules.logger) {
                baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
              } else {
                baseLogger.init(null, this.options);
              }
              let formatter;
              if (this.modules.formatter) {
                formatter = this.modules.formatter;
              } else if (typeof Intl !== 'undefined') {
                formatter = Formatter;
              }
              const lu = new LanguageUtil(this.options);
              this.store = new ResourceStore(this.options.resources, this.options);
              const s = this.services;
              s.logger = baseLogger;
              s.resourceStore = this.store;
              s.languageUtils = lu;
              s.pluralResolver = new PluralResolver(lu, {
                prepend: this.options.pluralSeparator,
                compatibilityJSON: this.options.compatibilityJSON,
                simplifyPluralSuffix: this.options.simplifyPluralSuffix
              });
              if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
                s.formatter = createClassOnDemand(formatter);
                s.formatter.init(s, this.options);
                this.options.interpolation.format = s.formatter.format.bind(s.formatter);
              }
              s.interpolator = new Interpolator(this.options);
              s.utils = {
                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
              };
              s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
              s.backendConnector.on('*', function (event) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                _this.emit(event, ...args);
              });
              if (this.modules.languageDetector) {
                s.languageDetector = createClassOnDemand(this.modules.languageDetector);
                if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
              }
              if (this.modules.i18nFormat) {
                s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
                if (s.i18nFormat.init) s.i18nFormat.init(this);
              }
              this.translator = new Translator(this.services, this.options);
              this.translator.on('*', function (event) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                _this.emit(event, ...args);
              });
              this.modules.external.forEach(m => {
                if (m.init) m.init(this);
              });
            }
            this.format = this.options.interpolation.format;
            if (!callback) callback = noop;
            if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
              const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
              if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];
            }
            if (!this.services.languageDetector && !this.options.lng) {
              this.logger.warn('init: no languageDetector is used and no lng is defined');
            }
            const storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
            storeApi.forEach(fcName => {
              this[fcName] = function () {
                return _this.store[fcName](...arguments);
              };
            });
            const storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];
            storeApiChained.forEach(fcName => {
              this[fcName] = function () {
                _this.store[fcName](...arguments);
                return _this;
              };
            });
            const deferred = defer();
            const load = () => {
              const finish = (err, t) => {
                this.isInitializing = false;
                if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn('init: i18next is already initialized. You should call init just once!');
                this.isInitialized = true;
                if (!this.options.isClone) this.logger.log('initialized', this.options);
                this.emit('initialized', this.options);
                deferred.resolve(t);
                callback(err, t);
              };
              if (this.languages && this.options.compatibilityAPI !== 'v1' && !this.isInitialized) return finish(null, this.t.bind(this));
              this.changeLanguage(this.options.lng, finish);
            };
            if (this.options.resources || !this.options.initImmediate) {
              load();
            } else {
              setTimeout(load, 0);
            }
            return deferred;
          }
          loadResources(language) {
            let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
            let usedCallback = callback;
            const usedLng = isString$1(language) ? language : this.language;
            if (typeof language === 'function') usedCallback = language;
            if (!this.options.resources || this.options.partialBundledLanguages) {
              if (usedLng && usedLng.toLowerCase() === 'cimode' && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
              const toLoad = [];
              const append = lng => {
                if (!lng) return;
                if (lng === 'cimode') return;
                const lngs = this.services.languageUtils.toResolveHierarchy(lng);
                lngs.forEach(l => {
                  if (l === 'cimode') return;
                  if (toLoad.indexOf(l) < 0) toLoad.push(l);
                });
              };
              if (!usedLng) {
                const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                fallbacks.forEach(l => append(l));
              } else {
                append(usedLng);
              }
              if (this.options.preload) {
                this.options.preload.forEach(l => append(l));
              }
              this.services.backendConnector.load(toLoad, this.options.ns, e => {
                if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
                usedCallback(e);
              });
            } else {
              usedCallback(null);
            }
          }
          reloadResources(lngs, ns, callback) {
            const deferred = defer();
            if (typeof lngs === 'function') {
              callback = lngs;
              lngs = undefined;
            }
            if (typeof ns === 'function') {
              callback = ns;
              ns = undefined;
            }
            if (!lngs) lngs = this.languages;
            if (!ns) ns = this.options.ns;
            if (!callback) callback = noop;
            this.services.backendConnector.reload(lngs, ns, err => {
              deferred.resolve();
              callback(err);
            });
            return deferred;
          }
          use(module) {
            if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');
            if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');
            if (module.type === 'backend') {
              this.modules.backend = module;
            }
            if (module.type === 'logger' || module.log && module.warn && module.error) {
              this.modules.logger = module;
            }
            if (module.type === 'languageDetector') {
              this.modules.languageDetector = module;
            }
            if (module.type === 'i18nFormat') {
              this.modules.i18nFormat = module;
            }
            if (module.type === 'postProcessor') {
              postProcessor.addPostProcessor(module);
            }
            if (module.type === 'formatter') {
              this.modules.formatter = module;
            }
            if (module.type === '3rdParty') {
              this.modules.external.push(module);
            }
            return this;
          }
          setResolvedLanguage(l) {
            if (!l || !this.languages) return;
            if (['cimode', 'dev'].indexOf(l) > -1) return;
            for (let li = 0; li < this.languages.length; li++) {
              const lngInLngs = this.languages[li];
              if (['cimode', 'dev'].indexOf(lngInLngs) > -1) continue;
              if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
                this.resolvedLanguage = lngInLngs;
                break;
              }
            }
          }
          changeLanguage(lng, callback) {
            var _this2 = this;
            this.isLanguageChangingTo = lng;
            const deferred = defer();
            this.emit('languageChanging', lng);
            const setLngProps = l => {
              this.language = l;
              this.languages = this.services.languageUtils.toResolveHierarchy(l);
              this.resolvedLanguage = undefined;
              this.setResolvedLanguage(l);
            };
            const done = (err, l) => {
              if (l) {
                setLngProps(l);
                this.translator.changeLanguage(l);
                this.isLanguageChangingTo = undefined;
                this.emit('languageChanged', l);
                this.logger.log('languageChanged', l);
              } else {
                this.isLanguageChangingTo = undefined;
              }
              deferred.resolve(function () {
                return _this2.t(...arguments);
              });
              if (callback) callback(err, function () {
                return _this2.t(...arguments);
              });
            };
            const setLng = lngs => {
              if (!lng && !lngs && this.services.languageDetector) lngs = [];
              const l = isString$1(lngs) ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
              if (l) {
                if (!this.language) {
                  setLngProps(l);
                }
                if (!this.translator.language) this.translator.changeLanguage(l);
                if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l);
              }
              this.loadResources(l, err => {
                done(err, l);
              });
            };
            if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
              setLng(this.services.languageDetector.detect());
            } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
              if (this.services.languageDetector.detect.length === 0) {
                this.services.languageDetector.detect().then(setLng);
              } else {
                this.services.languageDetector.detect(setLng);
              }
            } else {
              setLng(lng);
            }
            return deferred;
          }
          getFixedT(lng, ns, keyPrefix) {
            var _this3 = this;
            const _fixedT = function fixedT(key, opts) {
              let options;
              if (typeof opts !== 'object') {
                for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
                  rest[_key3 - 2] = arguments[_key3];
                }
                options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
              } else {
                options = _objectSpread3({}, opts);
              }
              options.lng = options.lng || _fixedT.lng;
              options.lngs = options.lngs || _fixedT.lngs;
              options.ns = options.ns || _fixedT.ns;
              if (options.keyPrefix !== '') options.keyPrefix = options.keyPrefix || keyPrefix || _fixedT.keyPrefix;
              const keySeparator = _this3.options.keySeparator || '.';
              let resultKey;
              if (options.keyPrefix && Array.isArray(key)) {
                resultKey = key.map(k => `${options.keyPrefix}${keySeparator}${k}`);
              } else {
                resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
              }
              return _this3.t(resultKey, options);
            };
            if (isString$1(lng)) {
              _fixedT.lng = lng;
            } else {
              _fixedT.lngs = lng;
            }
            _fixedT.ns = ns;
            _fixedT.keyPrefix = keyPrefix;
            return _fixedT;
          }
          t() {
            return this.translator && this.translator.translate(...arguments);
          }
          exists() {
            return this.translator && this.translator.exists(...arguments);
          }
          setDefaultNamespace(ns) {
            this.options.defaultNS = ns;
          }
          hasLoadedNamespace(ns) {
            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            if (!this.isInitialized) {
              this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
              return false;
            }
            if (!this.languages || !this.languages.length) {
              this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
              return false;
            }
            const lng = options.lng || this.resolvedLanguage || this.languages[0];
            const fallbackLng = this.options ? this.options.fallbackLng : false;
            const lastLng = this.languages[this.languages.length - 1];
            if (lng.toLowerCase() === 'cimode') return true;
            const loadNotPending = (l, n) => {
              const loadState = this.services.backendConnector.state[`${l}|${n}`];
              return loadState === -1 || loadState === 0 || loadState === 2;
            };
            if (options.precheck) {
              const preResult = options.precheck(this, loadNotPending);
              if (preResult !== undefined) return preResult;
            }
            if (this.hasResourceBundle(lng, ns)) return true;
            if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
            if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
            return false;
          }
          loadNamespaces(ns, callback) {
            const deferred = defer();
            if (!this.options.ns) {
              if (callback) callback();
              return Promise.resolve();
            }
            if (isString$1(ns)) ns = [ns];
            ns.forEach(n => {
              if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);
            });
            this.loadResources(err => {
              deferred.resolve();
              if (callback) callback(err);
            });
            return deferred;
          }
          loadLanguages(lngs, callback) {
            const deferred = defer();
            if (isString$1(lngs)) lngs = [lngs];
            const preloaded = this.options.preload || [];
            const newLngs = lngs.filter(lng => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
            if (!newLngs.length) {
              if (callback) callback();
              return Promise.resolve();
            }
            this.options.preload = preloaded.concat(newLngs);
            this.loadResources(err => {
              deferred.resolve();
              if (callback) callback(err);
            });
            return deferred;
          }
          dir(lng) {
            if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
            if (!lng) return 'rtl';
            const rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'];
            const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get$4());
            return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';
          }
          static createInstance() {
            let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            let callback = arguments.length > 1 ? arguments[1] : undefined;
            return new I18n(options, callback);
          }
          cloneInstance() {
            let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
            const forkResourceStore = options.forkResourceStore;
            if (forkResourceStore) delete options.forkResourceStore;
            const mergedOptions = _objectSpread3(_objectSpread3(_objectSpread3({}, this.options), options), {
              isClone: true
            });
            const clone = new I18n(mergedOptions);
            if (options.debug !== undefined || options.prefix !== undefined) {
              clone.logger = clone.logger.clone(options);
            }
            const membersToCopy = ['store', 'services', 'language'];
            membersToCopy.forEach(m => {
              clone[m] = this[m];
            });
            clone.services = _objectSpread3({}, this.services);
            clone.services.utils = {
              hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
            };
            if (forkResourceStore) {
              clone.store = new ResourceStore(this.store.data, mergedOptions);
              clone.services.resourceStore = clone.store;
            }
            clone.translator = new Translator(clone.services, mergedOptions);
            clone.translator.on('*', function (event) {
              for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
                args[_key4 - 1] = arguments[_key4];
              }
              clone.emit(event, ...args);
            });
            clone.init(mergedOptions, callback);
            clone.translator.options = mergedOptions;
            clone.translator.backendConnector.services.utils = {
              hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
            };
            return clone;
          }
          toJSON() {
            return {
              options: this.options,
              store: this.store,
              language: this.language,
              languages: this.languages,
              resolvedLanguage: this.resolvedLanguage
            };
          }
        }
        const instance = I18n.createInstance();
        instance.createInstance = I18n.createInstance;
        instance.createInstance;
        instance.dir;
        instance.init;
        instance.loadResources;
        instance.reloadResources;
        instance.use;
        instance.changeLanguage;
        instance.getFixedT;
        instance.t;
        instance.exists;
        instance.setDefaultNamespace;
        instance.hasLoadedNamespace;
        instance.loadNamespaces;
        instance.loadLanguages;
        var _translations;
        var translations = (_translations = {}, _defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_translations, EMPTY_GROUP, "Empty group"), EMPTY_RULE_GROUP, "No conditions for group field {{field}}"), EMPTY_QUERY, "Empty query"), EMPTY_CASE, "Empty case"), NO_CONFIG_FOR_FIELD, "No config for field {{field}}"), FIXED_OPERATOR, "Fixed operator {{from}} to {{to}} for field {{field}}"), NO_CONFIG_FOR_OPERATOR, "No config for operator {{operator}}"), NO_CONFIG_FOR_FUNCTION, "No config for function {{funcKey}}"), INVALID_VALUE, "Invalid value"), INVALID_FUNC_ARG_VALUE, "Invalid value of arg {{argName}} for func {{funcName}}: {{argValidationError}}"), _defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_translations, UNSUPPORTED_FIELD_TYPE, "Type of field {{field}} is not supported"), UNSUPPORTED_OPERATOR_FOR_FIELD, "Operator {{operator}} is not supported for field {{field}}"), INCOMPLETE_RULE, "Incomplete rule"), INCOMPLETE_LHS, "Incomplete LHS"), INCOMPLETE_RHS, "Incomplete RHS"), INVALID_VALUE_SRC, "Invalid value src {{valueSrcs, list}}"), BAD_MULTISELECT_VALUES + "_one", "Value {{badValues, list}} is not in the list of allowed values"), BAD_MULTISELECT_VALUES + "_other", "Values {{badValues, list}} are not in the list of allowed values"), BAD_SELECT_VALUE, "Value {{value}} is not in the list of allowed values"), INCORRECT_VALUE_TYPE, "Value should have type {{wType}}, but got value of type {{valueType}}"), _defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_translations, INCORRECT_VALUE_JS_TYPE, "Value should have JS type {{jsType}}, but got value of type {{valueTypeof}}"), VALUE_LENGTH_CONSTRAINT_FAIL, "Value {{value}} should have max length {{fieldSettings.maxLength}} but got {{length}}"), VALUE_MIN_CONSTRAINT_FAIL, "Value {{value}} should be greater than or equal to {{fieldSettings.min}}"), VALUE_MIN_CONSTRAINT_FAIL + "_" + _CONTEXT_MIN_MAX, "Value {{value}} should be from {{fieldSettings.min}} to {{fieldSettings.max}}"), VALUE_MAX_CONSTRAINT_FAIL, "Value {{value}} should be less than or equal to {{fieldSettings.max}}"), VALUE_MAX_CONSTRAINT_FAIL + "_" + _CONTEXT_MIN_MAX, "Value {{value}} should be from {{fieldSettings.min}} to {{fieldSettings.max}}"), NO_CONFIG_FOR_FIELD_VALUE, "No config for field {{field}}"), CANT_COMPARE_FIELD_WITH_ITSELF, "Can't compare field {{field}} with itself"), CANT_COMPARE_FIELD_WITH_FIELD, "Can't compare field {{leftField}} with {{rightField}}"), INCORRECT_FIELD_TYPE, "Field {{field}} is of type {{type}}, but expected {{expected}}"), _defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_translations, UNSUPPORTED_FUNCTION_FOR_FIELD, "Unsupported function {{funcKey}} for field {{field}}"), REQUIRED_FUNCTION_ARG, "Value of arg {{argName}} for func {{funcName}} is required"), INCORRECT_FUNCTION_RETURN_TYPE, "Function {{funcKey}} should return value of type {{returnType}}, but got {{valueType}}"), INVALID_RANGE, "Invalid range"), ITEM_POSITION_ROOT, "Root"), ITEM_POSITION + "__rule", "Leaf #{{globalLeafNo}}"), ITEM_POSITION + "__group", "Group #{{globalGroupNo}}"), ITEM_POSITION + "__rule_group", "Rule-group #{{globalNoByType}}"), ITEM_POSITION + "__case_group", "Case #{{globalNoByType}}"), ITEM_POSITION + "__rule__deleted", "Deleted leaf #{{globalLeafNo}}"), _defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_translations, ITEM_POSITION + "__group__deleted", "Deleted group #{{globalGroupNo}}"), ITEM_POSITION + "__rule_group__deleted", "Deleted rule-group #{{globalNoByType}}"), ITEM_POSITION + "__case_group__deleted", "Deleted case #{{globalNoByType}}"), ITEM_POSITION_IN_CASE, "{{str}} in case #{{caseNo}}"), ITEM_POSITION_WITH_INDEX_PATH, "{{str}} (index path: {{indexPath, list}})"));
        var NSV = "raqbvalidation";
        var NSVP = "".concat(NSV, ":");
        var i18n = instance.createInstance();
        i18n.init({
          fallbackLng: "en"
        });
        i18n.addResources("en", NSV, translations);
        var translateValidation = function translateValidation(key, args) {
          if (key !== null && key !== void 0 && key.str) {
            // already translated
            return key.str;
          }
          if (key !== null && key !== void 0 && key.key) {
            return translateValidation(key.key, key.args);
          }
          if (args === null) {
            return key;
          }
          return i18n.t(key.includes(":") ? key : NSVP + key, args);
        };
        function ownKeys$w(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$w(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$w(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$w(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        var typeOf = function typeOf(v) {
          if (_typeof$3(v) === "object" && v !== null && Array.isArray(v)) return "array";else return _typeof$3(v);
        };
        var isTypeOf = function isTypeOf(v, type) {
          if (typeOf(v) === type) return true;
          if (type === "number" && !isNaN(v)) return true; //can be casted
          return false;
        };

        // tip: If showErrorMessage is false, this function will always return true
        var isValidTree = function isValidTree(tree, config) {
          return getTreeBadFields(tree, config).length === 0;
        };

        // tip: If showErrorMessage is false, this function will always return []
        // tip: If LHS is func, func key will be used to put in array of bad fields (naive)
        var getTreeBadFields = function getTreeBadFields(tree, config) {
          var showErrorMessage = config.settings.showErrorMessage;
          var badFields = [];
          function _processNode(item, path, lev) {
            var _field$get, _field$get2;
            var id = item.get("id");
            var children = item.get("children1");
            var valueError = item.getIn(["properties", "valueError"]);
            var fieldError = item.getIn(["properties", "fieldError"]);
            var field = item.getIn(["properties", "field"]);
            var fieldStr = (_field$get = field === null || field === void 0 || (_field$get2 = field.get) === null || _field$get2 === void 0 ? void 0 : _field$get2.call(field, "func")) !== null && _field$get !== void 0 ? _field$get : field;
            var hasValueError = (valueError === null || valueError === void 0 ? void 0 : valueError.size) > 0 && valueError.filter(function (v) {
              return v != null;
            }).size > 0;
            var isBad = hasValueError || !!fieldError;
            if (isBad && showErrorMessage) {
              // for showErrorMessage=false valueError/fieldError is used to hold last error, but actual value is always valid
              badFields.push(fieldStr);
            }
            if (children) {
              children.map(function (child, _childId) {
                if (child) {
                  _processNode(child, path.concat(id));
                }
              });
            }
          }
          if (tree) _processNode(tree, []);
          return Array.from(new Set(badFields));
        };

        // @deprecated
        var checkTree = function checkTree(tree, config) {
          var extendedConfig = extendConfig(config, undefined, true);
          var options = {
            removeEmptyGroups: config.settings.removeEmptyGroupsOnLoad,
            removeIncompleteRules: config.settings.removeIncompleteRulesOnLoad,
            removeEmptyRules: config.settings.removeEmptyRulesOnLoad,
            forceFix: false
          };
          var _validateTree2 = _validateTree(tree, null, extendedConfig, extendedConfig, options),
            fixedTree = _validateTree2.fixedTree,
            allErrors = _validateTree2.allErrors,
            isSanitized = _validateTree2.isSanitized;
          if (isSanitized && allErrors.length) {
            console.warn("Tree check errors: ", allErrors);
          }
          return fixedTree;
        };

        /**
         * @param {Immutable.Map} tree
         * @param {SanitizeOptions} options
         * @returns {ValidationItemErrors[]}
        */
        var validateTree = function validateTree(tree, config) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var extendedConfig = extendConfig(config, undefined, true);
          var finalOptions = _objectSpread$w(_objectSpread$w({}, options), {}, {
            // disbale sanitize options, just validate
            removeEmptyGroups: false,
            removeEmptyRules: false,
            removeIncompleteRules: false,
            forceFix: false
          });
          var _validateTree3 = _validateTree(tree, null, extendedConfig, extendedConfig, finalOptions),
            allErrors = _validateTree3.allErrors;
          return allErrors;
        };

        /**
         * @param {Immutable.Map} tree
         * @param {SanitizeOptions} options
         * @returns {{
         *   fixedTree: Immutable.Map, 
         *   fixedErrors: ValidationItemErrors[],
         *   nonFixedErrors: ValidationItemErrors[],
         *   allErrors: ValidationItemErrors[],
         * }}
         */
        var sanitizeTree = function sanitizeTree(tree, config) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var extendedConfig = extendConfig(config, undefined, true);
          var finalOptions = _objectSpread$w({
            // defaults
            removeEmptyGroups: true,
            removeEmptyRules: true,
            removeIncompleteRules: true,
            forceFix: false
          }, options);
          var _validateTree4 = _validateTree(tree, null, extendedConfig, extendedConfig, finalOptions),
            fixedTree = _validateTree4.fixedTree,
            fixedErrors = _validateTree4.fixedErrors,
            nonFixedErrors = _validateTree4.nonFixedErrors,
            allErrors = _validateTree4.allErrors;
          return {
            fixedTree: fixedTree,
            fixedErrors: fixedErrors,
            nonFixedErrors: nonFixedErrors,
            allErrors: allErrors
          };
        };

        // tip: Should be used only internally in createValidationMemo()
        var validateAndFixTree$1 = function validateAndFixTree(newTree, _oldTree, newConfig, oldConfig, removeEmptyGroups, removeEmptyRules, removeIncompleteRules) {
          if (removeEmptyGroups === undefined) {
            removeEmptyGroups = newConfig.settings.removeEmptyGroupsOnLoad;
          }
          if (removeEmptyRules === undefined) {
            removeEmptyRules = newConfig.settings.removeEmptyRulesOnLoad;
          }
          if (removeIncompleteRules === undefined) {
            removeIncompleteRules = newConfig.settings.removeIncompleteRulesOnLoad;
          }
          var options = {
            // sanitize options
            removeEmptyGroups: removeEmptyGroups,
            removeEmptyRules: removeEmptyRules,
            removeIncompleteRules: removeIncompleteRules,
            forceFix: false
          };
          var _validateTree5 = _validateTree(newTree, _oldTree, newConfig, oldConfig, options),
            fixedTree = _validateTree5.fixedTree;
          _validateTree5.allErrors;
          var fixedErrors = _validateTree5.fixedErrors;
          _validateTree5.nonFixedErrors;
          var isSanitized = _validateTree5.isSanitized;
          if (isSanitized && fixedErrors.length) {
            console.warn("Fixed tree errors: ", fixedErrors);
          }
          // if (nonFixedErrors.length) {
          //   console.info("Tree validation errors: ", nonFixedErrors);
          // }
          fixedTree = fixPathsInTree(fixedTree);
          return fixedTree;
        };

        /**
         * @param {Immutable.Map} tree
         * @param {SanitizeOptions} options
         * @typedef {{
         *   removeEmptyGroups?: boolean,
         *   removeEmptyRules?: boolean,
         *   removeIncompleteRules?: boolean,
         *   forceFix?: boolean,
         *   translateErrors?: boolean,
         *   includeStringifiedItems?: boolean,
         *   stringifyFixedItems?: boolean,
         *   stringifyItemsUserFriendly?: boolean,
         *   includeItemsPositions?: boolean,
         * }} SanitizeOptions
         * @typedef {{
         *   path: string[],
         *   errors: {
         *     key: string, args?: object | null, str?: string,
         *     side?: "lhs"|"rhs"|"op", delta?: number, fixed?: boolean, fixedTo?: any, fixedFrom?: any,
         *   }[],
         *   itemStr?: string,
         *   itemPosition?: {
         *     caseNo: number | null, globalNoByType: number, indexPath: number[], globalLeafNo?: number, globalGroupNo?: number,
         *     isDeleted: boolean, index: number, type: "rule"|"group"|"rule_group"
         *   },
         *   itemPositionStr?: string,
         * }} ValidationItemErrors
         * @returns {{
         *   fixedTree: Immutable.Map, 
         *   allErrors: ValidationItemErrors[],
         *   fixedErrors: ValidationItemErrors[],
         *   nonFixedErrors: ValidationItemErrors[],
         *   isSanitized: boolean
         * }}
         */
        var _validateTree = function _validateTree(tree, _oldTree, config, oldConfig, options) {
          if (!tree) {
            return {
              fixedTree: tree,
              allErrors: [],
              fixedErrors: [],
              nonFixedErrors: [],
              isSanitized: false
            };
          }
          var _ref = options || {},
            removeEmptyGroups = _ref.removeEmptyGroups,
            removeEmptyRules = _ref.removeEmptyRules,
            removeIncompleteRules = _ref.removeIncompleteRules,
            forceFix = _ref.forceFix,
            _ref$translateErrors = _ref.translateErrors,
            translateErrors = _ref$translateErrors === void 0 ? true : _ref$translateErrors,
            _ref$includeStringifi = _ref.includeStringifiedItems,
            includeStringifiedItems = _ref$includeStringifi === void 0 ? true : _ref$includeStringifi,
            _ref$stringifyFixedIt = _ref.stringifyFixedItems,
            stringifyFixedItems = _ref$stringifyFixedIt === void 0 ? false : _ref$stringifyFixedIt,
            _ref$stringifyItemsUs = _ref.stringifyItemsUserFriendly,
            stringifyItemsUserFriendly = _ref$stringifyItemsUs === void 0 ? true : _ref$stringifyItemsUs,
            _ref$includeItemsPosi = _ref.includeItemsPositions,
            includeItemsPositions = _ref$includeItemsPosi === void 0 ? true : _ref$includeItemsPosi;
          var c = {
            config: config,
            oldConfig: oldConfig,
            removeEmptyGroups: removeEmptyGroups,
            removeEmptyRules: removeEmptyRules,
            removeIncompleteRules: removeIncompleteRules,
            forceFix: forceFix
          };
          var meta = {
            errors: {}
          };
          var fixedTree = validateItem(tree, [], null, meta, c);
          var isSanitized = meta.sanitized;

          // build allErrors
          var allErrors = [];
          var flatItems, oldFlatItems;
          if (includeItemsPositions) {
            flatItems = getFlatTree$1(fixedTree).items;
          }
          for (var id in meta.errors) {
            var _meta$errors$id = meta.errors[id],
              path = _meta$errors$id.path,
              errors = _meta$errors$id.errors;
            if (translateErrors) {
              errors = errors.map(function (e) {
                return _objectSpread$w(_objectSpread$w({}, e), {}, {
                  str: translateValidation(e)
                });
              });
            }
            var errorItem = {
              path: path,
              errors: errors
            };
            if (includeStringifiedItems) {
              var item = getItemByPath(stringifyFixedItems ? fixedTree : tree, path);
              var isRoot = path.length === 1;
              if (!isRoot && item.get("type") !== "group") {
                var isDebugMode = true;
                var isForDisplay = stringifyItemsUserFriendly;
                var itemStr = queryString(item, config, isForDisplay, isDebugMode);
                errorItem.itemStr = itemStr;
              }
            }
            if (includeItemsPositions) {
              var flatItem = flatItems[id];
              var isDeleted = !flatItem;
              if (isDeleted) {
                // get positions from old tree
                if (!oldFlatItems) {
                  oldFlatItems = getFlatTree$1(tree).items;
                }
                flatItem = oldFlatItems[id];
              }
              if (flatItem) {
                // build position object
                var itemPosition = _objectSpread$w(_objectSpread$w({}, flatItem.position), {}, {
                  index: flatItem.index,
                  type: flatItem.type,
                  isDeleted: isDeleted
                });
                errorItem.itemPosition = itemPosition;
                // build position string
                var trKey = !flatItem.index ? ITEM_POSITION_ROOT : ITEM_POSITION + "__" + flatItem.type + (isDeleted ? "__deleted" : "");
                var trArgs = _objectSpread$w({}, itemPosition);
                if (stringifyItemsUserFriendly) {
                  var _itemPosition$indexPa;
                  // convert indexes from 0-based to 1-based (user friendly)
                  for (var _i = 0, _arr = ["caseNo", "globalLeafNo", "globalGroupNo", "globalNoByType"]; _i < _arr.length; _i++) {
                    var k = _arr[_i];
                    if (trArgs[k] != undefined) {
                      trArgs[k] = trArgs[k] + 1;
                    }
                  }
                  trArgs.indexPath = (_itemPosition$indexPa = itemPosition.indexPath) === null || _itemPosition$indexPa === void 0 ? void 0 : _itemPosition$indexPa.map(function (ind) {
                    return ind + 1;
                  });
                }
                errorItem.itemPositionStr = translateValidation(trKey, trArgs);
                if (flatItem.index) {
                  // don't extend for root
                  if (flatItem.caseId && flatItem.type !== "case_group") {
                    errorItem.itemPositionStr = translateValidation(ITEM_POSITION_IN_CASE, _objectSpread$w(_objectSpread$w({}, trArgs), {}, {
                      str: errorItem.itemPositionStr
                    }));
                  }
                  if (flatItem.type !== "case_group") {
                    errorItem.itemPositionStr = translateValidation(ITEM_POSITION_WITH_INDEX_PATH, _objectSpread$w(_objectSpread$w({}, trArgs), {}, {
                      str: errorItem.itemPositionStr
                    }));
                  }
                }
              }
            }
            allErrors.push(errorItem);
          }

          // split allErrors to fixedErrors and nonFixedErrors
          var fixedErrors = [];
          var nonFixedErrors = [];
          for (var _i2 = 0, _allErrors = allErrors; _i2 < _allErrors.length; _i2++) {
            var itemErrors = _allErrors[_i2];
            var fixedItemErrors = itemErrors.errors.filter(function (e) {
              return !!e.fixed;
            });
            var nonFixedItemErrors = itemErrors.errors.filter(function (e) {
              return !e.fixed && e.key !== "EMPTY_QUERY";
            });
            if (fixedItemErrors.length) {
              fixedErrors.push(_objectSpread$w(_objectSpread$w({}, itemErrors), {}, {
                errors: fixedItemErrors
              }));
            }
            if (nonFixedItemErrors.length) {
              nonFixedErrors.push(_objectSpread$w(_objectSpread$w({}, itemErrors), {}, {
                errors: nonFixedItemErrors
              }));
            }
          }
          return {
            fixedTree: fixedTree,
            allErrors: allErrors,
            fixedErrors: fixedErrors,
            nonFixedErrors: nonFixedErrors,
            isSanitized: isSanitized
          };
        };
        function _addError(meta, item, path, err) {
          var id = item.get("id");
          if (!meta.errors[id]) {
            meta.errors[id] = {
              path: [].concat(_toConsumableArray(path), [id]),
              errors: []
            };
          }
          meta.errors[id].errors.push(err);
        }
        function _setErrorsAsFixed(meta, item) {
          var id = item.get("id");
          if (meta.errors[id]) {
            meta.errors[id].errors.map(function (e) {
              e.fixed = true;
            });
          }
        }
        function validateItem(item, path, itemId, meta, c) {
          var type = item === null || item === void 0 ? void 0 : item.get("type");
          if (type === "group" || type === "rule_group" || type == "case_group" || type == "switch_group") {
            return validateGroup(item, path, itemId, meta, c);
          } else if (type === "rule") {
            return validateRule(item, path, itemId, meta, c);
          } else {
            return item;
          }
        }
        function validateGroup(item, path, itemId, meta, c) {
          var _properties$get, _config$operators$ope, _config$operators$ope2, _children, _children2, _children3;
          var removeEmptyGroups = c.removeEmptyGroups,
            removeIncompleteRules = c.removeIncompleteRules;
          c.forceFix;
          var config = c.config;
          config.settings.showErrorMessage;
          var id = item.get("id");
          var children = item.get("children1");
          var isRoot = !path.length;
          var oldChildren = children;
          var type = item.get("type");
          var properties = item.get("properties");
          var field = properties === null || properties === void 0 ? void 0 : properties.get("field");
          var mode = properties === null || properties === void 0 ? void 0 : properties.get("mode");
          var operator = properties === null || properties === void 0 || (_properties$get = properties.get) === null || _properties$get === void 0 ? void 0 : _properties$get.call(properties, "operator");
          var isGroupExt = type === "rule_group" && mode === "array";
          var isCase = type === "case_group";
          var isDefaultCase = isCase && children == undefined;
          var cardinality = operator ? (_config$operators$ope = (_config$operators$ope2 = config.operators[operator]) === null || _config$operators$ope2 === void 0 ? void 0 : _config$operators$ope2.cardinality) !== null && _config$operators$ope !== void 0 ? _config$operators$ope : 1 : undefined;
          // tip: for group operators some/none/all children ARE required, for group operator count children are NOT required
          // tip: default case should contain only value
          var childrenAreRequired = isCase ? !isDefaultCase : isGroupExt ? cardinality == 0 : removeEmptyGroups;
          var canHaveValue = isGroupExt || isCase;
          if (!id && itemId) {
            id = itemId;
            item = item.set("id", id);
            meta.sanitized = true;
          }
          if (canHaveValue) {
            item = validateRule(item, path, itemId, meta, c);
          }

          //validate children
          var submeta = {
            errors: {}
          };
          children = (_children = children) === null || _children === void 0 ? void 0 : _children.map(function (currentChild, childId) {
            return validateItem(currentChild, path.concat(id), childId, submeta, c);
          });
          var nonEmptyChildren = (_children2 = children) === null || _children2 === void 0 ? void 0 : _children2.filter(function (currentChild) {
            return currentChild != undefined;
          });
          if (removeEmptyGroups) {
            children = nonEmptyChildren;
          }
          var sanitized = submeta.sanitized || (oldChildren === null || oldChildren === void 0 ? void 0 : oldChildren.size) != ((_children3 = children) === null || _children3 === void 0 ? void 0 : _children3.size);
          var isEmptyChildren = !(nonEmptyChildren !== null && nonEmptyChildren !== void 0 && nonEmptyChildren.size);
          var canDrop = removeEmptyGroups && !isRoot;
          if (isGroupExt && field) {
            // to remove rule-group like "SOME cars" (with SOME/ALL/NONE, but without filters), we need to rely on removeIncompleteRules
            canDrop = removeIncompleteRules;
          }
          if (isEmptyChildren && childrenAreRequired) {
            _addError(meta, item, path, {
              key: isRoot ? EMPTY_QUERY : isCase ? EMPTY_CASE : isGroupExt ? EMPTY_RULE_GROUP : EMPTY_GROUP,
              args: {
                field: field
              },
              fixed: canDrop
            });
            if (canDrop) {
              _setErrorsAsFixed(meta, item);
              item = undefined;
            }
          }
          if (sanitized) meta.sanitized = true;
          if (sanitized && item) item = item.set("children1", children);
          meta.errors = _objectSpread$w(_objectSpread$w({}, meta.errors), (submeta === null || submeta === void 0 ? void 0 : submeta.errors) || {});
          return item;
        }

        /**
         * @param {Immutable.Map} item
         * @returns {Immutable.Map}
         */
        function validateRule(item, path, itemId, meta, c) {
          var removeIncompleteRules = c.removeIncompleteRules,
            removeEmptyRules = c.removeEmptyRules,
            forceFix = c.forceFix,
            config = c.config,
            oldConfig = c.oldConfig;
          var showErrorMessage = config.settings.showErrorMessage;
          var canFix = !showErrorMessage || forceFix;
          var id = item.get("id");
          var type = item.get("type");
          var isCase = type === "case_group";
          var properties = item.get("properties");
          if (!properties) {
            if (isCase) {
              properties = new Immutable.Map();
            } else {
              var err = {
                key: INCOMPLETE_RULE,
                args: {},
                fixed: removeIncompleteRules || removeEmptyRules
              };
              _addError(meta, item, path, err);
              return undefined;
            }
          }
          var field = properties.get("field") || null;
          if (isCase) {
            field = "!case_value";
          }
          var fieldSrc = properties.get("fieldSrc") || null;
          var operator = properties.get("operator") || null;
          var operatorOptions = properties.get("operatorOptions");
          var valueSrc = properties.get("valueSrc");
          var value = properties.get("value");
          var valueError = properties.get("valueError");
          var fieldError = properties.get("fieldError");
          var serializeRule = function serializeRule() {
            var _field, _field$toJS;
            return {
              field: ((_field = field) === null || _field === void 0 || (_field$toJS = _field.toJS) === null || _field$toJS === void 0 ? void 0 : _field$toJS.call(_field)) || field,
              fieldSrc: fieldSrc,
              operator: operator,
              operatorOptions: operatorOptions ? operatorOptions.toJS() : {},
              valueSrc: valueSrc ? valueSrc.toJS() : null,
              value: value ? value.toJS() : null,
              valueError: valueError ? valueError.toJS() : null,
              fieldError: fieldError ? fieldError : null
            };
          };
          var oldSerialized = serializeRule();
          //const _wasValid = field && operator && value && !value.includes(undefined);

          if (!id && itemId) {
            id = itemId;
            item = item.set("id", id);
            meta.sanitized = true;
          }

          //validate field
          var fieldDefinition = field ? getFieldConfig$8(config, field) : null;
          if (field && !fieldDefinition) {
            _addError(meta, item, path, {
              key: NO_CONFIG_FOR_FIELD,
              args: {
                field: field
              },
              side: "lhs",
              fixed: removeIncompleteRules || removeEmptyRules
            });
            field = null;
          }
          if (field == null && !isCase) {
            properties = ["operator", "operatorOptions", "valueSrc", "value", "valueError", "fieldError", "field"].reduce(function (map, key) {
              return map["delete"](key);
            }, properties);
            operator = null;
          }
          if (!fieldSrc && field && !isCase) {
            fieldSrc = getFieldSrc(field);
            properties = properties.set("fieldSrc", fieldSrc);
          }

          //validate operator
          // Backward compatibility: obsolete operator range_between
          if (operator === "range_between" || operator === "range_not_between") {
            operator = operator === "range_between" ? "between" : "not_between";
            // _addError(meta, item, path, {
            //   type: "fix",
            //   key: constants.FIXED_OPERATOR,
            //   args: { from: properties.get("operator"), to: operator, field }
            // });
            properties = properties.set("operator", operator);
          }
          var operatorDefinition = operator ? getOperatorConfig$4(config, operator, field) : null;
          if (operator && !operatorDefinition) {
            _addError(meta, item, path, {
              key: NO_CONFIG_FOR_OPERATOR,
              args: {
                operator: operator
              },
              side: "op",
              fixed: removeIncompleteRules || removeEmptyRules
            });
            operator = null;
          }
          var availOps = field ? getOperatorsForField(config, field) : [];
          if (field && !isCase) {
            if (!(availOps !== null && availOps !== void 0 && availOps.length)) {
              _addError(meta, item, path, {
                key: UNSUPPORTED_FIELD_TYPE,
                args: {
                  field: field
                },
                side: "lhs",
                fixed: removeIncompleteRules || removeEmptyRules
              });
              operator = null;
            } else if (operator && availOps.indexOf(operator) == -1) {
              if (operator === "is_empty" || operator === "is_not_empty") {
                // Backward compatibility: is_empty #494
                operator = operator === "is_empty" ? "is_null" : "is_not_null";
                // _addError(meta, item, path, {
                //   type: "fix",
                //   key: constants.FIXED_OPERATOR,
                //   args: { from: properties.get("operator"), to: operator, field }
                // });
                properties = properties.set("operator", operator);
              } else {
                _addError(meta, item, path, {
                  key: UNSUPPORTED_OPERATOR_FOR_FIELD,
                  args: {
                    operator: operator,
                    field: field
                  },
                  side: "lhs",
                  fixed: removeIncompleteRules || removeEmptyRules
                });
                operator = null;
              }
            }
          }
          if (operator == null && !isCase) {
            // do not unset operator ?
            properties = ["operatorOptions", "valueSrc", "value", "valueError"].reduce(function (map, key) {
              return map["delete"](key);
            }, properties);
          }

          //validate operator options
          operatorOptions = properties.get("operatorOptions");
          //const _operatorCardinality = operator ? getOpCardinality(operatorDefinition) : null;
          if (!operator || operatorOptions && !operatorDefinition.options) {
            operatorOptions = null;
            properties = properties["delete"]("operatorOptions");
          } else if (operator && !operatorOptions && operatorDefinition.options) {
            operatorOptions = defaultOperatorOptions(config, operator, field);
            properties = properties.set("operatorOptions", operatorOptions);
          }

          //validate values
          valueSrc = properties.get("valueSrc");
          value = properties.get("value");
          var isEndValue = true;
          var _getNewValueForFieldO = getNewValueForFieldOp(config, oldConfig, properties, field, operator, null, canFix, isEndValue),
            newValue = _getNewValueForFieldO.newValue,
            newValueSrc = _getNewValueForFieldO.newValueSrc,
            newValueError = _getNewValueForFieldO.newValueError,
            validationErrors = _getNewValueForFieldO.validationErrors,
            newFieldError = _getNewValueForFieldO.newFieldError,
            fixedField = _getNewValueForFieldO.fixedField;
          value = newValue;
          valueSrc = newValueSrc;
          valueError = newValueError;
          fieldError = newFieldError;
          field = fixedField;
          properties = properties.set("field", field);
          properties = properties.set("value", value);
          properties = properties.set("valueSrc", valueSrc);
          if (showErrorMessage) {
            properties = properties.set("valueError", valueError).set("fieldError", fieldError);
          } else {
            properties = properties["delete"]("valueError")["delete"]("fieldError");
          }
          var newSerialized = serializeRule();
          var hasBeenSanitized = !deepEqual(oldSerialized, newSerialized);
          var compl = whatRulePropertiesAreCompleted(properties.toObject(), config);
          var isCompleted = isCase ? compl.parts.value : compl.score >= 3;
          if (hasBeenSanitized) {
            meta.sanitized = true;
            item = item.set("properties", properties);
          }
          validationErrors === null || validationErrors === void 0 || validationErrors.map(function (e) {
            return _addError(meta, item, path, e);
          });
          if (!isCompleted) {
            if (isCase) ;else {
              var shoudlRemoveRule = !compl.score ? removeEmptyRules : removeIncompleteRules;
              // if (shoudlRemoveRule && showErrorMessage) {
              //   // try to be not so rude about removing incomplete rule with functions
              //   const complLite = whatRulePropertiesAreCompleted(properties.toObject(), config, true);
              //   const isCompletedLite = complLite.score >= 3;
              //   if (isCompletedLite) {
              //     shoudlRemoveRule = false;
              //   }
              // }
              var incError = {
                key: INCOMPLETE_RULE,
                args: {}
              };
              if (!compl.parts.field) {
                incError.key = INCOMPLETE_LHS;
                incError.side = "lhs";
              } else if (!compl.parts.value) {
                var _newSerialized$valueS, _newSerialized$valueS2, _oldSerialized$valueS, _newSerialized$value;
                incError.key = INCOMPLETE_RHS;
                incError.side = "rhs";
                if ((_newSerialized$valueS = newSerialized.valueSrc) !== null && _newSerialized$valueS !== void 0 && _newSerialized$valueS[0] && ((_newSerialized$valueS2 = newSerialized.valueSrc) === null || _newSerialized$valueS2 === void 0 ? void 0 : _newSerialized$valueS2[0]) != ((_oldSerialized$valueS = oldSerialized.valueSrc) === null || _oldSerialized$valueS === void 0 ? void 0 : _oldSerialized$valueS[0]) && ((_newSerialized$value = newSerialized.value) === null || _newSerialized$value === void 0 ? void 0 : _newSerialized$value[0]) != undefined) {
                  // eg. operator `starts_with` supports only valueSrc "value"
                  incError.key = INVALID_VALUE_SRC;
                  incError.args = {
                    valueSrcs: newSerialized.valueSrc
                  };
                }
              }
              incError.fixed = shoudlRemoveRule;
              _addError(meta, item, path, incError);
              if (shoudlRemoveRule) {
                _setErrorsAsFixed(meta, item);
                item = undefined;
              }
            }
          }
          return item;
        }

        /**
         * 
         * @param {bool} canFix true is useful for func values to remove bad args
         * @param {bool} isEndValue false if value is in process of editing by user
         * @return {array} [fixedValue, allErrors] - if `allErrors` is empty and `canFix` == true, `fixedValue` can differ from value if was fixed.
         *  `allErrors` is an array of {key, args, fixed, fixedFrom, fixedTo}
         *  If `args` === null, `key` should not be translated
         */
        var validateValue = function validateValue(config, leftField, field, operator, value, valueType, valueSrc, asyncListValues) {
          var canFix = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
          var isEndValue = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
          var canDropArgs = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;
          var allErrors = [];
          var fixedValue = value;
          if (value != null) {
            var _allErrors2, _allErrors3, _allErrors4, _allErrors5;
            if (valueSrc === "field") {
              var _validateFieldValue = validateFieldValue(leftField, field, value, valueSrc, valueType, asyncListValues, config, operator, canFix, isEndValue);
              var _validateFieldValue2 = _slicedToArray$1(_validateFieldValue, 2);
              fixedValue = _validateFieldValue2[0];
              allErrors = _validateFieldValue2[1];
            } else if (valueSrc === "func") {
              var _validateFuncValue = validateFuncValue(leftField, field, value, valueSrc, valueType, asyncListValues, config, operator, canFix, isEndValue, canDropArgs);
              var _validateFuncValue2 = _slicedToArray$1(_validateFuncValue, 2);
              fixedValue = _validateFuncValue2[0];
              allErrors = _validateFuncValue2[1];
            } else if (valueSrc === "value" || !valueSrc) {
              var _validateNormalValue = validateNormalValue(field, value, valueSrc, valueType, asyncListValues, config, operator, canFix, isEndValue);
              var _validateNormalValue2 = _slicedToArray$1(_validateNormalValue, 2);
              fixedValue = _validateNormalValue2[0];
              allErrors = _validateNormalValue2[1];
            }
            var fixedAllErrors = !((_allErrors2 = allErrors) !== null && _allErrors2 !== void 0 && _allErrors2.find(function (e) {
              return !e.fixed;
            }));
            var shouldCallValidateFn = !!field
            // `validateValue` should not be available for valueSrc === "func" or "field"
            && !["field", "func"].includes(valueSrc)
            // eg. if value was > max, and fixed to max, but max value can not satisfy validateValue() in config
            && (!((_allErrors3 = allErrors) !== null && _allErrors3 !== void 0 && _allErrors3.length) || fixedAllErrors);
            if (shouldCallValidateFn) {
              //todo: why not just take fieldSettings from fieldConfig, why need to use getFieldWidgetConfig() ??
              // const fieldConfig = getFieldConfig(config, field);
              // const fieldSettings = fieldConfig?.fieldSettings;
              var w = getWidgetForFieldOp$3(config, field, operator, valueSrc);
              var operatorDefinition = operator ? getOperatorConfig$4(config, operator, field) : null;
              var fieldWidgetDefinition = getFieldWidgetConfig$3(config, field, operator, w, valueSrc, {
                forExport: true
              });
              var rightFieldDefinition = valueSrc === "field" ? getFieldConfig$8(config, value) : null;
              var fieldSettings = fieldWidgetDefinition; // widget definition merged with fieldSettings

              var fn = fieldWidgetDefinition.validateValue;
              if (typeof fn === "function") {
                var args = [fixedValue, fieldSettings, operator, operatorDefinition];
                if (valueSrc === "field") args.push(rightFieldDefinition);
                var validResult = fn.call.apply(fn, [config.ctx].concat(args));
                if (_typeof$3(validResult) === "object" && validResult !== null && !Array.isArray(validResult)) {
                  var _validResult$error;
                  var newError;
                  if ((_validResult$error = validResult.error) !== null && _validResult$error !== void 0 && _validResult$error.key) {
                    newError = _objectSpread$w({}, validResult.error);
                  } else {
                    // Note: `null` means it's not translated string!
                    newError = {
                      key: validResult.error,
                      args: null
                    };
                  }
                  if (validResult.fixedValue !== undefined && canFix) {
                    newError.fixed = true;
                    newError.fixedFrom = fixedValue;
                    newError.fixedTo = validResult.fixedValue;
                    fixedValue = validResult.fixedValue;
                  }
                  allErrors.push(newError);
                } else if (typeof validResult === "boolean") {
                  if (validResult == false) {
                    allErrors.push({
                      key: INVALID_VALUE,
                      args: {}
                    });
                  }
                } else if (typeof validResult === "string") {
                  allErrors.push({
                    key: validResult,
                    args: null
                  });
                }
              }
            }

            // if can't fix value, use defaultValue
            fixedAllErrors = !((_allErrors4 = allErrors) !== null && _allErrors4 !== void 0 && _allErrors4.find(function (e) {
              return !e.fixed;
            }));
            if ((_allErrors5 = allErrors) !== null && _allErrors5 !== void 0 && _allErrors5.length && !fixedAllErrors && canFix) {
              var fieldConfig = getFieldConfig$8(config, field);
              var _fieldSettings = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.fieldSettings;
              var defaultValue = _fieldSettings === null || _fieldSettings === void 0 ? void 0 : _fieldSettings.defaultValue;
              if (defaultValue !== undefined) {
                var lastError = allErrors[allErrors.length - 1];
                lastError.fixed = true;
                lastError.fixedFrom = fixedValue;
                lastError.fixedTo = defaultValue;
                fixedValue = defaultValue;
                // mark all errors as fixed
                allErrors.map(function (e) {
                  e.fixed = true;
                });
              }
            }
          }
          return [fixedValue, allErrors];
        };

        /**
         * 
         */
        var validateValueInList = function validateValueInList(value, listValues, canFix, isEndValue, removeInvalidMultiSelectValuesOnLoad) {
          var values = Immutable.List.isList(value) ? value.toJS() : value instanceof Array ? _toConsumableArray(value) : undefined;
          var fixedValue = value;
          var allErrors = [];
          if (values) {
            var _values$reduce = values.reduce(function (_ref2, val) {
                var _ref3 = _slicedToArray$1(_ref2, 2),
                  goodVals = _ref3[0],
                  badVals = _ref3[1];
                var vv = getItemInListValues(listValues, val);
                if (vv == undefined) {
                  return [goodVals, [].concat(_toConsumableArray(badVals), [val])];
                } else {
                  return [[].concat(_toConsumableArray(goodVals), [vv.value]), badVals];
                }
              }, [[], []]),
              _values$reduce2 = _slicedToArray$1(_values$reduce, 2),
              goodValues = _values$reduce2[0],
              badValues = _values$reduce2[1];
            var needFix = badValues.length > 0;
            // always remove bad values at tree validation as user can't unselect them (except AntDesign widget)
            canFix = canFix || removeInvalidMultiSelectValuesOnLoad === true;
            fixedValue = canFix && needFix ? goodValues : value;
            if (badValues.length) {
              var fixed = canFix && needFix;
              allErrors.push({
                key: BAD_MULTISELECT_VALUES,
                args: {
                  badValues: badValues,
                  count: badValues.length
                },
                fixed: fixed,
                fixedFrom: fixed ? values : undefined,
                fixedTo: fixed ? fixedValue : undefined
              });
            }
            return [fixedValue, allErrors];
          } else {
            var vv = getItemInListValues(listValues, value);
            if (vv == undefined) {
              fixedValue = canFix ? null : value;
              allErrors.push({
                key: BAD_SELECT_VALUE,
                args: {
                  value: value
                },
                fixed: canFix,
                fixedFrom: canFix ? value : undefined,
                fixedTo: canFix ? fixedValue : undefined
              });
            } else {
              fixedValue = vv.value;
            }
            return [fixedValue, allErrors];
          }
        };

        /**
         * 
         */
        var validateNormalValue = function validateNormalValue(field, value, valueSrc, valueType, asyncListValues, config) {
          var operator = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          var canFix = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
          var isEndValue = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
          var allErrors = [];
          var fixedValue = value;
          if (field) {
            var fieldConfig = getFieldConfig$8(config, field);
            var w = getWidgetForFieldOp$3(config, field, operator, valueSrc);
            var wConfig = config.widgets[w];
            var wType = wConfig === null || wConfig === void 0 ? void 0 : wConfig.type;
            var jsType = wConfig === null || wConfig === void 0 ? void 0 : wConfig.jsType;
            var fieldSettings = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.fieldSettings;
            var listValues = (fieldSettings === null || fieldSettings === void 0 ? void 0 : fieldSettings.treeValues) || (fieldSettings === null || fieldSettings === void 0 ? void 0 : fieldSettings.listValues);
            var isAsyncListValues = !!(fieldSettings !== null && fieldSettings !== void 0 && fieldSettings.asyncFetch);
            // todo: for select/multiselect value can be string or number
            var canSkipTypeCheck = listValues || isAsyncListValues;

            // validate type
            if (valueType && wType && valueType != wType) {
              allErrors.push({
                key: INCORRECT_VALUE_TYPE,
                args: {
                  wType: wType,
                  valueType: valueType
                }
              });
              return [value, allErrors];
            }
            if (jsType && !isTypeOf(value, jsType) && !canSkipTypeCheck) {
              allErrors.push({
                key: INCORRECT_VALUE_JS_TYPE,
                args: {
                  jsType: jsType,
                  valueTypeof: typeOf(value)
                }
              });
              return [value, allErrors];
            }
            if (fieldSettings) {
              // validate against list of values
              var realListValues = asyncListValues || listValues;
              // tip: "case_value" is deprecated, don't apply validation based on listValues
              if (realListValues && !fieldSettings.allowCustomValues && w !== "case_value") {
                var _validateValueInList = validateValueInList(value, realListValues, canFix, isEndValue, config.settings.removeInvalidMultiSelectValuesOnLoad);
                var _validateValueInList2 = _slicedToArray$1(_validateValueInList, 2);
                fixedValue = _validateValueInList2[0];
                allErrors = _validateValueInList2[1];
              }
              // validate length
              if (fieldSettings.maxLength > 0 && value != null && String(value).length > fieldSettings.maxLength) {
                fixedValue = canFix ? String(value).substring(0, fieldSettings.maxLength) : value;
                allErrors.push({
                  key: VALUE_LENGTH_CONSTRAINT_FAIL,
                  args: {
                    value: value,
                    length: String(value).length,
                    fieldSettings: fieldSettings
                  },
                  fixed: canFix,
                  fixedFrom: canFix ? value : undefined,
                  fixedTo: canFix ? fixedValue : undefined
                });
              }
              // validate min/max
              var minMaxContext = fieldSettings.min != undefined && fieldSettings.max != undefined ? _CONTEXT_MIN_MAX : undefined;
              if (fieldSettings.min != null && value < fieldSettings.min) {
                fixedValue = canFix ? fieldSettings.min : value;
                allErrors.push({
                  key: VALUE_MIN_CONSTRAINT_FAIL,
                  args: {
                    value: value,
                    fieldSettings: fieldSettings,
                    context: minMaxContext
                  },
                  fixed: canFix,
                  fixedFrom: canFix ? value : undefined,
                  fixedTo: canFix ? fixedValue : undefined
                });
              }
              if (fieldSettings.max != null && value > fieldSettings.max) {
                fixedValue = canFix ? fieldSettings.max : value;
                allErrors.push({
                  key: VALUE_MAX_CONSTRAINT_FAIL,
                  args: {
                    value: value,
                    fieldSettings: fieldSettings,
                    context: minMaxContext
                  },
                  fixed: canFix,
                  fixedFrom: canFix ? value : undefined,
                  fixedTo: canFix ? fixedValue : undefined
                });
              }
            }
          }
          return [fixedValue, allErrors];
        };

        /**
         * 
         */
        var validateFieldValue = function validateFieldValue(leftField, field, value, _valueSrc, valueType, asyncListValues, config) {
          var operator = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
          var allErrors = [];
          var _config$settings = config.settings,
            fieldSeparator = _config$settings.fieldSeparator,
            canCompareFieldWithField = _config$settings.canCompareFieldWithField;
          var isFuncArg = _typeof$3(field) == "object" && (field === null || field === void 0 ? void 0 : field._isFuncArg);
          var leftFieldStr = Array.isArray(leftField) ? leftField.join(fieldSeparator) : leftField;
          var leftFieldConfig = getFieldConfig$8(config, leftField);
          var rightFieldStr = Array.isArray(value) ? value.join(fieldSeparator) : value;
          var rightFieldConfig = getFieldConfig$8(config, value);
          if (!rightFieldConfig) {
            allErrors.push({
              key: NO_CONFIG_FOR_FIELD_VALUE,
              args: {
                field: rightFieldStr
              }
            });
            return [value, allErrors];
          }
          if (leftField && rightFieldStr === leftFieldStr && !isFuncArg) {
            allErrors.push({
              key: CANT_COMPARE_FIELD_WITH_ITSELF,
              args: {
                field: leftFieldStr
              }
            });
            return [value, allErrors];
          }
          if (valueType && valueType != rightFieldConfig.type) {
            allErrors.push({
              key: INCORRECT_FIELD_TYPE,
              args: {
                field: rightFieldStr,
                type: rightFieldConfig.type,
                expected: valueType
              }
            });
            return [value, allErrors];
          }
          if (leftField && !isFuncArg && canCompareFieldWithField) {
            var canUse = canCompareFieldWithField(leftFieldStr, leftFieldConfig, rightFieldStr, rightFieldConfig, operator);
            if (!canUse) {
              allErrors.push({
                key: CANT_COMPARE_FIELD_WITH_FIELD,
                args: {
                  leftField: leftFieldStr,
                  rightField: rightFieldStr
                }
              });
              return [value, allErrors];
            }
          }
          return [value];
        };

        /**
         * @param {bool} canDropArgs true only if user sets new func key
         */
        var validateFuncValue = function validateFuncValue(leftField, field, value, _valueSrc, valueType, asyncListValues, config) {
          var _value$get, _funcConfig$label;
          var operator = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
          var canFix = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
          var isEndValue = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
          var canDropArgs = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;
          var fixedValue = value;
          var allErrors = [];
          if (!value) {
            // empty value
            return [value];
          }
          var funcKey = (_value$get = value.get) === null || _value$get === void 0 ? void 0 : _value$get.call(value, "func");
          if (!funcKey) {
            // it's not a function value
            return [value];
          }
          var fieldDef = getFieldConfig$8(config, field);
          if (fieldDef !== null && fieldDef !== void 0 && fieldDef.funcs && !fieldDef.funcs.includes(funcKey)) {
            allErrors.push({
              key: UNSUPPORTED_FUNCTION_FOR_FIELD,
              args: {
                funcKey: funcKey,
                field: field
              }
            });
            return [value, allErrors];
          }
          var funcConfig = getFuncConfig$2(config, funcKey);
          if (!funcConfig) {
            allErrors.push({
              key: NO_CONFIG_FOR_FUNCTION,
              args: {
                funcKey: funcKey
              }
            });
            return [value, allErrors];
          }
          var funcName = (_funcConfig$label = funcConfig.label) !== null && _funcConfig$label !== void 0 ? _funcConfig$label : funcKey;
          if (valueType && funcConfig.returnType != valueType) {
            allErrors.push({
              key: INCORRECT_FUNCTION_RETURN_TYPE,
              args: {
                funcKey: funcKey,
                funcName: funcName,
                returnType: funcConfig.returnType,
                valueType: valueType
              }
            });
            return [value, allErrors];
          }
          //tip: Exception for canDropArgs (true only if changing func) - can fix/drop args to fit new func validations
          canFix = canFix || canDropArgs;
          for (var argKey in funcConfig.args) {
            var _argDef$label;
            var argConfig = funcConfig.args[argKey];
            var args = fixedValue.get("args");
            var argVal = args ? args.get(argKey) : undefined;
            var argDef = getFieldConfig$8(config, argConfig);
            var argName = (_argDef$label = argDef === null || argDef === void 0 ? void 0 : argDef.label) !== null && _argDef$label !== void 0 ? _argDef$label : argKey;
            var argValue = argVal ? argVal.get("value") : undefined;
            var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
            if (argValue !== undefined) {
              var _validateValue = validateValue(config, leftField, argDef, operator, argValue, argConfig.type, argValueSrc, asyncListValues, canFix, isEndValue, canDropArgs),
                _validateValue2 = _slicedToArray$1(_validateValue, 2),
                fixedArgVal = _validateValue2[0],
                argErrors = _validateValue2[1];
              var isValid = !(argErrors !== null && argErrors !== void 0 && argErrors.length);
              var willFix = canFix && fixedArgVal !== argValue;
              //const willFixAllErrors = !isValid && willFix && !allErrors?.find(e => !e.fixed);
              //tip: reset to default ONLY if isEndValue==true
              var canDropOrReset = canFix && !isValid && !willFix && (isEndValue || canDropArgs);
              if (willFix) {
                fixedValue = fixedValue.setIn(["args", argKey, "value"], fixedArgVal);
              }
              if (canDropOrReset) {
                // reset to default
                fixedValue = fixedValue.deleteIn(["args", argKey]);
                fixedValue = setFuncDefaultArg(config, fixedValue, funcConfig, argKey);
              }
              if (!isValid) {
                var _ref4, _argErrors$find;
                var firstError = (_ref4 = (_argErrors$find = argErrors.find(function (e) {
                  return !e.fixed && !e.ignore;
                })) !== null && _argErrors$find !== void 0 ? _argErrors$find : argErrors.find(function (e) {
                  return !e.fixed;
                })) !== null && _ref4 !== void 0 ? _ref4 : argErrors[0];
                var fixed = willFix || canDropOrReset;
                var ignore = argErrors.filter(function (e) {
                  return !e.ignore;
                }).length === 0;
                if (firstError) {
                  var argValidationError = translateValidation(firstError);
                  allErrors.push({
                    key: INVALID_FUNC_ARG_VALUE,
                    args: {
                      funcKey: funcKey,
                      funcName: funcName,
                      argKey: argKey,
                      argName: argName,
                      argValidationError: argValidationError,
                      // more meta
                      argErrors: argErrors
                    },
                    ignore: ignore,
                    fixed: fixed,
                    fixedFrom: fixed ? argValue : undefined,
                    fixedTo: fixed ? willFix ? fixedArgVal : argConfig.defaultValue : undefined
                  });
                }
              }
            } else if (!argConfig.isOptional && (isEndValue || canDropArgs)) {
              var canReset = canFix && argConfig.defaultValue !== undefined && (isEndValue || canDropArgs);
              var canAddError = isEndValue;
              //tip: Exception for canDropArgs (true only if changing func) - don't show error about required args
              if (canAddError) {
                allErrors.push({
                  key: REQUIRED_FUNCTION_ARG,
                  args: {
                    funcKey: funcKey,
                    funcName: funcName,
                    argKey: argKey,
                    argName: argName
                  },
                  fixed: canReset,
                  fixedTo: canReset ? argConfig.defaultValue : undefined,
                  ignore: !canReset // tip: don't show error message in UI about missing arg after validation API call
                });
              }
              if (canReset) {
                // set default
                fixedValue = fixedValue.deleteIn(["args", argKey]);
                fixedValue = setFuncDefaultArg(config, fixedValue, funcConfig, argKey);
              }
            }
          }
          return [fixedValue, allErrors];
        };

        /**
         * 
         */
        var validateRange = function validateRange(config, field, operator, values, valueSrcs) {
          var operatorConfig = getOperatorConfig$4(config, operator, field);
          var operatorCardinality = operator ? getOpCardinality$1(operatorConfig) : null;
          var valueSrcsArr = valueSrcs.toJS ? valueSrcs.toJS() : valueSrcs;
          var valuesArr = values.toJS ? values.toJS() : values;
          var areValueSrcsPureValues = valueSrcsArr.filter(function (vs) {
            return vs == "value" || vs == null;
          }).length == operatorCardinality;
          var rangeError;
          if (operatorConfig !== null && operatorConfig !== void 0 && operatorConfig.validateValues && areValueSrcsPureValues) {
            var valueSrc = valueSrcsArr[0];
            var w = getWidgetForFieldOp$3(config, field, operator, valueSrc);
            var fieldWidgetDefinition = getFieldWidgetConfig$3(config, field, operator, w, valueSrc);
            var jsValues = fieldWidgetDefinition !== null && fieldWidgetDefinition !== void 0 && fieldWidgetDefinition.toJS ? valuesArr.map(function (v) {
              var jsVal = fieldWidgetDefinition.toJS.call(config.ctx, v, fieldWidgetDefinition);
              if (jsVal instanceof Date) {
                jsVal = jsVal.getTime();
              }
              return jsVal;
            }) : valuesArr;
            var validResult = operatorConfig.validateValues(jsValues);
            if (typeof validResult === "boolean") {
              if (validResult == false) {
                rangeError = {
                  key: INVALID_RANGE,
                  args: {
                    jsValues: jsValues,
                    values: valuesArr
                  }
                };
              }
            }
          }
          return rangeError;
        };

        /**
         * @param {Immutable.Map} current
         * @param {string} changedProp
         * @param {boolean} canFix (default: false) true - eg. set value to max if it > max or revert or drop
         * @param {boolean} isEndValue (default: false) true - if value is in process of editing by user
         * @param {boolean} canDropArgs (default: false)
         * @return {{canReuseValue, newValue, newValueSrc, newValueType, fixedField, operatorCardinality,  newValueError, newFieldError, validationErrors}}
         */
        var getNewValueForFieldOp = function getNewValueForFieldOp(config) {
          var _currentField, _currentField$get, _newField, _newField$get;
          var oldConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var current = arguments.length > 2 ? arguments[2] : undefined;
          var newField = arguments.length > 3 ? arguments[3] : undefined;
          var newOperator = arguments.length > 4 ? arguments[4] : undefined;
          var changedProp = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          var canFix = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
          var isEndValue = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
          var canDropArgs = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
          //const isValidatingTree = (changedProp === null);
          if (!oldConfig) oldConfig = config;
          var _config$settings2 = config.settings,
            keepInputOnChangeFieldSrc = _config$settings2.keepInputOnChangeFieldSrc,
            convertableWidgets = _config$settings2.convertableWidgets,
            clearValueOnChangeField = _config$settings2.clearValueOnChangeField,
            clearValueOnChangeOp = _config$settings2.clearValueOnChangeOp;
          var isCase = newField == "!case_value";
          var currentField = current.get("field");
          if (!currentField && isCase) {
            currentField = newField;
          }
          var currentFieldType = current.get("fieldType");
          var currentFieldSrc = current.get("fieldSrc");
          var currentOperator = current.get("operator");
          var currentValue = current.get("value");
          var currentValueSrc = current.get("valueSrc", new Immutable.List());
          var currentValueType = current.get("valueType", new Immutable.List());
          var currentValueError = current.get("valueError", new Immutable.List());
          var asyncListValues = current.get("asyncListValues");
          var isOkWithoutOperator = isCase;
          var currentOperatorConfig = getOperatorConfig$4(oldConfig, currentOperator);
          var newOperatorConfig = getOperatorConfig$4(config, newOperator, newField);
          var currentOperatorCardinality = isCase ? 1 : currentOperator ? getOpCardinality$1(currentOperatorConfig) : null;
          var operatorCardinality = isCase ? 1 : newOperator ? getOpCardinality$1(newOperatorConfig) : null;
          var currentFieldConfig = getFieldConfig$8(oldConfig, currentField);
          var newFieldConfig = getFieldConfig$8(config, newField);
          var isOkWithoutField = !currentField && currentFieldType && keepInputOnChangeFieldSrc;
          var currentType = (currentFieldConfig === null || currentFieldConfig === void 0 ? void 0 : currentFieldConfig.type) || currentFieldType;
          var newType = (newFieldConfig === null || newFieldConfig === void 0 ? void 0 : newFieldConfig.type) || !newField && isOkWithoutField && currentType;
          var currentListValuesType = currentFieldConfig === null || currentFieldConfig === void 0 ? void 0 : currentFieldConfig.listValuesType;
          var newListValuesType = newFieldConfig === null || newFieldConfig === void 0 ? void 0 : newFieldConfig.listValuesType;
          var currentFieldSimpleValue = ((_currentField = currentField) === null || _currentField === void 0 || (_currentField$get = _currentField.get) === null || _currentField$get === void 0 ? void 0 : _currentField$get.call(_currentField, "func")) || currentField;
          var newFieldSimpleValue = ((_newField = newField) === null || _newField === void 0 || (_newField$get = _newField.get) === null || _newField$get === void 0 ? void 0 : _newField$get.call(_newField, "func")) || newField;
          var hasFieldChanged = newFieldSimpleValue != currentFieldSimpleValue;
          var validationErrors = [];
          var canReuseValue = (currentField || isOkWithoutField) && (currentOperator && newOperator || isOkWithoutOperator) && currentValue != undefined;
          if (!(currentType && newType && currentType == newType) || changedProp === "field" && hasFieldChanged && clearValueOnChangeField || changedProp === "operator" && clearValueOnChangeOp) {
            canReuseValue = false;
          }
          if (hasFieldChanged && selectTypes.includes(newType)) {
            if (newListValuesType && newListValuesType === currentListValuesType) ;else {
              // different fields of select types has different listValues
              canReuseValue = false;
            }
          }
          if (!isOkWithoutOperator && (!(currentValue !== null && currentValue !== void 0 && currentValue.size) && operatorCardinality || currentValue !== null && currentValue !== void 0 && currentValue.size && !operatorCardinality)) {
            canReuseValue = false;
          }

          // validate func LHS
          var newFieldError;
          if (currentFieldSrc === "func" && newField) {
            var _validateValue3 = validateValue(config, null, null, newOperator, newField, newType, currentFieldSrc, asyncListValues, canFix, isEndValue, canDropArgs),
              _validateValue4 = _slicedToArray$1(_validateValue3, 2),
              fixedField = _validateValue4[0],
              fieldErrors = _validateValue4[1];
            var isValid = !(fieldErrors !== null && fieldErrors !== void 0 && fieldErrors.length);
            var willFix = fixedField !== newField;
            var willFixAllErrors = !isValid && willFix && !fieldErrors.find(function (e) {
              return !e.fixed;
            });
            var willRevert = canFix && !isValid && !willFixAllErrors && !!changedProp && newField !== currentField;
            var willDrop = false; //canFix && !isValid && !willFixAllErrors && !willRevert && !changedProp;
            if (willDrop) {
              newField = null;
            } else if (willRevert) {
              newField = currentField;
            } else if (willFix) {
              newField = fixedField;
            }
            if (!isValid) {
              var showError = !isValid && !willFixAllErrors && !willDrop && !willRevert;
              var firstError = fieldErrors.find(function (e) {
                return !e.fixed && !e.ignore;
              });
              if (showError && firstError) {
                newFieldError = translateValidation(firstError);
              }
              // tip: even if we don't show errors, but revert LHS, put the reason of revert
              fieldErrors.map(function (e) {
                return validationErrors.push(_objectSpread$w(_objectSpread$w({
                  side: "lhs"
                }, e), {}, {
                  fixed: e.fixed || willRevert || willDrop
                }));
              });
            }
          }

          // compare old & new widgets
          for (var i = 0; i < operatorCardinality; i++) {
            var vs = currentValueSrc.get(i) || null;
            var currentWidget = getWidgetForFieldOp$3(oldConfig, currentField, currentOperator, vs);
            var newWidget = getWidgetForFieldOp$3(config, newField, newOperator, vs);
            // need to also check value widgets if we changed operator and current value source was 'field'
            // cause for select type op '=' requires single value and op 'in' requires array value
            var currentValueWidget = vs === "value" ? currentWidget : getWidgetForFieldOp$3(oldConfig, currentField, currentOperator, "value");
            var newValueWidget = vs === "value" ? newWidget : getWidgetForFieldOp$3(config, newField, newOperator, "value");
            var canReuseWidget = newValueWidget == currentValueWidget || (convertableWidgets[currentValueWidget] || []).includes(newValueWidget) || !currentValueWidget && isOkWithoutField;
            if (!canReuseWidget) {
              canReuseValue = false;
            }
          }
          if (currentOperator != newOperator && [currentOperator, newOperator].includes("proximity")) {
            canReuseValue = false;
          }
          var firstValueSrc = currentValueSrc.first();
          var firstWidgetConfig = getFieldWidgetConfig$3(config, newField, newOperator, null, firstValueSrc);
          var valueSources = getValueSourcesForFieldOp$1(config, newField, newOperator, null);
          if (!newField && isOkWithoutField) {
            valueSources = Object.keys(config.settings.valueSourcesInfo);
          }
          var defaultValueSrc = valueSources[0];
          var defaultValueType;
          if (operatorCardinality === 1 && firstWidgetConfig && firstWidgetConfig.type !== undefined) {
            defaultValueType = firstWidgetConfig.type;
          } else if (operatorCardinality === 1 && newFieldConfig && newFieldConfig.type !== undefined) {
            defaultValueType = newFieldConfig.type === "!group" ? "number" : newFieldConfig.type;
          }

          // changed operator from '==' to 'between'
          var canExtendValueToRange = canReuseValue && changedProp === "operator" && currentOperatorCardinality === 1 && operatorCardinality === 2;
          var valueFixes = [];
          var valueSrcFixes = [];
          var valueTypeFixes = [];
          var valueErrors = Array.from({
            length: operatorCardinality
          }, function () {
            return null;
          });
          if (canReuseValue) {
            var _loop = function _loop(_i3) {
              var v = currentValue.get(_i3);
              var vType = currentValueType.get(_i3) || null;
              var vSrc = currentValueSrc.get(_i3) || null;
              if (canExtendValueToRange && _i3 === 1) {
                v = valueFixes[0] !== undefined ? valueFixes[0] : currentValue.get(0);
                valueFixes[_i3] = v;
                vType = currentValueType.get(0) || null;
                vSrc = currentValueSrc.get(0) || null;
              }
              var isValidSrc = vSrc ? valueSources.find(function (v) {
                return v == vSrc;
              }) !== undefined : true;
              var _validateValue5 = validateValue(config, newField, newField, newOperator, v, vType, vSrc, asyncListValues, canFix, isEndValue, canDropArgs),
                _validateValue6 = _slicedToArray$1(_validateValue5, 2),
                fixedValue = _validateValue6[0],
                allErrors = _validateValue6[1];
              var isValid = !(allErrors !== null && allErrors !== void 0 && allErrors.length);
              // Allow bad value with error message
              // But not on field change - in that case just drop bad value that can't be reused
              // ? Maybe we should also drop bad value on op change?
              // For bad multiselect value we have both error message + fixed value.
              //  If we show error message, it will gone on next tree validation
              var willFix = fixedValue !== v;
              var willFixAllErrors = !isValid && willFix && !(allErrors !== null && allErrors !== void 0 && allErrors.find(function (e) {
                return !e.fixed;
              }));
              var allErrorsHandled = !(allErrors !== null && allErrors !== void 0 && allErrors.find(function (e) {
                return !e.fixed && !e.ignore;
              }));

              // tip: is value src is invalid, drop ANYWAY
              // tip: Edge case in demo:
              //      Given "login = LOWER(?)", change config to not show errors -> "LOWER(?)" will be dropped
              //      We don't want to drop func completely, so need to add `allErrorsAheHandled` or `vSrc !== "func"`
              // todo: `hasFieldChanged` is not needed ?
              var willDrop = !isValidSrc || canFix && !isValid && !willFixAllErrors && (!allErrorsHandled || hasFieldChanged);
              if (!isValid) {
                // tip: even if we don't show errors, but drop bad values, put the reason of removal
                allErrors === null || allErrors === void 0 || allErrors.map(function (e) {
                  return validationErrors.push(_objectSpread$w(_objectSpread$w({
                    side: "rhs",
                    delta: _i3
                  }, e), {}, {
                    fixed: e.fixed || willDrop
                  }));
                });
              }
              if (willDrop) {
                valueFixes[_i3] = null;
                if (_i3 === 0) {
                  delete valueFixes[1];
                }
              }
              var showError = !isValid && !willFix;
              var firstError = allErrors === null || allErrors === void 0 ? void 0 : allErrors.find(function (e) {
                return !e.fixed && !e.ignore;
              });
              if (showError && firstError) {
                valueErrors[_i3] = translateValidation(firstError);
              }
              if (willFix) {
                valueFixes[_i3] = fixedValue;
              }
              if (canExtendValueToRange && _i3 === 0 && !isValid && !willFix) {
                // don't extend bad value to range
                canExtendValueToRange = false;
              }
              if (canExtendValueToRange && _i3 === 0 && ["func", "field"].includes(vSrc)) {
                // don't extend func/field value, only primitive value
                canExtendValueToRange = false;
              }
            };
            for (var _i3 = 0; _i3 < operatorCardinality; _i3++) {
              _loop(_i3);
            }
          }

          // if can't reuse, get defaultValue
          if (!canReuseValue) {
            for (var _i4 = 0; _i4 < operatorCardinality; _i4++) {
              if (operatorCardinality === 1) {
                var _newFieldConfig$field;
                // tip: default range values (for cardinality > 1) are not supported yet, todo
                var dv = getFirstDefined([newFieldConfig === null || newFieldConfig === void 0 ? void 0 : newFieldConfig.defaultValue, newFieldConfig === null || newFieldConfig === void 0 || (_newFieldConfig$field = newFieldConfig.fieldSettings) === null || _newFieldConfig$field === void 0 ? void 0 : _newFieldConfig$field.defaultValue, firstWidgetConfig === null || firstWidgetConfig === void 0 ? void 0 : firstWidgetConfig.defaultValue]);
                valueFixes[_i4] = dv;
                if (dv !== null && dv !== void 0 && dv.func) {
                  valueSrcFixes[_i4] = "func";
                  //tip: defaultValue of src "field" is not supported, todo
                }
              }
            }
          }

          // set default valueSrc and valueType
          for (var _i5 = 0; _i5 < operatorCardinality; _i5++) {
            var _vs = canReuseValue && currentValueSrc.get(_i5) || null;
            var vt = canReuseValue && currentValueType.get(_i5) || null;
            if (canReuseValue && canExtendValueToRange && _i5 === 1) {
              var _valueSrcFixes$_i, _valueTypeFixes$_i;
              _vs = (_valueSrcFixes$_i = valueSrcFixes[_i5]) !== null && _valueSrcFixes$_i !== void 0 ? _valueSrcFixes$_i : currentValueSrc.get(0);
              vt = (_valueTypeFixes$_i = valueTypeFixes[_i5]) !== null && _valueTypeFixes$_i !== void 0 ? _valueTypeFixes$_i : currentValueType.get(0);
              valueSrcFixes[_i5] = _vs;
              valueTypeFixes[_i5] = vt;
            }
            var isValidSrc = valueSources.includes(_vs);
            if (!isValidSrc) {
              valueSrcFixes[_i5] = defaultValueSrc;
            }
            if (!vt) {
              valueTypeFixes[_i5] = defaultValueType;
            }
          }

          // build new values
          var newValue = currentValue;
          if (valueFixes.length > 0 || !canReuseValue) {
            newValue = new Immutable.List(Array.from({
              length: operatorCardinality
            }, function (_ignore, i) {
              return valueFixes[i] !== undefined ? valueFixes[i] : canReuseValue ? currentValue.get(i) : undefined;
            }));
          }
          var newValueSrc = currentValueSrc;
          if (valueSrcFixes.length > 0 || !canReuseValue) {
            newValueSrc = new Immutable.List(Array.from({
              length: operatorCardinality
            }, function (_ignore, i) {
              var _valueSrcFixes$i;
              return (_valueSrcFixes$i = valueSrcFixes[i]) !== null && _valueSrcFixes$i !== void 0 ? _valueSrcFixes$i : canReuseValue && currentValueSrc.get(i) || null;
            }));
          }
          var newValueType = currentValueType;
          if (valueTypeFixes.length > 0 || !canReuseValue) {
            newValueType = new Immutable.List(Array.from({
              length: operatorCardinality
            }, function (_ignore, i) {
              var _valueTypeFixes$i;
              return (_valueTypeFixes$i = valueTypeFixes[i]) !== null && _valueTypeFixes$i !== void 0 ? _valueTypeFixes$i : canReuseValue && currentValueType.get(i) || null;
            }));
          }

          // Validate range
          var rangeErrorObj = validateRange(config, newField, newOperator, newValue, newValueSrc);
          if (rangeErrorObj) {
            // last element in `valueError` list is for range validation error
            var rangeValidationError = translateValidation(rangeErrorObj);
            var _willFix = canFix && operatorCardinality >= 2;
            var badValue = newValue;
            if (_willFix) {
              valueFixes[1] = newValue.get(0);
              newValue = newValue.set(1, valueFixes[1]);
              valueErrors[1] = valueErrors[0];
            }
            var _showError = !_willFix;
            if (_showError) {
              valueErrors.push(rangeValidationError);
            }
            validationErrors.push(_objectSpread$w(_objectSpread$w({
              side: "rhs",
              delta: -1
            }, rangeErrorObj), {}, {
              fixed: _willFix,
              fixedFrom: _willFix ? [badValue.get(0), badValue.get(1)] : undefined,
              fixedTo: _willFix ? [newValue.get(0), newValue.get(1)] : undefined
            }));
          }
          var newValueError = currentValueError;
          var hasValueErrorChanged = (currentValueError === null || currentValueError === void 0 ? void 0 : currentValueError.size) !== valueErrors.length || valueErrors.filter(function (v, i) {
            return v != currentValueError.get(i);
          }).length > 0;
          if (hasValueErrorChanged) {
            newValueError = new Immutable.List(valueErrors);
          }
          return {
            canReuseValue: canReuseValue,
            newValue: newValue,
            newValueSrc: newValueSrc,
            newValueType: newValueType,
            operatorCardinality: operatorCardinality,
            fixedField: newField,
            newValueError: newValueError,
            newFieldError: newFieldError,
            validationErrors: validationErrors
          };
        };
        const validation = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          _validateTree,
          checkTree,
          getNewValueForFieldOp,
          getTreeBadFields,
          isValidTree,
          sanitizeTree,
          translateValidation,
          validateAndFixTree: validateAndFixTree$1,
          validateRange,
          validateTree,
          validateValue
        }, Symbol.toStringTag, {
          value: 'Module'
        }));

        // helpers
        var isObject$9 = function isObject(v) {
          return _typeof$3(v) == "object" && v !== null && !Array.isArray(v);
        };

        /**
         * @param {Immutable.Map} value
         * @param {object} config
         * @return {Immutable.Map | undefined} - undefined if func value is not complete (missing required arg vals); can return completed value != value
         */
        var completeFuncValue = function completeFuncValue(value, config) {
          if (!value) return undefined;
          var funcKey = value.get("func");
          var funcConfig = funcKey && getFuncConfig$2(config, funcKey);
          if (!funcConfig) return undefined;
          var complValue = value;
          var tmpHasOptional = false;
          for (var argKey in funcConfig.args) {
            var argConfig = funcConfig.args[argKey];
            var valueSources = argConfig.valueSources,
              isOptional = argConfig.isOptional,
              defaultValue = argConfig.defaultValue;
            var filteredValueSources = filterValueSourcesForField(config, valueSources, argConfig);
            var args = complValue.get("args");
            var argDefaultValueSrc = filteredValueSources.length == 1 ? filteredValueSources[0] : undefined;
            var argVal = args ? args.get(argKey) : undefined;
            var argValue = argVal ? argVal.get("value") : undefined;
            var argValueSrc = (argVal ? argVal.get("valueSrc") : undefined) || argDefaultValueSrc;
            if (argValue !== undefined) {
              var completeArgValue = completeValue(argValue, argValueSrc, config);
              if (completeArgValue === undefined) {
                return undefined;
              } else if (completeArgValue !== argValue) {
                complValue = complValue.setIn(["args", argKey, "value"], completeArgValue);
              }
              if (tmpHasOptional) {
                // has gap
                return undefined;
              }
            } else if (defaultValue !== undefined && !isObject$9(defaultValue)) {
              complValue = complValue.setIn(["args", argKey, "value"], getDefaultArgValue(argConfig));
              complValue = complValue.setIn(["args", argKey, "valueSrc"], "value");
            } else if (isOptional) {
              // optional
              tmpHasOptional = true;
            } else {
              // missing value
              return undefined;
            }
          }
          return complValue;
        };

        /**
         * @param {Immutable.Map} value 
         * @return {array} - [usedFields, badFields]
         */
        // const getUsedFieldsInFuncValue = (value, config) => {
        //   let usedFields = [];
        //   let badFields = [];

        //   const _traverse = (value) => {
        //     const args = value && value.get("args");
        //     if (!args) return;
        //     for (const arg of args.values()) {
        //       if (arg.get("valueSrc") == "field") {
        //         const rightField = arg.get("value");
        //         if (rightField) {
        //           const rightFieldDefinition = config ? getFieldConfig(config, rightField) : undefined;
        //           if (config && !rightFieldDefinition)
        //             badFields.push(rightField);
        //           else
        //             usedFields.push(rightField);
        //         }
        //       } else if (arg.get("valueSrc") == "func") {
        //         _traverse(arg.get("value"));
        //       }
        //     }
        //   };

        //   _traverse(value);

        //   return [usedFields, badFields];
        // };

        /**
         * Used @ FuncWidget
         * @param {Immutable.Map} value 
         * @param {string} funcKey 
         * @param {object} config 
         * @param {boolean} canFixArgs
         */
        var setFunc = function setFunc(value, funcKey, config, canFixArgs) {
          var fieldSeparator = config.settings.fieldSeparator;
          value = value || new Immutable.Map();
          if (Array.isArray(funcKey)) {
            // fix for cascader
            funcKey = funcKey.join(fieldSeparator);
          }
          var oldFuncKey = value.get("func");
          var oldArgs = value.get("args");
          value = value.set("func", funcKey);
          var funcConfig = funcKey && getFuncConfig$2(config, funcKey);
          var newFuncSignature = funcKey && getFuncSignature(config, funcKey);
          var oldFuncSignature = oldFuncKey && getFuncSignature(config, oldFuncKey);
          var keepArgsKeys = getCompatibleArgsOnFuncChange(oldFuncSignature, newFuncSignature, oldArgs, config, canFixArgs);
          if (keepArgsKeys.length) {
            var argsKeys = Object.keys(newFuncSignature.args);
            var deleteArgsKeys = argsKeys.filter(function (k) {
              return !keepArgsKeys.includes(k);
            });
            value = deleteArgsKeys.reduce(function (value, k) {
              return value.deleteIn(["args", k]);
            }, value);
          } else {
            value = value.set("args", new Immutable.Map());
          }

          // defaults
          value = setFuncDefaultArgs(config, value, funcConfig);
          return value;
        };
        var setFuncDefaultArgs = function setFuncDefaultArgs(config, funcValue, funcConfig) {
          if (funcConfig) {
            for (var argKey in funcConfig.args) {
              funcValue = setFuncDefaultArg(config, funcValue, funcConfig, argKey);
            }
          }
          return funcValue;
        };
        var setFuncDefaultArg = function setFuncDefaultArg(config, funcValue, funcConfig, argKey) {
          var argConfig = funcConfig.args[argKey];
          var valueSources = argConfig.valueSources,
            defaultValue = argConfig.defaultValue;
          var filteredValueSources = filterValueSourcesForField(config, valueSources, argConfig);
          var firstValueSrc = filteredValueSources.length ? filteredValueSources[0] : undefined;
          var defaultValueSrc = defaultValue ? isObject$9(defaultValue) && !!defaultValue.func ? "func" : "value" : undefined;
          var argDefaultValueSrc = defaultValueSrc || firstValueSrc;
          var hasValue = funcValue.getIn(["args", argKey]);
          if (!hasValue) {
            if (defaultValue !== undefined) {
              funcValue = funcValue.setIn(["args", argKey, "value"], getDefaultArgValue(argConfig));
            }
            if (argDefaultValueSrc) {
              funcValue = funcValue.setIn(["args", argKey, "valueSrc"], argDefaultValueSrc);
            }
          }
          return funcValue;
        };
        var getDefaultArgValue = function getDefaultArgValue(_ref) {
          var value = _ref.defaultValue;
          if (isObject$9(value) && !Immutable.Map.isMap(value) && value.func) {
            return Immutable.fromJS(value, function (k, v) {
              return Immutable.Iterable.isIndexed(v) ? v.toList() : v.toOrderedMap();
            });
          }
          return value;
        };

        /**
        * Used @ FuncWidget
        * @param {Immutable.Map} value 
        * @param {string} argKey 
        * @param {*} argVal 
        * @param {object} argConfig 
        */
        var setArgValue = function setArgValue(value, argKey, argVal, argConfig, config) {
          if (value && value.get("func")) {
            value = value.setIn(["args", argKey, "value"], argVal);

            // set default arg value source
            var valueSrc = value.getIn(["args", argKey, "valueSrc"]);
            var valueSources = argConfig.valueSources;
            var filteredValueSources = filterValueSourcesForField(config, valueSources, argConfig);
            var argDefaultValueSrc = filteredValueSources.length == 1 ? filteredValueSources[0] : undefined;
            if (!argDefaultValueSrc && filteredValueSources.includes("value")) {
              argDefaultValueSrc = "value";
            }
            if (!valueSrc && argDefaultValueSrc) {
              value = value.setIn(["args", argKey, "valueSrc"], argDefaultValueSrc);
            }
          }
          return value;
        };

        /**
        * Used @ FuncWidget
        * @param {Immutable.Map} value 
        * @param {string} argKey 
        * @param {string} argValSrc 
        * @param {object} argConfig 
        */
        var setArgValueSrc = function setArgValueSrc(value, argKey, argValSrc, _argConfig, _config) {
          if (value && value.get("func")) {
            value = value.setIn(["args", argKey], new Immutable.Map({
              valueSrc: argValSrc
            }));
          }
          return value;
        };

        // see getFuncSignature in configUtils
        var getCompatibleArgsOnFuncChange = function getCompatibleArgsOnFuncChange(s1, s2, argVals, config) {
          var canFixArgs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          if ((s1 === null || s1 === void 0 ? void 0 : s1.returnType) != (s2 === null || s2 === void 0 ? void 0 : s2.returnType)) return [];
          var keys = Object.keys(s2.args);
          var compatibleKeys = keys.filter(function (k, i) {
            var arg2 = s2.args[k];
            var arg1 = s1.args[k];
            Object.keys(s1.args).indexOf(k);
            if (!arg1 && (arg2.defaultValue !== undefined || arg2.isOptional)) {
              return true;
            }
            if ((arg1 === null || arg1 === void 0 ? void 0 : arg1.type) != arg2.type) return false;
            if (selectTypes.includes(arg2.type)) {
              if (!arg1.listValuesType || arg1.listValuesType !== arg2.listValuesType) return false;
            }
            if (argVals) {
              var _argValidErrors$filte;
              var argVal = argVals.get(k);
              var argValue = argVal === null || argVal === void 0 ? void 0 : argVal.get("value");
              var argValueSrc = argVal === null || argVal === void 0 ? void 0 : argVal.get("valueSrc");
              if (argValueSrc && arg2.valueSources && !arg2.valueSources.includes(argValueSrc)) return false;
              var leftField = null,
                operator = null,
                argDef = arg2,
                asyncListValues = null,
                isEndValue = true;
              var _validateValue = validateValue(config, leftField, argDef, operator, argValue, argDef.type, argValueSrc, asyncListValues, canFixArgs, isEndValue),
                _validateValue2 = _slicedToArray$1(_validateValue, 2);
              _validateValue2[0];
              var argValidErrors = _validateValue2[1];
              if (argValidErrors !== null && argValidErrors !== void 0 && (_argValidErrors$filte = argValidErrors.filter(function (e) {
                return !e.fixed;
              })) !== null && _argValidErrors$filte !== void 0 && _argValidErrors$filte.length) return false;
            }
            return true;
          });
          return compatibleKeys;
        };
        const funcUtils = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          completeFuncValue,
          getCompatibleArgsOnFuncChange,
          setArgValue,
          setArgValueSrc,
          setFunc,
          setFuncDefaultArg
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        var selectTypes = ["select", "multiselect", "treeselect", "treemultiselect"];
        var getOperatorsForType = function getOperatorsForType(config, fieldType) {
          var _config$types$fieldTy;
          return ((_config$types$fieldTy = config.types[fieldType]) === null || _config$types$fieldTy === void 0 ? void 0 : _config$types$fieldTy.operators) || null;
        };
        var getOperatorsForField = function getOperatorsForField(config, field) {
          var fieldConfig = getFieldConfig$8(config, field);
          var fieldOps = fieldConfig ? fieldConfig.operators : [];
          return fieldOps;
        };
        var getFirstOperator = function getFirstOperator(config, field) {
          var _fieldOps$;
          var fieldOps = getOperatorsForField(config, field);
          return (_fieldOps$ = fieldOps === null || fieldOps === void 0 ? void 0 : fieldOps[0]) !== null && _fieldOps$ !== void 0 ? _fieldOps$ : null;
        };
        var calculateValueType = function calculateValueType(value, valueSrc, config) {
          var calculatedValueType = null;
          if (value) {
            if (valueSrc === "field") {
              var fieldConfig = getFieldConfig$8(config, value);
              if (fieldConfig) {
                calculatedValueType = fieldConfig.type;
              }
            } else if (valueSrc === "func") {
              var funcKey = value.get("func");
              if (funcKey) {
                var funcConfig = getFuncConfig$2(config, funcKey);
                if (funcConfig) {
                  calculatedValueType = funcConfig.returnType || funcConfig.type;
                }
              }
            }
          }
          return calculatedValueType;
        };
        var getFuncPathLabels$1 = function getFuncPathLabels(field, config) {
          var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          return getFieldPathLabels$2(field, config, parentField, "funcs", "subfields");
        };
        var getFieldPathLabels$2 = function getFieldPathLabels(field, config) {
          var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var fieldsKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "fields";
          var subfieldsKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "subfields";
          if (!field) return null;
          var fieldSeparator = config.settings.fieldSeparator;
          var parts = getFieldParts$3(field, config);
          var parentParts = getFieldParts$3(parentField, config);
          var res = parts.slice(parentParts.length).map(function (_curr, ind, arr) {
            return arr.slice(0, ind + 1);
          }).map(function (parts) {
            return [].concat(_toConsumableArray(parentParts), _toConsumableArray(parts)).join(fieldSeparator);
          }).map(function (part) {
            var cnf = getFieldRawConfig(config, part, fieldsKey, subfieldsKey);
            return cnf && cnf.label || last$2(part.split(fieldSeparator));
          }).filter(function (label) {
            return label != null;
          });
          return res;
        };
        var getFieldPartsConfigs = function getFieldPartsConfigs(field, config) {
          var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          if (!field) return null;
          var parentFieldDef = parentField && getFieldRawConfig(config, parentField) || null;
          var fieldSeparator = config.settings.fieldSeparator;
          var parts = getFieldParts$3(field, config);
          var isDescendant = isFieldDescendantOfField(field, parentField, config);
          var parentParts = !isDescendant ? [] : getFieldParts$3(parentField, config);
          return parts.slice(parentParts.length).map(function (_curr, ind, arr) {
            return arr.slice(0, ind + 1);
          }).map(function (parts) {
            return {
              part: [].concat(_toConsumableArray(parentParts), _toConsumableArray(parts)).join(fieldSeparator),
              key: parts[parts.length - 1]
            };
          }).map(function (_ref) {
            var part = _ref.part,
              key = _ref.key;
            var cnf = getFieldRawConfig(config, part);
            return {
              key: key,
              cnf: cnf
            };
          }).map(function (_ref2, ind, arr) {
            var key = _ref2.key,
              cnf = _ref2.cnf;
            var parentCnf = ind > 0 ? arr[ind - 1].cnf : parentFieldDef;
            return [key, cnf, parentCnf];
          });
        };
        var getValueLabel$1 = function getValueLabel(config, field, operator, delta) {
          var valueSrc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var isSpecialRange = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
          // const isFuncArg = field && typeof field == "object" && !!field.func && !!field.arg;
          // const {showLabels} = config.settings;
          // const fieldConfig = getFieldConfig(config, field);
          var fieldWidgetConfig = getFieldWidgetConfig$3(config, field, operator, null, valueSrc) || {};
          var mergedOpConfig = getOperatorConfig$4(config, operator, field) || {};
          var cardinality = isSpecialRange ? 1 : mergedOpConfig.cardinality;
          var ret = null;
          if (cardinality > 1) {
            var valueLabels = fieldWidgetConfig.valueLabels || mergedOpConfig.valueLabels;
            if (valueLabels) ret = valueLabels[delta];
            if (ret && _typeof$3(ret) !== "object") {
              ret = {
                label: ret,
                placeholder: ret
              };
            }
            if (!ret) {
              ret = {
                label: config.settings.valueLabel + " " + (delta + 1),
                placeholder: config.settings.valuePlaceholder + " " + (delta + 1)
              };
            }
          } else {
            var label = fieldWidgetConfig.valueLabel;
            var placeholder = fieldWidgetConfig.valuePlaceholder;
            // tip: this logic moved to extendFieldConfig(), see comment "label for func arg"
            // if (isFuncArg) {
            //   if (!label)
            //     label = fieldConfig.label || field.arg;
            //   if (!placeholder && !showLabels)
            //     placeholder = fieldConfig.label || field.arg;
            // }

            ret = {
              label: label || config.settings.valueLabel,
              placeholder: placeholder || config.settings.valuePlaceholder
            };
          }
          return ret;
        };
        function _getWidgetsAndSrcsForFieldOp(config, field) {
          var operator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var widgets = [];
          var valueSrcs = [];
          if (!field) return {
            widgets: widgets,
            valueSrcs: valueSrcs
          };
          var fieldCacheKey = getFieldId$1(field);
          var cacheKey = fieldCacheKey ? "".concat(fieldCacheKey, "__").concat(operator, "__").concat(valueSrc) : null;
          var cached = _getFromConfigCache(config, "_getWidgetsAndSrcsForFieldOp", cacheKey);
          if (cached) return cached;
          var isFuncArg = _typeof$3(field) === "object" && (!!field.func && !!field.arg || field._isFuncArg);
          var fieldConfig = getFieldConfig$8(config, field);
          var opConfig = operator ? config.operators[operator] : null;
          if (fieldConfig !== null && fieldConfig !== void 0 && fieldConfig.widgets) {
            var _loop = function _loop() {
              var widgetConfig = fieldConfig.widgets[widget];
              if (!config.widgets[widget]) {
                return 1; // continue
              }
              var widgetValueSrc = config.widgets[widget].valueSrc || "value";
              var canAdd = true;
              if (widget === "field") {
                canAdd = canAdd && filterValueSourcesForField(config, ["field"], fieldConfig).length > 0;
              }
              if (widget === "func") {
                canAdd = canAdd && filterValueSourcesForField(config, ["func"], fieldConfig).length > 0;
              }
              // If can't check operators, don't add
              // Func args don't have operators
              if (valueSrc === "value" && !widgetConfig.operators && !isFuncArg && field !== "!case_value") canAdd = false;
              if (widgetConfig.operators && operator) canAdd = canAdd && widgetConfig.operators.indexOf(operator) != -1;
              if (valueSrc && valueSrc != widgetValueSrc && valueSrc !== "const") canAdd = false;
              if (opConfig && opConfig.cardinality == 0 && widgetValueSrc !== "value") canAdd = false;
              if (canAdd) {
                var _fieldConfig$valueSou, _opConfig$valueSource;
                widgets.push(widget);
                var canAddValueSrc = ((_fieldConfig$valueSou = fieldConfig.valueSources) === null || _fieldConfig$valueSou === void 0 ? void 0 : _fieldConfig$valueSou.indexOf(widgetValueSrc)) != -1;
                if ((opConfig === null || opConfig === void 0 || (_opConfig$valueSource = opConfig.valueSources) === null || _opConfig$valueSource === void 0 ? void 0 : _opConfig$valueSource.indexOf(widgetValueSrc)) == -1) canAddValueSrc = false;
                if (canAddValueSrc && !valueSrcs.find(function (v) {
                  return v == widgetValueSrc;
                })) valueSrcs.push(widgetValueSrc);
              }
            };
            for (var widget in fieldConfig.widgets) {
              if (_loop()) continue;
            }
          }
          var widgetWeight = function widgetWeight(w) {
            var wg = 0;
            if (fieldConfig.preferWidgets) {
              if (fieldConfig.preferWidgets.includes(w)) wg += 10 - fieldConfig.preferWidgets.indexOf(w);
            } else if (w == fieldConfig.mainWidget) {
              wg += 100;
            }
            if (w === "field") {
              wg -= 1;
            }
            if (w === "func") {
              wg -= 2;
            }
            return wg;
          };
          widgets.sort(function (w1, w2) {
            return widgetWeight(w2) - widgetWeight(w1);
          });
          var res = {
            widgets: widgets,
            valueSrcs: valueSrcs
          };
          _saveToConfigCache(config, "_getWidgetsAndSrcsForFieldOp", cacheKey, res);
          return res;
        }
        var getWidgetsForFieldOp = function getWidgetsForFieldOp(config, field, operator) {
          var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var _getWidgetsAndSrcsFor = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),
            widgets = _getWidgetsAndSrcsFor.widgets;
          return widgets;
        };
        var filterValueSourcesForField = function filterValueSourcesForField(config, valueSrcs, fieldDefinition) {
          var _fieldDefinition$type;
          if (!fieldDefinition) return valueSrcs;
          var fieldType = (_fieldDefinition$type = fieldDefinition.type) !== null && _fieldDefinition$type !== void 0 ? _fieldDefinition$type : fieldDefinition.returnType;
          if (fieldType === "!group") {
            // todo: aggregation can be not only number?
            fieldType = "number";
          }
          // const { _isCaseValue } = fieldDefinition;
          if (!valueSrcs) valueSrcs = Object.keys(config.settings.valueSourcesInfo);
          return valueSrcs.filter(function (vs) {
            var canAdd = true;
            if (vs === "field") {
              if (config.__fieldsCntByType) {
                // tip: LHS field can be used as arg in RHS function
                var minCnt = fieldDefinition._isFuncArg ? 0 : 1;
                canAdd = canAdd && config.__fieldsCntByType[fieldType] > minCnt;
              }
            }
            if (vs === "func") {
              if (fieldDefinition.funcs) {
                canAdd = canAdd && fieldDefinition.funcs.length > 0;
              }
              if (config.__funcsCntByType) {
                canAdd = canAdd && config.__funcsCntByType[fieldType] > 0;
              }
            }
            return canAdd;
          });
        };
        var getValueSourcesForFieldOp$1 = function getValueSourcesForFieldOp(config, field, operator) {
          var fieldDefinition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var _getWidgetsAndSrcsFor2 = _getWidgetsAndSrcsForFieldOp(config, field, operator, null),
            valueSrcs = _getWidgetsAndSrcsFor2.valueSrcs;
          var filteredValueSrcs = filterValueSourcesForField(config, valueSrcs, fieldDefinition);
          return filteredValueSrcs;
        };
        var getWidgetForFieldOp$3 = function getWidgetForFieldOp(config, field, operator) {
          var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var _getWidgetsAndSrcsFor3 = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),
            widgets = _getWidgetsAndSrcsFor3.widgets;
          var widget = null;
          if (widgets.length) widget = widgets[0];
          return widget;
        };

        // can use alias (fieldName)
        // even if `parentField` is provided, `field` is still a full path
        var formatFieldName = function formatFieldName(field, config, meta) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
          if (!field) return;
          var fieldDef = getFieldConfig$8(config, field) || {};
          var fieldSeparator = config.settings.fieldSeparator;
          var fieldParts = getFieldParts$3(field, config);
          var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field;
          if (options !== null && options !== void 0 && options.useTableName && fieldDef.tableName) {
            // legacy
            var fieldPartsCopy = _toConsumableArray(fieldParts);
            fieldPartsCopy[0] = fieldDef.tableName;
            fieldName = fieldPartsCopy.join(fieldSeparator);
          }
          if (fieldDef.fieldName) {
            fieldName = fieldDef.fieldName;
          }
          if (parentField) {
            getFieldConfig$8(config, parentField) || {};
            var parentFieldName = parentField;
            if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {
              fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);
              // fieldName = "#this." + fieldName; // ? for spel
            } else {
              if (fieldDef.fieldName) ;else {
                meta.errors.push("Can't cut group ".concat(parentFieldName, " from field ").concat(fieldName));
              }
            }
          }
          return fieldName;
        };

        /**
         * Used together with keepInputOnChangeFieldSrc
         */
        var isEmptyItem = function isEmptyItem(item, config) {
          var type = item.get("type");
          var mode = item.getIn(["properties", "mode"]);
          if (type == "rule_group" && mode == "array") {
            return isEmptyRuleGroupExt(item, config);
          } else if (type == "group" || type == "rule_group") {
            return isEmptyGroup(item, config);
          } else {
            return isEmptyRule(item, config);
          }
        };
        var isEmptyRuleGroupExt = function isEmptyRuleGroupExt(item, config) {
          var children = item.get("children1");
          var properties = item.get("properties");
          return isEmptyRuleGroupExtPropertiesAndChildren$1(properties.toObject(), children, config);
        };

        /**
         * Used to remove group ext without confirmation
         * 
         * If group operator is count, children can be empty.
         * If group operator is some/none/all, there should be at least one non-empty (even incomplete) child.
         */
        var isEmptyRuleGroupExtPropertiesAndChildren$1 = function isEmptyRuleGroupExtPropertiesAndChildren(properties, children, config) {
          var _config$operators$ope, _config$operators$ope2;
          var operator = properties.operator;
          var cardinality = (_config$operators$ope = (_config$operators$ope2 = config.operators[operator]) === null || _config$operators$ope2 === void 0 ? void 0 : _config$operators$ope2.cardinality) !== null && _config$operators$ope !== void 0 ? _config$operators$ope : 1;
          var childrenAreRequired = cardinality == 0; // tip: for group operators some/none/all
          var filledParts = {
            group: !isEmptyRuleProperties$1(properties, config),
            children: !isEmptyGroupChildren$1(children, config)
          };
          var hasEnough = filledParts.group && (childrenAreRequired ? filledParts.children : true);
          return !hasEnough;
        };
        var isEmptyGroup = function isEmptyGroup(group, config) {
          var children = group.get("children1");
          return isEmptyGroupChildren$1(children, config);
        };

        /**
         * Used to remove group without confirmation
         * @returns {boolean} false if there is at least one (even incomplete) child
         */
        var isEmptyGroupChildren$1 = function isEmptyGroupChildren(children, config) {
          var hasEnough = (children === null || children === void 0 ? void 0 : children.size) > 0 && children.filter(function (ch) {
            return !isEmptyItem(ch, config);
          }).size > 0;
          return !hasEnough;
        };
        var isEmptyRule = function isEmptyRule(rule, config) {
          var properties = rule.get("properties");
          return isEmptyRuleProperties$1((properties === null || properties === void 0 ? void 0 : properties.toObject()) || {}, config);
        };

        /**
         * Used to remove rule without confirmation
         * @param properties is an Object, but properties (like value) are Immutable
         * @returns {boolean} true if there is no enough data in rule
         */
        var isEmptyRuleProperties$1 = function isEmptyRuleProperties(properties, config) {
          var liteCheck = true;
          var scoreThreshold = 3;
          var compl = whatRulePropertiesAreCompleted(properties, config, liteCheck);
          var hasEnough = compl.score >= scoreThreshold;
          return !hasEnough;
        };

        /**
         * Used to validate rule
         * @param properties is an Object, but its properties (like `value`) are Immutable
         * @param liteCheck true can be used to check that rule has enough data to ask confirmation before delete
         * @return {{parts: {field: boolean, operator: boolean, value: boolean}, score: number}}
         */
        var whatRulePropertiesAreCompleted = function whatRulePropertiesAreCompleted(_ref3, config) {
          var _config$operators$ope3, _config$operators$ope4, _value$filter;
          var field = _ref3.field,
            fieldSrc = _ref3.fieldSrc;
          _ref3.fieldType;
          var operator = _ref3.operator,
            value = _ref3.value,
            valueSrc = _ref3.valueSrc;
          _ref3.valueType;
          var liteCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var cardinality = (_config$operators$ope3 = (_config$operators$ope4 = config.operators[operator]) === null || _config$operators$ope4 === void 0 ? void 0 : _config$operators$ope4.cardinality) !== null && _config$operators$ope3 !== void 0 ? _config$operators$ope3 : 1;
          var valueSrcs = valueSrc !== null && valueSrc !== void 0 && valueSrc.get ? valueSrc.toJS() : valueSrc;

          // tip: for liteCheck==true `score` should equal 3 if both LHS and RHS are at least partially filled
          var res = {
            parts: {},
            score: 0
          };
          res.parts.field = liteCheck ? field != null : isCompletedValue(field, fieldSrc, config);
          res.parts.operator = !!operator;
          res.parts.value = (value === null || value === void 0 || (_value$filter = value.filter(function (val, delta) {
            return isCompletedValue(val, valueSrcs === null || valueSrcs === void 0 ? void 0 : valueSrcs[delta], config, liteCheck);
          })) === null || _value$filter === void 0 ? void 0 : _value$filter.size) >= (liteCheck ? Math.min(cardinality, 1) : cardinality);
          res.score = Object.keys(res.parts).filter(function (k) {
            return !!res.parts[k];
          }).length;
          if (liteCheck && res.score < 3) {
            // Boost score to confirm deletion:
            // - if RHS is empty, but LHS is a completed function
            // - if LHS is empty (only fieldType is set), but there is a completed function in RHS
            var deepCheck = true;
            if (!res.parts.value && fieldSrc === "func" && isCompletedValue(field, fieldSrc, config, false, deepCheck)) {
              res.score++;
            }
            if (!res.parts.field) {
              value === null || value === void 0 || value.map(function (val, delta) {
                if ((valueSrcs === null || valueSrcs === void 0 ? void 0 : valueSrcs[delta]) === "func" && isCompletedValue(val, valueSrcs === null || valueSrcs === void 0 ? void 0 : valueSrcs[delta], config, false, deepCheck)) {
                  res.score++;
                }
              });
            }
          }
          return res;
        };
        var isCompletedValue = function isCompletedValue(value, valueSrc, config) {
          var liteCheck = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var deepCheck = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
          if (!liteCheck && valueSrc == "func" && value) {
            var _value$get;
            var funcKey = (_value$get = value.get) === null || _value$get === void 0 ? void 0 : _value$get.call(value, "func");
            var funcConfig = getFuncConfig$2(config, funcKey);
            if (funcConfig) {
              var args = value.get("args");
              for (var argKey in funcConfig.args) {
                var argConfig = funcConfig.args[argKey];
                var argVal = args ? args.get(argKey) : undefined;
                // const argDef = getFieldConfig(config, argConfig);
                var argValue = argVal ? argVal.get("value") : undefined;
                var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
                if (argValue == undefined && (argConfig === null || argConfig === void 0 ? void 0 : argConfig.defaultValue) === undefined && !(argConfig !== null && argConfig !== void 0 && argConfig.isOptional)) {
                  // arg is not completed
                  return false;
                }
                if (argValue != undefined) {
                  if (!isCompletedValue(argValue, argValueSrc, config, deepCheck ? liteCheck : true)) {
                    // arg is complex and is not completed
                    return false;
                  }
                }
              }
              // all args are completed
              return true;
            }
          }
          return value != undefined;
        };

        /**
         * @param {*} value
         * @param {'value'|'field'|'func'} valueSrc
         * @param {object} config
         * @return {* | undefined}  undefined if func value is not complete (missing required arg vals); can return completed value != value
         */
        var completeValue = function completeValue(value, valueSrc, config) {
          if (valueSrc == "func") return completeFuncValue(value, config);else return value;
        };

        // item - Immutable
        var getOneChildOrDescendant = function getOneChildOrDescendant(item) {
          var children = item.get("children1");
          if ((children === null || children === void 0 ? void 0 : children.size) == 1) {
            var child = children.first();
            var childType = child.get("type");
            if (childType === "group") {
              return getOneChildOrDescendant(child);
            }
            return child;
          }
          return null;
        };
        const ruleUtils = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          calculateValueType,
          completeValue,
          filterValueSourcesForField,
          formatFieldName,
          getFieldPartsConfigs,
          getFieldPathLabels: getFieldPathLabels$2,
          getFirstOperator,
          getFuncPathLabels: getFuncPathLabels$1,
          getOneChildOrDescendant,
          getOperatorsForField,
          getOperatorsForType,
          getValueLabel: getValueLabel$1,
          getValueSourcesForFieldOp: getValueSourcesForFieldOp$1,
          getWidgetForFieldOp: getWidgetForFieldOp$3,
          getWidgetsForFieldOp,
          isEmptyGroupChildren: isEmptyGroupChildren$1,
          isEmptyItem,
          isEmptyRuleGroupExtPropertiesAndChildren: isEmptyRuleGroupExtPropertiesAndChildren$1,
          isEmptyRuleProperties: isEmptyRuleProperties$1,
          selectTypes,
          whatRulePropertiesAreCompleted
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        var baseAssignValue$2 = _baseAssignValue,
          eq$2 = eq_1;

        /**
         * This function is like `assignValue` except that it doesn't assign
         * `undefined` values.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignMergeValue$3(object, key, value) {
          if (value !== undefined && !eq$2(object[key], value) || value === undefined && !(key in object)) {
            baseAssignValue$2(object, key, value);
          }
        }
        var _assignMergeValue = assignMergeValue$3;

        /**
         * Creates a base function for methods like `_.forIn` and `_.forOwn`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */

        function createBaseFor$2(fromRight) {
          return function (object, iteratee, keysFunc) {
            var index = -1,
              iterable = Object(object),
              props = keysFunc(object),
              length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        var _createBaseFor = createBaseFor$2;
        var createBaseFor$1 = _createBaseFor;

        /**
         * The base implementation of `baseForOwn` which iterates over `object`
         * properties returned by `keysFunc` and invokes `iteratee` for each property.
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseFor$3 = createBaseFor$1();
        var _baseFor = baseFor$3;
        var isArrayLike$4 = isArrayLike_1,
          isObjectLike$2 = isObjectLike_1;

        /**
         * This method is like `_.isArrayLike` except that it also checks if `value`
         * is an object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array-like object,
         *  else `false`.
         * @example
         *
         * _.isArrayLikeObject([1, 2, 3]);
         * // => true
         *
         * _.isArrayLikeObject(document.body.children);
         * // => true
         *
         * _.isArrayLikeObject('abc');
         * // => false
         *
         * _.isArrayLikeObject(_.noop);
         * // => false
         */
        function isArrayLikeObject$2(value) {
          return isObjectLike$2(value) && isArrayLike$4(value);
        }
        var isArrayLikeObject_1 = isArrayLikeObject$2;

        /**
         * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */

        function safeGet$3(object, key) {
          if (key === 'constructor' && typeof object[key] === 'function') {
            return;
          }
          if (key == '__proto__') {
            return;
          }
          return object[key];
        }
        var _safeGet = safeGet$3;
        var copyObject$1 = _copyObject,
          keysIn$2 = keysIn_1;

        /**
         * Converts `value` to a plain object flattening inherited enumerable string
         * keyed properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject$2(value) {
          return copyObject$1(value, keysIn$2(value));
        }
        var toPlainObject_1 = toPlainObject$2;
        var assignMergeValue$2 = _assignMergeValue,
          cloneBuffer$1 = _cloneBufferExports,
          cloneTypedArray$1 = _cloneTypedArray,
          copyArray$1 = _copyArray,
          initCloneObject$1 = _initCloneObject,
          isArguments$1 = isArguments_1,
          isArray$4 = isArray_1,
          isArrayLikeObject$1 = isArrayLikeObject_1,
          isBuffer$1 = isBufferExports,
          isFunction$1 = isFunction_1,
          isObject$8 = isObject_1,
          isPlainObject$1 = isPlainObject_1,
          isTypedArray$1 = isTypedArray_1,
          safeGet$2 = _safeGet,
          toPlainObject$1 = toPlainObject_1;

        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMergeDeep$2(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet$2(object, key),
            srcValue = safeGet$2(source, key),
            stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue$2(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
          var isCommon = newValue === undefined;
          if (isCommon) {
            var isArr = isArray$4(srcValue),
              isBuff = !isArr && isBuffer$1(srcValue),
              isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray$4(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject$1(objValue)) {
                newValue = copyArray$1(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer$1(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray$1(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject$1(srcValue) || isArguments$1(srcValue)) {
              newValue = objValue;
              if (isArguments$1(objValue)) {
                newValue = toPlainObject$1(objValue);
              } else if (!isObject$8(objValue) || isFunction$1(objValue)) {
                newValue = initCloneObject$1(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack['delete'](srcValue);
          }
          assignMergeValue$2(object, key, newValue);
        }
        var _baseMergeDeep = baseMergeDeep$2;
        var Stack$2 = _Stack,
          assignMergeValue$1 = _assignMergeValue,
          baseFor$2 = _baseFor,
          baseMergeDeep$1 = _baseMergeDeep,
          isObject$7 = isObject_1,
          keysIn$1 = keysIn_1,
          safeGet$1 = _safeGet;

        /**
         * The base implementation of `_.merge` without support for multiple sources.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMerge$3(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor$2(source, function (srcValue, key) {
            stack || (stack = new Stack$2());
            if (isObject$7(srcValue)) {
              baseMergeDeep$1(object, source, key, srcIndex, baseMerge$3, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet$1(object, key), srcValue, key + '', object, source, stack) : undefined;
              if (newValue === undefined) {
                newValue = srcValue;
              }
              assignMergeValue$1(object, key, newValue);
            }
          }, keysIn$1);
        }
        var _baseMerge = baseMerge$3;
        var identity$3 = identity_1,
          overRest$1 = _overRest,
          setToString$1 = _setToString;

        /**
         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         */
        function baseRest$2(func, start) {
          return setToString$1(overRest$1(func, start, identity$3), func + '');
        }
        var _baseRest = baseRest$2;
        var eq$1 = eq_1,
          isArrayLike$3 = isArrayLike_1,
          isIndex$1 = _isIndex,
          isObject$6 = isObject_1;

        /**
         * Checks if the given arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
         *  else `false`.
         */
        function isIterateeCall$3(value, index, object) {
          if (!isObject$6(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number' ? isArrayLike$3(object) && isIndex$1(index, object.length) : type == 'string' && index in object) {
            return eq$1(object[index], value);
          }
          return false;
        }
        var _isIterateeCall = isIterateeCall$3;
        var baseRest$1 = _baseRest,
          isIterateeCall$2 = _isIterateeCall;

        /**
         * Creates a function like `_.assign`.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner$3(assigner) {
          return baseRest$1(function (object, sources) {
            var index = -1,
              length = sources.length,
              customizer = length > 1 ? sources[length - 1] : undefined,
              guard = length > 2 ? sources[2] : undefined;
            customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
            if (guard && isIterateeCall$2(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            object = Object(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        var _createAssigner = createAssigner$3;
        var baseMerge$2 = _baseMerge,
          createAssigner$2 = _createAssigner;

        /**
         * This method is like `_.assign` except that it recursively merges own and
         * inherited enumerable string keyed properties of source objects into the
         * destination object. Source properties that resolve to `undefined` are
         * skipped if a destination value exists. Array and plain object properties
         * are merged recursively. Other objects and value types are overridden by
         * assignment. Source objects are applied from left to right. Subsequent
         * sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {
         *   'a': [{ 'b': 2 }, { 'd': 4 }]
         * };
         *
         * var other = {
         *   'a': [{ 'c': 3 }, { 'e': 5 }]
         * };
         *
         * _.merge(object, other);
         * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
         */
        var merge$1 = createAssigner$2(function (object, source, srcIndex) {
          baseMerge$2(object, source, srcIndex);
        });
        var merge_1 = merge$1;
        const merge$2 = /*@__PURE__*/getDefaultExportFromCjs(merge_1);
        var clone$4 = {
          exports: {}
        };
        (function (module) {
          var clone = function () {
            function _instanceof(obj, type) {
              return type != null && obj instanceof type;
            }
            var nativeMap;
            try {
              nativeMap = Map;
            } catch (_) {
              // maybe a reference error because no `Map`. Give it a dummy value that no
              // value will ever be an instanceof.
              nativeMap = function nativeMap() {};
            }
            var nativeSet;
            try {
              nativeSet = Set;
            } catch (_) {
              nativeSet = function nativeSet() {};
            }
            var nativePromise;
            try {
              nativePromise = Promise;
            } catch (_) {
              nativePromise = function nativePromise() {};
            }

            /**
             * Clones (copies) an Object using deep copying.
             *
             * This function supports circular references by default, but if you are certain
             * there are no circular references in your object, you can save some CPU time
             * by calling clone(obj, false).
             *
             * Caution: if `circular` is false and `parent` contains circular references,
             * your program may enter an infinite loop and crash.
             *
             * @param `parent` - the object to be cloned
             * @param `circular` - set to true if the object to be cloned may contain
             *    circular references. (optional - true by default)
             * @param `depth` - set to a number if the object is only to be cloned to
             *    a particular depth. (optional - defaults to Infinity)
             * @param `prototype` - sets the prototype to be used when cloning an object.
             *    (optional - defaults to parent prototype).
             * @param `includeNonEnumerable` - set to true if the non-enumerable properties
             *    should be cloned as well. Non-enumerable properties on the prototype
             *    chain will be ignored. (optional - false by default)
            */
            function clone(parent, circular, depth, prototype, includeNonEnumerable) {
              if (typeof circular === 'object') {
                depth = circular.depth;
                prototype = circular.prototype;
                includeNonEnumerable = circular.includeNonEnumerable;
                circular = circular.circular;
              }
              // maintain two arrays for circular references, where corresponding parents
              // and children have the same index
              var allParents = [];
              var allChildren = [];
              var useBuffer = typeof Buffer != 'undefined';
              if (typeof circular == 'undefined') circular = true;
              if (typeof depth == 'undefined') depth = Infinity;

              // recurse this function so we don't reset allParents and allChildren
              function _clone(parent, depth) {
                // cloning null always returns null
                if (parent === null) return null;
                if (depth === 0) return parent;
                var child;
                var proto;
                if (typeof parent != 'object') {
                  return parent;
                }
                if (_instanceof(parent, nativeMap)) {
                  child = new nativeMap();
                } else if (_instanceof(parent, nativeSet)) {
                  child = new nativeSet();
                } else if (_instanceof(parent, nativePromise)) {
                  child = new nativePromise(function (resolve, reject) {
                    parent.then(function (value) {
                      resolve(_clone(value, depth - 1));
                    }, function (err) {
                      reject(_clone(err, depth - 1));
                    });
                  });
                } else if (clone.__isArray(parent)) {
                  child = [];
                } else if (clone.__isRegExp(parent)) {
                  child = new RegExp(parent.source, __getRegExpFlags(parent));
                  if (parent.lastIndex) child.lastIndex = parent.lastIndex;
                } else if (clone.__isDate(parent)) {
                  child = new Date(parent.getTime());
                } else if (useBuffer && Buffer.isBuffer(parent)) {
                  if (Buffer.allocUnsafe) {
                    // Node.js >= 4.5.0
                    child = Buffer.allocUnsafe(parent.length);
                  } else {
                    // Older Node.js versions
                    child = new Buffer(parent.length);
                  }
                  parent.copy(child);
                  return child;
                } else if (_instanceof(parent, Error)) {
                  child = Object.create(parent);
                } else {
                  if (typeof prototype == 'undefined') {
                    proto = Object.getPrototypeOf(parent);
                    child = Object.create(proto);
                  } else {
                    child = Object.create(prototype);
                    proto = prototype;
                  }
                }
                if (circular) {
                  var index = allParents.indexOf(parent);
                  if (index != -1) {
                    return allChildren[index];
                  }
                  allParents.push(parent);
                  allChildren.push(child);
                }
                if (_instanceof(parent, nativeMap)) {
                  parent.forEach(function (value, key) {
                    var keyChild = _clone(key, depth - 1);
                    var valueChild = _clone(value, depth - 1);
                    child.set(keyChild, valueChild);
                  });
                }
                if (_instanceof(parent, nativeSet)) {
                  parent.forEach(function (value) {
                    var entryChild = _clone(value, depth - 1);
                    child.add(entryChild);
                  });
                }
                for (var i in parent) {
                  var attrs;
                  if (proto) {
                    attrs = Object.getOwnPropertyDescriptor(proto, i);
                  }
                  if (attrs && attrs.set == null) {
                    continue;
                  }
                  child[i] = _clone(parent[i], depth - 1);
                }
                if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(parent);
                  for (var i = 0; i < symbols.length; i++) {
                    // Don't need to worry about cloning a symbol because it is a primitive,
                    // like a number or string.
                    var symbol = symbols[i];
                    var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
                    if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                      continue;
                    }
                    child[symbol] = _clone(parent[symbol], depth - 1);
                    if (!descriptor.enumerable) {
                      Object.defineProperty(child, symbol, {
                        enumerable: false
                      });
                    }
                  }
                }
                if (includeNonEnumerable) {
                  var allPropertyNames = Object.getOwnPropertyNames(parent);
                  for (var i = 0; i < allPropertyNames.length; i++) {
                    var propertyName = allPropertyNames[i];
                    var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
                    if (descriptor && descriptor.enumerable) {
                      continue;
                    }
                    child[propertyName] = _clone(parent[propertyName], depth - 1);
                    Object.defineProperty(child, propertyName, {
                      enumerable: false
                    });
                  }
                }
                return child;
              }
              return _clone(parent, depth);
            }

            /**
             * Simple flat clone using prototype, accepts only objects, usefull for property
             * override on FLAT configuration object (no nested props).
             *
             * USE WITH CAUTION! This may not behave as you wish if you do not know how this
             * works.
             */
            clone.clonePrototype = function clonePrototype(parent) {
              if (parent === null) return null;
              var c = function c() {};
              c.prototype = parent;
              return new c();
            };

            // private utility functions

            function __objToStr(o) {
              return Object.prototype.toString.call(o);
            }
            clone.__objToStr = __objToStr;
            function __isDate(o) {
              return typeof o === 'object' && __objToStr(o) === '[object Date]';
            }
            clone.__isDate = __isDate;
            function __isArray(o) {
              return typeof o === 'object' && __objToStr(o) === '[object Array]';
            }
            clone.__isArray = __isArray;
            function __isRegExp(o) {
              return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
            }
            clone.__isRegExp = __isRegExp;
            function __getRegExpFlags(re) {
              var flags = '';
              if (re.global) flags += 'g';
              if (re.ignoreCase) flags += 'i';
              if (re.multiline) flags += 'm';
              return flags;
            }
            clone.__getRegExpFlags = __getRegExpFlags;
            return clone;
          }();
          if (module.exports) {
            module.exports = clone;
          }
        })(clone$4);
        var cloneExports = clone$4.exports;
        const clone$3 = /*@__PURE__*/getDefaultExportFromCjs(cloneExports);
        var logic = {
          exports: {}
        };

        /* globals define,module */

        (function (module, exports) {
          (function (root, factory) {
            {
              module.exports = factory();
            }
          })(commonjsGlobal, function () {
            /* globals console:false */

            if (!Array.isArray) {
              Array.isArray = function (arg) {
                return Object.prototype.toString.call(arg) === "[object Array]";
              };
            }

            /**
             * Return an array that contains no duplicates (original not modified)
             * @param  {array} array   Original reference array
             * @return {array}         New array with no duplicates
             */
            function arrayUnique(array) {
              var a = [];
              for (var i = 0, l = array.length; i < l; i++) {
                if (a.indexOf(array[i]) === -1) {
                  a.push(array[i]);
                }
              }
              return a;
            }
            var jsonLogic = {};
            var operations = {
              "==": function _(a, b) {
                return a == b;
              },
              "===": function _(a, b) {
                return a === b;
              },
              "!=": function _(a, b) {
                return a != b;
              },
              "!==": function _(a, b) {
                return a !== b;
              },
              ">": function _(a, b) {
                return a > b;
              },
              ">=": function _(a, b) {
                return a >= b;
              },
              "<": function _(a, b, c) {
                return c === undefined ? a < b : a < b && b < c;
              },
              "<=": function _(a, b, c) {
                return c === undefined ? a <= b : a <= b && b <= c;
              },
              "!!": function _(a) {
                return jsonLogic.truthy(a);
              },
              "!": function _(a) {
                return !jsonLogic.truthy(a);
              },
              "%": function _(a, b) {
                return a % b;
              },
              "log": function log(a) {
                console.log(a);
                return a;
              },
              "in": function _in(a, b) {
                if (!b || typeof b.indexOf === "undefined") return false;
                return b.indexOf(a) !== -1;
              },
              "cat": function cat() {
                return Array.prototype.join.call(arguments, "");
              },
              "substr": function substr(source, start, end) {
                if (end < 0) {
                  // JavaScript doesn't support negative end, this emulates PHP behavior
                  var temp = String(source).substr(start);
                  return temp.substr(0, temp.length + end);
                }
                return String(source).substr(start, end);
              },
              "+": function _() {
                return Array.prototype.reduce.call(arguments, function (a, b) {
                  return parseFloat(a, 10) + parseFloat(b, 10);
                }, 0);
              },
              "*": function _() {
                return Array.prototype.reduce.call(arguments, function (a, b) {
                  return parseFloat(a, 10) * parseFloat(b, 10);
                });
              },
              "-": function _(a, b) {
                if (b === undefined) {
                  return -a;
                } else {
                  return a - b;
                }
              },
              "/": function _(a, b) {
                return a / b;
              },
              "min": function min() {
                return Math.min.apply(this, arguments);
              },
              "max": function max() {
                return Math.max.apply(this, arguments);
              },
              "merge": function merge() {
                return Array.prototype.reduce.call(arguments, function (a, b) {
                  return a.concat(b);
                }, []);
              },
              "var": function _var(a, b) {
                var not_found = b === undefined ? null : b;
                var data = this;
                if (typeof a === "undefined" || a === "" || a === null) {
                  return data;
                }
                var sub_props = String(a).split(".");
                for (var i = 0; i < sub_props.length; i++) {
                  if (data === null || data === undefined) {
                    return not_found;
                  }
                  // Descending into data
                  data = data[sub_props[i]];
                  if (data === undefined) {
                    return not_found;
                  }
                }
                return data;
              },
              "missing": function missing() {
                /*
                Missing can receive many keys as many arguments, like {"missing:[1,2]}
                Missing can also receive *one* argument that is an array of keys,
                which typically happens if it's actually acting on the output of another command
                (like 'if' or 'merge')
                */

                var missing = [];
                var keys = Array.isArray(arguments[0]) ? arguments[0] : arguments;
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  var value = jsonLogic.apply({
                    "var": key
                  }, this);
                  if (value === null || value === "") {
                    missing.push(key);
                  }
                }
                return missing;
              },
              "missing_some": function missing_some(need_count, options) {
                // missing_some takes two arguments, how many (minimum) items must be present, and an array of keys (just like 'missing') to check for presence.
                var are_missing = jsonLogic.apply({
                  "missing": options
                }, this);
                if (options.length - are_missing.length >= need_count) {
                  return [];
                } else {
                  return are_missing;
                }
              }
            };
            jsonLogic.is_logic = function (logic) {
              return typeof logic === "object" &&
              // An object
              logic !== null &&
              // but not null
              !Array.isArray(logic) &&
              // and not an array
              Object.keys(logic).length === 1 // with exactly one key
              ;
            };

            /*
            This helper will defer to the JsonLogic spec as a tie-breaker when different language interpreters define different behavior for the truthiness of primitives.  E.g., PHP considers empty arrays to be falsy, but Javascript considers them to be truthy. JsonLogic, as an ecosystem, needs one consistent answer.
             Spec and rationale here: http://jsonlogic.com/truthy
            */
            jsonLogic.truthy = function (value) {
              if (Array.isArray(value) && value.length === 0) {
                return false;
              }
              return !!value;
            };
            jsonLogic.get_operator = function (logic) {
              return Object.keys(logic)[0];
            };
            jsonLogic.get_values = function (logic) {
              return logic[jsonLogic.get_operator(logic)];
            };
            jsonLogic.apply = function (logic, data) {
              // Does this array contain logic? Only one way to find out.
              if (Array.isArray(logic)) {
                return logic.map(function (l) {
                  return jsonLogic.apply(l, data);
                });
              }
              // You've recursed to a primitive, stop!
              if (!jsonLogic.is_logic(logic)) {
                return logic;
              }
              var op = jsonLogic.get_operator(logic);
              var values = logic[op];
              var i;
              var current;
              var scopedLogic;
              var scopedData;
              var initial;

              // easy syntax for unary operators, like {"var" : "x"} instead of strict {"var" : ["x"]}
              if (!Array.isArray(values)) {
                values = [values];
              }

              // 'if', 'and', and 'or' violate the normal rule of depth-first calculating consequents, let each manage recursion as needed.
              if (op === "if" || op == "?:") {
                /* 'if' should be called with a odd number of parameters, 3 or greater
                This works on the pattern:
                if( 0 ){ 1 }else{ 2 };
                if( 0 ){ 1 }else if( 2 ){ 3 }else{ 4 };
                if( 0 ){ 1 }else if( 2 ){ 3 }else if( 4 ){ 5 }else{ 6 };
                 The implementation is:
                For pairs of values (0,1 then 2,3 then 4,5 etc)
                If the first evaluates truthy, evaluate and return the second
                If the first evaluates falsy, jump to the next pair (e.g, 0,1 to 2,3)
                given one parameter, evaluate and return it. (it's an Else and all the If/ElseIf were false)
                given 0 parameters, return NULL (not great practice, but there was no Else)
                */
                for (i = 0; i < values.length - 1; i += 2) {
                  if (jsonLogic.truthy(jsonLogic.apply(values[i], data))) {
                    return jsonLogic.apply(values[i + 1], data);
                  }
                }
                if (values.length === i + 1) {
                  return jsonLogic.apply(values[i], data);
                }
                return null;
              } else if (op === "and") {
                // Return first falsy, or last
                for (i = 0; i < values.length; i += 1) {
                  current = jsonLogic.apply(values[i], data);
                  if (!jsonLogic.truthy(current)) {
                    return current;
                  }
                }
                return current; // Last
              } else if (op === "or") {
                // Return first truthy, or last
                for (i = 0; i < values.length; i += 1) {
                  current = jsonLogic.apply(values[i], data);
                  if (jsonLogic.truthy(current)) {
                    return current;
                  }
                }
                return current; // Last
              } else if (op === "filter") {
                scopedData = jsonLogic.apply(values[0], data);
                scopedLogic = values[1];
                if (!Array.isArray(scopedData)) {
                  return [];
                }
                // Return only the elements from the array in the first argument,
                // that return truthy when passed to the logic in the second argument.
                // For parity with JavaScript, reindex the returned array
                return scopedData.filter(function (datum) {
                  return jsonLogic.truthy(jsonLogic.apply(scopedLogic, datum));
                });
              } else if (op === "map") {
                scopedData = jsonLogic.apply(values[0], data);
                scopedLogic = values[1];
                if (!Array.isArray(scopedData)) {
                  return [];
                }
                return scopedData.map(function (datum) {
                  return jsonLogic.apply(scopedLogic, datum);
                });
              } else if (op === "reduce") {
                scopedData = jsonLogic.apply(values[0], data);
                scopedLogic = values[1];
                initial = typeof values[2] !== "undefined" ? jsonLogic.apply(values[2], data) : null;
                if (!Array.isArray(scopedData)) {
                  return initial;
                }
                return scopedData.reduce(function (accumulator, current) {
                  return jsonLogic.apply(scopedLogic, {
                    current: current,
                    accumulator: accumulator
                  });
                }, initial);
              } else if (op === "all") {
                scopedData = jsonLogic.apply(values[0], data);
                scopedLogic = values[1];
                // All of an empty set is false. Note, some and none have correct fallback after the for loop
                if (!Array.isArray(scopedData) || !scopedData.length) {
                  return false;
                }
                for (i = 0; i < scopedData.length; i += 1) {
                  if (!jsonLogic.truthy(jsonLogic.apply(scopedLogic, scopedData[i]))) {
                    return false; // First falsy, short circuit
                  }
                }
                return true; // All were truthy
              } else if (op === "none") {
                scopedData = jsonLogic.apply(values[0], data);
                scopedLogic = values[1];
                if (!Array.isArray(scopedData) || !scopedData.length) {
                  return true;
                }
                for (i = 0; i < scopedData.length; i += 1) {
                  if (jsonLogic.truthy(jsonLogic.apply(scopedLogic, scopedData[i]))) {
                    return false; // First truthy, short circuit
                  }
                }
                return true; // None were truthy
              } else if (op === "some") {
                scopedData = jsonLogic.apply(values[0], data);
                scopedLogic = values[1];
                if (!Array.isArray(scopedData) || !scopedData.length) {
                  return false;
                }
                for (i = 0; i < scopedData.length; i += 1) {
                  if (jsonLogic.truthy(jsonLogic.apply(scopedLogic, scopedData[i]))) {
                    return true; // First truthy, short circuit
                  }
                }
                return false; // None were truthy
              }

              // Everyone else gets immediate depth-first recursion
              values = values.map(function (val) {
                return jsonLogic.apply(val, data);
              });

              // The operation is called with "data" bound to its "this" and "values" passed as arguments.
              // Structured commands like % or > can name formal arguments while flexible commands (like missing or merge) can operate on the pseudo-array arguments
              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments
              if (operations.hasOwnProperty(op) && typeof operations[op] === "function") {
                return operations[op].apply(data, values);
              } else if (op.indexOf(".") > 0) {
                // Contains a dot, and not in the 0th position
                var sub_ops = String(op).split(".");
                var operation = operations;
                for (i = 0; i < sub_ops.length; i++) {
                  if (!operation.hasOwnProperty(sub_ops[i])) {
                    throw new Error("Unrecognized operation " + op + " (failed at " + sub_ops.slice(0, i + 1).join(".") + ")");
                  }
                  // Descending into operations
                  operation = operation[sub_ops[i]];
                }
                return operation.apply(data, values);
              }
              throw new Error("Unrecognized operation " + op);
            };
            jsonLogic.uses_data = function (logic) {
              var collection = [];
              if (jsonLogic.is_logic(logic)) {
                var op = jsonLogic.get_operator(logic);
                var values = logic[op];
                if (!Array.isArray(values)) {
                  values = [values];
                }
                if (op === "var") {
                  // This doesn't cover the case where the arg to var is itself a rule.
                  collection.push(values[0]);
                } else {
                  // Recursion!
                  values.forEach(function (val) {
                    collection.push.apply(collection, jsonLogic.uses_data(val));
                  });
                }
              }
              return arrayUnique(collection);
            };
            jsonLogic.add_operation = function (name, code) {
              operations[name] = code;
            };
            jsonLogic.rm_operation = function (name) {
              delete operations[name];
            };
            jsonLogic.rule_like = function (rule, pattern) {
              // console.log("Is ". JSON.stringify(rule) . " like " . JSON.stringify(pattern) . "?");
              if (pattern === rule) {
                return true;
              } // TODO : Deep object equivalency?
              if (pattern === "@") {
                return true;
              } // Wildcard!
              if (pattern === "number") {
                return typeof rule === "number";
              }
              if (pattern === "string") {
                return typeof rule === "string";
              }
              if (pattern === "array") {
                // !logic test might be superfluous in JavaScript
                return Array.isArray(rule) && !jsonLogic.is_logic(rule);
              }
              if (jsonLogic.is_logic(pattern)) {
                if (jsonLogic.is_logic(rule)) {
                  var pattern_op = jsonLogic.get_operator(pattern);
                  var rule_op = jsonLogic.get_operator(rule);
                  if (pattern_op === "@" || pattern_op === rule_op) {
                    // echo "\nOperators match, go deeper\n";
                    return jsonLogic.rule_like(jsonLogic.get_values(rule, false), jsonLogic.get_values(pattern, false));
                  }
                }
                return false; // pattern is logic, rule isn't, can't be eq
              }
              if (Array.isArray(pattern)) {
                if (Array.isArray(rule)) {
                  if (pattern.length !== rule.length) {
                    return false;
                  }
                  /*
                    Note, array order MATTERS, because we're using this array test logic to consider arguments, where order can matter. (e.g., + is commutative, but '-' or 'if' or 'var' are NOT)
                  */
                  for (var i = 0; i < pattern.length; i += 1) {
                    // If any fail, we fail
                    if (!jsonLogic.rule_like(rule[i], pattern[i])) {
                      return false;
                    }
                  }
                  return true; // If they *all* passed, we pass
                } else {
                  return false; // Pattern is array, rule isn't
                }
              }

              // Not logic, not array, not a === match for rule.
              return false;
            };
            return jsonLogic;
          });
        })(logic);
        var logicExports = logic.exports;
        const JL = /*@__PURE__*/getDefaultExportFromCjs(logicExports);
        function ownKeys$v(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$v(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$v(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$v(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function applyJsonLogic(logic, data) {
          return JL.apply(logic, data);
        }
        function addJsonLogicOperation(name, op) {
          return JL.add_operation(name, op);
        }
        var customJsonLogicOperations = {
          CALL: function CALL(fn, ctx) {
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            return fn.call.apply(fn, [ctx].concat(args));
          },
          JSX: function JSX(type, props) {
            return {
              type: type,
              props: props
            };
          },
          mergeObjects: function mergeObjects(obj1, obj2) {
            return _objectSpread$v(_objectSpread$v({}, obj1), obj2);
          },
          fromEntries: function fromEntries(entries) {
            return Object.fromEntries(entries);
          },
          strlen: function strlen(str) {
            return (str === null || str === void 0 ? void 0 : str.length) || 0;
          },
          regexTest: function regexTest(str, pattern, flags) {
            return (str === null || str === void 0 ? void 0 : str.match(new RegExp(pattern, flags))) != null;
          },
          now: function now() {
            return new Date();
          },
          date_add: function date_add(date, val, dim) {
            return hooks(date).add(val, dim).toDate();
          },
          toLowerCase: function toLowerCase(str) {
            return str.toLowerCase();
          },
          toUpperCase: function toUpperCase(str) {
            return str.toUpperCase();
          }
        };
        function addRequiredJsonLogicOperations() {
          for (var k in customJsonLogicOperations) {
            addJsonLogicOperation(k, customJsonLogicOperations[k]);
          }
        }
        function _createForOfIteratorHelper$9(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$9(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$9(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$9(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen);
        }
        function _arrayLikeToArray$9(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function ownKeys$u(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$u(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$u(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$u(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }

        // Add new operations for JsonLogic
        addRequiredJsonLogicOperations();
        function applyJsonLogicWithPath(logic, data, path) {
          var ret;
          try {
            ret = JL.apply(logic, data);
          } catch (e) {
            e.message = "".concat(path.join("."), " :: ").concat(e.message);
            throw e;
          }
          return ret;
        }
        function callContextFn(_this, fn, args, path) {
          var ret;
          try {
            ret = fn.call.apply(fn, [_this].concat(_toConsumableArray(args)));
          } catch (e) {
            e.message = "".concat(path.join("."), " :: ").concat(e.message);
            throw e;
          }
          return ret;
        }
        var configKeys = ["conjunctions", "fields", "types", "operators", "widgets", "settings", "funcs", "ctx"];

        // type: 
        //  x - iterate (with nesting `subfields`)
        //  "r" - RenderedReactElement
        //    Will be compiled with renderReactElement() into React element rendered with `React.createElement` (`ctx.RCE`)
        //  "rf" - JsonLogicFunction/string to render React
        //    JL data is { props, ctx }
        //    Should return {type, props} or string, where type or string - React component
        //    Can use { JSX: ["SomeComponent", {var: "props"}] } or just return "SomeComponent"
        //    Returned component will be searched in ctx.components/ctx.W/ctx.O, see getReactComponentFromCtx()
        //    Will be compiled with compileJsonLogicReact() into function with args (props, ctx) that will return renderReactElement()
        //  "f" - JsonLogicFunction/string
        //    JL data is { args, ctx } plus named args defined in `args` inside `compileMeta`
        //    Can use { CALL: [ {var: "ctx.someFunc"}, null, {var: "args[0]" }] } 
        //    If string is passed, it's a path to function in ctx (with dot notation)
        //    Will be compiled with compileJsonLogic() into function with any args and `this` should be `ctx`

        var compileMetaFieldSettings = {
          asyncFetch: {
            type: "f",
            args: ["search", "offset"]
          },
          labelYes: {
            type: "r"
          },
          labelNo: {
            type: "r"
          },
          marks: {
            type: "r",
            isArr: true
          },
          validateValue: {
            type: "f",
            args: ["val", "fieldSettings", "op", "opDef", "rightFieldDef"]
          }
        };
        var compileMetaWidget = _objectSpread$u(_objectSpread$u({}, compileMetaFieldSettings), {}, {
          factory: {
            type: "rf"
          },
          formatValue: {
            type: "f",
            args: ["val", "fieldDef", "wgtDef", "isForDisplay", "op", "opDef", "rightFieldDef"]
          },
          sqlFormatValue: {
            type: "f",
            args: ["val", "fieldDef", "wgtDef", "op", "opDef", "rightFieldDef"]
          },
          spelFormatValue: {
            type: "f",
            args: ["val", "fieldDef", "wgtDef", "op", "opDef", "rightFieldDef"]
          },
          spelImportValue: {
            type: "f",
            args: ["val", "wgtDef", "args"]
          },
          mongoFormatValue: {
            type: "f",
            args: ["val", "fieldDef", "wgtDef", "op", "opDef"]
          },
          elasticSearchFormatValue: {
            type: "f",
            args: ["queryType", "val", "op", "field", "config"]
          },
          jsonLogic: {
            type: "f",
            args: ["val", "fieldDef", "wgtDef", "op", "opDef"]
          },
          jsonLogicImport: {
            type: "f",
            args: ["val"]
          },
          validateValue: {
            type: "f",
            args: ["val", "fieldSettings", "op", "opDef", "rightFieldDef"]
          },
          // obsolete
          toJS: {
            type: "f",
            args: ["val"]
          }
        });
        var compileMetaOperator = {
          options: {
            // proximity
            factory: {
              type: "rf"
            }
          },
          formatOp: {
            type: "f",
            args: ["field", "op", "vals", "valueSrc", "valueType", "opDef", "operatorOptions", "isForDisplay", "fieldDef"]
          },
          mongoFormatOp: {
            type: "f",
            args: ["field", "op", "vals", "useExpr", "valueSrc", "valueType", "opDef", "operatorOptions", "fieldDef"]
          },
          sqlFormatOp: {
            type: "f",
            args: ["field", "op", "vals", "valueSrc", "valueType", "opDef", "operatorOptions", "fieldDef"]
          },
          spelFormatOp: {
            type: "f",
            args: ["field", "op", "vals", "valueSrc", "valueType", "opDef", "operatorOptions", "fieldDef"]
          },
          jsonLogic: {
            type: "f",
            ignore: "string",
            args: ["field", "op", "vals", "opDef", "operatorOptions", "fieldDef"]
          },
          elasticSearchQueryType: {
            type: "f",
            ignore: "string",
            args: ["valueType"]
          },
          textSeparators: {
            type: "r",
            isArr: true
          }
        };
        var compileMetaConjunction = {
          formatConj: {
            type: "f",
            args: ["children", "conj", "not", "isForDisplay"]
          },
          sqlFormatConj: {
            type: "f",
            args: ["children", "conj", "not"]
          },
          spelFormatConj: {
            type: "f",
            args: ["children", "conj", "not", "omitBrackets"]
          }
        };
        var compileMetaWidgetForType = {
          widgetProps: compileMetaWidget,
          opProps: compileMetaOperator
        };
        var compileMetaFunc = {
          renderBrackets: {
            type: "r",
            isArr: true
          },
          renderSeps: {
            type: "r",
            isArr: true
          },
          jsonLogic: {
            type: "f",
            ignore: "string",
            args: ["formattedArgs"]
          },
          jsonLogicImport: {
            type: "f",
            args: ["val"]
          },
          spelImport: {
            type: "f",
            args: ["spel"]
          },
          formatFunc: {
            type: "f",
            args: ["formattedArgs", "isForDisplay"]
          },
          sqlFormatFunc: {
            type: "f",
            args: ["formattedArgs"]
          },
          mongoFormatFunc: {
            type: "f",
            args: ["formattedArgs"]
          },
          spelFormatFunc: {
            type: "f",
            args: ["formattedArgs"]
          }
        };
        var compileMetaFieldLike = _objectSpread$u(_objectSpread$u({}, compileMetaFieldSettings), {}, {
          fieldSettings: compileMetaFieldSettings
        });
        var compileMetaField = _objectSpread$u(_objectSpread$u({}, compileMetaFieldSettings), {}, {
          fieldSettings: compileMetaFieldSettings,
          widgets: {
            x: compileMetaWidgetForType
          },
          mainWidgetProps: compileMetaWidget
        });
        var compileMetaSettings = {
          locale: {
            mui: {
              type: "f",
              args: [],
              invokeWith: [],
              ignore: "jl"
            }
          },
          caseValueField: compileMetaField,
          canCompareFieldWithField: {
            type: "f",
            args: ["leftField", "leftFieldConfig", "rightField", "rightFieldConfig", "op"]
          },
          formatReverse: {
            type: "f",
            args: ["q", "op", "reversedOp", "operatorDefinition", "revOperatorDefinition", "isForDisplay"]
          },
          sqlFormatReverse: {
            type: "f",
            args: ["q"]
          },
          spelFormatReverse: {
            type: "f",
            args: ["q"]
          },
          formatField: {
            type: "f",
            args: ["field", "parts", "label2", "fieldDefinition", "config", "isForDisplay"]
          },
          formatSpelField: {
            type: "f",
            args: ["field", "parentField", "parts", "partsExt", "fieldDefinition", "config"]
          },
          formatAggr: {
            type: "f",
            args: ["whereStr", "aggrField", "operator", "value", "valueSrc", "valueType", "opDef", "operatorOptions", "isForDisplay", "aggrFieldDef"]
          },
          normalizeListValues: {
            type: "f",
            args: ["listValues", "type", "fieldSettings"]
          },
          renderConfirm: {
            type: "f",
            args: ["props"]
          },
          useConfirm: {
            type: "f",
            args: []
          },
          renderField: {
            type: "rf"
          },
          renderOperator: {
            type: "rf"
          },
          renderFunc: {
            type: "rf"
          },
          renderConjs: {
            type: "rf"
          },
          renderButton: {
            type: "rf"
          },
          renderIcon: {
            type: "rf"
          },
          renderButtonGroup: {
            type: "rf"
          },
          renderValueSources: {
            type: "rf"
          },
          renderFieldSources: {
            type: "rf"
          },
          renderProvider: {
            type: "rf"
          },
          renderSwitch: {
            type: "rf"
          },
          renderSwitchPrefix: {
            type: "r"
          },
          renderItem: {
            type: "rf"
          },
          renderBeforeWidget: {
            type: "rf"
          },
          renderAfterWidget: {
            type: "rf"
          },
          renderBeforeActions: {
            type: "rf"
          },
          renderAfterActions: {
            type: "rf"
          },
          renderBeforeCaseValue: {
            type: "rf"
          },
          renderAfterCaseValue: {
            type: "rf"
          },
          renderRuleError: {
            type: "rf"
          }
        };
        var compileMeta = {
          fields: {
            x: compileMetaField
          },
          widgets: {
            x: compileMetaWidget
          },
          conjunctions: {
            x: compileMetaConjunction
          },
          operators: {
            x: compileMetaOperator
          },
          types: {
            x: {
              widgets: {
                x: compileMetaWidgetForType
              }
            }
          },
          funcs: {
            x: _objectSpread$u(_objectSpread$u(_objectSpread$u({}, compileMetaFieldLike), compileMetaFunc), {}, {
              args: {
                x: _objectSpread$u({}, compileMetaFieldLike)
              }
            })
          },
          settings: compileMetaSettings
        };
        var isObject$5 = function isObject(v) {
          return _typeof$3(v) == "object" && v !== null && !Array.isArray(v);
        };

        /////////////

        var compressConfig = function compressConfig(config, baseConfig) {
          if (config.__fieldNames) {
            throw new Error("Don't apply `compressConfig()` to extended config");
          }
          var zipConfig = pick$1(config, configKeys);
          delete zipConfig.ctx;
          var _clean = function _clean(target, base, path, meta) {
            if (isObject$5(target)) {
              if (isDirtyJSX(target)) {
                target = cleanJSX(target);
              }
              if (path[0] === "funcs" && !base) {
                var funcKey = path[path.length - 1];
                // todo: if there will be change in `BasicFuncs` when funcs can be nested, need to chnage code to find `base`
                base = getFieldRawConfig({
                  funcs: meta.BasicFuncs
                }, funcKey, "funcs", "subfields") || undefined;
                if (base) {
                  target["$$key"] = funcKey;
                }
              }
              if (base !== undefined && isObject$5(base)) {
                for (var k in base) {
                  if (Object.prototype.hasOwnProperty.call(base, k)) {
                    if (!Object.keys(target).includes(k) || target[k] === undefined && base[k] !== undefined) {
                      // deleted in target
                      target[k] = "$$deleted";
                    } else {
                      target[k] = _clean(target[k], base[k], [].concat(_toConsumableArray(path), [k]), meta);
                      if (target[k] === undefined) {
                        delete target[k];
                      }
                    }
                  }
                }
              }
              for (var _k in target) {
                if (Object.prototype.hasOwnProperty.call(target, _k)) {
                  if (!base || !Object.keys(base).includes(_k)) {
                    var _base;
                    // new in target
                    target[_k] = _clean(target[_k], (_base = base) === null || _base === void 0 ? void 0 : _base[_k], [].concat(_toConsumableArray(path), [_k]), meta);
                  }
                  if (target[_k] === undefined) {
                    delete target[_k];
                  }
                }
              }
              if (Object.keys(target).length === 0) {
                target = undefined;
              }
            } else if (Array.isArray(target)) {
              // don't deep compare arrays, but allow clean JSX inside array
              target.forEach(function (val, ind) {
                target[ind] = _clean(target[ind], undefined, [].concat(_toConsumableArray(path), [ind]), meta);
              });
            }
            if (base !== undefined && shallowEqual$4(target, base, true)) {
              return undefined;
            }
            if (typeof target === "function") {
              throw new Error("compressConfig: function at ".concat(path.join("."), " should be converted to JsonLogic"));
            }
            return target;
          };
          for (var _i = 0, _configKeys = configKeys; _i < _configKeys.length; _i++) {
            var rootKey = _configKeys[_i];
            if (rootKey === "ctx") ;else if (rootKey === "fields") {
              // just copy
              zipConfig[rootKey] = clone$3(zipConfig[rootKey]);
              _clean(zipConfig[rootKey], {}, [rootKey]);
            } else if (rootKey === "funcs") {
              // leave only diff for every used func
              zipConfig[rootKey] = clone$3(zipConfig[rootKey] || {});
              for (var k in zipConfig[rootKey]) {
                _clean(zipConfig[rootKey][k], null, [rootKey, k], {
                  BasicFuncs: BasicFuncs
                });
              }
            } else {
              // leave only diff
              zipConfig[rootKey] = clone$3(zipConfig[rootKey]);
              _clean(zipConfig[rootKey], baseConfig[rootKey], [rootKey]);
            }
          }
          return zipConfig;
        };
        var decompressConfig = function decompressConfig(zipConfig, baseConfig, ctx) {
          if (!zipConfig.settings.useConfigCompress) {
            throw new Error("Please enable `useConfigCompress` in config settings to use decompressConfig()");
          }
          var unzipConfig = {};
          var _mergeDeep = function _mergeDeep(target, mixin, path) {
            if (isObject$5(mixin)) {
              if (!isObject$5(target)) {
                target = {};
              }
              for (var k in mixin) {
                if (Object.prototype.hasOwnProperty.call(mixin, k)) {
                  if (mixin[k] === "$$deleted") {
                    delete target[k];
                  } else {
                    target[k] = _mergeDeep(target[k], mixin[k], [].concat(_toConsumableArray(path), [k]));
                  }
                }
              }
            } else if (Array.isArray(mixin)) {
              // don't merge arrays, just replace
              target = clone$3(mixin);
            } else {
              target = mixin;
            }
            return target;
          };
          var _resolveAndMergeDeep = function _resolveAndMergeDeep(target, path, meta) {
            // try to resolve by $$key and merge
            var resolved = false;
            if (isObject$5(target) && Object.prototype.hasOwnProperty.call(target, "$$key") && target["$$key"]) {
              var func = getFieldRawConfig({
                funcs: meta.BasicFuncs
              }, target["$$key"], "funcs", "subfields");
              if (func) {
                // deep merge func <- zip
                delete target["$$key"];
                target = _mergeDeep(clone$3(func), target, path);
                resolved = true;
              } else {
                throw new Error("decompressConfig: basic function not found by key ".concat(target["$$key"], " at ").concat(path.join(".")));
              }
            }
            if (!resolved) {
              if (isObject$5(target)) {
                // loop through object to find refs ($$key)
                for (var k in target) {
                  if (Object.prototype.hasOwnProperty.call(target, k)) {
                    target[k] = _resolveAndMergeDeep(target[k], [].concat(_toConsumableArray(path), [k]), meta);
                  }
                }
              } else if (Array.isArray(target)) {
                // also loop through array to find refs ($$key)
                var _iterator = _createForOfIteratorHelper$9(target),
                  _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var _k2 = _step.value;
                    target[_k2] = _resolveAndMergeDeep(target[_k2], [].concat(_toConsumableArray(path), [_k2]), meta);
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
            }
            return target;
          };
          for (var _i2 = 0, _configKeys2 = configKeys; _i2 < _configKeys2.length; _i2++) {
            var rootKey = _configKeys2[_i2];
            if (rootKey === "ctx") {
              // simple deep merge
              unzipConfig[rootKey] = merge$2({}, baseConfig.ctx || {}, ctx || {});
            } else if (rootKey === "funcs") {
              // use $$key to pick funcs from BasicFuncs
              unzipConfig[rootKey] = clone$3(zipConfig[rootKey] || {});
              _resolveAndMergeDeep(unzipConfig[rootKey], [rootKey], {
                BasicFuncs: BasicFuncs
              });
            } else if (rootKey === "fields") {
              // just copy
              unzipConfig[rootKey] = clone$3(zipConfig[rootKey] || {});
            } else {
              // deep merge base <- zip
              unzipConfig[rootKey] = clone$3(baseConfig[rootKey] || {});
              _mergeDeep(unzipConfig[rootKey], zipConfig[rootKey] || {}, [rootKey]);
            }
          }
          return unzipConfig;
        };

        /////////////

        var compileConfig = function compileConfig(config) {
          if (config.__compliled) {
            return config;
          }
          config = clone$3(config);
          var opts = {
            ctx: config.ctx
          };
          var logs = [];
          _compileConfigParts(config, config, opts, compileMeta, logs);
          //console.log(logs.join("\n"));

          Object.defineProperty(config, "__compliled", {
            enumerable: false,
            writable: false,
            value: true
          });
          return config;
        };
        function _compileConfigParts(config, subconfig, opts, meta, logs) {
          var path = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
          if (!subconfig) return;
          !path.length;
          for (var k in meta) {
            var submeta = meta[k];
            var newPath = k === "x" ? path : [].concat(_toConsumableArray(path), [k]);
            // if (isRoot) {
            //   //logs.push(`Cloned ${newPath.join(".")}`);
            //   config[k] = clone(config[k]);
            // }
            if (submeta.type === "r") {
              var targetObj = subconfig;
              var val = targetObj[k];
              if (submeta.isArr) {
                for (var ind in val) {
                  var newVal = renderReactElement(val[ind], opts, [].concat(_toConsumableArray(newPath), [ind]));
                  if (newVal !== val[ind]) {
                    logs.push("Compiled ".concat(newPath.join("."), "[").concat(ind, "]"));
                    val[ind] = newVal;
                  }
                }
              } else {
                var _newVal = renderReactElement(val, opts, newPath, undefined);
                if (_newVal !== val) {
                  logs.push("Compiled R ".concat(newPath.join(".")));
                  targetObj[k] = _newVal;
                }
              }
            } else if (submeta.type === "rf") {
              var _targetObj = subconfig;
              var _val = _targetObj[k];
              var _newVal2 = compileJsonLogicReact(_val, opts, newPath, submeta.ignore);
              if (_newVal2 !== _val) {
                logs.push("Compiled JL-RF ".concat(newPath.join(".")));
                _targetObj[k] = _newVal2;
              }
            } else if (submeta.type === "f") {
              var _targetObj2 = subconfig;
              var _val2 = _targetObj2[k];
              var _newVal3 = compileJsonLogic(_val2, opts, newPath, submeta.args, submeta.ignore);
              if (submeta.invokeWith && _newVal3 && typeof _newVal3 === "function") {
                var _newVal4;
                _newVal3 = (_newVal4 = _newVal3).call.apply(_newVal4, [null].concat(_toConsumableArray(submeta.invokeWith)));
              }
              if (_newVal3 !== _val2) {
                logs.push("Compiled JL-F ".concat(newPath.join(".")));
                _targetObj2[k] = _newVal3;
              }
            } else if (k === "x") {
              for (var field in subconfig) {
                newPath = [].concat(_toConsumableArray(path), [field]);
                var def = subconfig[field];
                _compileConfigParts(config, def, opts, submeta, logs, newPath);
                if (def.subfields) {
                  // tip: need to pass `meta`, not `submeta`
                  _compileConfigParts(config, def.subfields, opts, meta, logs, newPath);
                }
              }
            } else {
              var _def = subconfig[k];
              _compileConfigParts(config, _def, opts, submeta, logs, newPath);
            }
          }
        }
        function compileJsonLogicReact(jl, opts, path) {
          if (isJsonLogic(jl)) {
            return function (props, ctx) {
              ctx = ctx || (opts === null || opts === void 0 ? void 0 : opts.ctx); // can use context compile-time if not passed at runtime
              var data = {
                props: props,
                ctx: ctx
              };
              var re = applyJsonLogicWithPath(jl, data, path);
              if (typeof re === "string") {
                re = {
                  type: re,
                  props: props
                };
              }
              var ret = renderReactElement(re, {
                ctx: ctx
              }, path);
              return ret;
            };
          } else if (typeof jl === "string") {
            return function (props, ctx) {
              ctx = ctx || (opts === null || opts === void 0 ? void 0 : opts.ctx); // can use context compile-time if not passed at runtime
              var fn = jl.split(".").reduce(function (o, k) {
                return o === null || o === void 0 ? void 0 : o[k];
              }, ctx);
              if (fn) {
                return callContextFn(this, fn, [props, ctx], path);
              } else {
                var re = {
                  type: jl,
                  props: props
                };
                var ret = renderReactElement(re, {
                  ctx: ctx
                }, path);
                return ret;
              }
            };
          }
          return jl;
        }
        function compileJsonLogic(jl, opts, path, argNames) {
          var ignore = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
          if (isJsonLogic(jl) && ignore !== "jl") {
            return function () {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              var ctx = this || (opts === null || opts === void 0 ? void 0 : opts.ctx); // can use context compile-time if not passed at runtime
              var data = (argNames || []).reduce(function (acc, k, i) {
                return _objectSpread$u(_objectSpread$u({}, acc), {}, _defineProperty$4({}, k, args[i]));
              }, {
                args: args,
                ctx: ctx
              });
              var ret = applyJsonLogicWithPath(jl, data, path);
              return ret;
            }.bind(opts === null || opts === void 0 ? void 0 : opts.ctx);
          } else if (typeof jl === "string" && ignore !== "string") {
            return function () {
              var ctx = this || (opts === null || opts === void 0 ? void 0 : opts.ctx); // can use context compile-time if not passed at runtime
              var fn = jl.split(".").reduce(function (o, k) {
                return o === null || o === void 0 ? void 0 : o[k];
              }, ctx);
              if (fn) {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }
                return callContextFn(this, fn, args, path);
              } else {
                throw new Error("".concat(path.join("."), " :: Function ").concat(jl, " is not found in ctx"));
              }
            }.bind(opts === null || opts === void 0 ? void 0 : opts.ctx);
          }
          return jl;
        }
        function getReactComponentFromCtx(name, ctx) {
          var _ctx$components;
          return (ctx === null || ctx === void 0 || (_ctx$components = ctx.components) === null || _ctx$components === void 0 ? void 0 : _ctx$components[name]) || ctx.W[name] || ctx.O[name];
        }
        function renderReactElement(jsx, opts, path) {
          var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
          if (isJSX(jsx)) {
            var _props;
            var type = jsx.type,
              props = jsx.props;
            if (typeof type !== "string") {
              throw new Error("renderReactElement for ".concat(path.join("."), ": type should be string"));
            }
            var Cmp = getReactComponentFromCtx(type, opts.ctx) || type.toLowerCase();
            var children;
            if (key !== undefined) {
              props = _objectSpread$u(_objectSpread$u({}, props), {}, {
                key: key
              });
            }
            if ((_props = props) !== null && _props !== void 0 && _props.children) {
              children = renderReactElement(props.children, opts, path);
              props = _objectSpread$u(_objectSpread$u({}, props), {}, {
                children: children
              });
            }
            var res = opts.ctx.RCE(Cmp, props);
            return res;
          } else if (jsx instanceof Array) {
            return jsx.map(function (el, i) {
              return renderReactElement(el, opts, path, "" + i);
            });
          }
          return jsx;
        }
        var baseMerge$1 = _baseMerge,
          createAssigner$1 = _createAssigner;

        /**
         * This method is like `_.merge` except that it accepts `customizer` which
         * is invoked to produce the merged values of the destination and source
         * properties. If `customizer` returns `undefined`, merging is handled by the
         * method instead. The `customizer` is invoked with six arguments:
         * (objValue, srcValue, key, object, source, stack).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   if (_.isArray(objValue)) {
         *     return objValue.concat(srcValue);
         *   }
         * }
         *
         * var object = { 'a': [1], 'b': [2] };
         * var other = { 'a': [3], 'b': [4] };
         *
         * _.mergeWith(object, other, customizer);
         * // => { 'a': [1, 3], 'b': [2, 4] }
         */
        var mergeWith = createAssigner$1(function (object, source, srcIndex, customizer) {
          baseMerge$1(object, source, srcIndex, customizer);
        });
        var mergeWith_1 = mergeWith;
        const mergeWith$1 = /*@__PURE__*/getDefaultExportFromCjs(mergeWith_1);
        var settings$4 = {
          reverseOperatorsForNot: false,
          canShortMongoQuery: true,
          formatField: function formatField(field, parts, label2, fieldDefinition, config, isForDisplay) {
            if (isForDisplay) return label2;else return field;
          },
          caseValueField: {
            type: "case_value"
          },
          fieldSources: ["field"],
          keepInputOnChangeFieldSrc: true,
          fieldItemKeysForSearch: ["label", "path", "altLabel", "grouplabel"],
          listKeysForSearch: ["title", "value"],
          valueSourcesInfo: {
            value: {}
          },
          fieldSeparator: ".",
          fieldSeparatorDisplay: ".",
          canReorder: true,
          canRegroup: true,
          canDeleteLocked: false,
          canLeaveEmptyGroup: true,
          shouldCreateEmptyGroup: false,
          exportPreserveGroups: false,
          removeEmptyGroupsOnLoad: true,
          removeEmptyRulesOnLoad: true,
          removeIncompleteRulesOnLoad: false,
          removeInvalidMultiSelectValuesOnLoad: true,
          showErrorMessage: false,
          setOpOnChangeField: ["keep", "default"],
          // 'default' (default if present), 'keep' (keep prev from last field), 'first', 'none'
          groupOperators: ["some", "all", "none"],
          defaultGroupConjunction: "AND",
          // localization
          locale: {
            moment: "en"
          },
          valueLabel: "Value",
          valuePlaceholder: "Value",
          fieldLabel: "Field",
          operatorLabel: "Operator",
          funcLabel: "Function",
          fieldPlaceholder: "Select field",
          funcPlaceholder: "Select function",
          operatorPlaceholder: "Select operator",
          lockLabel: "Lock",
          lockedLabel: "Locked",
          deleteLabel: "Delete",
          addGroupLabel: "Add group",
          addCaseLabel: "Add condition",
          addDefaultCaseLabel: "Add default condition",
          defaultCaseLabel: "Default:",
          addRuleLabel: "Add rule",
          addSubRuleLabel: "Add sub rule",
          delGroupLabel: "Delete",
          notLabel: "Not",
          fieldSourcesPopupTitle: "Select source",
          valueSourcesPopupTitle: "Select value source",
          removeRuleConfirmOptions: null,
          removeGroupConfirmOptions: null
        };
        function _createForOfIteratorHelper$8(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$8(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$8(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$8(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen);
        }
        function _arrayLikeToArray$8(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        var memoId = 0;
        var configId = 0;
        var commonMemo;
        var memos = {};
        var getCommonMemo = function getCommonMemo() {
          if (!commonMemo) {
            commonMemo = createConfigMemo$1({
              reactIndex: undefined,
              maxSize: 3,
              canCompile: undefined // default is true
            });
          }
          return commonMemo;
        };
        var findExtendedConfigInAllMemos = function findExtendedConfigInAllMemos(config, needsToBeCompiled) {
          var foundExtConfig;
          for (var k in memos) {
            var found = memos[k].findExtendedConfig(config, needsToBeCompiled);
            if (found) {
              foundExtConfig = found;
              break;
            }
          }
          return foundExtConfig;
        };
        var createConfigMemo$1 = function createConfigMemo() {
          var meta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            reactIndex: undefined,
            maxSize: 2,
            // current and prev
            canCompile: true
          };
          var configStore = new Map();
          var maxSize = meta.maxSize || 2;
          var currentMemoId = ++memoId;
          var currentMemo;
          var pickConfig = function pickConfig(props) {
            return pick$1(props, configKeys);
          };
          var extendAndStore = function extendAndStore(config) {
            var extendedConfig = extendConfig(config, ++configId, meta.canCompile);
            storeConfigPair(config, extendedConfig);
            return extendedConfig;
          };
          var getSize = function getSize() {
            return configStore.size;
          };
          var storeConfigPair = function storeConfigPair(config, extendedConfig) {
            if (configStore.size + 1 > maxSize) {
              configStore["delete"](configStore.keys().next().value);
            }
            configStore.set(config, extendedConfig);
          };
          var findBasic = function findBasic(findConfig) {
            var _iterator = _createForOfIteratorHelper$8(configStore.keys()),
              _step;
            try {
              var _loop = function _loop() {
                  var basicConfig = _step.value;
                  var extConfig = configStore.get(basicConfig);
                  var found = configKeys.map(function (k) {
                    return extConfig[k] === findConfig[k];
                  }).filter(function (v) {
                    return !v;
                  }).length === 0;
                  if (found) {
                    return {
                      v: basicConfig
                    };
                  }
                },
                _ret;
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                _ret = _loop();
                if (_ret) return _ret.v;
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            return findConfig;
          };
          var findExtended = function findExtended(findConfig, needsToBeCompiled) {
            // strict find:
            // return configStore.get(findConfig) || configStore.values().find(ec => ec === findConfig);
            var _iterator2 = _createForOfIteratorHelper$8(configStore.keys()),
              _step2;
            try {
              var _loop2 = function _loop2() {
                  var savedConfig = _step2.value;
                  var foundParts = configKeys.filter(function (k) {
                    return savedConfig[k] === findConfig[k];
                  });
                  var found = foundParts.length === configKeys.length && (needsToBeCompiled ? savedConfig.__compliled : true);
                  if (found) {
                    return {
                      v: configStore.get(savedConfig)
                    };
                  }
                },
                _ret2;
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                _ret2 = _loop2();
                if (_ret2) return _ret2.v;
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            var _iterator3 = _createForOfIteratorHelper$8(configStore.values()),
              _step3;
            try {
              var _loop3 = function _loop3() {
                  var extendedConfig = _step3.value;
                  var foundParts = configKeys.filter(function (k) {
                    return extendedConfig[k] === findConfig[k];
                  });
                  var found = foundParts.length === configKeys.length && (needsToBeCompiled ? extendedConfig.__compliled : true);
                  if (found) {
                    return {
                      v: extendedConfig
                    };
                  }
                },
                _ret3;
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                _ret3 = _loop3();
                if (_ret3) return _ret3.v;
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
            return null;
          };
          var findOrExtend = function findOrExtend(config) {
            return findExtended(config) || extendAndStore(config);
          };
          var clearConfigMemo = function clearConfigMemo() {
            configStore.clear();
            delete memos[currentMemoId];
            if (commonMemo === currentMemo) {
              commonMemo = undefined;
            }
          };
          currentMemo = {
            getExtendedConfig: function getExtendedConfig(props) {
              return findOrExtend(pickConfig(props));
            },
            findExtendedConfig: findExtended,
            getBasicConfig: findBasic,
            clearConfigMemo: clearConfigMemo,
            configId: configId,
            storeConfigPair: storeConfigPair,
            getSize: getSize,
            configStore: configStore,
            memoId: currentMemoId,
            meta: meta
          };
          if (meta.reactIndex === undefined) {
            commonMemo = currentMemo;
          }
          memos[currentMemoId] = currentMemo;
          return currentMemo;
        };
        function _createForOfIteratorHelper$7(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$7(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);
        }
        function _arrayLikeToArray$7(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function ownKeys$t(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$t(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$t(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$t(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        var extendConfig = function extendConfig(config, configId) {
          var canCompile = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          //operators, defaultOperator - merge
          //widgetProps (including valueLabel, valuePlaceholder, hideOperator, operatorInlineLabel) - concrete by widget

          canCompile = canCompile && config.settings.useConfigCompress;

          // Already extended?
          if (config.__configId) {
            return config;
          }

          // Try to take from memo (cache)
          var cachedExtConfig = findExtendedConfigInAllMemos(config, canCompile);
          if (cachedExtConfig) {
            return cachedExtConfig;
          }
          var origConfig = config;

          // Clone (and compile if need)
          if (canCompile) {
            if (config.__compliled) {
              // already compiled
              config = clone$3(config);
            } else {
              // will be cloned and compiled
              config = compileConfig(config);
            }
          } else {
            config = clone$3(config);
          }
          config.settings = mergeWith$1({}, settings$4, config.settings, mergeCustomizerNoArrays);
          config.__fieldsCntByType = {};
          config.__funcsCntByType = {};
          config.__fieldNames = {};
          extendTypesConfig(config.types, config);
          extendFieldsConfig(config.fields, config);
          extendFuncsConfig(config.funcs, config);
          var caseValueField = config.settings.caseValueField;
          if (caseValueField) {
            extendFieldConfig(caseValueField, config, [], false, true);
          }
          var momentLocale = config.settings.locale.moment;
          if (momentLocale) {
            hooks.locale(momentLocale);
          }
          Object.defineProperty(config, "__configId", {
            enumerable: false,
            writable: false,
            value: configId || uuid()
          });
          config.__cache = {};
          deepFreeze(config);

          // Save to memo (cache)
          var memo = getCommonMemo();
          memo.storeConfigPair(origConfig, config);
          return config;
        };
        function extendTypesConfig(typesConfig, config) {
          for (var type in typesConfig) {
            var typeConfig = typesConfig[type];
            extendTypeConfig(type, typeConfig, config);
          }
        }
        function extendTypeConfig(type, typeConfig, config) {
          var operators = null,
            defaultOperator = null;
          typeConfig.mainWidget = typeConfig.mainWidget || Object.keys(typeConfig.widgets).filter(function (w) {
            return w != "field" && w != "func";
          })[0];
          var excludeOperators = typeConfig.excludeOperators || [];
          for (var widget in typeConfig.widgets) {
            var typeWidgetConfig = typeConfig.widgets[widget];
            var defOp = typeWidgetConfig.defaultOperator;
            if (typeWidgetConfig.operators) {
              var typeWidgetOperators = typeWidgetConfig.operators.filter(function (op) {
                return !excludeOperators.includes(op);
              });
              operators = mergeArraysSmart(operators, typeWidgetOperators);
            }
            if (defOp && !excludeOperators.includes(defOp)) {
              if (!defaultOperator || widget === typeConfig.mainWidget) {
                defaultOperator = defOp;
              }
            }
            if (widget == typeConfig.mainWidget) {
              typeWidgetConfig.widgetProps = _objectSpread$t(_objectSpread$t({}, typeConfig.mainWidgetProps || {}), typeWidgetConfig.widgetProps || {});
            }
            typeConfig.widgets[widget] = typeWidgetConfig;
          }
          if (!typeConfig.valueSources) typeConfig.valueSources = Object.keys(config.settings.valueSourcesInfo);
          var _iterator = _createForOfIteratorHelper$7(typeConfig.valueSources),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var valueSrc = _step.value;
              if (valueSrc != "value" && !typeConfig.widgets[valueSrc]) {
                typeConfig.widgets[valueSrc] = {};
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          if (!typeConfig.operators && operators) typeConfig.operators = Array.from(new Set(operators)); //unique
          if (!typeConfig.defaultOperator && defaultOperator) typeConfig.defaultOperator = defaultOperator;
        }
        function extendFieldsConfig(subconfig, config) {
          var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          for (var field in subconfig) {
            var fieldPathArr = [].concat(_toConsumableArray(path), [field]);
            extendFieldConfig(subconfig[field], config, fieldPathArr);
            if (subconfig[field].subfields) {
              extendFieldsConfig(subconfig[field].subfields, config, fieldPathArr);
            }
          }
        }
        function extendFuncsConfig(subconfig, config) {
          var _config$settings;
          var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          if (!subconfig) return;
          var fieldSeparator = (config === null || config === void 0 || (_config$settings = config.settings) === null || _config$settings === void 0 ? void 0 : _config$settings.fieldSeparator) || ".";
          for (var funcKey in subconfig) {
            var funcPathArr = [].concat(_toConsumableArray(path), [funcKey]);
            var funcPathStr = funcPathArr.join(fieldSeparator);
            var funcDef = subconfig[funcKey];
            if (funcDef.returnType) {
              funcDef.type = funcDef.returnType;
              if (!config.__funcsCntByType[funcDef.returnType]) config.__funcsCntByType[funcDef.returnType] = 0;
              config.__funcsCntByType[funcDef.returnType]++;
            }
            extendFieldConfig(funcDef, config, funcPathArr, false);
            if (funcDef.args) {
              for (var argKey in funcDef.args) {
                extendFieldConfig(funcDef.args[argKey], config, [].concat(_toConsumableArray(funcPathArr), [argKey]), true);
              }
              // isOptional can be only in the end
              var argKeys = Object.keys(funcDef.args);
              var tmpIsOptional = true;
              var _iterator2 = _createForOfIteratorHelper$7(argKeys.reverse()),
                _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var _argKey = _step2.value;
                  var argDef = funcDef.args[_argKey];
                  if (!tmpIsOptional && argDef.isOptional) {
                    logger$1.info("Arg ".concat(_argKey, " for func ").concat(funcPathStr, " can't be optional"));
                    delete argDef.isOptional;
                  }
                  if (!argDef.isOptional) tmpIsOptional = false;
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
            if (funcDef.subfields) {
              extendFuncsConfig(funcDef.subfields, config, [].concat(_toConsumableArray(path), [funcKey]));
            }
          }
        }
        function normalizeFieldSettings(fieldConfig, config, type) {
          var _fieldConfig$fieldSet, _fieldConfig$fieldSet2;
          var keysToPutInFieldSettings = ["listValues", "treeValues", "allowCustomValues", "validateValue"];
          for (var _i = 0, _keysToPutInFieldSett = keysToPutInFieldSettings; _i < _keysToPutInFieldSett.length; _i++) {
            var k = _keysToPutInFieldSett[_i];
            if (fieldConfig[k]) {
              if (!fieldConfig.fieldSettings) fieldConfig.fieldSettings = {};
              fieldConfig.fieldSettings[k] = fieldConfig[k];
              delete fieldConfig[k];
            }
          }

          // normalize listValues
          if ((_fieldConfig$fieldSet = fieldConfig.fieldSettings) !== null && _fieldConfig$fieldSet !== void 0 && _fieldConfig$fieldSet.listValues) {
            if (config.settings.normalizeListValues) {
              fieldConfig.fieldSettings.listValues = config.settings.normalizeListValues.call(config.ctx, fieldConfig.fieldSettings.listValues, type, fieldConfig.fieldSettings);
            }
          }
          // same for treeValues
          if ((_fieldConfig$fieldSet2 = fieldConfig.fieldSettings) !== null && _fieldConfig$fieldSet2 !== void 0 && _fieldConfig$fieldSet2.treeValues) {
            if (config.settings.normalizeListValues) {
              fieldConfig.fieldSettings.treeValues = config.settings.normalizeListValues.call(config.ctx, fieldConfig.fieldSettings.treeValues, type, fieldConfig.fieldSettings);
            }
          }
        }
        function extendFieldConfig(fieldConfig, config) {
          var _fieldSeparator;
          var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          var isFuncArg = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var isCaseValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          var _config$settings2 = config.settings,
            showLabels = _config$settings2.showLabels,
            fieldSeparator = _config$settings2.fieldSeparator;
          fieldSeparator = (_fieldSeparator = fieldSeparator) !== null && _fieldSeparator !== void 0 ? _fieldSeparator : ".";
          var argKey = path[path.length - 1];
          var funcKey = isFuncArg ? path.slice(0, path.length - 1).join(fieldSeparator) : path.join(fieldSeparator);
          var isFunc = !!fieldConfig.returnType;
          var type = fieldConfig.type || fieldConfig.returnType;
          // const isGroup = type === "!struct" || type === "!group";
          var typeConfig = config.types[type];
          var excludeOperatorsForField = fieldConfig.excludeOperators || [];
          var operators = (fieldConfig.operators || (typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.operators) || []).filter(function (op) {
            return !excludeOperatorsForField.includes(op);
          });
          var defaultOperator = fieldConfig.defaultOperator || (typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.defaultOperator);
          if (excludeOperatorsForField.includes(defaultOperator)) defaultOperator = undefined;
          var hasOwnDefaultOperator = !!defaultOperator && defaultOperator == fieldConfig.defaultOperator;
          if (hasOwnDefaultOperator) {
            fieldConfig.ownDefaultOperator = fieldConfig.defaultOperator;
          }
          if (!typeConfig) {
            // console.warn(`No type config for ${type}`);
            fieldConfig.disabled = true;
            return;
          }
          if (!isFuncArg && !isFunc && !isCaseValue) {
            if (!config.__fieldsCntByType[type]) config.__fieldsCntByType[type] = 0;
            config.__fieldsCntByType[type]++;
          }
          if (isFuncArg) {
            fieldConfig._isFuncArg = true;
            fieldConfig._argKey = argKey;
            fieldConfig._funcKey = funcKey;
          }
          if (isFunc) {
            fieldConfig._isFunc = true;
            fieldConfig._funcKey = funcKey;
          }
          if (isCaseValue) {
            fieldConfig._isCaseValue = true;
          }
          normalizeFieldSettings(fieldConfig, config, type);

          // copy from type to field
          var excludeKeysFromType = ["widgets", "operators", "defaultOperator"];
          Object.keys(typeConfig).filter(function (k) {
            return !excludeKeysFromType.includes(k);
          }).map(function (k) {
            if (!fieldConfig[k]) {
              fieldConfig[k] = shallowCopy(typeConfig[k]);
            }
          });

          // copy/merge widgets
          var excludeOperatorsForType = typeConfig.excludeOperators || [];
          if (fieldConfig.operators) {
            // `operators` from field can override `excludeOperators` from type, see `prox1` at examples
            excludeOperatorsForType = excludeOperatorsForType.filter(function (op) {
              return !fieldConfig.operators.includes(op);
            });
          }
          if (!fieldConfig.widgets) fieldConfig.widgets = {};
          var _loop = function _loop() {
            var fieldWidgetConfig = _objectSpread$t({}, fieldConfig.widgets[widget] || {});
            var typeWidgetConfig = typeConfig.widgets[widget] || {};

            // merge operators, defaultOperator
            if (!isFuncArg) {
              // tip: operators are not used for func args
              var defOp = fieldWidgetConfig.defaultOperator;
              var excludeOperators = [].concat(_toConsumableArray(excludeOperatorsForField), _toConsumableArray(excludeOperatorsForType));
              var shouldIncludeOperators = fieldConfig.preferWidgets && (widget === "field" || fieldConfig.preferWidgets.includes(widget)) || excludeOperators.length > 0;
              if (fieldWidgetConfig.operators) {
                var addOperators = fieldWidgetConfig.operators.filter(function (op) {
                  return !excludeOperators.includes(op);
                });
                fieldWidgetConfig.operators = addOperators;
                // operators = [...(operators || []), ...addOperators];
                operators = mergeArraysSmart(operators, addOperators);
              } else if (shouldIncludeOperators && typeWidgetConfig.operators) {
                var _addOperators = typeWidgetConfig.operators.filter(function (op) {
                  return !excludeOperators.includes(op);
                });
                fieldWidgetConfig.operators = _addOperators;
                // operators = [...(operators || []), ...addOperators];
                operators = mergeArraysSmart(operators, _addOperators);
              }
              if (defOp && !excludeOperators.includes(defOp)) {
                if (!defaultOperator || !hasOwnDefaultOperator && widget === fieldConfig.mainWidget) {
                  // tip: defOp can overwrite default operator from type config
                  defaultOperator = defOp;
                }
              }
            }

            // merge widgetProps
            if (widget === fieldConfig.mainWidget) {
              fieldWidgetConfig.widgetProps = _objectSpread$t(_objectSpread$t(_objectSpread$t({}, typeWidgetConfig.widgetProps || {}), fieldConfig.mainWidgetProps || {}), fieldWidgetConfig.widgetProps || {});
            } else {
              fieldWidgetConfig.widgetProps = _objectSpread$t(_objectSpread$t({}, typeWidgetConfig.widgetProps || {}), fieldWidgetConfig.widgetProps || {});
            }

            // merge opProps
            var opKeys = Array.from(new Set([].concat(_toConsumableArray(Object.keys(typeWidgetConfig.opProps || {})), _toConsumableArray(Object.keys(fieldWidgetConfig.opProps || {})))));
            if (opKeys.length) {
              var opProps = {};
              var _iterator3 = _createForOfIteratorHelper$7(opKeys),
                _step3;
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var _typeWidgetConfig$opP, _fieldWidgetConfig$op;
                  var op = _step3.value;
                  opProps[op] = _objectSpread$t(_objectSpread$t({}, ((_typeWidgetConfig$opP = typeWidgetConfig.opProps) === null || _typeWidgetConfig$opP === void 0 ? void 0 : _typeWidgetConfig$opP[op]) || {}), ((_fieldWidgetConfig$op = fieldWidgetConfig.opProps) === null || _fieldWidgetConfig$op === void 0 ? void 0 : _fieldWidgetConfig$op[op]) || {});
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
              fieldWidgetConfig.opProps = opProps;
            }

            // label for func arg
            var _fieldWidgetConfig = fieldWidgetConfig,
              valueLabel = _fieldWidgetConfig.valueLabel,
              valuePlaceholder = _fieldWidgetConfig.valuePlaceholder;
            if (isFuncArg) {
              if (!valueLabel) fieldWidgetConfig.valueLabel = fieldConfig.label || argKey;
              if (!valuePlaceholder && !showLabels) fieldWidgetConfig.valuePlaceholder = fieldConfig.label || argKey;
            }

            // copy other widget configs from type to field
            fieldWidgetConfig = _objectSpread$t(_objectSpread$t({}, typeWidgetConfig), fieldWidgetConfig);
            fieldConfig.widgets[widget] = fieldWidgetConfig;
          };
          for (var widget in typeConfig.widgets) {
            _loop();
          }
          if (!isFuncArg) {
            // tip: operators are not used for func args
            if (!fieldConfig.operators) {
              fieldConfig.operators = Array.from(new Set(operators)); // unique
            }
            if (!fieldConfig.defaultOperator) {
              fieldConfig.defaultOperator = defaultOperator;
            }
          }
          if (!isFuncArg && !isFunc && !isCaseValue) {
            var _computeFieldName = computeFieldName(config, path),
              fieldName = _computeFieldName.fieldName,
              inGroup = _computeFieldName.inGroup;
            if (fieldName) {
              fieldConfig.fieldName = fieldName;
              if (!config.__fieldNames[fieldName]) config.__fieldNames[fieldName] = [];
              config.__fieldNames[fieldName].push({
                fullPath: path,
                inGroup: inGroup
              });
            }
          }
        }
        function computeFieldName(config, path) {
          if (!path) return {};
          var fieldSeparator = config.settings.fieldSeparator;
          var _reduce = _toConsumableArray(path).reduce(function (_ref, f, i, arr) {
              var computedPath = _ref.computedPath,
                computed = _ref.computed,
                inGroup = _ref.inGroup;
              var fullPath = [].concat(_toConsumableArray(arr.slice(0, i)), [f]);
              var fConfig = getFieldRawConfig(config, fullPath);
              if ((fConfig === null || fConfig === void 0 ? void 0 : fConfig.type) === "!group" && i < arr.length - 1) {
                // don't include group in final field name
                inGroup = fullPath.join(fieldSeparator);
                computedPath = [];
              } else if (fConfig !== null && fConfig !== void 0 && fConfig.fieldName) {
                // tip: fieldName overrides path !
                computed = true;
                computedPath = [fConfig.fieldName];
              } else {
                computedPath = [].concat(_toConsumableArray(computedPath), [f]);
              }
              return {
                computedPath: computedPath,
                computed: computed,
                inGroup: inGroup
              };
            }, {
              computedPath: [],
              computed: false,
              inGroup: undefined
            }),
            computedPath = _reduce.computedPath,
            computed = _reduce.computed,
            inGroup = _reduce.inGroup;
          return computed ? {
            fieldName: computedPath.join(fieldSeparator),
            inGroup: inGroup
          } : {};
        }
        function ownKeys$s(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$s(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$s(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$s(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        var _marked = /*#__PURE__*/_regeneratorRuntime.mark(iterateFuncs),
          _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(iterateFields);
        var _widgetDefKeysToOmit$1 = widgetDefKeysToOmit; // for ui

        function iterateFuncs(config) {
          return _regeneratorRuntime.wrap(function iterateFuncs$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                return _context.delegateYield(_iterateFields(config, config.funcs || {}, []), "t0", 1);
              case 1:
              case "end":
                return _context.stop();
            }
          }, _marked);
        }
        function iterateFields(config) {
          return _regeneratorRuntime.wrap(function iterateFields$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.delegateYield(_iterateFields(config, config.fields || {}, []), "t0", 1);
              case 1:
              case "end":
                return _context2.stop();
            }
          }, _marked2);
        }
        function _iterateFields(config, subfields, path) {
          var subfieldsKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "subfields";
          return /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_config$settings) {
            var fieldSeparator, fieldKey, fieldConfig;
            return _regeneratorRuntime.wrap(function _callee$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  fieldSeparator = (config === null || config === void 0 || (_config$settings = config.settings) === null || _config$settings === void 0 ? void 0 : _config$settings.fieldSeparator) || ".";
                  _context3.t0 = _regeneratorRuntime.keys(subfields);
                case 2:
                  if ((_context3.t1 = _context3.t0()).done) {
                    _context3.next = 13;
                    break;
                  }
                  fieldKey = _context3.t1.value;
                  fieldConfig = subfields[fieldKey];
                  if (!fieldConfig[subfieldsKey]) {
                    _context3.next = 9;
                    break;
                  }
                  return _context3.delegateYield(_iterateFields(config, fieldConfig[subfieldsKey], [].concat(_toConsumableArray(path), [fieldKey]), subfieldsKey), "t2", 7);
                case 7:
                  _context3.next = 11;
                  break;
                case 9:
                  _context3.next = 11;
                  return [[].concat(_toConsumableArray(path), [fieldKey]).join(fieldSeparator), fieldConfig];
                case 11:
                  _context3.next = 2;
                  break;
                case 13:
                case "end":
                  return _context3.stop();
              }
            }, _callee);
          })();
        }
        var getFieldRawConfig = function getFieldRawConfig(config, field) {
          var _config$settings3;
          var fieldsKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "fields";
          var subfieldsKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "subfields";
          if (!field) return null;
          if (field === "!case_value") {
            var _config$settings2;
            return config === null || config === void 0 || (_config$settings2 = config.settings) === null || _config$settings2 === void 0 ? void 0 : _config$settings2.caseValueField;
          }
          var fieldSeparator = (config === null || config === void 0 || (_config$settings3 = config.settings) === null || _config$settings3 === void 0 ? void 0 : _config$settings3.fieldSeparator) || ".";
          var parts = getFieldParts$3(field, config);
          var targetFields = config[fieldsKey];
          if (!targetFields) return null;
          var fields = targetFields;
          var fieldConfig = null;
          var path = [];
          for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            path.push(part);
            var pathKey = path.join(fieldSeparator);
            fieldConfig = fields[pathKey];
            if (i < parts.length - 1) {
              if (fieldConfig && fieldConfig[subfieldsKey]) {
                fields = fieldConfig[subfieldsKey];
                path = [];
              } else {
                fieldConfig = null;
              }
            }
          }
          return fieldConfig;
        };

        // if `field` is alias (fieldName), convert to original full path
        var normalizeField = function normalizeField(config, field) {
          var _config$__fieldNames$, _config$__fieldNames$2;
          var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          // tip: if parentField is present, field is not full path
          var fieldSeparator = config.settings.fieldSeparator;
          var path = [parentField].concat(_toConsumableArray(field.split(fieldSeparator))).filter(function (f) {
            return f != null;
          });
          var findStr = field;
          var normalizedPath = (_config$__fieldNames$ = config.__fieldNames[findStr]) === null || _config$__fieldNames$ === void 0 || (_config$__fieldNames$2 = _config$__fieldNames$.find) === null || _config$__fieldNames$2 === void 0 || (_config$__fieldNames$2 = _config$__fieldNames$2.call(_config$__fieldNames$, function (_ref) {
            var inGroup = _ref.inGroup;
            if (inGroup) return parentField === null || parentField === void 0 ? void 0 : parentField.startsWith(inGroup);
            return true;
          })) === null || _config$__fieldNames$2 === void 0 ? void 0 : _config$__fieldNames$2.fullPath;
          return (normalizedPath || path).join(fieldSeparator);
        };
        var getFuncSignature = function getFuncSignature(config, func) {
          if (!func) return null;
          var funcConfig = getFieldRawConfig(config, func, "funcs", "subfields");
          if (!funcConfig) return null;
          var returnType = funcConfig.returnType,
            args = funcConfig.args;
          var argsSignature = Object.fromEntries(Object.entries(args || {}).map(function (_ref2) {
            var _ref3 = _slicedToArray$1(_ref2, 2),
              k = _ref3[0],
              v = _ref3[1];
            var argSignature = pick$1(v, ["type", "valueSources", "defaultValue", "fieldSettings",
            // "asyncListValues", // not supported
            "isOptional",
            // to get proper caching key
            "_funcKey", "_argKey", "_isFuncArg"]);
            return [k, argSignature];
          }));
          var signature = {
            returnType: returnType,
            args: argsSignature
          };
          return signature;
        };
        var getFuncConfig$2 = function getFuncConfig(config, func) {
          if (!func) return null;
          var funcConfig = getFieldRawConfig(config, func, "funcs", "subfields");
          if (!funcConfig) return null; //throw new Error("Can't find func " + func + ", please check your config");
          return funcConfig;
        };
        var getFuncArgConfig = function getFuncArgConfig(config, funcKey, argKey) {
          var funcConfig = getFuncConfig$2(config, funcKey);
          if (!funcConfig) return null; //throw new Error(`Can't find func ${funcKey}, please check your config`);
          var argConfig = funcConfig.args && funcConfig.args[argKey] || null;
          if (!argConfig) return null; //throw new Error(`Can't find arg ${argKey} for func ${funcKey}, please check your config`);
          return argConfig;
        };
        var isFieldDescendantOfField = function isFieldDescendantOfField(field, parentField) {
          var _config$settings4;
          var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          if (!parentField) return false;
          var fieldSeparator = (config === null || config === void 0 || (_config$settings4 = config.settings) === null || _config$settings4 === void 0 ? void 0 : _config$settings4.fieldSeparator) || ".";
          var path = getFieldPath(field, config);
          var parentPath = getFieldPath(parentField, config);
          return path.startsWith(parentPath + fieldSeparator);
        };
        var getFieldPath = function getFieldPath(field) {
          var _config$settings5;
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          if (typeof field === "string") return field;
          var fieldSeparator = (config === null || config === void 0 || (_config$settings5 = config.settings) === null || _config$settings5 === void 0 ? void 0 : _config$settings5.fieldSeparator) || ".";
          return getFieldParts$3(field, config).join(fieldSeparator);
        };
        var getFieldParts$3 = function getFieldParts(field) {
          var _config$settings6, _field$get, _field$split;
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          if (!field) return [];
          if (Array.isArray(field)) return field;
          var fieldSeparator = (config === null || config === void 0 || (_config$settings6 = config.settings) === null || _config$settings6 === void 0 ? void 0 : _config$settings6.fieldSeparator) || ".";
          if (field !== null && field !== void 0 && field.func) {
            return Array.isArray(field.func) ? field.func : field.func.split(fieldSeparator);
          }
          if (field !== null && field !== void 0 && (_field$get = field.get) !== null && _field$get !== void 0 && _field$get.call(field, "func")) {
            var _field$get2;
            // immutable
            return field === null || field === void 0 || (_field$get2 = field.get) === null || _field$get2 === void 0 ? void 0 : _field$get2.call(field, "func").split(fieldSeparator);
          }
          return (field === null || field === void 0 || (_field$split = field.split) === null || _field$split === void 0 ? void 0 : _field$split.call(field, fieldSeparator)) || [];
        };
        var getFieldPathParts$3 = function getFieldPathParts(field, config) {
          var onlyKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          if (!field) return null;
          var fieldSeparator = config.settings.fieldSeparator;
          var parts = getFieldParts$3(field, config);
          if (onlyKeys) return parts;else return parts.map(function (_curr, ind, arr) {
            return arr.slice(0, ind + 1);
          }).map(function (parts) {
            return parts.join(fieldSeparator);
          });
        };
        var getFieldId$1 = function getFieldId(field) {
          var _field$get3;
          if (typeof field === "string" || Array.isArray(field)) {
            return "field:".concat(getFieldPath(field));
          }
          if (_typeof$3(field) === "object" && field) {
            if (field._funcKey && field._argKey) {
              // it's func arg config
              return "arg:".concat(getFieldPath(field._funcKey), "__").concat(field._argKey);
            }
            if (field._funcKey) {
              // it's func config
              return "func:".concat(getFieldPath(field._funcKey));
            }
            if (field.func && field.arg) {
              // it's func arg
              return "arg:".concat(getFieldPath(field.func), "__").concat(field.arg);
            }
            if (field.func) {
              // it's field func
              return "func:".concat(getFieldPath(field.func));
            }
            if (field.type) {
              // it's already a config
              return null;
            }
          }
          if (field !== null && field !== void 0 && (_field$get3 = field.get) !== null && _field$get3 !== void 0 && _field$get3.call(field, "func")) {
            // immutable
            if (field !== null && field !== void 0 && field.get("arg")) {
              // it's func arg
              return "arg:".concat(getFieldPath(field.get("func")), "__").concat(field.get("arg"));
            } else {
              // it's field func
              return "func:".concat(getFieldPath(field.get("func")));
            }
          }
          return null;
        };
        var _getFromConfigCache = function _getFromConfigCache(config, bucketKey, cacheKey) {
          var _config$__cache;
          return (_config$__cache = config.__cache) === null || _config$__cache === void 0 || (_config$__cache = _config$__cache[bucketKey]) === null || _config$__cache === void 0 ? void 0 : _config$__cache[cacheKey];
        };
        var _saveToConfigCache = function _saveToConfigCache(config, bucketKey, cacheKey, value) {
          if (!config.__cache || !cacheKey) {
            return;
          }
          if (!config.__cache[bucketKey]) {
            config.__cache[bucketKey] = {};
          }
          config.__cache[bucketKey][cacheKey] = value;
        };
        var getFieldSrc = function getFieldSrc(field) {
          var _field$get4;
          if (!field) return null;
          if (_typeof$3(field) === "object") {
            if (!field.func && !!field.type) {
              // it's already a config
              return "field";
            }
            if (field.func) {
              if (field.func && field.arg) {
                // it's func arg
                return null;
              } else {
                // it's field func
                return "func";
              }
            }
          }
          if (field !== null && field !== void 0 && (_field$get4 = field.get) !== null && _field$get4 !== void 0 && _field$get4.call(field, "func")) {
            // immutable
            if (field !== null && field !== void 0 && field.get("arg")) {
              // it's func arg
              return null;
            } else {
              // it's field func
              return "func";
            }
          }
          return "field";
        };
        var getFieldConfig$8 = function getFieldConfig(config, field) {
          var _field$get5;
          if (!field) return null;
          if (_typeof$3(field) == "object") {
            if (!field.func && !!field.type) {
              // it's already a config
              return field;
            }
            if (field.func) {
              if (field.func && field.arg) {
                // it's func arg
                return getFuncArgConfig(config, field.func, field.arg);
              } else {
                // it's field func
                return getFuncConfig$2(config, field.func);
              }
            }
          }
          if (field !== null && field !== void 0 && (_field$get5 = field.get) !== null && _field$get5 !== void 0 && _field$get5.call(field, "func")) {
            // immutable
            if (field !== null && field !== void 0 && field.get("arg")) {
              // it's func arg
              return getFuncArgConfig(config, field.get("func"), field.get("arg"));
            } else {
              // it's field func
              return getFuncConfig$2(config, field.get("func"));
            }
          }
          var fieldConfig = getFieldRawConfig(config, field);
          if (!fieldConfig) return null; //throw new Error("Can't find field " + field + ", please check your config");
          return fieldConfig;
        };
        var getOperatorConfig$4 = function getOperatorConfig(config, operator) {
          var field = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          if (!operator) return null;
          var opConfig = config.operators[operator];
          if (field) {
            var _widgetConfig$opProps, _fieldWidgetConfig$op;
            var fieldCacheKey = getFieldId$1(field);
            var cacheKey = fieldCacheKey ? "".concat(fieldCacheKey, "__").concat(operator) : null;
            var cached = _getFromConfigCache(config, "getOperatorConfig", cacheKey);
            if (cached) return cached;
            var fieldConfig = getFieldConfig$8(config, field);
            var widget = getWidgetForFieldOp$3(config, field, operator, null);
            var widgetConfig = config.widgets[widget] || {};
            var fieldWidgetConfig = (fieldConfig && fieldConfig.widgets ? fieldConfig.widgets[widget] : {}) || {};
            var widgetOpProps = ((_widgetConfig$opProps = widgetConfig.opProps) === null || _widgetConfig$opProps === void 0 ? void 0 : _widgetConfig$opProps[operator]) || {};
            var fieldWidgetOpProps = ((_fieldWidgetConfig$op = fieldWidgetConfig.opProps) === null || _fieldWidgetConfig$op === void 0 ? void 0 : _fieldWidgetConfig$op[operator]) || {};
            var mergedConfig = _objectSpread$s(_objectSpread$s(_objectSpread$s({}, opConfig), widgetOpProps), fieldWidgetOpProps);
            _saveToConfigCache(config, "getOperatorConfig", cacheKey, mergedConfig);
            return mergedConfig;
          } else {
            return opConfig;
          }
        };
        var getFieldWidgetConfig$3 = function getFieldWidgetConfig(config, field) {
          var _fieldConfig$widgets;
          var operator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var widget = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var valueSrc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var meta = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
          if (!field) return null;
          var fieldConfig = getFieldConfig$8(config, field);
          var fieldCacheKey = getFieldId$1(field);
          if (!widget) {
            widget = getWidgetForFieldOp$3(config, field, operator, valueSrc);
          }
          var cacheKey = fieldCacheKey ? "".concat(fieldCacheKey, "__").concat(operator, "__").concat(widget, "__").concat(valueSrc) : null;
          var cached = _getFromConfigCache(config, "getFieldWidgetConfig", cacheKey);
          if (cached) return cached;
          var widgetConfig = config.widgets[widget] || {};
          var fieldWidgetConfig = (fieldConfig === null || fieldConfig === void 0 || (_fieldConfig$widgets = fieldConfig.widgets) === null || _fieldConfig$widgets === void 0 ? void 0 : _fieldConfig$widgets[widget]) || {};
          var fieldWidgetProps = fieldWidgetConfig.widgetProps || {};
          var valueFieldSettings = valueSrc === "value" || !valueSrc ? fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.fieldSettings : {}; // useful to take 'validateValue'
          var mergedConfig = _objectSpread$s(_objectSpread$s(_objectSpread$s(_objectSpread$s({}, widgetConfig), fieldWidgetConfig), fieldWidgetProps), valueFieldSettings);
          _saveToConfigCache(config, "getFieldWidgetConfig", cacheKey, mergedConfig);
          if (meta.forExport) {
            mergedConfig = omit$2(mergedConfig, "factory");
          }
          return mergedConfig;
        };
        var getFirstField = function getFirstField(config) {
          var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var fieldSeparator = config.settings.fieldSeparator;
          var parentPathArr = getFieldParts$3(parentRuleGroupPath, config);
          var parentField = parentRuleGroupPath ? getFieldRawConfig(config, parentRuleGroupPath) : config;
          var firstField = parentField,
            key = null,
            keysPath = [];
          do {
            var _firstField;
            var subfields = firstField === config ? config.fields : (_firstField = firstField) === null || _firstField === void 0 ? void 0 : _firstField.subfields;
            if (!subfields || !Object.keys(subfields).length) {
              firstField = key = null;
              break;
            }
            key = Object.keys(subfields)[0];
            keysPath.push(key);
            firstField = subfields[key];
          } while (firstField.type == "!struct" || firstField.type == "!group");
          return (parentPathArr || []).concat(keysPath).join(fieldSeparator);
        };
        const configUtils = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          _getFromConfigCache,
          _saveToConfigCache,
          _widgetDefKeysToOmit: _widgetDefKeysToOmit$1,
          applyJsonLogic,
          cleanJSX,
          compileConfig,
          compressConfig,
          configKeys,
          createConfigMemo: createConfigMemo$1,
          decompressConfig,
          extendConfig,
          findExtendedConfigInAllMemos,
          getCommonMemo,
          getFieldConfig: getFieldConfig$8,
          getFieldId: getFieldId$1,
          getFieldParts: getFieldParts$3,
          getFieldPath,
          getFieldPathParts: getFieldPathParts$3,
          getFieldRawConfig,
          getFieldSrc,
          getFieldWidgetConfig: getFieldWidgetConfig$3,
          getFirstField,
          getFuncArgConfig,
          getFuncConfig: getFuncConfig$2,
          getFuncSignature,
          getOperatorConfig: getOperatorConfig$4,
          isDirtyJSX,
          isFieldDescendantOfField,
          isJSX,
          iterateFields,
          iterateFuncs,
          normalizeField
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function ownKeys$r(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$r(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$r(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$r(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }

        /*
         Build tree to http://querybuilder.js.org/ like format
          Example:
         {
            "condition": "AND",
            "rules": [
                {
                    "id": "price",
                    "field": "price",
                    "type": "double",
                    "input": "text",
                    "operator": "less",
                    "value": "10.25"
                },
                {
                    "condition": "OR",
                    "rules": [
                        {
                            "id": "category",
                            "field": "category",
                            "type": "integer",
                            "input": "select",
                            "operator": "equal",
                            "value": "2"
                        },
                        {
                            "id": "category",
                            "field": "category",
                            "type": "integer",
                            "input": "select",
                            "operator": "equal",
                            "value": "1"
                        }
                    ]
                }
            ]
         }
         */

        var queryBuilderFormat = function queryBuilderFormat(item, config) {
          //meta is mutable
          var meta = {
            usedFields: []
          };
          var res = formatItem$3(item, config, meta);
          if (!res) return undefined;
          return _objectSpread$r(_objectSpread$r({}, res), meta);
        };
        var formatItem$3 = function formatItem(item, config, meta) {
          if (!item) return undefined;
          var type = item.get("type");
          var children = item.get("children1");
          if ((type === "group" || type === "rule_group") && children && children.size) {
            return formatGroup$3(item, config, meta);
          } else if (type === "rule") {
            return formatRule$3(item, config, meta);
          }
          return undefined;
        };
        var formatGroup$3 = function formatGroup(item, config, meta) {
          var properties = item.get("properties") || new Map$2();
          var children = item.get("children1");
          var id = item.get("id");
          var list = children.map(function (currentChild) {
            return formatItem$3(currentChild, config, meta);
          }).filter(function (currentChild) {
            return typeof currentChild !== "undefined";
          });
          if (!list.size) return undefined;
          var conjunction = properties.get("conjunction");
          if (!conjunction) conjunction = defaultConjunction(config);
          var not = properties.get("not");
          var resultQuery = {
            id: id,
            rules: list.toList(),
            condition: conjunction.toUpperCase(),
            not: not
          };
          return resultQuery;
        };
        var formatRule$3 = function formatRule(item, config, meta) {
          var _valueType;
          var properties = item.get("properties") || new Map$2();
          var id = item.get("id");
          var operator = properties.get("operator");
          var options = properties.get("operatorOptions");
          var field = properties.get("field");
          var value = properties.get("value");
          var valueSrc = properties.get("valueSrc");
          var valueType = properties.get("valueType");
          var hasUndefinedValues = value.filter(function (v) {
            return v === undefined;
          }).size > 0;
          if (field == null || operator == null || hasUndefinedValues) return undefined;
          var fieldDefinition = getFieldConfig$8(config, field) || {};
          var operatorDefinition = getOperatorConfig$4(config, operator, field) || {};
          var fieldType = fieldDefinition.type || "undefined";
          var cardinality = getOpCardinality$1(operatorDefinition);
          var typeConfig = config.types[fieldDefinition.type] || {};
          var fieldName = formatFieldName(field, config, meta);
          if (value.size < cardinality) return undefined;
          if (meta.usedFields.indexOf(field) == -1) meta.usedFields.push(field);
          value = value.toArray();
          valueSrc = valueSrc.toArray();
          valueType = ((_valueType = valueType) === null || _valueType === void 0 ? void 0 : _valueType.toArray()) || [];
          var values = [];
          for (var i = 0; i < value.length; i++) {
            var val = {
              type: valueType[i],
              value: value[i]
            };
            values.push(val);
            if (valueSrc[i] == "field") {
              var secondField = value[i];
              if (meta.usedFields.indexOf(secondField) == -1) meta.usedFields.push(secondField);
            }
          }
          var operatorOptions = options ? options.toJS() : null;
          if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;
          var ruleQuery = {
            id: id,
            fieldName: fieldName,
            type: fieldType,
            input: typeConfig.mainWidget,
            operator: operator
          };
          if (operatorOptions) ruleQuery.operatorOptions = operatorOptions;
          ruleQuery.values = values;
          return ruleQuery;
        };
        function ownKeys$q(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$q(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$q(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$q(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _createForOfIteratorHelper$6(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$6(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);
        }
        function _arrayLikeToArray$6(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }

        // http://jsonlogic.com/

        var jsonLogicFormat = function jsonLogicFormat(item, config) {
          //meta is mutable
          var meta = {
            usedFields: [],
            errors: []
          };
          var extendedConfig = extendConfig(config, undefined, false);
          var logic = formatItem$2(item, extendedConfig, meta, false, true);

          // build empty data
          var errors = meta.errors,
            usedFields = meta.usedFields;
          extendedConfig.settings.fieldSeparator;
          var data = {};
          var _iterator = _createForOfIteratorHelper$6(usedFields),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var ff = _step.value;
              //const fieldSrc = typeof ff === "string" ? "field" : "func";
              var parts = getFieldParts$3(ff, config);
              var def = getFieldConfig$8(extendedConfig, ff) || {};
              var tmp = data;
              for (var i = 0; i < parts.length; i++) {
                var p = parts[i];
                var pdef = getFieldConfig$8(extendedConfig, parts.slice(0, i + 1)) || {};
                if (i != parts.length - 1) {
                  if (pdef.type == "!group" && pdef.mode != "struct") {
                    if (!tmp[p]) tmp[p] = [{}];
                    tmp = tmp[p][0];
                  } else {
                    if (!tmp[p]) tmp[p] = {};
                    tmp = tmp[p];
                  }
                } else {
                  if (!tmp[p]) tmp[p] = null; // can use def.type for sample values
                }
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return {
            errors: errors,
            logic: logic,
            data: data
          };
        };
        var formatItem$2 = function formatItem(item, config, meta) {
          var _not = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var isRoot = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          var parentField = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          if (!item) return undefined;
          var type = item.get("type");
          var properties = item.get("properties") || new Map$2();
          var isLocked = properties.get("isLocked");
          var lockedOp = config.settings.jsonLogic.lockedOp;
          var ret;
          if (type === "group" || type === "rule_group") {
            ret = formatGroup$2(item, config, meta, _not, isRoot, parentField);
          } else if (type === "rule") {
            ret = formatRule$2(item, config, meta, _not, parentField);
          } else if (type == "switch_group") {
            ret = formatSwitch(item, config, meta, _not);
          } else if (type == "case_group") {
            ret = formatCase(item, config, meta, _not, parentField);
          }
          if (isLocked && ret && lockedOp) {
            ret = _defineProperty$4({}, lockedOp, ret);
          }
          return ret;
        };
        var formatGroup$2 = function formatGroup(item, config, meta) {
          var _groupOperatorDef, _groupOperatorDef2, _groupOperatorDef3, _reversedGroupOpDef, _reversedGroupOpDef2, _getOneChildOrDescend;
          var _not = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var isRoot = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          var parentField = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          var type = item.get("type");
          var properties = item.get("properties") || new Map$2();
          var mode = properties.get("mode");
          var children = item.get("children1") || new List();
          var field = properties.get("field");
          var fieldDefinition = getFieldConfig$8(config, field);
          var conjunction = properties.get("conjunction");
          if (!conjunction) conjunction = defaultConjunction(config);
          var conjunctionDefinition = config.conjunctions[conjunction];
          var conj = conjunctionDefinition.jsonLogicConj || conjunction.toLowerCase();
          var origNot = !!properties.get("not");
          var isRuleGroup = type === "rule_group" && !isRoot;
          var isRuleGroupArray = isRuleGroup && mode != "struct";
          var groupField = isRuleGroupArray ? field : parentField;
          var groupOperator = properties.get("operator");
          var groupOperatorDef = groupOperator && getOperatorConfig$4(config, groupOperator, field) || null;
          var formattedValue = formatItemValue(config, properties, meta, groupOperator, parentField);
          var isGroup0 = isRuleGroup && (!groupOperator || ((_groupOperatorDef = groupOperatorDef) === null || _groupOperatorDef === void 0 ? void 0 : _groupOperatorDef.cardinality) == 0);
          var isRuleGroupWithChildren = isRuleGroup && (children === null || children === void 0 ? void 0 : children.size) > 0;
          isRuleGroup && !(children !== null && children !== void 0 && children.size);

          // rev
          var not = origNot;
          var filterNot = false;
          if (isRuleGroupWithChildren) {
            // for rule_group `not` there should be 2 NOTs: from properties (for children) and from parent group (_not)
            filterNot = origNot;
            not = _not;
          } else {
            if (_not) {
              not = !not;
            }
          }
          var revChildren = false;
          var reversedGroupOp = (_groupOperatorDef2 = groupOperatorDef) === null || _groupOperatorDef2 === void 0 ? void 0 : _groupOperatorDef2.reversedOp;
          var reversedGroupOpDef = getOperatorConfig$4(config, reversedGroupOp, field);
          var groupOpNeedsReverse = !((_groupOperatorDef3 = groupOperatorDef) !== null && _groupOperatorDef3 !== void 0 && _groupOperatorDef3.jsonLogic) && !!((_reversedGroupOpDef = reversedGroupOpDef) !== null && _reversedGroupOpDef !== void 0 && _reversedGroupOpDef.jsonLogic);
          var groupOpCanReverse = !!((_reversedGroupOpDef2 = reversedGroupOpDef) !== null && _reversedGroupOpDef2 !== void 0 && _reversedGroupOpDef2.jsonLogic);
          var oneChildType = (_getOneChildOrDescend = getOneChildOrDescendant(item)) === null || _getOneChildOrDescend === void 0 ? void 0 : _getOneChildOrDescend.get("type");
          var canRevChildren = !!config.settings.reverseOperatorsForNot && (!isRuleGroup && not && oneChildType === "rule" || filterNot && (children === null || children === void 0 ? void 0 : children.size) === 1);
          if (canRevChildren) {
            if (isRuleGroupWithChildren) {
              filterNot = !filterNot;
            } else {
              not = !not;
            }
            revChildren = true;
          }
          var canRevGroupOp = not && isRuleGroup && groupOpCanReverse && (!!config.settings.reverseOperatorsForNot || groupOpNeedsReverse);
          if (canRevGroupOp) {
            not = !not;
            var _ref = [reversedGroupOp, groupOperator];
            groupOperator = _ref[0];
            reversedGroupOp = _ref[1];
            var _ref2 = [reversedGroupOpDef, groupOperatorDef];
            groupOperatorDef = _ref2[0];
            reversedGroupOpDef = _ref2[1];
          }
          var list = children.map(function (currentChild) {
            return formatItem$2(currentChild, config, meta, revChildren, false, groupField);
          }).filter(function (currentChild) {
            return typeof currentChild !== "undefined";
          });

          // allows for unnecessary (ie. empty or only one rule) groups to be exported
          var shouldPreserveGroups = !!config.settings.exportPreserveGroups;
          if (isRuleGroupArray && !isGroup0) {
            // "count" rule can have no "having" children, but should have number value
            if (formattedValue == undefined) return undefined;
          } else {
            if (!list.size && !shouldPreserveGroups) return undefined;
          }

          // I any of these conditions are true then we cannot remove group
          var preserveSingleRuleGroup = isRoot || shouldPreserveGroups || list.size != 1;

          // If preserveSingleRuleGroup is already true then there is no point to even check also if its not a negation group 
          // then this does not matter
          if (!preserveSingleRuleGroup && origNot && !revChildren) {
            // We check all children even thuogh there should be only one in case the formatting of one of them failed.
            // From config we see if exclamation is part of reverse operator definition and if so then we cannot ever remove a negation single 
            // rule group because then this combination would be identical to that reverse operator. see issue #1084
            preserveSingleRuleGroup = children.some(function (currentChild) {
              var _currentChild$get, _config$operators, _config$operators$rev, _config$operators2;
              var op = (_currentChild$get = currentChild.get("properties")) === null || _currentChild$get === void 0 ? void 0 : _currentChild$get.get("operator");
              var revOp = (_config$operators = config["operators"]) === null || _config$operators === void 0 || (_config$operators = _config$operators[op]) === null || _config$operators === void 0 ? void 0 : _config$operators.reversedOp;
              return (_config$operators$rev = (_config$operators2 = config.operators) === null || _config$operators2 === void 0 || (_config$operators2 = _config$operators2[revOp]) === null || _config$operators2 === void 0 ? void 0 : _config$operators2._jsonLogicIsExclamationOp) !== null && _config$operators$rev !== void 0 ? _config$operators$rev : false;
            });
          }
          var resultQuery = {};
          if (preserveSingleRuleGroup) resultQuery[conj] = list.toList().toJS();else resultQuery = list.first();

          // reverse filter
          if (filterNot) {
            resultQuery = {
              "!": resultQuery
            };
          }

          // rule_group (issue #246)
          if (isRuleGroupArray) {
            var formattedField = formatField$1(meta, config, field, parentField);
            if (isGroup0) {
              // config.settings.groupOperators
              var op = groupOperator || "some";
              resultQuery = _defineProperty$4({}, op, [formattedField, resultQuery]);
            } else {
              // there is rule for count
              var filter = !list.size ? formattedField : {
                "filter": [formattedField, resultQuery]
              };
              var count = {
                "reduce": [filter, {
                  "+": [1, {
                    "var": "accumulator"
                  }]
                }, 0]
              };
              resultQuery = formatLogic(config, properties, count, formattedValue, groupOperator, null, fieldDefinition);
            }
          }

          // reverse
          if (not) {
            resultQuery = {
              "!": resultQuery
            };
          }
          return resultQuery;
        };
        var formatRule$2 = function formatRule(item, config, meta) {
          var _operatorDefinition, _operatorDefinition2, _revOperatorDefinitio, _operatorDefinition3, _revOperatorDefinitio2, _revOperatorDefinitio3;
          var _not = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var properties = item.get("properties") || new Map$2();
          var field = properties.get("field");
          var fieldSrc = properties.get("fieldSrc");
          var operator = properties.get("operator");
          var operatorOptions = properties.get("operatorOptions");
          operatorOptions = operatorOptions ? operatorOptions.toJS() : null;
          if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;
          if (field == null || operator == null) return undefined;
          var fieldDefinition = getFieldConfig$8(config, field);
          var operatorDefinition = getOperatorConfig$4(config, operator, field);
          var reversedOp = (_operatorDefinition = operatorDefinition) === null || _operatorDefinition === void 0 ? void 0 : _operatorDefinition.reversedOp;
          var revOperatorDefinition = getOperatorConfig$4(config, reversedOp, field);

          // check op
          if (!((_operatorDefinition2 = operatorDefinition) !== null && _operatorDefinition2 !== void 0 && _operatorDefinition2.jsonLogic) && !((_revOperatorDefinitio = revOperatorDefinition) !== null && _revOperatorDefinitio !== void 0 && _revOperatorDefinitio.jsonLogic)) {
            meta.errors.push("Operator ".concat(operator, " is not supported"));
            return undefined;
          }

          // try reverse
          var not = _not;
          var opNeedsReverse = !((_operatorDefinition3 = operatorDefinition) !== null && _operatorDefinition3 !== void 0 && _operatorDefinition3.jsonLogic) && !!((_revOperatorDefinitio2 = revOperatorDefinition) !== null && _revOperatorDefinitio2 !== void 0 && _revOperatorDefinitio2.jsonLogic);
          var opCanReverse = !!((_revOperatorDefinitio3 = revOperatorDefinition) !== null && _revOperatorDefinitio3 !== void 0 && _revOperatorDefinitio3.jsonLogic);
          var canRev = opCanReverse && (!!config.settings.reverseOperatorsForNot || opNeedsReverse);
          var needRev = not && canRev || opNeedsReverse;
          if (needRev) {
            not = !not;
            var _ref3 = [reversedOp, operator];
            operator = _ref3[0];
            reversedOp = _ref3[1];
            var _ref4 = [revOperatorDefinition, operatorDefinition];
            operatorDefinition = _ref4[0];
            revOperatorDefinition = _ref4[1];
          }
          var formattedValue = formatItemValue(config, properties, meta, operator, parentField);
          if (formattedValue === undefined) return undefined;
          var formattedField = fieldSrc === "func" ? formatFunc$2(meta, config, field, parentField) : formatField$1(meta, config, field, parentField);
          if (formattedField === undefined) return undefined;
          return formatLogic(config, properties, formattedField, formattedValue, operator, operatorOptions, fieldDefinition, not);
        };
        var formatSwitch = function formatSwitch(item, config, meta) {
          var _not = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var children = item.get("children1");
          if (!children) return undefined;
          var cases = children.map(function (currentChild) {
            return formatCase(currentChild, config, meta, _not, null);
          }).filter(function (currentChild) {
            return typeof currentChild !== "undefined";
          }).valueSeq().toArray();
          var filteredCases = [];
          for (var i = 0; i < cases.length; i++) {
            if (i !== cases.length - 1 && !cases[i][0]) {
              meta.errors.push("No condition for case ".concat(i));
            } else {
              filteredCases.push(cases[i]);
              if (i === cases.length - 1 && cases[i][0]) {
                // no default - add null as default
                filteredCases.push([undefined, null]);
              }
            }
          }
          if (!filteredCases.length) return undefined;
          if (filteredCases.length === 1) {
            // only 1 case without condition
            var _filteredCases$ = _slicedToArray$1(filteredCases[0], 2);
            _filteredCases$[0];
            var _defVal = _filteredCases$[1];
            if (_defVal == undefined) _defVal = null;
            return _defVal;
          }
          var ret = {
            "if": []
          };
          var ifArgs = ret["if"];
          var _filteredCases = _slicedToArray$1(filteredCases[filteredCases.length - 1], 2);
          _filteredCases[0];
          var defVal = _filteredCases[1];
          for (var _i = 0; _i < filteredCases.length - 1; _i++) {
            var isLastIf = _i === filteredCases.length - 2;
            var _filteredCases$_i = _slicedToArray$1(filteredCases[_i], 2),
              cond = _filteredCases$_i[0],
              value = _filteredCases$_i[1];
            if (value == undefined) value = null;
            if (cond == undefined) cond = true;
            ifArgs.push(cond); // if
            ifArgs.push(value); // then
            if (isLastIf) {
              ifArgs.push(defVal); // else
            } else {
              // elif..
              ifArgs.push({
                "if": []
              });
              ifArgs = ifArgs[ifArgs.length - 1]["if"];
            }
          }
          return ret;
        };
        var formatCase = function formatCase(item, config, meta) {
          var _not = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var type = item.get("type");
          if (type != "case_group") {
            meta.errors.push("Unexpected child of type ".concat(type, " inside switch"));
            return undefined;
          }
          var properties = item.get("properties") || new Map$2();
          var cond = formatGroup$2(item, config, meta, _not, parentField);
          var formattedItem = formatItemValue(config, properties, meta, null, parentField, "!case_value");
          return [cond, formattedItem];
        };
        var formatItemValue = function formatItemValue(config, properties, meta, operator, parentField) {
          var expectedValueType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          var field = properties.get("field");
          var iValueSrc = properties.get("valueSrc");
          var iValueType = properties.get("valueType");
          if (expectedValueType == "!case_value" || iValueType && iValueType.get(0) == "case_value") {
            field = "!case_value";
          }
          var fieldDefinition = getFieldConfig$8(config, field);
          var operatorDefinition = getOperatorConfig$4(config, operator, field);
          var cardinality = getOpCardinality$1(operatorDefinition);
          var iValue = properties.get("value");
          var asyncListValues = properties.get("asyncListValues");
          if (iValue == undefined) return undefined;
          var oldUsedFields = meta.usedFields;
          var fvalue = iValue.map(function (currentValue, ind) {
            var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
            var valueType = iValueType ? iValueType.get(ind) : null;
            var cValue = completeValue(currentValue, valueSrc, config);
            var widget = getWidgetForFieldOp$3(config, field, operator, valueSrc);
            var fieldWidgetDef = getFieldWidgetConfig$3(config, field, operator, widget, valueSrc, {
              forExport: true
            });
            var fv = formatValue$2(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDefinition, operator, operatorDefinition, parentField, asyncListValues);
            return fv;
          });
          var hasUndefinedValues = fvalue.filter(function (v) {
            return v === undefined;
          }).size > 0;
          if (fvalue.size < cardinality || hasUndefinedValues) {
            meta.usedFields = oldUsedFields; // restore
            return undefined;
          }
          return cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;
        };
        var formatValue$2 = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {
          var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;
          var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;
          if (currentValue === undefined) return undefined;
          var ret;
          if (valueSrc == "field") {
            ret = formatField$1(meta, config, currentValue, parentField);
          } else if (valueSrc == "func") {
            ret = formatFunc$2(meta, config, currentValue, parentField);
          } else if (typeof (fieldWidgetDef === null || fieldWidgetDef === void 0 ? void 0 : fieldWidgetDef.jsonLogic) === "function") {
            var fn = fieldWidgetDef.jsonLogic;
            var args = [currentValue, _objectSpread$q(_objectSpread$q({}, fieldDef ? pick$1(fieldDef, ["fieldSettings", "listValues"]) : {}), {}, {
              asyncListValues: asyncListValues
            }),
            //useful options: valueFormat for date/time
            omit$2(fieldWidgetDef, widgetDefKeysToOmit)];
            if (operator) {
              args.push(operator);
              args.push(operatorDef);
            }
            ret = fn.call.apply(fn, [config.ctx].concat(args));
          } else {
            ret = currentValue;
          }
          return ret;
        };
        var formatFunc$2 = function formatFunc(meta, config, currentValue) {
          var _currentValue$get, _currentValue$get2;
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var funcKey = (_currentValue$get = currentValue.get) === null || _currentValue$get === void 0 ? void 0 : _currentValue$get.call(currentValue, "func");
          var args = (_currentValue$get2 = currentValue.get) === null || _currentValue$get2 === void 0 ? void 0 : _currentValue$get2.call(currentValue, "args");
          var funcConfig = getFuncConfig$2(config, funcKey);
          var funcParts = getFieldParts$3(funcKey, config);
          var funcLastKey = funcParts[funcParts.length - 1];
          if (!funcConfig) {
            meta.errors.push("Func ".concat(funcKey, " is not defined in config"));
            return undefined;
          }
          if (!(funcConfig !== null && funcConfig !== void 0 && funcConfig.jsonLogic)) {
            meta.errors.push("Func ".concat(funcKey, " is not supported"));
            return undefined;
          }
          var formattedArgs = {};
          var gaps = [];
          var missingArgKeys = [];
          for (var argKey in funcConfig.args) {
            var _argValue;
            var argConfig = funcConfig.args[argKey];
            var fieldDef = getFieldConfig$8(config, argConfig);
            var defaultValue = argConfig.defaultValue,
              isOptional = argConfig.isOptional;
            var defaultValueSrc = defaultValue !== null && defaultValue !== void 0 && defaultValue.func ? "func" : "value";
            var argVal = args ? args.get(argKey) : undefined;
            var argValue = argVal ? argVal.get("value") : undefined;
            var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
            if (argValueSrc !== "func" && (_argValue = argValue) !== null && _argValue !== void 0 && _argValue.toJS) {
              // value should not be Immutable
              argValue = argValue.toJS();
            }
            var operator = null;
            var widget = getWidgetForFieldOp$3(config, argConfig, operator, argValueSrc);
            var fieldWidgetDef = getFieldWidgetConfig$3(config, argConfig, operator, widget, argValueSrc, {
              forExport: true
            });
            var formattedArgVal = formatValue$2(meta, config, argValue, argValueSrc, argConfig.type, fieldWidgetDef, fieldDef, null, null, parentField);
            if (argValue != undefined && formattedArgVal === undefined) {
              if (argValueSrc != "func")
                // don't triger error if args value is another incomplete function
                meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
              return undefined;
            }
            var formattedDefaultVal = void 0;
            if (formattedArgVal === undefined && !isOptional && defaultValue != undefined) {
              var defaultWidget = getWidgetForFieldOp$3(config, argConfig, operator, defaultValueSrc);
              var defaultFieldWidgetDef = getFieldWidgetConfig$3(config, argConfig, operator, defaultWidget, defaultValueSrc, {
                forExport: true
              });
              formattedDefaultVal = formatValue$2(meta, config, defaultValue, defaultValueSrc, argConfig.type, defaultFieldWidgetDef, fieldDef, null, null, parentField);
              if (formattedDefaultVal === undefined) {
                if (defaultValueSrc != "func")
                  // don't triger error if args value is another incomplete function
                  meta.errors.push("Can't format default value of arg ".concat(argKey, " for func ").concat(funcKey));
                return undefined;
              }
            }
            var finalFormattedVal = formattedArgVal !== null && formattedArgVal !== void 0 ? formattedArgVal : formattedDefaultVal;
            if (finalFormattedVal !== undefined) {
              if (gaps.length) {
                var _iterator2 = _createForOfIteratorHelper$6(gaps),
                  _step2;
                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    var missedArgKey = _step2.value;
                    formattedArgs[missedArgKey] = undefined;
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }
                gaps = [];
              }
              formattedArgs[argKey] = finalFormattedVal;
            } else {
              if (!isOptional) missingArgKeys.push(argKey);
              gaps.push(argKey);
            }
          }
          if (missingArgKeys.length) {
            //meta.errors.push(`Missing vals for args ${missingArgKeys.join(", ")} for func ${funcKey}`);
            return undefined; // incomplete
          }
          var formattedArgsArr = Object.values(formattedArgs);
          var ret;
          if (typeof funcConfig.jsonLogic === "function") {
            var fn = funcConfig.jsonLogic;
            var _args = [formattedArgs];
            ret = fn.call.apply(fn, [config.ctx].concat(_args));
          } else {
            var funcName = funcConfig.jsonLogic || funcLastKey;
            var isMethod = !!funcConfig.jsonLogicIsMethod;
            if (isMethod) {
              var obj = formattedArgsArr[0],
                params = formattedArgsArr.slice(1);
              if (params.length) {
                ret = {
                  "method": [obj, funcName, params]
                };
              } else {
                ret = {
                  "method": [obj, funcName]
                };
              }
            } else {
              ret = _defineProperty$4({}, funcName, formattedArgsArr);
            }
          }
          return ret;
        };
        var formatField$1 = function formatField(meta, config, field) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var _config$settings = config.settings,
            fieldSeparator = _config$settings.fieldSeparator,
            jsonLogic = _config$settings.jsonLogic;
          var ret;
          if (field) {
            if (Array.isArray(field)) field = field.join(fieldSeparator);
            var fieldDef = getFieldConfig$8(config, field) || {};
            var fieldName = formatFieldName(field, config, meta, parentField);
            var varName = fieldDef.jsonLogicVar || (fieldDef.type == "!group" ? jsonLogic.groupVarKey : "var");
            ret = _defineProperty$4({}, varName, fieldName);
            if (meta.usedFields.indexOf(field) == -1) meta.usedFields.push(field);
          }
          return ret;
        };
        var buildFnToFormatOp$1 = function buildFnToFormatOp(operator, operatorDefinition, formattedField, formattedValue) {
          var formatteOp = operator;
          var cardinality = getOpCardinality$1(operatorDefinition);
          if (typeof operatorDefinition.jsonLogic == "string") formatteOp = operatorDefinition.jsonLogic;
          var rangeOps = ["<", "<=", ">", ">="];
          var eqOps = ["==", "!="];
          var fn = function fn(field, op, val, opDef, opOpts) {
            if (cardinality == 0 && eqOps.includes(formatteOp)) return _defineProperty$4({}, formatteOp, [formattedField, null]);else if (cardinality == 0) return _defineProperty$4({}, formatteOp, formattedField);else if (cardinality == 1) return _defineProperty$4({}, formatteOp, [formattedField, formattedValue]);else if (cardinality == 2 && rangeOps.includes(formatteOp)) return _defineProperty$4({}, formatteOp, [formattedValue[0], formattedField, formattedValue[1]]);else return _defineProperty$4({}, formatteOp, [formattedField].concat(_toConsumableArray(formattedValue)));
          };
          return fn;
        };
        var formatLogic = function formatLogic(config, properties, formattedField, formattedValue, operator) {
          var operatorOptions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          var fieldDefinition = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          var isRev = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
          var field = properties.get("field");
          //const fieldSrc = properties.get("fieldSrc");
          var operatorDefinition = getOperatorConfig$4(config, operator, field) || {};
          var fn = typeof operatorDefinition.jsonLogic == "function" ? operatorDefinition.jsonLogic : buildFnToFormatOp$1(operator, operatorDefinition, formattedField, formattedValue);
          var args = [formattedField, operator, formattedValue, omit$2(operatorDefinition, opDefKeysToOmit), operatorOptions, fieldDefinition];
          var ruleQuery = fn.call.apply(fn, [config.ctx].concat(args));
          if (isRev) {
            ruleQuery = {
              "!": ruleQuery
            };
          }
          return ruleQuery;
        };
        function _createForOfIteratorHelper$5(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$5(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
        }
        function _arrayLikeToArray$5(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function ownKeys$p(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$p(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$p(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$p(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }

        // helpers
        var isObject$4 = function isObject(v) {
          return _typeof$3(v) == "object" && v !== null && !Array.isArray(v);
        };
        var mongodbFormat = function mongodbFormat(tree, config) {
          return _mongodbFormat(tree, config, false);
        };
        var _mongodbFormat = function _mongodbFormat(tree, config) {
          var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          //meta is mutable
          var meta = {
            errors: []
          };
          var extendedConfig = extendConfig(config, undefined, false);
          var res = formatItem$1([], tree, extendedConfig, meta);
          if (returnErrors) {
            return [res, meta.errors];
          } else {
            if (meta.errors.length) console.warn("Errors while exporting to MongoDb:", meta.errors);
            return res;
          }
        };
        var formatItem$1 = function formatItem(parents, item, config, meta) {
          var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
          var _formatFieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;
          var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;
          if (!item) return undefined;
          var type = item.get("type");
          if (type === "group" || type === "rule_group") {
            return formatGroup$1(parents, item, config, meta, _not, _canWrapExpr, _formatFieldName, _value);
          } else if (type === "rule") {
            return formatRule$1(parents, item, config, meta, _not, _canWrapExpr, _formatFieldName, _value);
          }
          return undefined;
        };
        var formatGroup$1 = function formatGroup(parents, item, config, meta) {
          var _groupOperatorDef$car, _groupOperatorDef, _groupOperatorDef2, _groupOperatorDef3, _reversedGroupOpDef, _reversedGroupOpDef2, _getOneChildOrDescend, _conjunction;
          var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          var type = item.get("type");
          var properties = item.get("properties") || new Map$2();
          var origNot = !!properties.get("not");
          var children = item.get("children1") || new List();
          var _config$settings = config.settings,
            canShortMongoQuery = _config$settings.canShortMongoQuery,
            fieldSeparator = _config$settings.fieldSeparator;
          var sep = fieldSeparator;
          var hasParentRuleGroup = parents.filter(function (it) {
            return it.get("type") == "rule_group";
          }).length > 0;
          var parentPath = parents.filter(function (it) {
            return it.get("type") == "rule_group";
          }).map(function (it) {
            return it.get("properties").get("field");
          }).slice(-1).pop();
          var realParentPath = hasParentRuleGroup && parentPath;
          var isRuleGroup = type === "rule_group";
          var groupField = isRuleGroup ? properties.get("field") : null;
          var groupOperator = isRuleGroup ? properties.get("operator") : null;
          var groupOperatorDef = groupOperator && getOperatorConfig$4(config, groupOperator, groupField) || null;
          var groupOperatorCardinality = groupOperator ? (_groupOperatorDef$car = (_groupOperatorDef = groupOperatorDef) === null || _groupOperatorDef === void 0 ? void 0 : _groupOperatorDef.cardinality) !== null && _groupOperatorDef$car !== void 0 ? _groupOperatorDef$car : 1 : undefined;
          var groupFieldName = formatFieldName(groupField, config, meta, realParentPath);
          var groupFieldDef = getFieldConfig$8(config, groupField) || {};
          var mode = groupFieldDef.mode; //properties.get("mode");
          var canHaveEmptyChildren = groupField && mode === "array" && groupOperatorCardinality >= 1;
          var isRuleGroupWithChildren = isRuleGroup && (children === null || children === void 0 ? void 0 : children.size) > 0;
          isRuleGroup && !(children !== null && children !== void 0 && children.size);

          // rev
          var revChildren = false;
          var not = origNot;
          var filterNot = false;
          if (isRuleGroupWithChildren) {
            // for rule_group `not` there should be 2 NOTs: from properties (for children) and from parent group (_not)
            filterNot = origNot;
            not = _not;
          } else {
            if (_not) {
              not = !not;
            }
          }
          var reversedGroupOp = (_groupOperatorDef2 = groupOperatorDef) === null || _groupOperatorDef2 === void 0 ? void 0 : _groupOperatorDef2.reversedOp;
          var reversedGroupOpDef = getOperatorConfig$4(config, reversedGroupOp, groupField);
          var groupOpNeedsReverse = !((_groupOperatorDef3 = groupOperatorDef) !== null && _groupOperatorDef3 !== void 0 && _groupOperatorDef3.mongoFormatOp) && !!((_reversedGroupOpDef = reversedGroupOpDef) !== null && _reversedGroupOpDef !== void 0 && _reversedGroupOpDef.mongoFormatOp);
          var groupOpCanReverse = !!((_reversedGroupOpDef2 = reversedGroupOpDef) !== null && _reversedGroupOpDef2 !== void 0 && _reversedGroupOpDef2.mongoFormatOp);
          var oneChildType = (_getOneChildOrDescend = getOneChildOrDescendant(item)) === null || _getOneChildOrDescend === void 0 ? void 0 : _getOneChildOrDescend.get("type");
          var canRevChildren = !!config.settings.reverseOperatorsForNot && (!isRuleGroup && not && oneChildType === "rule" || filterNot && (children === null || children === void 0 ? void 0 : children.size) === 1);
          if (canRevChildren) {
            if (isRuleGroupWithChildren) {
              filterNot = !filterNot;
            } else {
              not = !not;
            }
            revChildren = true;
          }
          var canRevGroupOp = not && isRuleGroup && groupOpCanReverse && (!!config.settings.reverseOperatorsForNot || groupOpNeedsReverse);
          if (canRevGroupOp) {
            not = !not;
            var _ref = [reversedGroupOp, groupOperator];
            groupOperator = _ref[0];
            reversedGroupOp = _ref[1];
            var _ref2 = [reversedGroupOpDef, groupOperatorDef];
            groupOperatorDef = _ref2[0];
            reversedGroupOpDef = _ref2[1];
          }

          // conj
          var conjunction = properties.get("conjunction");
          if (!conjunction) conjunction = defaultConjunction(config);
          var conjunctionDefinition = config.conjunctions[conjunction];
          if (!conjunctionDefinition) return undefined;
          // rev conj
          var reversedConj = conjunctionDefinition.reversedConj;
          var canRev = not && ((_conjunction = conjunction) === null || _conjunction === void 0 ? void 0 : _conjunction.toLowerCase()) === "or" && reversedConj && !isRuleGroup && !!config.settings.canShortMongoQuery && !!config.settings.reverseOperatorsForNot;
          if (canRev) {
            conjunction = reversedConj;
            conjunctionDefinition = config.conjunctions[conjunction];
            not = !not;
            revChildren = true;
          }
          var mongoConj = conjunctionDefinition.mongoConj;
          var list = children.map(function (currentChild) {
            return formatItem$1([].concat(_toConsumableArray(parents), [item]), currentChild, config, meta, revChildren, mode != "array", mode == "array" ? function (f) {
              return "$$el".concat(sep).concat(f);
            } : undefined);
          }).filter(function (formattedChild) {
            return typeof formattedChild !== "undefined";
          });
          if (!canHaveEmptyChildren && !list.size) {
            return undefined;
          }
          var resultQuery;
          if (list.size == 1) {
            resultQuery = list.first();
          } else if (list.size > 1) {
            var rules = list.toList().toJS();
            var canShort = canShortMongoQuery && mongoConj == "$and";
            if (canShort) {
              resultQuery = rules.reduce(function (acc, rule) {
                if (!acc) return undefined;
                for (var k in rule) {
                  if (k[0] == "$") {
                    acc = undefined;
                    break;
                  }
                  if (acc[k] == undefined) {
                    acc[k] = rule[k];
                  } else {
                    // https://github.com/ukrbublik/react-awesome-query-builder/issues/182
                    var prev = acc[k],
                      next = rule[k];
                    if (!isObject$4(prev)) {
                      prev = {
                        "$eq": prev
                      };
                    }
                    if (!isObject$4(next)) {
                      next = {
                        "$eq": next
                      };
                    }
                    var prevOp = Object.keys(prev)[0],
                      nextOp = Object.keys(next)[0];
                    if (prevOp == nextOp) {
                      acc = undefined;
                      break;
                    }
                    acc[k] = Object.assign({}, prev, next);
                  }
                }
                return acc;
              }, {});
            }
            if (!resultQuery) {
              // can't be shorten
              resultQuery = _defineProperty$4({}, mongoConj, rules);
            }
          }
          if (groupField) {
            if (mode == "array") {
              var totalQuery = {
                "$size": {
                  "$ifNull": ["$" + groupFieldName, []]
                }
              };
              var filterQuery = resultQuery ? {
                "$size": {
                  "$ifNull": [{
                    "$filter": {
                      input: "$" + groupFieldName,
                      as: "el",
                      cond: resultQuery
                    }
                  }, []]
                }
              } : totalQuery;
              resultQuery = formatItem$1(parents, item.set("type", "rule"), config, meta, filterNot, false, function (_f) {
                return filterQuery;
              }, totalQuery);
              resultQuery = {
                "$expr": resultQuery
              };
            } else {
              resultQuery = _defineProperty$4({}, groupFieldName, {
                "$elemMatch": resultQuery
              });
            }
          }
          if (not) {
            resultQuery = {
              "$not": resultQuery
            };
          }
          return resultQuery;
        };
        var formatRule$1 = function formatRule(parents, item, config, meta) {
          var _operatorDefinition, _operatorDefinition2, _revOperatorDefinitio, _operatorDefinition3, _revOperatorDefinitio2, _revOperatorDefinitio3, _operatorDefinition4;
          var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
          var _formatFieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;
          var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;
          var properties = item.get("properties") || new Map$2();
          var hasParentRuleGroup = parents.filter(function (it) {
            return it.get("type") == "rule_group";
          }).length > 0;
          var parentPath = parents.filter(function (it) {
            return it.get("type") == "rule_group";
          }).map(function (it) {
            return it.get("properties").get("field");
          }).slice(-1).pop();
          var realParentPath = hasParentRuleGroup && parentPath;
          var operator = properties.get("operator");
          var operatorOptions = properties.get("operatorOptions");
          var field = properties.get("field");
          var fieldSrc = properties.get("fieldSrc");
          var iValue = properties.get("value");
          var iValueSrc = properties.get("valueSrc");
          var iValueType = properties.get("valueType");
          var asyncListValues = properties.get("asyncListValues");
          if (field == null || operator == null || iValue === undefined) return undefined;
          var fieldDef = getFieldConfig$8(config, field);

          // check op
          var operatorDefinition = getOperatorConfig$4(config, operator, field);
          var reversedOp = (_operatorDefinition = operatorDefinition) === null || _operatorDefinition === void 0 ? void 0 : _operatorDefinition.reversedOp;
          var revOperatorDefinition = getOperatorConfig$4(config, reversedOp, field);
          var cardinality = getOpCardinality$1(operatorDefinition);
          if (!((_operatorDefinition2 = operatorDefinition) !== null && _operatorDefinition2 !== void 0 && _operatorDefinition2.mongoFormatOp) && !((_revOperatorDefinitio = revOperatorDefinition) !== null && _revOperatorDefinitio !== void 0 && _revOperatorDefinitio.mongoFormatOp)) {
            meta.errors.push("Operator ".concat(operator, " is not supported"));
            return undefined;
          }

          // try reverse
          var not = _not;
          var opNeedsReverse = !((_operatorDefinition3 = operatorDefinition) !== null && _operatorDefinition3 !== void 0 && _operatorDefinition3.mongoFormatOp) && !!((_revOperatorDefinitio2 = revOperatorDefinition) !== null && _revOperatorDefinitio2 !== void 0 && _revOperatorDefinitio2.mongoFormatOp);
          var opCanReverse = !!((_revOperatorDefinitio3 = revOperatorDefinition) !== null && _revOperatorDefinitio3 !== void 0 && _revOperatorDefinitio3.mongoFormatOp);
          var canRev = opCanReverse && (!!config.settings.reverseOperatorsForNot || opNeedsReverse);
          var needRev = canRev && not || opNeedsReverse;
          if (needRev) {
            var _ref3 = [reversedOp, operator];
            operator = _ref3[0];
            reversedOp = _ref3[1];
            var _ref4 = [revOperatorDefinition, operatorDefinition];
            operatorDefinition = _ref4[0];
            revOperatorDefinition = _ref4[1];
            not = !not;
          }
          var formattedField;
          var useExpr = false;
          if (fieldSrc == "func") {
            var _formatFunc = formatFunc$1(meta, config, field, realParentPath);
            var _formatFunc2 = _slicedToArray$1(_formatFunc, 2);
            formattedField = _formatFunc2[0];
            useExpr = _formatFunc2[1];
          } else {
            formattedField = formatFieldName(field, config, meta, realParentPath);
            if (_formatFieldName) {
              useExpr = true;
              formattedField = _formatFieldName(formattedField);
            }
          }
          if (formattedField == undefined) return undefined;

          //format value
          var valueSrcs = [];
          var valueTypes = [];
          var formattedValue;
          if (iValue != undefined) {
            var fvalue = iValue.map(function (currentValue, ind) {
              var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
              var valueType = iValueType ? iValueType.get(ind) : null;
              var cValue = completeValue(currentValue, valueSrc, config);
              var widget = getWidgetForFieldOp$3(config, field, operator, valueSrc);
              var fieldWidgetDef = getFieldWidgetConfig$3(config, field, operator, widget, valueSrc, {
                forExport: true
              });
              var _formatValue = formatValue$1(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, realParentPath, operator, operatorDefinition, asyncListValues),
                _formatValue2 = _slicedToArray$1(_formatValue, 2),
                fv = _formatValue2[0],
                fvUseExpr = _formatValue2[1];
              if (fv !== undefined) {
                useExpr = useExpr || fvUseExpr;
                valueSrcs.push(valueSrc);
                valueTypes.push(valueType);
              }
              return fv;
            });
            var hasUndefinedValues = fvalue.filter(function (v) {
              return v === undefined;
            }).size > 0;
            if (fvalue.size < cardinality || hasUndefinedValues) return undefined;
            formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;
          }
          var wrapExpr = useExpr && _canWrapExpr;

          //build rule
          var fn = (_operatorDefinition4 = operatorDefinition) === null || _operatorDefinition4 === void 0 ? void 0 : _operatorDefinition4.mongoFormatOp;
          var args = [formattedField, operator, _value !== undefined && formattedValue == null ? _value : formattedValue, useExpr, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], omit$2(operatorDefinition, opDefKeysToOmit), operatorOptions, fieldDef];
          var ruleQuery = fn.call.apply(fn, [config.ctx].concat(args));
          if (wrapExpr) {
            ruleQuery = {
              "$expr": ruleQuery
            };
          }
          if (not) {
            ruleQuery = {
              "$not": ruleQuery
            };
          }
          return ruleQuery;
        };
        var formatValue$1 = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, parentPath, operator, operatorDef, asyncListValues) {
          if (currentValue === undefined) return [undefined, false];
          var ret;
          var useExpr = false;
          if (valueSrc == "field") {
            var _formatRightField = formatRightField(meta, config, currentValue, parentPath);
            var _formatRightField2 = _slicedToArray$1(_formatRightField, 2);
            ret = _formatRightField2[0];
            useExpr = _formatRightField2[1];
          } else if (valueSrc == "func") {
            var _formatFunc3 = formatFunc$1(meta, config, currentValue, parentPath);
            var _formatFunc4 = _slicedToArray$1(_formatFunc3, 2);
            ret = _formatFunc4[0];
            useExpr = _formatFunc4[1];
          } else {
            if (typeof (fieldWidgetDef === null || fieldWidgetDef === void 0 ? void 0 : fieldWidgetDef.mongoFormatValue) === "function") {
              var fn = fieldWidgetDef.mongoFormatValue;
              var args = [currentValue, _objectSpread$p(_objectSpread$p({}, fieldDef ? pick$1(fieldDef, ["fieldSettings", "listValues"]) : {}), {}, {
                asyncListValues: asyncListValues
              }),
              //useful options: valueFormat for date/time
              omit$2(fieldWidgetDef, widgetDefKeysToOmit)];
              if (operator) {
                args.push(operator);
                args.push(operatorDef);
              }
              ret = fn.call.apply(fn, [config.ctx].concat(args));
            } else {
              ret = currentValue;
            }
          }
          return [ret, useExpr];
        };
        var formatRightField = function formatRightField(meta, config, rightField, parentPath) {
          var fieldSeparator = config.settings.fieldSeparator;
          var ret;
          var useExpr = true;
          if (rightField) {
            var rightFieldDefinition = getFieldConfig$8(config, rightField) || {};
            var fieldParts = getFieldParts$3(rightField, config);
            var fieldPartsLabels = getFieldPathLabels$2(rightField, config);
            var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;
            var formatFieldFn = config.settings.formatField;
            var rightFieldName = formatFieldName(rightField, config, meta, parentPath);
            var formattedField = formatFieldFn(rightFieldName, fieldParts, fieldFullLabel, rightFieldDefinition, config, false);
            ret = "$" + formattedField;
          }
          return [ret, useExpr];
        };
        var formatFunc$1 = function formatFunc(meta, config, currentValue, parentPath) {
          var _currentValue$get, _currentValue$get2;
          var useExpr = true;
          var ret;
          var funcKey = (_currentValue$get = currentValue.get) === null || _currentValue$get === void 0 ? void 0 : _currentValue$get.call(currentValue, "func");
          var args = (_currentValue$get2 = currentValue.get) === null || _currentValue$get2 === void 0 ? void 0 : _currentValue$get2.call(currentValue, "args");
          var funcConfig = getFuncConfig$2(config, funcKey);
          if (!funcConfig) {
            meta.errors.push("Func ".concat(funcKey, " is not defined in config"));
            return [undefined, false];
          }
          var funcParts = getFieldParts$3(funcKey, config);
          var funcLastKey = funcParts[funcParts.length - 1];
          var funcName = funcConfig.mongoFunc || funcLastKey;
          var mongoArgsAsObject = funcConfig.mongoArgsAsObject;
          var formattedArgs = {};
          var argsCnt = 0;
          var lastArg = undefined;
          var gaps = [];
          var missingArgKeys = [];
          for (var argKey in funcConfig.args) {
            var _argValue;
            argsCnt++;
            var argConfig = funcConfig.args[argKey];
            var fieldDef = getFieldConfig$8(config, argConfig);
            var defaultValue = argConfig.defaultValue,
              isOptional = argConfig.isOptional;
            var defaultValueSrc = defaultValue !== null && defaultValue !== void 0 && defaultValue.func ? "func" : "value";
            var argVal = args ? args.get(argKey) : undefined;
            var argValue = argVal ? argVal.get("value") : undefined;
            var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
            if (argValueSrc !== "func" && (_argValue = argValue) !== null && _argValue !== void 0 && _argValue.toJS) {
              // value should not be Immutable
              argValue = argValue.toJS();
            }
            var argAsyncListValues = argVal ? argVal.get("asyncListValues") : undefined;
            var operator = null;
            var widget = getWidgetForFieldOp$3(config, argConfig, operator, argValueSrc);
            var fieldWidgetDef = getFieldWidgetConfig$3(config, argConfig, operator, widget, argValueSrc, {
              forExport: true
            });
            var _formatValue3 = formatValue$1(meta, config, argValue, argValueSrc, argConfig.type, fieldWidgetDef, fieldDef, parentPath, null, null, argAsyncListValues),
              _formatValue4 = _slicedToArray$1(_formatValue3, 2),
              formattedArgVal = _formatValue4[0];
            _formatValue4[1];
            if (argValue != undefined && formattedArgVal === undefined) {
              if (argValueSrc != "func")
                // don't triger error if args value is another incomplete function
                meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
              return [undefined, false];
            }
            var formattedDefaultVal = void 0;
            if (formattedArgVal === undefined && !isOptional && defaultValue != undefined) {
              var defaultWidget = getWidgetForFieldOp$3(config, argConfig, operator, defaultValueSrc);
              var defaultFieldWidgetDef = getFieldWidgetConfig$3(config, argConfig, operator, defaultWidget, defaultValueSrc, {
                forExport: true
              });
              var _formatValue5 = formatValue$1(meta, config, defaultValue, defaultValueSrc, argConfig.type, defaultFieldWidgetDef, fieldDef, parentPath, null, null, argAsyncListValues);
              var _formatValue6 = _slicedToArray$1(_formatValue5, 2);
              formattedDefaultVal = _formatValue6[0];
              _formatValue6[1];
              if (formattedDefaultVal === undefined) {
                if (defaultValueSrc != "func")
                  // don't triger error if args value is another incomplete function
                  meta.errors.push("Can't format default value of arg ".concat(argKey, " for func ").concat(funcKey));
                return [undefined, false];
              }
            }
            var finalFormattedVal = formattedArgVal !== null && formattedArgVal !== void 0 ? formattedArgVal : formattedDefaultVal;
            if (finalFormattedVal !== undefined) {
              if (gaps.length) {
                var _iterator = _createForOfIteratorHelper$5(gaps),
                  _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var missedArgKey = _step.value;
                    formattedArgs[missedArgKey] = undefined;
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                gaps = [];
              }
              formattedArgs[argKey] = finalFormattedVal;
              lastArg = finalFormattedVal;
            } else {
              if (!isOptional) missingArgKeys.push(argKey);
              gaps.push(argKey);
            }
          }
          if (missingArgKeys.length) {
            //meta.errors.push(`Missing vals for args ${missingArgKeys.join(", ")} for func ${funcKey}`);
            return [undefined, false]; // incomplete
          }
          if (typeof funcConfig.mongoFormatFunc === "function") {
            var fn = funcConfig.mongoFormatFunc;
            var _args = [formattedArgs];
            ret = fn.call.apply(fn, [config.ctx].concat(_args));
          } else if (funcConfig.mongoFormatFunc === null) {
            meta.errors.push("Functon ".concat(funcName, " is not supported"));
            return [undefined, false];
          } else {
            if (mongoArgsAsObject) ret = _defineProperty$4({}, funcName, formattedArgs);else if (argsCnt == 1 && lastArg !== undefined) ret = _defineProperty$4({}, funcName, lastArg);else ret = _defineProperty$4({}, funcName, Object.values(formattedArgs));
          }
          return [ret, useExpr];
        };
        function _createForOfIteratorHelper$4(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$4(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
        }
        function _arrayLikeToArray$4(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function ownKeys$o(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$o(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$o(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$o(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        var sqlFormat = function sqlFormat(tree, config) {
          return _sqlFormat(tree, config, false);
        };
        var _sqlFormat = function _sqlFormat(tree, config) {
          var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          //meta is mutable
          var meta = {
            errors: []
          };
          var extendedConfig = extendConfig(config, undefined, false);
          var res = formatItem(tree, extendedConfig, meta);
          if (returnErrors) {
            return [res, meta.errors];
          } else {
            if (meta.errors.length) console.warn("Errors while exporting to SQL:", meta.errors);
            return res;
          }
        };
        var formatItem = function formatItem(item, config, meta) {
          if (!item) return undefined;
          var type = item.get("type");
          item.get("children1");
          if (type === "group" || type === "rule_group") {
            return formatGroup(item, config, meta);
          } else if (type === "rule") {
            return formatRule(item, config, meta);
          }
          return undefined;
        };
        var formatGroup = function formatGroup(item, config, meta) {
          var type = item.get("type");
          var properties = item.get("properties") || new Map$2();
          var children = item.get("children1") || new List();
          var isRuleGroup = type === "rule_group";
          var groupField = isRuleGroup ? properties.get("field") : null;
          var groupFieldDef = getFieldConfig$8(config, groupField) || {};
          var mode = groupFieldDef.mode;
          if (mode == "array") {
            meta.errors.push("Aggregation is not supported for ".concat(groupField));
          }
          var not = properties.get("not");
          var list = children.map(function (currentChild) {
            return formatItem(currentChild, config, meta);
          }).filter(function (currentChild) {
            return typeof currentChild !== "undefined";
          });
          if (!list.size) return undefined;
          var conjunction = properties.get("conjunction");
          if (!conjunction) conjunction = defaultConjunction(config);
          var conjunctionDefinition = config.conjunctions[conjunction];
          return conjunctionDefinition.sqlFormatConj.call(config.ctx, list, conjunction, not);
        };
        var buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition) {
          var sqlOp = operatorDefinition.sqlOp || operator;
          var cardinality = getOpCardinality$1(operatorDefinition);
          var fn;
          if (cardinality == 0) {
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              return "".concat(field, " ").concat(sqlOp);
            };
          } else if (cardinality == 1) {
            fn = function fn(field, op, value, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              return "".concat(field, " ").concat(sqlOp, " ").concat(value);
            };
          } else if (cardinality == 2) {
            // between
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              var _values$first, _values$get;
              var valFrom = values === null || values === void 0 || (_values$first = values.first) === null || _values$first === void 0 ? void 0 : _values$first.call(values);
              var valTo = values === null || values === void 0 || (_values$get = values.get) === null || _values$get === void 0 ? void 0 : _values$get.call(values, 1);
              return "".concat(field, " ").concat(sqlOp, " ").concat(valFrom, " AND ").concat(valTo);
            };
          }
          return fn;
        };
        var formatRule = function formatRule(item, config, meta) {
          var properties = item.get("properties") || new Map$2();
          var field = properties.get("field");
          var fieldSrc = properties.get("fieldSrc");
          var operator = properties.get("operator");
          var operatorOptions = properties.get("operatorOptions");
          var iValueSrc = properties.get("valueSrc");
          var iValueType = properties.get("valueType");
          var iValue = properties.get("value");
          var asyncListValues = properties.get("asyncListValues");
          if (field == null || operator == null) return undefined;
          var fieldDefinition = getFieldConfig$8(config, field) || {};
          var opDef = getOperatorConfig$4(config, operator, field) || {};
          var reversedOp = opDef.reversedOp;
          var revOpDef = getOperatorConfig$4(config, reversedOp, field) || {};
          var cardinality = getOpCardinality$1(opDef);

          // check op
          var isRev = false;
          var canFormatOp = opDef.sqlOp || opDef.sqlFormatOp;
          var canFormatRevOp = revOpDef.sqlOp || revOpDef.sqlFormatOp;
          if (!canFormatOp && !canFormatRevOp) {
            meta.errors.push("Operator ".concat(operator, " is not supported"));
            return undefined;
          }
          if (!canFormatOp && canFormatRevOp) {
            isRev = true;
            var _ref = [reversedOp, operator];
            operator = _ref[0];
            reversedOp = _ref[1];
            var _ref2 = [revOpDef, opDef];
            opDef = _ref2[0];
            revOpDef = _ref2[1];
          }

          //format value
          var valueSrcs = [];
          var valueTypes = [];
          var formattedValue;
          if (iValue != undefined) {
            var fvalue = iValue.map(function (currentValue, ind) {
              var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
              var valueType = iValueType ? iValueType.get(ind) : null;
              var cValue = completeValue(currentValue, valueSrc, config);
              var widget = getWidgetForFieldOp$3(config, field, operator, valueSrc);
              var fieldWidgetDefinition = getFieldWidgetConfig$3(config, field, operator, widget, valueSrc, {
                forExport: true
              });
              var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, opDef, asyncListValues);
              if (fv !== undefined) {
                valueSrcs.push(valueSrc);
                valueTypes.push(valueType);
              }
              return fv;
            });
            var hasUndefinedValues = fvalue.filter(function (v) {
              return v === undefined;
            }).size > 0;
            if (hasUndefinedValues || fvalue.size < cardinality) return undefined;
            formattedValue = cardinality == 1 ? fvalue.first() : fvalue;
          }

          //find fn to format expr
          var fn = opDef.sqlFormatOp || buildFnToFormatOp(operator, opDef);
          if (!fn) {
            meta.errors.push("Operator ".concat(operator, " is not supported"));
            return undefined;
          }

          //format field
          var formattedField = fieldSrc == "func" ? formatFunc(meta, config, field) : formatField(meta, config, field);
          if (formattedField == undefined) return undefined;

          //format expr
          var args = [formattedField, operator, formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], omit$2(opDef, opDefKeysToOmit), operatorOptions, fieldDefinition];
          var ret;
          ret = fn.call.apply(fn, [config.ctx].concat(args));
          if (isRev) {
            ret = config.settings.sqlFormatReverse.call(config.ctx, ret);
          }
          if (ret === undefined) {
            meta.errors.push("Operator ".concat(operator, " is not supported for value source ").concat(valueSrcs.join(", ")));
            return undefined;
          }
          return ret;
        };
        var formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, asyncListValues) {
          if (currentValue === undefined) return undefined;
          var ret;
          if (valueSrc == "field") {
            ret = formatField(meta, config, currentValue);
          } else if (valueSrc == "func") {
            ret = formatFunc(meta, config, currentValue);
          } else {
            if (typeof (fieldWidgetDef === null || fieldWidgetDef === void 0 ? void 0 : fieldWidgetDef.sqlFormatValue) === "function") {
              var fn = fieldWidgetDef.sqlFormatValue;
              var args = [currentValue, _objectSpread$o(_objectSpread$o({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
                asyncListValues: asyncListValues
              }),
              //useful options: valueFormat for date/time
              omit$2(fieldWidgetDef, widgetDefKeysToOmit)];
              if (operator) {
                args.push(operator);
                args.push(operatorDef);
              }
              if (valueSrc == "field") {
                var valFieldDefinition = getFieldConfig$8(config, currentValue) || {};
                args.push(valFieldDefinition);
              }
              ret = fn.call.apply(fn, [config.ctx].concat(args));
            } else {
              if (Array.isArray(currentValue)) {
                ret = currentValue.map(function (v) {
                  return SqlString.escape(v);
                });
              } else {
                ret = SqlString.escape(currentValue);
              }
            }
          }
          return ret;
        };
        var formatField = function formatField(meta, config, field) {
          if (!field) return;
          var fieldSeparator = config.settings.fieldSeparator;
          var fieldDefinition = getFieldConfig$8(config, field) || {};
          var fieldParts = getFieldParts$3(field, config);
          var fieldPartsLabels = getFieldPathLabels$2(field, config);
          var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;
          var formatFieldFn = config.settings.formatField;
          var fieldName = formatFieldName(field, config, meta, null, {
            useTableName: true
          });
          var formattedField = formatFieldFn(fieldName, fieldParts, fieldFullLabel, fieldDefinition, config);
          return formattedField;
        };
        var formatFunc = function formatFunc(meta, config, currentValue) {
          var _currentValue$get, _currentValue$get2;
          var funcKey = (_currentValue$get = currentValue.get) === null || _currentValue$get === void 0 ? void 0 : _currentValue$get.call(currentValue, "func");
          var args = (_currentValue$get2 = currentValue.get) === null || _currentValue$get2 === void 0 ? void 0 : _currentValue$get2.call(currentValue, "args");
          var funcConfig = getFuncConfig$2(config, funcKey);
          if (!funcConfig) {
            meta.errors.push("Func ".concat(funcKey, " is not defined in config"));
            return undefined;
          }
          var funcParts = getFieldParts$3(funcKey, config);
          var funcLastKey = funcParts[funcParts.length - 1];
          var funcName = funcConfig.sqlFunc || funcLastKey;
          var formattedArgs = {};
          var gaps = [];
          var missingArgKeys = [];
          for (var argKey in funcConfig.args) {
            var _argValue;
            var argConfig = funcConfig.args[argKey];
            var fieldDef = getFieldConfig$8(config, argConfig);
            var defaultValue = argConfig.defaultValue,
              isOptional = argConfig.isOptional;
            var defaultValueSrc = defaultValue !== null && defaultValue !== void 0 && defaultValue.func ? "func" : "value";
            var argVal = args ? args.get(argKey) : undefined;
            var argValue = argVal ? argVal.get("value") : undefined;
            var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
            if (argValueSrc !== "func" && (_argValue = argValue) !== null && _argValue !== void 0 && _argValue.toJS) {
              // value should not be Immutable
              argValue = argValue.toJS();
            }
            var argAsyncListValues = argVal ? argVal.get("asyncListValues") : undefined;
            var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, argAsyncListValues);
            if (argValue != undefined && formattedArgVal === undefined) {
              if (argValueSrc != "func")
                // don't triger error if args value is another incomplete function
                meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
              return undefined;
            }
            var formattedDefaultVal = void 0;
            if (formattedArgVal === undefined && !isOptional && defaultValue != undefined) {
              formattedDefaultVal = formatValue(meta, config, defaultValue, defaultValueSrc, argConfig.type, fieldDef, argConfig, null, null, argAsyncListValues);
              if (formattedDefaultVal === undefined) {
                if (defaultValueSrc != "func")
                  // don't triger error if args value is another incomplete function
                  meta.errors.push("Can't format default value of arg ".concat(argKey, " for func ").concat(funcKey));
                return undefined;
              }
            }
            var finalFormattedVal = formattedArgVal !== null && formattedArgVal !== void 0 ? formattedArgVal : formattedDefaultVal;
            if (finalFormattedVal !== undefined) {
              if (gaps.length) {
                var _iterator = _createForOfIteratorHelper$4(argKey),
                  _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var missedArgKey = _step.value;
                    formattedArgs[missedArgKey] = undefined;
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                gaps = [];
              }
              formattedArgs[argKey] = finalFormattedVal;
            } else {
              if (!isOptional) missingArgKeys.push(argKey);
              gaps.push(argKey);
            }
          }
          if (missingArgKeys.length) {
            //meta.errors.push(`Missing vals for args ${missingArgKeys.join(", ")} for func ${funcKey}`);
            return undefined; // incomplete
          }
          var ret;
          if (typeof funcConfig.sqlFormatFunc === "function") {
            var fn = funcConfig.sqlFormatFunc;
            var _args = [formattedArgs];
            ret = fn.call.apply(fn, [config.ctx].concat(_args));
          } else {
            var argsStr = Object.entries(formattedArgs).map(function (_ref3) {
              var _ref4 = _slicedToArray$1(_ref3, 2);
              _ref4[0];
              var v = _ref4[1];
              return v;
            }).join(", ");
            ret = "".concat(funcName, "(").concat(argsStr, ")");
          }
          return ret;
        };
        function ownKeys$n(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$n(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$n(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$n(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }

        /**
         * Converts a string representation of top_left and bottom_right cords to
         * a ES geo_point required for query
         *
         * @param {string} geoPointString - comma separated string of lat/lon coods
         * @returns {{top_left: {lon: number, lat: number}, bottom_right: {lon: number, lat: number}}} - ES geoPoint formatted object
         * @private
         */
        function buildEsGeoPoint(geoPointString) {
          if (geoPointString == null) {
            return null;
          }
          var coordsNumberArray = geoPointString.split(",").map(Number);
          return {
            top_left: {
              lat: coordsNumberArray[0],
              lon: coordsNumberArray[1]
            },
            bottom_right: {
              lat: coordsNumberArray[2],
              lon: coordsNumberArray[3]
            }
          };
        }

        /**
         * Converts a dateTime string from the query builder to a ES range formatted object
         *
         * @param {string} dateTime - dateTime formatted string
         * @param {string} operator - query builder operator type, see constants.js and query builder docs
         * @returns {{lt: string}|{lte: string}|{gte: string}|{gte: string, lte: string}|undefined} - ES range query parameter
         *
         * @private
         */
        function buildEsRangeParameters(value, operator) {
          // -- if value is greater than 1 then we assume this is a between operator : BUG this is wrong, a selectable list can have multiple values
          if (value.length > 1) {
            return {
              gte: "".concat(value[0]),
              lte: "".concat(value[1])
            };
          } // -- if value is only one we assume this is a date time query for a specific day

          var dateTime = value[0]; //TODO: Rethink about this part, what if someone adds a new type of opperator

          //todo: move this logic into config
          switch (operator) {
            case "on_date": //todo: not used
            case "not_on_date":
            case "equal":
            case "select_equals":
            case "not_equal":
              return {
                gte: "".concat(dateTime, "||/d"),
                lte: "".concat(dateTime, "||+1d")
              };
            case "less_or_equal":
              return {
                lte: "".concat(dateTime)
              };
            case "greater_or_equal":
              return {
                gte: "".concat(dateTime)
              };
            case "less":
              return {
                lt: "".concat(dateTime)
              };
            case "greater":
              return {
                gt: "".concat(dateTime)
              };
            default:
              return undefined;
          }
        }

        /**
         * Builds the DSL parameters for a Wildcard query
         *
         * @param {string} value - The match value
         * @returns {{value: string}} - The value = value parameter surrounded with * on each end
         * @private
         */
        function buildEsWildcardParameters(value) {
          return {
            value: "*" + value + "*"
          };
        }

        /**
         * Takes the match type string from awesome query builder like 'greater_or_equal' and
         * returns the ES occurrence required for bool queries
         *
         * @param {string} combinator - query group type or rule condition
         * @param {bool} not
         * @returns {string} - ES occurrence type. See constants.js
         * @private
         */
        function determineOccurrence(combinator, not) {
          //todo: move into config, like mongoConj
          switch (combinator) {
            case "AND":
              return not ? "must_not" : "must";
            // -- AND

            case "OR":
              return not ? "should_not" : "should";
            // -- OR

            case "NOT":
              return not ? "must" : "must_not";
            // -- NOT AND

            default:
              return undefined;
          }
        }

        /**
         * Determines what field to query off of given the operator type
         *
         * @param {string} fieldDataType - The type of data
         * @param {string} fullFieldName - A '.' separated string containing the property lineage (including self)
         * @param {string} queryType - The query type
         * @returns {string|*} - will be either the fullFieldName or fullFieldName.keyword
         * @private
         */
        //todo: not used
        // function determineQueryField(fieldDataType, fullFieldName, queryType) {
        //   if (fieldDataType === "boolean") {
        //     return fullFieldName;
        //   }

        //   switch (queryType) {
        //   case "term":
        //   case "wildcard":
        //     return "".concat(fullFieldName, ".keyword");

        //   case "geo_bounding_box":
        //   case "range":
        //   case "match":
        //     return fullFieldName;

        //   default:
        //     console.error("Can't determine query field for query type ".concat(queryType));
        //     return null;
        //   }
        // }

        function buildRegexpParameters(value) {
          return {
            value: value
          };
        }
        function determineField(fieldName, config) {
          //todo: ElasticSearchTextField - not used
          //return config.fields[fieldName].ElasticSearchTextField || fieldName;
          return fieldName;
        }
        function buildParameters(queryType, value, operator, fieldName, config, syntax) {
          var textField = determineField(fieldName);
          switch (queryType) {
            case "filter":
              //todo: elasticSearchScript - not used
              return {
                script: config.operators[operator].elasticSearchScript(fieldName, value)
              };
            case "exists":
              return {
                field: fieldName
              };
            case "match":
              return _defineProperty$4({}, textField, value[0]);
            case "term":
              return syntax === ES_7_SYNTAX ? _defineProperty$4({}, fieldName, {
                value: value[0]
              }) : _defineProperty$4({}, fieldName, value[0]);

            //todo: not used
            // need to add geo type into RAQB or remove this code
            case "geo_bounding_box":
              return _defineProperty$4({}, fieldName, buildEsGeoPoint(value[0]));
            case "range":
              return _defineProperty$4({}, fieldName, buildEsRangeParameters(value, operator));
            case "wildcard":
              return _defineProperty$4({}, fieldName, buildEsWildcardParameters(value[0]));
            case "regexp":
              return _defineProperty$4({}, fieldName, buildRegexpParameters(value[0]));
            default:
              return undefined;
          }
        }
        /**
         * Handles the building of the group portion of the DSL
         *
         * @param {string} fieldName - The name of the field you are building a rule for
         * @param {string} fieldDataType - The type of data this field holds
         * @param {string} value - The value of this rule
         * @param {string} operator - The condition on how the value is matched
         * @param {string} syntax - The version of ElasticSearch syntax to generate
         * @returns {object} - The ES rule
         * @private
         */
        function buildEsRule(fieldName, value, operator, config, valueSrc, syntax) {
          if (!fieldName || !operator || value == undefined) return undefined; // rule is not fully entered
          var op = operator;
          var opConfig = config.operators[op];
          if (!opConfig) return undefined; // unknown operator
          var _opConfig = opConfig,
            elasticSearchQueryType = _opConfig.elasticSearchQueryType;

          // not
          var not = false;
          if (!elasticSearchQueryType && opConfig.reversedOp) {
            not = true;
            op = opConfig.reversedOp;
            opConfig = config.operators[op];
            var _opConfig2 = opConfig;
            elasticSearchQueryType = _opConfig2.elasticSearchQueryType;
          }

          // handle if value 0 has multiple values like a select in a array
          var widget = getWidgetForFieldOp$3(config, fieldName, op, valueSrc);
          var widgetConfig = config.widgets[widget];
          if (!widgetConfig) return undefined; // unknown widget
          var elasticSearchFormatValue = widgetConfig.elasticSearchFormatValue;

          /** In most cases the queryType will be static however in some casese (like between) the query type will change
           * based on the data type. i.e. a between time will be different than between number, date, letters etc... */
          var queryType;
          if (typeof elasticSearchQueryType === "function") {
            queryType = elasticSearchQueryType(widget);
          } else {
            queryType = elasticSearchQueryType;
          }
          if (!queryType) {
            // Not supported
            return undefined;
          }

          /** If a widget has a rule on how to format that data then use that otherwise use default way of determineing search parameters
           * */
          var parameters;
          if (typeof elasticSearchFormatValue === "function") {
            parameters = elasticSearchFormatValue(queryType, value, op, fieldName, config);
          } else {
            parameters = buildParameters(queryType, value, op, fieldName, config, syntax);
          }
          if (not) {
            return {
              bool: {
                must_not: _defineProperty$4({}, queryType, _objectSpread$n({}, parameters))
              }
            };
          } else {
            return _defineProperty$4({}, queryType, _objectSpread$n({}, parameters));
          }
        }

        /**
         * Handles the building of the group portion of the DSL
         *
         * @param {object} children - The contents of the group
         * @param {string} conjunction - The way the contents of the group are joined together i.e. AND OR
         * @param {bool} not
         * @param {Function} recursiveFxn - The recursive fxn to build the contents of the groups children
         * @private
         * @returns {object} - The ES group
         */
        function buildEsGroup(children, conjunction, not, recursiveFxn, config, syntax) {
          if (!children || !children.size) return undefined;
          var childrenArray = children.valueSeq().toArray();
          var occurrence = determineOccurrence(conjunction, not);
          var result = childrenArray.map(function (c) {
            return recursiveFxn(c, config, syntax);
          }).filter(function (v) {
            return v !== undefined;
          });
          if (!result.length) return undefined;
          var resultFlat = result.flat(Infinity);
          return {
            bool: _defineProperty$4({}, occurrence, resultFlat)
          };
        }
        var ES_7_SYNTAX = "ES_7_SYNTAX";
        var ES_6_SYNTAX = "ES_6_SYNTAX";
        function elasticSearchFormat(tree, config) {
          var syntax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ES_6_SYNTAX;
          var extendedConfig = extendConfig(config, undefined, false);
          // -- format the es dsl here
          if (!tree) return undefined;
          var type = tree.get("type");
          var properties = tree.get("properties") || new Map();
          if (type === "rule" && properties.get("field")) {
            var _properties$get, _properties$get2, _properties$get3;
            // -- field is null when a new blank rule is added
            var operator = properties.get("operator");
            var field = properties.get("field");
            var fieldSrc = properties.get("fieldSrc");
            var value = (_properties$get = properties.get("value")) === null || _properties$get === void 0 ? void 0 : _properties$get.toJS();
            (_properties$get2 = properties.get("valueType")) === null || _properties$get2 === void 0 ? void 0 : _properties$get2.get(0);
            var valueSrc = (_properties$get3 = properties.get("valueSrc")) === null || _properties$get3 === void 0 ? void 0 : _properties$get3.get(0);
            if (valueSrc === "func" || fieldSrc == "func") {
              // -- elastic search doesn't support functions (that is post processing)
              return;
            }
            if (value && Array.isArray(value[0])) {
              //TODO : Handle case where the value has multiple values such as in the case of a list
              return value[0].map(function (val) {
                return buildEsRule(field, [val], operator, extendedConfig, valueSrc, syntax);
              });
            } else {
              return buildEsRule(field, value, operator, extendedConfig, valueSrc, syntax);
            }
          }
          if (type === "group" || type === "rule_group") {
            var not = properties.get("not");
            var conjunction = properties.get("conjunction");
            if (!conjunction) conjunction = defaultConjunction(extendedConfig);
            var children = tree.get("children1");
            return buildEsGroup(children, conjunction, not, elasticSearchFormat, extendedConfig, syntax);
          }
        }
        const Export = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          _mongodbFormat,
          _spelFormat,
          _sqlFormat,
          elasticSearchFormat,
          jsonLogicFormat,
          mongodbFormat,
          queryBuilderFormat,
          queryString,
          spelFormat,
          sqlFormat
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function asyncGeneratorStep(n, t, e, r, o, a, c) {
          try {
            var i = n[a](c),
              u = i.value;
          } catch (n) {
            return void e(n);
          }
          i.done ? t(u) : Promise.resolve(u).then(r, o);
        }
        function _asyncToGenerator(n) {
          return function () {
            var t = this,
              e = arguments;
            return new Promise(function (r, o) {
              var a = n.apply(t, e);
              function _next(n) {
                asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
              }
              function _throw(n) {
                asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
              }
              _next(void 0);
            });
          };
        }
        var _excluded$9 = ["title", "value", "disabled", "groupTitle", "grouplabel", "renderTitle", "children", "label", "isCustom", "isHidden"];
        function _createForOfIteratorHelper$3(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$3(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
        }
        function _arrayLikeToArray$3(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function ownKeys$m(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$m(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$m(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$m(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }

        // simple polyfill for Next
        var findLastIndex = function findLastIndex(arr, fn) {
          if (arr.findLastIndex) {
            return arr.findLastIndex(fn);
          } else {
            var ind = _toConsumableArray(arr).reverse().findIndex(fn);
            return ind == -1 ? -1 : arr.length - 1 - ind;
          }
        };
        var simulateAsyncFetch = function simulateAsyncFetch(all) {
          var cPageSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
          return /*#__PURE__*/function () {
            var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(search, offset, meta) {
              var pageSize, filtered, currentOffset, values, newOffset, hasMore;
              return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    pageSize = (meta === null || meta === void 0 ? void 0 : meta.pageSize) != undefined ? meta.pageSize : cPageSize;
                    filtered = listValuesToArray$1(all).filter(function (_ref2) {
                      var title = _ref2.title,
                        value = _ref2.value;
                      return search == null ? true : title.toUpperCase().indexOf(search.toUpperCase()) != -1 || "".concat(value).toUpperCase().indexOf(search.toUpperCase()) != -1;
                    });
                    pageSize ? Math.ceil(filtered.length / pageSize) : 0;
                    currentOffset = offset || 0;
                    values = pageSize ? filtered.slice(currentOffset, currentOffset + pageSize) : filtered;
                    newOffset = pageSize ? currentOffset + values.length : null;
                    hasMore = pageSize ? newOffset < filtered.length : false;
                    if (!delay) {
                      _context.next = 11;
                      break;
                    }
                    _context.next = 11;
                    return sleep$1(delay);
                  case 11:
                    return _context.abrupt("return", {
                      values: values,
                      hasMore: hasMore
                    });
                  case 12:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function (_x, _x2, _x3) {
              return _ref.apply(this, arguments);
            };
          }();
        };
        var mergeListValues$1 = function mergeListValues(values, newValues) {
          var toStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var hideNewValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          if (!newValues) return values;
          var old = values || [];
          var newFiltered = newValues.filter(function (v) {
            return old.find(function (av) {
              return "" + av.value == "" + v.value;
            }) == undefined;
          }).map(function (v) {
            return hideNewValues ? _objectSpread$m(_objectSpread$m({}, v), {}, {
              isHidden: true
            }) : v;
          });
          var merged = toStart ? [].concat(_toConsumableArray(newFiltered), _toConsumableArray(old)) : [].concat(_toConsumableArray(old), _toConsumableArray(newFiltered));
          return merged;
        };
        var optionToListValue$1 = function optionToListValue(val, listValues, allowCustomValues) {
          var _val$value;
          var v = val == null || val == "" ? undefined : (_val$value = val === null || val === void 0 ? void 0 : val.value) !== null && _val$value !== void 0 ? _val$value : val;
          var item = getListValue$1(v, listValues);
          var customItem = allowCustomValues && !item ? makeCustomListValue$1(v) : undefined;
          var listValue = item || customItem;
          var lvs = listValue ? [listValue] : undefined; //not allow []
          return [v, lvs];
        };
        var optionsToListValues$1 = function optionsToListValues(vals, listValues, allowCustomValues) {
          var newSelectedListValues = vals.map(function (val, _i) {
            var _val$value2;
            var v = val == null || val == "" ? undefined : (_val$value2 = val === null || val === void 0 ? void 0 : val.value) !== null && _val$value2 !== void 0 ? _val$value2 : val;
            var item = getListValue$1(v, listValues);
            var customItem = allowCustomValues && !item ? makeCustomListValue$1(v) : undefined;
            var listValue = item || customItem;
            return listValue;
          }).filter(function (o) {
            return o != undefined;
          });
          var newSelectedValues = newSelectedListValues.map(function (o) {
            var _o$value;
            return (_o$value = o === null || o === void 0 ? void 0 : o.value) !== null && _o$value !== void 0 ? _o$value : o;
          });
          if (!newSelectedValues.length) newSelectedValues = undefined; //not allow []
          return [newSelectedValues, newSelectedListValues];
        };
        var listValueToOption$1 = function listValueToOption(lv) {
          if (lv == null) return null;
          var title = lv.title,
            value = lv.value,
            disabled = lv.disabled,
            groupTitle = lv.groupTitle,
            grouplabel = lv.grouplabel,
            renderTitle = lv.renderTitle,
            children = lv.children,
            label = lv.label,
            isCustom = lv.isCustom,
            isHidden = lv.isHidden,
            rest = _objectWithoutProperties$2(lv, _excluded$9);
          var option = {
            value: value,
            title: title || label || children // fix issue #930 for AntD
          };
          if (disabled) option.disabled = disabled;
          if (isCustom) option.isCustom = isCustom;
          if (isHidden) option.isHidden = isHidden;
          // group
          if (groupTitle || grouplabel) option.groupTitle = groupTitle || grouplabel;
          // used only for MUI field autocomplete (if matchesType, render as bold)
          if (renderTitle) option.renderTitle = renderTitle;
          option = _objectSpread$m(_objectSpread$m({}, option), rest);
          return option;
        };
        var fixListValuesGroupOrder$1 = function fixListValuesGroupOrder(listValues) {
          var newValues = [];
          var groupTitles = [];
          var _iterator = _createForOfIteratorHelper$3(listValues),
            _step;
          try {
            var _loop = function _loop() {
              var lv = _step.value;
              var i = findLastIndex(newValues, function (lv1) {
                var _lv1$groupTitle, _lv$groupTitle;
                return ((_lv1$groupTitle = lv1.groupTitle) !== null && _lv1$groupTitle !== void 0 ? _lv1$groupTitle : "") == ((_lv$groupTitle = lv.groupTitle) !== null && _lv$groupTitle !== void 0 ? _lv$groupTitle : "");
              });
              if (lv.groupTitle != undefined && !groupTitles.includes(lv.groupTitle)) {
                groupTitles.push(lv.groupTitle);
                if (groupTitles.length === 1) {
                  // fix empty groupTitles
                  newValues = newValues.map(function (nv) {
                    return _objectSpread$m(_objectSpread$m({}, nv), {}, {
                      groupTitle: ""
                    });
                  });
                }
              }
              if (lv.groupTitle == undefined && groupTitles.length) {
                // fix empty groupTitle
                lv = _objectSpread$m(_objectSpread$m({}, lv), {}, {
                  groupTitle: ""
                });
              }
              if (i != -1) {
                newValues.splice(i + 1, 0, lv);
              } else {
                newValues.push(lv);
              }
            };
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return newValues;
        };
        const autocomplete = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          fixListValuesGroupOrder: fixListValuesGroupOrder$1,
          getListValue: getListValue$1,
          listValueToOption: listValueToOption$1,
          mergeListValues: mergeListValues$1,
          optionToListValue: optionToListValue$1,
          optionsToListValues: optionsToListValues$1,
          simulateAsyncFetch
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        const BasicUtils = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          Autocomplete: autocomplete,
          ConfigUtils: configUtils,
          DefaultUtils: defaultUtils,
          ExportUtils: _export,
          FuncUtils: funcUtils,
          ListUtils: listValues,
          OtherUtils: stuff,
          RuleUtils: ruleUtils,
          TreeUtils: treeUtils,
          Validation: validation,
          checkTree,
          clone: clone$3,
          compressConfig,
          decompressConfig,
          getSwitchValues,
          i18n,
          isValidTree,
          moment: hooks,
          sanitizeTree,
          uuid,
          validateAndFixTree: validateAndFixTree$1,
          validateTree
        }, Symbol.toStringTag, {
          value: 'Module'
        }));

        //import { customJsonLogicOperations } from "../utils/jsonLogic";

        // Tip: search for `customJsonLogicOperations` in codebase to see custom JL funcs we use in `jsonLogicCustomOps`

        var NOW = {
          label: "Now",
          returnType: "datetime",
          jsonLogic: "now",
          jsonLogicCustomOps: {
            now: {}
          },
          //spelFunc: "new java.util.Date()",
          spelFunc: "T(java.time.LocalDateTime).now()",
          sqlFormatFunc: function sqlFormatFunc() {
            return "NOW()";
          },
          mongoFormatFunc: function mongoFormatFunc() {
            return new Date();
          },
          formatFunc: function formatFunc() {
            return "NOW";
          }
        };
        var RELATIVE_DATETIME = {
          label: "Relative",
          returnType: "datetime",
          renderBrackets: ["", ""],
          renderSeps: ["", "", ""],
          spelFormatFunc: function spelFormatFunc(_ref) {
            var date = _ref.date,
              op = _ref.op,
              val = _ref.val,
              dim = _ref.dim;
            var dimPlural = dim.charAt(0).toUpperCase() + dim.slice(1) + "s";
            var method = op + dimPlural;
            return "".concat(date, ".").concat(method, "(").concat(val, ")");
          },
          spelImport: function spelImport(spel) {
            var _spel$methodName;
            var date, op, val, dim;
            var matchRes = (_spel$methodName = spel.methodName) === null || _spel$methodName === void 0 ? void 0 : _spel$methodName.match(/^(minus|plus)(\w+)s$/);
            if (matchRes) {
              dim = matchRes[2].toLowerCase();
              op = matchRes[1];
              if (["minus", "plus"].includes(op)) {
                if (["day", "week", "month", "year"].includes(dim)) {
                  op = {
                    type: "string",
                    val: op
                  };
                  dim = {
                    type: "string",
                    val: dim
                  };
                  val = spel.args[0];
                  date = spel.obj;
                  return {
                    date: date,
                    op: op,
                    val: val,
                    dim: dim
                  };
                }
              }
            }
          },
          jsonLogic: function jsonLogic(_ref2) {
            var date = _ref2.date,
              op = _ref2.op,
              val = _ref2.val,
              dim = _ref2.dim;
            return {
              "date_add": [date, val * (op == "minus" ? -1 : +1), dim]
            };
          },
          jsonLogicImport: function jsonLogicImport(v) {
            var date = v["date_add"][0];
            var val = Math.abs(v["date_add"][1]);
            var op = v["date_add"][1] >= 0 ? "plus" : "minus";
            var dim = v["date_add"][2];
            return [date, op, val, dim];
          },
          jsonLogicCustomOps: {
            date_add: {}
          },
          // MySQL
          //todo: other SQL dialects?
          sqlFormatFunc: function sqlFormatFunc(_ref3) {
            var date = _ref3.date,
              op = _ref3.op,
              val = _ref3.val,
              dim = _ref3.dim;
            return "DATE_ADD(".concat(date, ", INTERVAL ").concat(parseInt(val) * (op == "minus" ? -1 : +1), " ").concat(dim.replace(/^'|'$/g, ""), ")");
          },
          mongoFormatFunc: null,
          //todo: support?
          formatFunc: function formatFunc(_ref4) {
            var date = _ref4.date,
              op = _ref4.op,
              val = _ref4.val,
              dim = _ref4.dim;
            return !val ? date : "".concat(date, " ").concat(op == "minus" ? "-" : "+", " ").concat(val, " ").concat(dim);
          },
          args: {
            date: {
              label: "Date",
              type: "datetime",
              defaultValue: {
                func: "NOW",
                args: []
              },
              valueSources: ["func", "field", "value"],
              spelEscapeForFormat: true
            },
            op: {
              label: "Op",
              type: "select",
              defaultValue: "plus",
              valueSources: ["value"],
              mainWidgetProps: {
                customProps: {
                  showSearch: false
                }
              },
              fieldSettings: {
                listValues: {
                  plus: "+",
                  minus: "-"
                }
              },
              spelEscapeForFormat: false
            },
            val: {
              label: "Value",
              type: "number",
              fieldSettings: {
                min: 0
              },
              defaultValue: 0,
              valueSources: ["value"],
              spelEscapeForFormat: false
            },
            dim: {
              label: "Dimension",
              type: "select",
              defaultValue: "day",
              valueSources: ["value"],
              mainWidgetProps: {
                customProps: {
                  showSearch: false
                }
              },
              fieldSettings: {
                listValues: {
                  day: "day",
                  week: "week",
                  month: "month",
                  year: "year"
                }
              },
              spelEscapeForFormat: false
            }
          }
        };
        var LOWER = {
          label: "Lowercase",
          mongoFunc: "$toLower",
          jsonLogic: "toLowerCase",
          spelFunc: "${str}.toLowerCase()",
          //jsonLogicIsMethod: true, // Removed in JsonLogic 2.x due to Prototype Pollution
          jsonLogicCustomOps: {
            toLowerCase: {}
          },
          returnType: "text",
          args: {
            str: {
              label: "String",
              type: "text",
              valueSources: ["value", "field", "func"]
            }
          }
        };
        var UPPER = {
          label: "Uppercase",
          mongoFunc: "$toUpper",
          jsonLogic: "toUpperCase",
          spelFunc: "${str}.toUpperCase()",
          //jsonLogicIsMethod: true, // Removed in JsonLogic 2.x due to Prototype Pollution
          jsonLogicCustomOps: {
            toUpperCase: {}
          },
          returnType: "text",
          args: {
            str: {
              label: "String",
              type: "text",
              valueSources: ["value", "field", "func"]
            }
          }
        };
        var LINEAR_REGRESSION = {
          label: "Linear regression",
          returnType: "number",
          formatFunc: function formatFunc(_ref5, _) {
            var coef = _ref5.coef,
              bias = _ref5.bias,
              val = _ref5.val;
            return "(".concat(coef, " * ").concat(val, " + ").concat(bias, ")");
          },
          sqlFormatFunc: function sqlFormatFunc(_ref6) {
            var coef = _ref6.coef,
              bias = _ref6.bias,
              val = _ref6.val;
            return "(".concat(coef, " * ").concat(val, " + ").concat(bias, ")");
          },
          spelFormatFunc: function spelFormatFunc(_ref7) {
            var coef = _ref7.coef,
              bias = _ref7.bias,
              val = _ref7.val;
            return "(".concat(coef, " * ").concat(val, " + ").concat(bias, ")");
          },
          spelImport: function spelImport(spel) {
            var coef, val, bias, a;
            if (spel.type === "op-plus") {
              var _spel$children = _slicedToArray$1(spel.children, 2);
              a = _spel$children[0];
              bias = _spel$children[1];
              if (a.type === "op-multiply") {
                var _a$children = _slicedToArray$1(a.children, 2);
                coef = _a$children[0];
                val = _a$children[1];
                return {
                  coef: coef,
                  val: val,
                  bias: bias
                };
              }
            }
          },
          mongoFormatFunc: function mongoFormatFunc(_ref8) {
            var coef = _ref8.coef,
              bias = _ref8.bias,
              val = _ref8.val;
            return {
              "$sum": [{
                "$multiply": [coef, val]
              }, bias]
            };
          },
          jsonLogic: function jsonLogic(_ref9) {
            var coef = _ref9.coef,
              bias = _ref9.bias,
              val = _ref9.val;
            return {
              "+": [{
                "*": [coef, val]
              }, bias]
            };
          },
          jsonLogicImport: function jsonLogicImport(v) {
            var coef = v["+"][0]["*"][0];
            var val = v["+"][0]["*"][1];
            var bias = v["+"][1];
            return [coef, val, bias];
          },
          renderBrackets: ["", ""],
          renderSeps: [" * ", " + "],
          args: {
            coef: {
              label: "Coef",
              type: "number",
              defaultValue: 1,
              valueSources: ["value"]
            },
            val: {
              label: "Value",
              type: "number",
              valueSources: ["value", "field"]
            },
            bias: {
              label: "Bias",
              type: "number",
              defaultValue: 0,
              valueSources: ["value"]
            }
          }
        };

        // helpers for mongo format
        var mongoFormatOp1 = function mongoFormatOp1(mop, mc, not, field, _op, value, useExpr, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
          var $field = typeof field == "string" && !field.startsWith("$") ? "$" + field : field;
          var mv = mc(value, fieldDef);
          if (mv === undefined) return undefined;
          if (not) {
            if (!useExpr && (!mop || mop == "$eq")) return _defineProperty$4({}, field, {
              "$ne": mv
            }); // short form
            return !useExpr ? _defineProperty$4({}, field, {
              "$not": _defineProperty$4({}, mop, mv)
            }) : {
              "$not": _defineProperty$4({}, mop, [$field, mv])
            };
          } else {
            if (!useExpr && (!mop || mop == "$eq")) return _defineProperty$4({}, field, mv); // short form
            return !useExpr ? _defineProperty$4({}, field, _defineProperty$4({}, mop, mv)) : _defineProperty$4({}, mop, [$field, mv]);
          }
        };
        var mongoFormatOp2 = function mongoFormatOp2(mops, not, field, _op, values, useExpr, valueSrcs, valueTypes, opDef, operatorOptions, fieldDef) {
          var $field = typeof field == "string" && !field.startsWith("$") ? "$" + field : field;
          if (not) {
            return !useExpr ? _defineProperty$4({}, field, {
              "$not": _defineProperty$4(_defineProperty$4({}, mops[0], values[0]), mops[1], values[1])
            }) : {
              "$not": {
                "$and": [_defineProperty$4({}, mops[0], [$field, values[0]]), _defineProperty$4({}, mops[1], [$field, values[1]])]
              }
            };
          } else {
            return !useExpr ? _defineProperty$4({}, field, _defineProperty$4(_defineProperty$4({}, mops[0], values[0]), mops[1], values[1])) : {
              "$and": [_defineProperty$4({}, mops[0], [$field, values[0]]), _defineProperty$4({}, mops[1], [$field, values[1]])]
            };
          }
        };
        var ctx$2 = {
          utils: {
            SqlString: SqlString,
            moment: hooks,
            mongoFormatOp1: mongoFormatOp1,
            mongoFormatOp2: mongoFormatOp2,
            mongoEmptyValue: mongoEmptyValue,
            escapeRegExp: escapeRegExp,
            sqlEmptyValue: sqlEmptyValue,
            stringifyForDisplay: stringifyForDisplay,
            getTitleInListValues: getTitleInListValues$1,
            spelEscape: spelEscape,
            spelFixList: spelFixList,
            wrapWithBrackets: wrapWithBrackets
          }
        };
        function _createForOfIteratorHelper$2(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$2(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
        }
        function _arrayLikeToArray$2(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function ownKeys$l(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$l(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$l(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$l(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }

        //----------------------------  conjunctions

        var conjunctions$2 = {
          AND: {
            label: "And",
            mongoConj: "$and",
            jsonLogicConj: "and",
            sqlConj: "AND",
            spelConj: "and",
            spelConjs: ["and", "&&"],
            reversedConj: "OR",
            formatConj: function formatConj(children, conj, not, isForDisplay) {
              var ret = children.size > 1 ? children.join(" " + (isForDisplay ? "AND" : "&&") + " ") : children.first();
              if (children.size > 1 || not) {
                ret = this.utils.wrapWithBrackets(ret);
              }
              if (not) {
                ret = "NOT " + ret;
              }
              return ret;
            },
            sqlFormatConj: function sqlFormatConj(children, conj, not) {
              var ret = children.size > 1 ? children.join(" " + "AND" + " ") : children.first();
              if (children.size > 1 || not) {
                ret = this.utils.wrapWithBrackets(ret);
              }
              if (not) {
                ret = "NOT " + ret;
              }
              return ret;
            },
            spelFormatConj: function spelFormatConj(children, conj, not, omitBrackets) {
              if (not) omitBrackets = false;
              var ret = children.size > 1 ? children.join(" " + "&&" + " ") : children.first();
              if ((children.size > 1 || not) && !omitBrackets) {
                ret = this.utils.wrapWithBrackets(ret);
              }
              if (not) {
                ret = "!" + ret;
              }
              return ret;
            }
          },
          OR: {
            label: "Or",
            mongoConj: "$or",
            jsonLogicConj: "or",
            sqlConj: "OR",
            spelConj: "or",
            spelConjs: ["or", "||"],
            reversedConj: "AND",
            formatConj: function formatConj(children, conj, not, isForDisplay) {
              return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" " + (isForDisplay ? "OR" : "||") + " ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
            },
            sqlFormatConj: function sqlFormatConj(children, conj, not) {
              return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" " + "OR" + " ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
            },
            spelFormatConj: function spelFormatConj(children, conj, not, omitBrackets) {
              if (not) omitBrackets = false;
              return children.size > 1 ? (not ? "!" : "") + (omitBrackets ? "" : "(") + children.join(" " + "||" + " ") + (omitBrackets ? "" : ")") : (not ? "!(" : "") + children.first() + (not ? ")" : "");
            }
          }
        };

        //----------------------------  operators

        var operators$2 = {
          equal: {
            label: "==",
            labelForFormat: "==",
            sqlOp: "=",
            spelOp: "==",
            spelOps: ["==", "eq"],
            reversedOp: "not_equal",
            formatOp: function formatOp(field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) {
              var opStr = isForDisplay ? "=" : opDef.label;
              if (valueTypes == "boolean" && isForDisplay) return value == "No" ? "NOT ".concat(field) : "".concat(field);else return "".concat(field, " ").concat(opStr, " ").concat(value);
            },
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_this$utils = this.utils).mongoFormatOp1.apply(_this$utils, ["$eq", function (v) {
                return v;
              }, false].concat(args));
            },
            jsonLogic: "==",
            elasticSearchQueryType: "term"
          },
          not_equal: {
            isNotOp: true,
            label: "!=",
            labelForFormat: "!=",
            sqlOp: "<>",
            spelOp: "!=",
            spelOps: ["!=", "ne"],
            reversedOp: "equal",
            formatOp: function formatOp(field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) {
              if (valueTypes == "boolean" && isForDisplay) return value == "No" ? "".concat(field) : "NOT ".concat(field);else return "".concat(field, " ").concat(opDef.label, " ").concat(value);
            },
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils2;
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              return (_this$utils2 = this.utils).mongoFormatOp1.apply(_this$utils2, ["$ne", function (v) {
                return v;
              }, false].concat(args));
            },
            jsonLogic: "!="
          },
          less: {
            label: "<",
            labelForFormat: "<",
            sqlOp: "<",
            spelOp: "<",
            spelOps: ["<", "lt"],
            reversedOp: "greater_or_equal",
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils3;
              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
              }
              return (_this$utils3 = this.utils).mongoFormatOp1.apply(_this$utils3, ["$lt", function (v) {
                return v;
              }, false].concat(args));
            },
            jsonLogic: "<",
            elasticSearchQueryType: "range"
          },
          less_or_equal: {
            label: "<=",
            labelForFormat: "<=",
            sqlOp: "<=",
            spelOp: "<=",
            spelOps: ["<=", "le"],
            reversedOp: "greater",
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils4;
              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
              }
              return (_this$utils4 = this.utils).mongoFormatOp1.apply(_this$utils4, ["$lte", function (v) {
                return v;
              }, false].concat(args));
            },
            jsonLogic: "<=",
            elasticSearchQueryType: "range"
          },
          greater: {
            label: ">",
            labelForFormat: ">",
            sqlOp: ">",
            spelOp: ">",
            spelOps: [">", "gt"],
            reversedOp: "less_or_equal",
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils5;
              for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                args[_key5] = arguments[_key5];
              }
              return (_this$utils5 = this.utils).mongoFormatOp1.apply(_this$utils5, ["$gt", function (v) {
                return v;
              }, false].concat(args));
            },
            jsonLogic: ">",
            elasticSearchQueryType: "range"
          },
          greater_or_equal: {
            label: ">=",
            labelForFormat: ">=",
            sqlOp: ">=",
            spelOp: ">=",
            spelOps: [">=", "ge"],
            reversedOp: "less",
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils6;
              for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                args[_key6] = arguments[_key6];
              }
              return (_this$utils6 = this.utils).mongoFormatOp1.apply(_this$utils6, ["$gte", function (v) {
                return v;
              }, false].concat(args));
            },
            jsonLogic: ">=",
            elasticSearchQueryType: "range"
          },
          like: {
            label: "Contains",
            labelForFormat: "Contains",
            reversedOp: "not_like",
            sqlOp: "LIKE",
            spelOp: "${0}.contains(${1})",
            valueTypes: ["text"],
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils7,
                _this = this;
              for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
                args[_key7] = arguments[_key7];
              }
              return (_this$utils7 = this.utils).mongoFormatOp1.apply(_this$utils7, ["$regex", function (v) {
                return typeof v == "string" ? _this.utils.escapeRegExp(v) : undefined;
              }, false].concat(args));
            },
            jsonLogic: function jsonLogic(field, op, val) {
              return {
                "in": [val, field]
              };
            },
            jsonLogic2: "#in",
            valueSources: ["value"],
            elasticSearchQueryType: "regexp"
          },
          not_like: {
            isNotOp: true,
            label: "Not contains",
            reversedOp: "like",
            labelForFormat: "Not Contains",
            sqlOp: "NOT LIKE",
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils8,
                _this2 = this;
              for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
                args[_key8] = arguments[_key8];
              }
              return (_this$utils8 = this.utils).mongoFormatOp1.apply(_this$utils8, ["$regex", function (v) {
                return typeof v == "string" ? _this2.utils.escapeRegExp(v) : undefined;
              }, true].concat(args));
            },
            jsonLogic: function jsonLogic(field, op, val) {
              return {
                "!": {
                  "in": [val, field]
                }
              };
            },
            jsonLogic2: "#!in",
            _jsonLogicIsExclamationOp: true,
            valueSources: ["value"]
          },
          starts_with: {
            label: "Starts with",
            labelForFormat: "Starts with",
            sqlOp: "LIKE",
            spelOp: "${0}.startsWith(${1})",
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils9,
                _this3 = this;
              for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
                args[_key9] = arguments[_key9];
              }
              return (_this$utils9 = this.utils).mongoFormatOp1.apply(_this$utils9, ["$regex", function (v) {
                return typeof v == "string" ? "^" + _this3.utils.escapeRegExp(v) : undefined;
              }, false].concat(args));
            },
            jsonLogic: undefined,
            // not supported
            valueSources: ["value"]
          },
          ends_with: {
            label: "Ends with",
            labelForFormat: "Ends with",
            sqlOp: "LIKE",
            spelOp: "${0}.endsWith(${1})",
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils10,
                _this4 = this;
              for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
                args[_key10] = arguments[_key10];
              }
              return (_this$utils10 = this.utils).mongoFormatOp1.apply(_this$utils10, ["$regex", function (v) {
                return typeof v == "string" ? _this4.utils.escapeRegExp(v) + "$" : undefined;
              }, false].concat(args));
            },
            jsonLogic: undefined,
            // not supported
            valueSources: ["value"]
          },
          between: {
            label: "Between",
            labelForFormat: "BETWEEN",
            sqlOp: "BETWEEN",
            cardinality: 2,
            formatOp: function formatOp(field, op, values, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) {
              var valFrom = values.first();
              var valTo = values.get(1);
              if (isForDisplay) return "".concat(field, " BETWEEN ").concat(valFrom, " AND ").concat(valTo);else return "".concat(field, " >= ").concat(valFrom, " && ").concat(field, " <= ").concat(valTo);
            },
            spelFormatOp: function spelFormatOp(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
              var valFrom = values[0];
              var valTo = values[1];
              return "".concat(field, " >= ").concat(valFrom, " && ").concat(field, " <= ").concat(valTo);
            },
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils11;
              for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
                args[_key11] = arguments[_key11];
              }
              return (_this$utils11 = this.utils).mongoFormatOp2.apply(_this$utils11, [["$gte", "$lte"], false].concat(args));
            },
            valueLabels: ["Value from", "Value to"],
            textSeparators: [null, "and"],
            reversedOp: "not_between",
            jsonLogic: "<=",
            validateValues: function validateValues(values) {
              if (values[0] != undefined && values[1] != undefined) {
                return values[0] <= values[1];
              }
              return null;
            },
            elasticSearchQueryType: function elasticSearchQueryType(type) {
              return type === "time" ? "filter" : "range";
            }
          },
          not_between: {
            isNotOp: true,
            label: "Not between",
            labelForFormat: "NOT BETWEEN",
            sqlOp: "NOT BETWEEN",
            cardinality: 2,
            formatOp: function formatOp(field, op, values, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) {
              var valFrom = values.first();
              var valTo = values.get(1);
              if (isForDisplay) return "".concat(field, " NOT BETWEEN ").concat(valFrom, " AND ").concat(valTo);else return "(".concat(field, " < ").concat(valFrom, " || ").concat(field, " > ").concat(valTo, ")");
            },
            spelFormatOp: function spelFormatOp(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
              var valFrom = values[0];
              var valTo = values[1];
              return "(".concat(field, " < ").concat(valFrom, " || ").concat(field, " > ").concat(valTo, ")");
            },
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils12;
              for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
                args[_key12] = arguments[_key12];
              }
              return (_this$utils12 = this.utils).mongoFormatOp2.apply(_this$utils12, [["$gte", "$lte"], true].concat(args));
            },
            valueLabels: ["Value from", "Value to"],
            textSeparators: [null, "and"],
            reversedOp: "between",
            jsonLogic: function jsonLogic(field, op, val) {
              return {
                "!": {
                  "<=": [Array.isArray(val) ? val[0] : val, field, Array.isArray(val) ? val[1] : val]
                }
              };
            },
            jsonLogic2: "!<=",
            _jsonLogicIsExclamationOp: true,
            validateValues: function validateValues(values) {
              if (values[0] != undefined && values[1] != undefined) {
                return values[0] <= values[1];
              }
              return null;
            }
          },
          is_empty: {
            label: "Is empty",
            labelForFormat: "IS EMPTY",
            cardinality: 0,
            reversedOp: "is_not_empty",
            formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              return isForDisplay ? "".concat(field, " IS EMPTY") : "!".concat(field);
            },
            sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              var empty = this.utils.sqlEmptyValue(fieldDef);
              return "COALESCE(".concat(field, ", ").concat(empty, ") = ").concat(empty);
            },
            spelFormatOp: function spelFormatOp(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
              //tip: is empty or null
              return "".concat(field, " <= ''");
            },
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils13,
                _this5 = this;
              for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
                args[_key13] = arguments[_key13];
              }
              return (_this$utils13 = this.utils).mongoFormatOp1.apply(_this$utils13, ["$in", function (v, fieldDef) {
                return [_this5.utils.mongoEmptyValue(fieldDef), null];
              }, false].concat(args));
            },
            jsonLogic: "!"
          },
          is_not_empty: {
            isNotOp: true,
            label: "Is not empty",
            labelForFormat: "IS NOT EMPTY",
            cardinality: 0,
            reversedOp: "is_empty",
            formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              return isForDisplay ? "".concat(field, " IS NOT EMPTY") : "!!".concat(field);
            },
            sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              var empty = this.utils.sqlEmptyValue(fieldDef);
              return "COALESCE(".concat(field, ", ").concat(empty, ") <> ").concat(empty);
            },
            spelFormatOp: function spelFormatOp(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
              //tip: is not empty and not null
              return "".concat(field, " > ''");
            },
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils14,
                _this6 = this;
              for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
                args[_key14] = arguments[_key14];
              }
              return (_this$utils14 = this.utils).mongoFormatOp1.apply(_this$utils14, ["$nin", function (v, fieldDef) {
                return [_this6.utils.mongoEmptyValue(fieldDef), null];
              }, false].concat(args));
            },
            jsonLogic: "!!",
            elasticSearchQueryType: "exists"
          },
          is_null: {
            label: "Is null",
            labelForFormat: "IS NULL",
            sqlOp: "IS NULL",
            cardinality: 0,
            reversedOp: "is_not_null",
            formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              return isForDisplay ? "".concat(field, " IS NULL") : "!".concat(field);
            },
            spelFormatOp: function spelFormatOp(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
              return "".concat(field, " == null");
            },
            // check if value is null OR not exists
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils15;
              for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
                args[_key15] = arguments[_key15];
              }
              return (_this$utils15 = this.utils).mongoFormatOp1.apply(_this$utils15, ["$eq", function (v) {
                return null;
              }, false].concat(args));
            },
            jsonLogic: "=="
          },
          is_not_null: {
            label: "Is not null",
            labelForFormat: "IS NOT NULL",
            sqlOp: "IS NOT NULL",
            cardinality: 0,
            reversedOp: "is_null",
            formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              return isForDisplay ? "".concat(field, " IS NOT NULL") : "!!".concat(field);
            },
            spelFormatOp: function spelFormatOp(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
              return "".concat(field, " != null");
            },
            // check if value exists and is not null
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils16;
              for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
                args[_key16] = arguments[_key16];
              }
              return (_this$utils16 = this.utils).mongoFormatOp1.apply(_this$utils16, ["$ne", function (v) {
                return null;
              }, false].concat(args));
            },
            jsonLogic: "!=",
            elasticSearchQueryType: "exists"
          },
          select_equals: {
            label: "==",
            labelForFormat: "==",
            sqlOp: "=",
            // enum/set
            formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              var opStr = isForDisplay ? "=" : "==";
              return "".concat(field, " ").concat(opStr, " ").concat(value);
            },
            spelOp: "==",
            spelOps: ["==", "eq"],
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils17;
              for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
                args[_key17] = arguments[_key17];
              }
              return (_this$utils17 = this.utils).mongoFormatOp1.apply(_this$utils17, ["$eq", function (v) {
                return v;
              }, false].concat(args));
            },
            reversedOp: "select_not_equals",
            jsonLogic: "==",
            elasticSearchQueryType: "term"
          },
          select_not_equals: {
            isNotOp: true,
            label: "!=",
            labelForFormat: "!=",
            sqlOp: "<>",
            // enum/set
            formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              return "".concat(field, " != ").concat(value);
            },
            spelOp: "!=",
            spelOps: ["!=", "ne"],
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils18;
              for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
                args[_key18] = arguments[_key18];
              }
              return (_this$utils18 = this.utils).mongoFormatOp1.apply(_this$utils18, ["$ne", function (v) {
                return v;
              }, false].concat(args));
            },
            reversedOp: "select_equals",
            jsonLogic: "!="
          },
          select_any_in: {
            label: "Any in",
            labelForFormat: "IN",
            sqlOp: "IN",
            formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              if (valueSrc == "value") return "".concat(field, " IN (").concat(values.join(", "), ")");else return "".concat(field, " IN (").concat(values, ")");
            },
            sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              if (valueSrc == "value") {
                return "".concat(field, " IN (").concat(values.join(", "), ")");
              } else return undefined; // not supported
            },
            valueTypes: ["multiselect"],
            spelOp: "${1}.contains(${0})",
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils19;
              for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
                args[_key19] = arguments[_key19];
              }
              return (_this$utils19 = this.utils).mongoFormatOp1.apply(_this$utils19, ["$in", function (v) {
                return v;
              }, false].concat(args));
            },
            reversedOp: "select_not_any_in",
            jsonLogic: "in",
            elasticSearchQueryType: "term"
          },
          select_not_any_in: {
            isNotOp: true,
            label: "Not in",
            labelForFormat: "NOT IN",
            sqlOp: "NOT IN",
            formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              if (valueSrc == "value") return "".concat(field, " NOT IN (").concat(values.join(", "), ")");else return "".concat(field, " NOT IN (").concat(values, ")");
            },
            sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              if (valueSrc == "value") {
                return "".concat(field, " NOT IN (").concat(values.join(", "), ")");
              } else return undefined; // not supported
            },
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils20;
              for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
                args[_key20] = arguments[_key20];
              }
              return (_this$utils20 = this.utils).mongoFormatOp1.apply(_this$utils20, ["$nin", function (v) {
                return v;
              }, false].concat(args));
            },
            reversedOp: "select_any_in",
            jsonLogic: function jsonLogic(field, op, val) {
              return {
                "!": {
                  "in": [field, val]
                }
              };
            },
            jsonLogic2: "!in",
            _jsonLogicIsExclamationOp: true
          },
          // it's not "contains all", but "contains any" operator
          multiselect_contains: {
            label: "Contains",
            labelForFormat: "CONTAINS",
            formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              if (valueSrc == "value") return "".concat(field, " CONTAINS [").concat(values.join(", "), "]");else return "".concat(field, " CONTAINS ").concat(values);
            },
            reversedOp: "multiselect_not_contains",
            jsonLogic2: "some-in",
            jsonLogic: function jsonLogic(field, op, vals) {
              return {
                "some": [field, {
                  "in": [{
                    "var": ""
                  }, vals]
                }]
              };
            },
            //spelOp: "${0}.containsAll(${1})",
            spelOp: "T(CollectionUtils).containsAny(${0}, ${1})",
            elasticSearchQueryType: "term",
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils21;
              for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
                args[_key21] = arguments[_key21];
              }
              return (_this$utils21 = this.utils).mongoFormatOp1.apply(_this$utils21, ["$in", function (v) {
                return v;
              }, false].concat(args));
            }
          },
          multiselect_not_contains: {
            isNotOp: true,
            label: "Not contains",
            labelForFormat: "NOT CONTAINS",
            formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              if (valueSrc == "value") return "".concat(field, " NOT CONTAINS [").concat(values.join(", "), "]");else return "".concat(field, " NOT CONTAINS ").concat(values);
            },
            reversedOp: "multiselect_contains",
            jsonLogic2: "!some-in",
            jsonLogic: function jsonLogic(field, op, vals) {
              return {
                "!": {
                  "some": [field, {
                    "in": [{
                      "var": ""
                    }, vals]
                  }]
                }
              };
            },
            _jsonLogicIsExclamationOp: true
          },
          multiselect_equals: {
            label: "Equals",
            labelForFormat: "==",
            sqlOp: "=",
            formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              var opStr = isForDisplay ? "=" : "==";
              if (valueSrc == "value") return "".concat(field, " ").concat(opStr, " [").concat(values.join(", "), "]");else return "".concat(field, " ").concat(opStr, " ").concat(values);
            },
            sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              var _this7 = this;
              if (valueSrc == "value")
                // set
                return "".concat(field, " = '").concat(values.map(function (v) {
                  return _this7.utils.SqlString.trim(v);
                }).join(","), "'");else return undefined; //not supported
            },
            spelOp: "${0}.equals(${1})",
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils22;
              for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
                args[_key22] = arguments[_key22];
              }
              return (_this$utils22 = this.utils).mongoFormatOp1.apply(_this$utils22, ["$eq", function (v) {
                return v;
              }, false].concat(args));
            },
            reversedOp: "multiselect_not_equals",
            jsonLogic2: "all-in",
            jsonLogic: function jsonLogic(field, op, vals) {
              return {
                // it's not "equals", but "includes" operator - just for example
                "all": [field, {
                  "in": [{
                    "var": ""
                  }, vals]
                }]
              };
            },
            elasticSearchQueryType: "term"
          },
          multiselect_not_equals: {
            isNotOp: true,
            label: "Not equals",
            labelForFormat: "!=",
            sqlOp: "<>",
            formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              if (valueSrc == "value") return "".concat(field, " != [").concat(values.join(", "), "]");else return "".concat(field, " != ").concat(values);
            },
            sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              var _this8 = this;
              if (valueSrc == "value")
                // set
                return "".concat(field, " != '").concat(values.map(function (v) {
                  return _this8.utils.SqlString.trim(v);
                }).join(","), "'");else return undefined; //not supported
            },
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils23;
              for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
                args[_key23] = arguments[_key23];
              }
              return (_this$utils23 = this.utils).mongoFormatOp1.apply(_this$utils23, ["$ne", function (v) {
                return v;
              }, false].concat(args));
            },
            reversedOp: "multiselect_equals",
            jsonLogic2: "!all-in",
            jsonLogic: function jsonLogic(field, op, vals) {
              return {
                // it's not "equals", but "includes" operator - just for example
                "!": {
                  "all": [field, {
                    "in": [{
                      "var": ""
                    }, vals]
                  }]
                }
              };
            },
            _jsonLogicIsExclamationOp: true
          },
          proximity: {
            label: "Proximity search",
            cardinality: 2,
            valueLabels: [{
              label: "Word 1",
              placeholder: "Enter first word"
            }, {
              label: "Word 2",
              placeholder: "Enter second word"
            }],
            textSeparators: [
              //'Word 1',
              //'Word 2'
            ],
            formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              var val1 = values.first();
              var val2 = values.get(1);
              var prox = operatorOptions === null || operatorOptions === void 0 ? void 0 : operatorOptions.get("proximity");
              return "".concat(field, " ").concat(val1, " NEAR/").concat(prox, " ").concat(val2);
            },
            sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              // https://learn.microsoft.com/en-us/sql/relational-databases/search/search-for-words-close-to-another-word-with-near?view=sql-server-ver16#example-1
              var val1 = values.first();
              var val2 = values.get(1);
              var aVal1 = this.utils.SqlString.trim(val1);
              var aVal2 = this.utils.SqlString.trim(val2);
              var prox = operatorOptions === null || operatorOptions === void 0 ? void 0 : operatorOptions.get("proximity");
              return "CONTAINS(".concat(field, ", 'NEAR((").concat(aVal1, ", ").concat(aVal2, "), ").concat(prox, ")')");
            },
            mongoFormatOp: undefined,
            // not supported
            jsonLogic: undefined,
            // not supported
            options: {
              optionLabel: "Near",
              // label on top of "near" selectbox (for config.settings.showLabels==true)
              optionTextBefore: "Near",
              // label before "near" selectbox (for config.settings.showLabels==false)
              optionPlaceholder: "Select words between",
              // placeholder for "near" selectbox
              minProximity: 2,
              maxProximity: 10,
              defaults: {
                proximity: 2
              }
            }
          },
          some: {
            label: "Some",
            labelForFormat: "SOME",
            cardinality: 0,
            jsonLogic: "some",
            spelFormatOp: function spelFormatOp(filteredSize) {
              return "".concat(filteredSize, " > 0");
            },
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils24;
              for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {
                args[_key24] = arguments[_key24];
              }
              return (_this$utils24 = this.utils).mongoFormatOp1.apply(_this$utils24, ["$gt", function (v) {
                return 0;
              }, false].concat(args));
            }
            // reversedOp: undefined,
          },
          all: {
            label: "All",
            labelForFormat: "ALL",
            cardinality: 0,
            jsonLogic: "all",
            spelFormatOp: function spelFormatOp(filteredSize, op, fullSize) {
              return "".concat(filteredSize, " == ").concat(fullSize);
            },
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils25;
              for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {
                args[_key25] = arguments[_key25];
              }
              return (_this$utils25 = this.utils).mongoFormatOp1.apply(_this$utils25, ["$eq", function (v) {
                return v;
              }, false].concat(args));
            }
            // reversedOp: "none",
          },
          none: {
            label: "None",
            labelForFormat: "NONE",
            cardinality: 0,
            jsonLogic: "none",
            spelFormatOp: function spelFormatOp(filteredSize) {
              return "".concat(filteredSize, " == 0");
            },
            mongoFormatOp: function mongoFormatOp() {
              var _this$utils26;
              for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {
                args[_key26] = arguments[_key26];
              }
              return (_this$utils26 = this.utils).mongoFormatOp1.apply(_this$utils26, ["$eq", function (v) {
                return 0;
              }, false].concat(args));
            }
            // reversedOp: "all",
          }
        };

        //----------------------------  widgets

        var widgets$3 = {
          text: {
            type: "text",
            jsType: "string",
            valueSrc: "value",
            valueLabel: "String",
            valuePlaceholder: "Enter string",
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              return isForDisplay ? this.utils.stringifyForDisplay(val) : JSON.stringify(val);
            },
            spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef, op, opDef) {
              return this.utils.spelEscape(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              if (opDef.sqlOp == "LIKE" || opDef.sqlOp == "NOT LIKE") {
                return this.utils.SqlString.escapeLike(val, op != "starts_with", op != "ends_with");
              } else {
                return this.utils.SqlString.escape(val);
              }
            },
            toJS: function toJS(val, fieldSettings) {
              return val;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              return val;
            }
          },
          textarea: {
            type: "text",
            jsType: "string",
            valueSrc: "value",
            valueLabel: "Text",
            valuePlaceholder: "Enter text",
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              return isForDisplay ? this.utils.stringifyForDisplay(val) : JSON.stringify(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              if (opDef.sqlOp == "LIKE" || opDef.sqlOp == "NOT LIKE") {
                return this.utils.SqlString.escapeLike(val, op != "starts_with", op != "ends_with");
              } else {
                return this.utils.SqlString.escape(val);
              }
            },
            spelFormatValue: function spelFormatValue(val) {
              return this.utils.spelEscape(val);
            },
            toJS: function toJS(val, fieldSettings) {
              return val;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              return val;
            },
            fullWidth: true
          },
          number: {
            type: "number",
            jsType: "number",
            valueSrc: "value",
            valueLabel: "Number",
            valuePlaceholder: "Enter number",
            valueLabels: [{
              label: "Number from",
              placeholder: "Enter number from"
            }, {
              label: "Number to",
              placeholder: "Enter number to"
            }],
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              return isForDisplay ? this.utils.stringifyForDisplay(val) : JSON.stringify(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              return this.utils.SqlString.escape(val);
            },
            spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef) {
              var isFloat = wgtDef.step && !Number.isInteger(wgtDef.step);
              return this.utils.spelEscape(val, isFloat);
            },
            toJS: function toJS(val, fieldSettings) {
              return val;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              return val;
            }
          },
          slider: {
            type: "number",
            jsType: "number",
            valueSrc: "value",
            valueLabel: "Number",
            valuePlaceholder: "Enter number or move slider",
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              return isForDisplay ? this.utils.stringifyForDisplay(val) : JSON.stringify(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              return this.utils.SqlString.escape(val);
            },
            spelFormatValue: function spelFormatValue(val) {
              return this.utils.spelEscape(val);
            },
            toJS: function toJS(val, fieldSettings) {
              return val;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              return val;
            }
          },
          select: {
            type: "select",
            jsType: "string",
            valueSrc: "value",
            valueLabel: "Value",
            valuePlaceholder: "Select value",
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              var valLabel = this.utils.getTitleInListValues(fieldDef.fieldSettings.listValues || fieldDef.asyncListValues, val);
              return isForDisplay ? this.utils.stringifyForDisplay(valLabel) : JSON.stringify(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              return this.utils.SqlString.escape(val);
            },
            spelFormatValue: function spelFormatValue(val) {
              return this.utils.spelEscape(val);
            },
            toJS: function toJS(val, fieldSettings) {
              return val;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              return val;
            }
          },
          multiselect: {
            type: "multiselect",
            jsType: "array",
            valueSrc: "value",
            valueLabel: "Values",
            valuePlaceholder: "Select values",
            formatValue: function formatValue(vals, fieldDef, wgtDef, isForDisplay) {
              var _this9 = this;
              var valsLabels = vals.map(function (v) {
                return _this9.utils.getTitleInListValues(fieldDef.fieldSettings.listValues || fieldDef.asyncListValues, v);
              });
              return isForDisplay ? valsLabels.map(this.utils.stringifyForDisplay) : vals.map(JSON.stringify);
            },
            sqlFormatValue: function sqlFormatValue(vals, fieldDef, wgtDef, op, opDef) {
              var _this10 = this;
              return vals.map(function (v) {
                return _this10.utils.SqlString.escape(v);
              });
            },
            spelFormatValue: function spelFormatValue(vals, fieldDef, wgtDef, op, opDef) {
              var isCallable = opDef && opDef.spelOp && opDef.spelOp.startsWith("${1}");
              var res = this.utils.spelEscape(vals); // inline list
              if (isCallable) {
                // `{1,2}.contains(1)` NOT works
                // `{1,2}.?[true].contains(1)` works
                res = this.utils.spelFixList(res);
              }
              return res;
            },
            toJS: function toJS(val, fieldSettings) {
              return val;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              return val;
            }
          },
          date: {
            type: "date",
            jsType: "string",
            valueSrc: "value",
            dateFormat: "DD.MM.YYYY",
            valueFormat: "YYYY-MM-DD",
            valueLabel: "Date",
            valuePlaceholder: "Enter date",
            valueLabels: [{
              label: "Date from",
              placeholder: "Enter date from"
            }, {
              label: "Date to",
              placeholder: "Enter date to"
            }],
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              var dateVal = this.utils.moment(val, wgtDef.valueFormat);
              return isForDisplay ? dateVal.format(wgtDef.dateFormat) : JSON.stringify(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              var dateVal = this.utils.moment(val, wgtDef.valueFormat);
              return this.utils.SqlString.escape(dateVal.format("YYYY-MM-DD"));
            },
            spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef, op, opDef) {
              var dateVal = this.utils.moment(val, wgtDef.valueFormat);
              var v = dateVal.format("YYYY-MM-DD");
              var fmt = "yyyy-MM-dd";
              //return `new java.text.SimpleDateFormat('${fmt}').parse('${v}')`;
              return "T(java.time.LocalDate).parse('".concat(v, "', T(java.time.format.DateTimeFormatter).ofPattern('").concat(fmt, "'))");
            },
            spelImportFuncs: [
            //"new java.text.SimpleDateFormat(${fmt}).parse(${v})",
            {
              obj: {
                cls: ["java", "time", "LocalDate"]
              },
              methodName: "parse",
              args: [{
                "var": "v"
              }, {
                obj: {
                  cls: ["java", "time", "format", "DateTimeFormatter"]
                },
                methodName: "ofPattern",
                args: [{
                  "var": "fmt"
                }]
              }]
            }],
            spelImportValue: function spelImportValue(val, wgtDef, args) {
              var _args$fmt, _args$fmt$includes, _args$fmt2, _args$fmt2$toLowerCas;
              if (!wgtDef) return [undefined, "No widget def to get value format"];
              if (args !== null && args !== void 0 && (_args$fmt = args.fmt) !== null && _args$fmt !== void 0 && (_args$fmt = _args$fmt.value) !== null && _args$fmt !== void 0 && (_args$fmt$includes = _args$fmt.includes) !== null && _args$fmt$includes !== void 0 && _args$fmt$includes.call(_args$fmt, " ") || (_args$fmt2 = args.fmt) !== null && _args$fmt2 !== void 0 && (_args$fmt2 = _args$fmt2.value) !== null && _args$fmt2 !== void 0 && (_args$fmt2$toLowerCas = _args$fmt2.toLowerCase) !== null && _args$fmt2$toLowerCas !== void 0 && _args$fmt2$toLowerCas.call(_args$fmt2).includes("hh:mm")) return [undefined, "Invalid date format ".concat(JSON.stringify(args.fmt))];
              var dateVal = this.utils.moment(val.value, this.utils.moment.ISO_8601);
              if (dateVal.isValid()) {
                return [dateVal.format(wgtDef === null || wgtDef === void 0 ? void 0 : wgtDef.valueFormat), []];
              } else {
                return [undefined, "Invalid date"];
              }
            },
            jsonLogic: function jsonLogic(val, fieldDef, wgtDef) {
              return this.utils.moment(val, wgtDef.valueFormat).toDate();
            },
            toJS: function toJS(val, fieldSettings) {
              var dateVal = this.utils.moment(val, fieldSettings.valueFormat);
              return dateVal.isValid() ? dateVal.toDate() : undefined;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              var dateVal = this.utils.moment(val, wgtDef.valueFormat);
              return dateVal.isValid() ? dateVal.toDate() : undefined;
            }
          },
          time: {
            type: "time",
            jsType: "string",
            valueSrc: "value",
            timeFormat: "HH:mm",
            valueFormat: "HH:mm:ss",
            use12Hours: false,
            valueLabel: "Time",
            valuePlaceholder: "Enter time",
            valueLabels: [{
              label: "Time from",
              placeholder: "Enter time from"
            }, {
              label: "Time to",
              placeholder: "Enter time to"
            }],
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              var dateVal = this.utils.moment(val, wgtDef.valueFormat);
              return isForDisplay ? dateVal.format(wgtDef.timeFormat) : JSON.stringify(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              var dateVal = this.utils.moment(val, wgtDef.valueFormat);
              return this.utils.SqlString.escape(dateVal.format("HH:mm:ss"));
            },
            spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef, op, opDef) {
              var dateVal = this.utils.moment(val, wgtDef.valueFormat);
              var v = dateVal.format("HH:mm:ss");
              return "T(java.time.LocalTime).parse('".concat(v, "')");
              //return `new java.text.SimpleDateFormat('${fmt}').parse('${v}')`;
            },
            spelImportFuncs: ["T(java.time.LocalTime).parse(${v})"
            //"new java.text.SimpleDateFormat(${fmt}).parse(${v})"
            ],
            spelImportValue: function spelImportValue(val, wgtDef, args) {
              var _args$fmt3, _args$fmt3$toLowerCas, _args$fmt4;
              if (!wgtDef) return [undefined, "No widget def to get value format"];
              if (args !== null && args !== void 0 && args.fmt && (!((_args$fmt3 = args.fmt) !== null && _args$fmt3 !== void 0 && (_args$fmt3 = _args$fmt3.value) !== null && _args$fmt3 !== void 0 && (_args$fmt3$toLowerCas = _args$fmt3.toLowerCase) !== null && _args$fmt3$toLowerCas !== void 0 && _args$fmt3$toLowerCas.call(_args$fmt3).includes("hh:mm")) || (_args$fmt4 = args.fmt) !== null && _args$fmt4 !== void 0 && (_args$fmt4 = _args$fmt4.value) !== null && _args$fmt4 !== void 0 && _args$fmt4.includes(" "))) return [undefined, "Invalid time format ".concat(JSON.stringify(args.fmt))];
              var dateVal = this.utils.moment(val.value, "HH:mm:ss");
              if (dateVal.isValid()) {
                return [dateVal.format(wgtDef === null || wgtDef === void 0 ? void 0 : wgtDef.valueFormat), []];
              } else {
                return [undefined, "Invalid date"];
              }
            },
            jsonLogic: function jsonLogic(val, fieldDef, wgtDef) {
              // return seconds of day
              var dateVal = this.utils.moment(val, wgtDef.valueFormat);
              return dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second");
            },
            toJS: function toJS(val, fieldSettings) {
              // return seconds of day
              var dateVal = this.utils.moment(val, fieldSettings.valueFormat);
              return dateVal.isValid() ? dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second") : undefined;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              // return seconds of day
              var dateVal = this.utils.moment(val, wgtDef.valueFormat);
              return dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second");
            },
            elasticSearchFormatValue: function elasticSearchFormatValue(queryType, value, operator, fieldName) {
              return {
                script: {
                  script: {
                    source: "doc[".concat(fieldName, "][0].getHour() >== params.min && doc[").concat(fieldName, "][0].getHour() <== params.max"),
                    params: {
                      min: value[0],
                      max: value[1]
                    }
                  }
                }
              };
            }
          },
          datetime: {
            type: "datetime",
            jsType: "string",
            valueSrc: "value",
            timeFormat: "HH:mm",
            dateFormat: "DD.MM.YYYY",
            valueFormat: "YYYY-MM-DD HH:mm:ss",
            use12Hours: false,
            valueLabel: "Datetime",
            valuePlaceholder: "Enter datetime",
            valueLabels: [{
              label: "Datetime from",
              placeholder: "Enter datetime from"
            }, {
              label: "Datetime to",
              placeholder: "Enter datetime to"
            }],
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              var dateVal = this.utils.moment(val, wgtDef.valueFormat);
              return isForDisplay ? dateVal.format(wgtDef.dateFormat + " " + wgtDef.timeFormat) : JSON.stringify(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              var dateVal = this.utils.moment(val, wgtDef.valueFormat);
              return this.utils.SqlString.escape(dateVal.toDate());
            },
            spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef, op, opDef) {
              var dateVal = this.utils.moment(val, wgtDef.valueFormat);
              var v = dateVal.format("YYYY-MM-DD HH:mm:ss");
              var fmt = "yyyy-MM-dd HH:mm:ss";
              //return `new java.text.SimpleDateFormat('${fmt}').parse('${v}')`;
              return "T(java.time.LocalDateTime).parse('".concat(v, "', T(java.time.format.DateTimeFormatter).ofPattern('").concat(fmt, "'))");
            },
            spelImportFuncs: [
            //"new java.text.SimpleDateFormat(${fmt}).parse(${v})",
            {
              obj: {
                cls: ["java", "time", "LocalDateTime"]
              },
              methodName: "parse",
              args: [{
                "var": "v"
              }, {
                obj: {
                  cls: ["java", "time", "format", "DateTimeFormatter"]
                },
                methodName: "ofPattern",
                args: [{
                  "var": "fmt"
                }]
              }]
            }],
            spelImportValue: function spelImportValue(val, wgtDef, args) {
              var _args$fmt5, _args$fmt5$includes;
              if (!wgtDef) return [undefined, "No widget def to get value format"];
              if (!(args !== null && args !== void 0 && (_args$fmt5 = args.fmt) !== null && _args$fmt5 !== void 0 && (_args$fmt5 = _args$fmt5.value) !== null && _args$fmt5 !== void 0 && (_args$fmt5$includes = _args$fmt5.includes) !== null && _args$fmt5$includes !== void 0 && _args$fmt5$includes.call(_args$fmt5, " "))) return [undefined, "Invalid datetime format ".concat(JSON.stringify(args.fmt))];
              var dateVal = this.utils.moment(val.value, this.utils.moment.ISO_8601);
              if (dateVal.isValid()) {
                return [dateVal.format(wgtDef === null || wgtDef === void 0 ? void 0 : wgtDef.valueFormat), []];
              } else {
                return [undefined, "Invalid date"];
              }
            },
            jsonLogic: function jsonLogic(val, fieldDef, wgtDef) {
              return this.utils.moment(val, wgtDef.valueFormat).toDate();
            },
            toJS: function toJS(val, fieldSettings) {
              var dateVal = this.utils.moment(val, fieldSettings.valueFormat);
              return dateVal.isValid() ? dateVal.toDate() : undefined;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              var dateVal = this.utils.moment(val, wgtDef.valueFormat);
              return dateVal.isValid() ? dateVal.toDate() : undefined;
            }
          },
          "boolean": {
            type: "boolean",
            jsType: "boolean",
            valueSrc: "value",
            labelYes: "Yes",
            labelNo: "No",
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              return isForDisplay ? val ? "Yes" : "No" : JSON.stringify(!!val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              return this.utils.SqlString.escape(val);
            },
            spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef, op, opDef) {
              return this.utils.spelEscape(val);
            },
            defaultValue: false,
            toJS: function toJS(val, fieldSettings) {
              return val;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              return val;
            }
          },
          field: {
            valueSrc: "field",
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay, op, opDef, rightFieldDef) {
              return isForDisplay ? rightFieldDef.label || val : val;
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef, rightFieldDef) {
              return val;
            },
            spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef, op, opDef) {
              return val;
            },
            valueLabel: "Field to compare",
            valuePlaceholder: "Select field to compare"
          },
          func: {
            valueSrc: "func",
            valueLabel: "Function",
            valuePlaceholder: "Select function"
          },
          /**
           * @deprecated
           */
          case_value: {
            valueSrc: "value",
            type: "case_value",
            spelFormatValue: function spelFormatValue(val) {
              return this.utils.spelEscape(val === "" ? null : val);
            },
            spelImportValue: function spelImportValue(val) {
              return [val.value, []];
            },
            jsonLogic: function jsonLogic(val) {
              return val === "" ? null : val;
            }
          }
        };

        //----------------------------  types

        var types$4 = {
          text: {
            defaultOperator: "equal",
            mainWidget: "text",
            widgets: {
              text: {
                operators: ["equal", "not_equal", "like", "not_like", "starts_with", "ends_with", "proximity", "is_empty", "is_not_empty", "is_null", "is_not_null"],
                widgetProps: {},
                opProps: {}
              },
              textarea: {
                operators: ["equal", "not_equal", "like", "not_like", "starts_with", "ends_with", "is_empty", "is_not_empty", "is_null", "is_not_null"],
                widgetProps: {},
                opProps: {}
              },
              field: {
                operators: [
                //unary ops (like `is_empty`) will be excluded anyway, see getWidgetsForFieldOp()
                "equal", "not_equal", "proximity" //can exclude if you want
                ]
              }
            }
          },
          number: {
            defaultOperator: "equal",
            mainWidget: "number",
            widgets: {
              number: {
                operators: ["equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              },
              slider: {
                operators: ["equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              }
            }
          },
          date: {
            defaultOperator: "equal",
            widgets: {
              date: {
                operators: ["equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              }
            }
          },
          time: {
            defaultOperator: "equal",
            widgets: {
              time: {
                operators: ["equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              }
            }
          },
          datetime: {
            defaultOperator: "equal",
            widgets: {
              datetime: {
                operators: ["equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              }
            }
          },
          select: {
            mainWidget: "select",
            defaultOperator: "select_equals",
            widgets: {
              select: {
                operators: ["select_equals", "select_not_equals",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              },
              multiselect: {
                operators: ["select_any_in", "select_not_any_in",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              }
            }
          },
          multiselect: {
            defaultOperator: "multiselect_equals",
            widgets: {
              multiselect: {
                operators: ["multiselect_contains", "multiselect_not_contains", "multiselect_equals", "multiselect_not_equals",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              }
            }
          },
          "boolean": {
            defaultOperator: "equal",
            widgets: {
              "boolean": {
                operators: ["equal", "not_equal", "is_null", "is_not_null"],
                widgetProps: {
                  //you can enable this if you don't use fields as value sources
                  // hideOperator: true,
                  // operatorInlineLabel: "is",
                }
              },
              field: {
                operators: ["equal", "not_equal"]
              }
            }
          },
          "!group": {
            defaultOperator: "some",
            mainWidget: "number",
            widgets: {
              number: {
                widgetProps: {
                  min: 0
                },
                operators: [
                // w/o operand
                "some", "all", "none",
                // w/ operand - count
                "equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between"],
                opProps: {
                  equal: {
                    label: "Count =="
                  },
                  not_equal: {
                    label: "Count !="
                  },
                  less: {
                    label: "Count <"
                  },
                  less_or_equal: {
                    label: "Count <="
                  },
                  greater: {
                    label: "Count >"
                  },
                  greater_or_equal: {
                    label: "Count >="
                  },
                  between: {
                    label: "Count between"
                  },
                  not_between: {
                    label: "Count not between"
                  }
                }
              }
            }
          },
          /**
           * @deprecated
           */
          "case_value": {
            mainWidget: "case_value",
            widgets: {
              case_value: {
                widgetProps: {}
              }
            }
          }
        };

        //----------------------------  settings

        var settings$3 = _objectSpread$l(_objectSpread$l({}, settings$4), {}, {
          convertableWidgets: {
            "number": ["slider", "rangeslider"],
            "slider": ["number", "rangeslider"],
            "rangeslider": ["number", "slider"],
            "text": ["textarea"],
            "textarea": ["text"]
          },
          formatSpelField: function formatSpelField(field, parentField, parts, partsExt, fieldDefinition, config) {
            var _this11 = this;
            var fieldName = partsExt.map(function (_ref, ind) {
              var key = _ref.key,
                parent = _ref.parent,
                sep = _ref.fieldSeparator;
              if (ind == 0) {
                if (parent == "[map]") return "#this[".concat(_this11.utils.spelEscape(key), "]");else if (parent == "[class]") return key;else return key;
              } else {
                if (parent == "map" || parent == "[map]") return "[".concat(_this11.utils.spelEscape(key), "]");else if (parent == "class" || parent == "[class]") return "".concat(sep).concat(key);else return "".concat(sep).concat(key);
              }
            }).join("");
            if (fieldDefinition.fieldName) {
              fieldName = field;
            }
            if (fieldDefinition.isSpelVariable) {
              fieldName = "#" + fieldName;
            }
            return fieldName;
          },
          sqlFormatReverse: function sqlFormatReverse(q) {
            if (q == undefined) return undefined;
            return "NOT" + this.utils.wrapWithBrackets(q);
          },
          spelFormatReverse: function spelFormatReverse(q) {
            if (q == undefined) return undefined;
            return "!" + this.utils.wrapWithBrackets(q);
          },
          formatReverse: function formatReverse(q, operator, reversedOp, operatorDefinition, revOperatorDefinition, isForDisplay) {
            if (q == undefined) return undefined;
            if (isForDisplay) return "NOT " + this.utils.wrapWithBrackets(q);else return "!" + this.utils.wrapWithBrackets(q);
          },
          formatAggr: function formatAggr(whereStr, aggrField, operator, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay, aggrFieldDef) {
            var labelForFormat = opDef.labelForFormat,
              cardinality = opDef.cardinality;
            if (cardinality == 0) {
              var cond = whereStr ? " HAVE ".concat(whereStr) : "";
              return "".concat(labelForFormat, " OF ").concat(aggrField).concat(cond);
            } else if (cardinality == undefined || cardinality == 1) {
              var _cond = whereStr ? " WHERE ".concat(whereStr) : "";
              return "COUNT OF ".concat(aggrField).concat(_cond, " ").concat(labelForFormat, " ").concat(value);
            } else if (cardinality == 2) {
              var _cond2 = whereStr ? " WHERE ".concat(whereStr) : "";
              var valFrom = value.first();
              var valTo = value.get(1);
              return "COUNT OF ".concat(aggrField).concat(_cond2, " ").concat(labelForFormat, " ").concat(valFrom, " AND ").concat(valTo);
            }
          },
          jsonLogic: {
            groupVarKey: "var",
            altVarKey: "var",
            lockedOp: "locked"
          },
          canCompareFieldWithField: function canCompareFieldWithField(leftField, leftFieldConfig, rightField, rightFieldConfig) {
            //for type == 'select'/'multiselect' you can check listValues
            return true;
          },
          // enable compare fields
          valueSourcesInfo: {
            value: {
              label: "Value"
            },
            field: {
              label: "Field",
              widget: "field"
            },
            func: {
              label: "Function",
              widget: "func"
            }
          }
        });

        //----------------------------

        var _addMixins = function _addMixins(config, mixins) {
          var doAdd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          var mixinFuncs = {
            rangeslider: mixinWidgetRangeslider,
            treeselect: mixinWidgetTreeselect,
            treemultiselect: mixinWidgetTreemultiselect,
            rangeable__date: mixinRangeableWidget("date", "date")
          };
          var _iterator = _createForOfIteratorHelper$2(mixins),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var mixName = _step.value;
              var mixinFunc = mixinFuncs[mixName];
              if (mixinFunc) {
                config = mixinFunc(config, doAdd);
              } else {
                throw new Error("Can't ".concat(doAdd ? "add" : "remove", " mixin ").concat(mixName));
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return config;
        };
        var addMixins = function addMixins(config, mixins) {
          return _addMixins(config, mixins, true);
        };
        var removeMixins = function removeMixins(config, mixins) {
          return _addMixins(config, mixins, false);
        };
        var mixinRangeableWidget = function mixinRangeableWidget(type, widget) {
          return function (config) {
            var addMixin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var types = config.types;
            types = _objectSpread$l(_objectSpread$l({}, types), {}, _defineProperty$4({}, type, _objectSpread$l(_objectSpread$l({}, types[type]), {}, {
              widgets: _objectSpread$l({}, types[type].widgets)
            })));
            if (addMixin) {
              types[type].widgets[widget] = _objectSpread$l({
                opProps: {
                  between: {
                    isSpecialRange: true,
                    textSeparators: [null, null]
                  },
                  not_between: {
                    isSpecialRange: true,
                    textSeparators: [null, null]
                  }
                }
              }, types[type].widgets[widget]);
            } else {
              delete types[type].widgets[widget];
            }
            return _objectSpread$l(_objectSpread$l({}, config), {}, {
              types: types
            });
          };
        };
        var mixinWidgetRangeslider = function mixinWidgetRangeslider(config) {
          var addMixin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var widgets = config.widgets,
            types = config.types;
          widgets = _objectSpread$l({}, widgets);
          if (addMixin) {
            widgets.rangeslider = _objectSpread$l({
              type: "number",
              jsType: "number",
              valueSrc: "value",
              valueLabel: "Range",
              valuePlaceholder: "Select range",
              valueLabels: [{
                label: "Number from",
                placeholder: "Enter number from"
              }, {
                label: "Number to",
                placeholder: "Enter number to"
              }],
              formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
                return isForDisplay ? this.utils.stringifyForDisplay(val) : JSON.stringify(val);
              },
              sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
                return this.utils.SqlString.escape(val);
              },
              spelFormatValue: function spelFormatValue(val) {
                return this.utils.spelEscape(val);
              },
              singleWidget: "slider",
              toJS: function toJS(val, fieldSettings) {
                return val;
              }
            }, widgets.rangeslider);
          } else {
            delete widgets.rangeslider;
          }
          types = _objectSpread$l(_objectSpread$l({}, types), {}, {
            number: _objectSpread$l(_objectSpread$l({}, types.number), {}, {
              widgets: _objectSpread$l({}, types.number.widgets)
            })
          });
          if (addMixin) {
            types.number.widgets.rangeslider = _objectSpread$l({
              opProps: {
                between: {
                  isSpecialRange: true
                },
                not_between: {
                  isSpecialRange: true
                }
              },
              operators: ["between", "not_between",
              // "is_empty",
              // "is_not_empty",
              "is_null", "is_not_null"]
            }, types.number.widgets.rangeslider);
          } else {
            delete types.number.widgets.rangeslider;
          }
          return _objectSpread$l(_objectSpread$l({}, config), {}, {
            widgets: widgets,
            types: types
          });
        };
        var mixinWidgetTreeselect = function mixinWidgetTreeselect(config) {
          var addMixin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var widgets = config.widgets,
            types = config.types;
          widgets = _objectSpread$l({}, widgets);
          if (addMixin) {
            widgets.treeselect = _objectSpread$l({
              type: "treeselect",
              jsType: "string",
              valueSrc: "value",
              valueLabel: "Value",
              valuePlaceholder: "Select value",
              formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
                var treeData = fieldDef.fieldSettings.treeValues || fieldDef.fieldSettings.listValues || fieldDef.asyncListValues;
                var valLabel = this.utils.getTitleInListValues(treeData, val);
                return isForDisplay ? this.utils.stringifyForDisplay(valLabel) : JSON.stringify(val);
              },
              sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
                return this.utils.SqlString.escape(val);
              },
              spelFormatValue: function spelFormatValue(val) {
                return this.utils.spelEscape(val);
              },
              toJS: function toJS(val, fieldSettings) {
                return val;
              }
            }, widgets.treeselect);
          } else {
            delete widgets.treeselect;
          }
          types = _objectSpread$l({}, types);
          if (addMixin) {
            types.treeselect = _objectSpread$l({
              mainWidget: "treeselect",
              defaultOperator: "select_equals",
              widgets: {
                treeselect: {
                  operators: ["select_equals", "select_not_equals"]
                },
                treemultiselect: {
                  operators: ["select_any_in", "select_not_any_in"]
                }
              }
            }, types.treeselect);
          } else {
            delete types.treeselect;
          }
          return _objectSpread$l(_objectSpread$l({}, config), {}, {
            widgets: widgets,
            types: types
          });
        };
        var mixinWidgetTreemultiselect = function mixinWidgetTreemultiselect(config) {
          var addMixin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var widgets = config.widgets,
            types = config.types;
          widgets = _objectSpread$l({}, widgets);
          if (addMixin) {
            widgets.treemultiselect = _objectSpread$l({
              type: "treemultiselect",
              jsType: "array",
              valueSrc: "value",
              valueLabel: "Values",
              valuePlaceholder: "Select values",
              formatValue: function formatValue(vals, fieldDef, wgtDef, isForDisplay) {
                var _this12 = this;
                var treeData = fieldDef.fieldSettings.treeValues || fieldDef.fieldSettings.listValues || fieldDef.asyncListValues;
                var valsLabels = vals.map(function (v) {
                  return _this12.utils.getTitleInListValues(treeData, v);
                });
                return isForDisplay ? valsLabels.map(this.utils.stringifyForDisplay) : vals.map(JSON.stringify);
              },
              sqlFormatValue: function sqlFormatValue(vals, fieldDef, wgtDef, op, opDef) {
                var _this13 = this;
                return vals.map(function (v) {
                  return _this13.utils.SqlString.escape(v);
                });
              },
              spelFormatValue: function spelFormatValue(val) {
                return this.utils.spelEscape(val);
              },
              toJS: function toJS(val, fieldSettings) {
                return val;
              }
            }, widgets.treemultiselect);
          } else {
            delete widgets.treemultiselect;
          }
          types = _objectSpread$l({}, types);
          if (addMixin) {
            types.treemultiselect = _objectSpread$l({
              defaultOperator: "multiselect_equals",
              widgets: {
                treemultiselect: {
                  operators: ["multiselect_equals", "multiselect_not_equals"]
                }
              }
            }, types.treemultiselect);
          } else {
            delete types.treemultiselect;
          }
          return _objectSpread$l(_objectSpread$l({}, config), {}, {
            widgets: widgets,
            types: types
          });
        };
        var ConfigMixins = {
          addMixins: addMixins,
          removeMixins: removeMixins
        };

        //----------------------------

        var config$3 = {
          conjunctions: conjunctions$2,
          operators: operators$2,
          widgets: widgets$3,
          types: types$4,
          settings: settings$3,
          ctx: ctx$2
        };
        // Mixin advanced widgets just to allow using it on server-side eg. for export routines
        config$3 = addMixins(config$3, ["rangeslider", "treeselect", "treemultiselect"]);
        const CoreConfig = config$3;
        var ADD_GROUP = "ADD_GROUP";
        var ADD_CASE_GROUP = "ADD_CASE_GROUP";
        var REMOVE_GROUP = "REMOVE_GROUP";
        var SET_CONJUNCTION = "SET_CONJUNCTION";
        var SET_NOT = "SET_NOT";
        var ADD_RULE = "ADD_RULE";
        var REMOVE_RULE = "REMOVE_RULE";
        var SET_FIELD = "SET_FIELD";
        var SET_FIELD_SRC = "SET_FIELD_SRC";
        var SET_OPERATOR = "SET_OPERATOR";
        var SET_VALUE = "SET_VALUE";
        var SET_VALUE_SRC = "SET_VALUE_SRC";
        var SET_FUNC_VALUE = "SET_FUNC_VALUE";
        var SET_OPERATOR_OPTION = "SET_OPERATOR_OPTION";
        var SET_LOCK = "SET_LOCK";
        var SET_TREE = "SET_TREE";
        var MOVE_ITEM = "MOVE_ITEM";
        var PLACEMENT_AFTER$1 = "after";
        var PLACEMENT_BEFORE$1 = "before";
        var PLACEMENT_APPEND$1 = "append";
        var PLACEMENT_PREPEND$1 = "prepend";
        var SET_DRAG_PROGRESS$1 = "SET_DRAG_PROGRESS";
        var SET_DRAG_START$1 = "SET_DRAG_START";
        var SET_DRAG_END$1 = "SET_DRAG_END";
        var baseFor$1 = _baseFor,
          keys$2 = keys_1;

        /**
         * The base implementation of `_.forOwn` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn$4(object, iteratee) {
          return object && baseFor$1(object, iteratee, keys$2);
        }
        var _baseForOwn = baseForOwn$4;
        var Stack$1 = _Stack,
          baseIsEqual$2 = _baseIsEqual;

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$7 = 1,
          COMPARE_UNORDERED_FLAG$5 = 2;

        /**
         * The base implementation of `_.isMatch` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Array} matchData The property names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch$2(object, source, matchData, customizer) {
          var index = matchData.length,
            length = index,
            noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
              objValue = object[key],
              srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack$1();
              if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result === undefined ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$7 | COMPARE_UNORDERED_FLAG$5, customizer, stack) : result)) {
                return false;
              }
            }
          }
          return true;
        }
        var _baseIsMatch = baseIsMatch$2;
        var isObject$3 = isObject_1;

        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable$3(value) {
          return value === value && !isObject$3(value);
        }
        var _isStrictComparable = isStrictComparable$3;
        var isStrictComparable$2 = _isStrictComparable,
          keys$1 = keys_1;

        /**
         * Gets the property names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData$2(object) {
          var result = keys$1(object),
            length = result.length;
          while (length--) {
            var key = result[length],
              value = object[key];
            result[length] = [key, value, isStrictComparable$2(value)];
          }
          return result;
        }
        var _getMatchData = getMatchData$2;

        /**
         * A specialized version of `matchesProperty` for source values suitable
         * for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */

        function matchesStrictComparable$3(key, srcValue) {
          return function (object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
          };
        }
        var _matchesStrictComparable = matchesStrictComparable$3;
        var baseIsMatch$1 = _baseIsMatch,
          getMatchData$1 = _getMatchData,
          matchesStrictComparable$2 = _matchesStrictComparable;

        /**
         * The base implementation of `_.matches` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatches$2(source) {
          var matchData = getMatchData$1(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable$2(matchData[0][0], matchData[0][1]);
          }
          return function (object) {
            return object === source || baseIsMatch$1(object, source, matchData);
          };
        }
        var _baseMatches = baseMatches$2;
        var baseGet$2 = _baseGet;

        /**
         * Gets the value at `path` of `object`. If the resolved value is
         * `undefined`, the `defaultValue` is returned in its place.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.get(object, 'a[0].b.c');
         * // => 3
         *
         * _.get(object, ['a', '0', 'b', 'c']);
         * // => 3
         *
         * _.get(object, 'a.b.c', 'default');
         * // => 'default'
         */
        function get$3(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet$2(object, path);
          return result === undefined ? defaultValue : result;
        }
        var get_1 = get$3;
        var baseIsEqual$1 = _baseIsEqual,
          get$2 = get_1,
          hasIn$1 = hasIn_1,
          isKey$2 = _isKey,
          isStrictComparable$1 = _isStrictComparable,
          matchesStrictComparable$1 = _matchesStrictComparable,
          toKey$2 = _toKey;

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$6 = 1,
          COMPARE_UNORDERED_FLAG$4 = 2;

        /**
         * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatchesProperty$2(path, srcValue) {
          if (isKey$2(path) && isStrictComparable$1(srcValue)) {
            return matchesStrictComparable$1(toKey$2(path), srcValue);
          }
          return function (object) {
            var objValue = get$2(object, path);
            return objValue === undefined && objValue === srcValue ? hasIn$1(object, path) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$6 | COMPARE_UNORDERED_FLAG$4);
          };
        }
        var _baseMatchesProperty = baseMatchesProperty$2;

        /**
         * The base implementation of `_.property` without support for deep paths.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @returns {Function} Returns the new accessor function.
         */

        function baseProperty$2(key) {
          return function (object) {
            return object == null ? undefined : object[key];
          };
        }
        var _baseProperty = baseProperty$2;
        var baseGet$1 = _baseGet;

        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         */
        function basePropertyDeep$2(path) {
          return function (object) {
            return baseGet$1(object, path);
          };
        }
        var _basePropertyDeep = basePropertyDeep$2;
        var baseProperty$1 = _baseProperty,
          basePropertyDeep$1 = _basePropertyDeep,
          isKey$1 = _isKey,
          toKey$1 = _toKey;

        /**
         * Creates a function that returns the value at `path` of a given object.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': 2 } },
         *   { 'a': { 'b': 1 } }
         * ];
         *
         * _.map(objects, _.property('a.b'));
         * // => [2, 1]
         *
         * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
         * // => [1, 2]
         */
        function property$2(path) {
          return isKey$1(path) ? baseProperty$1(toKey$1(path)) : basePropertyDeep$1(path);
        }
        var property_1 = property$2;
        var baseMatches$1 = _baseMatches,
          baseMatchesProperty$1 = _baseMatchesProperty,
          identity$2 = identity_1,
          isArray$3 = isArray_1,
          property$1 = property_1;

        /**
         * The base implementation of `_.iteratee`.
         *
         * @private
         * @param {*} [value=_.identity] The value to convert to an iteratee.
         * @returns {Function} Returns the iteratee.
         */
        function baseIteratee$4(value) {
          // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
          // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
          if (typeof value == 'function') {
            return value;
          }
          if (value == null) {
            return identity$2;
          }
          if (typeof value == 'object') {
            return isArray$3(value) ? baseMatchesProperty$1(value[0], value[1]) : baseMatches$1(value);
          }
          return property$1(value);
        }
        var _baseIteratee = baseIteratee$4;
        var baseAssignValue$1 = _baseAssignValue,
          baseForOwn$3 = _baseForOwn,
          baseIteratee$3 = _baseIteratee;

        /**
         * Creates an object with the same keys as `object` and values generated
         * by running each own enumerable string keyed property of `object` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, key, object).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @see _.mapKeys
         * @example
         *
         * var users = {
         *   'fred':    { 'user': 'fred',    'age': 40 },
         *   'pebbles': { 'user': 'pebbles', 'age': 1 }
         * };
         *
         * _.mapValues(users, function(o) { return o.age; });
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         *
         * // The `_.property` iteratee shorthand.
         * _.mapValues(users, 'age');
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         */
        function mapValues(object, iteratee) {
          var result = {};
          iteratee = baseIteratee$3(iteratee);
          baseForOwn$3(object, function (value, key, object) {
            baseAssignValue$1(result, key, iteratee(value, key, object));
          });
          return result;
        }
        var mapValues_1 = mapValues;
        const mapValues$1 = /*@__PURE__*/getDefaultExportFromCjs(mapValues_1);
        function ownKeys$k(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$k(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$k(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$k(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _createForOfIteratorHelper$1(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$1(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
        }
        function _arrayLikeToArray$1(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {Immutable.Map} properties
         */
        var addNewGroup = function addNewGroup(state, path, type, generatedId, properties, config) {
          var _properties$get;
          var children = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          var meta = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
          var targetItem = state.getIn(expandTreePath(path));
          if (!targetItem) {
            // incorrect path
            return state;
          }
          var groupUuid = (properties === null || properties === void 0 || (_properties$get = properties.get) === null || _properties$get === void 0 ? void 0 : _properties$get.call(properties, "id")) || generatedId;
          var shouldCreateEmptyGroup = config.settings.shouldCreateEmptyGroup;
          var groupPath = path.push(groupUuid);
          var canAddNewRule = !shouldCreateEmptyGroup;
          var isDefaultCase = !!(meta !== null && meta !== void 0 && meta.isDefaultCase);
          var origState = state;
          state = addItem(state, path, type, groupUuid, defaultGroupProperties(config).merge(fromJS(properties) || {}), config, children);
          if (state !== origState) {
            if (!children && !isDefaultCase) {
              state = state.setIn(expandTreePath(groupPath, "children1"), new Immutable.OrderedMap());

              // Add one empty rule into new group
              if (canAddNewRule) {
                state = addItem(state, groupPath, "rule", uuid(), defaultRuleProperties(config), config);
              }
            }
            state = fixPathsInTree(state);
          }
          return state;
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {Immutable.Map} properties
         */
        var removeGroup$1 = function removeGroup(state, path, config) {
          var targetItem = state.getIn(expandTreePath(path));
          if (!targetItem) {
            // incorrect path
            return state;
          }
          state = removeItem(state, path);
          var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;
          var parentPath = path.slice(0, -1);
          var isEmptyParentGroup = !hasChildren(state, parentPath);
          if (isEmptyParentGroup && !canLeaveEmptyGroup) {
            // check ancestors for emptiness (and delete 'em if empty)
            state = fixEmptyGroupsInTree(state);
            if (isEmptyTree(state) && !canLeaveEmptyGroup) {
              // if whole query is empty, add one empty(!) rule to root
              var canUseDefaultFieldAndOp = false;
              var canGetFirst = false;
              state = addItem(state, new Immutable.List(), "rule", uuid(), defaultRuleProperties(config, undefined, undefined, canUseDefaultFieldAndOp, canGetFirst), config);
            }
          }
          state = fixPathsInTree(state);
          return state;
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         */
        var removeRule$1 = function removeRule(state, path, config) {
          var targetItem = state.getIn(expandTreePath(path));
          if (!targetItem) {
            // incorrect path
            return state;
          }
          state = removeItem(state, path);
          var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;
          var parentPath = path.pop();
          var parent = state.getIn(expandTreePath(parentPath));
          var parentField = parent.getIn(["properties", "field"]);
          var parentOperator = parent.getIn(["properties", "operator"]);
          // const parentValue = parent.getIn(["properties", "value", 0]);
          var parentFieldConfig = parentField ? getFieldConfig$8(config, parentField) : null;
          var parentOperatorConfig = parentOperator ? getOperatorConfig$4(config, parentOperator, parentField) : null;
          var hasGroupCountRule = parentField && parentOperator && parentOperatorConfig.cardinality != 0; // && parentValue != undefined;

          var isParentRuleGroup = parent.get("type") == "rule_group";
          var isEmptyParentGroup = !hasChildren(state, parentPath);
          var canLeaveEmpty = isParentRuleGroup ? hasGroupCountRule && parentFieldConfig.initialEmptyWhere : canLeaveEmptyGroup;
          if (isEmptyParentGroup && !canLeaveEmpty) {
            if (isParentRuleGroup) {
              // deleted last rule from rule_group, so delete whole rule_group
              state = state.deleteIn(expandTreePath(parentPath));
            }

            // check ancestors for emptiness (and delete 'em if empty)
            state = fixEmptyGroupsInTree(state);
            if (isEmptyTree(state) && !canLeaveEmptyGroup) {
              // if whole query is empty, add one empty(!) rule to root
              var canUseDefaultFieldAndOp = false;
              var canGetFirst = false;
              state = addItem(state, new Immutable.List(), "rule", uuid(), defaultRuleProperties(config, undefined, undefined, canUseDefaultFieldAndOp, canGetFirst), config);
            }
          }
          state = fixPathsInTree(state);
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {bool} not
         */
        var setNot$1 = function setNot(state, path, not) {
          var targetItem = state.getIn(expandTreePath(path));
          if (!targetItem) {
            // incorrect path
            return state;
          }
          state = state.setIn(expandTreePath(path, "properties", "not"), not);
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {bool} lock
         */
        var setLock$1 = function setLock(state, path, lock) {
          var targetItem = state.getIn(expandTreePath(path));
          if (!targetItem) {
            // incorrect path
            return state;
          }
          state = removeIsLockedInTree(state.setIn(expandTreePath(path, "properties", "isLocked"), lock));
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {string} conjunction
         */
        var setConjunction$1 = function setConjunction(state, path, conjunction) {
          var targetItem = state.getIn(expandTreePath(path));
          if (!targetItem) {
            // incorrect path
            return state;
          }
          state = state.setIn(expandTreePath(path, "properties", "conjunction"), conjunction);
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {string} type
         * @param {string} id
         * @param {Immutable.OrderedMap} properties
         * @param {object} config
         */
        var addItem = function addItem(state, path, type, generatedId, properties, config) {
          var _properties$get2;
          var children = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          if (type === "switch_group") throw new Error("Can't add switch_group programmatically");
          var targetItem = state.getIn(expandTreePath(path));
          if (!targetItem) {
            // incorrect path
            return state;
          }
          var id = (properties === null || properties === void 0 || (_properties$get2 = properties.get) === null || _properties$get2 === void 0 ? void 0 : _properties$get2.call(properties, "id")) || generatedId;
          var _config$settings = config.settings,
            maxNumberOfCases = _config$settings.maxNumberOfCases,
            maxNumberOfRules = _config$settings.maxNumberOfRules,
            maxNesting = _config$settings.maxNesting;
          var rootType = state.get("type");
          var isTernary = rootType === "switch_group";
          var caseGroup = isTernary ? state.getIn(expandTreePath(path.take(2))) : null;
          var childrenPath = expandTreePath(path, "children1");
          var targetChildren = state.getIn(childrenPath);
          var hasChildren = !!targetChildren && targetChildren.size;
          var targetChildrenSize = hasChildren ? targetChildren.size : null;
          var currentNumber, maxNumber;
          if (type === "case_group") {
            currentNumber = targetChildrenSize;
            maxNumber = maxNumberOfCases;
          } else if (type === "group") {
            currentNumber = path.size;
            maxNumber = maxNesting;
          } else if ((targetItem === null || targetItem === void 0 ? void 0 : targetItem.get("type")) === "rule_group") ;else {
            currentNumber = isTernary ? getTotalRulesCountInTree$2(caseGroup) : getTotalRulesCountInTree$2(state);
            maxNumber = maxNumberOfRules;
          }
          var canAdd = maxNumber && currentNumber ? currentNumber < maxNumber : true;
          var item = {
            type: type,
            id: id,
            properties: properties
          };
          _addChildren1(config, item, children);
          var isLastDefaultCase = type === "case_group" && hasChildren && targetChildren.last().get("children1") == null;
          if (canAdd) {
            var newChildren = new Immutable.OrderedMap(_defineProperty$4({}, id, new Immutable.Map(item)));
            if (!hasChildren) {
              state = state.setIn(childrenPath, newChildren);
            } else if (isLastDefaultCase) {
              var last = targetChildren.last();
              var newChildrenWithLast = new Immutable.OrderedMap(_defineProperty$4(_defineProperty$4({}, id, new Immutable.Map(item)), last.get("id"), last));
              state = state.deleteIn(expandTreePath(childrenPath, "children1", last.get("id")));
              state = state.mergeIn(childrenPath, newChildrenWithLast);
            } else {
              state = state.mergeIn(childrenPath, newChildren);
            }
            state = fixPathsInTree(state);
          }
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         */
        var removeItem = function removeItem(state, path) {
          state = state.deleteIn(expandTreePath(path));
          state = fixPathsInTree(state);
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} fromPath
         * @param {Immutable.List} toPath
         * @param {string} placement, see constants PLACEMENT_*: PLACEMENT_AFTER, PLACEMENT_BEFORE, PLACEMENT_APPEND, PLACEMENT_PREPEND
         * @param {object} config
         */
        var moveItem$1 = function moveItem(state, fromPath, toPath, placement, config) {
          var from = getItemByPath(state, fromPath);
          var sourcePath = fromPath.pop();
          var source = fromPath.size > 1 ? getItemByPath(state, sourcePath) : null;
          var sourceChildren = source ? source.get("children1") : null;
          var to = getItemByPath(state, toPath);
          var targetPath = placement == PLACEMENT_APPEND$1 || placement == PLACEMENT_PREPEND$1 ? toPath : toPath.pop();
          var target = placement == PLACEMENT_APPEND$1 || placement == PLACEMENT_PREPEND$1 ? to : toPath.size > 1 ? getItemByPath(state, targetPath) : null;
          var targetChildren = target ? target.get("children1") : null;
          if (!source || !target || !from) {
            // incorrect path
            return state;
          }
          var isSameParent = source.get("id") == target.get("id");
          var isSourceInsideTarget = targetPath.size < sourcePath.size && deepEqual(targetPath.toArray(), sourcePath.toArray().slice(0, targetPath.size));
          var isTargetInsideSource = targetPath.size > sourcePath.size && deepEqual(sourcePath.toArray(), targetPath.toArray().slice(0, sourcePath.size));
          var sourceSubpathFromTarget = null;
          var targetSubpathFromSource = null;
          if (isSourceInsideTarget) {
            sourceSubpathFromTarget = Immutable.List(sourcePath.toArray().slice(targetPath.size));
          } else if (isTargetInsideSource) {
            targetSubpathFromSource = Immutable.List(targetPath.toArray().slice(sourcePath.size));
          }
          var newTargetChildren = targetChildren,
            newSourceChildren = sourceChildren;
          if (!isTargetInsideSource) newSourceChildren = newSourceChildren["delete"](from.get("id"));
          if (isSameParent) {
            newTargetChildren = newSourceChildren;
          } else if (isSourceInsideTarget) {
            newTargetChildren = newTargetChildren.updateIn(expandTreeSubpath(sourceSubpathFromTarget, "children1"), function (_oldChildren) {
              return newSourceChildren;
            });
          }
          if (placement == PLACEMENT_BEFORE$1 || placement == PLACEMENT_AFTER$1) {
            newTargetChildren = Immutable.OrderedMap().withMutations(function (r) {
              var _iterator = _createForOfIteratorHelper$1(newTargetChildren.entries()),
                _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var _step$value = _slicedToArray$1(_step.value, 2),
                    itemId = _step$value[0],
                    item = _step$value[1];
                  if (itemId == (to === null || to === void 0 ? void 0 : to.get("id")) && placement == PLACEMENT_BEFORE$1) {
                    r.set(from.get("id"), from);
                  }
                  r.set(itemId, item);
                  if (itemId == (to === null || to === void 0 ? void 0 : to.get("id")) && placement == PLACEMENT_AFTER$1) {
                    r.set(from.get("id"), from);
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            });
          } else if (placement == PLACEMENT_APPEND$1) {
            newTargetChildren = newTargetChildren.merge(Immutable.OrderedMap(_defineProperty$4({}, from.get("id"), from)));
          } else if (placement == PLACEMENT_PREPEND$1) {
            newTargetChildren = Immutable.OrderedMap(_defineProperty$4({}, from.get("id"), from)).merge(newTargetChildren);
          }
          if (isTargetInsideSource) {
            newSourceChildren = newSourceChildren.updateIn(expandTreeSubpath(targetSubpathFromSource, "children1"), function (_oldChildren) {
              return newTargetChildren;
            });
            newSourceChildren = newSourceChildren["delete"](from.get("id"));
          }
          if (!isSameParent && !isSourceInsideTarget) state = state.updateIn(expandTreePath(sourcePath, "children1"), function (_oldChildren) {
            return newSourceChildren;
          });
          if (!isTargetInsideSource) state = state.updateIn(expandTreePath(targetPath, "children1"), function (_oldChildren) {
            return newTargetChildren;
          });
          state = fixPathsInTree(state);
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {integer} delta
         * @param {string} srcKey
         */
        var setFieldSrc$1 = function setFieldSrc(state, path, srcKey, config) {
          var currentRule = state.getIn(expandTreePath(path));
          if (!currentRule) {
            // incorrect path
            return state;
          }
          var keepInputOnChangeFieldSrc = config.settings.keepInputOnChangeFieldSrc;
          var currentProperties = currentRule.get("properties");
          var currentField = currentProperties === null || currentProperties === void 0 ? void 0 : currentProperties.get("field");
          var currentFielType = currentProperties === null || currentProperties === void 0 ? void 0 : currentProperties.get("fieldType");
          var currentFieldConfig = getFieldConfig$8(config, currentField);
          // const currentType = currentRule.get("type");
          // const currentFieldSrc = currentProperties?.get("fieldSrc");

          // get fieldType for "memory effect"
          var fieldType = (currentFieldConfig === null || currentFieldConfig === void 0 ? void 0 : currentFieldConfig.type) || currentFielType;
          if (!fieldType || fieldType === "!group" || fieldType === "!struct") {
            fieldType = null;
          }
          var canReuseValue = !selectTypes.includes(fieldType);
          var keepInput = keepInputOnChangeFieldSrc && !isEmptyItem(currentRule, config) && canReuseValue;
          if (!keepInput) {
            // clear ALL properties
            state = state.setIn(expandTreePath(path, "properties"), defaultRuleProperties(config, null, null, false));
          } else {
            // clear non-relevant properties
            state = state.setIn(expandTreePath(path, "properties", "field"), null);
            state = state.deleteIn(expandTreePath(path, "properties", "fieldError"));
            // set fieldType for "memory effect"
            state = state.setIn(expandTreePath(path, "properties", "fieldType"), fieldType);
          }

          // set fieldSrc
          state = state.setIn(expandTreePath(path, "properties", "fieldSrc"), srcKey);
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {integer} delta
         * @param {Array} parentFuncs
         * @param {string | null} argKey
         * @param {*} argValue if argKey is null, it's new func key
         * @param {string | "!valueSrc"} valueType
         * @param {*} asyncListValues
         */
        var setFuncValue$1 = function setFuncValue(config, state, path, delta, parentFuncs, argKey, argValue, valueType, asyncListValues) {
          var _meta = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : {};
          var currentRule = state.getIn(expandTreePath(path));
          if (!currentRule) {
            // incorrect path
            return state;
          }
          var isLHS = delta === -1;
          var currentProperties = currentRule.get("properties");
          var currentField = currentProperties.get("field");
          var currentValue = currentProperties.get("value");
          var currentV = isLHS ? currentField : currentValue.getIn([delta]);

          // go inwards
          var funcsPath = [];
          var targetFV = currentV;
          var _iterator2 = _createForOfIteratorHelper$1(parentFuncs || []),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _step2$value = _slicedToArray$1(_step2.value, 2),
                _funcK = _step2$value[0],
                _argK = _step2$value[1];
              funcsPath.push([_funcK, _argK, targetFV]);
              if (_funcK !== targetFV.get("func")) {
                var funcPath = funcsPath.map(function (_ref) {
                  var _ref2 = _slicedToArray$1(_ref, 2),
                    f = _ref2[0],
                    a = _ref2[1];
                  return "".concat(f, "(").concat(a, ")");
                }).join("/") || "root";
                throw new Error("In ".concat(isLHS ? "LHS" : "RHS", " for path ").concat(funcPath, " expected func key ").concat(_funcK, " but got ").concat(parent.get("func")));
              }
              targetFV = targetFV.getIn(["args", _argK, "value"]);
            }

            // modify
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          if (!argKey) {
            var newFuncKey = argValue;
            var canFixArgs = true; // try to fix args to fit new func validations, otherwise - drop invalid args
            targetFV = setFunc(targetFV, newFuncKey, config, canFixArgs);
            // allow drop invalid args / reset to default, but don't trigger error if some arg is required
            // (not same as setting isEndValue = true)
            _meta.canDropArgs = true;
          } else {
            var funcKey = targetFV.get("func");
            var funcDefinition = getFuncConfig$2(config, funcKey);
            var args = funcDefinition.args;
            var argDefinition = args[argKey];
            if (valueType === "!valueSrc") {
              targetFV = setArgValueSrc(targetFV, argKey, argValue);
            } else {
              targetFV = setArgValue(targetFV, argKey, argValue, argDefinition, config);
            }
          }

          // go outwards
          var newV = targetFV;
          while (funcsPath.length) {
            var _funcsPath$pop = funcsPath.pop(),
              _funcsPath$pop2 = _slicedToArray$1(_funcsPath$pop, 3),
              funcK = _funcsPath$pop2[0],
              argK = _funcsPath$pop2[1],
              parentFV = _funcsPath$pop2[2];
            var _funcDefinition = getFuncConfig$2(config, funcK);
            var _args = _funcDefinition.args;
            var _argDefinition = _args[argK];
            newV = setArgValue(parentFV, argK, newV, _argDefinition, config);
          }
          if (isLHS) {
            return setField$1(state, path, newV, config, asyncListValues, _meta);
          } else {
            return setValue$1(state, path, delta, newV, undefined, config, asyncListValues, _meta);
          }
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {string | Immutable.OrderedMap} newField
         */
        var setField$1 = function setField(state, path, newField, config, asyncListValues) {
          var _newFieldConfig$opera, _currentField$get, _newField, _newField$get;
          var _meta = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
          var currentRule = state.getIn(expandTreePath(path));
          if (!currentRule) {
            // incorrect path
            return {
              state: state
            };
          }
          var isEndValue = _meta.isEndValue,
            canDropArgs = _meta.canDropArgs;
          if (!newField) {
            state = removeItem(state, path);
            return {
              state: state
            };
          }
          var _config$settings2 = config.settings,
            fieldSeparator = _config$settings2.fieldSeparator,
            setOpOnChangeField = _config$settings2.setOpOnChangeField,
            showErrorMessage = _config$settings2.showErrorMessage;
          if (Array.isArray(newField)) newField = newField.join(fieldSeparator);
          var currentType = currentRule.get("type");
          var currentProperties = currentRule.get("properties");
          var wasRuleGroup = currentType == "rule_group";
          var currentFieldSrc = currentProperties === null || currentProperties === void 0 ? void 0 : currentProperties.get("fieldSrc");
          // const currentFieldError = currentProperties?.get("fieldError");
          var newFieldConfig = getFieldConfig$8(config, newField);
          if (!newFieldConfig) {
            console.warn("No config for LHS ".concat(newField));
            return {
              state: state
            };
          }
          var fieldType = newFieldConfig.type;
          if (fieldType === "!group" || fieldType === "!struct") {
            fieldType = null;
          }
          var currentOperator = currentProperties === null || currentProperties === void 0 ? void 0 : currentProperties.get("operator");
          var currentOperatorOptions = currentProperties === null || currentProperties === void 0 ? void 0 : currentProperties.get("operatorOptions");
          var currentField = currentProperties === null || currentProperties === void 0 ? void 0 : currentProperties.get("field");
          // const currentValue = currentProperties?.get("value");
          // const currentValueErrorStr = currentProperties?.get("valueError")?.join?.("|");
          // const _currentValueSrc = currentProperties?.get("valueSrc", new Immutable.List());
          // const _currentValueType = currentProperties?.get("valueType", new Immutable.List());

          var isRuleGroup = newFieldConfig.type == "!group";
          var isRuleGroupExt = isRuleGroup && newFieldConfig.mode == "array";
          var isChangeToAnotherType = wasRuleGroup != isRuleGroup;
          // const wasOkWithoutField = !currentField && currentFieldSrc && currentOperator;

          // If the newly selected field supports the same operator the rule currently
          // uses, keep it selected.
          var lastOp = newFieldConfig && ((_newFieldConfig$opera = newFieldConfig.operators) === null || _newFieldConfig$opera === void 0 ? void 0 : _newFieldConfig$opera.indexOf(currentOperator)) !== -1 ? currentOperator : null;
          var isSameFunc = currentFieldSrc === "func" && (currentField === null || currentField === void 0 || (_currentField$get = currentField.get) === null || _currentField$get === void 0 ? void 0 : _currentField$get.call(currentField, "func")) === ((_newField = newField) === null || _newField === void 0 || (_newField$get = _newField.get) === null || _newField$get === void 0 ? void 0 : _newField$get.call(_newField, "func"));
          var forceKeepOp = isSameFunc && !!lastOp;
          var newOperator = null;
          var availOps = currentFieldSrc === "func" ? getOperatorsForType(config, fieldType) : getOperatorsForField(config, newField);
          if (availOps && availOps.length == 1) newOperator = availOps[0];else if (forceKeepOp) newOperator = lastOp;else if (availOps && availOps.length > 1) {
            var _iterator3 = _createForOfIteratorHelper$1(setOpOnChangeField),
              _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var strategy = _step3.value;
                if (strategy == "keep" && !isChangeToAnotherType) newOperator = lastOp;else if (strategy == "default") newOperator = getDefaultOperator(config, newField, false);else if (strategy == "first") newOperator = getFirstOperator(config, newField);
                if (newOperator)
                  //found op for strategy
                  break;
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
          if (!isRuleGroup && !newFieldConfig.operators) {
            console.warn("Type ".concat(newFieldConfig.type, " is not supported"));
            return {
              state: state
            };
          }
          if (wasRuleGroup && !isRuleGroup) {
            state = state.setIn(expandTreePath(path, "type"), "rule");
            state = state.deleteIn(expandTreePath(path, "children1"));
            state = state.setIn(expandTreePath(path, "properties"), new Immutable.OrderedMap());
          }
          if (!currentProperties) {
            state = state.setIn(expandTreePath(path, "properties"), new Immutable.OrderedMap());
          }
          var canFix = !showErrorMessage;
          if (isRuleGroup) {
            state = state.setIn(expandTreePath(path, "type"), "rule_group");
            var _getNewValueForFieldO = getNewValueForFieldOp(config, config, currentProperties, newField, newOperator, "field", canFix, isEndValue, canDropArgs);
            _getNewValueForFieldO.canReuseValue;
            var newValue = _getNewValueForFieldO.newValue,
              newValueSrc = _getNewValueForFieldO.newValueSrc,
              newValueType = _getNewValueForFieldO.newValueType,
              operatorCardinality = _getNewValueForFieldO.operatorCardinality;
            var groupProperties = defaultGroupProperties(config, newFieldConfig).merge({
              field: newField,
              fieldSrc: "field",
              mode: newFieldConfig.mode
            });
            if (isRuleGroupExt) {
              groupProperties = groupProperties.merge({
                operator: newOperator,
                value: newValue,
                valueSrc: newValueSrc,
                valueType: newValueType
              });
            }
            state = state.setIn(expandTreePath(path, "children1"), new Immutable.OrderedMap());
            state = state.setIn(expandTreePath(path, "properties"), groupProperties);
            if (newFieldConfig.initialEmptyWhere && operatorCardinality == 1) ;else {
              state = addItem(state, path, "rule", uuid(), defaultRuleProperties(config, newField), config);
            }
            state = fixPathsInTree(state);
          } else {
            state = state.updateIn(expandTreePath(path, "properties"), function (map) {
              return map.withMutations(function (current) {
                var _getNewValueForFieldO2 = getNewValueForFieldOp(config, config, current, newField, newOperator, "field", canFix, isEndValue, canDropArgs),
                  canReuseValue = _getNewValueForFieldO2.canReuseValue,
                  newValue = _getNewValueForFieldO2.newValue,
                  newValueSrc = _getNewValueForFieldO2.newValueSrc,
                  newValueType = _getNewValueForFieldO2.newValueType,
                  newValueError = _getNewValueForFieldO2.newValueError,
                  newFieldError = _getNewValueForFieldO2.newFieldError,
                  fixedField = _getNewValueForFieldO2.fixedField;
                // const newValueErrorStr = newValueError?.join?.("|");
                var newCorrectField = newField;
                var willFixField = fixedField !== newField;
                if (willFixField) {
                  newCorrectField = fixedField;
                }
                // tip: `newCorrectField` is SAFE to set: even if it can't be fixed, it is reverted to previous good field.
                //      Unlike logic in `setValue()` action where we need to calc `canUpdValue`
                // const didFieldErrorChanged = showErrorMessage ? currentFieldError != newFieldError : !!currentFieldError != !!newFieldError;
                // const didValueErrorChanged = showErrorMessage ? currentValueErrorStr != newValueErrorStr : !!currentValueErrorStr != !!newValueErrorStr;
                // const didErrorChanged = didFieldErrorChanged || didValueErrorChanged;
                // isInternalValueChange = !didErrorChanged && !willFixField;
                if (showErrorMessage) {
                  current = current.set("fieldError", newFieldError);
                  current = current.set("valueError", newValueError);
                }
                var newOperatorOptions = canReuseValue ? currentOperatorOptions : defaultOperatorOptions(config, newOperator, newCorrectField);
                current = current.set("field", newCorrectField)["delete"]("fieldType") // remove "memory effect"
                .set("fieldSrc", currentFieldSrc).set("operator", newOperator).set("operatorOptions", newOperatorOptions).set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType);
                if (!canReuseValue) {
                  current = current["delete"]("asyncListValues");
                }
                return current;
              });
            });
          }
          return {
            state: state
          };
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {string} operator
         */
        var setOperator$1 = function setOperator(state, path, newOperator, config) {
          var currentRule = state.getIn(expandTreePath(path));
          if (!currentRule) {
            // incorrect path
            return state;
          }
          var showErrorMessage = config.settings.showErrorMessage;
          var properties = currentRule.get("properties");
          var children = currentRule.get("children1");
          var currentField = properties.get("field");
          properties.get("fieldSrc");
          var fieldConfig = getFieldConfig$8(config, currentField);
          var isRuleGroup = (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) == "!group";
          var operatorConfig = getOperatorConfig$4(config, newOperator, currentField);
          var operatorCardinality = operatorConfig ? getOpCardinality$1(operatorConfig) : null;
          var canFix = true;
          state = state.updateIn(expandTreePath(path, "properties"), function (map) {
            return map.withMutations(function (current) {
              var currentField = current.get("field");
              var currentOperatorOptions = current.get("operatorOptions");
              current.get("value", new Immutable.List());
              current.get("valueSrc", new Immutable.List());
              current.get("operator");
              var _getNewValueForFieldO3 = getNewValueForFieldOp(config, config, current, currentField, newOperator, "operator", canFix),
                canReuseValue = _getNewValueForFieldO3.canReuseValue,
                newValue = _getNewValueForFieldO3.newValue,
                newValueSrc = _getNewValueForFieldO3.newValueSrc,
                newValueType = _getNewValueForFieldO3.newValueType,
                newValueError = _getNewValueForFieldO3.newValueError;
              if (showErrorMessage) {
                current = current.set("valueError", newValueError);
              }
              var newOperatorOptions = canReuseValue ? currentOperatorOptions : defaultOperatorOptions(config, newOperator, currentField);
              if (!canReuseValue) {
                current = current["delete"]("asyncListValues");
              }
              return current.set("operator", newOperator).set("operatorOptions", newOperatorOptions).set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType);
            });
          });
          if (isRuleGroup) {
            if (operatorCardinality == 0 && children.size == 0) {
              state = addItem(state, path, "rule", uuid(), defaultRuleProperties(config, currentField), config);
            }
          }
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {integer} delta
         * @param {*} value
         * @param {string} valueType
         * @param {*} asyncListValues
         */
        var setValue$1 = function setValue(state, path, delta, value, valueType, config, asyncListValues) {
          var _meta = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
          var currentRule = state.getIn(expandTreePath(path));
          if (!currentRule) {
            // incorrect path
            return {
              state: state
            };
          }
          var canDropArgs = _meta.canDropArgs,
            isEndValue = _meta.isEndValue;
          var _config$settings3 = config.settings,
            fieldSeparator = _config$settings3.fieldSeparator,
            showErrorMessage = _config$settings3.showErrorMessage;
          var valueSrc = state.getIn(expandTreePath(path, "properties", "valueSrc", delta + "")) || null;
          if (valueSrc === "field" && Array.isArray(value)) value = value.join(fieldSeparator);
          var field = state.getIn(expandTreePath(path, "properties", "field")) || null;
          //const fieldSrc = state.getIn(expandTreePath(path, "properties", "fieldSrc")) || null;
          var operator = state.getIn(expandTreePath(path, "properties", "operator")) || null;
          var operatorConfig = getOperatorConfig$4(config, operator, field);
          var operatorCardinality = operator ? getOpCardinality$1(operatorConfig) : null;
          var calculatedValueType = valueType || calculateValueType(value, valueSrc, config);
          var canFix = !showErrorMessage;
          var _validateValue = validateValue(config, field, field, operator, value, calculatedValueType, valueSrc, asyncListValues, canFix, isEndValue, canDropArgs),
            _validateValue2 = _slicedToArray$1(_validateValue, 2),
            fixedValue = _validateValue2[0],
            allErrors = _validateValue2[1];
          var firstError = allErrors === null || allErrors === void 0 ? void 0 : allErrors.find(function (e) {
            return !e.fixed && !e.ignore;
          });
          var validationError = firstError ? translateValidation(firstError) : null;
          // tip: even if canFix == false, use fixedValue, it can SAFELY fix value of select
          //  (get exact value from listValues, not string)
          var willFix = fixedValue !== value;
          if (willFix) {
            value = fixedValue;
          }

          // init lists
          state = initEmptyValueLists(state, path, config, operatorCardinality);

          // Additional validation for range values
          var values = Array.from({
            length: operatorCardinality
          }, function (_, i) {
            return i == delta ? value : state.getIn(expandTreePath(path, "properties", "value", i + "")) || null;
          });
          var valueSrcs = Array.from({
            length: operatorCardinality
          }, function (_, i) {
            return state.getIn(expandTreePath(path, "properties", "valueSrc", i + "")) || null;
          });
          var rangeErrorObj = validateRange(config, field, operator, values, valueSrcs);
          var rangeValidationError = rangeErrorObj ? translateValidation(rangeErrorObj) : null;
          var isValid = !validationError && !rangeValidationError;
          var canUpdValue = showErrorMessage ? true : isValid || willFix; // set only good value
          // const lastValue = state.getIn(expandTreePath(path, "properties", "value", delta));
          // const lastError = state.getIn(expandTreePath(path, "properties", "valueError", delta));
          // const lastRangeError = state.getIn(expandTreePath(path, "properties", "valueError", operatorCardinality));
          // const didDeltaErrorChanged = showErrorMessage ? lastError != validationError : !!lastError != !!validationError;
          // const didRangeErrorChanged = showErrorMessage ? lastRangeError != rangeValidationError : !!lastRangeError != !!rangeValidationError;
          // const didErrorChanged = didDeltaErrorChanged || didRangeErrorChanged;
          // const didEmptinessChanged = !!lastValue != !!value;
          // isInternalValueChange = !didEmptinessChanged && !didErrorChanged && !willFix;

          if (canUpdValue) {
            state = state.deleteIn(expandTreePath(path, "properties", "asyncListValues"));
            if (typeof value === "undefined") {
              state = state.setIn(expandTreePath(path, "properties", "value", delta), undefined);
              state = state.setIn(expandTreePath(path, "properties", "valueType", delta), null);
            } else {
              if (asyncListValues) {
                state = state.setIn(expandTreePath(path, "properties", "asyncListValues"), asyncListValues);
              }
              state = state.setIn(expandTreePath(path, "properties", "value", delta), value);
              state = state.setIn(expandTreePath(path, "properties", "valueType", delta), calculatedValueType);
            }
          }
          if (showErrorMessage) {
            // check list
            var lastValueErrorArr = state.getIn(expandTreePath(path, "properties", "valueError"));
            if (!lastValueErrorArr) {
              state = state.setIn(expandTreePath(path, "properties", "valueError"), new Immutable.List(new Array(operatorCardinality)));
            }
            // set error at delta
            state = state.setIn(expandTreePath(path, "properties", "valueError", delta), validationError);
            // set range error
            if (operatorCardinality >= 2) {
              state = state.setIn(expandTreePath(path, "properties", "valueError", operatorCardinality), rangeValidationError);
            }
          }
          return {
            state: state
          };
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {integer} delta
         * @param {*} srcKey
         */
        var setValueSrc$1 = function setValueSrc(state, path, delta, srcKey, config) {
          var currentRule = state.getIn(expandTreePath(path));
          if (!currentRule) {
            // incorrect path
            return state;
          }
          var showErrorMessage = config.settings.showErrorMessage;
          var field = state.getIn(expandTreePath(path, "properties", "field")) || null;
          //const fieldSrc = state.getIn(expandTreePath(path, "properties", "fieldSrc")) || null;
          var operator = state.getIn(expandTreePath(path, "properties", "operator")) || null;
          var operatorConfig = getOperatorConfig$4(config, operator, field);
          var operatorCardinality = operator ? getOpCardinality$1(operatorConfig) : null;

          // init lists
          state = initEmptyValueLists(state, path, config, operatorCardinality);
          state = state.setIn(expandTreePath(path, "properties", "value", delta + ""), undefined);
          state = state.setIn(expandTreePath(path, "properties", "valueType", delta + ""), null);
          state = state.deleteIn(expandTreePath(path, "properties", "asyncListValues"));
          if (showErrorMessage) {
            // clear value error
            state = state.setIn(expandTreePath(path, "properties", "valueError", delta), null);

            // if current operator is range, clear possible range error
            if (operatorConfig.validateValues) {
              state = state.setIn(expandTreePath(path, "properties", "valueError", operatorCardinality), null);
            }
          }

          // set valueSrc
          if (typeof srcKey === "undefined") {
            state = state.setIn(expandTreePath(path, "properties", "valueSrc", delta + ""), null);
          } else {
            state = state.setIn(expandTreePath(path, "properties", "valueSrc", delta + ""), srcKey);
          }

          // maybe set default value
          if (srcKey) {
            var properties = state.getIn(expandTreePath(path, "properties"));
            // this call should return canReuseValue = false and provide default value
            var canFix = true;
            var _getNewValueForFieldO4 = getNewValueForFieldOp(config, config, properties, field, operator, "valueSrc", canFix),
              canReuseValue = _getNewValueForFieldO4.canReuseValue,
              newValue = _getNewValueForFieldO4.newValue,
              newValueSrc = _getNewValueForFieldO4.newValueSrc,
              newValueType = _getNewValueForFieldO4.newValueType;
            _getNewValueForFieldO4.newValueError;
            if (!canReuseValue && newValueSrc.get(delta) == srcKey) {
              state = state.setIn(expandTreePath(path, "properties", "value", delta + ""), newValue.get(delta));
              state = state.setIn(expandTreePath(path, "properties", "valueType", delta + ""), newValueType.get(delta));
            }
          }
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {string} name
         * @param {*} value
         */
        var setOperatorOption$1 = function setOperatorOption(state, path, name, value) {
          var currentRule = state.getIn(expandTreePath(path));
          if (!currentRule) {
            // incorrect path
            return state;
          }
          return state.setIn(expandTreePath(path, "properties", "operatorOptions", name), value);
        };

        /**
         * @param {Immutable.Map} state
         */
        var checkEmptyGroups = function checkEmptyGroups(state, config) {
          var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;
          if (!canLeaveEmptyGroup) {
            state = fixEmptyGroupsInTree(state);
          }
          return state;
        };
        var initEmptyValueLists = function initEmptyValueLists(state, path, config, operatorCardinality) {
          if (!operatorCardinality) {
            var field = state.getIn(expandTreePath(path, "properties", "field")) || null;
            var operator = state.getIn(expandTreePath(path, "properties", "operator")) || null;
            var operatorConfig = getOperatorConfig$4(config, operator, field);
            operatorCardinality = operator ? getOpCardinality$1(operatorConfig) : null;
          }
          for (var _i = 0, _arr = ["value", "valueType", "valueError", "valueSrc"]; _i < _arr.length; _i++) {
            var k = _arr[_i];
            if (!state.getIn(expandTreePath(path, "properties", k))) {
              state = state.setIn(expandTreePath(path, "properties", k), new Immutable.List(operatorCardinality ? Array.from({
                length: operatorCardinality
              }) : []));
            }
          }
          return state;
        };

        // convert children deeply from JS to Immutable
        var _addChildren1 = function _addChildren1(config, item, children) {
          if (children && Array.isArray(children)) {
            item.children1 = new Immutable.OrderedMap(children.reduce(function (map, it) {
              var _it$id;
              var id1 = (_it$id = it.id) !== null && _it$id !== void 0 ? _it$id : uuid();
              var it1 = _objectSpread$k(_objectSpread$k({}, it), {}, {
                properties: defaultItemProperties(config, it).merge(fromJS(it.properties) || {}),
                id: id1
              });
              _addChildren1(config, it1, it1.children1);
              //todo: guarantee order
              return _objectSpread$k(_objectSpread$k({}, map), {}, _defineProperty$4({}, id1, new Immutable.Map(it1)));
            }, {}));
          }
        };
        var getField = function getField(state, path) {
          var field = state.getIn(expandTreePath(path, "properties", "field")) || null;
          return field;
        };
        var emptyDrag = {
          dragging: {
            id: null,
            x: null,
            y: null,
            w: null,
            h: null
          },
          mousePos: {},
          dragStart: {
            id: null
          }
        };
        var getActionMeta = function getActionMeta(action, state) {
          if (!action || !action.type) return null;
          var actionKeysToOmit = ["config", "asyncListValues"];
          var actionTypesToIgnore = [SET_TREE, SET_DRAG_START$1, SET_DRAG_PROGRESS$1, SET_DRAG_END$1];
          var meta = mapValues$1(omit$1(action, actionKeysToOmit), applyToJS);
          var affectedField = action.path && getField(state.tree, action.path) || action.field;
          if (affectedField) {
            var _affectedField;
            if ((_affectedField = affectedField) !== null && _affectedField !== void 0 && _affectedField.toJS) affectedField = affectedField.toJS();
            meta.affectedField = affectedField;
          }
          if (actionTypesToIgnore.includes(action.type) || action.type.indexOf("@@redux") == 0) meta = null;
          return meta;
        };

        /**
         * @param {Immutable.Map} state
         * @param {object} action
         */
        const TreeStore = function TreeStore(initialConfig, tree, getMemoizedTree, setLastTree, getLastConfig) {
          var initTree = tree;
          var emptyState = _objectSpread$k({
            tree: initTree
          }, emptyDrag);
          return function () {
            var _ref3, _getLastConfig;
            var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyState;
            var action = arguments.length > 1 ? arguments[1] : undefined;
            var config = (_ref3 = (_getLastConfig = getLastConfig === null || getLastConfig === void 0 ? void 0 : getLastConfig()) !== null && _getLastConfig !== void 0 ? _getLastConfig : action === null || action === void 0 ? void 0 : action.config) !== null && _ref3 !== void 0 ? _ref3 : initialConfig;
            var unset = {
              __lastAction: undefined
            };
            var set = {};
            var actionMeta = getActionMeta(action, state);
            switch (action === null || action === void 0 ? void 0 : action.type) {
              case SET_TREE:
                {
                  var validatedTree = getMemoizedTree(config, action.tree);
                  set.tree = validatedTree;
                  break;
                }
              case ADD_CASE_GROUP:
                {
                  set.tree = addNewGroup(state.tree, action.path, "case_group", action.id, action.properties, config, action.children, action.meta);
                  break;
                }
              case ADD_GROUP:
                {
                  set.tree = addNewGroup(state.tree, action.path, "group", action.id, action.properties, config, action.children, action.meta);
                  break;
                }
              case REMOVE_GROUP:
                {
                  set.tree = removeGroup$1(state.tree, action.path, config);
                  break;
                }
              case ADD_RULE:
                {
                  set.tree = addItem(state.tree, action.path, action.ruleType, action.id, action.properties, config, action.children);
                  break;
                }
              case REMOVE_RULE:
                {
                  set.tree = removeRule$1(state.tree, action.path, config);
                  break;
                }
              case SET_CONJUNCTION:
                {
                  set.tree = setConjunction$1(state.tree, action.path, action.conjunction);
                  break;
                }
              case SET_NOT:
                {
                  set.tree = setNot$1(state.tree, action.path, action.not);
                  break;
                }
              case SET_FIELD:
                {
                  var _setField = setField$1(state.tree, action.path, action.field, config, action.asyncListValues, action._meta),
                    newTree = _setField.state;
                  set.tree = newTree;
                  break;
                }
              case SET_FIELD_SRC:
                {
                  set.tree = setFieldSrc$1(state.tree, action.path, action.srcKey, config);
                  break;
                }
              case SET_LOCK:
                {
                  set.tree = setLock$1(state.tree, action.path, action.lock);
                  break;
                }
              case SET_OPERATOR:
                {
                  set.tree = setOperator$1(state.tree, action.path, action.operator, config);
                  break;
                }
              case SET_VALUE:
                {
                  var _setValue = setValue$1(state.tree, action.path, action.delta, action.value, action.valueType, config, action.asyncListValues, action._meta),
                    _newTree = _setValue.state;
                  set.tree = _newTree;
                  break;
                }
              case SET_FUNC_VALUE:
                {
                  var _setFuncValue = setFuncValue$1(config, state.tree, action.path, action.delta, action.parentFuncs, action.argKey, action.value, action.valueType, action.asyncListValues, action._meta),
                    _newTree2 = _setFuncValue.state;
                  set.tree = _newTree2;
                  break;
                }
              case SET_VALUE_SRC:
                {
                  set.tree = setValueSrc$1(state.tree, action.path, action.delta, action.srcKey, config, action._meta);
                  break;
                }
              case SET_OPERATOR_OPTION:
                {
                  set.tree = setOperatorOption$1(state.tree, action.path, action.name, action.value);
                  break;
                }
              case MOVE_ITEM:
                {
                  set.tree = moveItem$1(state.tree, action.fromPath, action.toPath, action.placement);
                  break;
                }
              case SET_DRAG_START$1:
                {
                  set.dragStart = action.dragStart;
                  set.dragging = action.dragging;
                  set.mousePos = action.mousePos;
                  break;
                }
              case SET_DRAG_PROGRESS$1:
                {
                  set.mousePos = action.mousePos;
                  set.dragging = action.dragging;
                  break;
                }
              case SET_DRAG_END$1:
                {
                  set.tree = checkEmptyGroups(state.tree, config);
                  set = _objectSpread$k(_objectSpread$k({}, set), emptyDrag);
                  break;
                }
            }
            if (actionMeta) {
              set.__lastAction = actionMeta;
            }
            if (setLastTree && set.tree && state.tree) {
              setLastTree(state.tree);
            }
            return _objectSpread$k(_objectSpread$k(_objectSpread$k({}, state), unset), set);
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.Map} tree
         */
        var setTree = function setTree(config, tree) {
          return {
            type: SET_TREE,
            tree: tree,
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {Immutable.Map} properties
         */
        var addRule = function addRule(config, path, properties) {
          var ruleType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "rule";
          var children = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var parentRuleGroupPath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          return {
            type: ADD_RULE,
            ruleType: ruleType,
            children: children,
            path: toImmutableList(path),
            id: uuid(),
            properties: defaultRuleProperties(config, parentRuleGroupPath).merge(fromJS(properties) || {}),
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         */
        var removeRule = function removeRule(config, path) {
          return {
            type: REMOVE_RULE,
            path: toImmutableList(path),
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {Immutable.Map} properties
         */
        var addDefaultCaseGroup = function addDefaultCaseGroup(config, path, properties) {
          var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          return {
            type: ADD_CASE_GROUP,
            path: toImmutableList(path),
            children: children,
            id: uuid(),
            properties: defaultGroupProperties(config).merge(fromJS(properties) || {}),
            config: config,
            meta: {
              isDefaultCase: true
            }
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {Immutable.Map} properties
         */
        var addCaseGroup = function addCaseGroup(config, path, properties) {
          var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          return {
            type: ADD_CASE_GROUP,
            path: toImmutableList(path),
            children: children,
            id: uuid(),
            properties: defaultGroupProperties(config).merge(fromJS(properties) || {}),
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {Immutable.Map} properties
         */
        var addGroup = function addGroup(config, path, properties) {
          var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          return {
            type: ADD_GROUP,
            path: toImmutableList(path),
            children: children,
            id: uuid(),
            properties: defaultGroupProperties(config).merge(fromJS(properties) || {}),
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         */
        var removeGroup = function removeGroup(config, path) {
          return {
            type: REMOVE_GROUP,
            path: toImmutableList(path),
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Array} fromPath
         * @param {Array} toPath
         * @param {String} placement, see constants PLACEMENT_*
         */
        var moveItem = function moveItem(config, fromPath, toPath, placement) {
          return {
            type: MOVE_ITEM,
            fromPath: toImmutableList(fromPath),
            toPath: toImmutableList(toPath),
            placement: placement,
            config: config
          };
        };
        const tree$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          addCaseGroup,
          addDefaultCaseGroup,
          addGroup,
          addRule,
          moveItem,
          removeGroup,
          removeRule,
          setTree
        }, Symbol.toStringTag, {
          value: 'Module'
        }));

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {string} conjunction
         */
        var setConjunction = function setConjunction(config, path, conjunction) {
          return {
            type: SET_CONJUNCTION,
            path: toImmutableList(path),
            conjunction: conjunction
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {bool} not
         */
        var setNot = function setNot(config, path, not) {
          return {
            type: SET_NOT,
            path: toImmutableList(path),
            not: not
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {bool} lock
         */
        var setLock = function setLock(config, path, lock) {
          return {
            type: SET_LOCK,
            path: toImmutableList(path),
            lock: lock
          };
        };
        const group$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          setConjunction,
          setLock,
          setNot
        }, Symbol.toStringTag, {
          value: 'Module'
        }));

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {string} field
         */
        var setField = function setField(config, path, field, asyncListValues, _meta) {
          return {
            type: SET_FIELD,
            path: toImmutableList(path),
            field: field,
            config: config,
            asyncListValues: asyncListValues,
            _meta: _meta
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {*} srcKey
         */
        var setFieldSrc = function setFieldSrc(config, path, srcKey) {
          return {
            type: SET_FIELD_SRC,
            path: toImmutableList(path),
            srcKey: srcKey,
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {string} operator
         */
        var setOperator = function setOperator(config, path, operator) {
          return {
            type: SET_OPERATOR,
            path: toImmutableList(path),
            operator: operator,
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {integer} delta
         * @param {*} value
         * @param {string} valueType
         * @param {*} asyncListValues
         */
        var setValue = function setValue(config, path, delta, value, valueType, asyncListValues, _meta) {
          return {
            type: SET_VALUE,
            path: toImmutableList(path),
            delta: delta,
            value: value,
            valueType: valueType,
            asyncListValues: asyncListValues,
            config: config,
            _meta: _meta
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {integer} delta
         * @param {*} srcKey
         */
        var setValueSrc = function setValueSrc(config, path, delta, srcKey, _meta) {
          return {
            type: SET_VALUE_SRC,
            path: toImmutableList(path),
            delta: delta,
            srcKey: srcKey,
            config: config,
            _meta: _meta
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {integer} delta
         * @param {Array} parentFuncs
         * @param {string | null} argKey
         * @param {*} value
         * @param {string | "!valueSrc"} valueType
         * @param {*} asyncListValues
         */
        var setFuncValue = function setFuncValue(config, path, delta, parentFuncs, argKey, value, valueType, asyncListValues, _meta) {
          return {
            type: SET_FUNC_VALUE,
            path: toImmutableList(path),
            delta: delta,
            parentFuncs: parentFuncs,
            argKey: argKey,
            value: value,
            valueType: valueType,
            asyncListValues: asyncListValues,
            config: config,
            _meta: _meta
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {string} name
         * @param {*} value
         */
        var setOperatorOption = function setOperatorOption(config, path, name, value) {
          return {
            type: SET_OPERATOR_OPTION,
            path: toImmutableList(path),
            name: name,
            value: value,
            config: config
          };
        };
        const rule$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          setField,
          setFieldSrc,
          setFuncValue,
          setOperator,
          setOperatorOption,
          setValue,
          setValueSrc
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function ownKeys$j(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$j(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$j(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$j(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        var Utils$1 = _objectSpread$j(_objectSpread$j(_objectSpread$j({}, BasicUtils), {}, {
          Export: Export,
          Import: Import,
          // intrenal
          ConfigMixins: ConfigMixins
        }, Export), Import);
        const context = /*#__PURE__*/React.createContext();
        var PLACEMENT_AFTER = "after";
        var PLACEMENT_BEFORE = "before";
        var PLACEMENT_APPEND = "append";
        var PLACEMENT_PREPEND = "prepend";
        var SET_DRAG_PROGRESS = "SET_DRAG_PROGRESS";
        var SET_DRAG_START = "SET_DRAG_START";
        var SET_DRAG_END = "SET_DRAG_END";

        /**
         * @param {Object} mousePos
         * @param {Object} dragging
         */
        var setDragProgress = function setDragProgress(mousePos, dragging) {
          return {
            type: SET_DRAG_PROGRESS,
            mousePos: mousePos,
            dragging: dragging
          };
        };

        /**
         * @param {Object} dragStart
         * @param {Object} dragging
         * @param {Object} mousePos
         */
        var setDragStart = function setDragStart(dragStart, dragging, mousePos) {
          return {
            type: SET_DRAG_START,
            dragStart: dragStart,
            dragging: dragging,
            mousePos: mousePos
          };
        };

        /**
         *
         */
        var setDragEnd = function setDragEnd() {
          return {
            type: SET_DRAG_END
          };
        };
        var tree = tree$1,
          group = group$1,
          rule = rule$1;
        var define_process_env_default = {};
        var getOpCardinality = function getOpCardinality2(opDef) {
          var _opDef$cardinality;
          return (_opDef$cardinality = opDef === null || opDef === void 0 ? void 0 : opDef.cardinality) !== null && _opDef$cardinality !== void 0 ? _opDef$cardinality : 1;
        };
        var truncateString = function truncateString2(str, n, useWordBoundary) {
          if (!n || !str || str.length <= n) {
            return str;
          }
          var subString = str.substr(0, n - 1);
          return subString + "...";
        };
        var immutableEqual = function immutableEqual2(v1, v2) {
          if (v1 === v2) {
            return true;
          } else {
            return v1 === null || v1 === void 0 ? void 0 : v1.equals(v2);
          }
        };
        var shallowEqual$3 = function shallowEqual2(a, b) {
          var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (a === b) {
            return true;
          } else if (Array.isArray(a)) return shallowEqualArrays(a, b, deep);else if (a && typeof a.equals === "function") return a.equals(b);else if (_typeof$3(a) === "object") return shallowEqualObjects(a, b, deep);else return a === b;
        };
        function shallowEqualArrays(arrA, arrB) {
          var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (arrA === arrB) {
            return true;
          }
          if (!arrA || !arrB) {
            return false;
          }
          var len = arrA.length;
          if (arrB.length !== len) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            var isEqual = deep ? shallowEqual$3(arrA[i], arrB[i], deep) : arrA[i] === arrB[i];
            if (!isEqual) {
              return false;
            }
          }
          return true;
        }
        function shallowEqualObjects(objA, objB) {
          var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (objA === objB) {
            return true;
          }
          if (!objA || !objB) {
            return false;
          }
          var aKeys = Object.keys(objA);
          var bKeys = Object.keys(objB);
          var len = aKeys.length;
          if (bKeys.length !== len) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            var key = aKeys[i];
            var isEqual = deep ? shallowEqual$3(objA[key], objB[key], deep) : objA[key] === objB[key];
            if (!isEqual) {
              return false;
            }
          }
          return true;
        }
        var isDev = function isDev2() {
          return typeof process !== "undefined" && define_process_env_default && false;
        };
        var getLogger = function getLogger2() {
          var devMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          var verbose = devMode != void 0 ? devMode : isDev();
          return verbose ? console : {
            error: function error() {},
            log: function log() {},
            warn: function warn() {},
            debug: function debug() {},
            info: function info() {}
          };
        };
        var logger = getLogger();
        var validateAndFixTree = Utils$1.Validation.validateAndFixTree;
        var createValidationMemo = function createValidationMemo() {
          var originalTree;
          var validatedTree;
          var configId;
          return function (config, tree) {
            var oldConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
            var sanitizeTree = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            if (!tree) {
              return null;
            }
            if (config.__configId === configId && (immutableEqual(tree, originalTree) || immutableEqual(tree, validatedTree))) {
              return validatedTree;
            } else {
              configId = config.__configId;
              originalTree = tree;
              if (sanitizeTree === false) {
                validatedTree = validateAndFixTree(tree, null, config, oldConfig || config, false, false, false);
              } else {
                validatedTree = validateAndFixTree(tree, null, config, oldConfig || config);
              }
              return validatedTree;
            }
          };
        };
        var getReactContainerType = function getReactContainerType(el) {
          if (el._reactRootContainer) {
            return "root";
          }
          if (Object.getOwnPropertyNames(el).filter(function (k) {
            return k.startsWith("__reactContainer");
          }).length > 0) {
            return "container";
          }
          return undefined;
        };
        var getReactRootNodeType = function getReactRootNodeType(node) {
          if (!node) {
            return undefined;
          }
          var type = getReactContainerType(node);
          if (type !== undefined) {
            return type;
          } else {
            return getReactRootNodeType(node.parentNode);
          }
        };
        var isUsingLegacyReactDomRender = function isUsingLegacyReactDomRender(node) {
          return getReactRootNodeType(node) === "root";
        };
        var liteShouldComponentUpdate = function liteShouldComponentUpdate(self, config) {
          return function (nextProps, nextState) {
            var prevProps = self.props;
            var prevState = self.state;
            var should = nextProps != prevProps || nextState != prevState;
            if (should) {
              if (prevState == nextState && prevProps != nextProps) {
                var chs = [];
                for (var k in nextProps) {
                  var changed = nextProps[k] != prevProps[k];
                  if (changed) {
                    if (config[k] == "ignore") changed = false;else if (config[k] == "shallow_deep") changed = !shallowEqual$3(nextProps[k], prevProps[k], true);else if (config[k] == "shallow") changed = !shallowEqual$3(nextProps[k], prevProps[k]);else if (typeof config[k] == "function") changed = config[k](nextProps[k], prevProps[k], nextProps, prevProps);
                  }
                  if (changed) chs.push(k);
                }
                if (!chs.length) should = false;
              }
            }
            return should;
          };
        };
        var pureShouldComponentUpdate = function pureShouldComponentUpdate(self) {
          return function (nextProps, nextState) {
            return !shallowEqual$3(self.props, nextProps) || !shallowEqual$3(self.state, nextState);
          };
        };
        var canUseOldComponentWillReceiveProps = function canUseOldComponentWillReceiveProps() {
          var v = React.version.split(".").map(parseInt.bind(null, 10));
          return v[0] == 16 && v[1] < 3 || v[0] < 16;
        };
        var useOnPropsChanged = function useOnPropsChanged(obj) {
          // 1. `shouldComponentUpdate` should be called after `componentWillReceiveProps`
          // 2. `shouldComponentUpdate` should not be used for PureComponent

          // Because `useOnPropsChanged` can only be applied to `Component` not `PureComponent`, make it pure now
          if (!obj.shouldComponentUpdate) {
            obj.shouldComponentUpdate = pureShouldComponentUpdate(obj);
          }
          if (canUseOldComponentWillReceiveProps()) {
            // Use old method
            obj.componentWillReceiveProps = function (nextProps) {
              obj.onPropsChanged(nextProps);
            };
          } else {
            // Simulate `componentWillReceiveProps` with `shouldComponentUpdate`
            var origShouldComponentUpdate = obj.shouldComponentUpdate;
            var newShouldComponentUpdate = function newShouldComponentUpdate(nextProps, nextState) {
              var shouldNotify = !shallowEqual$3(obj.props, nextProps);
              if (shouldNotify) {
                obj.onPropsChanged(nextProps);
              }
              var shouldUpdate = origShouldComponentUpdate.call(obj, nextProps, nextState);
              return shouldUpdate;
            };
            obj.shouldComponentUpdate = newShouldComponentUpdate.bind(obj);
          }
        };
        var bindActionCreators = function bindActionCreators(actionCreators, config, dispatch) {
          return mapValues$1(actionCreators, function (actionCreator) {
            return function () {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return dispatch(actionCreator.apply(void 0, [config].concat(args)));
            };
          });
        };
        const ReactUtils = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          bindActionCreators,
          isUsingLegacyReactDomRender,
          liteShouldComponentUpdate,
          pureShouldComponentUpdate,
          useOnPropsChanged
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function ownKeys$i(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$i(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$i(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$i(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _callSuper$r(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$r() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$r() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$r = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var Query = /*#__PURE__*/function (_Component) {
          function Query(props) {
            var _this;
            _classCallCheck$b(this, Query);
            _this = _callSuper$r(this, Query, [props]);
            _this.shouldComponentUpdate = liteShouldComponentUpdate(_this, {
              tree: function tree(nextValue) {
                if (nextValue === _this.oldValidatedTree && _this.oldValidatedTree === _this.validatedTree) {
                  // Got value dispatched from QueryContainer
                  // Ignore, because we've just rendered it
                  return false;
                }
                return true;
              }
            });
            useOnPropsChanged(_this);
            _this._updateActions(props);

            // For preventive validation (tree and config consistency)
            // When config has changed from QueryContainer, 
            //  but new dispatched validated tree value is not in redux store yet (tree prop is old)
            _this.validatedTree = props.getMemoizedTree(props.config, props.tree, undefined, props.sanitizeTree);
            _this.oldValidatedTree = _this.validatedTree;
            var basicConfig = props.getBasicConfig(props.config);
            props.onInit && props.onInit(_this.validatedTree, basicConfig, undefined, _this.actions);
            return _this;
          }
          _inherits$b(Query, _Component);
          return _createClass$9(Query, [{
            key: "_updateActions",
            value: function _updateActions(props) {
              var config = props.config,
                dispatch = props.dispatch;
              this.actions = bindActionCreators(_objectSpread$i(_objectSpread$i(_objectSpread$i({}, tree), group), rule), config, dispatch);
            }
          }, {
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var onChange = nextProps.onChange;
              var oldConfig = this.props.config;
              var newTree = nextProps.tree;
              this.props.tree;
              var newConfig = nextProps.config;
              this.oldValidatedTree = this.validatedTree;
              this.validatedTree = newTree;
              if (oldConfig !== newConfig) {
                this._updateActions(nextProps);
                this.validatedTree = nextProps.getMemoizedTree(newConfig, newTree, oldConfig);
              }
              var validatedTreeChanged = !immutableEqual(this.validatedTree, this.oldValidatedTree);
              if (validatedTreeChanged) {
                var newBasicConfig = nextProps.getBasicConfig(newConfig);
                onChange && onChange(this.validatedTree, newBasicConfig, nextProps.__lastAction, this.actions);
              }
            }
          }, {
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                renderBuilder = _this$props.renderBuilder,
                dispatch = _this$props.dispatch;
              var builderProps = {
                tree: this.validatedTree,
                actions: this.actions,
                config: config,
                dispatch: dispatch
              };
              return renderBuilder(builderProps);
            }
          }]);
        }(reactExports.Component);
        Query.propTypes = {
          config: PropTypes.object.isRequired,
          onChange: PropTypes.func,
          onInit: PropTypes.func,
          renderBuilder: PropTypes.func,
          tree: PropTypes.any //instanceOf(Immutable.Map)
          //dispatch: PropTypes.func.isRequired,
          //__lastAction
          //getMemoizedTree: PropTypes.func.isRequired,
          //getBasicConfig: PropTypes.func.isRequired,
          //sanitizeTree
        };
        var ConnectedQuery = connect$1(function (state) {
          return {
            tree: state.tree,
            __lastAction: state.__lastAction
          };
        }, null, null, {
          context: context
        })(Query);
        ConnectedQuery.displayName = "ConnectedQuery";
        function _callSuper$q(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$q() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$q() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$q = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var defaultRoot = Utils$1.DefaultUtils.defaultRoot;
        var createConfigMemo = Utils$1.ConfigUtils.createConfigMemo;
        var QueryContainer = /*#__PURE__*/function (_Component) {
          function QueryContainer(props, context) {
            var _this$_reactInternals, _this$_reactInternals2;
            var _this;
            _classCallCheck$b(this, QueryContainer);
            _this = _callSuper$q(this, QueryContainer, [props, context]);
            _this.setLastTree = function (lastTree) {
              if (_this.prevTree) {
                _this.prevprevTree = _this.prevTree;
              }
              _this.prevTree = lastTree;
            };
            _this.getConfig = function () {
              return _this.config;
            };
            _this.shouldComponentUpdate = liteShouldComponentUpdate(_this, {
              value: function value(nextValue, prevValue) {
                return false;
              }
            });
            useOnPropsChanged(_this);
            var _createConfigMemo = createConfigMemo({
                reactIndex: (_this$_reactInternals = (_this$_reactInternals2 = _this._reactInternals) === null || _this$_reactInternals2 === void 0 ? void 0 : _this$_reactInternals2.index) !== null && _this$_reactInternals !== void 0 ? _this$_reactInternals : -1,
                maxSize: 2,
                // current and prev
                canCompile: true
              }),
              getExtendedConfig = _createConfigMemo.getExtendedConfig,
              getBasicConfig = _createConfigMemo.getBasicConfig,
              clearConfigMemo = _createConfigMemo.clearConfigMemo;
            _this.getMemoizedConfig = getExtendedConfig;
            _this.getBasicConfig = getBasicConfig;
            _this.clearConfigMemo = clearConfigMemo;
            _this.getMemoizedTree = createValidationMemo();
            var config = _this.getMemoizedConfig(props);
            var shouldCreateEmptyGroup = config.settings.shouldCreateEmptyGroup;
            var canAddDefaultRule = !shouldCreateEmptyGroup; // if prop `value` is not provided, can add default/empty rule?
            var emptyTree = defaultRoot(config, canAddDefaultRule);
            var sanitizeTree = !!props.value;
            var tree = props.value || emptyTree;
            var validatedTree = _this.getMemoizedTree(config, tree, undefined, sanitizeTree);
            var reducer = TreeStore(config, validatedTree, _this.getMemoizedTree, _this.setLastTree, _this.getConfig);
            var store = createStore(reducer);
            _this.config = config;
            _this.state = {
              store: store
            };
            _this.QueryWrapper = function (pr) {
              return config.settings.renderProvider(pr, config.ctx);
            };
            return _this;
          }
          _inherits$b(QueryContainer, _Component);
          return _createClass$9(QueryContainer, [{
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
              this.clearConfigMemo();
            }
          }, {
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              // compare configs
              var prevProps = this.props;
              var oldConfig = this.config;
              var nextConfig = this.getMemoizedConfig(nextProps);
              var isConfigChanged = oldConfig !== nextConfig;

              // compare trees
              var storeValue = this.state.store.getState().tree;
              var isTreeChanged = !immutableEqual(nextProps.value, this.props.value) && !immutableEqual(nextProps.value, storeValue);
              var currentTree = isTreeChanged ? nextProps.value || defaultRoot(nextProps) : storeValue;
              var isTreeTrulyChanged = isTreeChanged && !immutableEqual(nextProps.value, this.prevTree) && !immutableEqual(nextProps.value, this.prevprevTree);
              this.sanitizeTree = isTreeTrulyChanged || isConfigChanged;
              if (isConfigChanged) {
                if (prevProps.settings.renderProvider !== nextProps.settings.renderProvider) {
                  this.QueryWrapper = function (props) {
                    return nextConfig.settings.renderProvider(props, nextConfig.ctx);
                  };
                }
                this.config = nextConfig;
              }
              if (isTreeChanged || isConfigChanged) {
                var validatedTree = this.getMemoizedTree(nextConfig, currentTree, oldConfig, this.sanitizeTree);
                //return Promise.resolve().then(() => {
                this.state.store.dispatch(tree.setTree(nextConfig, validatedTree));
                //});
              }
            }
          }, {
            key: "render",
            value: function render() {
              // `get_children` is deprecated!
              var _this$props = this.props,
                renderBuilder = _this$props.renderBuilder,
                get_children = _this$props.get_children,
                onChange = _this$props.onChange,
                onInit = _this$props.onInit;
              var store = this.state.store;
              var config = this.config;
              var QueryWrapper = this.QueryWrapper;
              return /*#__PURE__*/React.createElement(QueryWrapper, {
                config: config
              }, /*#__PURE__*/React.createElement(Provider, {
                store: store,
                context: context
              }, /*#__PURE__*/React.createElement(ConnectedQuery, {
                config: config,
                getMemoizedTree: this.getMemoizedTree,
                getBasicConfig: this.getBasicConfig,
                sanitizeTree: this.sanitizeTree,
                onChange: onChange,
                onInit: onInit,
                renderBuilder: renderBuilder || get_children
              })));
            }
          }]);
        }(reactExports.Component);
        QueryContainer.propTypes = {
          //config
          conjunctions: PropTypes.object.isRequired,
          fields: PropTypes.object.isRequired,
          types: PropTypes.object.isRequired,
          operators: PropTypes.object.isRequired,
          widgets: PropTypes.object.isRequired,
          settings: PropTypes.object.isRequired,
          ctx: PropTypes.object.isRequired,
          onChange: PropTypes.func,
          onInit: PropTypes.func,
          renderBuilder: PropTypes.func,
          value: PropTypes.any //instanceOf(Immutable.Map)
        };
        function _callSuper$p(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$p() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$p() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$p = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var getFieldConfig$7 = Utils$1.ConfigUtils.getFieldConfig;
        var createRuleContainer = function createRuleContainer(Rule) {
          var _RuleContainer;
          return _RuleContainer = /*#__PURE__*/function (_Component) {
            function RuleContainer(props) {
              var _this;
              _classCallCheck$b(this, RuleContainer);
              _this = _callSuper$p(this, RuleContainer, [props]);
              _this.dummyFn = function () {};
              _this.removeSelf = function () {
                _this.props.actions.removeRule(_this.props.path);
              };
              _this.setLock = function () {
                var lock = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                _this.props.actions.setLock(_this.props.path, lock);
              };
              _this.setField = function (field, asyncListValues, _meta) {
                _this.props.actions.setField(_this.props.path, field, asyncListValues, _meta);
              };
              _this.setFieldSrc = function (srcKey) {
                _this.props.actions.setFieldSrc(_this.props.path, srcKey);
              };
              _this.setOperator = function (operator) {
                _this.props.actions.setOperator(_this.props.path, operator);
              };
              _this.setOperatorOption = function (name, value) {
                _this.props.actions.setOperatorOption(_this.props.path, name, value);
              };
              _this.setValue = function (delta, value, type, asyncListValues, _meta) {
                _this.props.actions.setValue(_this.props.path, delta, value, type, asyncListValues, _meta);
              };
              _this.setValueSrc = function (delta, srcKey, _meta) {
                _this.props.actions.setValueSrc(_this.props.path, delta, srcKey, _meta);
              };
              // can be used for both LHS and LHS
              _this.setFuncValue = function (delta, parentFuncs, argKey, value, type, asyncListValues, _meta) {
                _this.props.actions.setFuncValue(_this.props.path, delta, parentFuncs, argKey, value, type, asyncListValues, _meta);
              };
              _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_this);
              _this.dummyFn.isDummyFn = true;
              return _this;
            }
            _inherits$b(RuleContainer, _Component);
            return _createClass$9(RuleContainer, [{
              key: "shouldComponentUpdate",
              value: function shouldComponentUpdate(nextProps, nextState) {
                var prevProps = this.props;
                var prevState = this.state;
                var should = this.pureShouldComponentUpdate(nextProps, nextState);
                if (should) {
                  if (prevState == nextState && prevProps != nextProps) {
                    var draggingId = nextProps.dragging.id || prevProps.dragging.id;
                    var isDraggingMe = draggingId == nextProps.id;
                    var chs = [];
                    for (var k in nextProps) {
                      var changed = nextProps[k] != prevProps[k];
                      if (k == "dragging" && !isDraggingMe) {
                        changed = false; //dragging another item -> ignore
                      }
                      if (changed) {
                        chs.push(k);
                      }
                    }
                    if (!chs.length) should = false;
                  }
                }
                return should;
              }
            }, {
              key: "render",
              value: function render() {
                var isDraggingMe = this.props.dragging.id == this.props.id;
                var fieldConfig = getFieldConfig$7(this.props.config, this.props.field);
                var fieldType = this.props.fieldType || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) || null;
                var showErrorMessage = this.props.config.settings.showErrorMessage;
                fieldConfig && fieldConfig.type == "!struct";
                var isInDraggingTempo = !isDraggingMe && this.props.isDraggingTempo;
                var _this$props = this.props,
                  valueError = _this$props.valueError,
                  fieldError = _this$props.fieldError;
                var oneError = [fieldError].concat(_toConsumableArray((valueError === null || valueError === void 0 ? void 0 : valueError.toArray()) || [])).filter(function (e) {
                  return !!e;
                }).shift() || null;
                var hasError = oneError != null && showErrorMessage;
                return /*#__PURE__*/React.createElement("div", {
                  className: classNames("group-or-rule-container", "rule-container", hasError ? "rule-with-error" : null),
                  "data-id": this.props.id
                }, [isDraggingMe ? /*#__PURE__*/React.createElement(Rule, {
                  key: "dragging",
                  id: this.props.id,
                  groupId: this.props.groupId,
                  isDraggingMe: true,
                  isDraggingTempo: true,
                  dragging: this.props.dragging,
                  setField: this.dummyFn,
                  setFieldSrc: this.dummyFn,
                  setFuncValue: this.dummyFn,
                  setOperator: this.dummyFn,
                  setOperatorOption: this.dummyFn,
                  setLock: this.dummyFn,
                  removeSelf: this.dummyFn,
                  setValue: this.dummyFn,
                  setValueSrc: this.dummyFn,
                  selectedField: this.props.field || null,
                  selectedFieldSrc: this.props.fieldSrc || "field",
                  selectedFieldType: fieldType,
                  parentField: this.props.parentField || null,
                  selectedOperator: this.props.operator || null,
                  value: this.props.value || null,
                  valueSrc: this.props.valueSrc || null,
                  valueType: this.props.valueType || null,
                  valueError: this.props.valueError || null,
                  fieldError: this.props.fieldError || null,
                  operatorOptions: this.props.operatorOptions,
                  config: this.props.config,
                  reordableNodesCnt: this.props.reordableNodesCnt,
                  totalRulesCnt: this.props.totalRulesCnt,
                  asyncListValues: this.props.asyncListValues,
                  isLocked: this.props.isLocked,
                  isTrueLocked: this.props.isTrueLocked,
                  parentReordableNodesCnt: this.props.parentReordableNodesCnt
                }) : null, /*#__PURE__*/React.createElement(Rule, {
                  key: this.props.id,
                  id: this.props.id,
                  groupId: this.props.groupId,
                  isDraggingMe: isDraggingMe,
                  isDraggingTempo: isInDraggingTempo,
                  onDragStart: this.props.onDragStart,
                  setLock: isInDraggingTempo ? this.dummyFn : this.setLock,
                  removeSelf: isInDraggingTempo ? this.dummyFn : this.removeSelf,
                  setField: isInDraggingTempo ? this.dummyFn : this.setField,
                  setFieldSrc: isInDraggingTempo ? this.dummyFn : this.setFieldSrc,
                  setFuncValue: isInDraggingTempo ? this.dummyFn : this.setFuncValue,
                  setOperator: isInDraggingTempo ? this.dummyFn : this.setOperator,
                  setOperatorOption: isInDraggingTempo ? this.dummyFn : this.setOperatorOption,
                  setValue: isInDraggingTempo ? this.dummyFn : this.setValue,
                  setValueSrc: isInDraggingTempo ? this.dummyFn : this.setValueSrc,
                  selectedField: this.props.field || null,
                  selectedFieldSrc: this.props.fieldSrc || "field",
                  selectedFieldType: fieldType,
                  parentField: this.props.parentField || null,
                  selectedOperator: this.props.operator || null,
                  value: this.props.value || null,
                  valueSrc: this.props.valueSrc || null,
                  valueType: this.props.valueType || null,
                  valueError: this.props.valueError || null,
                  fieldError: this.props.fieldError || null,
                  operatorOptions: this.props.operatorOptions,
                  config: this.props.config,
                  reordableNodesCnt: this.props.reordableNodesCnt,
                  totalRulesCnt: this.props.totalRulesCnt,
                  asyncListValues: this.props.asyncListValues,
                  isLocked: this.props.isLocked,
                  isTrueLocked: this.props.isTrueLocked,
                  parentReordableNodesCnt: this.props.parentReordableNodesCnt
                })]);
              }
            }]);
          }(reactExports.Component), _RuleContainer.propTypes = {
            id: PropTypes.string.isRequired,
            groupId: PropTypes.string,
            config: PropTypes.object.isRequired,
            path: PropTypes.any.isRequired,
            //instanceOf(Immutable.List)
            operator: PropTypes.string,
            field: PropTypes.any,
            fieldSrc: PropTypes.string,
            fieldType: PropTypes.string,
            actions: PropTypes.object.isRequired,
            //{removeRule: Function, setField, setFieldSrc, setOperator, setOperatorOption, setValue, setValueSrc, ...}
            onDragStart: PropTypes.func,
            value: PropTypes.any,
            //depends on widget
            valueSrc: PropTypes.any,
            asyncListValues: PropTypes.array,
            valueError: PropTypes.any,
            fieldError: PropTypes.string,
            operatorOptions: PropTypes.object,
            reordableNodesCnt: PropTypes.number,
            parentField: PropTypes.string,
            //from RuleGroup
            isLocked: PropTypes.bool,
            isTrueLocked: PropTypes.bool,
            //connected:
            dragging: PropTypes.object,
            //{id, x, y, w, h}
            isDraggingTempo: PropTypes.bool
          }, _RuleContainer;
        };
        const RuleContainer = function RuleContainer(Rule) {
          var ConnectedRuleContainer = connect$1(function (state) {
            return {
              dragging: state.dragging
            };
          }, null, null, {
            context: context
          })(createRuleContainer(Rule));
          ConnectedRuleContainer.displayName = "ConnectedRuleContainer";
          return ConnectedRuleContainer;
        };
        function _callSuper$o(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$o() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$o() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$o = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var clone$2 = Utils$1.clone;
        var getFlatTree = Utils$1.TreeUtils.getFlatTree;
        var _isReorderingTree = false;
        var createSortableContainer = function createSortableContainer(Builder) {
          var _SortableContainer;
          var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return _SortableContainer = /*#__PURE__*/function (_Component) {
            function SortableContainer(props) {
              var _this;
              _classCallCheck$b(this, SortableContainer);
              _this = _callSuper$o(this, SortableContainer, [props]);
              _this._getEventTarget = function (e, dragStart) {
                return e && e.__mocked_window || document.body || window;
              };
              _this.onDragStart = function (id, dom, e) {
                var treeEl = dom.closest(".query-builder");
                if (_this._isUsingLegacyReactDomRender === undefined) {
                  _this._isUsingLegacyReactDomRender = isUsingLegacyReactDomRender(treeEl);
                }
                document.body.classList.add("qb-dragging");
                treeEl.classList.add("qb-dragging");
                var treeElContainer = treeEl.closest(".query-builder-container") || treeEl;
                treeElContainer = _this._getScrollParent(treeElContainer) || document.body;
                var scrollTop = treeElContainer.scrollTop;
                _this._getDraggableNodeEl(treeEl);
                _this._getPlaceholderNodeEl(treeEl);
                var tmpAllGroups = treeEl.querySelectorAll(".group--children");
                var anyGroup = tmpAllGroups.length ? tmpAllGroups[0] : null;
                var groupPadding;
                if (anyGroup) {
                  groupPadding = window.getComputedStyle(anyGroup, null).getPropertyValue("padding-left");
                  groupPadding = parseInt(groupPadding);
                }
                var dragging = {
                  id: id,
                  x: dom.offsetLeft,
                  y: dom.offsetTop,
                  w: dom.offsetWidth,
                  h: dom.offsetHeight,
                  itemInfo: _this.tree.items[id],
                  paddingLeft: groupPadding
                };
                var dragStart = {
                  id: id,
                  x: dom.offsetLeft,
                  y: dom.offsetTop,
                  scrollTop: scrollTop,
                  clientX: e.clientX,
                  clientY: e.clientY,
                  itemInfo: clone$2(_this.tree.items[id]),
                  treeEl: treeEl,
                  treeElContainer: treeElContainer
                };
                var mousePos = {
                  clientX: e.clientX,
                  clientY: e.clientY
                };
                var target = _this._getEventTarget(e, dragStart);
                _this.eventTarget = target;
                target.addEventListener("mousemove", _this.onDrag);
                target.addEventListener("mouseup", _this.onDragEnd);
                _this.props.setDragStart(dragStart, dragging, mousePos);
              };
              _this.onDrag = function (e) {
                var doHandleDrag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                var dragging = Object.assign({}, _this.props.dragging);
                var startDragging = _this.props.dragStart;
                var paddingLeft = dragging.paddingLeft; //this.props.paddingLeft;
                var treeElContainer = startDragging.treeElContainer;
                var scrollTop = treeElContainer.scrollTop;
                dragging.itemInfo = _this.tree.items[dragging.id];
                if (!dragging.itemInfo) {
                  return;
                }
                var mousePos = {
                  clientX: e.clientX,
                  clientY: e.clientY
                };
                var startMousePos = {
                  clientX: startDragging.clientX,
                  clientY: startDragging.clientY
                };
                if (e.__mock_dom) {
                  var treeEl = startDragging.treeEl;
                  var dragEl = _this._getDraggableNodeEl(treeEl);
                  var plhEl = _this._getPlaceholderNodeEl(treeEl);
                  e.__mock_dom({
                    treeEl: treeEl,
                    dragEl: dragEl,
                    plhEl: plhEl
                  });
                }

                //first init plX/plY
                if (!startDragging.plX) {
                  var _treeEl = startDragging.treeEl;
                  var _plhEl2 = _this._getPlaceholderNodeEl(_treeEl);
                  if (_plhEl2) {
                    startDragging.plX = _plhEl2.getBoundingClientRect().left + window.scrollX;
                    startDragging.plY = _plhEl2.getBoundingClientRect().top + window.scrollY;
                  }
                }
                var startX = startDragging.x;
                var startY = startDragging.y;
                var startClientX = startDragging.clientX;
                var startClientY = startDragging.clientY;
                var startScrollTop = startDragging.scrollTop;
                var pos = {
                  x: startX + (e.clientX - startClientX),
                  y: startY + (e.clientY - startClientY) + (scrollTop - startScrollTop)
                };
                dragging.x = pos.x;
                dragging.y = pos.y;
                dragging.paddingLeft = paddingLeft;
                dragging.mousePos = mousePos;
                dragging.startMousePos = startMousePos;
                _this.props.setDragProgress(mousePos, dragging);
                var moved = doHandleDrag ? _this.handleDrag(dragging, e, CanMoveFn) : false;
                if (!moved) {
                  if (e.preventDefault) e.preventDefault();
                }
              };
              _this.onDragEnd = function () {
                var treeEl = _this.props.dragStart.treeEl;
                _this.props.setDragEnd();
                treeEl.classList.remove("qb-dragging");
                document.body.classList.remove("qb-dragging");
                _this._cacheEls = {};
                var target = _this.eventTarget || _this._getEventTarget();
                target.removeEventListener("mousemove", _this.onDrag);
                target.removeEventListener("mouseup", _this.onDragEnd);
              };
              _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_this);
              useOnPropsChanged(_this);
              _this.onPropsChanged(props);
              return _this;
            }
            _inherits$b(SortableContainer, _Component);
            return _createClass$9(SortableContainer, [{
              key: "onPropsChanged",
              value: function onPropsChanged(nextProps) {
                this.tree = getFlatTree(nextProps.tree);
              }
            }, {
              key: "shouldComponentUpdate",
              value: function shouldComponentUpdate(nextProps, nextState) {
                var prevProps = this.props;
                var prevState = this.state;
                var should = this.pureShouldComponentUpdate(nextProps, nextState);
                if (should) {
                  if (prevState == nextState && prevProps != nextProps) {
                    var chs = [];
                    for (var k in nextProps) {
                      var changed = nextProps[k] != prevProps[k];
                      if (changed) {
                        //don't render <Builder> on dragging - appropriate redux-connected components will do it
                        if (k != "dragging" && k != "mousePos") chs.push(k);
                      }
                    }
                    if (!chs.length) should = false;
                  }
                }
                return should;
              }
            }, {
              key: "componentDidUpdate",
              value: function componentDidUpdate(_prevProps, _prevState) {
                var dragging = this.props.dragging;
                var startDragging = this.props.dragStart;
                _isReorderingTree = false;
                if (startDragging && startDragging.id) {
                  dragging.itemInfo = this.tree.items[dragging.id];
                  if (dragging.itemInfo) {
                    if (dragging.itemInfo.index != startDragging.itemInfo.index || dragging.itemInfo.parent != startDragging.itemInfo.parent) {
                      var treeEl = startDragging.treeEl;
                      var treeElContainer = startDragging.treeElContainer;
                      var plhEl = this._getPlaceholderNodeEl(treeEl, true);
                      if (plhEl) {
                        var plX = plhEl.getBoundingClientRect().left + window.scrollX;
                        var plY = plhEl.getBoundingClientRect().top + window.scrollY;
                        var oldPlX = startDragging.plX;
                        var oldPlY = startDragging.plY;
                        var scrollTop = treeElContainer.scrollTop;
                        startDragging.plX = plX;
                        startDragging.plY = plY;
                        startDragging.itemInfo = clone$2(dragging.itemInfo);
                        startDragging.y = plhEl.offsetTop;
                        startDragging.x = plhEl.offsetLeft;
                        startDragging.clientY += plY - oldPlY;
                        startDragging.clientX += plX - oldPlX;
                        if (treeElContainer != document.body) startDragging.scrollTop = scrollTop;
                        this.onDrag(this.props.mousePos, false);
                      }
                    }
                  }
                }
              }
            }, {
              key: "_getNodeElById",
              value: function _getNodeElById(treeEl, indexId) {
                var ignoreCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                if (indexId == null) return null;
                if (!this._cacheEls) this._cacheEls = {};
                var el = this._cacheEls[indexId];
                if (el && document.contains(el) && !ignoreCache) return el;
                el = treeEl.querySelector('.group-or-rule-container[data-id="' + indexId + '"]');
                this._cacheEls[indexId] = el;
                return el;
              }
            }, {
              key: "_getDraggableNodeEl",
              value: function _getDraggableNodeEl(treeEl) {
                var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                if (!this._cacheEls) this._cacheEls = {};
                var el = this._cacheEls["draggable"];
                if (el && document.contains(el) && !ignoreCache) return el;
                var els = treeEl.getElementsByClassName("qb-draggable");
                el = els.length ? els[0] : null;
                this._cacheEls["draggable"] = el;
                return el;
              }
            }, {
              key: "_getPlaceholderNodeEl",
              value: function _getPlaceholderNodeEl(treeEl) {
                var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                if (!this._cacheEls) this._cacheEls = {};
                var el = this._cacheEls["placeholder"];
                if (el && document.contains(el) && !ignoreCache) return el;
                var els = treeEl.getElementsByClassName("qb-placeholder");
                el = els.length ? els[0] : null;
                this._cacheEls["placeholder"] = el;
                return el;
              }
            }, {
              key: "_isScrollable",
              value: function _isScrollable(node) {
                var overflowY = window.getComputedStyle(node)["overflow-y"];
                return (overflowY === "scroll" || overflowY === "auto") && node.scrollHeight > node.offsetHeight;
              }
            }, {
              key: "_getScrollParent",
              value: function _getScrollParent(node) {
                if (node == null) return null;
                if (node === document.body || this._isScrollable(node)) {
                  return node;
                } else {
                  return this._getScrollParent(node.parentNode);
                }
              }
            }, {
              key: "handleDrag",
              value: function handleDrag(dragInfo, e, canMoveFn) {
                var _this2 = this;
                var canMoveBeforeAfterGroup = true;
                var itemInfo = dragInfo.itemInfo;
                var paddingLeft = dragInfo.paddingLeft;
                var moveInfo = null;
                var treeEl = this.props.dragStart.treeEl;
                var dragId = dragInfo.id;
                var dragEl = this._getDraggableNodeEl(treeEl);
                var plhEl = this._getPlaceholderNodeEl(treeEl);
                var dragRect, plhRect, hovRect, treeRect;
                if (dragEl && plhEl) {
                  dragRect = dragEl.getBoundingClientRect();
                  plhRect = plhEl.getBoundingClientRect();
                  if (!plhRect.width) {
                    return;
                  }
                  var dragDirs = {
                    hrz: 0,
                    vrt: 0
                  };
                  if (dragRect.top < plhRect.top) dragDirs.vrt = -1; //up
                  else if (dragRect.bottom > plhRect.bottom) dragDirs.vrt = +1; //down
                  if (dragRect.left > plhRect.left) dragDirs.hrz = +1; //right
                  else if (dragRect.left < plhRect.left) dragDirs.hrz = -1; //left

                  treeRect = treeEl.getBoundingClientRect();
                  var trgCoord = {
                    x: treeRect.left + (treeRect.right - treeRect.left) / 2,
                    y: dragDirs.vrt >= 0 ? dragRect.bottom : dragRect.top
                  };
                  var hovCNodeEl;
                  if (e.__mocked_hov_container) {
                    hovCNodeEl = e.__mocked_hov_container;
                  } else {
                    var hovNodeEl = document.elementFromPoint(trgCoord.x, trgCoord.y - 1);
                    hovCNodeEl = hovNodeEl ? hovNodeEl.closest(".group-or-rule-container") : null;
                    if (!hovCNodeEl && hovNodeEl && hovNodeEl.classList.contains("query-builder-container")) {
                      var _hovNodeEl$firstChild;
                      // fix 2022-01-24 - get root .group-or-rule-container
                      var rootGroupContainer = hovNodeEl === null || hovNodeEl === void 0 || (_hovNodeEl$firstChild = hovNodeEl.firstChild) === null || _hovNodeEl$firstChild === void 0 ? void 0 : _hovNodeEl$firstChild.firstChild;
                      if (rootGroupContainer && rootGroupContainer.classList.contains("group-or-rule-container")) {
                        hovCNodeEl = rootGroupContainer;
                      }
                    }
                  }
                  if (!hovCNodeEl) {
                    logger.log("out of tree bounds!");
                  } else {
                    var isGroup = hovCNodeEl.classList.contains("group-container");
                    var hovNodeId = hovCNodeEl.getAttribute("data-id");
                    var hovEl = hovCNodeEl;
                    var doAppend = false;
                    var doPrepend = false;
                    if (hovEl) {
                      hovRect = hovEl.getBoundingClientRect();
                      var hovHeight = hovRect.bottom - hovRect.top;
                      var hovII = this.tree.items[hovNodeId];
                      if (!hovII) {
                        throw new Error("There is an issue with rendering. If you use Next.js, please check getServerSideProps() method.");
                      }
                      var trgRect = null,
                        trgEl = null,
                        trgII = null,
                        altII = null; //for canMoveBeforeAfterGroup

                      if (dragDirs.vrt == 0) {
                        trgII = itemInfo;
                        trgEl = plhEl;
                        if (trgEl) trgRect = trgEl.getBoundingClientRect();
                      } else {
                        if (isGroup) {
                          if (dragDirs.vrt > 0) {
                            //down
                            //take group header (for prepend only)
                            var hovInnerEl = hovCNodeEl.getElementsByClassName("group--header");
                            var hovEl2 = hovInnerEl.length ? hovInnerEl[0] : null;
                            if (hovEl2) {
                              var hovRect2 = hovEl2.getBoundingClientRect();
                              var hovHeight2 = hovRect2.bottom - hovRect2.top;
                              var isOverHover = dragRect.bottom - hovRect2.top > hovHeight2 * 3 / 4;
                              if (isOverHover && hovII.top > dragInfo.itemInfo.top) {
                                trgII = hovII;
                                trgRect = hovRect2;
                                trgEl = hovEl2;
                                doPrepend = true;
                              }
                            }
                          } else if (dragDirs.vrt < 0) {
                            //up
                            if (hovII.lev >= itemInfo.lev) {
                              //take whole group
                              var isClimbToHover = hovRect.bottom - dragRect.top >= 2;
                              if (isClimbToHover && hovII.top < dragInfo.itemInfo.top) {
                                trgII = hovII;
                                trgRect = hovRect;
                                trgEl = hovEl;
                                doAppend = true;
                              }
                            }
                          }
                          if (!doPrepend && !doAppend || canMoveBeforeAfterGroup) {
                            //take whole group and check if we can move before/after group
                            var _isOverHover = dragDirs.vrt < 0 //up
                            ? hovRect.bottom - dragRect.top > hovHeight - 5 : dragRect.bottom - hovRect.top > hovHeight - 5;
                            if (_isOverHover) {
                              if (!doPrepend && !doAppend) {
                                trgII = hovII;
                                trgRect = hovRect;
                                trgEl = hovEl;
                              }
                              {
                                altII = hovII;
                              }
                            }
                          }
                        } else {
                          //check if we can move before/after group
                          var _isOverHover2 = dragDirs.vrt < 0 //up
                          ? hovRect.bottom - dragRect.top > hovHeight / 2 : dragRect.bottom - hovRect.top > hovHeight / 2;
                          if (_isOverHover2) {
                            trgII = hovII;
                            trgRect = hovRect;
                            trgEl = hovEl;
                          }
                        }
                      }
                      var isSamePos = trgII && trgII.id == dragId;
                      if (trgRect) {
                        var dragLeftOffset = dragRect.left - treeRect.left;
                        trgRect.left - treeRect.left;
                        var dragLev = Math.max(0, Math.round(dragLeftOffset / paddingLeft));

                        //find all possible moves
                        var availMoves = [];
                        var altMoves = []; //alternatively can move after/before group, if can't move into it
                        if (isSamePos) ;else {
                          if (isGroup) {
                            if (doAppend) {
                              availMoves.push([PLACEMENT_APPEND, trgII, trgII.lev + 1]);
                            } else if (doPrepend) {
                              availMoves.push([PLACEMENT_PREPEND, trgII, trgII.lev + 1]);
                            }
                            //alt
                            if (altII) {
                              // fix 2022-01-24: do prepend/append instead of before/after for root
                              var isToRoot = altII.lev == 0;
                              // fix 2022-01-25: fix prepend/append instead of before/after for case_group
                              var isToCase = altII.type == "case_group" && itemInfo.type != "case_group";
                              var prevCaseId = altII.prev && this.tree.items[altII.prev].caseId;
                              var nextCaseId = altII.next && this.tree.items[altII.next].caseId;
                              if (itemInfo.caseId == prevCaseId) prevCaseId = null;
                              if (itemInfo.caseId == nextCaseId) nextCaseId = null;
                              var prevCase = prevCaseId && this.tree.items[prevCaseId];
                              var nextCase = nextCaseId && this.tree.items[nextCaseId];
                              if (dragDirs.vrt > 0) {
                                //down
                                if (isToRoot) {
                                  altMoves.push([PLACEMENT_APPEND, altII, altII.lev + 1]);
                                } else if (isToCase && nextCase) {
                                  altMoves.push([PLACEMENT_PREPEND, nextCase, nextCase.lev + 1]);
                                } else {
                                  altMoves.push([PLACEMENT_AFTER, altII, altII.lev]);
                                }
                              } else if (dragDirs.vrt < 0) {
                                //up
                                if (isToRoot) {
                                  altMoves.push([PLACEMENT_PREPEND, altII, altII.lev + 1]);
                                } else if (isToCase && prevCase) {
                                  altMoves.push([PLACEMENT_APPEND, prevCase, prevCase.lev + 1]);
                                } else {
                                  altMoves.push([PLACEMENT_BEFORE, altII, altII.lev]);
                                }
                              }
                            }
                          }
                          if (!doAppend && !doPrepend) {
                            if (dragDirs.vrt < 0) {
                              //up
                              availMoves.push([PLACEMENT_BEFORE, trgII, trgII.lev]);
                            } else if (dragDirs.vrt > 0) {
                              //down
                              availMoves.push([PLACEMENT_AFTER, trgII, trgII.lev]);
                            }
                          }
                        }

                        //add case
                        var addCaseII = function addCaseII(am) {
                          var toII = am[1];
                          var fromCaseII = itemInfo.caseId ? _this2.tree.items[itemInfo.caseId] : null;
                          var toCaseII = toII.caseId ? _this2.tree.items[toII.caseId] : null;
                          return [].concat(_toConsumableArray(am), [fromCaseII, toCaseII]);
                        };
                        availMoves = availMoves.map(addCaseII);
                        altMoves = altMoves.map(addCaseII);

                        //sanitize
                        availMoves = availMoves.filter(function (am) {
                          var placement = am[0];
                          var trg = am[1];
                          if ((placement == PLACEMENT_BEFORE || placement == PLACEMENT_AFTER) && trg.parent == null) return false;
                          if (trg.collapsed && (placement == PLACEMENT_APPEND || placement == PLACEMENT_PREPEND)) return false;
                          var isInside = trg.id == itemInfo.id;
                          if (!isInside) {
                            var tmp = trg;
                            while (tmp.parent) {
                              tmp = _this2.tree.items[tmp.parent];
                              if (tmp.id == itemInfo.id) {
                                isInside = true;
                                break;
                              }
                            }
                          }
                          return !isInside;
                        }).map(function (am) {
                          var placement = am[0],
                            toII = am[1];
                          am[2];
                          am[3];
                          am[4];
                          var toParentII = null;
                          if (placement == PLACEMENT_APPEND || placement == PLACEMENT_PREPEND) toParentII = toII;else toParentII = _this2.tree.items[toII.parent];
                          if (toParentII && toParentII.parent == null) toParentII = null;
                          am[5] = toParentII;
                          return am;
                        });
                        var bestMode = null;
                        var filteredMoves = availMoves.filter(function (am) {
                          return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);
                        });
                        if (filteredMoves.length == 0 && altMoves.length > 0) {
                          filteredMoves = altMoves.filter(function (am) {
                            return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);
                          });
                        }
                        var levs = filteredMoves.map(function (am) {
                          return am[2];
                        });
                        var curLev = itemInfo.lev;
                        var allLevs = levs.concat(curLev);
                        var closestDragLev = null;
                        if (allLevs.indexOf(dragLev) != -1) closestDragLev = dragLev;else if (dragLev > Math.max.apply(Math, _toConsumableArray(allLevs))) closestDragLev = Math.max.apply(Math, _toConsumableArray(allLevs));else if (dragLev < Math.min.apply(Math, _toConsumableArray(allLevs))) closestDragLev = Math.min.apply(Math, _toConsumableArray(allLevs));
                        bestMode = filteredMoves.find(function (am) {
                          return am[2] == closestDragLev;
                        });
                        if (!isSamePos && !bestMode && filteredMoves.length) bestMode = filteredMoves[0];
                        moveInfo = bestMode;
                      }
                    }
                  }
                }
                if (moveInfo) {
                  this.move(itemInfo, moveInfo[1], moveInfo[0], moveInfo[3]);

                  // logger.log("DRAG-N-DROP", JSON.stringify({
                  //   dragRect,
                  //   plhRect,
                  //   treeRect,
                  //   hovRect,
                  //   startMousePos: dragInfo.startMousePos,
                  //   mousePos: dragInfo.mousePos,
                  // }));
                  return true;
                }
                return false;
              }
            }, {
              key: "canMove",
              value: function canMove(fromII, toII, placement, fromCaseII, toCaseII, toParentII, canMoveFn) {
                if (!fromII || !toII) return false;
                if (fromII.id === toII.id) return false;
                var _this$props$config$se = this.props.config.settings,
                  canRegroup = _this$props$config$se.canRegroup,
                  canRegroupCases = _this$props$config$se.canRegroupCases,
                  maxNesting = _this$props$config$se.maxNesting,
                  maxNumberOfRules = _this$props$config$se.maxNumberOfRules,
                  canLeaveEmptyCase = _this$props$config$se.canLeaveEmptyCase;
                var newLev = toParentII ? toParentII.lev + 1 : toII.lev;
                var newDepthLev = newLev + (fromII.depth || 0);
                var isBeforeAfter = placement == PLACEMENT_BEFORE || placement == PLACEMENT_AFTER;
                var isPend = placement == PLACEMENT_PREPEND || placement == PLACEMENT_APPEND;
                var isLev1 = isBeforeAfter && toII.lev == 1 || isPend && toII.lev == 0;
                var isParentChange = fromII.parent != toII.parent;
                var isStructChange = isPend || isParentChange;
                // can't move `case_group` anywhere but before/after anoter `case_group`
                var isForbiddenStructChange = fromII.type == "case_group" && !isLev1
                // can't restruct `rule_group`
                || fromII.parentType == "rule_group" || toII.type == "rule_group" || toII.parentType == "rule_group"
                // only `case_group` can be placed under `switch_group`
                || fromII.type != "case_group" && toII.type == "case_group" && isBeforeAfter || fromII.type != "case_group" && toII.type == "switch_group"
                // can't move rule/group to another case
                || !canRegroupCases && fromII.caseId != toII.caseId;
                var isLockedChange = toII.isLocked || fromII.isLocked || toParentII && toParentII.isLocked;
                if (maxNesting && newDepthLev > maxNesting) return false;
                if (isStructChange && (!canRegroup || isForbiddenStructChange || isLockedChange)) return false;
                if (fromII.type != "case_group" && fromII.caseId != toII.caseId) {
                  var isLastFromCase = fromCaseII ? fromCaseII._height == 2 : false;
                  var newRulesInTargetCase = toCaseII ? toCaseII.atomicRulesCountInCase + 1 : 0;
                  if (maxNumberOfRules && newRulesInTargetCase > maxNumberOfRules) return false;
                  if (isLastFromCase && !canLeaveEmptyCase) return false;
                }
                if (fromII.type == "case_group" && (fromII.isDefaultCase || toII.isDefaultCase || toII.type == "switch_group" && placement == PLACEMENT_APPEND)) {
                  // leave default case alone
                  return false;
                }
                var res = true;
                if (canMoveFn) {
                  res = canMoveFn(fromII.node.toJS(), toII.node.toJS(), placement, toParentII ? toParentII.node.toJS() : null);
                }
                return res;
              }
            }, {
              key: "move",
              value: function move(fromII, toII, placement, toParentII) {
                if (!this._isUsingLegacyReactDomRender) {
                  _isReorderingTree = true;
                }
                //logger.log("move", fromII, toII, placement, toParentII);
                this.props.actions.moveItem(fromII.path, toII.path, placement);
              }
            }, {
              key: "render",
              value: function render() {
                return /*#__PURE__*/React.createElement(Builder, _extends$h({}, this.props, {
                  onDragStart: this.onDragStart
                }));
              }
            }]);
          }(reactExports.Component), _SortableContainer.propTypes = {
            tree: PropTypes.any.isRequired,
            //instanceOf(Immutable.Map)
            actions: PropTypes.object.isRequired // {moveItem: Function, ..}
            //... see Builder
          }, _SortableContainer;
        };
        const SortableContainer = function SortableContainer(Builder) {
          var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var ConnectedSortableContainer = connect$1(function (state) {
            return {
              dragging: state.dragging,
              dragStart: state.dragStart,
              mousePos: state.mousePos
            };
          }, {
            setDragStart: setDragStart,
            setDragProgress: setDragProgress,
            setDragEnd: setDragEnd
          }, null, {
            context: context
          })(createSortableContainer(Builder, CanMoveFn));
          ConnectedSortableContainer.displayName = "ConnectedSortableContainer";
          return ConnectedSortableContainer;
        };
        var _excluded$8 = ["isDraggingTempo", "isDraggingMe", "dragging"];
        function _callSuper$n(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$n() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$n() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$n = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        const Draggable = function Draggable(className) {
          return function (GroupOrRule) {
            var _Draggable;
            return _Draggable = /*#__PURE__*/function (_PureComponent) {
              function Draggable(props) {
                var _this;
                _classCallCheck$b(this, Draggable);
                _this = _callSuper$n(this, Draggable, [props]);
                _this.handleDraggerMouseDown = function (e) {
                  var nodeId = _this.props.id;
                  var dom = _this.wrapper.current;
                  if (_this.props.onDragStart) {
                    _this.props.onDragStart(nodeId, dom, e);
                  }
                };
                _this.wrapper = /*#__PURE__*/React.createRef();
                return _this;
              }
              _inherits$b(Draggable, _PureComponent);
              return _createClass$9(Draggable, [{
                key: "render",
                value: function render() {
                  var _this$props = this.props,
                    isDraggingTempo = _this$props.isDraggingTempo,
                    isDraggingMe = _this$props.isDraggingMe,
                    dragging = _this$props.dragging,
                    otherProps = _objectWithoutProperties$2(_this$props, _excluded$8);
                  var isTrueLocked = otherProps.isTrueLocked;
                  var styles = {};
                  if (isDraggingMe && isDraggingTempo) {
                    if (_isReorderingTree) ;else {
                      styles = {
                        top: dragging.y,
                        left: dragging.x,
                        width: dragging.w
                      };
                    }
                  }
                  var cn = classNames(className, "group-or-rule", isDraggingMe && isDraggingTempo ? "qb-draggable" : null, isDraggingMe && !isDraggingTempo ? "qb-placeholder" : null, isTrueLocked ? "locked" : null);
                  return /*#__PURE__*/React.createElement("div", {
                    className: cn,
                    style: styles,
                    ref: this.wrapper,
                    "data-id": this.props.id
                  }, /*#__PURE__*/React.createElement(GroupOrRule, _extends$h({
                    handleDraggerMouseDown: this.handleDraggerMouseDown,
                    isDraggingMe: isDraggingMe,
                    isDraggingTempo: isDraggingTempo
                  }, otherProps)));
                }
              }]);
            }(reactExports.PureComponent), _Draggable.propTypes = {
              isDraggingTempo: PropTypes.bool,
              isDraggingMe: PropTypes.bool,
              onDragStart: PropTypes.func,
              dragging: PropTypes.object,
              //{id, x, y, w, h}
              isLocked: PropTypes.bool,
              isTrueLocked: PropTypes.bool
            }, _Draggable;
          };
        };
        var arrayMap$2 = _arrayMap,
          baseIteratee$2 = _baseIteratee,
          basePickBy = _basePickBy,
          getAllKeysIn = _getAllKeysIn;

        /**
         * Creates an object composed of the `object` properties `predicate` returns
         * truthy for. The predicate is invoked with two arguments: (value, key).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The source object.
         * @param {Function} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pickBy(object, _.isNumber);
         * // => { 'a': 1, 'c': 3 }
         */
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap$2(getAllKeysIn(object), function (prop) {
            return [prop];
          });
          predicate = baseIteratee$2(predicate);
          return basePickBy(object, props, function (value, path) {
            return predicate(value, path[0]);
          });
        }
        var pickBy_1 = pickBy;
        const pickBy$1 = /*@__PURE__*/getDefaultExportFromCjs(pickBy_1);
        function ownKeys$h(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$h(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$h(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$h(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _callSuper$m(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$m() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$m() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$m = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var _Utils$ConfigUtils$6 = Utils$1.ConfigUtils,
          getFieldConfig$6 = _Utils$ConfigUtils$6.getFieldConfig,
          getOperatorConfig$3 = _Utils$ConfigUtils$6.getOperatorConfig;
        var Operator = /*#__PURE__*/function (_Component) {
          function Operator(props) {
            var _this;
            _classCallCheck$b(this, Operator);
            _this = _callSuper$m(this, Operator, [props]);
            _this.shouldComponentUpdate = liteShouldComponentUpdate(_this, {
              // tip: rely on selectedFieldId instead
              selectedField: function selectedField(nextValue, prevValue) {
                return false;
              }
            });
            useOnPropsChanged(_this);
            _this.onPropsChanged(props);
            return _this;
          }
          _inherits$b(Operator, _Component);
          return _createClass$9(Operator, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var keysForMeta = ["config", "selectedField", "selectedFieldSrc", "selectedFieldType", "selectedOperator"];
              var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
                return nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps);
              }
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref) {
              var _config$types$selecte;
              var config = _ref.config,
                selectedField = _ref.selectedField,
                selectedFieldType = _ref.selectedFieldType,
                selectedOperator = _ref.selectedOperator;
              var fieldConfig = getFieldConfig$6(config, selectedField);
              var operators = _toConsumableArray((fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.operators) || ((_config$types$selecte = config.types[selectedFieldType]) === null || _config$types$selecte === void 0 ? void 0 : _config$types$selecte.operators) || []);
              if (!selectedField && !operators.includes(selectedOperator)) {
                // eg. `prox` field was selected, then `fieldSrc` changed to `func`
                // But `text` type excludes `proximity` operator in config, so add manually
                operators.push(selectedOperator);
              }
              var operatorsOptions = mapValues$1(pickBy$1(config.operators, function (item, key) {
                return (operators === null || operators === void 0 ? void 0 : operators.indexOf(key)) !== -1;
              }), function (_opts, op) {
                return getOperatorConfig$3(config, op, selectedField);
              });
              var items = this.buildOptions(config, operatorsOptions, operators);
              var selectedOpts = operatorsOptions[selectedOperator] || {};
              var placeholder = this.props.config.settings.operatorPlaceholder;
              var selectedKey = selectedOperator;
              var selectedKeys = selectedKey ? [selectedKey] : null;
              var selectedPath = selectedKeys;
              var selectedLabel = selectedOpts.label;
              // tip: label2 is not documented for operators
              var selectedAltLabel = selectedOpts.label2 || selectedOpts.tooltip;
              return {
                placeholder: placeholder,
                items: items,
                selectedKey: selectedKey,
                selectedKeys: selectedKeys,
                selectedPath: selectedPath,
                selectedLabel: selectedLabel,
                selectedAltLabel: selectedAltLabel,
                selectedOpts: selectedOpts,
                fieldConfig: fieldConfig
              };
            }
          }, {
            key: "buildOptions",
            value: function buildOptions(config, fields, ops) {
              if (!fields || !ops) return null;
              return keys$9(fields).sort(function (a, b) {
                return ops.indexOf(a) - ops.indexOf(b);
              }).map(function (fieldKey) {
                var field = fields[fieldKey];
                var label = field.label;
                var altLabel = field.label2;
                var tooltip = field.tooltip;
                return {
                  key: fieldKey,
                  path: fieldKey,
                  label: label,
                  altLabel: altLabel,
                  tooltip: tooltip
                };
              });
            }
          }, {
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                customProps = _this$props.customProps,
                setOperator = _this$props.setOperator,
                readonly = _this$props.readonly,
                id = _this$props.id,
                groupId = _this$props.groupId;
              var renderOperator = config.settings.renderOperator;
              var renderProps = _objectSpread$h({
                id: id,
                groupId: groupId,
                config: config,
                customProps: customProps,
                readonly: readonly,
                setField: setOperator
              }, this.meta);
              if (!renderProps.items) return null;
              return renderOperator(renderProps, config.ctx);
            }
          }]);
        }(reactExports.Component);
        Operator.propTypes = {
          id: PropTypes.string,
          groupId: PropTypes.string,
          config: PropTypes.object.isRequired,
          selectedField: PropTypes.any,
          selectedFieldId: PropTypes.string,
          selectedFieldType: PropTypes.string,
          selectedFieldSrc: PropTypes.string,
          selectedOperator: PropTypes.string,
          readonly: PropTypes.bool,
          customProps: PropTypes.object,
          //actions
          setOperator: PropTypes.func.isRequired
        };
        var _excluded$7 = ["children"];
        var Col = function Col(_ref) {
          var children = _ref.children,
            props = _objectWithoutProperties$2(_ref, _excluded$7);
          return /*#__PURE__*/React.createElement("div", props, children);
        };
        var dummyFn = function dummyFn() {};
        var DragIcon$1 = function DragIcon() {
          return /*#__PURE__*/React.createElement("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            fill: "gray",
            width: "18px",
            height: "18px"
          }, /*#__PURE__*/React.createElement("path", {
            d: "M0 0h24v24H0V0z",
            fill: "none"
          }), /*#__PURE__*/React.createElement("path", {
            d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"
          }));
        };
        var WithConfirmFn = function WithConfirmFn(Cmp) {
          return function (props) {
            var useConfirm = props.config.settings.useConfirm;
            var confirmFn = useConfirm ? useConfirm.call(props.config.ctx, props.config.ctx) : null;
            return /*#__PURE__*/React.createElement(Cmp, _extends$h({}, props, {
              confirmFn: confirmFn
            }));
          };
        };
        var getWidgetId = function getWidgetId(_ref2) {
          var id = _ref2.id,
            isLHS = _ref2.isLHS,
            delta = _ref2.delta,
            parentFuncs = _ref2.parentFuncs;
          return [id, isLHS ? "L" : "R", isLHS ? -1 : delta || 0, (parentFuncs || []).map(function (_ref3) {
            var _ref4 = _slicedToArray$1(_ref3, 2),
              f = _ref4[0],
              a = _ref4[1];
            return "".concat(f, "(").concat(a, ")");
          }).join("/")].join(":");
        };
        var getRenderFromConfig = function getRenderFromConfig(config, renderFn) {
          var Cmp;
          if (typeof renderFn === "function") {
            Cmp = function Cmp(pr) {
              return renderFn === null || renderFn === void 0 ? void 0 : renderFn(pr, config.ctx);
            };
            Cmp.displayName = renderFn.name;
          } else {
            Cmp = renderFn;
          }
          return Cmp;
        };
        function _callSuper$l(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$l() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$l() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$l = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var OperatorWrapper = /*#__PURE__*/function (_PureComponent) {
          function OperatorWrapper() {
            _classCallCheck$b(this, OperatorWrapper);
            return _callSuper$l(this, OperatorWrapper, arguments);
          }
          _inherits$b(OperatorWrapper, _PureComponent);
          return _createClass$9(OperatorWrapper, [{
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                selectedField = _this$props.selectedField,
                selectedFieldSrc = _this$props.selectedFieldSrc,
                selectedFieldType = _this$props.selectedFieldType,
                selectedOperator = _this$props.selectedOperator,
                setOperator = _this$props.setOperator,
                selectedFieldId = _this$props.selectedFieldId,
                showOperator = _this$props.showOperator,
                showOperatorLabel = _this$props.showOperatorLabel,
                selectedFieldWidgetConfig = _this$props.selectedFieldWidgetConfig,
                readonly = _this$props.readonly,
                id = _this$props.id,
                groupId = _this$props.groupId;
              var operator = showOperator && /*#__PURE__*/React.createElement(Col, {
                key: "operators-for-" + selectedFieldId,
                className: "rule--operator"
              }, config.settings.showLabels && /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, config.settings.operatorLabel), /*#__PURE__*/React.createElement(Operator, {
                key: "operator",
                config: config,
                selectedField: selectedField,
                selectedFieldSrc: selectedFieldSrc,
                selectedFieldType: selectedFieldType,
                selectedFieldId: selectedFieldId,
                selectedOperator: selectedOperator,
                setOperator: setOperator,
                customProps: config.settings.customOperatorSelectProps,
                readonly: readonly,
                id: id,
                groupId: groupId
              }));
              var hiddenOperator = showOperatorLabel && /*#__PURE__*/React.createElement(Col, {
                key: "operators-for-" + selectedFieldId,
                className: "rule--operator"
              }, /*#__PURE__*/React.createElement("div", {
                className: "rule--operator-wrapper"
              }, config.settings.showLabels ? /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, "\xA0") : null, /*#__PURE__*/React.createElement("div", {
                className: "rule--operator-text-wrapper"
              }, /*#__PURE__*/React.createElement("span", {
                className: "rule--operator-text"
              }, selectedFieldWidgetConfig.operatorInlineLabel))));
              return [operator, hiddenOperator];
            }
          }]);
        }(reactExports.PureComponent);
        function ownKeys$g(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$g(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$g(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$g(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _callSuper$k(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$k() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$k() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$k = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var getFieldPathLabels$1 = Utils$1.RuleUtils.getFieldPathLabels;
        var _Utils$ConfigUtils$5 = Utils$1.ConfigUtils,
          getFieldConfig$5 = _Utils$ConfigUtils$5.getFieldConfig,
          getFieldParts$2 = _Utils$ConfigUtils$5.getFieldParts,
          getFieldPathParts$2 = _Utils$ConfigUtils$5.getFieldPathParts;
        var Field = /*#__PURE__*/function (_Component) {
          function Field(props) {
            var _this;
            _classCallCheck$b(this, Field);
            _this = _callSuper$k(this, Field, [props]);
            _this.setField = function (field, asyncListValues) {
              var _meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              var id = _this.props.id;
              if (!_meta.widgetId) {
                var widgetId = [id, "L", -1].join(":");
                _meta.widgetId = widgetId;
              }
              _this.props.setField(field, asyncListValues, _meta);
            };
            useOnPropsChanged(_this);
            _this.onPropsChanged(props);
            return _this;
          }
          _inherits$b(Field, _Component);
          return _createClass$9(Field, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var keysForMeta = ["selectedField", "selectedFieldSrc", "selectedFieldType", "config", "parentField"];
              var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
                return nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps);
              }
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref) {
              var selectedField = _ref.selectedField,
                selectedFieldType = _ref.selectedFieldType,
                config = _ref.config,
                parentField = _ref.parentField;
              var selectedKey = selectedField;
              var _config$settings = config.settings,
                maxLabelsLength = _config$settings.maxLabelsLength,
                fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay,
                fieldPlaceholder = _config$settings.fieldPlaceholder;
              _config$settings.fieldSeparator;
              var isFieldSelected = !!selectedField;
              var placeholder = !isFieldSelected ? truncateString(fieldPlaceholder, maxLabelsLength) : null;
              var currField = isFieldSelected ? getFieldConfig$5(config, selectedKey) : null;
              var selectedOpts = currField || {};
              var selectedKeys = getFieldPathParts$2(selectedKey, config);
              var selectedPath = getFieldPathParts$2(selectedKey, config, true);
              var selectedLabel = this.getFieldLabel(currField, selectedKey, config);
              var partsLabels = getFieldPathLabels$1(selectedKey, config);
              var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
              if (selectedFullLabel == selectedLabel || parentField) selectedFullLabel = null;
              var selectedAltLabel = selectedOpts.label2 || selectedOpts.tooltip;
              var parentFieldPath = getFieldParts$2(parentField, config);
              var parentFieldConfig = parentField ? getFieldConfig$5(config, parentField) : null;
              var sourceFields = parentField ? parentFieldConfig && parentFieldConfig.subfields : config.fields;
              var lookingForFieldType = !isFieldSelected && selectedFieldType;
              var items = this.buildOptions(parentFieldPath, config, sourceFields, lookingForFieldType, parentFieldPath);

              // Field source has been chnaged, no new field selected, but op & value remains
              var errorText = lookingForFieldType ? "Please select field" : null;
              if (selectedKey && _typeof$3(selectedKey) === "object") {
                // can happen due to incorrect rule state: field is Map{func, args} but fieldSrc is not "func"
                selectedKey = undefined;
              }
              return {
                placeholder: placeholder,
                items: items,
                parentField: parentField,
                selectedKey: selectedKey,
                selectedKeys: selectedKeys,
                selectedPath: selectedPath,
                selectedLabel: selectedLabel,
                selectedOpts: selectedOpts,
                selectedAltLabel: selectedAltLabel,
                selectedFullLabel: selectedFullLabel,
                errorText: errorText
              };
            }
          }, {
            key: "getFieldLabel",
            value: function getFieldLabel(fieldOpts, fieldKey, config) {
              if (!fieldKey) return null;
              var maxLabelsLength = config.settings.maxLabelsLength;
              var fieldParts = getFieldParts$2(fieldKey, config);
              var label = (fieldOpts === null || fieldOpts === void 0 ? void 0 : fieldOpts.label) || last$2(fieldParts);
              label = truncateString(label, maxLabelsLength);
              return label;
            }
          }, {
            key: "buildOptions",
            value: function buildOptions(parentFieldPath, config, fields) {
              var _this2 = this;
              var fieldType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
              var path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
              var optGroup = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
              if (!fields) return null;
              var _config$settings2 = config.settings,
                fieldSeparator = _config$settings2.fieldSeparator,
                fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
              var prefix = path !== null && path !== void 0 && path.length ? path.join(fieldSeparator) + fieldSeparator : "";
              var countFieldsMatchesType = function countFieldsMatchesType(fields) {
                return Object.keys(fields || {}).reduce(function (acc, fieldKey) {
                  var field = fields[fieldKey];
                  if (field.type === "!struct") {
                    return acc + countFieldsMatchesType(field.subfields);
                  } else {
                    return acc + (field.type === fieldType ? 1 : 0);
                  }
                }, 0);
              };
              return keys$9(fields).map(function (fieldKey) {
                var fullFieldPath = [].concat(_toConsumableArray(path !== null && path !== void 0 ? path : []), [fieldKey]);
                var field = fields[fieldKey];
                var label = _this2.getFieldLabel(field, fullFieldPath, config);
                var partsLabels = getFieldPathLabels$1(fullFieldPath, config);
                var fullLabel = partsLabels.join(fieldSeparatorDisplay);
                if (fullLabel == label || parentFieldPath !== null && parentFieldPath !== void 0 && parentFieldPath.length) fullLabel = null;
                var altLabel = field.label2;
                var tooltip = field.tooltip;
                var disabled = field.disabled;
                if (field.hideForSelect) return undefined;
                if (field.type == "!struct") {
                  var items = _this2.buildOptions(parentFieldPath, config, field.subfields, fieldType, fullFieldPath, {
                    label: label,
                    tooltip: tooltip
                  });
                  var hasItemsMatchesType = countFieldsMatchesType(field.subfields) > 0;
                  return {
                    disabled: disabled,
                    key: fieldKey,
                    path: prefix + fieldKey,
                    label: label,
                    fullLabel: fullLabel,
                    altLabel: altLabel,
                    tooltip: tooltip,
                    items: items,
                    matchesType: hasItemsMatchesType
                  };
                } else {
                  var matchesType = fieldType !== undefined ? field.type === fieldType : undefined;
                  return {
                    disabled: disabled,
                    key: fieldKey,
                    path: prefix + fieldKey,
                    label: label,
                    fullLabel: fullLabel,
                    altLabel: altLabel,
                    tooltip: tooltip,
                    grouplabel: optGroup === null || optGroup === void 0 ? void 0 : optGroup.label,
                    group: optGroup,
                    matchesType: matchesType
                  };
                }
              }).filter(function (o) {
                return !!o;
              });
            }
          }, {
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                customProps = _this$props.customProps,
                setFieldSrc = _this$props.setFieldSrc,
                readonly = _this$props.readonly,
                id = _this$props.id,
                groupId = _this$props.groupId;
              var renderField = config.settings.renderField;
              var renderProps = _objectSpread$g({
                id: id,
                groupId: groupId,
                config: config,
                customProps: customProps,
                readonly: readonly,
                setField: this.setField,
                setFieldSrc: setFieldSrc
              }, this.meta);
              return renderField(renderProps, config.ctx);
            }
          }]);
        }(reactExports.Component);
        Field.propTypes = {
          id: PropTypes.string,
          groupId: PropTypes.string,
          config: PropTypes.object.isRequired,
          selectedField: PropTypes.any,
          selectedFieldSrc: PropTypes.string,
          selectedFieldType: PropTypes.string,
          parentField: PropTypes.string,
          customProps: PropTypes.object,
          readonly: PropTypes.bool,
          //actions
          setField: PropTypes.func.isRequired,
          setFieldSrc: PropTypes.func
        };
        function ownKeys$f(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$f(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$f(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$f(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _callSuper$j(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$j() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$j() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$j = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var clone$1 = Utils$1.clone;
        var _Utils$ConfigUtils$4 = Utils$1.ConfigUtils,
          getFieldConfig$4 = _Utils$ConfigUtils$4.getFieldConfig,
          getFuncConfig$1 = _Utils$ConfigUtils$4.getFuncConfig,
          getFieldParts$1 = _Utils$ConfigUtils$4.getFieldParts,
          getFieldPathParts$1 = _Utils$ConfigUtils$4.getFieldPathParts;
        var _Utils$RuleUtils$2 = Utils$1.RuleUtils,
          getFuncPathLabels = _Utils$RuleUtils$2.getFuncPathLabels,
          getWidgetForFieldOp$2 = _Utils$RuleUtils$2.getWidgetForFieldOp;
        var shallowEqual$2 = Utils$1.OtherUtils.shallowEqual;

        //tip: this.props.value - right value, this.props.field - left value
        var FuncSelect = /*#__PURE__*/function (_Component) {
          function FuncSelect(props) {
            var _this;
            _classCallCheck$b(this, FuncSelect);
            _this = _callSuper$j(this, FuncSelect, [props]);
            useOnPropsChanged(_this);
            _this.onPropsChanged(props);
            return _this;
          }
          _inherits$b(FuncSelect, _Component);
          return _createClass$9(FuncSelect, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var keysForItems = ["config", "field", "fieldType", "fieldSrc", "operator", "isFuncArg", "isLHS", "parentFuncs"];
              var keysForMeta = ["config", "field", "fieldType", "fieldSrc", "value", "isLHS"];
              var needUpdateItems = !this.items || keysForItems.map(function (k) {
                return k === "parentFuncs" ? !shallowEqual$2(nextProps[k], prevProps[k], true) : nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
                return nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps);
              }
              if (needUpdateItems) {
                this.items = this.getItems(nextProps, this.meta);
              }
            }
          }, {
            key: "getItems",
            value: function getItems(_ref, _ref2) {
              var config = _ref.config,
                field = _ref.field,
                fieldType = _ref.fieldType,
                isLHS = _ref.isLHS,
                operator = _ref.operator,
                parentFuncs = _ref.parentFuncs,
                fieldDefinition = _ref.fieldDefinition,
                isFuncArg = _ref.isFuncArg;
              var lookingForFieldType = _ref2.lookingForFieldType;
              var canUseFuncForField = config.settings.canUseFuncForField;
              var filteredFuncs = this.filterFuncs(config, config.funcs, field, fieldType, isLHS, operator, canUseFuncForField, parentFuncs, isFuncArg, fieldDefinition);
              var items = this.buildOptions(config, filteredFuncs, lookingForFieldType);
              return items;
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref3) {
              var config = _ref3.config;
              _ref3._field;
              var fieldType = _ref3.fieldType,
                value = _ref3.value,
                isLHS = _ref3.isLHS,
                isFuncArg = _ref3.isFuncArg;
              var _config$settings = config.settings,
                funcPlaceholder = _config$settings.funcPlaceholder,
                fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay;
              var selectedFuncKey = value;
              var isFuncSelected = !!value;

              // const leftFieldConfig = getFieldConfig(config, field);
              // const leftFieldWidgetField = leftFieldConfig?.widgets?.field;
              // const leftFieldWidgetFieldProps = leftFieldWidgetField && leftFieldWidgetField.widgetProps || {};
              var placeholder = !isFuncSelected ? funcPlaceholder : null;
              var currFunc = isFuncSelected ? getFuncConfig$1(config, selectedFuncKey) : null;
              var selectedOpts = currFunc || {};
              var selectedKeys = getFieldPathParts$1(selectedFuncKey, config);
              var selectedPath = getFieldPathParts$1(selectedFuncKey, config, true);
              var selectedLabel = this.getFuncLabel(currFunc, selectedFuncKey, config);
              var partsLabels = getFuncPathLabels(selectedFuncKey, config);
              var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
              if (selectedFullLabel == selectedLabel) selectedFullLabel = null;
              var isRootFuncAtLHS = isLHS && !isFuncArg;
              var lookingForFieldType = isRootFuncAtLHS && !isFuncSelected && fieldType;
              // Field source has been chnaged, no new func selected, but op & value remains
              var errorText = lookingForFieldType ? "Please select function" : null;
              return {
                placeholder: placeholder,
                selectedKey: selectedFuncKey,
                selectedKeys: selectedKeys,
                selectedPath: selectedPath,
                selectedLabel: selectedLabel,
                selectedOpts: selectedOpts,
                selectedFullLabel: selectedFullLabel,
                errorText: errorText,
                lookingForFieldType: lookingForFieldType
              };
            }
          }, {
            key: "filterFuncs",
            value: function filterFuncs(config, funcs, leftFieldFullkey, fieldType, isLHS, operator, canUseFuncForField, parentFuncs, isFuncArg, fieldDefinition) {
              funcs = clone$1(funcs);
              var fieldSeparator = config.settings.fieldSeparator;
              var leftFieldConfig = getFieldConfig$4(config, leftFieldFullkey);
              var expectedType;
              var targetDefinition = leftFieldConfig;
              var widget = getWidgetForFieldOp$2(config, leftFieldFullkey, operator, "value");
              widget && config.widgets[widget];
              if (isFuncArg) {
                targetDefinition = fieldDefinition;
                expectedType = fieldDefinition === null || fieldDefinition === void 0 ? void 0 : fieldDefinition.type;
              } else if (leftFieldConfig) {
                expectedType = leftFieldConfig.type;
              } else if (!isLHS) {
                // no field at LHS, but can use type from "memory effect"
                expectedType = fieldType;
              }
              function _filter(list, path) {
                for (var funcKey in list) {
                  var subfields = list[funcKey].subfields;
                  var subpath = (path ? path : []).concat(funcKey);
                  var funcFullkey = subpath.join(fieldSeparator);
                  var funcConfig = getFuncConfig$1(config, funcFullkey);
                  if (funcConfig.type == "!struct") {
                    if (_filter(subfields, subpath) == 0) delete list[funcKey];
                  } else {
                    var _targetDefinition;
                    var canUse = !expectedType || funcConfig.returnType == expectedType;
                    if ((_targetDefinition = targetDefinition) !== null && _targetDefinition !== void 0 && _targetDefinition.funcs) canUse = canUse && targetDefinition.funcs.includes(funcFullkey);
                    if (canUseFuncForField) canUse = canUse && canUseFuncForField(leftFieldFullkey, leftFieldConfig, funcFullkey, funcConfig, operator);
                    // don't use func in func (can be configurable, but usually users don't need this)
                    if (!funcConfig.allowSelfNesting && parentFuncs && parentFuncs.map(function (_ref4) {
                      var _ref5 = _slicedToArray$1(_ref4, 2),
                        func = _ref5[0];
                      _ref5[1];
                      return func;
                    }).includes(funcFullkey)) canUse = false;
                    if (!canUse) delete list[funcKey];
                  }
                }
                return keys$9(list).length;
              }
              _filter(funcs, []);
              return funcs;
            }
          }, {
            key: "buildOptions",
            value: function buildOptions(config, funcs) {
              var _this2 = this;
              var fieldType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
              var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
              var optGroup = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
              if (!funcs) return null;
              var _config$settings2 = config.settings,
                fieldSeparator = _config$settings2.fieldSeparator,
                fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
              var prefix = path !== null && path !== void 0 && path.length ? path.join(fieldSeparator) + fieldSeparator : "";
              var countFieldsMatchesType = function countFieldsMatchesType(fields) {
                return Object.keys(fields || {}).reduce(function (acc, fieldKey) {
                  var field = fields[fieldKey];
                  if (field.type === "!struct") {
                    return acc + countFieldsMatchesType(field.subfields);
                  } else {
                    return acc + (field.type === fieldType ? 1 : 0);
                  }
                }, 0);
              };
              return keys$9(funcs).map(function (funcKey) {
                var fullFuncPath = [].concat(_toConsumableArray(path !== null && path !== void 0 ? path : []), [funcKey]);
                var func = funcs[funcKey];
                var label = _this2.getFuncLabel(func, fullFuncPath, config);
                var partsLabels = getFuncPathLabels(fullFuncPath, config);
                var fullLabel = partsLabels.join(fieldSeparatorDisplay);
                if (fullLabel == label) fullLabel = null;
                var tooltip = func.tooltip;
                if (func.type == "!struct") {
                  var items = _this2.buildOptions(config, func.subfields, fieldType, fullFuncPath, {
                    label: label,
                    tooltip: tooltip
                  });
                  var hasItemsMatchesType = countFieldsMatchesType(func.subfields) > 0;
                  return {
                    key: funcKey,
                    path: prefix + funcKey,
                    label: label,
                    fullLabel: fullLabel,
                    tooltip: tooltip,
                    items: items,
                    matchesType: hasItemsMatchesType
                  };
                } else {
                  var matchesType = fieldType !== undefined ? func.returnType === fieldType : undefined;
                  return {
                    key: funcKey,
                    path: prefix + funcKey,
                    label: label,
                    fullLabel: fullLabel,
                    tooltip: tooltip,
                    grouplabel: optGroup === null || optGroup === void 0 ? void 0 : optGroup.label,
                    group: optGroup,
                    matchesType: matchesType
                  };
                }
              });
            }
          }, {
            key: "getFuncLabel",
            value: function getFuncLabel(funcOpts, funcKey, config) {
              if (!funcKey) return null;
              var maxLabelsLength = config.settings.maxLabelsLength;
              var funcParts = getFieldParts$1(funcKey, config);
              var label = (funcOpts === null || funcOpts === void 0 ? void 0 : funcOpts.label) || last$2(funcParts);
              label = truncateString(label, maxLabelsLength);
              return label;
            }
          }, {
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                customProps = _this$props.customProps,
                setValue = _this$props.setValue,
                readonly = _this$props.readonly,
                id = _this$props.id,
                groupId = _this$props.groupId;
              var renderFunc = config.settings.renderFunc;
              var renderProps = _objectSpread$f({
                config: config,
                customProps: customProps,
                readonly: readonly,
                setField: setValue,
                items: this.items,
                id: id,
                groupId: groupId
              }, this.meta);
              return renderFunc(renderProps, config.ctx);
            }
          }]);
        }(reactExports.Component);
        FuncSelect.propTypes = {
          id: PropTypes.string,
          groupId: PropTypes.string,
          config: PropTypes.object.isRequired,
          field: PropTypes.any,
          fieldType: PropTypes.string,
          fieldSrc: PropTypes.string,
          operator: PropTypes.string,
          customProps: PropTypes.object,
          value: PropTypes.string,
          setValue: PropTypes.func.isRequired,
          readonly: PropTypes.bool,
          parentFuncs: PropTypes.array,
          fieldDefinition: PropTypes.object,
          isFuncArg: PropTypes.bool,
          isLHS: PropTypes.bool
        };

        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeCeil = Math.ceil,
          nativeMax$3 = Math.max;

        /**
         * The base implementation of `_.range` and `_.rangeRight` which doesn't
         * coerce arguments.
         *
         * @private
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @param {number} step The value to increment or decrement by.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the range of numbers.
         */
        function baseRange$1(start, end, step, fromRight) {
          var index = -1,
            length = nativeMax$3(nativeCeil((end - start) / (step || 1)), 0),
            result = Array(length);
          while (length--) {
            result[fromRight ? length : ++index] = start;
            start += step;
          }
          return result;
        }
        var _baseRange = baseRange$1;

        /** Used to match a single whitespace character. */

        var reWhitespace$1 = /\s/;

        /**
         * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
         * character of `string`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {number} Returns the index of the last non-whitespace character.
         */
        function trimmedEndIndex$2(string) {
          var index = string.length;
          while (index-- && reWhitespace$1.test(string.charAt(index))) {}
          return index;
        }
        var _trimmedEndIndex = trimmedEndIndex$2;
        var trimmedEndIndex$1 = _trimmedEndIndex;

        /** Used to match leading whitespace. */
        var reTrimStart$1 = /^\s+/;

        /**
         * The base implementation of `_.trim`.
         *
         * @private
         * @param {string} string The string to trim.
         * @returns {string} Returns the trimmed string.
         */
        function baseTrim$2(string) {
          return string ? string.slice(0, trimmedEndIndex$1(string) + 1).replace(reTrimStart$1, '') : string;
        }
        var _baseTrim = baseTrim$2;
        var baseTrim$1 = _baseTrim,
          isObject$2 = isObject_1,
          isSymbol$1 = isSymbol_1;

        /** Used as references for various `Number` constants. */
        var NAN$1 = 0 / 0;

        /** Used to detect bad signed hexadecimal string values. */
        var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;

        /** Used to detect binary string values. */
        var reIsBinary$1 = /^0b[01]+$/i;

        /** Used to detect octal string values. */
        var reIsOctal$1 = /^0o[0-7]+$/i;

        /** Built-in method references without a dependency on `root`. */
        var freeParseInt$1 = parseInt;

        /**
         * Converts `value` to a number.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         * @example
         *
         * _.toNumber(3.2);
         * // => 3.2
         *
         * _.toNumber(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toNumber(Infinity);
         * // => Infinity
         *
         * _.toNumber('3.2');
         * // => 3.2
         */
        function toNumber$3(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol$1(value)) {
            return NAN$1;
          }
          if (isObject$2(value)) {
            var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
            value = isObject$2(other) ? other + '' : other;
          }
          if (typeof value != 'string') {
            return value === 0 ? value : +value;
          }
          value = baseTrim$1(value);
          var isBinary = reIsBinary$1.test(value);
          return isBinary || reIsOctal$1.test(value) ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8) : reIsBadHex$1.test(value) ? NAN$1 : +value;
        }
        var toNumber_1 = toNumber$3;
        var toNumber$2 = toNumber_1;

        /** Used as references for various `Number` constants. */
        var INFINITY$2 = 1 / 0,
          MAX_INTEGER = 1.7976931348623157e+308;

        /**
         * Converts `value` to a finite number.
         *
         * @static
         * @memberOf _
         * @since 4.12.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted number.
         * @example
         *
         * _.toFinite(3.2);
         * // => 3.2
         *
         * _.toFinite(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toFinite(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toFinite('3.2');
         * // => 3.2
         */
        function toFinite$2(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber$2(value);
          if (value === INFINITY$2 || value === -INFINITY$2) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        var toFinite_1 = toFinite$2;
        var baseRange = _baseRange,
          isIterateeCall$1 = _isIterateeCall,
          toFinite$1 = toFinite_1;

        /**
         * Creates a `_.range` or `_.rangeRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new range function.
         */
        function createRange$1(fromRight) {
          return function (start, end, step) {
            if (step && typeof step != 'number' && isIterateeCall$1(start, end, step)) {
              end = step = undefined;
            }
            // Ensure the sign of `-0` is preserved.
            start = toFinite$1(start);
            if (end === undefined) {
              end = start;
              start = 0;
            } else {
              end = toFinite$1(end);
            }
            step = step === undefined ? start < end ? 1 : -1 : toFinite$1(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        var _createRange = createRange$1;
        var createRange = _createRange;

        /**
         * Creates an array of numbers (positive and/or negative) progressing from
         * `start` up to, but not including, `end`. A step of `-1` is used if a negative
         * `start` is specified without an `end` or `step`. If `end` is not specified,
         * it's set to `start` with `start` then set to `0`.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the range of numbers.
         * @see _.inRange, _.rangeRight
         * @example
         *
         * _.range(4);
         * // => [0, 1, 2, 3]
         *
         * _.range(-4);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 5);
         * // => [1, 2, 3, 4]
         *
         * _.range(0, 20, 5);
         * // => [0, 5, 10, 15]
         *
         * _.range(0, -4, -1);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.range(0);
         * // => []
         */
        var range = createRange();
        var range_1 = range;
        const range$1 = /*@__PURE__*/getDefaultExportFromCjs(range_1);
        var _excluded$6 = ["widgetFactory"],
          _excluded2 = ["factory"];
        function ownKeys$e(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$e(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$e(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        var getTitleInListValues = Utils$1.ListUtils.getTitleInListValues;
        var _widgetDefKeysToOmit = Utils$1.ConfigUtils._widgetDefKeysToOmit;
        var _Utils$TreeUtils$2 = Utils$1.TreeUtils,
          _fixImmutableValue = _Utils$TreeUtils$2._fixImmutableValue,
          isImmutable = _Utils$TreeUtils$2.isImmutable;
        var WidgetFactoryMemo = /*#__PURE__*/reactExports.memo(function (_ref) {
          var widgetFactory = _ref.widgetFactory,
            widgetProps = _objectWithoutProperties$2(_ref, _excluded$6);
          var config = widgetProps.config,
            isFuncArg = widgetProps.isFuncArg,
            fieldDefinition = widgetProps.fieldDefinition;
          var _ref2 = fieldDefinition || {},
            fieldSettings = _ref2.fieldSettings,
            defaultValue = _ref2.defaultValue,
            valueSources = _ref2.valueSources;
          var isConst = isFuncArg && (valueSources === null || valueSources === void 0 ? void 0 : valueSources.length) == 1 && (valueSources === null || valueSources === void 0 ? void 0 : valueSources[0]) === "const";
          var listValues = (fieldSettings === null || fieldSettings === void 0 ? void 0 : fieldSettings.treeValues) || (fieldSettings === null || fieldSettings === void 0 ? void 0 : fieldSettings.listValues);
          if (isConst && defaultValue) {
            if (typeof defaultValue === "boolean") {
              return defaultValue ? widgetProps.labelYes || "YES" : widgetProps.labelNo || "NO";
            } else if (listValues) {
              if (Array.isArray(defaultValue)) return defaultValue.map(function (v) {
                return getTitleInListValues(listValues, v) || v;
              }).join(", ");else return getTitleInListValues(listValues, defaultValue) || defaultValue;
            }
            return "" + defaultValue;
          }
          if (!widgetFactory) {
            return "?";
          }
          return widgetFactory(widgetProps, config.ctx);
        });
        WidgetFactoryMemo.displayName = "WidgetFactoryMemo";
        var WidgetFactory = function WidgetFactory(_ref3) {
          var delta = _ref3.delta,
            isFuncArg = _ref3.isFuncArg,
            valueSrc = _ref3.valueSrc,
            immValue = _ref3.value,
            immValueError = _ref3.valueError,
            fieldError = _ref3.fieldError,
            asyncListValues = _ref3.asyncListValues,
            isSpecialRange = _ref3.isSpecialRange,
            fieldDefinition = _ref3.fieldDefinition,
            widget = _ref3.widget,
            widgetDefinition = _ref3.widgetDefinition,
            widgetValueLabel = _ref3.widgetValueLabel,
            valueLabels = _ref3.valueLabels,
            textSeparators = _ref3.textSeparators,
            setValue = _ref3.setValue,
            setFuncValue = _ref3.setFuncValue,
            config = _ref3.config,
            field = _ref3.field,
            fieldSrc = _ref3.fieldSrc,
            fieldPath = _ref3.fieldPath,
            fieldType = _ref3.fieldType,
            isLHS = _ref3.isLHS,
            operator = _ref3.operator,
            readonly = _ref3.readonly,
            parentField = _ref3.parentField,
            parentFuncs = _ref3.parentFuncs,
            id = _ref3.id,
            groupId = _ref3.groupId,
            widgetId = _ref3.widgetId;
          var widgetFactory = widgetDefinition.factory,
            fieldWidgetProps = _objectWithoutProperties$2(widgetDefinition, _excluded2);

          // Widget value (if it's not a func with args) should NOT be Immutable
          // Eg. for multiselect value should be a JS Array, not Immutable List
          var fixedImmValue = immValue ? immValue.map(function (v) {
            return _fixImmutableValue(v);
          }) : undefined;
          var value = reactExports.useMemo(function () {
            if (isSpecialRange) {
              var _value = [fixedImmValue === null || fixedImmValue === void 0 ? void 0 : fixedImmValue.get(0), fixedImmValue === null || fixedImmValue === void 0 ? void 0 : fixedImmValue.get(1)];
              if (_value[0] === undefined && _value[1] === undefined) _value = undefined;
              return _value;
            }
            return fixedImmValue === null || fixedImmValue === void 0 ? void 0 : fixedImmValue.get(delta);
          }, [isSpecialRange, immValue]);
          var valueError = reactExports.useMemo(function () {
            if (!immValueError) {
              return null;
            }
            if (isSpecialRange) {
              return [immValueError.get(0), immValueError.get(1), immValueError.get(2)];
            }
            return immValueError === null || immValueError === void 0 ? void 0 : immValueError.get(delta);
          }, [isSpecialRange, immValue]);
          var errorMessage = isLHS ? fieldError : valueError;
          var _ref4 = fieldDefinition || {},
            fieldSettings = _ref4.fieldSettings;
          var label = widgetValueLabel.label,
            placeholder = widgetValueLabel.placeholder;
          var placeholders = valueLabels ? valueLabels.placeholder : null;
          var simpleField = isImmutable(field) ? null : field;
          var widgetProps = omit$1(_objectSpread$e(_objectSpread$e(_objectSpread$e({}, fieldWidgetProps), fieldSettings), {}, {
            config: config,
            field: simpleField,
            // !!! using of field prop in widget is strongly discouraged
            fieldPath: fieldPath,
            fieldSrc: fieldSrc,
            fieldType: fieldType,
            isLHS: isLHS,
            parentField: parentField,
            parentFuncs: parentFuncs,
            fieldDefinition: fieldDefinition,
            operator: operator,
            delta: delta,
            isSpecialRange: isSpecialRange,
            isFuncArg: isFuncArg,
            value: value,
            valueSrc: valueSrc,
            valueError: valueError,
            fieldError: fieldError,
            errorMessage: errorMessage,
            label: label,
            placeholder: placeholder,
            placeholders: placeholders,
            textSeparators: textSeparators,
            setValue: setValue,
            setFuncValue: setFuncValue,
            readonly: readonly,
            asyncListValues: asyncListValues,
            id: id,
            groupId: groupId,
            widgetId: widgetId,
            widgetFactory: widgetFactory,
            widget: widget
          }), [].concat(_toConsumableArray(_widgetDefKeysToOmit), ["toJS"]));
          return /*#__PURE__*/React.createElement(WidgetFactoryMemo, _extends$h({
            widgetFactory: widgetFactory
          }, widgetProps));
        };
        WidgetFactory.displayName = "WidgetFactory";
        function _callSuper$i(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$i() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$i() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$i = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var _Utils$ConfigUtils$3 = Utils$1.ConfigUtils,
          getFieldConfig$3 = _Utils$ConfigUtils$3.getFieldConfig,
          getOperatorConfig$2 = _Utils$ConfigUtils$3.getOperatorConfig,
          getFieldWidgetConfig$2 = _Utils$ConfigUtils$3.getFieldWidgetConfig;
        var _Utils$RuleUtils$1 = Utils$1.RuleUtils,
          getValueSourcesForFieldOp = _Utils$RuleUtils$1.getValueSourcesForFieldOp,
          getWidgetForFieldOp$1 = _Utils$RuleUtils$1.getWidgetForFieldOp,
          getValueLabel = _Utils$RuleUtils$1.getValueLabel;
        var createListWithOneElement$1 = Utils$1.DefaultUtils.createListWithOneElement;
        var shallowEqual$1 = Utils$1.OtherUtils.shallowEqual;
        Utils$1.TreeUtils.isImmutable;
        var funcArgDummyOpDef = {
          cardinality: 1
        };
        var Widget = /*#__PURE__*/function (_Component) {
          function Widget(_props) {
            var _this;
            _classCallCheck$b(this, Widget);
            _this = _callSuper$i(this, Widget, [_props]);
            _this._setValue = function (isSpecialRange, delta, widgetType, widgetId,
            // bound!
            value, asyncListValues) {
              var _meta = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};
              if (!_meta.widgetId) {
                _meta.widgetId = widgetId;
              }
              if (isSpecialRange && Array.isArray(value)) {
                var oldRange = [_this.props.value.get(0), _this.props.value.get(1)];
                if (oldRange[0] != value[0]) _this.props.setValue(0, value[0], widgetType, asyncListValues, _meta);
                if (oldRange[1] != value[1]) _this.props.setValue(1, value[1], widgetType, asyncListValues, _meta);
              } else {
                _this.props.setValue(delta, value, widgetType, asyncListValues, _meta);
              }
            };
            _this._setValueSrc = function (delta, widgetId,
            // bound!
            srcKey) {
              var _meta = {
                widgetId: widgetId
              };
              _this.props.setValueSrc(delta, srcKey, _meta);
            };
            _this.renderWidget = function (delta, meta, props) {
              var config = props.config,
                isFuncArg = props.isFuncArg,
                leftField = props.leftField,
                operator = props.operator,
                values = props.value,
                valueError = props.valueError,
                fieldError = props.fieldError,
                readonly = props.readonly,
                parentField = props.parentField,
                parentFuncs = props.parentFuncs,
                id = props.id,
                groupId = props.groupId,
                fieldSrc = props.fieldSrc,
                fieldType = props.fieldType,
                isLHS = props.isLHS,
                setFuncValue = props.setFuncValue;
              var settings = config.settings;
              var widgets = meta.widgets,
                iValues = meta.iValues,
                aField = meta.aField,
                valueSources = meta.valueSources;
              var value = isFuncArg ? iValues : values;
              var field = isFuncArg ? leftField : aField;
              var _widgets$delta = widgets[delta],
                valueSrc = _widgets$delta.valueSrc,
                valueLabel = _widgets$delta.valueLabel,
                widgetId = _widgets$delta.widgetId;
              var hasValueSources = valueSources.length > 1 && !readonly;
              var widgetLabel = settings.showLabels ? /*#__PURE__*/React.createElement("label", {
                key: "label-" + widgetId,
                className: "rule--label"
              }, valueLabel.label) : null;
              return /*#__PURE__*/React.createElement("div", {
                key: "wrapper-" + widgetId,
                className: classNames(valueSrc === "func" ? "widget--func" : "widget--widget", hasValueSources ? "widget--has-valuerscs" : "widget--has-no-valuerscs")
              }, valueSrc === "func" ? null : widgetLabel, /*#__PURE__*/React.createElement(WidgetFactory, _extends$h({
                key: widgetId,
                id: id // id of rule
                ,

                groupId: groupId,
                widgetId: widgetId,
                valueSrc: valueSrc,
                delta: delta,
                value: value,
                valueError: valueError,
                fieldError: fieldError,
                isFuncArg: isFuncArg,
                isLHS: isLHS
              }, pick$1(meta, ["isSpecialRange", "fieldDefinition", "asyncListValues"]), pick$1(widgets[delta], ["widget", "widgetDefinition", "widgetValueLabel", "valueLabels", "textSeparators", "setValue"]), {
                setFuncValue: setFuncValue,
                config: config,
                field: field,
                fieldSrc: fieldSrc,
                fieldType: fieldType,
                parentField: parentField,
                parentFuncs: parentFuncs,
                operator: operator,
                readonly: readonly
              })));
            };
            _this.renderValueSources = function (delta, meta, props) {
              var config = props.config,
                isFuncArg = props.isFuncArg,
                leftField = props.leftField,
                operator = props.operator,
                readonly = props.readonly;
              var settings = config.settings;
              var valueSources = meta.valueSources,
                widgets = meta.widgets,
                aField = meta.aField,
                valueSourcesOptions = meta.valueSourcesOptions;
              var field = isFuncArg ? leftField : aField;
              var _widgets$delta2 = widgets[delta],
                valueSrc = _widgets$delta2.valueSrc,
                setValueSrc = _widgets$delta2.setValueSrc;
              var ValueSources = _this.ValueSources;
              var sourceLabel = settings.showLabels ? /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, "\xA0") : null;
              return valueSources.length > 1 && !readonly && /*#__PURE__*/React.createElement("div", {
                key: "wrapper-" + "valuesrc-" + delta,
                className: "widget--valuesrc"
              }, sourceLabel, /*#__PURE__*/React.createElement(ValueSources, {
                key: "valuesrc-" + delta,
                delta: delta,
                valueSources: valueSourcesOptions,
                valueSrc: valueSrc,
                config: config,
                field: field,
                operator: operator,
                setValueSrc: setValueSrc,
                readonly: readonly,
                title: settings.valueSourcesPopupTitle
              }));
            };
            _this.renderSep = function (delta, meta, props) {
              var config = props.config;
              var widgets = meta.widgets;
              var settings = config.settings;
              var sepText = widgets[delta].sepText;
              var sepLabel = settings.showLabels ? /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, "\xA0") : null;
              return sepText && /*#__PURE__*/React.createElement("div", {
                key: "widget-separators-" + delta,
                className: classNames("widget--sep", delta == 0 && "widget--sep-first")
              }, sepLabel, /*#__PURE__*/React.createElement("span", null, sepText));
            };
            _this.renderWidgetDelta = function (delta) {
              var sep = _this.renderSep(delta, _this.meta, _this.props);
              var sources = _this.renderValueSources(delta, _this.meta, _this.props);
              var widgetCmp = _this.renderWidget(delta, _this.meta, _this.props);
              return [sep, sources, widgetCmp];
            };
            useOnPropsChanged(_this);
            _this.onPropsChanged(_props);
            return _this;
          }
          _inherits$b(Widget, _Component);
          return _createClass$9(Widget, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var configChanged = !this.ValueSources || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.config) !== (nextProps === null || nextProps === void 0 ? void 0 : nextProps.config);
              var keysForMeta = ["config", "id", "parentFuncs", "field", "fieldId", "fieldSrc", "fieldType", "fieldFunc", "fieldArg", "leftField", "operator", "valueSrc", "asyncListValues", "isLHS", "isFuncArg", "isForRuleGroup", "isCaseValue", "value"];
              var changedKeys = keysForMeta.filter(function (k) {
                if (k === "parentFuncs") {
                  return !shallowEqual$1(nextProps[k], prevProps[k], true);
                }
                // if (k === "value") {
                //   if (nextProps["value"] !== prevProps["value"] && isImmutable(nextProps["value"])) {
                //   }
                // }
                if (k === "field") {
                  //tip: if `fieldId` has not changed, but `field` changed -> ignore
                  // (because we are in RHS and field is LHS)
                  return nextProps["fieldId"] !== prevProps["fieldId"];
                }
                return nextProps[k] !== prevProps[k];
              });
              var needUpdateMeta = !this.meta || changedKeys.length > 0;
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps, changedKeys);
              }
              if (configChanged) {
                var config = nextProps.config;
                var renderValueSources = config.settings.renderValueSources;
                this.ValueSources = getRenderFromConfig(config, renderValueSources);
              }
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref) {
              var _iValueSrcs,
                _iValueSrcs2,
                _this$meta,
                _this$meta2,
                _this2 = this;
              var config = _ref.config,
                simpleField = _ref.field;
              _ref.fieldSrc;
              var fieldType = _ref.fieldType,
                fieldFunc = _ref.fieldFunc,
                fieldArg = _ref.fieldArg,
                operator = _ref.operator,
                valueSrcs = _ref.valueSrc,
                values = _ref.value,
                isForRuleGroup = _ref.isForRuleGroup,
                isCaseValue = _ref.isCaseValue,
                isFuncArg = _ref.isFuncArg;
              _ref.leftField;
              var asyncListValues = _ref.asyncListValues,
                parentFuncs = _ref.parentFuncs,
                isLHS = _ref.isLHS,
                id = _ref.id;
              var changedKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
              var valueSourcesInfo = config.settings.valueSourcesInfo;
              var field = isFuncArg ? {
                func: fieldFunc,
                arg: fieldArg
              } : simpleField;
              var isOkWithoutField = !simpleField && fieldType;
              var iValueSrcs = valueSrcs;
              var iValues = values;
              if (isFuncArg || isForRuleGroup || isCaseValue) {
                iValueSrcs = createListWithOneElement$1(valueSrcs);
                iValues = createListWithOneElement$1(values);
              }
              var fieldDefinition = getFieldConfig$3(config, field);
              if (!fieldDefinition && isOkWithoutField) {
                fieldDefinition = config.types[fieldType];
              }
              var defaultWidget = getWidgetForFieldOp$1(config, field, operator);
              if (!defaultWidget && isOkWithoutField) {
                var _config$types$fieldTy;
                defaultWidget = (_config$types$fieldTy = config.types[fieldType]) === null || _config$types$fieldTy === void 0 ? void 0 : _config$types$fieldTy.mainWidget;
              }
              var operatorDefinition = isFuncArg ? funcArgDummyOpDef : getOperatorConfig$2(config, operator, field);
              if ((fieldDefinition == null || operatorDefinition == null) && !isCaseValue) {
                return null;
              }
              var isSpecialRange = operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.isSpecialRange;
              var isSpecialRangeForSrcField = isSpecialRange && (((_iValueSrcs = iValueSrcs) === null || _iValueSrcs === void 0 ? void 0 : _iValueSrcs.get(0)) === "field" || ((_iValueSrcs2 = iValueSrcs) === null || _iValueSrcs2 === void 0 ? void 0 : _iValueSrcs2.get(1)) === "field");
              var isTrueSpecialRange = isSpecialRange && !isSpecialRangeForSrcField;
              var cardinality = isTrueSpecialRange ? 1 : getOpCardinality(operatorDefinition);
              if (cardinality === 0) {
                return null;
              }
              var valueSources = (_this$meta = this.meta) === null || _this$meta === void 0 ? void 0 : _this$meta.valueSources;
              var valueSourcesOptions = (_this$meta2 = this.meta) === null || _this$meta2 === void 0 ? void 0 : _this$meta2.valueSourcesOptions;
              if (!valueSources || ["field", "operator", "config", "fieldDefinition", "isForRuleGroup"].filter(function (k) {
                return changedKeys.includes(k);
              }).length) {
                valueSources = getValueSourcesForFieldOp(config, field, operator, fieldDefinition);
                if (isForRuleGroup) {
                  // todo: aggregation can be not only number?
                  valueSources = ["value"];
                }
                if (!field) {
                  valueSources = Object.keys(valueSourcesInfo);
                }
                valueSourcesOptions = valueSources.map(function (srcKey) {
                  return [srcKey, {
                    label: valueSourcesInfo[srcKey].label
                  }];
                });
              }
              var widgets = range$1(0, cardinality).map(function (delta) {
                var _this2$meta, _iValueSrcs3, _widgetDefinition, _this2$meta2;
                var oldWidgetMeta = (_this2$meta = _this2.meta) === null || _this2$meta === void 0 || (_this2$meta = _this2$meta.widgets) === null || _this2$meta === void 0 ? void 0 : _this2$meta[delta];
                var valueSrc = ((_iValueSrcs3 = iValueSrcs) === null || _iValueSrcs3 === void 0 ? void 0 : _iValueSrcs3.get(delta)) || null;
                var widget = getWidgetForFieldOp$1(config, field, operator, valueSrc);
                var widgetDefinition = getFieldWidgetConfig$2(config, field, operator, widget, valueSrc);
                if (isSpecialRangeForSrcField) {
                  widget = widgetDefinition.singleWidget;
                  widgetDefinition = getFieldWidgetConfig$2(config, field, operator, widget, valueSrc);
                }
                if (!widgetDefinition && isOkWithoutField) {
                  widget = ["func", "field"].includes(valueSrc) ? valueSrc : defaultWidget;
                  widgetDefinition = config.widgets[widget];
                }
                var widgetType = (_widgetDefinition = widgetDefinition) === null || _widgetDefinition === void 0 ? void 0 : _widgetDefinition.type;
                var valueLabel = getValueLabel(config, field, operator, delta, valueSrc, isTrueSpecialRange);
                var widgetValueLabel = getValueLabel(config, field, operator, delta, null, isTrueSpecialRange);
                var sepText = operatorDefinition !== null && operatorDefinition !== void 0 && operatorDefinition.textSeparators ? operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.textSeparators[delta] : null;
                var valueLabels = null;
                var textSeparators = null;
                if (isSpecialRange) {
                  valueLabels = [getValueLabel(config, field, operator, 0), getValueLabel(config, field, operator, 1)];
                  valueLabels = {
                    placeholder: [valueLabels[0].placeholder, valueLabels[1].placeholder],
                    label: [valueLabels[0].label, valueLabels[1].label]
                  };
                  textSeparators = operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.textSeparators;
                }
                var widgetId = getWidgetId({
                  id: id,
                  isLHS: isLHS,
                  delta: delta,
                  parentFuncs: parentFuncs
                });
                var vsId = widgetId + ":" + "VS";
                var setValueSrc = oldWidgetMeta === null || oldWidgetMeta === void 0 ? void 0 : oldWidgetMeta.setValueSrc;
                if (!setValueSrc || (oldWidgetMeta === null || oldWidgetMeta === void 0 ? void 0 : oldWidgetMeta.widgetId) !== widgetId) {
                  setValueSrc = _this2._setValueSrc.bind(_this2, delta, vsId);
                }
                var setValue = oldWidgetMeta === null || oldWidgetMeta === void 0 ? void 0 : oldWidgetMeta.setValue;
                if (!setValue || (oldWidgetMeta === null || oldWidgetMeta === void 0 ? void 0 : oldWidgetMeta.widgetId) !== widgetId || (oldWidgetMeta === null || oldWidgetMeta === void 0 ? void 0 : oldWidgetMeta.widgetType) !== widgetType || ((_this2$meta2 = _this2.meta) === null || _this2$meta2 === void 0 ? void 0 : _this2$meta2.isSpecialRange) !== isSpecialRange) {
                  setValue = _this2._setValue.bind(_this2, isSpecialRange, delta, widgetType, widgetId);
                }
                return {
                  valueSrc: valueSrc,
                  valueLabel: valueLabel,
                  widget: widget,
                  sepText: sepText,
                  widgetDefinition: widgetDefinition,
                  widgetValueLabel: widgetValueLabel,
                  valueLabels: valueLabels,
                  textSeparators: textSeparators,
                  setValueSrc: setValueSrc,
                  setValue: setValue,
                  widgetId: widgetId,
                  widgetType: widgetType
                };
              });
              return {
                defaultWidget: defaultWidget,
                fieldDefinition: fieldDefinition,
                operatorDefinition: operatorDefinition,
                isSpecialRange: isTrueSpecialRange,
                cardinality: cardinality,
                valueSources: valueSources,
                valueSourcesOptions: valueSourcesOptions,
                widgets: widgets,
                iValues: iValues,
                //correct for isFuncArg
                aField: field,
                //correct for isFuncArg
                asyncListValues: asyncListValues
              };
            }
          }, {
            key: "render",
            value: function render() {
              if (!this.meta) return null;
              var _this$meta3 = this.meta,
                defaultWidget = _this$meta3.defaultWidget,
                cardinality = _this$meta3.cardinality;
              if (!defaultWidget) return null;
              var name = defaultWidget;
              return /*#__PURE__*/React.createElement(Col, {
                className: "rule--widget rule--widget--".concat(name.toUpperCase()),
                key: "widget-col-" + name
              }, range$1(0, cardinality).map(this.renderWidgetDelta));
            }
          }]);
        }(reactExports.Component);
        Widget.propTypes = {
          config: PropTypes.object.isRequired,
          value: PropTypes.any,
          //instanceOf(Immutable.List)
          valueSrc: PropTypes.any,
          //instanceOf(Immutable.List)
          valueError: PropTypes.any,
          //instanceOf(Immutable.List)
          fieldError: PropTypes.string,
          field: PropTypes.any,
          fieldSrc: PropTypes.string,
          fieldType: PropTypes.string,
          fieldId: PropTypes.string,
          operator: PropTypes.string,
          readonly: PropTypes.bool,
          asyncListValues: PropTypes.array,
          id: PropTypes.string,
          groupId: PropTypes.string,
          //actions
          setValue: PropTypes.func,
          setValueSrc: PropTypes.func,
          setFuncValue: PropTypes.func,
          // for isFuncArg
          isFuncArg: PropTypes.bool,
          fieldFunc: PropTypes.string,
          fieldArg: PropTypes.string,
          leftField: PropTypes.any,
          // for RuleGroupExt
          isForRuleGroup: PropTypes.bool,
          parentField: PropTypes.string,
          // for func in func
          parentFuncs: PropTypes.array,
          isLHS: PropTypes.bool,
          // for case_value
          isCaseValue: PropTypes.bool
        };
        function _callSuper$h(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$h() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$h() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$h = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var getFuncConfig = Utils$1.ConfigUtils.getFuncConfig;
        var shallowEqual = Utils$1.OtherUtils.shallowEqual;
        var FuncWidget = /*#__PURE__*/function (_Component) {
          function FuncWidget(props) {
            var _this;
            _classCallCheck$b(this, FuncWidget);
            _this = _callSuper$h(this, FuncWidget, [props]);
            _this.setFunc = function (funcKey) {
              var _meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var _this$props = _this.props,
                isLHS = _this$props.isLHS,
                delta = _this$props.delta,
                parentFuncs = _this$props.parentFuncs,
                id = _this$props.id;
              if (!_meta.widgetId) {
                var widgetId = getWidgetId({
                  id: id,
                  isLHS: isLHS,
                  delta: delta,
                  parentFuncs: parentFuncs
                });
                _meta.widgetId = widgetId;
              }
              _this.props.setFuncValue(isLHS ? -1 : delta || 0, parentFuncs, null, funcKey, "!func", undefined, _meta);
            };
            _this.setArgValue = function (argKey, argVal, widgetType, asyncListValues, _meta) {
              var _this$props2 = _this.props;
              _this$props2.config;
              var delta = _this$props2.delta,
                isLHS = _this$props2.isLHS,
                parentFuncs = _this$props2.parentFuncs;
              _this.props.setFuncValue(isLHS ? -1 : delta || 0, parentFuncs, argKey, argVal, widgetType, asyncListValues, _meta);
            };
            _this.setArgValueSrc = function (argKey, argValSrc, _meta) {
              var _this$props3 = _this.props;
              _this$props3.config;
              var delta = _this$props3.delta,
                isLHS = _this$props3.isLHS,
                parentFuncs = _this$props3.parentFuncs;
              _this.props.setFuncValue(isLHS ? -1 : delta || 0, parentFuncs, argKey, argValSrc, "!valueSrc", undefined, _meta);
            };
            _this.renderFuncSelect = function () {
              var _value$get, _value$get2;
              var _this$props4 = _this.props,
                config = _this$props4.config,
                field = _this$props4.field,
                fieldType = _this$props4.fieldType,
                fieldSrc = _this$props4.fieldSrc,
                isLHS = _this$props4.isLHS,
                operator = _this$props4.operator,
                customProps = _this$props4.customProps,
                value = _this$props4.value,
                readonly = _this$props4.readonly,
                parentFuncs = _this$props4.parentFuncs,
                id = _this$props4.id,
                groupId = _this$props4.groupId,
                isFuncArg = _this$props4.isFuncArg,
                fieldDefinition = _this$props4.fieldDefinition;
              var funcKey = (_value$get = value === null || value === void 0 || (_value$get2 = value.get) === null || _value$get2 === void 0 ? void 0 : _value$get2.call(value, "func")) !== null && _value$get !== void 0 ? _value$get : null;
              var selectProps = {
                value: funcKey,
                setValue: _this.setFunc,
                config: config,
                field: field,
                fieldType: fieldType,
                fieldSrc: fieldSrc,
                isLHS: isLHS,
                operator: operator,
                customProps: customProps,
                readonly: readonly,
                parentFuncs: parentFuncs,
                isFuncArg: isFuncArg,
                fieldDefinition: fieldDefinition,
                id: id,
                groupId: groupId
              };
              var _config$settings = config.settings,
                showLabels = _config$settings.showLabels,
                funcLabel = _config$settings.funcLabel;
              var widgetLabel = showLabels ? /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, funcLabel) : null;
              return /*#__PURE__*/React.createElement(Col, {
                key: "func",
                className: "rule--func"
              }, widgetLabel, /*#__PURE__*/React.createElement(FuncSelect, selectProps));
            };
            _this.renderArgLabel = function (argKey, argDefinition) {
              var valueSources = argDefinition.valueSources,
                type = argDefinition.type,
                showPrefix = argDefinition.showPrefix,
                label = argDefinition.label;
              var config = _this.props.config;
              var isConst = valueSources && valueSources.length == 1 && valueSources[0] == "const";
              var forceShow = !config.settings.showLabels && (type == "boolean" || isConst) && showPrefix;
              if (!forceShow) return null;
              return /*#__PURE__*/React.createElement(Col, {
                className: "rule--func--arg-label"
              }, label || argKey);
            };
            _this.renderArgLabelSep = function (argKey, argDefinition) {
              var valueSources = argDefinition.valueSources,
                type = argDefinition.type,
                showPrefix = argDefinition.showPrefix;
              var config = _this.props.config;
              var isConst = valueSources && valueSources.length == 1 && valueSources[0] == "const";
              var forceShow = !config.settings.showLabels && (type == "boolean" || isConst) && showPrefix;
              if (!forceShow) return null;
              return /*#__PURE__*/React.createElement(Col, {
                className: "rule--func--arg-label-sep"
              }, ":");
            };
            _this.renderArgVal = function (funcKey, argKey, argDefinition) {
              var _this$props5 = _this.props,
                config = _this$props5.config,
                field = _this$props5.field,
                fieldType = _this$props5.fieldType,
                fieldSrc = _this$props5.fieldSrc,
                isLHS = _this$props5.isLHS;
              _this$props5.operator;
              var value = _this$props5.value,
                readonly = _this$props5.readonly,
                parentFuncs = _this$props5.parentFuncs,
                id = _this$props5.id,
                groupId = _this$props5.groupId,
                fieldError = _this$props5.fieldError,
                valueError = _this$props5.valueError,
                setFuncValue = _this$props5.setFuncValue;
              var arg = value ? value.getIn(["args", argKey]) : null;
              var argVal = arg ? arg.get("value") : undefined;
              var defaultValueSource = argDefinition.valueSources.length == 1 ? argDefinition.valueSources[0] : undefined;
              var argValSrc = arg ? arg.get("valueSrc") || defaultValueSource || "value" : defaultValueSource;
              var widgetProps = {
                config: config,
                fieldFunc: funcKey,
                fieldArg: argKey,
                leftField: field,
                fieldType: fieldType,
                // type of leftField
                fieldSrc: fieldSrc,
                // src of leftField
                fieldError: fieldError,
                // error in LHS
                valueError: valueError,
                // error in RHS
                isLHS: isLHS,
                operator: null,
                value: argVal,
                valueSrc: argValSrc,
                setValue: _this.setArgValue,
                setValueSrc: _this.setArgValueSrc,
                setFuncValue: setFuncValue,
                funcKey: funcKey,
                argKey: argKey,
                argDefinition: argDefinition,
                readonly: readonly,
                parentFuncs: parentFuncs,
                id: id,
                groupId: groupId
              };
              //tip: value & valueSrc will be converted to Immutable.List at <Widget>

              return /*#__PURE__*/React.createElement(Col, {
                className: "rule--func--arg-value"
              }, /*#__PURE__*/React.createElement(ArgWidget, widgetProps));
            };
            _this.renderArgSep = function (argKey, argDefinition, argIndex, _ref) {
              var renderSeps = _ref.renderSeps;
              if (!argIndex) return null;
              return /*#__PURE__*/React.createElement(Col, {
                className: "rule--func--arg-sep"
              }, renderSeps ? renderSeps[argIndex - 1] : ", ");
            };
            _this.renderBracketBefore = function (_ref2) {
              var renderBrackets = _ref2.renderBrackets;
              return /*#__PURE__*/React.createElement(Col, {
                key: "before_args",
                className: "rule--func--bracket-before"
              }, renderBrackets ? renderBrackets[0] : "(");
            };
            _this.renderBracketAfter = function (_ref3) {
              var renderBrackets = _ref3.renderBrackets;
              return /*#__PURE__*/React.createElement(Col, {
                key: "after_args",
                className: "rule--func--bracket-after"
              }, renderBrackets ? renderBrackets[1] : ")");
            };
            _this.renderFuncArgs = function () {
              var _this$meta = _this.meta,
                funcDefinition = _this$meta.funcDefinition,
                funcKey = _this$meta.funcKey;
              if (!funcKey) return null;
              var _ref4 = funcDefinition || {},
                args = _ref4.args;
              if (!args) return null;
              return /*#__PURE__*/React.createElement(React.Fragment, null, _this.renderBracketBefore(funcDefinition), /*#__PURE__*/React.createElement(Col, {
                key: "args-".concat(funcKey),
                className: "rule--func--args rule--func--".concat(funcKey, "--args")
              }, Object.keys(args).map(function (argKey, argIndex) {
                return /*#__PURE__*/React.createElement(Col, {
                  key: "arg-".concat(argKey, "-").concat(argIndex),
                  className: "rule--func--arg rule--func--".concat(funcKey, "--arg--").concat(argKey)
                }, _this.renderArgSep(argKey, args[argKey], argIndex, funcDefinition), _this.renderArgLabel(argKey, args[argKey]), _this.renderArgLabelSep(argKey, args[argKey]), _this.renderArgVal(funcKey, argKey, args[argKey]));
              })), _this.renderBracketAfter(funcDefinition));
            };
            useOnPropsChanged(_this);
            _this.onPropsChanged(props);
            return _this;
          }
          _inherits$b(FuncWidget, _Component);
          return _createClass$9(FuncWidget, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var keysForMeta = ["config", "field", "operator", "value", "fieldSrc", "fieldType", "isLHS"];
              var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
                return k === "parentFuncs" ? !shallowEqual(nextProps[k], prevProps[k], true) : nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps);
              }
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref5) {
              var _value$get3, _value$get4;
              var config = _ref5.config;
              _ref5.field;
              _ref5.operator;
              var value = _ref5.value;
              var funcKey = (_value$get3 = value === null || value === void 0 || (_value$get4 = value.get) === null || _value$get4 === void 0 ? void 0 : _value$get4.call(value, "func")) !== null && _value$get3 !== void 0 ? _value$get3 : null;
              var funcDefinition = funcKey ? getFuncConfig(config, funcKey) : null;
              return {
                funcDefinition: funcDefinition,
                funcKey: funcKey
              };
            }
          }, {
            key: "render",
            value: function render() {
              var parentFuncs = this.props.parentFuncs;
              var funcPath = parentFuncs ? parentFuncs.map(function (_ref6) {
                var _ref7 = _slicedToArray$1(_ref6, 2),
                  f = _ref7[0],
                  a = _ref7[1];
                return "".concat(f, "_").concat(a);
              }).join("-") : "root";
              var funcLevel = (parentFuncs === null || parentFuncs === void 0 ? void 0 : parentFuncs.length) || 0;
              return /*#__PURE__*/React.createElement(Col, {
                className: "rule--func--wrapper rule--func--wrapper--under-".concat(funcPath, " rule--func--wrapper--lev-").concat(funcLevel)
              }, this.renderFuncSelect(), this.renderFuncArgs());
            }
          }]);
        }(reactExports.Component);
        FuncWidget.propTypes = {
          id: PropTypes.string,
          groupId: PropTypes.string,
          config: PropTypes.object.isRequired,
          field: PropTypes.any,
          fieldSrc: PropTypes.string,
          fieldType: PropTypes.string,
          fieldError: PropTypes.string,
          operator: PropTypes.string,
          customProps: PropTypes.object,
          value: PropTypes.object,
          //instanceOf(Immutable.Map) //with keys 'func' and `args`
          setValue: PropTypes.func.isRequired,
          setFuncValue: PropTypes.func,
          readonly: PropTypes.bool,
          parentFuncs: PropTypes.array,
          fieldDefinition: PropTypes.object,
          isFuncArg: PropTypes.bool,
          isLHS: PropTypes.bool,
          valueError: PropTypes.string
        };
        var ArgWidget = /*#__PURE__*/function (_Component2) {
          function ArgWidget(props) {
            var _this2;
            _classCallCheck$b(this, ArgWidget);
            _this2 = _callSuper$h(this, ArgWidget, [props]);
            _this2.setValue = function (_delta, value, widgetType, asyncListValues, _meta) {
              var _this2$props = _this2.props,
                setValue = _this2$props.setValue,
                argKey = _this2$props.argKey;
              setValue(argKey, value, widgetType, asyncListValues, _meta);
            };
            _this2.setValueSrc = function (_delta, valueSrc, _meta) {
              var _this2$props2 = _this2.props,
                setValueSrc = _this2$props2.setValueSrc,
                argKey = _this2$props2.argKey;
              setValueSrc(argKey, valueSrc, _meta);
            };
            useOnPropsChanged(_this2);
            _this2.onPropsChanged(props);
            return _this2;
          }
          _inherits$b(ArgWidget, _Component2);
          return _createClass$9(ArgWidget, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var keysForMeta = ["parentFuncs", "funcKey", "argKey"];
              var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
                return k === "parentFuncs" ? !shallowEqual(nextProps[k], prevProps[k], true) : nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps);
              }
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref8) {
              var parentFuncs = _ref8.parentFuncs,
                funcKey = _ref8.funcKey,
                argKey = _ref8.argKey;
              var newParentFuncs = [].concat(_toConsumableArray(parentFuncs || []), [[funcKey, argKey]]);
              return {
                parentFuncs: newParentFuncs
              };
            }
          }, {
            key: "render",
            value: function render() {
              var parentFuncs = this.meta.parentFuncs;
              return /*#__PURE__*/React.createElement(Widget, _extends$h({}, this.props, {
                setValue: this.setValue,
                setValueSrc: this.setValueSrc,
                isFuncArg: true,
                parentFuncs: parentFuncs
              }));
            }
          }]);
        }(reactExports.Component);
        ArgWidget.propTypes = {
          funcKey: PropTypes.string.isRequired,
          argKey: PropTypes.string.isRequired,
          setValue: PropTypes.func.isRequired,
          setValueSrc: PropTypes.func.isRequired,
          readonly: PropTypes.bool,
          isLHS: PropTypes.bool,
          parentFuncs: PropTypes.array,
          id: PropTypes.string,
          groupId: PropTypes.string
        };
        function _callSuper$g(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$g() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$g() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$g = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var FieldWrapper = /*#__PURE__*/function (_Component) {
          function FieldWrapper(props) {
            var _this;
            _classCallCheck$b(this, FieldWrapper);
            _this = _callSuper$g(this, FieldWrapper, [props]);
            _this.renderField = function () {
              var _this$props = _this.props,
                config = _this$props.config,
                classname = _this$props.classname,
                selectedField = _this$props.selectedField,
                selectedFieldSrc = _this$props.selectedFieldSrc,
                selectedFieldType = _this$props.selectedFieldType,
                setField = _this$props.setField,
                setFuncValue = _this$props.setFuncValue,
                parentField = _this$props.parentField,
                readonly = _this$props.readonly,
                id = _this$props.id,
                groupId = _this$props.groupId,
                fieldError = _this$props.fieldError,
                valueError = _this$props.valueError;
              var supportedFieldSrcs = ["func", "field"];
              if (!supportedFieldSrcs.includes(selectedFieldSrc)) {
                return "?";
              }
              var field = selectedFieldSrc === "func" ? /*#__PURE__*/React.createElement(FuncWidget, {
                isLHS: true,
                config: config,
                value: selectedField,
                fieldSrc: selectedFieldSrc,
                fieldType: selectedFieldType,
                fieldError: fieldError,
                valueError: valueError,
                parentField: parentField,
                setValue: setField,
                setFuncValue: setFuncValue,
                readonly: readonly,
                id: id,
                groupId: groupId,
                key: "field-func-" + id
              }) : /*#__PURE__*/React.createElement(Field, {
                config: config,
                selectedField: selectedField,
                selectedFieldSrc: selectedFieldSrc,
                selectedFieldType: selectedFieldType,
                parentField: parentField,
                setField: setField,
                customProps: config.settings.customFieldSelectProps,
                readonly: readonly,
                id: id,
                groupId: groupId,
                key: "field-" + id
              });
              var fieldLabel = selectedFieldSrc === "func" ? config.settings.funcLabel : config.settings.fieldLabel;
              var label = config.settings.showLabels && selectedFieldSrc !== "func" && /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, fieldLabel);
              return /*#__PURE__*/React.createElement("div", {
                key: selectedFieldSrc,
                className: classname
              }, label, field);
            };
            _this.renderFieldSources = function () {
              if (!_this.meta) return null;
              var _this$props2 = _this.props,
                config = _this$props2.config,
                readonly = _this$props2.readonly,
                selectedFieldSrc = _this$props2.selectedFieldSrc,
                setFieldSrc = _this$props2.setFieldSrc,
                id = _this$props2.id;
              var fieldSourcesOptions = _this.meta.fieldSourcesOptions;
              var settings = config.settings;
              var ValueSources = _this.ValueSources;
              var sourceLabel = settings.showLabels ? /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, "\xA0") : null;
              return fieldSourcesOptions.length > 1 && !readonly && /*#__PURE__*/React.createElement("div", {
                key: "fieldsrc",
                className: "rule--fieldsrc"
              }, sourceLabel, /*#__PURE__*/React.createElement(ValueSources, {
                key: "fieldsrc-" + id,
                valueSources: fieldSourcesOptions,
                valueSrc: selectedFieldSrc,
                config: config,
                setValueSrc: setFieldSrc,
                readonly: readonly,
                title: settings.fieldSourcesPopupTitle
              }));
            };
            useOnPropsChanged(_this);
            _this.onPropsChanged(props);
            return _this;
          }
          _inherits$b(FieldWrapper, _Component);
          return _createClass$9(FieldWrapper, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var configChanged = !this.ValueSources || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.config) !== (nextProps === null || nextProps === void 0 ? void 0 : nextProps.config);
              var keysForMeta = ["config"];
              var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
                return nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps);
              }
              if (configChanged) {
                var config = nextProps.config;
                var renderValueSources = config.settings.renderValueSources;
                this.ValueSources = function (pr) {
                  return renderValueSources(pr, config.ctx);
                };
              }
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref) {
              var config = _ref.config;
              var _config$settings = config.settings,
                valueSourcesInfo = _config$settings.valueSourcesInfo,
                fieldSources = _config$settings.fieldSources;
              var fieldSourcesOptions = fieldSources.map(function (srcKey) {
                return [srcKey, {
                  label: valueSourcesInfo[srcKey].label
                }];
              });
              return {
                fieldSourcesOptions: fieldSourcesOptions
              };
            }
          }, {
            key: "render",
            value: function render() {
              var _this$props3 = this.props;
              _this$props3.classname;
              var canSelectFieldSource = _this$props3.canSelectFieldSource;
              var fieldSources = canSelectFieldSource && this.renderFieldSources();
              var field = this.renderField();
              if (!canSelectFieldSource) {
                return field;
              } else {
                return /*#__PURE__*/React.createElement(Col, {
                  className: "rule--field-wrapper"
                }, fieldSources, field);
              }
            }
          }]);
        }(reactExports.Component);
        var _excluded$5 = ["factory"];
        function _callSuper$f(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$f() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$f() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$f = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var getOperatorConfig$1 = Utils$1.ConfigUtils.getOperatorConfig;
        var OperatorOptions = /*#__PURE__*/function (_PureComponent) {
          function OperatorOptions() {
            _classCallCheck$b(this, OperatorOptions);
            return _callSuper$f(this, OperatorOptions, arguments);
          }
          _inherits$b(OperatorOptions, _PureComponent);
          return _createClass$9(OperatorOptions, [{
            key: "render",
            value: function render() {
              if (!this.props.selectedOperator) return null;
              var operatorDefinitions = getOperatorConfig$1(this.props.config, this.props.selectedOperator, this.props.selectedField);
              if (typeof operatorDefinitions.options === "undefined") {
                return null;
              }
              var _operatorDefinitions$ = operatorDefinitions.options,
                optionsFactory = _operatorDefinitions$.factory,
                basicOptionsProps = _objectWithoutProperties$2(_operatorDefinitions$, _excluded$5);
              var optionsProps = Object.assign({}, basicOptionsProps, {
                config: this.props.config,
                field: this.props.selectedField,
                fieldSrc: this.props.selectedFieldSrc,
                operator: this.props.selectedOperator,
                options: this.props.operatorOptions,
                setOption: this.props.setOperatorOption,
                readonly: this.props.readonly
              });
              var optionsCmp = optionsFactory(optionsProps, this.props.config.ctx);
              var name = this.props.selectedOperator;
              return /*#__PURE__*/React.createElement("div", {
                className: "rule--operator rule--operator--".concat(name.toUpperCase())
              }, optionsCmp);
            }
          }]);
        }(reactExports.PureComponent);
        OperatorOptions.propTypes = {
          config: PropTypes.object.isRequired,
          operatorOptions: PropTypes.any.isRequired,
          //instanceOf(Immutable.Map)
          selectedField: PropTypes.any,
          selectedFieldSrc: PropTypes.string,
          selectedOperator: PropTypes.string.isRequired,
          readonly: PropTypes.bool,
          //actions
          setOperatorOption: PropTypes.func.isRequired
        };
        function ownKeys$d(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$d(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$d(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _callSuper$e(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$e() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$e() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$e = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var _Utils$ConfigUtils$2 = Utils$1.ConfigUtils,
          getFieldConfig$2 = _Utils$ConfigUtils$2.getFieldConfig,
          getOperatorConfig = _Utils$ConfigUtils$2.getOperatorConfig,
          getFieldWidgetConfig$1 = _Utils$ConfigUtils$2.getFieldWidgetConfig,
          getFieldId = _Utils$ConfigUtils$2.getFieldId;
        var isEmptyRuleProperties = Utils$1.RuleUtils.isEmptyRuleProperties;
        var Rule = /*#__PURE__*/function (_Component) {
          function Rule(props) {
            var _this;
            _classCallCheck$b(this, Rule);
            _this = _callSuper$e(this, Rule, [props]);
            useOnPropsChanged(_this);
            _this.removeSelf = _this.removeSelf.bind(_this);
            _this.setLock = _this.setLock.bind(_this);
            _this.onPropsChanged(props);
            return _this;
          }
          _inherits$b(Rule, _Component);
          return _createClass$9(Rule, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var _this2 = this;
              var prevProps = this.props;
              var configChanged = !this.Icon || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.config) !== (nextProps === null || nextProps === void 0 ? void 0 : nextProps.config);
              var keysForMeta = ["selectedField", "selectedFieldSrc", "selectedFieldType", "selectedOperator", "config", "reordableNodesCnt", "isLocked"];
              var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
                return nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps);
              }
              if (configChanged) {
                var config = nextProps.config;
                var _config$settings = config.settings,
                  renderIcon = _config$settings.renderIcon,
                  renderButton = _config$settings.renderButton,
                  renderButtonGroup = _config$settings.renderButtonGroup,
                  renderSwitch = _config$settings.renderSwitch,
                  renderBeforeWidget = _config$settings.renderBeforeWidget,
                  renderAfterWidget = _config$settings.renderAfterWidget,
                  renderRuleError = _config$settings.renderRuleError;
                this.Icon = getRenderFromConfig(config, renderIcon);
                this.Btn = getRenderFromConfig(config, renderButton);
                this.BtnGrp = getRenderFromConfig(config, renderButtonGroup);
                this.Switch = getRenderFromConfig(config, renderSwitch);
                this.BeforeWidget = getRenderFromConfig(config, renderBeforeWidget);
                this.AfterWidget = getRenderFromConfig(config, renderAfterWidget);
                this.RuleError = getRenderFromConfig(config, renderRuleError);
              }
              this.doRemove = function () {
                _this2.props.removeSelf();
              };
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref) {
              var selectedField = _ref.selectedField,
                selectedFieldType = _ref.selectedFieldType,
                selectedOperator = _ref.selectedOperator,
                config = _ref.config,
                reordableNodesCnt = _ref.reordableNodesCnt,
                isLocked = _ref.isLocked;
              var keepInputOnChangeFieldSrc = config.settings.keepInputOnChangeFieldSrc;
              var selectedFieldId = getFieldId(selectedField, config);
              var selectedFieldConfig = getFieldConfig$2(config, selectedField);
              var isSelectedGroup = selectedFieldConfig && selectedFieldConfig.type === "!struct";
              var isOkWithoutField = keepInputOnChangeFieldSrc && selectedFieldType;
              var isFieldSelected = !!selectedField || isOkWithoutField;
              var isFieldAndOpSelected = isFieldSelected && selectedOperator;
              var selectedOperatorConfig = getOperatorConfig(config, selectedOperator, selectedField);
              var selectedOperatorHasOptions = selectedOperatorConfig && selectedOperatorConfig.options != null;
              var selectedFieldWidgetConfig = getFieldWidgetConfig$1(config, selectedField, selectedOperator, null, null) || {};
              var hideOperator = selectedFieldWidgetConfig.hideOperator;
              var showDragIcon = config.settings.canReorder && reordableNodesCnt > 1 && !isLocked;
              var showOperator = isFieldSelected && !hideOperator;
              var showOperatorLabel = isFieldSelected && hideOperator && selectedFieldWidgetConfig.operatorInlineLabel;
              var showWidget = isFieldAndOpSelected && !isSelectedGroup;
              var showOperatorOptions = isFieldAndOpSelected && selectedOperatorHasOptions;
              return {
                selectedFieldId: selectedFieldId,
                selectedFieldWidgetConfig: selectedFieldWidgetConfig,
                showDragIcon: showDragIcon,
                showOperator: showOperator,
                showOperatorLabel: showOperatorLabel,
                showWidget: showWidget,
                showOperatorOptions: showOperatorOptions
              };
            }
          }, {
            key: "setLock",
            value: function setLock(lock) {
              this.props.setLock(lock);
            }
          }, {
            key: "removeSelf",
            value: function removeSelf() {
              var _this$props = this.props,
                confirmFn = _this$props.confirmFn,
                config = _this$props.config;
              var _config$settings2 = config.settings,
                renderConfirm = _config$settings2.renderConfirm,
                confirmOptions = _config$settings2.removeRuleConfirmOptions;
              if (confirmOptions && !this.isEmptyCurrentRule()) {
                renderConfirm.call(config.ctx, _objectSpread$d(_objectSpread$d({}, confirmOptions), {}, {
                  onOk: this.doRemove,
                  onCancel: null,
                  confirmFn: confirmFn
                }), config.ctx);
              } else {
                this.doRemove();
              }
            }
          }, {
            key: "_buildWidgetProps",
            value: function _buildWidgetProps(_ref2, _ref3) {
              var selectedField = _ref2.selectedField,
                selectedFieldSrc = _ref2.selectedFieldSrc,
                selectedFieldType = _ref2.selectedFieldType,
                selectedOperator = _ref2.selectedOperator,
                operatorOptions = _ref2.operatorOptions,
                value = _ref2.value,
                valueType = _ref2.valueType,
                valueSrc = _ref2.valueSrc,
                asyncListValues = _ref2.asyncListValues,
                valueError = _ref2.valueError,
                fieldError = _ref2.fieldError,
                parentField = _ref2.parentField;
              var selectedFieldId = _ref3.selectedFieldId;
              return {
                field: selectedField,
                fieldSrc: selectedFieldSrc,
                fieldType: selectedFieldType,
                fieldId: selectedFieldId,
                operator: selectedOperator,
                operatorOptions: operatorOptions,
                value: value,
                valueType: valueType,
                valueSrc: valueSrc,
                asyncListValues: asyncListValues,
                valueError: valueError,
                fieldError: fieldError,
                parentField: parentField
              };
            }
          }, {
            key: "isEmptyCurrentRule",
            value: function isEmptyCurrentRule() {
              var config = this.props.config;
              var ruleData = this._buildWidgetProps(this.props, this.meta);
              return isEmptyRuleProperties(ruleData, config);
            }
          }, {
            key: "renderField",
            value: function renderField() {
              var _this$props2 = this.props,
                config = _this$props2.config,
                isLocked = _this$props2.isLocked,
                parentField = _this$props2.parentField,
                groupId = _this$props2.groupId,
                id = _this$props2.id,
                selectedFieldSrc = _this$props2.selectedFieldSrc,
                selectedField = _this$props2.selectedField,
                selectedFieldType = _this$props2.selectedFieldType,
                setField = _this$props2.setField,
                setFuncValue = _this$props2.setFuncValue,
                setFieldSrc = _this$props2.setFieldSrc,
                fieldError = _this$props2.fieldError;
              var immutableFieldsMode = config.settings.immutableFieldsMode;
              var selectedFieldId = this.meta.selectedFieldId;
              // tip: don't allow function inside !group (yet)

              return /*#__PURE__*/React.createElement(FieldWrapper, {
                key: "field",
                classname: classNames(selectedFieldSrc == "func" ? "rule--field--func" : "rule--field"),
                config: config,
                canSelectFieldSource: !parentField,
                selectedField: selectedField,
                selectedFieldSrc: selectedFieldSrc,
                selectedFieldType: selectedFieldType,
                selectedFieldId: selectedFieldId,
                fieldError: fieldError,
                setField: !immutableFieldsMode ? setField : dummyFn,
                setFuncValue: !immutableFieldsMode ? setFuncValue : dummyFn,
                setFieldSrc: !immutableFieldsMode ? setFieldSrc : dummyFn,
                parentField: parentField,
                readonly: immutableFieldsMode || isLocked,
                id: id,
                groupId: groupId
              });
            }
          }, {
            key: "renderOperator",
            value: function renderOperator() {
              var _this$props3 = this.props,
                config = _this$props3.config,
                isLocked = _this$props3.isLocked;
              var _this$meta = this.meta,
                selectedFieldId = _this$meta.selectedFieldId,
                selectedFieldWidgetConfig = _this$meta.selectedFieldWidgetConfig,
                showOperator = _this$meta.showOperator,
                showOperatorLabel = _this$meta.showOperatorLabel;
              var immutableOpsMode = config.settings.immutableOpsMode;
              return /*#__PURE__*/React.createElement(OperatorWrapper, {
                key: "operator",
                config: config,
                selectedField: this.props.selectedField,
                selectedFieldSrc: this.props.selectedFieldSrc,
                selectedFieldType: this.props.selectedFieldType,
                selectedFieldId: selectedFieldId,
                selectedOperator: this.props.selectedOperator,
                setOperator: !immutableOpsMode ? this.props.setOperator : dummyFn,
                showOperator: showOperator,
                showOperatorLabel: showOperatorLabel,
                selectedFieldWidgetConfig: selectedFieldWidgetConfig,
                readonly: immutableOpsMode || isLocked,
                id: this.props.id,
                groupId: this.props.groupId
              });
            }
          }, {
            key: "renderWidget",
            value: function renderWidget() {
              var _this$props4 = this.props,
                config = _this$props4.config,
                isLocked = _this$props4.isLocked;
              var showWidget = this.meta.showWidget;
              var immutableValuesMode = config.settings.immutableValuesMode;
              if (!showWidget) return null;
              var widget = /*#__PURE__*/React.createElement(Widget, _extends$h({
                key: "values"
              }, this._buildWidgetProps(this.props, this.meta), {
                config: config,
                setValue: !immutableValuesMode ? this.props.setValue : dummyFn,
                setValueSrc: !immutableValuesMode ? this.props.setValueSrc : dummyFn,
                setFuncValue: !immutableValuesMode ? this.props.setFuncValue : dummyFn,
                readonly: immutableValuesMode || isLocked,
                id: this.props.id,
                groupId: this.props.groupId
              }));
              return /*#__PURE__*/React.createElement(Col, {
                key: "widget-for-" + this.props.selectedOperator,
                className: "rule--value"
              }, widget);
            }
          }, {
            key: "renderOperatorOptions",
            value: function renderOperatorOptions() {
              var config = this.props.config;
              var showOperatorOptions = this.meta.showOperatorOptions;
              var _config$settings3 = config.settings,
                immutableOpsMode = _config$settings3.immutableOpsMode,
                immutableValuesMode = _config$settings3.immutableValuesMode;
              if (!showOperatorOptions) return null;
              var opOpts = /*#__PURE__*/React.createElement(OperatorOptions, {
                key: "operatorOptions",
                selectedField: this.props.selectedField,
                selectedOperator: this.props.selectedOperator,
                operatorOptions: this.props.operatorOptions,
                setOperatorOption: !immutableOpsMode ? this.props.setOperatorOption : dummyFn,
                config: config,
                readonly: immutableValuesMode
              });
              return /*#__PURE__*/React.createElement(Col, {
                key: "op-options-for-" + this.props.selectedOperator,
                className: "rule--operator-options"
              }, opOpts);
            }
          }, {
            key: "renderBeforeWidget",
            value: function renderBeforeWidget() {
              var BeforeWidget = this.BeforeWidget;
              if (!BeforeWidget) return null;
              return /*#__PURE__*/React.createElement(Col, {
                key: "before-widget-for-" + this.props.selectedOperator,
                className: "rule--before-widget"
              }, /*#__PURE__*/React.createElement(BeforeWidget, this.props));
            }
          }, {
            key: "renderAfterWidget",
            value: function renderAfterWidget() {
              var AfterWidget = this.AfterWidget;
              if (!AfterWidget) return null;
              return /*#__PURE__*/React.createElement(Col, {
                key: "after-widget-for-" + this.props.selectedOperator,
                className: "rule--after-widget"
              }, /*#__PURE__*/React.createElement(AfterWidget, this.props));
            }
          }, {
            key: "renderError",
            value: function renderError() {
              var _this$props5 = this.props,
                config = _this$props5.config,
                valueError = _this$props5.valueError,
                fieldError = _this$props5.fieldError;
              var showErrorMessage = config.settings.showErrorMessage;
              var RuleError = this.RuleError;
              var oneError = [fieldError].concat(_toConsumableArray((valueError === null || valueError === void 0 ? void 0 : valueError.toArray()) || [])).filter(function (e) {
                return !!e;
              }).shift() || null;
              return showErrorMessage && oneError && /*#__PURE__*/React.createElement("div", {
                className: "rule--error"
              }, RuleError ? /*#__PURE__*/React.createElement(RuleError, {
                error: oneError
              }) : oneError);
            }
          }, {
            key: "renderDrag",
            value: function renderDrag() {
              var handleDraggerMouseDown = this.props.handleDraggerMouseDown;
              var showDragIcon = this.meta.showDragIcon;
              var Icon = this.Icon;
              var icon = /*#__PURE__*/React.createElement(Icon, {
                type: "drag"
              });
              return showDragIcon && /*#__PURE__*/React.createElement("div", {
                key: "rule-drag-icon",
                onMouseDown: handleDraggerMouseDown,
                className: "qb-drag-handler rule--drag-handler"
              }, icon);
            }
          }, {
            key: "renderDel",
            value: function renderDel() {
              var _this$props6 = this.props,
                config = _this$props6.config,
                isLocked = _this$props6.isLocked;
              var _config$settings4 = config.settings,
                deleteLabel = _config$settings4.deleteLabel,
                immutableGroupsMode = _config$settings4.immutableGroupsMode,
                canDeleteLocked = _config$settings4.canDeleteLocked;
              var Icon = this.Icon;
              var Btn = this.Btn;
              return !immutableGroupsMode && (!isLocked || isLocked && canDeleteLocked) && /*#__PURE__*/React.createElement(Btn, {
                key: "rule-del",
                type: "delRule",
                onClick: this.removeSelf,
                label: deleteLabel,
                config: config,
                renderIcon: Icon
              });
            }
          }, {
            key: "renderLock",
            value: function renderLock() {
              var _this$props7 = this.props,
                config = _this$props7.config,
                isLocked = _this$props7.isLocked,
                isTrueLocked = _this$props7.isTrueLocked,
                id = _this$props7.id;
              var _config$settings5 = config.settings,
                lockLabel = _config$settings5.lockLabel,
                lockedLabel = _config$settings5.lockedLabel,
                showLock = _config$settings5.showLock;
              var Switch = this.Switch;
              return showLock && !(isLocked && !isTrueLocked) && /*#__PURE__*/React.createElement(Switch, {
                key: "rule-lock",
                type: "lock",
                id: id,
                value: isLocked,
                setValue: this.setLock,
                label: lockLabel,
                checkedLabel: lockedLabel,
                hideLabel: true,
                config: config
              });
            }
          }, {
            key: "render",
            value: function render() {
              var _this$meta2 = this.meta,
                showOperatorOptions = _this$meta2.showOperatorOptions,
                selectedFieldWidgetConfig = _this$meta2.selectedFieldWidgetConfig;
              var _this$props8 = this.props,
                valueSrc = _this$props8.valueSrc,
                value = _this$props8.value,
                config = _this$props8.config;
              var canShrinkValue = (valueSrc === null || valueSrc === void 0 ? void 0 : valueSrc.first()) == "value" && !showOperatorOptions && value.size == 1 && selectedFieldWidgetConfig.fullWidth;
              var BtnGrp = this.BtnGrp;
              var parts = [this.renderField(), this.renderOperator(), this.renderBeforeWidget(), this.renderWidget(), this.renderAfterWidget(), this.renderOperatorOptions()];
              var body = /*#__PURE__*/React.createElement("div", {
                key: "rule-body",
                className: classNames("rule--body", canShrinkValue && "can--shrink--value")
              }, parts);
              var error = this.renderError();
              var drag = this.renderDrag();
              var lock = this.renderLock();
              var del = this.renderDel();
              return /*#__PURE__*/React.createElement(React.Fragment, null, drag, /*#__PURE__*/React.createElement("div", {
                key: "rule-body-wrapper",
                className: "rule--body--wrapper"
              }, body, error), /*#__PURE__*/React.createElement("div", {
                key: "rule-header-wrapper",
                className: "rule--header"
              }, /*#__PURE__*/React.createElement(BtnGrp, {
                key: "rule-header-group",
                config: config
              }, lock, del)));
            }
          }]);
        }(reactExports.Component);
        Rule.propTypes = {
          id: PropTypes.string.isRequired,
          groupId: PropTypes.string,
          selectedField: PropTypes.any,
          selectedFieldSrc: PropTypes.string,
          selectedFieldType: PropTypes.string,
          selectedOperator: PropTypes.string,
          operatorOptions: PropTypes.object,
          config: PropTypes.object.isRequired,
          value: PropTypes.any,
          //depends on widget
          valueSrc: PropTypes.any,
          valueType: PropTypes.any,
          asyncListValues: PropTypes.array,
          isDraggingMe: PropTypes.bool,
          isDraggingTempo: PropTypes.bool,
          parentField: PropTypes.string,
          //from RuleGroup
          valueError: PropTypes.any,
          fieldError: PropTypes.string,
          isLocked: PropTypes.bool,
          isTrueLocked: PropTypes.bool,
          //path: PropTypes.instanceOf(Immutable.List),
          //actions
          handleDraggerMouseDown: PropTypes.func,
          setField: PropTypes.func,
          setFieldSrc: PropTypes.func,
          setOperator: PropTypes.func,
          setOperatorOption: PropTypes.func,
          setLock: PropTypes.func,
          removeSelf: PropTypes.func,
          setValue: PropTypes.func,
          setValueSrc: PropTypes.func,
          setFuncValue: PropTypes.func,
          reordableNodesCnt: PropTypes.number,
          totalRulesCnt: PropTypes.number,
          parentReordableNodesCnt: PropTypes.number
        };
        const Rule$1 = RuleContainer(Draggable("rule")(WithConfirmFn(Rule)));

        /**
         * The base implementation of `_.clamp` which doesn't coerce arguments.
         *
         * @private
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         */

        function baseClamp$1(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        var _baseClamp = baseClamp$1;
        var toFinite = toFinite_1;

        /**
         * Converts `value` to an integer.
         *
         * **Note:** This method is loosely based on
         * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toInteger(3.2);
         * // => 3
         *
         * _.toInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toInteger(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toInteger('3.2');
         * // => 3
         */
        function toInteger$1(value) {
          var result = toFinite(value),
            remainder = result % 1;
          return result === result ? remainder ? result - remainder : result : 0;
        }
        var toInteger_1 = toInteger$1;
        var baseClamp = _baseClamp,
          baseToString$1 = _baseToString,
          toInteger = toInteger_1,
          toString$1 = toString_1;

        /**
         * Checks if `string` starts with the given target string.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {string} [target] The string to search for.
         * @param {number} [position=0] The position to search from.
         * @returns {boolean} Returns `true` if `string` starts with `target`,
         *  else `false`.
         * @example
         *
         * _.startsWith('abc', 'a');
         * // => true
         *
         * _.startsWith('abc', 'b');
         * // => false
         *
         * _.startsWith('abc', 'b', 1);
         * // => true
         */
        function startsWith(string, target, position) {
          string = toString$1(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString$1(target);
          return string.slice(position, position + target.length) == target;
        }
        var startsWith_1 = startsWith;
        const startsWith$1 = /*@__PURE__*/getDefaultExportFromCjs(startsWith_1);
        function _callSuper$d(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$d() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$d() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$d = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var defaultGroupConjunction = Utils$1.DefaultUtils.defaultGroupConjunction;
        var createGroupContainer = function createGroupContainer(Group, itemType) {
          var _GroupContainer;
          return _GroupContainer = /*#__PURE__*/function (_Component) {
            function GroupContainer(_props) {
              var _this;
              _classCallCheck$b(this, GroupContainer);
              _this = _callSuper$d(this, GroupContainer, [_props]);
              _this._selectedConjunction = function (props) {
                props = props || _this.props;
                return props.conjunction || defaultGroupConjunction(props.config, props.field);
              };
              _this.setConjunction = function () {
                var conj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                _this.props.actions.setConjunction(_this.props.path, conj);
              };
              _this.setNot = function () {
                var not = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                _this.props.actions.setNot(_this.props.path, not);
              };
              _this.setLock = function () {
                var lock = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                _this.props.actions.setLock(_this.props.path, lock);
              };
              _this.dummyFn = function () {};
              _this.removeSelf = function () {
                _this.props.actions.removeGroup(_this.props.path);
              };
              _this.addGroup = function () {
                _this.props.actions.addGroup(_this.props.path);
              };
              _this.addCaseGroup = function () {
                _this.props.actions.addCaseGroup(_this.props.path);
              };
              _this.addDefaultCaseGroup = function () {
                _this.props.actions.addDefaultCaseGroup(_this.props.path);
              };
              _this.addRule = function () {
                var parentRuleGroupPath = itemType == "rule_group" ? _this.props.field : null;
                _this.props.actions.addRule(_this.props.path, undefined, undefined, undefined, parentRuleGroupPath);
              };
              // for RuleGroup
              _this.setField = function (field, asyncListValues, _meta) {
                _this.props.actions.setField(_this.props.path, field, asyncListValues, _meta);
              };
              // for RuleGroupExt
              _this.setOperator = function (operator) {
                _this.props.actions.setOperator(_this.props.path, operator);
              };
              // for RuleGroupExt, CaseGroup
              _this.setValue = function (delta, value, type, asyncListValues, _meta) {
                _this.props.actions.setValue(_this.props.path, delta, value, type, asyncListValues, _meta);
              };
              _this.setValueSrc = function (delta, srcKey, _meta) {
                _this.props.actions.setValueSrc(_this.props.path, delta, srcKey, _meta);
              };
              // can be used for both LHS and LHS
              _this.setFuncValue = function (delta, parentFuncs, argKey, value, type, asyncListValues, _meta) {
                _this.props.actions.setFuncValue(_this.props.path, delta, parentFuncs, argKey, value, type, asyncListValues, _meta);
              };
              _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_this);
              useOnPropsChanged(_this);
              _this.selectedConjunction = _this._selectedConjunction(_props);
              _this.conjunctionOptions = _this._getConjunctionOptions(_props);
              _this.dummyFn.isDummyFn = true;
              return _this;
            }
            _inherits$b(GroupContainer, _Component);
            return _createClass$9(GroupContainer, [{
              key: "shouldComponentUpdate",
              value: function shouldComponentUpdate(nextProps, nextState) {
                var prevProps = this.props;
                var prevState = this.state;
                var should = this.pureShouldComponentUpdate(nextProps, nextState);
                if (should) {
                  if (prevState == nextState && prevProps != nextProps) {
                    var draggingId = nextProps.dragging.id || prevProps.dragging.id;
                    var isDraggingMe = draggingId == nextProps.id;
                    var chs = [];
                    for (var k in nextProps) {
                      var changed = nextProps[k] != prevProps[k];
                      if (k == "dragging" && !isDraggingMe) {
                        changed = false; //dragging another item -> ignore
                      }
                      if (changed) {
                        chs.push(k);
                      }
                    }
                    if (!chs.length) should = false;
                  }
                }
                return should;
              }
            }, {
              key: "onPropsChanged",
              value: function onPropsChanged(nextProps) {
                var config = nextProps.config;
                nextProps.id;
                var conjunction = nextProps.conjunction;
                var oldConfig = this.props.config;
                var oldConjunction = this.props.conjunction;
                if (oldConfig != config || oldConjunction != conjunction) {
                  this.selectedConjunction = this._selectedConjunction(nextProps);
                  this.conjunctionOptions = this._getConjunctionOptions(nextProps);
                }
              }
            }, {
              key: "_getConjunctionOptions",
              value: function _getConjunctionOptions(props) {
                var _this2 = this;
                return mapValues$1(props.config.conjunctions, function (item, index) {
                  return {
                    id: "conjunction-".concat(props.id, "-").concat(index),
                    name: "conjunction[".concat(props.id, "]"),
                    key: index,
                    label: item.label,
                    checked: index === _this2._selectedConjunction(props)
                  };
                });
              }
            }, {
              key: "render",
              value: function render() {
                var showErrorMessage = this.props.config.settings.showErrorMessage;
                var isDraggingMe = this.props.dragging.id == this.props.id;
                var currentNesting = this.props.path.size;
                var maxNesting = this.props.config.settings.maxNesting;
                var isInDraggingTempo = !isDraggingMe && this.props.isDraggingTempo;
                var fieldType = this.props.fieldType || null;
                var valueError = this.props.valueError;
                var oneError = _toConsumableArray((valueError === null || valueError === void 0 ? void 0 : valueError.toArray()) || []).filter(function (e) {
                  return !!e;
                }).shift() || null;
                var hasError = oneError != null && showErrorMessage;

                // Don't allow nesting further than the maximum configured depth and don't
                // allow removal of the root group.
                var allowFurtherNesting = typeof maxNesting === "undefined" || currentNesting < maxNesting;
                var isRoot = currentNesting == 1;
                return /*#__PURE__*/React.createElement("div", {
                  className: classNames("group-or-rule-container", "group-container", hasError ? "group-with-error" : null),
                  "data-id": this.props.id
                }, [isDraggingMe ? /*#__PURE__*/React.createElement(Group, {
                  key: "dragging",
                  id: this.props.id,
                  groupId: this.props.groupId,
                  isDraggingMe: true,
                  isDraggingTempo: true,
                  dragging: this.props.dragging,
                  isRoot: isRoot,
                  allowFurtherNesting: allowFurtherNesting,
                  conjunctionOptions: this.conjunctionOptions,
                  not: this.props.not,
                  selectedConjunction: this.selectedConjunction,
                  setConjunction: this.dummyFn,
                  setNot: this.dummyFn,
                  setLock: this.dummyFn,
                  removeSelf: this.dummyFn,
                  addGroup: this.dummyFn,
                  addCaseGroup: this.dummyFn,
                  addDefaultCaseGroup: this.dummyFn,
                  addRule: this.dummyFn,
                  setField: this.dummyFn,
                  setFuncValue: this.dummyFn,
                  setOperator: this.dummyFn,
                  setValue: this.dummyFn,
                  setValueSrc: this.dummyFn,
                  value: this.props.value || null,
                  valueError: this.props.valueError || null,
                  valueSrc: this.props.valueSrc || null,
                  config: this.props.config,
                  children1: this.props.children1,
                  actions: this.props.actions,
                  reordableNodesCnt: this.props.reordableNodesCnt,
                  totalRulesCnt: this.props.totalRulesCnt,
                  selectedField: this.props.field || null,
                  selectedFieldSrc: this.props.fieldSrc || "field",
                  selectedFieldType: fieldType,
                  parentField: this.props.parentField || null,
                  selectedOperator: this.props.operator || null,
                  isLocked: this.props.isLocked,
                  isTrueLocked: this.props.isTrueLocked,
                  parentReordableNodesCnt: this.props.parentReordableNodesCnt
                }) : null, /*#__PURE__*/React.createElement(Group, {
                  key: this.props.id,
                  id: this.props.id,
                  groupId: this.props.groupId,
                  isDraggingMe: isDraggingMe,
                  isDraggingTempo: isInDraggingTempo,
                  onDragStart: this.props.onDragStart,
                  isRoot: isRoot,
                  allowFurtherNesting: allowFurtherNesting,
                  conjunctionOptions: this.conjunctionOptions,
                  not: this.props.not,
                  selectedConjunction: this.selectedConjunction,
                  setConjunction: isInDraggingTempo ? this.dummyFn : this.setConjunction,
                  setNot: isInDraggingTempo ? this.dummyFn : this.setNot,
                  setLock: isInDraggingTempo ? this.dummyFn : this.setLock,
                  removeSelf: isInDraggingTempo ? this.dummyFn : this.removeSelf,
                  addGroup: isInDraggingTempo ? this.dummyFn : this.addGroup,
                  addCaseGroup: isInDraggingTempo ? this.dummyFn : this.addCaseGroup,
                  addDefaultCaseGroup: isInDraggingTempo ? this.dummyFn : this.addDefaultCaseGroup,
                  addRule: isInDraggingTempo ? this.dummyFn : this.addRule,
                  setField: isInDraggingTempo ? this.dummyFn : this.setField,
                  setFuncValue: isInDraggingTempo ? this.dummyFn : this.setFuncValue,
                  setOperator: isInDraggingTempo ? this.dummyFn : this.setOperator,
                  setValue: isInDraggingTempo ? this.dummyFn : this.setValue,
                  setValueSrc: isInDraggingTempo ? this.dummyFn : this.setValueSrc,
                  value: this.props.value || null,
                  valueError: this.props.valueError || null,
                  valueSrc: this.props.valueSrc || null,
                  config: this.props.config,
                  children1: this.props.children1,
                  actions: this.props.actions,
                  reordableNodesCnt: this.props.reordableNodesCnt,
                  totalRulesCnt: this.props.totalRulesCnt,
                  selectedField: this.props.field || null,
                  selectedFieldSrc: this.props.fieldSrc || "field",
                  selectedFieldType: fieldType,
                  parentField: this.props.parentField || null,
                  selectedOperator: this.props.operator || null,
                  isLocked: this.props.isLocked,
                  isTrueLocked: this.props.isTrueLocked,
                  parentReordableNodesCnt: this.props.parentReordableNodesCnt
                })]);
              }
            }]);
          }(reactExports.Component), _GroupContainer.propTypes = {
            config: PropTypes.object.isRequired,
            actions: PropTypes.object.isRequired,
            //{setConjunction: Function, removeGroup, addGroup, addRule, ...}
            path: PropTypes.any.isRequired,
            //instanceOf(Immutable.List)
            id: PropTypes.string.isRequired,
            groupId: PropTypes.string,
            not: PropTypes.bool,
            conjunction: PropTypes.string,
            children1: PropTypes.any,
            //instanceOf(Immutable.OrderedMap)
            onDragStart: PropTypes.func,
            reordableNodesCnt: PropTypes.number,
            field: PropTypes.any,
            // for RuleGroup
            fieldSrc: PropTypes.string,
            // for RuleGroup
            fieldType: PropTypes.string,
            // for RuleGroup
            parentField: PropTypes.string,
            //from RuleGroup
            value: PropTypes.any,
            // for RuleGroup, CaseGroup
            valueSrc: PropTypes.any,
            valueError: PropTypes.any,
            isLocked: PropTypes.bool,
            isTrueLocked: PropTypes.bool,
            //connected:
            dragging: PropTypes.object,
            //{id, x, y, w, h}
            isDraggingTempo: PropTypes.bool
          }, _GroupContainer;
        };
        const GroupContainer = function GroupContainer(Group, itemType) {
          var ConnectedGroupContainer = connect$1(function (state) {
            return {
              dragging: state.dragging
            };
          }, null, null, {
            context: context
          })(createGroupContainer(Group, itemType));
          ConnectedGroupContainer.displayName = "ConnectedGroupContainer";
          return ConnectedGroupContainer;
        };
        function _callSuper$c(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$c() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$c() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$c = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var groupActionsPositionList$1 = {
          topLeft: "group--actions--tl",
          topCenter: "group--actions--tc",
          topRight: "group--actions--tr",
          bottomLeft: "group--actions--bl",
          bottomCenter: "group--actions--bc",
          bottomRight: "group--actions--br"
        };
        var defaultPosition$2 = "topRight";
        var GroupActions = /*#__PURE__*/function (_PureComponent) {
          function GroupActions() {
            _classCallCheck$b(this, GroupActions);
            return _callSuper$c(this, GroupActions, arguments);
          }
          _inherits$b(GroupActions, _PureComponent);
          return _createClass$9(GroupActions, [{
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                addRule = _this$props.addRule,
                addGroup = _this$props.addGroup,
                removeSelf = _this$props.removeSelf,
                setLock = _this$props.setLock,
                isLocked = _this$props.isLocked,
                isTrueLocked = _this$props.isTrueLocked,
                id = _this$props.id,
                canAddGroup = _this$props.canAddGroup,
                canAddRule = _this$props.canAddRule,
                canDeleteGroup = _this$props.canDeleteGroup;
              var _config$settings = config.settings,
                immutableGroupsMode = _config$settings.immutableGroupsMode,
                addRuleLabel = _config$settings.addRuleLabel,
                addGroupLabel = _config$settings.addGroupLabel,
                delGroupLabel = _config$settings.delGroupLabel,
                groupActionsPosition = _config$settings.groupActionsPosition,
                renderButton = _config$settings.renderButton,
                renderIcon = _config$settings.renderIcon,
                renderSwitch = _config$settings.renderSwitch,
                renderButtonGroup = _config$settings.renderButtonGroup,
                lockLabel = _config$settings.lockLabel,
                lockedLabel = _config$settings.lockedLabel,
                showLock = _config$settings.showLock,
                canDeleteLocked = _config$settings.canDeleteLocked;
              var Icon = function Icon(pr) {
                return renderIcon(pr, config.ctx);
              };
              var Btn = function Btn(pr) {
                return renderButton(pr, config.ctx);
              };
              var Switch = function Switch(pr) {
                return renderSwitch(pr, config.ctx);
              };
              var BtnGrp = function BtnGrp(pr) {
                return renderButtonGroup(pr, config.ctx);
              };
              var position = groupActionsPositionList$1[groupActionsPosition || defaultPosition$2];
              var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /*#__PURE__*/React.createElement(Switch, {
                type: "lock",
                id: id,
                value: isLocked,
                setValue: setLock,
                label: lockLabel,
                checkedLabel: lockedLabel,
                config: config
              });
              var addRuleBtn = !immutableGroupsMode && canAddRule && !isLocked && /*#__PURE__*/React.createElement(Btn, {
                type: "addRule",
                onClick: addRule,
                label: addRuleLabel,
                readonly: isLocked,
                config: config,
                renderIcon: Icon
              });
              var addGroupBtn = !immutableGroupsMode && canAddGroup && !isLocked && /*#__PURE__*/React.createElement(Btn, {
                type: "addGroup",
                onClick: addGroup,
                label: addGroupLabel,
                readonly: isLocked,
                config: config,
                renderIcon: Icon
              });
              var delGroupBtn = !immutableGroupsMode && canDeleteGroup && (!isLocked || isLocked && canDeleteLocked) && /*#__PURE__*/React.createElement(Btn, {
                type: "delGroup",
                onClick: removeSelf,
                label: delGroupLabel,
                config: config,
                renderIcon: Icon
              });
              return /*#__PURE__*/React.createElement("div", {
                className: "group--actions ".concat(position)
              }, /*#__PURE__*/React.createElement(BtnGrp, {
                config: config
              }, setLockSwitch, addRuleBtn, addGroupBtn, delGroupBtn));
            }
          }]);
        }(reactExports.PureComponent);
        function ownKeys$c(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$c(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$c(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _callSuper$b(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$b() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$b() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$b = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var isEmptyGroupChildren = Utils$1.RuleUtils.isEmptyGroupChildren;
        var defaultPosition$1 = "topRight";
        var BasicGroup = /*#__PURE__*/function (_Component) {
          function BasicGroup(props) {
            var _this;
            _classCallCheck$b(this, BasicGroup);
            _this = _callSuper$b(this, BasicGroup, [props]);
            _this.childrenClassName = function () {
              return "";
            };
            _this.renderBeforeActions = function () {
              var BeforeActions = _this.BeforeActions;
              if (BeforeActions == undefined) return null;
              return /*#__PURE__*/React.createElement(BeforeActions, _extends$h({
                key: "group-actions-before"
              }, _this.props));
            };
            _this.renderAfterActions = function () {
              var AfterActions = _this.AfterActions;
              if (AfterActions == undefined) return null;
              return /*#__PURE__*/React.createElement(AfterActions, _extends$h({
                key: "group-actions-after"
              }, _this.props));
            };
            useOnPropsChanged(_this);
            _this.onPropsChanged(props);
            _this.removeSelf = _this.removeSelf.bind(_this);
            _this.setLock = _this.setLock.bind(_this);
            _this.renderItem = _this.renderItem.bind(_this);
            return _this;
          }
          _inherits$b(BasicGroup, _Component);
          return _createClass$9(BasicGroup, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var _this2 = this;
              var prevProps = this.props;
              var configChanged = !this.Icon || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.config) !== (nextProps === null || nextProps === void 0 ? void 0 : nextProps.config);
              if (configChanged) {
                var config = nextProps.config;
                var _config$settings = config.settings,
                  renderIcon = _config$settings.renderIcon,
                  renderConjs = _config$settings.renderConjs,
                  renderBeforeActions = _config$settings.renderBeforeActions,
                  renderAfterActions = _config$settings.renderAfterActions;
                this.Icon = getRenderFromConfig(config, renderIcon);
                this.Conjs = getRenderFromConfig(config, renderConjs);
                this.BeforeActions = getRenderFromConfig(config, renderBeforeActions);
                this.AfterActions = getRenderFromConfig(config, renderAfterActions);
              }
              this.doRemove = function () {
                _this2.props.removeSelf();
              };
            }
          }, {
            key: "isGroupTopPosition",
            value: function isGroupTopPosition() {
              return startsWith$1(this.props.config.settings.groupActionsPosition || defaultPosition$1, "top");
            }
          }, {
            key: "setLock",
            value: function setLock(lock) {
              this.props.setLock(lock);
            }
          }, {
            key: "removeSelf",
            value: function removeSelf() {
              var _this$props = this.props,
                confirmFn = _this$props.confirmFn,
                config = _this$props.config;
              var _config$settings2 = config.settings,
                renderConfirm = _config$settings2.renderConfirm,
                confirmOptions = _config$settings2.removeGroupConfirmOptions;
              if (confirmOptions && !this.isEmptyCurrentGroup()) {
                renderConfirm.call(config.ctx, _objectSpread$c(_objectSpread$c({}, confirmOptions), {}, {
                  onOk: this.doRemove,
                  onCancel: null,
                  confirmFn: confirmFn
                }), config.ctx);
              } else {
                this.doRemove();
              }
            }
          }, {
            key: "isEmptyCurrentGroup",
            value: function isEmptyCurrentGroup() {
              var _this$props2 = this.props,
                children1 = _this$props2.children1,
                config = _this$props2.config;
              return isEmptyGroupChildren(children1, config);
            }
          }, {
            key: "showNot",
            value: function showNot() {
              var config = this.props.config;
              return config.settings.showNot;
            }

            // show conjs for 2+ children?
          }, {
            key: "showConjs",
            value: function showConjs() {
              var _this$props3 = this.props,
                conjunctionOptions = _this$props3.conjunctionOptions;
              _this$props3.children1;
              _this$props3.config;
              var conjunctionCount = Object.keys(conjunctionOptions).length;
              return conjunctionCount > 1 || this.showNot();
            }
          }, {
            key: "isNoChildren",
            value: function isNoChildren() {
              var children1 = this.props.children1;
              return children1 ? children1.size == 0 : true;
            }
          }, {
            key: "isOneChild",
            value: function isOneChild() {
              var children1 = this.props.children1;
              return children1 ? children1.size < 2 : true;
            }
          }, {
            key: "renderChildrenWrapper",
            value: function renderChildrenWrapper() {
              var children1 = this.props.children1;
              return children1 && /*#__PURE__*/React.createElement("div", {
                key: "group-children",
                className: classNames("group--children", !this.showConjs() ? "hide--conjs" : "", this.isOneChild() ? "hide--line" : "", this.isOneChild() ? "one--child" : "", this.childrenClassName())
              }, this.renderChildren());
            }
          }, {
            key: "renderHeaderWrapper",
            value: function renderHeaderWrapper() {
              var isGroupTopPosition = this.isGroupTopPosition();
              return /*#__PURE__*/React.createElement("div", {
                key: "group-header",
                className: classNames("group--header", this.isOneChild() ? "one--child" : "", !this.showConjs() ? "hide--conjs" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "")
              }, this.renderHeader(), isGroupTopPosition && this.renderBeforeActions(), isGroupTopPosition && this.renderActions(), isGroupTopPosition && this.renderAfterActions());
            }
          }, {
            key: "renderFooterWrapper",
            value: function renderFooterWrapper() {
              var isGroupTopPosition = this.isGroupTopPosition();
              return !isGroupTopPosition && /*#__PURE__*/React.createElement("div", {
                key: "group-footer",
                className: "group--footer"
              }, this.renderBeforeActions(), this.renderActions(), this.renderAfterActions());
            }
          }, {
            key: "renderActions",
            value: function renderActions() {
              var _this$props4 = this.props,
                config = _this$props4.config,
                addRule = _this$props4.addRule,
                addGroup = _this$props4.addGroup,
                isLocked = _this$props4.isLocked,
                isTrueLocked = _this$props4.isTrueLocked,
                id = _this$props4.id;
              return /*#__PURE__*/React.createElement(GroupActions, {
                key: "group-actions",
                config: config,
                addRule: addRule,
                addGroup: addGroup,
                canAddGroup: this.canAddGroup(),
                canAddRule: this.canAddRule(),
                canDeleteGroup: this.canDeleteGroup(),
                removeSelf: this.removeSelf,
                setLock: this.setLock,
                isLocked: isLocked,
                isTrueLocked: isTrueLocked,
                id: id
              });
            }
          }, {
            key: "canAddGroup",
            value: function canAddGroup() {
              return this.props.allowFurtherNesting;
            }
          }, {
            key: "canAddRule",
            value: function canAddRule() {
              var maxNumberOfRules = this.props.config.settings.maxNumberOfRules;
              var totalRulesCnt = this.props.totalRulesCnt;
              if (maxNumberOfRules) {
                return totalRulesCnt < maxNumberOfRules;
              }
              return true;
            }
          }, {
            key: "canDeleteGroup",
            value: function canDeleteGroup() {
              return !this.props.isRoot;
            }
          }, {
            key: "renderChildren",
            value: function renderChildren() {
              var children1 = this.props.children1;
              return children1 ? children1.valueSeq().toArray().map(this.renderItem) : null;
            }
          }, {
            key: "renderItem",
            value: function renderItem(item) {
              if (!item) {
                return undefined;
              }
              var props = this.props;
              var config = props.config,
                actions = props.actions,
                onDragStart = props.onDragStart,
                isLocked = props.isLocked;
              var isRuleGroup = item.get("type") == "group" && item.getIn(["properties", "field"]) != null;
              var type = isRuleGroup ? "rule_group" : item.get("type");
              return /*#__PURE__*/React.createElement(Item, _extends$h({}, this.extraPropsForItem(item), {
                key: item.get("id"),
                id: item.get("id"),
                groupId: props.id
                //path={props.path.push(item.get('id'))}
                ,

                path: item.get("path"),
                type: type,
                properties: item.get("properties"),
                config: config,
                actions: actions,
                children1: item.get("children1"),
                reordableNodesCnt: this.reordableNodesCntForItem(item),
                totalRulesCnt: this.totalRulesCntForItem(item),
                parentReordableNodesCnt: this.reordableNodesCnt(),
                onDragStart: onDragStart,
                isDraggingTempo: this.props.isDraggingTempo,
                isParentLocked: isLocked
              }));
            }
          }, {
            key: "extraPropsForItem",
            value: function extraPropsForItem(_item) {
              return {};
            }
          }, {
            key: "reordableNodesCnt",
            value: function reordableNodesCnt() {
              if (this.props.isLocked) return 0;
              return this.props.reordableNodesCnt;
            }
          }, {
            key: "totalRulesCntForItem",
            value: function totalRulesCntForItem(_item) {
              return this.props.totalRulesCnt;
            }
          }, {
            key: "reordableNodesCntForItem",
            value: function reordableNodesCntForItem(_item) {
              if (this.props.isLocked) return 0;
              return this.reordableNodesCnt();
            }
          }, {
            key: "showDragIcon",
            value: function showDragIcon() {
              var _this$props5 = this.props,
                config = _this$props5.config,
                isRoot = _this$props5.isRoot,
                isLocked = _this$props5.isLocked;
              var reordableNodesCnt = this.reordableNodesCnt();
              return config.settings.canReorder && !isRoot && reordableNodesCnt > 1 && !isLocked;
            }
          }, {
            key: "renderDrag",
            value: function renderDrag() {
              var handleDraggerMouseDown = this.props.handleDraggerMouseDown;
              var Icon = this.Icon;
              var icon = /*#__PURE__*/React.createElement(Icon, {
                type: "drag"
              });
              return this.showDragIcon() && /*#__PURE__*/React.createElement("div", {
                key: "group-drag-icon",
                onMouseDown: handleDraggerMouseDown,
                className: "qb-drag-handler group--drag-handler"
              }, icon);
            }
          }, {
            key: "conjunctionOptions",
            value: function conjunctionOptions() {
              var conjunctionOptions = this.props.conjunctionOptions;
              return conjunctionOptions;
            }
          }, {
            key: "renderConjs",
            value: function renderConjs() {
              var _this$props6 = this.props,
                config = _this$props6.config,
                children1 = _this$props6.children1,
                id = _this$props6.id,
                selectedConjunction = _this$props6.selectedConjunction,
                setConjunction = _this$props6.setConjunction,
                not = _this$props6.not,
                setNot = _this$props6.setNot,
                isLocked = _this$props6.isLocked;
              var _config$settings3 = config.settings,
                immutableGroupsMode = _config$settings3.immutableGroupsMode;
              _config$settings3.renderConjs;
              _config$settings3.showNot;
              var notLabel = _config$settings3.notLabel;
              var conjunctionOptions = this.conjunctionOptions();
              if (!this.showConjs()) return null;
              if (!children1 || !children1.size) return null;
              var renderProps = {
                disabled: this.isOneChild(),
                readonly: immutableGroupsMode || isLocked,
                selectedConjunction: selectedConjunction,
                setConjunction: immutableGroupsMode ? dummyFn : setConjunction,
                conjunctionOptions: conjunctionOptions,
                config: config,
                not: not || false,
                id: id,
                setNot: immutableGroupsMode ? dummyFn : setNot,
                notLabel: notLabel,
                showNot: this.showNot(),
                isLocked: isLocked
              };
              var Conjs = this.Conjs;
              return /*#__PURE__*/React.createElement(Conjs, _extends$h({
                key: "group-conjs"
              }, renderProps));
            }
          }, {
            key: "renderHeader",
            value: function renderHeader() {
              return /*#__PURE__*/React.createElement("div", {
                key: "group-conjunctions",
                className: "group--conjunctions"
              }, this.renderConjs(), this.renderDrag());
            }
          }, {
            key: "render",
            value: function render() {
              return /*#__PURE__*/React.createElement(React.Fragment, null, this.renderHeaderWrapper(), this.renderChildrenWrapper(), this.renderFooterWrapper());
            }
          }]);
        }(reactExports.Component);
        BasicGroup.propTypes = {
          reordableNodesCnt: PropTypes.number,
          conjunctionOptions: PropTypes.object.isRequired,
          allowFurtherNesting: PropTypes.bool.isRequired,
          isRoot: PropTypes.bool.isRequired,
          not: PropTypes.bool,
          selectedConjunction: PropTypes.string,
          config: PropTypes.object.isRequired,
          id: PropTypes.string.isRequired,
          groupId: PropTypes.string,
          path: PropTypes.any,
          //instanceOf(Immutable.List)
          children1: PropTypes.any,
          //instanceOf(Immutable.OrderedMap)
          isDraggingMe: PropTypes.bool,
          isDraggingTempo: PropTypes.bool,
          isLocked: PropTypes.bool,
          isTrueLocked: PropTypes.bool,
          //actions
          handleDraggerMouseDown: PropTypes.func,
          onDragStart: PropTypes.func,
          addRule: PropTypes.func.isRequired,
          addGroup: PropTypes.func.isRequired,
          removeSelf: PropTypes.func.isRequired,
          setConjunction: PropTypes.func.isRequired,
          setNot: PropTypes.func.isRequired,
          setLock: PropTypes.func.isRequired,
          actions: PropTypes.object.isRequired
        };
        const Group = GroupContainer(Draggable("group")(WithConfirmFn(BasicGroup)), "group");
        function _superPropBase(t, o) {
          for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf$1(t)););
          return t;
        }
        function _get() {
          return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
            var p = _superPropBase(e, t);
            if (p) {
              var n = Object.getOwnPropertyDescriptor(p, t);
              return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
            }
          }, _get.apply(null, arguments);
        }
        function _callSuper$a(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$a() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$a() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$a = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var RuleGroupActions = /*#__PURE__*/function (_PureComponent) {
          function RuleGroupActions() {
            _classCallCheck$b(this, RuleGroupActions);
            return _callSuper$a(this, RuleGroupActions, arguments);
          }
          _inherits$b(RuleGroupActions, _PureComponent);
          return _createClass$9(RuleGroupActions, [{
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                addRule = _this$props.addRule,
                canAddRule = _this$props.canAddRule,
                canDeleteGroup = _this$props.canDeleteGroup,
                removeSelf = _this$props.removeSelf,
                setLock = _this$props.setLock,
                isLocked = _this$props.isLocked,
                isTrueLocked = _this$props.isTrueLocked,
                id = _this$props.id;
              var _config$settings = config.settings,
                immutableGroupsMode = _config$settings.immutableGroupsMode,
                addRuleLabel = _config$settings.addRuleLabel,
                delGroupLabel = _config$settings.delGroupLabel,
                renderButton = _config$settings.renderButton,
                renderIcon = _config$settings.renderIcon,
                renderSwitch = _config$settings.renderSwitch,
                renderButtonGroup = _config$settings.renderButtonGroup,
                lockLabel = _config$settings.lockLabel,
                lockedLabel = _config$settings.lockedLabel,
                showLock = _config$settings.showLock,
                canDeleteLocked = _config$settings.canDeleteLocked;
              var Icon = function Icon(pr) {
                return renderIcon(pr, config.ctx);
              };
              var Btn = function Btn(pr) {
                return renderButton(pr, config.ctx);
              };
              var Switch = function Switch(pr) {
                return renderSwitch(pr, config.ctx);
              };
              var BtnGrp = function BtnGrp(pr) {
                return renderButtonGroup(pr, config.ctx);
              };
              var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /*#__PURE__*/React.createElement(Switch, {
                type: "lock",
                id: id,
                value: isLocked,
                setValue: setLock,
                label: lockLabel,
                checkedLabel: lockedLabel,
                hideLabel: true,
                config: config
              });
              var addRuleBtn = !immutableGroupsMode && canAddRule && !isLocked && /*#__PURE__*/React.createElement(Btn, {
                type: "addRuleGroup",
                onClick: addRule,
                label: addRuleLabel,
                readonly: isLocked,
                config: config,
                renderIcon: Icon
              });
              var delGroupBtn = !immutableGroupsMode && canDeleteGroup && (!isLocked || isLocked && canDeleteLocked) && /*#__PURE__*/React.createElement(Btn, {
                type: "delRuleGroup",
                onClick: removeSelf,
                label: delGroupLabel,
                config: config,
                renderIcon: Icon
              });
              return /*#__PURE__*/React.createElement("div", {
                className: "group--actions"
              }, /*#__PURE__*/React.createElement(BtnGrp, {
                config: config
              }, setLockSwitch, addRuleBtn, delGroupBtn));
            }
          }]);
        }(reactExports.PureComponent);
        function ownKeys$b(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$b(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$b(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _callSuper$9(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$9() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$9() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$9 = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var RuleGroup = /*#__PURE__*/function (_BasicGroup) {
          function RuleGroup(props) {
            var _this;
            _classCallCheck$b(this, RuleGroup);
            _this = _callSuper$9(this, RuleGroup, [props]);
            _this.childrenClassName = function () {
              return "rule_group--children";
            };
            _this.renderHeaderWrapper = function () {
              return null;
            };
            _this.renderFooterWrapper = function () {
              return null;
            };
            _this.renderConjs = function () {
              return null;
            };
            _this.canAddGroup = function () {
              return false;
            };
            _this.canAddRule = function () {
              return true;
            };
            _this.canDeleteGroup = function () {
              return false;
            };
            return _this;
          }
          _inherits$b(RuleGroup, _BasicGroup);
          return _createClass$9(RuleGroup, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              _get(_getPrototypeOf$1(RuleGroup.prototype), "onPropsChanged", this).call(this, nextProps);
            }
          }, {
            key: "reordableNodesCntForItem",
            value: function reordableNodesCntForItem(_item) {
              if (this.props.isLocked) return 0;
              var children1 = this.props.children1;
              return (children1 === null || children1 === void 0 ? void 0 : children1.size) || 0;
            }
          }, {
            key: "renderChildrenWrapper",
            value: function renderChildrenWrapper() {
              return /*#__PURE__*/React.createElement(React.Fragment, null, this.renderDrag(), this.renderField(), this.renderActions(), _get(_getPrototypeOf$1(RuleGroup.prototype), "renderChildrenWrapper", this).call(this));
            }
          }, {
            key: "renderField",
            value: function renderField() {
              var _this$props = this.props,
                config = _this$props.config,
                selectedField = _this$props.selectedField,
                selectedFieldSrc = _this$props.selectedFieldSrc,
                selectedFieldType = _this$props.selectedFieldType,
                setField = _this$props.setField,
                setFuncValue = _this$props.setFuncValue,
                setFieldSrc = _this$props.setFieldSrc,
                parentField = _this$props.parentField,
                id = _this$props.id,
                groupId = _this$props.groupId,
                isLocked = _this$props.isLocked;
              var immutableFieldsMode = config.settings.immutableFieldsMode;
              return /*#__PURE__*/React.createElement(FieldWrapper, {
                key: "field",
                classname: "group--field",
                config: config,
                canSelectFieldSource: false,
                selectedField: selectedField,
                selectedFieldSrc: selectedFieldSrc,
                selectedFieldType: selectedFieldType,
                setField: setField,
                setFuncValue: setFuncValue,
                setFieldSrc: setFieldSrc,
                parentField: parentField,
                readonly: immutableFieldsMode || isLocked,
                id: id,
                groupId: groupId
              });
            }
          }, {
            key: "renderActions",
            value: function renderActions() {
              var _this$props2 = this.props,
                config = _this$props2.config,
                addRule = _this$props2.addRule,
                isLocked = _this$props2.isLocked,
                isTrueLocked = _this$props2.isTrueLocked,
                id = _this$props2.id;
              return /*#__PURE__*/React.createElement(RuleGroupActions, {
                config: config,
                addRule: addRule,
                canAddRule: this.canAddRule(),
                canDeleteGroup: this.canDeleteGroup(),
                removeSelf: this.removeSelf,
                setLock: this.setLock,
                isLocked: isLocked,
                isTrueLocked: isTrueLocked,
                id: id
              });
            }
          }, {
            key: "extraPropsForItem",
            value: function extraPropsForItem(_item) {
              return {
                parentField: this.props.selectedField
              };
            }
          }]);
        }(BasicGroup);
        RuleGroup.propTypes = _objectSpread$b(_objectSpread$b({}, BasicGroup.propTypes), {}, {
          selectedField: PropTypes.any,
          selectedFieldSrc: PropTypes.string,
          parentField: PropTypes.string,
          setField: PropTypes.func,
          setFieldSrc: PropTypes.func
        });
        const RuleGroup$1 = GroupContainer(Draggable("group rule_group")(WithConfirmFn(RuleGroup)), "rule_group");
        function _callSuper$8(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$8() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$8() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$8 = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var RuleGroupExtActions = /*#__PURE__*/function (_PureComponent) {
          function RuleGroupExtActions() {
            _classCallCheck$b(this, RuleGroupExtActions);
            return _callSuper$8(this, RuleGroupExtActions, arguments);
          }
          _inherits$b(RuleGroupExtActions, _PureComponent);
          return _createClass$9(RuleGroupExtActions, [{
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                addRule = _this$props.addRule,
                canAddRule = _this$props.canAddRule,
                canDeleteGroup = _this$props.canDeleteGroup,
                removeSelf = _this$props.removeSelf,
                setLock = _this$props.setLock,
                isLocked = _this$props.isLocked,
                isTrueLocked = _this$props.isTrueLocked,
                id = _this$props.id;
              var _config$settings = config.settings,
                immutableGroupsMode = _config$settings.immutableGroupsMode,
                addSubRuleLabel = _config$settings.addSubRuleLabel,
                delGroupLabel = _config$settings.delGroupLabel,
                renderButton = _config$settings.renderButton,
                renderIcon = _config$settings.renderIcon,
                renderSwitch = _config$settings.renderSwitch,
                renderButtonGroup = _config$settings.renderButtonGroup,
                lockLabel = _config$settings.lockLabel,
                lockedLabel = _config$settings.lockedLabel,
                showLock = _config$settings.showLock,
                canDeleteLocked = _config$settings.canDeleteLocked;
              var Icon = function Icon(pr) {
                return renderIcon(pr, config.ctx);
              };
              var Btn = function Btn(pr) {
                return renderButton(pr, config.ctx);
              };
              var Switch = function Switch(pr) {
                return renderSwitch(pr, config.ctx);
              };
              var BtnGrp = function BtnGrp(pr) {
                return renderButtonGroup(pr, config.ctx);
              };
              var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /*#__PURE__*/React.createElement(Switch, {
                type: "lock",
                id: id,
                value: isLocked,
                setValue: setLock,
                label: lockLabel,
                checkedLabel: lockedLabel,
                config: config
              });
              var addRuleBtn = !immutableGroupsMode && canAddRule && !isLocked && /*#__PURE__*/React.createElement(Btn, {
                type: "addRuleGroupExt",
                onClick: addRule,
                label: addSubRuleLabel,
                readonly: isLocked,
                config: config,
                renderIcon: Icon
              });
              var delGroupBtn = !immutableGroupsMode && canDeleteGroup && (!isLocked || isLocked && canDeleteLocked) && /*#__PURE__*/React.createElement(Btn, {
                type: "delRuleGroup",
                onClick: removeSelf,
                label: delGroupLabel,
                config: config,
                renderIcon: Icon
              });
              return /*#__PURE__*/React.createElement("div", {
                className: "group--actions group--actions--tr"
              }, /*#__PURE__*/React.createElement(BtnGrp, {
                config: config
              }, setLockSwitch, addRuleBtn, delGroupBtn));
            }
          }]);
        }(reactExports.PureComponent);
        function ownKeys$a(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$a(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$a(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _createForOfIteratorHelper(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function _callSuper$7(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$7() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$7() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$7 = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var _Utils$ConfigUtils$1 = Utils$1.ConfigUtils,
          getFieldConfig$1 = _Utils$ConfigUtils$1.getFieldConfig,
          getFieldWidgetConfig = _Utils$ConfigUtils$1.getFieldWidgetConfig;
        var isEmptyRuleGroupExtPropertiesAndChildren = Utils$1.RuleUtils.isEmptyRuleGroupExtPropertiesAndChildren;
        var RuleGroupExt = /*#__PURE__*/function (_BasicGroup) {
          function RuleGroupExt(props) {
            var _this;
            _classCallCheck$b(this, RuleGroupExt);
            _this = _callSuper$7(this, RuleGroupExt, [props]);
            _this.childrenClassName = function () {
              return "rule_group_ext--children";
            };
            _this.renderFooterWrapper = function () {
              return null;
            };
            _this.canAddGroup = function () {
              return false;
            };
            _this.canAddRule = function () {
              return true;
            };
            _this.canDeleteGroup = function () {
              return true;
            };
            return _this;
          }
          _inherits$b(RuleGroupExt, _BasicGroup);
          return _createClass$9(RuleGroupExt, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              _get(_getPrototypeOf$1(RuleGroupExt.prototype), "onPropsChanged", this).call(this, nextProps);
            }
          }, {
            key: "renderHeaderWrapper",
            value: function renderHeaderWrapper() {
              return /*#__PURE__*/React.createElement("div", {
                key: "group-header",
                className: classNames("group--header", this.isOneChild() ? "one--child" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "", this.showDragIcon() ? "with--drag" : "hide--drag", this.showConjs() && (!this.isOneChild() || this.showNot()) ? "with--conjs" : "hide--conjs")
              }, this.renderHeader(), this.renderGroupField(), this.renderActions());
            }
          }, {
            key: "renderHeader",
            value: function renderHeader() {
              return /*#__PURE__*/React.createElement("div", {
                className: "group--conjunctions"
              }, this.renderConjs(), this.renderDrag());
            }
          }, {
            key: "renderGroupField",
            value: function renderGroupField() {
              return /*#__PURE__*/React.createElement("div", {
                className: "group--field--count--rule"
              }, this.renderField(), this.renderOperator(), this.renderWidget(), this.renderError());
            }
          }, {
            key: "renderError",
            value: function renderError() {
              var _this$props = this.props,
                config = _this$props.config,
                valueError = _this$props.valueError;
              var _config$settings = config.settings,
                renderRuleError = _config$settings.renderRuleError,
                showErrorMessage = _config$settings.showErrorMessage;
              var oneError = _toConsumableArray((valueError === null || valueError === void 0 ? void 0 : valueError.toArray()) || []).filter(function (e) {
                return !!e;
              }).shift() || null;
              return showErrorMessage && oneError && /*#__PURE__*/React.createElement("div", {
                className: "rule_group--error"
              }, renderRuleError ? renderRuleError({
                error: oneError
              }, config.ctx) : oneError);
            }
          }, {
            key: "showNot",
            value: function showNot() {
              var _this$props2 = this.props,
                config = _this$props2.config,
                selectedField = _this$props2.selectedField;
              _this$props2.selectedOperator;
              var selectedFieldConfig = getFieldConfig$1(config, selectedField) || {};
              return selectedFieldConfig.showNot != undefined ? selectedFieldConfig.showNot : config.settings.showNot;
            }
          }, {
            key: "conjunctionOptions",
            value: function conjunctionOptions() {
              var _this$props3 = this.props,
                config = _this$props3.config,
                selectedField = _this$props3.selectedField;
              _this$props3.selectedOperator;
              var selectedFieldConfig = getFieldConfig$1(config, selectedField) || {};
              var conjunctionOptions = _get(_getPrototypeOf$1(RuleGroupExt.prototype), "conjunctionOptions", this).call(this);
              if (selectedFieldConfig.conjunctions) {
                var filtered = {};
                var _iterator = _createForOfIteratorHelper(selectedFieldConfig.conjunctions),
                  _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var k = _step.value;
                    var options = conjunctionOptions[k];
                    if (options) {
                      filtered[k] = options;
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                conjunctionOptions = filtered;
              }
              return conjunctionOptions;
            }
          }, {
            key: "renderField",
            value: function renderField() {
              var _this$props4 = this.props,
                config = _this$props4.config,
                selectedField = _this$props4.selectedField,
                selectedFieldSrc = _this$props4.selectedFieldSrc,
                selectedFieldType = _this$props4.selectedFieldType,
                setField = _this$props4.setField,
                setFieldSrc = _this$props4.setFieldSrc,
                setFuncValue = _this$props4.setFuncValue,
                parentField = _this$props4.parentField,
                id = _this$props4.id,
                groupId = _this$props4.groupId,
                isLocked = _this$props4.isLocked;
              var immutableFieldsMode = config.settings.immutableFieldsMode;
              return /*#__PURE__*/React.createElement(FieldWrapper, {
                key: "field",
                classname: "rule--field",
                config: config,
                canSelectFieldSource: false,
                selectedField: selectedField,
                selectedFieldSrc: selectedFieldSrc,
                selectedFieldType: selectedFieldType,
                setField: setField,
                setFuncValue: setFuncValue,
                setFieldSrc: setFieldSrc,
                parentField: parentField,
                readonly: immutableFieldsMode || isLocked,
                id: id,
                groupId: groupId
              });
            }
          }, {
            key: "renderOperator",
            value: function renderOperator() {
              var _this$props5 = this.props,
                config = _this$props5.config,
                selectedField = _this$props5.selectedField,
                selectedFieldSrc = _this$props5.selectedFieldSrc,
                selectedOperator = _this$props5.selectedOperator;
              _this$props5.setField;
              var setOperator = _this$props5.setOperator,
                isLocked = _this$props5.isLocked;
              var immutableFieldsMode = config.settings.immutableFieldsMode;
              var selectedFieldWidgetConfig = getFieldWidgetConfig(config, selectedField, selectedOperator) || {};
              var hideOperator = selectedFieldWidgetConfig.hideOperator;
              var showOperatorLabel = selectedField && hideOperator && selectedFieldWidgetConfig.operatorInlineLabel;
              var showOperator = selectedField && !hideOperator;
              return /*#__PURE__*/React.createElement(OperatorWrapper, {
                key: "operator",
                classname: "group--operator",
                config: config,
                selectedField: selectedField,
                selectedFieldSrc: selectedFieldSrc,
                selectedOperator: selectedOperator,
                setOperator: setOperator,
                showOperator: showOperator,
                showOperatorLabel: showOperatorLabel,
                selectedFieldWidgetConfig: selectedFieldWidgetConfig,
                readonly: immutableFieldsMode || isLocked,
                id: this.props.id,
                groupId: this.props.groupId
              });
            }
          }, {
            key: "isEmptyCurrentGroup",
            value: function isEmptyCurrentGroup() {
              var _this$props6 = this.props,
                children1 = _this$props6.children1,
                config = _this$props6.config;
              var ruleData = this._buildWidgetProps(this.props);
              return isEmptyRuleGroupExtPropertiesAndChildren(ruleData, children1, config);
            }
          }, {
            key: "_buildWidgetProps",
            value: function _buildWidgetProps(_ref) {
              var selectedField = _ref.selectedField,
                selectedFieldSrc = _ref.selectedFieldSrc,
                selectedFieldType = _ref.selectedFieldType,
                selectedOperator = _ref.selectedOperator,
                operatorOptions = _ref.operatorOptions,
                value = _ref.value,
                valueType = _ref.valueType;
              _ref.valueSrc;
              _ref.asyncListValues;
              var valueError = _ref.valueError;
              _ref.fieldError;
              var parentField = _ref.parentField;
              return {
                field: selectedField,
                fieldSrc: selectedFieldSrc,
                fieldType: selectedFieldType,
                operator: selectedOperator,
                operatorOptions: operatorOptions,
                value: value,
                valueType: valueType,
                // new Immutable.List(["number"])
                // todo: aggregation can be not only number?
                valueSrc: ["value"],
                //new Immutable.List(["value"]), // should be fixed in isEmptyRuleGroupExtPropertiesAndChildren
                //asyncListValues,
                valueError: valueError,
                fieldError: null,
                parentField: parentField
              };
            }
          }, {
            key: "renderWidget",
            value: function renderWidget() {
              var _this$props7 = this.props,
                config = _this$props7.config,
                selectedField = _this$props7.selectedField,
                selectedOperator = _this$props7.selectedOperator,
                isLocked = _this$props7.isLocked;
              var immutableValuesMode = config.settings.immutableValuesMode;
              var isFieldAndOpSelected = selectedField && selectedOperator;
              var showWidget = isFieldAndOpSelected;
              if (!showWidget) return null;
              var widget = /*#__PURE__*/React.createElement(Widget, _extends$h({
                key: "values",
                isForRuleGroup: true
              }, this._buildWidgetProps(this.props), {
                config: config,
                setValue: !immutableValuesMode ? this.props.setValue : dummyFn
                // todo: aggregation can be not only number?
                ,

                setValueSrc: dummyFn,
                readonly: immutableValuesMode || isLocked,
                id: this.props.id,
                groupId: this.props.groupId
              }));
              return /*#__PURE__*/React.createElement(Col, {
                key: "widget-for-" + this.props.selectedOperator,
                className: "rule--value"
              }, widget);
            }
          }, {
            key: "renderActions",
            value: function renderActions() {
              var _this$props8 = this.props,
                config = _this$props8.config,
                addRule = _this$props8.addRule,
                isLocked = _this$props8.isLocked,
                isTrueLocked = _this$props8.isTrueLocked,
                id = _this$props8.id;
              return /*#__PURE__*/React.createElement(RuleGroupExtActions, {
                config: config,
                addRule: addRule,
                canAddRule: this.canAddRule(),
                canDeleteGroup: this.canDeleteGroup(),
                removeSelf: this.removeSelf,
                setLock: this.setLock,
                isLocked: isLocked,
                isTrueLocked: isTrueLocked,
                id: id
              });
            }
          }, {
            key: "reordableNodesCntForItem",
            value: function reordableNodesCntForItem(_item) {
              if (this.props.isLocked) return 0;
              var children1 = this.props.children1;
              return (children1 === null || children1 === void 0 ? void 0 : children1.size) || 0;
            }
          }, {
            key: "extraPropsForItem",
            value: function extraPropsForItem(_item) {
              return {
                parentField: this.props.selectedField
              };
            }
          }]);
        }(BasicGroup);
        RuleGroupExt.propTypes = _objectSpread$a(_objectSpread$a({}, BasicGroup.propTypes), {}, {
          selectedField: PropTypes.any,
          selectedFieldSrc: PropTypes.string,
          selectedOperator: PropTypes.string,
          value: PropTypes.any,
          parentField: PropTypes.string,
          setField: PropTypes.func,
          setFieldSrc: PropTypes.func,
          setOperator: PropTypes.func,
          setValue: PropTypes.func,
          valueError: PropTypes.any
        });
        const RuleGroupExt$1 = GroupContainer(Draggable("group rule_group_ext")(WithConfirmFn(RuleGroupExt)), "rule_group");
        function _callSuper$6(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$6() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$6() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$6 = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var groupActionsPositionList = {
          topLeft: "group--actions--tl",
          topCenter: "group--actions--tc",
          topRight: "group--actions--tr",
          bottomLeft: "group--actions--bl",
          bottomCenter: "group--actions--bc",
          bottomRight: "group--actions--br"
        };
        var defaultPosition = "topRight";
        var SwitchGroupActions = /*#__PURE__*/function (_PureComponent) {
          function SwitchGroupActions() {
            _classCallCheck$b(this, SwitchGroupActions);
            return _callSuper$6(this, SwitchGroupActions, arguments);
          }
          _inherits$b(SwitchGroupActions, _PureComponent);
          return _createClass$9(SwitchGroupActions, [{
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                addCaseGroup = _this$props.addCaseGroup,
                addDefaultCaseGroup = _this$props.addDefaultCaseGroup,
                setLock = _this$props.setLock,
                isLocked = _this$props.isLocked,
                isTrueLocked = _this$props.isTrueLocked,
                id = _this$props.id,
                canAddGroup = _this$props.canAddGroup,
                canAddDefault = _this$props.canAddDefault;
              var _config$settings = config.settings,
                immutableGroupsMode = _config$settings.immutableGroupsMode,
                addCaseLabel = _config$settings.addCaseLabel,
                addDefaultCaseLabel = _config$settings.addDefaultCaseLabel,
                groupActionsPosition = _config$settings.groupActionsPosition,
                renderButton = _config$settings.renderButton,
                renderIcon = _config$settings.renderIcon,
                renderSwitch = _config$settings.renderSwitch,
                renderButtonGroup = _config$settings.renderButtonGroup,
                lockLabel = _config$settings.lockLabel,
                lockedLabel = _config$settings.lockedLabel,
                showLock = _config$settings.showLock;
              var Icon = function Icon(pr) {
                return renderIcon(pr, config.ctx);
              };
              var Btn = function Btn(pr) {
                return renderButton(pr, config.ctx);
              };
              var Switch = function Switch(pr) {
                return renderSwitch(pr, config.ctx);
              };
              var BtnGrp = function BtnGrp(pr) {
                return renderButtonGroup(pr, config.ctx);
              };
              var position = groupActionsPositionList[groupActionsPosition || defaultPosition];
              var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /*#__PURE__*/React.createElement(Switch, {
                type: "lock",
                id: id,
                value: isLocked,
                setValue: setLock,
                label: lockLabel,
                checkedLabel: lockedLabel,
                config: config
              });
              var addCaseGroupBtn = !immutableGroupsMode && canAddGroup && !isLocked && /*#__PURE__*/React.createElement(Btn, {
                type: "addCaseGroup",
                onClick: addCaseGroup,
                label: addCaseLabel,
                readonly: isLocked,
                config: config,
                renderIcon: Icon
              });
              var addDefaultCaseGroupBtn = !immutableGroupsMode && canAddDefault && !isLocked && /*#__PURE__*/React.createElement(Btn, {
                type: "addDefaultCaseGroup",
                onClick: addDefaultCaseGroup,
                label: addDefaultCaseLabel,
                readonly: isLocked,
                config: config,
                renderIcon: Icon
              });
              return /*#__PURE__*/React.createElement("div", {
                className: "group--actions ".concat(position)
              }, /*#__PURE__*/React.createElement(BtnGrp, {
                config: config
              }, setLockSwitch, addCaseGroupBtn, addDefaultCaseGroupBtn));
            }
          }]);
        }(reactExports.PureComponent);
        function ownKeys$9(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$9(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$9(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _callSuper$5(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$5() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$5() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$5 = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var _Utils$TreeUtils$1 = Utils$1.TreeUtils,
          getTotalReordableNodesCountInTree$1 = _Utils$TreeUtils$1.getTotalReordableNodesCountInTree,
          getTotalRulesCountInTree$1 = _Utils$TreeUtils$1.getTotalRulesCountInTree;
        var SwitchGroup = /*#__PURE__*/function (_BasicGroup) {
          function SwitchGroup(props) {
            var _this;
            _classCallCheck$b(this, SwitchGroup);
            _this = _callSuper$5(this, SwitchGroup, [props]);
            _this.childrenClassName = function () {
              return "switch_group--children";
            };
            _this.renderFooterWrapper = function () {
              return null;
            };
            _this.hasDefaultCase = function () {
              var _this$props$children;
              return ((_this$props$children = _this.props.children1) === null || _this$props$children === void 0 ? void 0 : _this$props$children.size) && _this.props.children1.filter(function (c) {
                return c.get("children1") == null;
              }).size > 0;
            };
            return _this;
          }
          _inherits$b(SwitchGroup, _BasicGroup);
          return _createClass$9(SwitchGroup, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              _get(_getPrototypeOf$1(SwitchGroup.prototype), "onPropsChanged", this).call(this, nextProps);
            }
          }, {
            key: "canAddGroup",
            value: function canAddGroup() {
              var _this$props$children2;
              var maxNumberOfCases = this.props.config.settings.maxNumberOfCases;
              var totalCasesCnt = ((_this$props$children2 = this.props.children1) === null || _this$props$children2 === void 0 ? void 0 : _this$props$children2.size) || 0;
              if (maxNumberOfCases) {
                return totalCasesCnt < maxNumberOfCases;
              }
              return true;
            }
          }, {
            key: "canAddRule",
            value: function canAddRule() {
              return false;
            }
          }, {
            key: "reordableNodesCnt",
            value: function reordableNodesCnt() {
              var _this$props$children3;
              // result will be passed to each case's `parentReordableNodesCnt` prop
              var totalCasesCnt = ((_this$props$children3 = this.props.children1) === null || _this$props$children3 === void 0 ? void 0 : _this$props$children3.size) || 0;
              var casesToReorder = totalCasesCnt;
              if (this.hasDefaultCase()) {
                casesToReorder--;
              }
              return casesToReorder;
            }
          }, {
            key: "totalRulesCntForItem",
            value: function totalRulesCntForItem(item) {
              return getTotalRulesCountInTree$1(item);
            }
          }, {
            key: "reordableNodesCntForItem",
            value: function reordableNodesCntForItem(item) {
              var _this$props$children4;
              if (this.props.isLocked) return 0;
              var _this$props$config$se = this.props.config.settings,
                canLeaveEmptyCase = _this$props$config$se.canLeaveEmptyCase,
                canRegroupCases = _this$props$config$se.canRegroupCases;
              var totalCasesCnt = ((_this$props$children4 = this.props.children1) === null || _this$props$children4 === void 0 ? void 0 : _this$props$children4.size) || 0;
              var casesToReorder = totalCasesCnt;
              if (this.hasDefaultCase()) {
                casesToReorder--;
              }
              var nodesInCase = getTotalReordableNodesCountInTree$1(item);
              var cnt = nodesInCase;
              if (cnt == 1 && canRegroupCases && canLeaveEmptyCase && casesToReorder > 1) cnt = 111;
              return cnt;
            }
          }, {
            key: "renderHeaderWrapper",
            value: function renderHeaderWrapper() {
              return /*#__PURE__*/React.createElement("div", {
                key: "group-header",
                className: classNames("group--header", this.isOneChild() ? "one--child" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "", this.showDragIcon() ? "with--drag" : "hide--drag"
                //this.showConjs() && (!this.isOneChild() || this.showNot()) ? "with--conjs" : "hide--conjs"
                )
              }, this.renderHeader(), this.renderActions());
            }
          }, {
            key: "renderHeader",
            value: function renderHeader() {
              return /*#__PURE__*/React.createElement("div", {
                className: "group--conjunctions"
              }, this.renderConjs(), this.renderDrag());
            }
          }, {
            key: "renderConjs",
            value: function renderConjs() {
              var config = this.props.config;
              var renderSwitchPrefix = config.settings.renderSwitchPrefix;
              return renderSwitchPrefix || null;
            }
          }, {
            key: "showNot",
            value: function showNot() {
              return false;
            }
          }, {
            key: "renderActions",
            value: function renderActions() {
              var _this$props = this.props,
                config = _this$props.config,
                addCaseGroup = _this$props.addCaseGroup,
                addDefaultCaseGroup = _this$props.addDefaultCaseGroup,
                isLocked = _this$props.isLocked,
                isTrueLocked = _this$props.isTrueLocked,
                id = _this$props.id;
              return /*#__PURE__*/React.createElement(SwitchGroupActions, {
                config: config,
                addCaseGroup: addCaseGroup,
                addDefaultCaseGroup: addDefaultCaseGroup,
                canAddDefault: !this.hasDefaultCase(),
                canAddGroup: this.canAddGroup(),
                setLock: this.setLock,
                isLocked: isLocked,
                isTrueLocked: isTrueLocked,
                id: id
              });
            }
          }]);
        }(BasicGroup);
        SwitchGroup.propTypes = _objectSpread$9({}, BasicGroup.propTypes);
        const SwitchGroup$1 = GroupContainer(Draggable("group switch_group")(WithConfirmFn(SwitchGroup)), "switch_group");
        function ownKeys$8(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$8(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$8(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _callSuper$4(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$4() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$4() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$4 = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var CaseGroup = /*#__PURE__*/function (_BasicGroup) {
          function CaseGroup(props) {
            var _this;
            _classCallCheck$b(this, CaseGroup);
            _this = _callSuper$4(this, CaseGroup, [props]);
            _this.childrenClassName = function () {
              return "case_group--children";
            };
            _this.renderFooterWrapper = function () {
              return null;
            };
            return _this;
          }
          _inherits$b(CaseGroup, _BasicGroup);
          return _createClass$9(CaseGroup, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var configChanged = !this.renderBeforeCaseValue || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.config) !== (nextProps === null || nextProps === void 0 ? void 0 : nextProps.config);
              _get(_getPrototypeOf$1(CaseGroup.prototype), "onPropsChanged", this).call(this, nextProps);
              if (configChanged) {
                var config = nextProps.config;
                var _config$settings = config.settings,
                  renderBeforeCaseValue = _config$settings.renderBeforeCaseValue,
                  renderAfterCaseValue = _config$settings.renderAfterCaseValue,
                  renderRuleError = _config$settings.renderRuleError;
                this.BeforeCaseValue = getRenderFromConfig(config, renderBeforeCaseValue);
                this.AfterCaseValue = getRenderFromConfig(config, renderAfterCaseValue);
                this.RuleError = getRenderFromConfig(config, renderRuleError);
              }
            }
          }, {
            key: "isDefaultCase",
            value: function isDefaultCase() {
              return this.props.children1 == undefined;
            }
          }, {
            key: "reordableNodesCnt",
            value: function reordableNodesCnt() {
              // `parentReordableNodesCnt` is number of cases to reorder
              return this.props.parentReordableNodesCnt;
            }
          }, {
            key: "reordableNodesCntForItem",
            value: function reordableNodesCntForItem(_item) {
              // `reordableNodesCnt` is number of nodes is current case
              if (this.props.isLocked) return 0;
              return this.props.reordableNodesCnt;
            }
          }, {
            key: "totalRulesCntForItem",
            value: function totalRulesCntForItem(_item) {
              // `totalRulesCnt` is number of nodes is current case
              return this.props.totalRulesCnt;
            }
          }, {
            key: "showDragIcon",
            value: function showDragIcon() {
              // default impl of `showDragIcon()` uses `this.reordableNodesCnt()`
              if (this.isDefaultCase()) return false;
              return _get(_getPrototypeOf$1(CaseGroup.prototype), "showDragIcon", this).call(this);
            }
          }, {
            key: "renderHeaderWrapper",
            value: function renderHeaderWrapper() {
              return /*#__PURE__*/React.createElement("div", {
                key: "group-header",
                className: classNames("group--header", this.isOneChild() ? "one--child" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "", this.showDragIcon() ? "with--drag" : "hide--drag", this.showConjs() && (!this.isOneChild() || this.showNot()) ? "with--conjs" : "hide--conjs")
              }, this.renderHeaderLeft(), this.renderHeaderCenter(), this.renderActions());
            }
          }, {
            key: "renderChildrenWrapper",
            value: function renderChildrenWrapper() {
              if (this.isDefaultCase()) return null;
              // body has 2 columns: condition & value
              return /*#__PURE__*/React.createElement("div", {
                className: "case_group--body"
              }, this.renderCondition(), this.renderBeforeValue(), this.renderValue(), this.renderAfterValue());
            }
          }, {
            key: "renderHeaderLeft",
            value: function renderHeaderLeft() {
              if (this.isDefaultCase()) {
                var defaultCaseLabel = this.props.config.settings.defaultCaseLabel;
                return defaultCaseLabel || "";
              }
              // default impl:
              return /*#__PURE__*/React.createElement("div", {
                className: "group--conjunctions"
              }, this.renderConjs(), this.renderDrag(), this.renderError());
            }
          }, {
            key: "renderCondition",
            value: function renderCondition() {
              if (this.isDefaultCase()) return null;
              return _get(_getPrototypeOf$1(CaseGroup.prototype), "renderChildrenWrapper", this).call(this);
            }
          }, {
            key: "renderHeaderCenter",
            value: function renderHeaderCenter() {
              if (this.isDefaultCase()) {
                return /*#__PURE__*/React.createElement("div", null, this.renderValue(), this.renderError());
              }
              return null;
            }
          }, {
            key: "canAddGroup",
            value: function canAddGroup() {
              if (this.isDefaultCase()) return false;
              return _get(_getPrototypeOf$1(CaseGroup.prototype), "canAddGroup", this).call(this);
            }
          }, {
            key: "canAddRule",
            value: function canAddRule() {
              if (this.isDefaultCase()) return false;
              return _get(_getPrototypeOf$1(CaseGroup.prototype), "canAddRule", this).call(this);
            }
          }, {
            key: "renderBeforeValue",
            value: function renderBeforeValue() {
              var BeforeCaseValue = this.BeforeCaseValue;
              if (BeforeCaseValue == undefined) return null;
              return /*#__PURE__*/React.createElement(BeforeCaseValue, _extends$h({
                key: "values-before"
              }, this.props));
            }
          }, {
            key: "renderAfterValue",
            value: function renderAfterValue() {
              var AfterCaseValue = this.AfterCaseValue;
              if (AfterCaseValue == undefined) return null;
              return /*#__PURE__*/React.createElement(AfterCaseValue, _extends$h({
                key: "values-after"
              }, this.props));
            }
          }, {
            key: "renderError",
            value: function renderError() {
              var _this$props = this.props,
                config = _this$props.config,
                valueError = _this$props.valueError;
              var showErrorMessage = config.settings.showErrorMessage;
              var RuleError = this.RuleError;
              var oneError = _toConsumableArray((valueError === null || valueError === void 0 ? void 0 : valueError.toArray()) || []).filter(function (e) {
                return !!e;
              }).shift() || null;
              return showErrorMessage && oneError && /*#__PURE__*/React.createElement("div", {
                className: "rule--error"
              }, RuleError ? /*#__PURE__*/React.createElement(RuleError, {
                error: oneError
              }) : oneError);
            }
          }, {
            key: "renderValue",
            value: function renderValue() {
              var _this$props2 = this.props,
                config = _this$props2.config,
                isLocked = _this$props2.isLocked,
                value = _this$props2.value,
                valueSrc = _this$props2.valueSrc,
                valueError = _this$props2.valueError,
                setValue = _this$props2.setValue,
                setValueSrc = _this$props2.setValueSrc,
                setFuncValue = _this$props2.setFuncValue,
                id = _this$props2.id;
              var immutableValuesMode = config.settings.immutableValuesMode;
              var widget = /*#__PURE__*/React.createElement(Widget, {
                key: "values",
                isCaseValue: true,
                field: "!case_value",
                operator: null,
                value: value,
                valueSrc: valueSrc !== null && valueSrc !== void 0 ? valueSrc : "value",
                valueError: valueError,
                fieldError: null,
                config: config,
                setValue: !immutableValuesMode ? setValue : dummyFn,
                setValueSrc: !immutableValuesMode ? setValueSrc : dummyFn,
                setFuncValue: !immutableValuesMode ? setFuncValue : dummyFn,
                readonly: immutableValuesMode || isLocked,
                id: id,
                groupId: null
              });
              return /*#__PURE__*/React.createElement(Col, {
                className: "case_group--value"
              }, widget);
            }
          }, {
            key: "renderActions",
            value: function renderActions() {
              var _this$props3 = this.props,
                config = _this$props3.config,
                addGroup = _this$props3.addGroup,
                addRule = _this$props3.addRule,
                isLocked = _this$props3.isLocked,
                isTrueLocked = _this$props3.isTrueLocked,
                id = _this$props3.id;
              return /*#__PURE__*/React.createElement(GroupActions, {
                config: config,
                addGroup: addGroup,
                addRule: addRule,
                canAddRule: this.canAddRule(),
                canAddGroup: this.canAddGroup(),
                canDeleteGroup: this.canDeleteGroup(),
                removeSelf: this.removeSelf,
                setLock: this.setLock,
                isLocked: isLocked,
                isTrueLocked: isTrueLocked,
                id: id
              });
            }
          }, {
            key: "isEmptyCurrentGroup",
            value: function isEmptyCurrentGroup() {
              // used to confirm self-deletion
              var value = this.props.value;
              var oneValue = value && value.size ? value.get(0) : null;
              var hasValue = oneValue != null && (Array.isArray(oneValue) ? oneValue.length > 0 : true);
              return _get(_getPrototypeOf$1(CaseGroup.prototype), "isEmptyCurrentGroup", this).call(this) && !hasValue;
            }
          }]);
        }(BasicGroup);
        CaseGroup.propTypes = _objectSpread$8(_objectSpread$8({}, BasicGroup.propTypes), {}, {
          parentReordableNodesCnt: PropTypes.number,
          value: PropTypes.any,
          setValue: PropTypes.func
        });
        const CaseGroup$1 = GroupContainer(Draggable("group case_group")(WithConfirmFn(CaseGroup)), "case_group");
        var _excluded$4 = ["type"];
        function _callSuper$3(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$3() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$3() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$3 = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        function ownKeys$7(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$7(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$7(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        var types$3 = ["rule", "group", "rule_group", "switch_group", "case_group"];
        var getProperties = function getProperties(props) {
          var _props$properties;
          var properties = ((_props$properties = props.properties) === null || _props$properties === void 0 ? void 0 : _props$properties.toObject()) || {};
          var result = _objectSpread$7({}, properties);
          if (props.isParentLocked) {
            result.isLocked = true;
          }
          if (properties.isLocked) {
            result.isTrueLocked = true;
          }
          return result;
        };
        var typeMap = {
          rule: function rule(props) {
            return /*#__PURE__*/React.createElement(Rule$1, _extends$h({}, getProperties(props), {
              id: props.id,
              groupId: props.groupId,
              path: props.path,
              actions: props.actions,
              reordableNodesCnt: props.reordableNodesCnt,
              totalRulesCnt: props.totalRulesCnt,
              config: props.config,
              onDragStart: props.onDragStart,
              isDraggingTempo: props.isDraggingTempo,
              parentField: props.parentField,
              parentReordableNodesCnt: props.parentReordableNodesCnt
            }));
          },
          group: function group(props) {
            return /*#__PURE__*/React.createElement(Group, _extends$h({}, getProperties(props), {
              id: props.id,
              groupId: props.groupId,
              path: props.path,
              actions: props.actions,
              config: props.config,
              reordableNodesCnt: props.reordableNodesCnt,
              totalRulesCnt: props.totalRulesCnt,
              onDragStart: props.onDragStart,
              isDraggingTempo: props.isDraggingTempo,
              children1: props.children1,
              parentField: null,
              parentReordableNodesCnt: props.parentReordableNodesCnt
            }));
          },
          rule_group: function rule_group(props) {
            return /*#__PURE__*/React.createElement(RuleGroup$1, _extends$h({}, getProperties(props), {
              id: props.id,
              groupId: props.groupId,
              path: props.path,
              actions: props.actions,
              config: props.config,
              reordableNodesCnt: props.reordableNodesCnt,
              totalRulesCnt: props.totalRulesCnt,
              onDragStart: props.onDragStart,
              isDraggingTempo: props.isDraggingTempo,
              children1: props.children1,
              parentField: props.parentField,
              parentReordableNodesCnt: props.parentReordableNodesCnt
            }));
          },
          rule_group_ext: function rule_group_ext(props) {
            return /*#__PURE__*/React.createElement(RuleGroupExt$1, _extends$h({}, getProperties(props), {
              id: props.id,
              groupId: props.groupId,
              path: props.path,
              actions: props.actions,
              config: props.config,
              reordableNodesCnt: props.reordableNodesCnt,
              totalRulesCnt: props.totalRulesCnt,
              onDragStart: props.onDragStart,
              isDraggingTempo: props.isDraggingTempo,
              children1: props.children1,
              parentField: props.parentField,
              parentReordableNodesCnt: props.parentReordableNodesCnt
            }));
          },
          switch_group: function switch_group(props) {
            return /*#__PURE__*/React.createElement(SwitchGroup$1, _extends$h({}, getProperties(props), {
              id: props.id,
              groupId: props.groupId,
              path: props.path,
              actions: props.actions,
              config: props.config,
              reordableNodesCnt: props.reordableNodesCnt,
              totalRulesCnt: props.totalRulesCnt,
              onDragStart: props.onDragStart,
              isDraggingTempo: props.isDraggingTempo,
              children1: props.children1,
              parentField: null,
              parentReordableNodesCnt: props.parentReordableNodesCnt
            }));
          },
          case_group: function case_group(props) {
            return /*#__PURE__*/React.createElement(CaseGroup$1, _extends$h({}, getProperties(props), {
              id: props.id,
              groupId: props.groupId,
              path: props.path,
              actions: props.actions,
              config: props.config,
              reordableNodesCnt: props.reordableNodesCnt,
              totalRulesCnt: props.totalRulesCnt,
              onDragStart: props.onDragStart,
              isDraggingTempo: props.isDraggingTempo,
              children1: props.children1,
              parentField: null,
              parentReordableNodesCnt: props.parentReordableNodesCnt
            }));
          }
        };
        var Item = /*#__PURE__*/function (_PureComponent) {
          function Item() {
            _classCallCheck$b(this, Item);
            return _callSuper$3(this, Item, arguments);
          }
          _inherits$b(Item, _PureComponent);
          return _createClass$9(Item, [{
            key: "render",
            value: function render() {
              var _props$properties2;
              var _this$props = this.props,
                type = _this$props.type,
                props = _objectWithoutProperties$2(_this$props, _excluded$4);
              var mode = (_props$properties2 = props.properties) === null || _props$properties2 === void 0 ? void 0 : _props$properties2.get("mode");
              var postfix = mode == "array" ? "_ext" : "";
              var renderItem = props.config.settings.renderItem;
              var Cmp = typeMap[type + postfix];
              if (renderItem) {
                return renderItem(_objectSpread$7(_objectSpread$7({}, props), {}, {
                  type: type,
                  itemComponent: Cmp
                }), props.config.ctx);
              }
              if (!Cmp) return null;
              return Cmp(props);
            }
          }]);
        }(reactExports.PureComponent);
        Item.propTypes = {
          config: PropTypes.object.isRequired,
          id: PropTypes.string.isRequired,
          groupId: PropTypes.string,
          type: PropTypes.oneOf(types$3).isRequired,
          path: PropTypes.any.isRequired,
          //instanceOf(Immutable.List)
          properties: PropTypes.any,
          //instanceOf(Immutable.Map)
          children1: PropTypes.any,
          //instanceOf(Immutable.OrderedMap)
          actions: PropTypes.object.isRequired,
          reordableNodesCnt: PropTypes.number,
          onDragStart: PropTypes.func,
          parentField: PropTypes.string,
          //from RuleGroup
          isDraggingTempo: PropTypes.bool,
          isParentLocked: PropTypes.bool
        };
        function _callSuper$2(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$2() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$2() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var _Utils$TreeUtils = Utils$1.TreeUtils,
          getTotalReordableNodesCountInTree = _Utils$TreeUtils.getTotalReordableNodesCountInTree,
          getTotalRulesCountInTree = _Utils$TreeUtils.getTotalRulesCountInTree;
        var _Utils$DefaultUtils = Utils$1.DefaultUtils,
          createListWithOneElement = _Utils$DefaultUtils.createListWithOneElement,
          emptyProperties = _Utils$DefaultUtils.emptyProperties;
        var Builder = /*#__PURE__*/function (_Component) {
          function Builder(props) {
            var _this;
            _classCallCheck$b(this, Builder);
            _this = _callSuper$2(this, Builder, [props]);
            _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_this);
            _this._updPath(props);
            return _this;
          }
          _inherits$b(Builder, _Component);
          return _createClass$9(Builder, [{
            key: "shouldComponentUpdate",
            value: function shouldComponentUpdate(nextProps, nextState) {
              var should = this.pureShouldComponentUpdate(nextProps, nextState);
              return should;
            }
          }, {
            key: "_updPath",
            value: function _updPath(props) {
              var id = props.tree.get("id");
              this.path = createListWithOneElement(id);
            }
          }, {
            key: "render",
            value: function render() {
              var _this$props = this.props,
                tree = _this$props.tree,
                config = _this$props.config,
                actions = _this$props.actions,
                onDragStart = _this$props.onDragStart;
              var rootType = tree.get("type");
              var isTernary = rootType == "switch_group";
              var reordableNodesCnt = isTernary ? null : getTotalReordableNodesCountInTree(tree);
              var totalRulesCnt = isTernary ? null : getTotalRulesCountInTree(tree);
              var id = tree.get("id");
              return /*#__PURE__*/React.createElement(Item, {
                key: id,
                id: id,
                path: this.path,
                type: rootType,
                properties: tree.get("properties") || emptyProperties(),
                config: config,
                actions: actions,
                children1: tree.get("children1") || emptyProperties(),
                reordableNodesCnt: reordableNodesCnt,
                totalRulesCnt: totalRulesCnt,
                parentReordableNodesCnt: 0,
                onDragStart: onDragStart
              });
            }
          }]);
        }(reactExports.Component);
        Builder.propTypes = {
          tree: PropTypes.any.isRequired,
          //instanceOf(Immutable.Map)
          config: PropTypes.object.isRequired,
          actions: PropTypes.object.isRequired,
          onDragStart: PropTypes.func
        };
        const Builder$1 = SortableContainer(Builder);
        function ownKeys$6(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$6(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _callSuper$1(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct$1() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var clone = Utils$1.clone;
        var _Utils$ConfigUtils = Utils$1.ConfigUtils,
          getFieldConfig = _Utils$ConfigUtils.getFieldConfig,
          getFieldParts = _Utils$ConfigUtils.getFieldParts,
          getFieldPathParts = _Utils$ConfigUtils.getFieldPathParts;
        var _Utils$RuleUtils = Utils$1.RuleUtils,
          getFieldPathLabels = _Utils$RuleUtils.getFieldPathLabels,
          getWidgetForFieldOp = _Utils$RuleUtils.getWidgetForFieldOp;

        //tip: this.props.value - right value, this.props.field - left value
        var ValueField = /*#__PURE__*/function (_Component) {
          function ValueField(props) {
            var _this;
            _classCallCheck$b(this, ValueField);
            _this = _callSuper$1(this, ValueField, [props]);
            useOnPropsChanged(_this);
            _this.onPropsChanged(props);
            return _this;
          }
          _inherits$b(ValueField, _Component);
          return _createClass$9(ValueField, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var keysForItems = ["config", "field", "fieldSrc", "fieldType", "operator", "isFuncArg", "parentField"];
              var keysForMeta = ["config", "field", "fieldSrc", "fieldType", "operator", "value", "placeholder", "isFuncArg", "parentField"];
              var needUpdateItems = !this.items || keysForItems.map(function (k) {
                return nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
                return nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              if (needUpdateItems) {
                this.items = this.getItems(nextProps);
              }
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps);
              }
            }
          }, {
            key: "getItems",
            value: function getItems(_ref) {
              var config = _ref.config,
                field = _ref.field,
                fieldType = _ref.fieldType,
                operator = _ref.operator,
                parentField = _ref.parentField,
                isFuncArg = _ref.isFuncArg,
                fieldDefinition = _ref.fieldDefinition;
              var canCompareFieldWithField = config.settings.canCompareFieldWithField;
              // const fieldSeparator = config.settings.fieldSeparator;
              var parentFieldPath = getFieldParts(parentField, config);
              var parentFieldConfig = parentField ? getFieldConfig(config, parentField) : null;
              var sourceFields = parentField ? parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.subfields : config.fields;
              var filteredFields = this.filterFields(config, sourceFields, field, parentField, parentFieldPath, operator, canCompareFieldWithField, isFuncArg, fieldDefinition, fieldType);
              var items = this.buildOptions(parentFieldPath, config, filteredFields, parentFieldPath);
              return items;
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref2) {
              var _leftFieldConfig$widg;
              var config = _ref2.config,
                field = _ref2.field;
              _ref2.fieldType;
              _ref2.operator;
              var value = _ref2.value,
                customPlaceholder = _ref2.placeholder,
                isFuncArg = _ref2.isFuncArg,
                parentField = _ref2.parentField;
              var _config$settings = config.settings,
                fieldPlaceholder = _config$settings.fieldPlaceholder,
                fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay;
              var selectedKey = value;
              var isFieldSelected = !!value;
              var leftFieldConfig = field ? getFieldConfig(config, field) : {};
              var leftFieldWidgetField = leftFieldConfig === null || leftFieldConfig === void 0 || (_leftFieldConfig$widg = leftFieldConfig.widgets) === null || _leftFieldConfig$widg === void 0 ? void 0 : _leftFieldConfig$widg.field;
              var leftFieldWidgetFieldProps = (leftFieldWidgetField === null || leftFieldWidgetField === void 0 ? void 0 : leftFieldWidgetField.widgetProps) || {};
              var placeholder = isFieldSelected ? null : isFuncArg && customPlaceholder || leftFieldWidgetFieldProps.valuePlaceholder || fieldPlaceholder;
              var currField = isFieldSelected ? getFieldConfig(config, selectedKey) : null;
              var selectedOpts = currField || {};
              var selectedKeys = getFieldPathParts(selectedKey, config);
              var selectedPath = getFieldPathParts(selectedKey, config, true);
              var selectedLabel = this.getFieldLabel(currField, selectedKey, config);
              var partsLabels = getFieldPathLabels(selectedKey, config);
              var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
              if (selectedFullLabel == selectedLabel || parentField) selectedFullLabel = null;
              var selectedAltLabel = selectedOpts.label2 || selectedOpts.tooltip;
              return {
                placeholder: placeholder,
                selectedKey: selectedKey,
                selectedKeys: selectedKeys,
                selectedPath: selectedPath,
                selectedLabel: selectedLabel,
                selectedOpts: selectedOpts,
                selectedAltLabel: selectedAltLabel,
                selectedFullLabel: selectedFullLabel
              };
            }
          }, {
            key: "filterFields",
            value: function filterFields(config, fields, leftFieldFullkey, parentField, parentFieldPath, operator, canCompareFieldWithField, isFuncArg, fieldDefinition, fieldType) {
              fields = clone(fields);
              var fieldSeparator = config.settings.fieldSeparator;
              var leftFieldConfig = getFieldConfig(config, leftFieldFullkey);
              var widget = getWidgetForFieldOp(config, leftFieldFullkey, operator, "value");
              config.widgets[widget];
              var expectedType;
              if (isFuncArg) {
                expectedType = fieldDefinition === null || fieldDefinition === void 0 ? void 0 : fieldDefinition.type;
              } else if (leftFieldConfig) {
                expectedType = leftFieldConfig.type;
              } else {
                // no field at LHS, but can use type from "memory effect"
                expectedType = fieldType;
              }
              function _filter(list, path) {
                for (var rightFieldKey in list) {
                  var subfields = list[rightFieldKey].subfields;
                  var subpath = (path ? path : []).concat(rightFieldKey);
                  var rightFieldFullkey = subpath.join(fieldSeparator);
                  var rightFieldConfig = getFieldConfig(config, rightFieldFullkey);
                  if (!rightFieldConfig) {
                    delete list[rightFieldKey];
                  } else if (rightFieldConfig.type == "!struct" || rightFieldConfig.type == "!group") {
                    if (_filter(subfields, subpath) == 0) delete list[rightFieldKey];
                  } else {
                    // tip: LHS field can be used as arg in RHS function
                    var canUse = (!expectedType || rightFieldConfig.type == expectedType) && (isFuncArg ? true : rightFieldFullkey != leftFieldFullkey);
                    var fn = canCompareFieldWithField || config.settings.canCompareFieldWithField;
                    if (fn) canUse = canUse && fn(leftFieldFullkey, leftFieldConfig, rightFieldFullkey, rightFieldConfig, operator);
                    if (!canUse) delete list[rightFieldKey];
                  }
                }
                return keys$9(list).length;
              }
              _filter(fields, parentFieldPath || []);
              return fields;
            }
          }, {
            key: "buildOptions",
            value: function buildOptions(parentFieldPath, config, fields) {
              var _this2 = this;
              var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
              var optGroup = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
              if (!fields) return null;
              var _config$settings2 = config.settings,
                fieldSeparator = _config$settings2.fieldSeparator,
                fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
              var prefix = path !== null && path !== void 0 && path.length ? path.join(fieldSeparator) + fieldSeparator : "";
              return keys$9(fields).map(function (fieldKey) {
                var fullFieldPath = [].concat(_toConsumableArray(path !== null && path !== void 0 ? path : []), [fieldKey]);
                var field = fields[fieldKey];
                var label = _this2.getFieldLabel(field, fullFieldPath, config);
                var partsLabels = getFieldPathLabels(fullFieldPath, config);
                var fullLabel = partsLabels.join(fieldSeparatorDisplay);
                if (fullLabel == label || parentFieldPath) fullLabel = null;
                var altLabel = field.label2;
                var tooltip = field.tooltip;
                if (field.hideForCompare) return undefined;
                if (field.type == "!struct" || field.type == "!group") {
                  return {
                    key: fieldKey,
                    path: prefix + fieldKey,
                    label: label,
                    fullLabel: fullLabel,
                    altLabel: altLabel,
                    tooltip: tooltip,
                    items: _this2.buildOptions(parentFieldPath, config, field.subfields, fullFieldPath, {
                      label: label,
                      tooltip: tooltip
                    })
                  };
                } else {
                  return {
                    key: fieldKey,
                    path: prefix + fieldKey,
                    label: label,
                    fullLabel: fullLabel,
                    altLabel: altLabel,
                    tooltip: tooltip,
                    grouplabel: optGroup === null || optGroup === void 0 ? void 0 : optGroup.label,
                    group: optGroup
                  };
                }
              }).filter(function (o) {
                return !!o;
              });
            }
          }, {
            key: "getFieldLabel",
            value: function getFieldLabel(fieldOpts, fieldKey, config) {
              if (!fieldKey) return null;
              var maxLabelsLength = config.settings.maxLabelsLength;
              var fieldParts = getFieldParts(fieldKey, config);
              var label = (fieldOpts === null || fieldOpts === void 0 ? void 0 : fieldOpts.label) || last$2(fieldParts);
              label = truncateString(label, maxLabelsLength);
              return label;
            }
          }, {
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                customProps = _this$props.customProps,
                setValue = _this$props.setValue,
                readonly = _this$props.readonly,
                id = _this$props.id,
                groupId = _this$props.groupId;
              var renderField = config.settings.renderField;
              var renderProps = _objectSpread$6({
                isValueField: true,
                config: config,
                customProps: customProps,
                setField: setValue,
                readonly: readonly,
                items: this.items,
                id: id,
                groupId: groupId
              }, this.meta);
              return renderField(renderProps, config.ctx);
            }
          }]);
        }(reactExports.Component);
        ValueField.propTypes = {
          id: PropTypes.string,
          groupId: PropTypes.string,
          setValue: PropTypes.func.isRequired,
          config: PropTypes.object.isRequired,
          field: PropTypes.any,
          fieldSrc: PropTypes.string,
          fieldType: PropTypes.string,
          value: PropTypes.string,
          operator: PropTypes.string,
          customProps: PropTypes.object,
          readonly: PropTypes.bool,
          parentField: PropTypes.string,
          fieldDefinition: PropTypes.object,
          isFuncArg: PropTypes.bool
        };
        const VanillaBoolean = function VanillaBoolean(props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var labelYes = props.labelYes,
            labelNo = props.labelNo,
            readonly = props.readonly;
          props.widgetId;
          var _props$customProps = props.customProps,
            customProps = _props$customProps === void 0 ? {} : _props$customProps;
          var customRadioYesProps = customProps.radioYes || {};
          var customRadioNoProps = customProps.radioNo || {};
          var onRadioChange = function onRadioChange(e) {
            return setValue(e.target.value == "true");
          };

          // return <>
          //     <input key={widgetId}  type="checkbox" id={widgetId} checked={!!value} disabled={readonly} onChange={onCheckboxChange} />
          //     <label style={{display: "inline"}} key={id+"label"}  htmlFor={widgetId}>{value ? labelYes : labelNo}</label>
          // </>;

          return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("input", _extends$h({
            type: "radio",
            value: true,
            checked: !!value,
            disabled: readonly,
            onChange: onRadioChange
          }, customRadioYesProps)), " ", labelYes, /*#__PURE__*/React.createElement("input", _extends$h({
            type: "radio",
            value: false,
            checked: !value,
            disabled: readonly,
            onChange: onRadioChange
          }, customRadioNoProps)), " ", labelNo);
        };
        const VanillaText = function VanillaText(props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var readonly = props.readonly,
            placeholder = props.placeholder,
            maxLength = props.maxLength,
            customProps = props.customProps;
          var onChange = function onChange(e) {
            var val = e.target.value;
            if (val === "") val = undefined; // don't allow empty value
            setValue(val);
          };
          var textValue = value || "";
          return /*#__PURE__*/React.createElement("input", _extends$h({
            type: "text",
            value: textValue,
            placeholder: placeholder,
            disabled: readonly,
            onChange: onChange,
            maxLength: maxLength
          }, customProps));
        };
        const VanillaTextArea = function VanillaTextArea(props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var readonly = props.readonly,
            placeholder = props.placeholder,
            maxLength = props.maxLength;
          props.maxRows;
          var fullWidth = props.fullWidth,
            customProps = props.customProps;
          var onChange = function onChange(e) {
            var val = e.target.value;
            if (val === "") val = undefined; // don't allow empty value
            setValue(val);
          };
          var textValue = value || "";
          return /*#__PURE__*/React.createElement("textarea", _extends$h({
            value: textValue,
            placeholder: placeholder,
            disabled: readonly,
            onChange: onChange,
            maxLength: maxLength,
            style: {
              width: fullWidth ? "100%" : undefined
            }
          }, customProps));
        };
        Utils$1.moment;
        const VanillaDate = function VanillaDate(props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          props.valueFormat;
          var readonly = props.readonly,
            customProps = props.customProps;
          var onChange = function onChange(e) {
            var value = e.target.value;
            if (value == "") value = undefined;
            setValue(value);
          };
          return /*#__PURE__*/React.createElement("input", _extends$h({
            type: "date",
            value: value || "",
            disabled: readonly,
            onChange: onChange
          }, customProps));
        };
        const VanillaTime = function VanillaTime(props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          props.valueFormat;
          props.use12Hours;
          var readonly = props.readonly,
            customProps = props.customProps;
          var onChange = function onChange(e) {
            var value = e.target.value;
            if (value == "") value = undefined;
            setValue(value);
          };
          return /*#__PURE__*/React.createElement("input", _extends$h({
            type: "time",
            value: value || "",
            disabled: readonly,
            onChange: onChange
          }, customProps));
        };
        var moment$3 = Utils$1.moment;
        const VanillaDateTime = function VanillaDateTime(props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var valueFormat = props.valueFormat;
          props.use12Hours;
          var readonly = props.readonly,
            customProps = props.customProps;
          var onChange = function onChange(e) {
            var value = e.target.value;
            if (value == "") value = undefined;else value = moment$3(new Date(value)).format(valueFormat);
            setValue(value);
          };
          var dtValue = value;
          if (!value) dtValue = "";else dtValue = moment$3(value).format("YYYY-MM-DDTHH:mm");
          return /*#__PURE__*/React.createElement("input", _extends$h({
            type: "datetime-local",
            value: dtValue,
            disabled: readonly,
            onChange: onChange
          }, customProps));
        };
        var mapListValues$4 = Utils$1.ListUtils.mapListValues;
        const VanillaMultiSelect = function VanillaMultiSelect(_ref) {
          var listValues = _ref.listValues,
            value = _ref.value,
            setValue = _ref.setValue;
          _ref.allowCustomValues;
          var readonly = _ref.readonly,
            customProps = _ref.customProps;
          var renderOptions = function renderOptions() {
            return mapListValues$4(listValues, function (_ref2) {
              var title = _ref2.title,
                value = _ref2.value;
              return /*#__PURE__*/React.createElement("option", {
                key: value,
                value: value
              }, title);
            });
          };
          var getMultiSelectValues = function getMultiSelectValues(multiselect) {
            var values = [];
            var options = multiselect.options;
            for (var i = 0; i < options.length; i++) {
              var opt = options[i];
              if (opt.selected) {
                values.push(opt.value);
              }
            }
            if (!values.length) values = undefined; //not allow []
            return values;
          };
          var onChange = function onChange(e) {
            return setValue(getMultiSelectValues(e.target));
          };
          return /*#__PURE__*/React.createElement("select", _extends$h({
            multiple: true,
            onChange: onChange,
            value: value,
            disabled: readonly
          }, omit$1(customProps, ["showSearch", "input", "showCheckboxes"])), renderOptions());
        };
        var mapListValues$3 = Utils$1.ListUtils.mapListValues;
        const VanillaSelect = function VanillaSelect(_ref) {
          var listValues = _ref.listValues,
            value = _ref.value,
            setValue = _ref.setValue;
          _ref.allowCustomValues;
          var readonly = _ref.readonly,
            customProps = _ref.customProps;
          var renderOptions = function renderOptions() {
            return mapListValues$3(listValues, function (_ref2) {
              var title = _ref2.title,
                value = _ref2.value;
              return /*#__PURE__*/React.createElement("option", {
                key: value,
                value: value
              }, title);
            });
          };
          var onChange = function onChange(e) {
            return setValue(e.target.value);
          };
          var hasValue = value != null;
          return /*#__PURE__*/React.createElement("select", _extends$h({
            onChange: onChange,
            value: hasValue ? value : "",
            disabled: readonly
          }, omit$1(customProps, ["showSearch", "input"])), !hasValue && /*#__PURE__*/React.createElement("option", {
            disabled: true,
            value: ""
          }), renderOptions());
        };
        const VanillaNumber = function VanillaNumber(props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var readonly = props.readonly,
            min = props.min,
            max = props.max,
            step = props.step,
            placeholder = props.placeholder,
            customProps = props.customProps;
          var onChange = function onChange(e) {
            var val = e.target.value;
            if (val === "" || val === null) val = undefined;else val = Number(val);
            setValue(val);
          };
          var numberValue = value == undefined ? "" : value;
          return /*#__PURE__*/React.createElement("input", _extends$h({
            type: "number",
            value: numberValue,
            placeholder: placeholder,
            disabled: readonly,
            min: min,
            max: max,
            step: step,
            onChange: onChange
          }, customProps));
        };
        const VanillaSlider = function VanillaSlider(props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var readonly = props.readonly,
            min = props.min,
            max = props.max,
            step = props.step,
            placeholder = props.placeholder,
            _props$customProps = props.customProps,
            customProps = _props$customProps === void 0 ? {} : _props$customProps;
          var customInputProps = customProps.input || {};
          var customSliderProps = customProps.slider || customProps;
          var onChange = function onChange(e) {
            var val = e.target.value;
            if (val === "" || val === null) val = undefined;else val = Number(val);
            setValue(val);
          };
          var numberValue = value == undefined ? "" : value;
          return /*#__PURE__*/React.createElement("div", {
            style: {
              display: "inline-flex"
            }
          }, /*#__PURE__*/React.createElement("input", _extends$h({
            key: "number",
            type: "number",
            value: numberValue,
            placeholder: placeholder,
            disabled: readonly,
            min: min,
            max: max,
            step: step,
            onChange: onChange
          }, customInputProps)), /*#__PURE__*/React.createElement("input", _extends$h({
            key: "range",
            type: "range",
            value: numberValue,
            disabled: readonly,
            min: min,
            max: max,
            step: step,
            onChange: onChange
          }, customSliderProps)));
        };
        const VanillaFieldSelect = function VanillaFieldSelect(_ref) {
          var items = _ref.items,
            setField = _ref.setField,
            selectedKey = _ref.selectedKey,
            readonly = _ref.readonly,
            errorText = _ref.errorText;
          var renderOptions = function renderOptions(fields) {
            return fields.map(function (field) {
              var items = field.items,
                path = field.path,
                label = field.label,
                disabled = field.disabled,
                matchesType = field.matchesType;
              if (items) {
                return /*#__PURE__*/React.createElement("optgroup", {
                  disabled: disabled,
                  key: path,
                  label: label
                }, renderOptions(items));
              } else {
                var style = matchesType ? {
                  fontWeight: "bold"
                } : {};
                return /*#__PURE__*/React.createElement("option", {
                  disabled: disabled,
                  key: path,
                  value: path,
                  style: style
                }, label);
              }
            });
          };
          var onChange = function onChange(e) {
            return setField(e.target.value);
          };
          var hasValue = selectedKey != null;
          return /*#__PURE__*/React.createElement("select", {
            onChange: onChange,
            value: hasValue ? selectedKey : "",
            disabled: readonly,
            style: {
              color: errorText ? "red" : null
            }
          }, !hasValue && /*#__PURE__*/React.createElement("option", {
            disabled: true,
            value: ""
          }), renderOptions(items));
        };
        const VanillaConjs = function VanillaConjs(_ref) {
          var id = _ref.id,
            not = _ref.not,
            setNot = _ref.setNot,
            conjunctionOptions = _ref.conjunctionOptions,
            setConjunction = _ref.setConjunction,
            disabled = _ref.disabled,
            readonly = _ref.readonly,
            config = _ref.config,
            showNot = _ref.showNot,
            notLabel = _ref.notLabel;
          var conjsCount = Object.keys(conjunctionOptions).length;
          var lessThenTwo = disabled;
          var forceShowConj = config.settings.forceShowConj;
          var showConj = forceShowConj || conjsCount > 1 && !lessThenTwo;
          var renderOptions = function renderOptions() {
            return Object.keys(conjunctionOptions).map(function (key) {
              var _conjunctionOptions$k = conjunctionOptions[key],
                id = _conjunctionOptions$k.id,
                name = _conjunctionOptions$k.name,
                label = _conjunctionOptions$k.label,
                checked = _conjunctionOptions$k.checked;
              var postfix = setConjunction.isDummyFn ? "__dummy" : "";
              if ((readonly || disabled) && !checked) return null;
              return [/*#__PURE__*/React.createElement("input", {
                key: id + postfix,
                type: "radio",
                id: id + postfix,
                name: name + postfix,
                checked: checked,
                disabled: readonly || disabled,
                value: key,
                onChange: onChange
              }), /*#__PURE__*/React.createElement("label", {
                key: id + postfix + "label",
                htmlFor: id + postfix
              }, label)];
            });
          };
          var renderNot = function renderNot() {
            var postfix = "not";
            return [/*#__PURE__*/React.createElement("input", {
              key: id + postfix,
              type: "checkbox",
              id: id + postfix,
              checked: not,
              disabled: readonly,
              onChange: onNotChange
            }), /*#__PURE__*/React.createElement("label", {
              key: id + postfix + "label",
              htmlFor: id + postfix
            }, notLabel || "NOT")];
          };
          var onChange = function onChange(e) {
            return setConjunction(e.target.value);
          };
          var onNotChange = function onNotChange(e) {
            return setNot(e.target.checked);
          };
          return [showNot && renderNot(), showConj && renderOptions()];
        };
        var typeToLabel = {
          "addRuleGroup": "+",
          "addRuleGroupExt": "+",
          "delGroup": "x",
          "delRuleGroup": "x",
          "delRule": "x"
        };
        const VanillaButton = function VanillaButton(_ref) {
          var type = _ref.type,
            label = _ref.label,
            onClick = _ref.onClick,
            readonly = _ref.readonly;
          var btnLabel = label || typeToLabel[type];
          return /*#__PURE__*/React.createElement("button", {
            onClick: onClick,
            type: "button",
            disabled: readonly
          }, btnLabel);
        };
        const VanillaIcon = function VanillaIcon(_ref) {
          var type = _ref.type;
          var typeToIcon = {};
          var icon = typeToIcon[type] || null;
          if (!icon && type === "drag") {
            icon = /*#__PURE__*/React.createElement(DragIcon$1, null);
          }
          return icon;
        };
        const VanillaButtonGroup = function VanillaButtonGroup(_ref) {
          var children = _ref.children;
          _ref.config;
          return /*#__PURE__*/React.createElement(React.Fragment, null, children);
        };
        const VanillaValueSources = function VanillaValueSources(_ref) {
          _ref.config;
          var valueSources = _ref.valueSources,
            valueSrc = _ref.valueSrc;
          _ref.title;
          var setValueSrc = _ref.setValueSrc,
            readonly = _ref.readonly;
          var renderOptions = function renderOptions(valueSources) {
            return valueSources.map(function (_ref2) {
              var _ref3 = _slicedToArray$1(_ref2, 2),
                srcKey = _ref3[0],
                info = _ref3[1];
              return /*#__PURE__*/React.createElement("option", {
                key: srcKey,
                value: srcKey
              }, info.label);
            });
          };
          var onChange = function onChange(e) {
            return setValueSrc(e.target.value);
          };
          return /*#__PURE__*/React.createElement("select", {
            onChange: onChange,
            value: valueSrc || "",
            disabled: readonly
          }, renderOptions(valueSources));
        };
        const VanillaSwitch = function VanillaSwitch(_ref) {
          var value = _ref.value,
            setValue = _ref.setValue,
            label = _ref.label,
            id = _ref.id;
          _ref.config;
          var type = _ref.type;
          var onChange = function onChange(e) {
            return setValue(e.target.checked);
          };
          var postfix = type;
          return [/*#__PURE__*/React.createElement("input", {
            key: id + postfix,
            type: "checkbox",
            id: id + postfix,
            checked: !!value,
            onChange: onChange
          }), /*#__PURE__*/React.createElement("label", {
            key: id + postfix + "label",
            htmlFor: id + postfix
          }, label)];
        };
        const vanillaConfirm = function vanillaConfirm(_ref) {
          var onOk = _ref.onOk;
          _ref.okText;
          _ref.cancelText;
          var title = _ref.title;
          if (confirm(title)) {
            onOk();
          }
        };
        var VanillaProvider = function VanillaProvider(_ref) {
          _ref.config;
          var children = _ref.children;
          return children;
        };
        const Widgets = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          FuncWidget,
          ValueFieldWidget: ValueField,
          VanillaBooleanWidget: VanillaBoolean,
          VanillaButton,
          VanillaButtonGroup,
          VanillaConjs,
          VanillaDateTimeWidget: VanillaDateTime,
          VanillaDateWidget: VanillaDate,
          VanillaFieldSelect,
          VanillaIcon,
          VanillaMultiSelectWidget: VanillaMultiSelect,
          VanillaNumberWidget: VanillaNumber,
          VanillaProvider,
          VanillaSelectWidget: VanillaSelect,
          VanillaSliderWidget: VanillaSlider,
          VanillaSwitch,
          VanillaTextAreaWidget: VanillaTextArea,
          VanillaTextWidget: VanillaText,
          VanillaTimeWidget: VanillaTime,
          VanillaValueSources,
          vanillaConfirm
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function _callSuper(t, o, e) {
          return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var Proximity = /*#__PURE__*/function (_PureComponent) {
          function Proximity() {
            var _this;
            _classCallCheck$b(this, Proximity);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            _this = _callSuper(this, Proximity, [].concat(args));
            _this.handleChange = function (value) {
              _this.props.setOption("proximity", parseInt(value));
            };
            return _this;
          }
          _inherits$b(Proximity, _PureComponent);
          return _createClass$9(Proximity, [{
            key: "render",
            value: function render() {
              var _this$props = this.props,
                defaults = _this$props.defaults,
                options = _this$props.options,
                config = _this$props.config,
                optionLabel = _this$props.optionLabel,
                optionPlaceholder = _this$props.optionPlaceholder,
                customProps = _this$props.customProps,
                minProximity = _this$props.minProximity,
                maxProximity = _this$props.maxProximity,
                optionTextBefore = _this$props.optionTextBefore,
                readonly = _this$props.readonly;
              var settings = config.settings,
                widgets = config.widgets,
                ctx = config.ctx;
              var defaultProximity = defaults ? defaults.proximity : undefined;
              var showLabels = settings.showLabels;
              var selectedProximity = options.get("proximity", defaultProximity);
              var proxValues = range$1(minProximity, maxProximity + 1).map(function (item) {
                return {
                  title: item,
                  value: item
                };
              });
              var factory = widgets.select.factory;
              var Select = function Select(props) {
                return factory(props, ctx);
              };
              return /*#__PURE__*/React.createElement("div", {
                className: "operator--PROXIMITY"
              }, /*#__PURE__*/React.createElement("div", {
                className: "operator--options"
              }, showLabels && /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, optionLabel), !showLabels && optionTextBefore && /*#__PURE__*/React.createElement("div", {
                className: "operator--options--sep"
              }, /*#__PURE__*/React.createElement("span", null, optionTextBefore)), /*#__PURE__*/React.createElement(Select, _extends$h({
                config: config,
                value: selectedProximity,
                listValues: proxValues,
                setValue: this.handleChange,
                readonly: readonly,
                placeholder: optionPlaceholder
              }, customProps))), /*#__PURE__*/React.createElement("div", {
                className: "operator--widgets"
              }, this.props.children));
            }
          }]);
        }(reactExports.PureComponent);
        Proximity.propTypes = {
          config: PropTypes.object.isRequired,
          setOption: PropTypes.func.isRequired,
          options: PropTypes.any.isRequired,
          //instanceOf(Immutable.Map)
          minProximity: PropTypes.number,
          maxProximity: PropTypes.number,
          optionPlaceholder: PropTypes.string,
          optionTextBefore: PropTypes.string,
          optionLabel: PropTypes.string,
          customProps: PropTypes.object,
          readonly: PropTypes.bool
          //children
        };
        Proximity.defaultProps = {
          customProps: {},
          minProximity: 2,
          maxProximity: 10,
          optionPlaceholder: "Select words between",
          optionLabel: "Words between",
          optionTextBefore: null
        };
        const CustomOperators = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          ProximityOperator: Proximity
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function ownKeys$5(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$5(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }

        //----------------------------  conjunctions

        var conjunctions$1 = _objectSpread$5({}, CoreConfig.conjunctions);

        //----------------------------  operators

        var operators$1 = _objectSpread$5(_objectSpread$5({}, CoreConfig.operators), {}, {
          proximity: _objectSpread$5(_objectSpread$5({}, CoreConfig.operators.proximity), {}, {
            options: _objectSpread$5(_objectSpread$5({}, CoreConfig.operators.proximity.options), {}, {
              factory: function factory(props, _ref) {
                var RCE = _ref.RCE,
                  ProximityOperator = _ref.O.ProximityOperator;
                return RCE(ProximityOperator, props);
              }
            })
          })
        });

        //----------------------------  widgets

        var widgets$2 = {
          text: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.text), {}, {
            factory: function factory(props, _ref2) {
              var RCE = _ref2.RCE,
                VanillaTextWidget = _ref2.W.VanillaTextWidget;
              return RCE(VanillaTextWidget, props);
            }
          }),
          textarea: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.textarea), {}, {
            factory: function factory(props, _ref3) {
              var RCE = _ref3.RCE,
                VanillaTextAreaWidget = _ref3.W.VanillaTextAreaWidget;
              return RCE(VanillaTextAreaWidget, props);
            }
          }),
          number: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.number), {}, {
            factory: function factory(props, _ref4) {
              var RCE = _ref4.RCE,
                VanillaNumberWidget = _ref4.W.VanillaNumberWidget;
              return RCE(VanillaNumberWidget, props);
            }
          }),
          slider: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.slider), {}, {
            factory: function factory(props, _ref5) {
              var RCE = _ref5.RCE,
                VanillaSliderWidget = _ref5.W.VanillaSliderWidget;
              return RCE(VanillaSliderWidget, props);
            }
          }),
          select: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.select), {}, {
            factory: function factory(props, _ref6) {
              var RCE = _ref6.RCE,
                VanillaSelectWidget = _ref6.W.VanillaSelectWidget;
              return RCE(VanillaSelectWidget, props);
            }
          }),
          multiselect: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.multiselect), {}, {
            factory: function factory(props, _ref7) {
              var RCE = _ref7.RCE,
                VanillaMultiSelectWidget = _ref7.W.VanillaMultiSelectWidget;
              return RCE(VanillaMultiSelectWidget, props);
            }
          }),
          date: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.date), {}, {
            factory: function factory(props, _ref8) {
              var RCE = _ref8.RCE,
                VanillaDateWidget = _ref8.W.VanillaDateWidget;
              return RCE(VanillaDateWidget, props);
            }
          }),
          time: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.time), {}, {
            factory: function factory(props, _ref9) {
              var RCE = _ref9.RCE,
                VanillaTimeWidget = _ref9.W.VanillaTimeWidget;
              return RCE(VanillaTimeWidget, props);
            }
          }),
          datetime: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.datetime), {}, {
            factory: function factory(props, _ref10) {
              var RCE = _ref10.RCE,
                VanillaDateTimeWidget = _ref10.W.VanillaDateTimeWidget;
              return RCE(VanillaDateTimeWidget, props);
            }
          }),
          "boolean": _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets["boolean"]), {}, {
            factory: function factory(props, _ref11) {
              var RCE = _ref11.RCE,
                VanillaBooleanWidget = _ref11.W.VanillaBooleanWidget;
              return RCE(VanillaBooleanWidget, props);
            }
          }),
          field: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.field), {}, {
            factory: function factory(props, _ref12) {
              var RCE = _ref12.RCE,
                ValueFieldWidget = _ref12.W.ValueFieldWidget;
              return RCE(ValueFieldWidget, props);
            },
            customProps: {
              showSearch: true
            }
          }),
          func: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.func), {}, {
            factory: function factory(props, _ref13) {
              var RCE = _ref13.RCE,
                FuncWidget = _ref13.W.FuncWidget;
              return RCE(FuncWidget, props);
            },
            customProps: {
              //showSearch: true
            }
          }),
          /**
           * @deprecated
           */
          case_value: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.case_value), {}, {
            // simple text value
            factory: function factory(props, _ref14) {
              var RCE = _ref14.RCE,
                VanillaTextWidget = _ref14.W.VanillaTextWidget;
              return RCE(VanillaTextWidget, props);
            }
          })
        };

        //----------------------------  types

        var types$2 = _objectSpread$5(_objectSpread$5({}, CoreConfig.types), {}, {
          select: _objectSpread$5(_objectSpread$5({}, CoreConfig.types.select), {}, {
            widgets: _objectSpread$5(_objectSpread$5({}, CoreConfig.types.select.widgets), {}, {
              select: _objectSpread$5(_objectSpread$5({}, CoreConfig.types.select.widgets.select), {}, {
                widgetProps: {
                  customProps: {
                    showSearch: true
                  }
                }
              })
            })
          })
        });

        //----------------------------  settings

        var settings$2 = _objectSpread$5(_objectSpread$5({}, CoreConfig.settings), {}, {
          renderField: function renderField(props, _ref15) {
            var RCE = _ref15.RCE,
              VanillaFieldSelect = _ref15.W.VanillaFieldSelect;
            return RCE(VanillaFieldSelect, props);
          },
          renderOperator: function renderOperator(props, _ref16) {
            var RCE = _ref16.RCE,
              VanillaFieldSelect = _ref16.W.VanillaFieldSelect;
            return RCE(VanillaFieldSelect, props);
          },
          renderFunc: function renderFunc(props, _ref17) {
            var RCE = _ref17.RCE,
              VanillaFieldSelect = _ref17.W.VanillaFieldSelect;
            return RCE(VanillaFieldSelect, props);
          },
          renderConjs: function renderConjs(props, _ref18) {
            var RCE = _ref18.RCE,
              VanillaConjs = _ref18.W.VanillaConjs;
            return RCE(VanillaConjs, props);
          },
          renderSwitch: function renderSwitch(props, _ref19) {
            var RCE = _ref19.RCE,
              VanillaSwitch = _ref19.W.VanillaSwitch;
            return RCE(VanillaSwitch, props);
          },
          renderButton: function renderButton(props, _ref20) {
            var RCE = _ref20.RCE,
              VanillaButton = _ref20.W.VanillaButton;
            return RCE(VanillaButton, props);
          },
          renderIcon: function renderIcon(props, _ref21) {
            var RCE = _ref21.RCE,
              VanillaIcon = _ref21.W.VanillaIcon;
            return RCE(VanillaIcon, props);
          },
          renderButtonGroup: function renderButtonGroup(props, _ref22) {
            var RCE = _ref22.RCE,
              VanillaButtonGroup = _ref22.W.VanillaButtonGroup;
            return RCE(VanillaButtonGroup, props);
          },
          renderProvider: function renderProvider(props, _ref23) {
            var RCE = _ref23.RCE,
              VanillaProvider = _ref23.W.VanillaProvider;
            return RCE(VanillaProvider, props);
          },
          renderValueSources: function renderValueSources(props, _ref24) {
            var RCE = _ref24.RCE,
              VanillaValueSources = _ref24.W.VanillaValueSources;
            return RCE(VanillaValueSources, props);
          },
          renderFieldSources: function renderFieldSources(props, _ref25) {
            var RCE = _ref25.RCE,
              VanillaValueSources = _ref25.W.VanillaValueSources;
            return RCE(VanillaValueSources, props);
          },
          renderConfirm: function renderConfirm(props, _ref26) {
            var vanillaConfirm = _ref26.W.vanillaConfirm;
            return vanillaConfirm(props);
          },
          renderSwitchPrefix: "IF",
          renderBeforeCaseValue: function renderBeforeCaseValue(props, _ref27) {
            var RCE = _ref27.RCE;
            return RCE("span", {
              children: [" then "]
            });
          },
          customFieldSelectProps: {
            showSearch: true
          },
          customOperatorSelectProps: {
            // showSearch: false
          },
          defaultSliderWidth: "200px",
          defaultSelectWidth: "200px",
          defaultSearchWidth: "100px",
          defaultMaxRows: 5,
          renderSize: "small",
          maxLabelsLength: 100,
          showLock: false,
          showNot: true,
          forceShowConj: false,
          groupActionsPosition: "topRight" // oneOf [topLeft, topCenter, topRight, bottomLeft, bottomCenter, bottomRight]
        });

        //----------------------------

        var ctx$1 = _objectSpread$5(_objectSpread$5({}, CoreConfig.ctx), {}, {
          W: _objectSpread$5({}, Widgets),
          O: _objectSpread$5({}, CustomOperators),
          RCE: function RCE(C, P) {
            return /*#__PURE__*/React.createElement(C, P);
          }
        });

        //----------------------------

        var config$2 = {
          conjunctions: conjunctions$1,
          operators: operators$1,
          widgets: widgets$2,
          types: types$2,
          settings: settings$2,
          ctx: ctx$1
        };
        config$2 = Utils$1.ConfigMixins.removeMixins(config$2, ["rangeslider", "treeselect", "treemultiselect"]);
        const BasicConfig = config$2;
        var root$1 = _root;

        /**
         * Gets the timestamp of the number of milliseconds that have elapsed since
         * the Unix epoch (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Date
         * @returns {number} Returns the timestamp.
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => Logs the number of milliseconds it took for the deferred invocation.
         */
        var now$2 = function now$2() {
          return root$1.Date.now();
        };
        var now_1 = now$2;
        var isObject$1 = isObject_1,
          now$1 = now_1,
          toNumber$1 = toNumber_1;

        /** Error message constants. */
        var FUNC_ERROR_TEXT$3 = 'Expected a function';

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeMax$2 = Math.max,
          nativeMin$1 = Math.min;

        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed `func` invocations and a `flush` method to immediately invoke them.
         * Provide `options` to indicate whether `func` should be invoked on the
         * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
         * with the last arguments provided to the debounced function. Subsequent
         * calls to the debounced function return the result of the last `func`
         * invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the debounced function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=false]
         *  Specify invoking on the leading edge of the timeout.
         * @param {number} [options.maxWait]
         *  The maximum time `func` is allowed to be delayed before it's invoked.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // Avoid costly calculations while the window size is in flux.
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // Invoke `sendMail` when clicked, debouncing subsequent calls.
         * jQuery(element).on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
         * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', debounced);
         *
         * // Cancel the trailing debounced invocation.
         * jQuery(window).on('popstate', debounced.cancel);
         */
        function debounce$1(func, wait, options) {
          var lastArgs,
            lastThis,
            maxWait,
            result,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT$3);
          }
          wait = toNumber$1(wait) || 0;
          if (isObject$1(options)) {
            leading = !!options.leading;
            maxing = 'maxWait' in options;
            maxWait = maxing ? nativeMax$2(toNumber$1(options.maxWait) || 0, wait) : maxWait;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs,
              thisArg = lastThis;
            lastArgs = lastThis = undefined;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
          }
          function leadingEdge(time) {
            // Reset any `maxWait` timer.
            lastInvokeTime = time;
            // Start the timer for the trailing edge.
            timerId = setTimeout(timerExpired, wait);
            // Invoke the leading edge.
            return leading ? invokeFunc(time) : result;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime;

            // Either this is the first call, activity has stopped and we're at the
            // trailing edge, the system time has gone backwards and we're treating
            // it as the trailing edge, or we've hit the `maxWait` limit.
            return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now$1();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            // Restart the timer.
            timerId = setTimeout(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined;

            // Only invoke if we have `lastArgs` which means `func` has been
            // debounced at least once.
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined;
            return result;
          }
          function cancel() {
            if (timerId !== undefined) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined;
          }
          function flush() {
            return timerId === undefined ? result : trailingEdge(now$1());
          }
          function debounced() {
            var time = now$1(),
              isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                // Handle invocations in a tight loop.
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var debounce_1 = debounce$1;
        const debounce$2 = /*@__PURE__*/getDefaultExportFromCjs(debounce_1);
        function ownKeys$4(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$4(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        var _Utils$Autocomplete = Utils$1.Autocomplete,
          mergeListValues = _Utils$Autocomplete.mergeListValues,
          listValueToOption = _Utils$Autocomplete.listValueToOption,
          optionToListValue = _Utils$Autocomplete.optionToListValue,
          optionsToListValues = _Utils$Autocomplete.optionsToListValues,
          fixListValuesGroupOrder = _Utils$Autocomplete.fixListValuesGroupOrder;
        var _Utils$ListUtils = Utils$1.ListUtils,
          mapListValues$2 = _Utils$ListUtils.mapListValues,
          listValuesToArray = _Utils$ListUtils.listValuesToArray,
          getListValue = _Utils$ListUtils.getListValue,
          makeCustomListValue = _Utils$ListUtils.makeCustomListValue,
          searchListValue = _Utils$ListUtils.searchListValue;
        _Utils$ListUtils.getItemInListValues;
        function sleep(delay) {
          return new Promise(function (resolve) {
            setTimeout(resolve, delay);
          });
        }
        var useListValuesAutocomplete$1 = function useListValuesAutocomplete(_ref, _ref2) {
          var asyncFetch = _ref.asyncFetch,
            useLoadMore = _ref.useLoadMore,
            useAsyncSearch = _ref.useAsyncSearch,
            forceAsyncSearch = _ref.forceAsyncSearch,
            selectedAsyncListValues = _ref.asyncListValues,
            staticListValues = _ref.listValues,
            allowCustomValues = _ref.allowCustomValues,
            selectedValue = _ref.value,
            setValue = _ref.setValue,
            placeholder = _ref.placeholder,
            config = _ref.config;
          var debounceTimeout = _ref2.debounceTimeout,
            multiple = _ref2.multiple,
            uif = _ref2.uif,
            isFieldAutocomplete = _ref2.isFieldAutocomplete;
          var knownSpecialValues = ["LOAD_MORE", "LOADING_MORE"];
          var loadMoreTitle = "Load more...";
          var loadingMoreTitle = "Loading more...";
          var aPlaceholder = forceAsyncSearch ? "Type to search" : placeholder;

          // state
          var _React$useState = React.useState(false),
            _React$useState2 = _slicedToArray$1(_React$useState, 2),
            open = _React$useState2[0],
            setOpen = _React$useState2[1];
          var _React$useState3 = React.useState(undefined),
            _React$useState4 = _slicedToArray$1(_React$useState3, 2),
            asyncFetchMeta = _React$useState4[0],
            setAsyncFetchMeta = _React$useState4[1];
          var _React$useState5 = React.useState(0),
            _React$useState6 = _slicedToArray$1(_React$useState5, 2),
            loadingCnt = _React$useState6[0],
            setLoadingCnt = _React$useState6[1];
          var _React$useState7 = React.useState(false),
            _React$useState8 = _slicedToArray$1(_React$useState7, 2),
            isLoadingMore = _React$useState8[0],
            setIsLoadingMore = _React$useState8[1];
          var _React$useState9 = React.useState(""),
            _React$useState10 = _slicedToArray$1(_React$useState9, 2),
            inputValue = _React$useState10[0],
            setInputValue = _React$useState10[1];
          var _React$useState11 = React.useState(undefined),
            _React$useState12 = _slicedToArray$1(_React$useState11, 2),
            asyncListValues = _React$useState12[0],
            setAsyncListValues = _React$useState12[1];

          // ref
          var asyncFectchCnt = React.useRef(0);
          var componentIsMounted = React.useRef(0);
          var isSelectedLoadMore = React.useRef(false);

          // compute
          var nSelectedAsyncListValues = React.useMemo(function () {
            return listValuesToArray(selectedAsyncListValues);
          }, [selectedAsyncListValues]);
          var listValues = React.useMemo(function () {
            return asyncFetch ? selectedAsyncListValues ? mergeListValues(asyncListValues, nSelectedAsyncListValues, true) : asyncListValues : listValuesToArray(staticListValues);
          }, [asyncFetch, selectedAsyncListValues, asyncListValues, staticListValues]);
          // todo: useMemo for calcing listValuesToDisplay ?
          var listValuesToDisplay = asyncFetch ? asyncListValues : listValuesToArray(staticListValues);
          if (allowCustomValues && inputValue && !searchListValue(inputValue, asyncListValues)) {
            listValuesToDisplay = mergeListValues(listValuesToDisplay, [makeCustomListValue(inputValue)], true);
          }
          if (asyncFetch && !asyncListValues && selectedAsyncListValues && !inputValue && !open && uif === "antd") {
            // for initial loading, to resolve "a" -> "A"
            listValuesToDisplay = listValues;
          }
          if (asyncFetch && !allowCustomValues && selectedAsyncListValues && uif === "mui") {
            // to prevent warning, when select A, search E -> A is missing in options
            //  MUI: The value provided to Autocomplete is invalid.
            //  None of the options match with `"a"`.
            //  You can use the `isOptionEqualToValue` prop to customize the equality test.
            listValuesToDisplay = mergeListValues(listValuesToDisplay, nSelectedAsyncListValues, true, true);
          }
          //const isDirtyInitialListValues = asyncListValues == undefined && selectedAsyncListValues && selectedAsyncListValues.length && typeof selectedAsyncListValues[0] != "object";
          var isLoading = loadingCnt > 0;
          var canInitialLoad = open && asyncFetch && asyncListValues === undefined && (forceAsyncSearch ? inputValue : true);
          var isInitialLoading = canInitialLoad && isLoading;
          var canLoadMore = !isInitialLoading && listValues && listValues.length > 0 && asyncFetchMeta && asyncFetchMeta.hasMore && (asyncFetchMeta.filter || "") === inputValue;
          var canShowLoadMore = !isLoading && canLoadMore;
          var options = mapListValues$2(listValuesToDisplay, listValueToOption);
          var hasValue = selectedValue != null;
          var selectedListValue = !multiple && hasValue ? getListValue(selectedValue, listValues) : null;
          // const selectedListValues = multiple && hasValue ? selectedValue.map(v => getItemInListValues(listValues, v)) : [];

          // fetch
          var fetchListValues = /*#__PURE__*/function () {
            var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
              var filter,
                isLoadMore,
                offset,
                meta,
                newAsyncFetchCnt,
                res,
                isFetchCancelled,
                _ref4,
                values,
                hasMore,
                newMeta,
                nValues,
                assumeHasMore,
                newValues,
                realNewMeta,
                _args = arguments;
              return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    filter = _args.length > 0 && _args[0] !== undefined ? _args[0] : null;
                    isLoadMore = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;
                    // clear obsolete meta
                    if (!isLoadMore && asyncFetchMeta) {
                      setAsyncFetchMeta(undefined);
                    }
                    offset = isLoadMore && asyncListValues ? asyncListValues.length : 0;
                    meta = isLoadMore && asyncFetchMeta || !useLoadMore && {
                      pageSize: 0
                    };
                    newAsyncFetchCnt = ++asyncFectchCnt.current;
                    _context.next = 8;
                    return asyncFetch.call(config === null || config === void 0 ? void 0 : config.ctx, filter, offset, meta);
                  case 8:
                    res = _context.sent;
                    isFetchCancelled = asyncFectchCnt.current != newAsyncFetchCnt;
                    if (!(isFetchCancelled || !componentIsMounted.current)) {
                      _context.next = 12;
                      break;
                    }
                    return _context.abrupt("return", null);
                  case 12:
                    _ref4 = res !== null && res !== void 0 && res.values ? res : {
                      values: res
                    }, values = _ref4.values, hasMore = _ref4.hasMore, newMeta = _ref4.meta;
                    nValues = listValuesToArray(values);
                    if (isLoadMore) {
                      newValues = mergeListValues(asyncListValues, nValues, false);
                      assumeHasMore = newValues.length > asyncListValues.length;
                    } else {
                      newValues = nValues;
                      if (useLoadMore) {
                        assumeHasMore = newValues.length > 0;
                      }
                    }

                    // save new meta
                    realNewMeta = hasMore != null || newMeta != null || assumeHasMore != null ? _objectSpread$4(_objectSpread$4(_objectSpread$4(_objectSpread$4({}, assumeHasMore != null ? {
                      hasMore: assumeHasMore
                    } : {}), hasMore != null ? {
                      hasMore: hasMore
                    } : {}), newMeta != null ? newMeta : {}), {}, {
                      filter: filter
                    }) : undefined;
                    if (realNewMeta) {
                      setAsyncFetchMeta(realNewMeta);
                    }
                    return _context.abrupt("return", newValues);
                  case 18:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function fetchListValues() {
              return _ref3.apply(this, arguments);
            };
          }();
          var loadListValues = /*#__PURE__*/function () {
            var _ref5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
              var filter,
                isLoadMore,
                list,
                _args2 = arguments;
              return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    filter = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : null;
                    isLoadMore = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : false;
                    setLoadingCnt(function (x) {
                      return x + 1;
                    });
                    setIsLoadingMore(isLoadMore);
                    _context2.next = 6;
                    return fetchListValues(filter, isLoadMore);
                  case 6:
                    list = _context2.sent;
                    if (componentIsMounted.current) {
                      _context2.next = 9;
                      break;
                    }
                    return _context2.abrupt("return");
                  case 9:
                    if (list != null) {
                      // tip: null can be used for reject (eg, if user don't want to filter by input)
                      setAsyncListValues(list);
                    }
                    setLoadingCnt(function (x) {
                      return x - 1;
                    });
                    setIsLoadingMore(false);
                  case 12:
                  case "end":
                    return _context2.stop();
                }
              }, _callee2);
            }));
            return function loadListValues() {
              return _ref5.apply(this, arguments);
            };
          }();
          var loadListValuesDebounced = React.useCallback(debounce$2(loadListValues, debounceTimeout), []);
          React.useEffect(function () {
            componentIsMounted.current++;
            // Initial loading
            if (canInitialLoad && loadingCnt == 0 && asyncFectchCnt.current == 0) {
              _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
                return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return loadListValues();
                    case 2:
                    case "end":
                      return _context3.stop();
                  }
                }, _callee3);
              }))();
            }
            // Unmount
            return function () {
              componentIsMounted.current--;
            };
          }, [canInitialLoad]);

          // Event handlers
          var onOpen = function onOpen() {
            setOpen(true);
          };
          var onClose = /*#__PURE__*/function () {
            var _ref7 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_e) {
              var isLoadMoreClick, resetValue;
              return _regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) switch (_context4.prev = _context4.next) {
                  case 0:
                    isLoadMoreClick = isSelectedLoadMore.current;
                    if (isLoadMoreClick) {
                      isSelectedLoadMore.current = false;
                      if (multiple) {
                        // required for MUI
                        setOpen(false);
                      }
                    } else {
                      setOpen(false);
                    }
                    if (!(uif === "mui" && !isLoadMoreClick)) {
                      _context4.next = 6;
                      break;
                    }
                    // parity with Antd
                    resetValue = "";
                    _context4.next = 6;
                    return onInputChange(null, resetValue, "my-reset");
                  case 6:
                  case "end":
                    return _context4.stop();
                }
              }, _callee4);
            }));
            return function onClose(_x) {
              return _ref7.apply(this, arguments);
            };
          }();
          var onDropdownVisibleChange = function onDropdownVisibleChange(open) {
            if (open) {
              onOpen();
            } else {
              onClose();
            }
          };
          var isSpecialValue = function isSpecialValue(option) {
            var specialValue = (option === null || option === void 0 ? void 0 : option.specialValue) || (option === null || option === void 0 ? void 0 : option.value);
            return knownSpecialValues.includes(specialValue);
          };
          var onChange = /*#__PURE__*/function () {
            var _ref8 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(e, val, option) {
              var _option2;
              var isClearingAll, isClearingInput, isClearingSingle, _option$value, _option, specialValue, shouldIgnore, isAddingCustomOptionFromSearch, _optionsToListValues, _optionsToListValues2, newSelectedValues, newSelectedListValues, _optionToListValue, _optionToListValue2, v, lvs;
              return _regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) switch (_context5.prev = _context5.next) {
                  case 0:
                    // todo: don't rely on 3rd param. check MUI 6
                    isClearingAll = multiple && uif === "mui" && option === "clear"; // if user removes all chars in search, don't clear selected value
                    isClearingInput = !multiple && uif === "mui" && option === "clear" && (e === null || e === void 0 ? void 0 : e.type) === "change";
                    isClearingSingle = !multiple && uif === "mui" && option === "clear" && (e === null || e === void 0 ? void 0 : e.type) !== "change";
                    if (uif === "mui") {
                      option = val;
                      if (multiple) {
                        val = option.map(function (o) {
                          var _o$value;
                          return (_o$value = o === null || o === void 0 ? void 0 : o.value) !== null && _o$value !== void 0 ? _o$value : o;
                        });
                      } else {
                        val = (_option$value = (_option = option) === null || _option === void 0 ? void 0 : _option.value) !== null && _option$value !== void 0 ? _option$value : option;
                      }
                    }
                    specialValue = multiple && Array.isArray(option) && option.map(function (opt) {
                      return opt === null || opt === void 0 ? void 0 : opt.specialValue;
                    }).find(function (v) {
                      return !!v;
                    }) || ((_option2 = option) === null || _option2 === void 0 ? void 0 : _option2.specialValue);
                    if (multiple && val && !Array.isArray(val)) {
                      val = [].concat(_toConsumableArray(selectedValue || []), [val]);
                      option = null;
                    }
                    // if there are tags AND input and select is opened, clear input first
                    shouldIgnore = isClearingAll && val.length === 0 && inputValue && open || isClearingInput;
                    if (!shouldIgnore) {
                      _context5.next = 9;
                      break;
                    }
                    return _context5.abrupt("return");
                  case 9:
                    isAddingCustomOptionFromSearch = multiple && val.length && val.length > (selectedValue || []).length && val[val.length - 1] == inputValue && !getListValue(inputValue, asyncListValues);
                    if (!(specialValue == "LOAD_MORE")) {
                      _context5.next = 17;
                      break;
                    }
                    setInputValue(inputValue);
                    isSelectedLoadMore.current = true;
                    _context5.next = 15;
                    return loadListValues(inputValue, true);
                  case 15:
                    _context5.next = 37;
                    break;
                  case 17:
                    if (!(specialValue == "LOADING_MORE")) {
                      _context5.next = 21;
                      break;
                    }
                    isSelectedLoadMore.current = true;
                    _context5.next = 37;
                    break;
                  case 21:
                    if (!multiple) {
                      _context5.next = 31;
                      break;
                    }
                    _optionsToListValues = optionsToListValues(val, listValues, allowCustomValues), _optionsToListValues2 = _slicedToArray$1(_optionsToListValues, 2), newSelectedValues = _optionsToListValues2[0], newSelectedListValues = _optionsToListValues2[1];
                    setValue(newSelectedValues, asyncFetch ? newSelectedListValues : undefined);
                    if (!isAddingCustomOptionFromSearch) {
                      _context5.next = 29;
                      break;
                    }
                    _context5.next = 27;
                    return sleep(0);
                  case 27:
                    _context5.next = 29;
                    return onInputChange(null, "", "my-reset");
                  case 29:
                    _context5.next = 37;
                    break;
                  case 31:
                    _optionToListValue = optionToListValue(val, listValues, allowCustomValues), _optionToListValue2 = _slicedToArray$1(_optionToListValue, 2), v = _optionToListValue2[0], lvs = _optionToListValue2[1];
                    setValue(v, asyncFetch ? lvs : undefined);
                    if (!(isClearingSingle && isFieldAutocomplete)) {
                      _context5.next = 37;
                      break;
                    }
                    _context5.next = 36;
                    return sleep(0);
                  case 36:
                    setOpen(false);
                  case 37:
                  case "end":
                    return _context5.stop();
                }
              }, _callee5);
            }));
            return function onChange(_x2, _x3, _x4) {
              return _ref8.apply(this, arguments);
            };
          }();
          var onInputChange = /*#__PURE__*/function () {
            var _ref9 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(e, newInputValue, eventType) {
              var shouldIgnore, val, canSearchAsync;
              return _regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) switch (_context6.prev = _context6.next) {
                  case 0:
                    // eventType=reset used by MUI on:
                    // - (single) initial set, select option - e = null, newInputValue = selected  (+1 call before with e != null)
                    // - (single/multi, -ACV) blur - e != null, newInputValue = ''
                    // - (multiple v5, -ACV) blur - e = null, newInputValue = '' # unwanted
                    // - (multiple) select option - e != null, newInputValue = ''
                    // - (multiple v4) delete tag while searching - e = null, newInputValue = ''  # unwanted
                    // - (multiple v4) select option while searching - e = null, newInputValue = ''  # unwanted
                    shouldIgnore = uif === "mui" && eventType === "reset";
                    val = newInputValue;
                    if (!(val === loadMoreTitle || val === loadingMoreTitle || shouldIgnore)) {
                      _context6.next = 4;
                      break;
                    }
                    return _context6.abrupt("return");
                  case 4:
                    if (!(newInputValue != inputValue)) {
                      _context6.next = 13;
                      break;
                    }
                    setInputValue(val);
                    canSearchAsync = useAsyncSearch && (forceAsyncSearch ? !!val : true);
                    if (!canSearchAsync) {
                      _context6.next = 12;
                      break;
                    }
                    _context6.next = 10;
                    return loadListValuesDebounced(val);
                  case 10:
                    _context6.next = 13;
                    break;
                  case 12:
                    if (useAsyncSearch && forceAsyncSearch) {
                      setAsyncListValues([]);
                    }
                  case 13:
                  case "end":
                    return _context6.stop();
                }
              }, _callee6);
            }));
            return function onInputChange(_x5, _x6, _x7) {
              return _ref9.apply(this, arguments);
            };
          }();

          // Options
          var extendOptions = function extendOptions(options) {
            var filtered = _toConsumableArray(options);
            if (useLoadMore) {
              if (canShowLoadMore) {
                filtered.push({
                  specialValue: "LOAD_MORE",
                  title: loadMoreTitle
                });
              } else if (isLoadingMore) {
                filtered.push({
                  specialValue: "LOADING_MORE",
                  title: loadingMoreTitle,
                  disabled: true
                });
              }
            }
            return filtered;
          };
          var getOptionSelected = function getOptionSelected(option, valueOrOption) {
            if (valueOrOption == null) return null;
            var selectedValue = valueOrOption.value != undefined ? valueOrOption.value : valueOrOption;
            return option.value === selectedValue;
          };
          var getOptionDisabled = function getOptionDisabled(valueOrOption) {
            return valueOrOption && valueOrOption.disabled;
          };
          var getOptionIsCustom = function getOptionIsCustom(valueOrOption) {
            var _valueOrOption$value;
            if (valueOrOption !== null && valueOrOption !== void 0 && valueOrOption.isCustom) return true;
            var val = (_valueOrOption$value = valueOrOption === null || valueOrOption === void 0 ? void 0 : valueOrOption.value) !== null && _valueOrOption$value !== void 0 ? _valueOrOption$value : valueOrOption;
            var lv = getListValue(val, listValues);
            return (lv === null || lv === void 0 ? void 0 : lv.isCustom) || false;
          };
          var getOptionLabel = function getOptionLabel(valueOrOption) {
            if (valueOrOption == null) return null;
            var option = valueOrOption.value != undefined ? valueOrOption : listValueToOption(getListValue(valueOrOption, listValues));
            if (!option && valueOrOption.specialValue) {
              // special last 'Load more...' item
              return valueOrOption.title;
            }
            if (!option && allowCustomValues) {
              // there is just string value, it's not item from list
              return valueOrOption.toString();
            }
            if (!option) {
              // weird
              return valueOrOption.toString();
            }
            return option.title || option.label || option.value.toString(); // fallback to value
          };
          var fixedOptions = uif === "mui" ? fixListValuesGroupOrder(options) : options;
          return {
            options: fixedOptions,
            listValues: listValues,
            hasValue: hasValue,
            selectedListValue: selectedListValue,
            open: open,
            onOpen: onOpen,
            onClose: onClose,
            onDropdownVisibleChange: onDropdownVisibleChange,
            onChange: onChange,
            inputValue: inputValue,
            onInputChange: onInputChange,
            canShowLoadMore: canShowLoadMore,
            isInitialLoading: isInitialLoading,
            isLoading: isLoading,
            isLoadingMore: isLoadingMore,
            isSpecialValue: isSpecialValue,
            extendOptions: extendOptions,
            getOptionSelected: getOptionSelected,
            getOptionDisabled: getOptionDisabled,
            getOptionIsCustom: getOptionIsCustom,
            getOptionLabel: getOptionLabel,
            aPlaceholder: aPlaceholder
          };
        };
        function ownKeys$3(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$3(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        const Utils = _objectSpread$3(_objectSpread$3({}, Utils$1), {}, {
          ReactUtils: ReactUtils,
          DragIcon: DragIcon$1
        });
        var _xdpPackage$version$s$3, _xdpPackage$version$3;
        var moment$2 = Utils.moment;
        var xdpVersion$3 = parseInt((_xdpPackage$version$s$3 = xdpPackage === null || xdpPackage === void 0 || (_xdpPackage$version$3 = xdpPackage.version) === null || _xdpPackage$version$3 === void 0 || (_xdpPackage$version$3 = _xdpPackage$version$3.split(".")) === null || _xdpPackage$version$3 === void 0 ? void 0 : _xdpPackage$version$3[0]) !== null && _xdpPackage$version$s$3 !== void 0 ? _xdpPackage$version$s$3 : "0");
        const MuiDateWidget = function MuiDateWidget(props) {
          var value = props.value,
            setValue = props.setValue,
            readonly = props.readonly,
            customProps = props.customProps,
            dateFormat = props.dateFormat,
            valueFormat = props.valueFormat,
            placeholder = props.placeholder;
          var formatSingleValue = function formatSingleValue(value) {
            return value && value.isValid() ? value.format(valueFormat) : undefined;
          };
          var handleChange = function handleChange(value) {
            setValue(formatSingleValue(value));
          };
          var renderInput = function renderInput(params) {
            return /*#__PURE__*/React.createElement(TextField, _extends$h({
              size: "small",
              variant: "standard"
            }, params));
          };
          var desktopModeMediaQuery = "@media (pointer: fine), (pointer: none)";
          var pickerProps = xdpVersion$3 >= 6 ? {
            format: dateFormat,
            slotProps: {
              textField: {
                size: "small",
                variant: "standard"
              },
              toolbar: {
                toolbarPlaceholder: !readonly ? placeholder : ""
              }
            }
          } : {
            inputFormat: dateFormat,
            renderInput: renderInput,
            toolbarPlaceholder: !readonly ? placeholder : ""
          };
          var aValue = value ? xdpVersion$3 >= 6 ? moment$2(value, valueFormat) : value : null;
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(DatePicker, _extends$h({
            desktopModeMediaQuery: desktopModeMediaQuery,
            readOnly: readonly,
            disabled: readonly,
            value: aValue,
            onChange: handleChange
          }, pickerProps, customProps)));
        };
        var _xdpPackage$version$s$2, _xdpPackage$version$2;
        var moment$1 = Utils.moment;
        var xdpVersion$2 = parseInt((_xdpPackage$version$s$2 = xdpPackage === null || xdpPackage === void 0 || (_xdpPackage$version$2 = xdpPackage.version) === null || _xdpPackage$version$2 === void 0 || (_xdpPackage$version$2 = _xdpPackage$version$2.split(".")) === null || _xdpPackage$version$2 === void 0 ? void 0 : _xdpPackage$version$2[0]) !== null && _xdpPackage$version$s$2 !== void 0 ? _xdpPackage$version$s$2 : "0");
        const MuiDateTimeWidget = function MuiDateTimeWidget(props) {
          var value = props.value,
            setValue = props.setValue,
            use12Hours = props.use12Hours,
            readonly = props.readonly,
            placeholder = props.placeholder,
            dateFormat = props.dateFormat,
            timeFormat = props.timeFormat,
            valueFormat = props.valueFormat,
            customProps = props.customProps;
          var formatSingleValue = function formatSingleValue(value) {
            return value && value.isValid() ? value.format(valueFormat) : undefined;
          };
          var handleChange = function handleChange(value) {
            setValue(formatSingleValue(value));
          };
          var dateTimeFormat = dateFormat + " " + timeFormat;
          var renderInput = function renderInput(params) {
            return /*#__PURE__*/React.createElement(TextField, _extends$h({
              size: "small",
              variant: "standard"
            }, params));
          };
          var desktopModeMediaQuery = "@media (pointer: fine), (pointer: none)";
          var pickerProps = xdpVersion$2 >= 6 ? {
            format: dateTimeFormat,
            slotProps: {
              textField: {
                size: "small",
                variant: "standard"
              },
              toolbar: {
                toolbarPlaceholder: !readonly ? placeholder : ""
              }
            }
          } : {
            inputFormat: dateTimeFormat,
            renderInput: renderInput,
            toolbarPlaceholder: !readonly ? placeholder : ""
          };
          var aValue = value ? xdpVersion$2 >= 6 ? moment$1(value, valueFormat) : value : null;
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(DateTimePicker, _extends$h({
            desktopModeMediaQuery: desktopModeMediaQuery,
            readOnly: readonly,
            disabled: readonly,
            ampm: !!use12Hours,
            value: aValue,
            onChange: handleChange
          }, pickerProps, customProps)));
        };
        var _xdpPackage$version$s$1, _xdpPackage$version$1;
        var moment = Utils.moment;
        var xdpVersion$1 = parseInt((_xdpPackage$version$s$1 = xdpPackage === null || xdpPackage === void 0 || (_xdpPackage$version$1 = xdpPackage.version) === null || _xdpPackage$version$1 === void 0 || (_xdpPackage$version$1 = _xdpPackage$version$1.split(".")) === null || _xdpPackage$version$1 === void 0 ? void 0 : _xdpPackage$version$1[0]) !== null && _xdpPackage$version$s$1 !== void 0 ? _xdpPackage$version$s$1 : "0");
        const MuiTimeWidget = function MuiTimeWidget(props) {
          var value = props.value,
            setValue = props.setValue,
            use12Hours = props.use12Hours,
            readonly = props.readonly,
            placeholder = props.placeholder,
            timeFormat = props.timeFormat,
            valueFormat = props.valueFormat,
            customProps = props.customProps;
          var formatSingleValue = function formatSingleValue(value) {
            return value && value.isValid() ? value.format(valueFormat) : undefined;
          };
          var handleChange = function handleChange(value) {
            setValue(formatSingleValue(value));
          };
          var hasSeconds = timeFormat.indexOf(":ss") != -1;
          var timeValue = value ? moment(value, timeFormat) : null;
          var renderInput = function renderInput(params) {
            return /*#__PURE__*/React.createElement(TextField, _extends$h({
              size: "small",
              variant: "standard"
            }, params));
          };
          var desktopModeMediaQuery = "@media (pointer: fine), (pointer: none)";
          var pickerProps = xdpVersion$1 >= 6 ? {
            format: timeFormat,
            slotProps: {
              textField: {
                size: "small",
                variant: "standard"
              },
              toolbar: {
                toolbarPlaceholder: !readonly ? placeholder : ""
              }
            }
          } : {
            inputFormat: timeFormat,
            renderInput: renderInput,
            toolbarPlaceholder: !readonly ? placeholder : ""
          };
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(TimePicker, _extends$h({
            desktopModeMediaQuery: desktopModeMediaQuery,
            readOnly: readonly,
            disabled: readonly,
            ampm: !!use12Hours,
            value: timeValue,
            onChange: handleChange,
            views: hasSeconds ? ["hours", "minutes", "seconds"] : ["hours", "minutes"]
          }, pickerProps, customProps)));
        };
        var mapListValues$1 = Utils.ListUtils.mapListValues;
        const MuiSelectWidget = function MuiSelectWidget(_ref) {
          var listValues = _ref.listValues,
            value = _ref.value,
            setValue = _ref.setValue;
          _ref.allowCustomValues;
          var readonly = _ref.readonly,
            placeholder = _ref.placeholder,
            customProps = _ref.customProps;
          var renderOptions = function renderOptions() {
            return mapListValues$1(listValues, function (_ref2) {
              var title = _ref2.title,
                value = _ref2.value;
              return /*#__PURE__*/React.createElement(MenuItem, {
                key: value,
                value: value
              }, title);
            });
          };
          var onChange = function onChange(e) {
            if (e.target.value === undefined) return;
            setValue(e.target.value);
          };
          var renderValue = function renderValue(selectedValue) {
            if (!readonly && selectedValue == null) return placeholder;
            return getListValueTitle(selectedValue);
          };
          var getListValueTitle = function getListValueTitle(selectedValue) {
            return mapListValues$1(listValues, function (_ref3) {
              var title = _ref3.title,
                value = _ref3.value;
              return value === selectedValue ? title : null;
            }).filter(function (v) {
              return v !== null;
            }).shift();
          };
          var hasValue = value != null;
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Select, _extends$h({
            variant: "standard",
            autoWidth: true,
            displayEmpty: true,
            placeholder: !readonly ? placeholder : "",
            onChange: onChange,
            value: hasValue ? value : "",
            disabled: readonly,
            readOnly: readonly,
            renderValue: renderValue,
            size: "small"
          }, omit$1(customProps, ["showSearch", "input"])), renderOptions()));
        };
        const MuiNumberWidget = function MuiNumberWidget(props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var readonly = props.readonly,
            min = props.min,
            max = props.max,
            step = props.step,
            placeholder = props.placeholder,
            customProps = props.customProps;
          var onChange = function onChange(e) {
            var val = e.target.value;
            if (val === "" || val === null) val = undefined;else val = Number(val);
            setValue(val);
          };
          var numberValue = value == undefined ? "" : value;
          var InputProps = reactExports.useMemo(function () {
            return {
              readOnly: readonly
            };
          }, [readonly]);
          var inputProps = reactExports.useMemo(function () {
            return {
              min: min,
              max: max,
              step: step
            };
          }, [min, max, step]);
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(TextField, _extends$h({
            variant: "standard",
            type: "number",
            value: numberValue,
            placeholder: !readonly ? placeholder : "",
            InputProps: InputProps,
            inputProps: inputProps,
            disabled: readonly,
            onChange: onChange,
            size: "small"
          }, customProps)));
        };
        var _excluded$3 = ["width"];
        const MuiSliderWidget = function MuiSliderWidget(props) {
          var config = props.config,
            placeholder = props.placeholder,
            customProps = props.customProps,
            value = props.value,
            setValue = props.setValue,
            min = props.min,
            max = props.max,
            step = props.step,
            marks = props.marks,
            readonly = props.readonly;
          var defaultSliderWidth = config.settings.defaultSliderWidth;
          var handleSliderChange = reactExports.useCallback(function (_e, newValue) {
            setValue(newValue);
          }, [setValue]);
          var handleInputChange = reactExports.useCallback(function (e) {
            var val = e.target.value;
            if (val === "" || val === null) val = undefined;else val = Number(val);
            setValue(val);
          }, [setValue]);
          var handleInputBlur = reactExports.useCallback(function (e) {
            var val = e.target.value;
            if (val === "" || val === null) val = undefined;else val = Number(val);
            // TIP: Fix if typed value out of range in input
            if (val < min) {
              setValue(min);
            } else if (val > max) {
              setValue(max);
            }
          }, [setValue, min, max]);
          var _ref = customProps || {},
            width = _ref.width,
            rest = _objectWithoutProperties$2(_ref, _excluded$3);
          var customInputProps = rest.input || {};
          var customSliderProps = rest.slider || rest;

          // TIP: Can't pass undefined to MUI, cause it means uncontrolled component use.
          //      For empty value input needs "", slider needs null or 0
          var inputValue = typeof value === "number" ? value : "";
          var sliderValue = typeof value === "number" ? value : null;

          // marks example: { 0: "0%", 100: React.createElement('strong', null, "100%") }
          var muiMarks = reactExports.useMemo(function () {
            return marks ? Object.keys(marks).map(function (v) {
              return {
                value: Number(v),
                label: _typeof$3(marks[v]) === "object" || typeof marks[v] === "undefined" ? marks[v] : /*#__PURE__*/React.createElement("p", null, marks[v])
              };
            }) : false;
          }, [marks]);
          var InputProps = reactExports.useMemo(function () {
            return {
              readOnly: readonly
            };
          }, [readonly]);
          var inputProps = reactExports.useMemo(function () {
            return {
              min: min,
              max: max,
              step: step
            };
          }, [min, max, step]);
          var InputCmp = /*#__PURE__*/React.createElement(TextField, _extends$h({
            variant: "standard",
            type: "number",
            value: inputValue,
            placeholder: placeholder,
            InputProps: InputProps,
            inputProps: inputProps,
            disabled: readonly,
            onChange: handleInputChange,
            onBlur: handleInputBlur,
            size: "small"
          }, customInputProps));
          var SliderCmp = /*#__PURE__*/React.createElement(Slider$1, _extends$h({
            value: sliderValue,
            onChange: handleSliderChange,
            disabled: readonly,
            min: min,
            max: max,
            step: step,
            marks: muiMarks,
            valueLabelDisplay: "auto",
            size: "small"
          }, customSliderProps));
          var stylesWrapper = {
            display: "inline-flex",
            alignItems: "center",
            flexWrap: "wrap"
          };
          var stylesInputWrapper = {
            marginLeft: "5px"
          };
          var stylesSliderWrapper = {
            marginLeft: "5px",
            paddingLeft: "12px",
            marginBottom: muiMarks && "-16px",
            width: width || defaultSliderWidth
          };
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement("div", {
            style: stylesWrapper
          }, /*#__PURE__*/React.createElement("div", {
            style: stylesInputWrapper
          }, InputCmp), /*#__PURE__*/React.createElement("div", {
            style: stylesSliderWrapper
          }, SliderCmp)));
        };
        var _excluded$2 = ["width"];
        const MuiRangeWidget = function MuiRangeWidget(props) {
          var config = props.config,
            placeholders = props.placeholders,
            customProps = props.customProps,
            value = props.value,
            setValue = props.setValue,
            min = props.min,
            max = props.max,
            step = props.step,
            marks = props.marks,
            readonly = props.readonly,
            textSeparators = props.textSeparators;
          var defaultSliderWidth = config.settings.defaultSliderWidth;
          reactExports.useEffect(function () {
            var _ref = props.value || [undefined, undefined],
              _ref2 = _slicedToArray$1(_ref, 2),
              valueFrom = _ref2[0],
              valueTo = _ref2[1];
            if (props.value && (valueFrom == undefined || valueTo == undefined)) ;
          }, []);
          var handleSliderChange = function handleSliderChange(_e, newValues) {
            setValue(newValues);
          };
          var handleInputChangeFrom = function handleInputChangeFrom(e) {
            // TIP: need to use props.value instead of value
            var valueFrom = e.target.value;
            if (valueFrom === "" || valueFrom == null) valueFrom = undefined;else valueFrom = Number(valueFrom);
            var value = props.value ? _toConsumableArray(props.value) : [undefined, undefined];
            value[0] = valueFrom;
            setValue(value);
          };
          var handleInputChangeTo = function handleInputChangeTo(e) {
            var valueTo = e.target.value;
            if (valueTo === "" || valueTo == null) valueTo = undefined;else valueTo = Number(valueTo);
            var value = props.value ? _toConsumableArray(props.value) : [undefined, undefined];
            value[1] = valueTo;
            setValue(value);
          };
          var handleInputBlur = function handleInputBlur() {
            // TIP: Fix if typed value out of range in inputs
            if (!value) return;
            if (value[0] < min) {
              setValue([min, value[1]]);
            } else if (value[1] > max) {
              setValue([value[0], max]);
            }
          };
          var _ref3 = customProps || {},
            width = _ref3.width,
            rest = _objectWithoutProperties$2(_ref3, _excluded$2);
          var customInputProps = rest.input || {};
          var customSliderProps = rest.slider || rest;

          // marks example: { 0: "0%", 100: React.createElement('strong', null, "100%") }
          var muiMarks = marks ? Object.keys(marks).map(function (v) {
            return {
              value: Number(v),
              label: _typeof$3(marks[v]) === "object" || typeof marks[v] === "undefined" ? marks[v] : /*#__PURE__*/React.createElement("p", null, marks[v])
            };
          }) : false;

          // TIP: Can't pass undefined to MUI, cause it means uncontrolled component use.
          //      For empty value input needs "", slider needs null or 0, but null will cause problems with range mode
          var sliderValue = value ? _toConsumableArray(value) : [undefined, undefined];
          var _sliderValue = _slicedToArray$1(sliderValue, 2),
            valueFrom = _sliderValue[0],
            valueTo = _sliderValue[1];
          if (valueFrom == undefined) {
            valueFrom = "";
            sliderValue[0] = 0;
          }
          if (valueTo == undefined) {
            valueTo = "";
            sliderValue[1] = 0;
          }
          var FromInputCmp = /*#__PURE__*/React.createElement(TextField, _extends$h({
            variant: "standard",
            type: "number",
            value: valueFrom,
            placeholder: placeholders[0],
            InputProps: {
              readOnly: readonly
            },
            inputProps: {
              min: min,
              max: max,
              step: step
            },
            disabled: readonly,
            onChange: handleInputChangeFrom,
            onBlur: handleInputBlur,
            size: "small"
          }, customInputProps));
          var ToInputCmp = /*#__PURE__*/React.createElement(TextField, _extends$h({
            variant: "standard",
            type: "number",
            value: valueTo,
            placeholder: placeholders[1],
            InputProps: {
              readOnly: readonly
            },
            inputProps: {
              min: min,
              max: max,
              step: step
            },
            disabled: readonly,
            onChange: handleInputChangeTo,
            onBlur: handleInputBlur,
            size: "small"
          }, customInputProps));
          var SliderCmp = /*#__PURE__*/React.createElement(Slider$1, _extends$h({
            value: sliderValue,
            onChange: handleSliderChange,
            disabled: readonly,
            min: min,
            max: max,
            step: step,
            marks: muiMarks,
            valueLabelDisplay: "auto",
            size: "small"
          }, customSliderProps));
          var stylesWrapper = {
            display: "inline-flex",
            flexWrap: "wrap"
          };
          var stylesInputWrapper = {
            marginLeft: "5px"
          };
          var stylesSliderWrapper = {
            marginLeft: "5px",
            paddingLeft: "12px",
            marginBottom: muiMarks && "-16px",
            width: width || defaultSliderWidth
          };
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement("div", {
            style: stylesWrapper
          }, /*#__PURE__*/React.createElement("div", {
            style: stylesInputWrapper
          }, FromInputCmp), /*#__PURE__*/React.createElement("div", {
            className: "widget--sep"
          }, /*#__PURE__*/React.createElement("span", null, textSeparators[1])), /*#__PURE__*/React.createElement("div", {
            style: stylesInputWrapper
          }, ToInputCmp), /*#__PURE__*/React.createElement("div", {
            style: stylesSliderWrapper
          }, SliderCmp)));
        };
        const MuiBooleanWidget = function MuiBooleanWidget(props) {
          var customProps = props.customProps,
            value = props.value,
            setValue = props.setValue,
            labelYes = props.labelYes,
            labelNo = props.labelNo,
            readonly = props.readonly;
          var onChange = function onChange() {
            setValue(!value);
          };
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Typography, {
            component: "div"
          }, /*#__PURE__*/React.createElement(Grid$1, {
            component: "label",
            container: true,
            alignItems: "center",
            spacing: 0
          }, /*#__PURE__*/React.createElement(Grid$1, {
            item: true,
            component: "span"
          }, labelNo), /*#__PURE__*/React.createElement(Grid$1, {
            item: true,
            component: "span"
          }, /*#__PURE__*/React.createElement(Switch, _extends$h({
            checked: !!value,
            onChange: onChange,
            disabled: readonly
          }, customProps))), /*#__PURE__*/React.createElement(Grid$1, {
            item: true,
            component: "span"
          }, labelYes))));
        };
        var mapListValues = Utils.ListUtils.mapListValues;
        const MuiMultiSelectWidget = function MuiMultiSelectWidget(_ref) {
          var listValues = _ref.listValues,
            value = _ref.value,
            setValue = _ref.setValue;
          _ref.allowCustomValues;
          var readonly = _ref.readonly,
            placeholder = _ref.placeholder,
            customProps = _ref.customProps;
          var renderOptions = function renderOptions(selectedValues) {
            return mapListValues(listValues, function (_ref2) {
              var title = _ref2.title,
                value = _ref2.value;
              return /*#__PURE__*/React.createElement(MenuItem, {
                key: value,
                value: value
              }, /*#__PURE__*/React.createElement(Checkbox, {
                checked: selectedValues.indexOf(value) > -1
              }), /*#__PURE__*/React.createElement(ListItemText, {
                primary: title
              }));
            });
          };
          var renderValue = function renderValue(selectedValues) {
            if (!readonly && !selectedValues.length) return placeholder;
            var selectedTitles = mapListValues(listValues, function (_ref3) {
              var title = _ref3.title,
                value = _ref3.value;
              return selectedValues.indexOf(value) > -1 ? title : null;
            }).filter(function (v) {
              return v !== null;
            });
            return selectedTitles.join(", ");
          };
          var hasValue = value != null && value.length > 0;
          var onChange = function onChange(e) {
            if (e.target.value === undefined) return;
            setValue(e.target.value);
          };
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Select, _extends$h({
            multiple: true,
            variant: "standard",
            autoWidth: true,
            displayEmpty: true,
            label: !readonly ? placeholder : "",
            onChange: onChange,
            value: hasValue ? value : [],
            disabled: readonly,
            readOnly: readonly,
            renderValue: renderValue,
            size: "small"
          }, omit$1(customProps, ["showSearch", "input", "showCheckboxes"])), renderOptions(hasValue ? value : [])));
        };
        var Check = {};
        var _interopRequireDefault$i = interopRequireDefaultExports;
        Object.defineProperty(Check, "__esModule", {
          value: true
        });
        var default_1$a = Check.default = void 0;
        var _createSvgIcon$a = _interopRequireDefault$i(requireCreateSvgIcon());
        var _jsxRuntime$a = jsxRuntimeExports;
        default_1$a = Check.default = (0, _createSvgIcon$a.default)(/*#__PURE__*/(0, _jsxRuntime$a.jsx)("path", {
          d: "M9 16.17 4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"
        }), 'Check');
        var _excluded$1 = ["width"];
        function ownKeys$2(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$2(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        var useListValuesAutocomplete = useListValuesAutocomplete$1;
        var emptyArray = [];

        // tip: option can contain `group: {label, title}` intead of `groupTitle`
        // but it's internal format, made for field autocomplete
        // see `JSON.stringify(option.group)` and `JSON.parse(groupMaybeJson)`

        const MuiAutocompleteWidget = function MuiAutocompleteWidget(props) {
          var allowCustomValues = props.allowCustomValues,
            multiple = props.multiple,
            disableClearable = props.disableClearable,
            selectedValue = props.value,
            customProps = props.customProps,
            readonly = props.readonly,
            config = props.config,
            filterOptionsConfig = props.filterOptionsConfig,
            errorText = props.errorText,
            tooltipText = props.tooltipText,
            isFieldAutocomplete = props.isFieldAutocomplete;
          var stringifyOption = reactExports.useCallback(function (option) {
            var keysForFilter = config.settings.listKeysForSearch;
            var valueForFilter = keysForFilter.map(function (k) {
              return typeof option[k] == "string" ? option[k] : "";
            }).join("\0");
            return valueForFilter;
          }, [config]);
          var defaultFilterOptionsConfig = {
            stringify: stringifyOption
          };
          var filterOptionsFn = createFilterOptions(filterOptionsConfig || defaultFilterOptionsConfig);

          // hook
          var _useListValuesAutocom = useListValuesAutocomplete(props, {
              debounceTimeout: 100,
              multiple: multiple,
              uif: "mui",
              isFieldAutocomplete: isFieldAutocomplete
            }),
            open = _useListValuesAutocom.open,
            onOpen = _useListValuesAutocom.onOpen,
            onClose = _useListValuesAutocom.onClose,
            onChange = _useListValuesAutocom.onChange,
            onInputChange = _useListValuesAutocom.onInputChange,
            inputValue = _useListValuesAutocom.inputValue,
            options = _useListValuesAutocom.options,
            isInitialLoading = _useListValuesAutocom.isInitialLoading,
            isLoading = _useListValuesAutocom.isLoading,
            aPlaceholder = _useListValuesAutocom.aPlaceholder,
            extendOptions = _useListValuesAutocom.extendOptions,
            getOptionDisabled = _useListValuesAutocom.getOptionDisabled,
            getOptionIsCustom = _useListValuesAutocom.getOptionIsCustom,
            getOptionLabel = _useListValuesAutocom.getOptionLabel,
            selectedListValue = _useListValuesAutocom.selectedListValue;

          // settings
          var _config$settings = config.settings,
            defaultSelectWidth = _config$settings.defaultSelectWidth,
            defaultSearchWidth = _config$settings.defaultSearchWidth;
          var _ref = customProps || {},
            width = _ref.width,
            rest = _objectWithoutProperties$2(_ref, _excluded$1);
          var customInputProps = rest.input || {};
          customInputProps.width || defaultSearchWidth; // todo: use as min-width for Autocomplete comp
          customInputProps = omit$1(customInputProps, ["width"]);
          var customAutocompleteProps = omit$1(rest, ["showSearch", "showCheckboxes"]);
          var fullWidth = false;
          var minWidth = width || defaultSelectWidth;
          var style = {
            width: multiple ? undefined : minWidth,
            minWidth: minWidth
          };
          var placeholder = !readonly ? aPlaceholder : "";

          // For accessibility, always give the input field an aria-label
          var ariaLabel = placeholder || config.settings.fieldPlaceholder;
          var hasValue = selectedValue != null;
          // should be simple value to prevent re-render!s
          var value = hasValue ? selectedValue : multiple ? emptyArray : null;
          var filterOptions = function filterOptions(options, params) {
            var filtered = filterOptionsFn(options, params);
            var extended = extendOptions(filtered);
            return extended;
          };
          var groupBy = function groupBy(option) {
            return option !== null && option !== void 0 && option.group ? JSON.stringify(option.group) : option === null || option === void 0 ? void 0 : option.groupTitle;
          };
          var theme = useTheme();

          // render
          var renderInput = function renderInput(params) {
            var _ref2, _selectedListValue$ti, _ref3;
            // parity with Antd
            var shouldRenderSelected = !multiple && !open;
            var selectedTitle = (_ref2 = (_selectedListValue$ti = selectedListValue === null || selectedListValue === void 0 ? void 0 : selectedListValue.title) !== null && _selectedListValue$ti !== void 0 ? _selectedListValue$ti : value === null || value === void 0 ? void 0 : value.toString()) !== null && _ref2 !== void 0 ? _ref2 : "";
            var shouldHide = multiple && !open;
            var renderValue = shouldRenderSelected ? selectedTitle : shouldHide ? "" : (_ref3 = inputValue !== null && inputValue !== void 0 ? inputValue : value === null || value === void 0 ? void 0 : value.toString()) !== null && _ref3 !== void 0 ? _ref3 : "";
            return /*#__PURE__*/React.createElement(TextField, _extends$h({
              variant: "standard"
            }, params, {
              inputProps: _objectSpread$2(_objectSpread$2({
                "aria-label": ariaLabel
              }, params.inputProps), {}, {
                value: renderValue
              }),
              InputProps: _objectSpread$2(_objectSpread$2({}, params.InputProps), {}, {
                readOnly: readonly,
                endAdornment: /*#__PURE__*/React.createElement(React.Fragment, null, isLoading ? /*#__PURE__*/React.createElement(CircularProgress, {
                  color: "inherit",
                  size: 20
                }) : null, params.InputProps.endAdornment)
              }),
              disabled: readonly,
              placeholder: placeholder,
              error: !!errorText
              //onChange={onInputChange}
            }, customInputProps));
          };
          var GroupHeader = function GroupHeader(_ref4) {
            var groupMaybeJson = _ref4.groupMaybeJson;
            if (!groupMaybeJson) return null;
            var group = {
              label: groupMaybeJson
            };
            if (typeof groupMaybeJson === "string" && groupMaybeJson[0] === "{") {
              try {
                group = JSON.parse(groupMaybeJson);
              } catch (_) {
                // ignore
              }
            }
            var groupLabel = group.label;
            if (groupLabel && group.tooltip) {
              groupLabel = /*#__PURE__*/React.createElement(Tooltip, {
                title: group.tooltip,
                placement: "left-start"
              }, /*#__PURE__*/React.createElement("span", null, groupLabel));
            }
            var res = /*#__PURE__*/React.createElement("div", {
              style: {
                position: "sticky",
                top: "-8px",
                padding: "4px 10px",
                color: theme.palette.primary.main,
                backgroundColor: theme.palette.background["default"]
              }
            }, groupLabel);
            return res;
          };
          var GroupItems = function GroupItems(_ref5) {
            var children = _ref5.children;
            return /*#__PURE__*/React.createElement(React.Fragment, null, children);
          };
          var renderGroup = function renderGroup(params) {
            var res = /*#__PURE__*/React.createElement("div", {
              key: params.key
            }, /*#__PURE__*/React.createElement(GroupHeader, {
              groupMaybeJson: params.group
            }), /*#__PURE__*/React.createElement(GroupItems, null, params.children));
            return res;
          };
          var renderTags = function renderTags(value, getTagProps) {
            return value.map(function (option, index) {
              return /*#__PURE__*/React.createElement(Chip, _extends$h({
                key: option.value,
                label: getOptionLabel(option),
                size: "small",
                variant: getOptionIsCustom(option) ? "outlined" : "filled"
              }, getTagProps({
                index: index
              })));
            });
          };
          var isOptionEqualToValue = function isOptionEqualToValue(option, value) {
            return (option === null || option === void 0 ? void 0 : option.value) == value;
          };
          var renderOption = function renderOption(props, option) {
            var title = option.title,
              renderTitle = option.renderTitle,
              value = option.value,
              isHidden = option.isHidden,
              tooltip = option.tooltip,
              group = option.group,
              groupTitle = option.groupTitle;
            var isGrouped = groupTitle || group;
            var isSelected = multiple ? (selectedValue || []).includes(value) : selectedValue == value;
            var className = getOptionIsCustom(option) ? "customSelectOption" : undefined;
            var prefix = !isFieldAutocomplete && isGrouped ? "\xA0\xA0" : "";
            var finalTitle = renderTitle || prefix + title;
            var titleSpan = /*#__PURE__*/React.createElement("span", {
              className: className
            }, finalTitle);
            if (tooltip) {
              titleSpan = /*#__PURE__*/React.createElement(Tooltip, {
                title: tooltip,
                placement: "left-start"
              }, titleSpan);
            }
            if (isHidden) return null;
            if (option.specialValue) {
              return /*#__PURE__*/React.createElement("div", props, finalTitle);
            } else if (multiple) {
              var itemContent = isSelected ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ListItemIcon, null, /*#__PURE__*/React.createElement(default_1$a, null)), titleSpan) : /*#__PURE__*/React.createElement(ListItemText, {
                inset: true
              }, titleSpan);
              return /*#__PURE__*/React.createElement(MenuItem, _extends$h({}, props, {
                size: "small",
                selected: isSelected
              }), itemContent);
            } else {
              return /*#__PURE__*/React.createElement("div", props, titleSpan);
            }
          };
          var res = /*#__PURE__*/React.createElement(Autocomplete, _extends$h({
            disableClearable: disableClearable,
            disableCloseOnSelect: multiple,
            fullWidth: fullWidth,
            multiple: multiple,
            style: style,
            freeSolo: allowCustomValues,
            loading: isInitialLoading,
            open: open,
            onOpen: onOpen,
            onClose: onClose,
            inputValue: inputValue,
            onInputChange: onInputChange,
            label: placeholder,
            onChange: onChange,
            value: value,
            disabled: readonly,
            readOnly: readonly,
            options: options,
            groupBy: groupBy,
            getOptionLabel: getOptionLabel,
            getOptionDisabled: getOptionDisabled,
            renderInput: renderInput,
            renderGroup: renderGroup,
            renderTags: renderTags,
            renderOption: renderOption,
            filterOptions: filterOptions,
            isOptionEqualToValue: isOptionEqualToValue,
            size: "small"
          }, customAutocompleteProps));
          if (tooltipText) {
            res = /*#__PURE__*/React.createElement(Tooltip, {
              title: !open ? tooltipText : null,
              placement: "top-start"
            }, res);
          }
          res = /*#__PURE__*/React.createElement(FormControl, {
            fullWidth: fullWidth
          }, res);
          return res;
        };
        const MuiFieldSelect = function MuiFieldSelect(_ref) {
          var items = _ref.items,
            setField = _ref.setField,
            selectedKey = _ref.selectedKey,
            readonly = _ref.readonly,
            placeholder = _ref.placeholder,
            errorText = _ref.errorText,
            selectedLabel = _ref.selectedLabel;
          _ref.selectedOpts;
          var selectedAltLabel = _ref.selectedAltLabel,
            selectedFullLabel = _ref.selectedFullLabel;
          var _useState = reactExports.useState(false),
            _useState2 = _slicedToArray$1(_useState, 2),
            open = _useState2[0],
            setOpen = _useState2[1];
          var onOpen = reactExports.useCallback(function () {
            setOpen(true);
          }, [setOpen]);
          var onClose = reactExports.useCallback(function () {
            setOpen(false);
          }, [setOpen]);
          var renderOptions = function renderOptions(fields) {
            var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            return Object.keys(fields).map(function (fieldKey) {
              var field = fields[fieldKey];
              var items = field.items,
                path = field.path,
                label = field.label,
                disabled = field.disabled,
                matchesType = field.matchesType,
                tooltip = field.tooltip;
              var prefix = "\xA0\xA0".repeat(level);
              var finalLabel = /*#__PURE__*/React.createElement("span", null, prefix && /*#__PURE__*/React.createElement("span", null, prefix), matchesType ? /*#__PURE__*/React.createElement("b", null, label) : label);
              if (tooltip) {
                finalLabel = /*#__PURE__*/React.createElement(Tooltip, {
                  title: tooltip,
                  placement: "left-start"
                }, finalLabel);
              }
              if (items) {
                return [/*#__PURE__*/React.createElement(ListSubheader, {
                  disabled: disabled,
                  key: path,
                  disableSticky: true
                }, finalLabel), renderOptions(items, level + 1)];
              } else {
                return /*#__PURE__*/React.createElement(MenuItem, {
                  disabled: disabled,
                  key: path,
                  value: path
                }, finalLabel);
              }
            });
          };
          var onChange = reactExports.useCallback(function (e) {
            if (e.target.value === undefined) return;
            setField(e.target.value);
          }, [setField]);
          var renderValue = reactExports.useCallback(function (selectedValue) {
            if (!readonly && !selectedValue) return placeholder;
            var findLabel = function findLabel(fields) {
              return fields.map(function (field) {
                if (!field.items) return field.path === selectedValue ? field.label : null;
                return findLabel(field.items);
              });
            };
            var label = findLabel(items).filter(function (v) {
              if (Array.isArray(v)) {
                return v.some(function (value) {
                  return value !== null;
                });
              } else {
                return v !== null;
              }
            }).pop();
            return label;
          }, [readonly, placeholder, items]);
          var hasValue = selectedKey != null;
          var tooltipText = selectedAltLabel || selectedFullLabel;
          if (tooltipText == selectedLabel) tooltipText = null;
          var res = /*#__PURE__*/React.createElement(Select, {
            error: !!errorText,
            variant: "standard",
            autoWidth: true,
            displayEmpty: true,
            placeholder: placeholder,
            onChange: onChange,
            value: hasValue ? selectedKey : "",
            disabled: readonly,
            renderValue: renderValue,
            size: "small",
            open: open,
            onOpen: onOpen,
            onClose: onClose
          }, renderOptions(items));
          if (tooltipText) {
            res = /*#__PURE__*/React.createElement(Tooltip, {
              title: !open ? tooltipText : null
            }, res);
          }
          res = /*#__PURE__*/React.createElement(FormControl, null, res);
          return res;
        };
        var _excluded = ["items", "selectedKey", "setField", "isValueField", "selectedLabel", "selectedOpts", "selectedAltLabel", "selectedFullLabel"];
        function ownKeys$1(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread$1(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }

        // see type FieldItemSearchableKeys
        var mapFieldItemToOptionKeys = {
          key: "_value2",
          path: "value",
          label: "title",
          altLabel: "_altLabel",
          tooltip: "tooltip",
          grouplabel: "groupTitle"
        };
        var itemsToListValues = function itemsToListValues(items) {
          var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          return items.map(function (item) {
            var items = item.items,
              path = item.path,
              key = item.key,
              label = item.label,
              altLabel = item.altLabel,
              disabled = item.disabled,
              grouplabel = item.grouplabel,
              group = item.group,
              matchesType = item.matchesType,
              tooltip = item.tooltip;
            var prefix = "\xA0\xA0".repeat(level);
            if (items) {
              return itemsToListValues(items, level + 1);
            } else {
              return {
                title: label,
                renderTitle: matchesType ? /*#__PURE__*/React.createElement("b", null, prefix + label) : prefix + label,
                value: path,
                disabled: disabled,
                groupTitle: level > 0 ? prefix + grouplabel : null,
                group: level > 0 ? _objectSpread$1(_objectSpread$1({}, group), {}, {
                  label: prefix + group.label
                }) : null,
                tooltip: tooltip,
                _value2: key,
                _altLabel: altLabel
              };
            }
          }).flat(Infinity);
        };
        var fieldAdapter = function fieldAdapter(_ref, config) {
          var items = _ref.items,
            selectedKey = _ref.selectedKey,
            setField = _ref.setField,
            isValueField = _ref.isValueField,
            selectedLabel = _ref.selectedLabel;
          _ref.selectedOpts;
          var selectedAltLabel = _ref.selectedAltLabel,
            selectedFullLabel = _ref.selectedFullLabel,
            rest = _objectWithoutProperties$2(_ref, _excluded);
          var tooltipText = selectedAltLabel || selectedFullLabel;
          if (tooltipText == selectedLabel) tooltipText = null;
          var listValues = itemsToListValues(items);
          var value = selectedKey;
          var setValue = function setValue(value, _asyncValues) {
            if (!value && !isValueField) return undefined;
            return setField(value);
          };
          var filterOptionsConfig = {
            stringify: reactExports.useCallback(function (option) {
              var keysForFilter = config.settings.fieldItemKeysForSearch.map(function (k) {
                return mapFieldItemToOptionKeys[k];
              });
              var valueForFilter = keysForFilter.map(function (k) {
                return typeof option[k] == "string" ? option[k] : "";
              }).join("\0");
              return valueForFilter;
            }, [config])
          };
          return _objectSpread$1(_objectSpread$1({}, rest), {}, {
            tooltipText: tooltipText,
            listValues: listValues,
            setValue: setValue,
            filterOptionsConfig: filterOptionsConfig,
            allowCustomValues: false,
            multiple: false,
            disableClearable: !isValueField,
            value: value,
            isFieldAutocomplete: true
          });
        };
        const MuiFieldAutocomplete = function MuiFieldAutocomplete(props) {
          return /*#__PURE__*/React.createElement(MuiAutocompleteWidget, fieldAdapter(props, props.config));
        };
        var DragHandle = {};
        var _interopRequireDefault$h = interopRequireDefaultExports;
        Object.defineProperty(DragHandle, "__esModule", {
          value: true
        });
        var default_1$9 = DragHandle.default = void 0;
        var _createSvgIcon$9 = _interopRequireDefault$h(requireCreateSvgIcon());
        var _jsxRuntime$9 = jsxRuntimeExports;
        default_1$9 = DragHandle.default = (0, _createSvgIcon$9.default)(/*#__PURE__*/(0, _jsxRuntime$9.jsx)("path", {
          d: "M20 9H4v2h16zM4 15h16v-2H4z"
        }), 'DragHandle');
        var DragIcon = Utils.DragIcon;
        var typeToIcon = {
          "delGroup": /*#__PURE__*/React.createElement(default_1$q, null),
          "delRuleGroup": /*#__PURE__*/React.createElement(default_1$q, null),
          "delRule": /*#__PURE__*/React.createElement(default_1$q, null),
          "addRuleGroup": /*#__PURE__*/React.createElement(default_1$c, null),
          "addRuleGroupExt": /*#__PURE__*/React.createElement(default_1$c, null),
          "addRule": /*#__PURE__*/React.createElement(default_1$c, null),
          "addGroup": /*#__PURE__*/React.createElement(default_1$c, null),
          "drag": /*#__PURE__*/React.createElement(default_1$9, null)
        };
        var typeToColor$1 = {
          // "addRule": "primary",
          // "addGroup": "primary",
          // "delGroup": "secondary",
          // "delRuleGroup": "secondary",
          // "delRule": "secondary",
          "drag": "primary"
        };
        const MuiIcon = function MuiIcon(_ref) {
          var type = _ref.type,
            readonly = _ref.readonly;
          var icon = typeToIcon[type] || null;
          if (!icon && type === "drag") {
            return /*#__PURE__*/React.createElement(DragIcon, null);
          }
          if (type === "drag") {
            return /*#__PURE__*/React.createElement(Icon, {
              size: "small",
              disabled: readonly,
              color: typeToColor$1[type]
            }, icon);
          } else {
            return icon;
          }
        };
        var hideLabelsFor = {
          "addRuleGroup": true,
          "addRuleGroupExt": true,
          "delGroup": true,
          "delRuleGroup": true,
          "delRule": true
        };
        var typeToColor = {
          "addRule": "primary",
          "addGroup": "primary",
          "delGroup": "secondary",
          "delRuleGroup": "secondary",
          "delRule": "secondary"
        };
        const MuiButton = /*#__PURE__*/reactExports.memo(function (props) {
          var type = props.type,
            label = props.label,
            onClick = props.onClick,
            readonly = props.readonly,
            renderIcon = props.renderIcon;
          var iconProps = {
            type: type,
            readonly: readonly
          };
          var icon = renderIcon === null || renderIcon === void 0 ? void 0 : renderIcon(iconProps);
          if (!label || hideLabelsFor[type]) {
            // For icons, use the label as aria-label for accessibility
            return /*#__PURE__*/React.createElement(IconButton, {
              size: "small",
              disabled: readonly,
              onClick: onClick,
              color: typeToColor[type],
              "aria-label": label
            }, icon);
          } else {
            return /*#__PURE__*/React.createElement(Button, {
              size: "small",
              disabled: readonly,
              onClick: onClick,
              color: typeToColor[type],
              startIcon: icon
            }, label);
          }
        });
        const MuiButtonGroup = function MuiButtonGroup(_ref) {
          var children = _ref.children;
          _ref.config;
          return /*#__PURE__*/React.createElement(React.Fragment, null, children);
        };
        var Conj = /*#__PURE__*/React.memo(function (_ref) {
          var conjKey = _ref.conjKey,
            id = _ref.id;
          _ref.name;
          var label = _ref.label,
            checked = _ref.checked,
            setConjunction = _ref.setConjunction,
            readonly = _ref.readonly,
            disabled = _ref.disabled;
          var onClick = reactExports.useCallback(function () {
            setConjunction(conjKey);
          }, [conjKey, setConjunction]);
          var postfix = setConjunction.isDummyFn ? "__dummy" : "";
          if ((readonly || disabled) && !checked) {
            return null;
          }
          return /*#__PURE__*/React.createElement(Button, {
            key: id + postfix,
            id: id + postfix,
            color: checked ? "primary" : "inherit",
            value: conjKey,
            onClick: onClick,
            disabled: readonly || disabled
          }, label);
        });
        var Conjs = /*#__PURE__*/React.memo(function (_ref2) {
          var id = _ref2.id,
            not = _ref2.not,
            setNot = _ref2.setNot,
            conjunctionOptions = _ref2.conjunctionOptions,
            setConjunction = _ref2.setConjunction,
            disabled = _ref2.disabled,
            readonly = _ref2.readonly,
            config = _ref2.config,
            showNot = _ref2.showNot,
            notLabel = _ref2.notLabel;
          //TIP: disabled=true if only 1 rule; readonly=true if immutable mode
          var conjsCount = Object.keys(conjunctionOptions).length;
          var lessThenTwo = disabled;
          var forceShowConj = config.settings.forceShowConj;
          var showConj = forceShowConj || conjsCount > 1 && !lessThenTwo;
          var renderOptions = function renderOptions() {
            return Object.keys(conjunctionOptions).map(function (conjKey) {
              var _conjunctionOptions$c = conjunctionOptions[conjKey],
                id = _conjunctionOptions$c.id,
                name = _conjunctionOptions$c.name,
                label = _conjunctionOptions$c.label,
                checked = _conjunctionOptions$c.checked;
              var conjProps = {
                conjKey: conjKey,
                id: id,
                name: name,
                label: label,
                checked: checked,
                setConjunction: setConjunction,
                readonly: readonly,
                disabled: disabled
              };
              return /*#__PURE__*/React.createElement(Conj, _extends$h({
                key: id
              }, conjProps));
            });
          };
          var onNotClick = reactExports.useCallback(function () {
            setNot(!not);
          }, [not, setNot]);
          var renderNot = function renderNot() {
            if (readonly && !not) return null;
            return /*#__PURE__*/React.createElement(Button, {
              key: id,
              id: id + "__not",
              color: not ? "error" : "inherit",
              onClick: onNotClick,
              disabled: readonly
            }, notLabel || "NOT");
          };
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(ButtonGroup, {
            disableElevation: true,
            variant: "contained",
            size: "small",
            disabled: readonly
          }, showNot && renderNot(), showConj && renderOptions()));
        });
        var LockOpen = {};
        var _interopRequireDefault$g = interopRequireDefaultExports;
        Object.defineProperty(LockOpen, "__esModule", {
          value: true
        });
        var default_1$8 = LockOpen.default = void 0;
        var _createSvgIcon$8 = _interopRequireDefault$g(requireCreateSvgIcon());
        var _jsxRuntime$8 = jsxRuntimeExports;
        default_1$8 = LockOpen.default = (0, _createSvgIcon$8.default)(/*#__PURE__*/(0, _jsxRuntime$8.jsx)("path", {
          d: "M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2m0 12H6V10h12z"
        }), 'LockOpen');
        var Lock = {};
        var _interopRequireDefault$f = interopRequireDefaultExports;
        Object.defineProperty(Lock, "__esModule", {
          value: true
        });
        var default_1$7 = Lock.default = void 0;
        var _createSvgIcon$7 = _interopRequireDefault$f(requireCreateSvgIcon());
        var _jsxRuntime$7 = jsxRuntimeExports;
        default_1$7 = Lock.default = (0, _createSvgIcon$7.default)(/*#__PURE__*/(0, _jsxRuntime$7.jsx)("path", {
          d: "M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2m-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2m3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1z"
        }), 'Lock');
        const MuiSwitch = function MuiSwitch(_ref) {
          var value = _ref.value,
            setValue = _ref.setValue,
            label = _ref.label,
            checkedLabel = _ref.checkedLabel,
            hideLabel = _ref.hideLabel,
            id = _ref.id,
            config = _ref.config,
            type = _ref.type;
          config.settings.renderSize;
          var onChange = function onChange(e) {
            return setValue(e.target.checked);
          };
          var onClick = function onClick() {
            return setValue(!value);
          };
          var postfix = type;
          var showLabel = value ? checkedLabel || label : label;
          var icon = value ? /*#__PURE__*/React.createElement(default_1$7, null) : /*#__PURE__*/React.createElement(default_1$8, null);
          if (type == "lock") {
            if (hideLabel) {
              return /*#__PURE__*/React.createElement(IconButton, {
                key: id + postfix,
                onClick: onClick,
                size: "small"
              }, icon);
            } else {
              return /*#__PURE__*/React.createElement(Button, {
                key: id + postfix,
                onClick: onClick,
                size: "small",
                startIcon: icon
              }, showLabel);
            }
          }
          return /*#__PURE__*/React.createElement(FormControlLabel, {
            control: /*#__PURE__*/React.createElement(Switch, {
              checked: !!value,
              size: "small",
              onChange: onChange
            }),
            label: showLabel
          });
        };
        var ExpandMoreSharp = {};
        var _interopRequireDefault$e = interopRequireDefaultExports;
        Object.defineProperty(ExpandMoreSharp, "__esModule", {
          value: true
        });
        var default_1$6 = ExpandMoreSharp.default = void 0;
        var _createSvgIcon$6 = _interopRequireDefault$e(requireCreateSvgIcon());
        var _jsxRuntime$6 = jsxRuntimeExports;
        default_1$6 = ExpandMoreSharp.default = (0, _createSvgIcon$6.default)(/*#__PURE__*/(0, _jsxRuntime$6.jsx)("path", {
          d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
        }), 'ExpandMoreSharp');
        var ValueSource = /*#__PURE__*/React.memo(function (_ref) {
          var valueSrc = _ref.valueSrc,
            srcKey = _ref.srcKey,
            handleChange = _ref.handleChange,
            info = _ref.info;
          var isSelected = valueSrc == srcKey || !valueSrc && srcKey == "value";
          var onClick = reactExports.useCallback(function (e) {
            return handleChange(e, srcKey);
          }, [handleChange, srcKey]);
          return /*#__PURE__*/React.createElement(MenuItem, {
            value: srcKey,
            selected: isSelected,
            onClick: onClick
          }, !isSelected && /*#__PURE__*/React.createElement(ListItemText, {
            inset: true
          }, info.label), isSelected && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ListItemIcon, null, /*#__PURE__*/React.createElement(default_1$a, null)), info.label));
        });
        var ValueSources = /*#__PURE__*/React.memo(function (_ref2) {
          var valueSources = _ref2.valueSources,
            valueSrc = _ref2.valueSrc,
            title = _ref2.title,
            setValueSrc = _ref2.setValueSrc;
          _ref2.readonly;
          var _React$useState = React.useState(null),
            _React$useState2 = _slicedToArray$1(_React$useState, 2),
            anchorEl = _React$useState2[0],
            setAnchorEl = _React$useState2[1];
          var handleOpen = reactExports.useCallback(function (event) {
            setAnchorEl(event.currentTarget);
          }, [setAnchorEl]);
          var handleClose = reactExports.useCallback(function () {
            setAnchorEl(null);
          }, [setAnchorEl]);
          var toggleOpenClose = reactExports.useCallback(function (event) {
            anchorEl ? handleClose() : handleOpen(event);
          }, [handleClose, handleOpen, anchorEl]);
          var handleChange = reactExports.useCallback(function (_e, srcKey) {
            setValueSrc(srcKey);
            handleClose();
          }, [handleClose, setValueSrc]);
          var renderOptions = function renderOptions(valueSources) {
            return valueSources.map(function (_ref3) {
              var _ref4 = _slicedToArray$1(_ref3, 2),
                srcKey = _ref4[0],
                info = _ref4[1];
              return /*#__PURE__*/React.createElement(ValueSource, {
                key: srcKey,
                valueSrc: valueSrc,
                srcKey: srcKey,
                handleChange: handleChange,
                info: info
              });
            });
          };
          var open = Boolean(anchorEl);
          return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(IconButton, {
            size: "small",
            onClick: toggleOpenClose
          }, /*#__PURE__*/React.createElement(default_1$6, null)), /*#__PURE__*/React.createElement(Menu, {
            anchorEl: anchorEl,
            open: open,
            onClose: handleClose
          }, /*#__PURE__*/React.createElement(FormControl, {
            component: "fieldset",
            sx: {
              p: 0
            }
          }, /*#__PURE__*/React.createElement(FormLabel, {
            component: "legend",
            sx: {
              p: 2,
              pt: 0,
              pb: 1
            }
          }, title), renderOptions(valueSources))));
        });
        const MuiConfirm = function MuiConfirm(_ref) {
          var onOk = _ref.onOk,
            okText = _ref.okText,
            cancelText = _ref.cancelText,
            title = _ref.title,
            confirmFn = _ref.confirmFn;
          confirmFn({
            description: title || "Are you sure?",
            title: null,
            confirmationText: okText || "Ok",
            cancellationText: cancelText || "Cancel"
          }).then(onOk)["catch"](function () {});
        };
        var _xdpPackage$version$s, _xdpPackage$version;
        var xdpVersion = parseInt((_xdpPackage$version$s = xdpPackage === null || xdpPackage === void 0 || (_xdpPackage$version = xdpPackage.version) === null || _xdpPackage$version === void 0 || (_xdpPackage$version = _xdpPackage$version.split(".")) === null || _xdpPackage$version === void 0 ? void 0 : _xdpPackage$version[0]) !== null && _xdpPackage$version$s !== void 0 ? _xdpPackage$version$s : "0");

        // provider
        var MuiProvider = function MuiProvider(_ref) {
          var config = _ref.config,
            children = _ref.children;
          var settingsTheme = config.settings.theme || {};
          var settingsLocale = config.settings.locale || {};
          var momentLocale = settingsLocale.moment;
          var themeConfig = settingsTheme.mui;
          var locale = settingsLocale.mui;
          var theme = createTheme(themeConfig, locale, {
            palette: {
              // neutral: {
              //   main: "#64748B",
              //   contrastText: "#fff"
              // },
            }
          });
          var locProviderProps = xdpVersion >= 6 ? {
            locale: momentLocale
          } : {
            adapterLocale: momentLocale
          };
          var base = /*#__PURE__*/React.createElement("div", {
            className: "mui"
          }, children);
          var withProviders = /*#__PURE__*/React.createElement(LocalizationProvider, _extends$h({
            dateAdapter: MomentUtils
          }, locProviderProps), /*#__PURE__*/React.createElement(ConfirmProvider, null, base));
          var withTheme = theme ? /*#__PURE__*/React.createElement(ThemeProvider, {
            theme: theme
          }, withProviders) : withProviders;
          return withTheme;
        };
        const MuiWidgets = {
          MuiTextWidget: MuiTextWidget,
          MuiTextAreaWidget: MuiTextAreaWidget,
          MuiDateWidget: MuiDateWidget,
          MuiDateTimeWidget: MuiDateTimeWidget,
          MuiTimeWidget: MuiTimeWidget,
          MuiSelectWidget: MuiSelectWidget,
          MuiNumberWidget: MuiNumberWidget,
          MuiSliderWidget: MuiSliderWidget,
          MuiRangeWidget: MuiRangeWidget,
          MuiBooleanWidget: MuiBooleanWidget,
          MuiMultiSelectWidget: MuiMultiSelectWidget,
          MuiAutocompleteWidget: MuiAutocompleteWidget,
          MuiFieldSelect: MuiFieldSelect,
          MuiFieldAutocomplete: MuiFieldAutocomplete,
          MuiIcon: MuiIcon,
          MuiButton: MuiButton,
          MuiButtonGroup: MuiButtonGroup,
          MuiConjs: Conjs,
          MuiSwitch: MuiSwitch,
          MuiValueSources: ValueSources,
          MuiConfirm: MuiConfirm,
          MuiUseConfirm: useConfirm,
          MuiProvider: MuiProvider
        };
        function ownKeys(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
              _defineProperty$4(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        var settings$1 = _objectSpread(_objectSpread({}, BasicConfig.settings), {}, {
          renderField: function renderField(props, _ref) {
            var _props$customProps;
            var RCE = _ref.RCE,
              _ref$W = _ref.W,
              MuiFieldAutocomplete = _ref$W.MuiFieldAutocomplete,
              MuiFieldSelect = _ref$W.MuiFieldSelect;
            return props !== null && props !== void 0 && (_props$customProps = props.customProps) !== null && _props$customProps !== void 0 && _props$customProps.showSearch ? RCE(MuiFieldAutocomplete, props) : RCE(MuiFieldSelect, props);
          },
          renderOperator: function renderOperator(props, _ref2) {
            var _props$customProps2;
            var RCE = _ref2.RCE,
              _ref2$W = _ref2.W,
              MuiFieldAutocomplete = _ref2$W.MuiFieldAutocomplete,
              MuiFieldSelect = _ref2$W.MuiFieldSelect;
            return props !== null && props !== void 0 && (_props$customProps2 = props.customProps) !== null && _props$customProps2 !== void 0 && _props$customProps2.showSearch ? RCE(MuiFieldAutocomplete, props) : RCE(MuiFieldSelect, props);
          },
          renderFunc: function renderFunc(props, _ref3) {
            var RCE = _ref3.RCE,
              MuiFieldSelect = _ref3.W.MuiFieldSelect;
            return RCE(MuiFieldSelect, props);
          },
          renderConjs: function renderConjs(props, _ref4) {
            var RCE = _ref4.RCE,
              MuiConjs = _ref4.W.MuiConjs;
            return RCE(MuiConjs, props);
          },
          renderSwitch: function renderSwitch(props, _ref5) {
            var RCE = _ref5.RCE,
              MuiSwitch = _ref5.W.MuiSwitch;
            return RCE(MuiSwitch, props);
          },
          renderButton: function renderButton(props, _ref6) {
            var RCE = _ref6.RCE,
              MuiButton = _ref6.W.MuiButton;
            return RCE(MuiButton, props);
          },
          renderIcon: function renderIcon(props, _ref7) {
            var RCE = _ref7.RCE,
              MuiIcon = _ref7.W.MuiIcon;
            return RCE(MuiIcon, props);
          },
          renderButtonGroup: function renderButtonGroup(props, _ref8) {
            var RCE = _ref8.RCE,
              MuiButtonGroup = _ref8.W.MuiButtonGroup;
            return RCE(MuiButtonGroup, props);
          },
          renderValueSources: function renderValueSources(props, _ref9) {
            var RCE = _ref9.RCE,
              MuiValueSources = _ref9.W.MuiValueSources;
            return RCE(MuiValueSources, props);
          },
          renderFieldSources: function renderFieldSources(props, _ref10) {
            var RCE = _ref10.RCE,
              MuiValueSources = _ref10.W.MuiValueSources;
            return RCE(MuiValueSources, props);
          },
          renderProvider: function renderProvider(props, _ref11) {
            var RCE = _ref11.RCE,
              MuiProvider = _ref11.W.MuiProvider;
            return RCE(MuiProvider, props);
          },
          renderConfirm: function renderConfirm(props, _ref12) {
            var MuiConfirm = _ref12.W.MuiConfirm;
            return MuiConfirm(props);
          },
          useConfirm: function useConfirm(_ref13) {
            var MuiUseConfirm = _ref13.W.MuiUseConfirm;
            return MuiUseConfirm();
          }
        });
        var widgets$1 = _objectSpread(_objectSpread({}, BasicConfig.widgets), {}, {
          text: _objectSpread(_objectSpread({}, BasicConfig.widgets.text), {}, {
            factory: function factory(props, _ref14) {
              var RCE = _ref14.RCE,
                MuiTextWidget = _ref14.W.MuiTextWidget;
              return RCE(MuiTextWidget, props);
            }
          }),
          textarea: _objectSpread(_objectSpread({}, BasicConfig.widgets.textarea), {}, {
            factory: function factory(props, _ref15) {
              var RCE = _ref15.RCE,
                MuiTextAreaWidget = _ref15.W.MuiTextAreaWidget;
              return RCE(MuiTextAreaWidget, props);
            }
          }),
          number: _objectSpread(_objectSpread({}, BasicConfig.widgets.number), {}, {
            factory: function factory(props, _ref16) {
              var RCE = _ref16.RCE,
                MuiNumberWidget = _ref16.W.MuiNumberWidget;
              return RCE(MuiNumberWidget, props);
            }
          }),
          multiselect: _objectSpread(_objectSpread({}, BasicConfig.widgets.multiselect), {}, {
            factory: function factory(props, _ref17) {
              var RCE = _ref17.RCE,
                _ref17$W = _ref17.W,
                MuiAutocompleteWidget = _ref17$W.MuiAutocompleteWidget,
                MuiMultiSelectWidget = _ref17$W.MuiMultiSelectWidget;
              return props.asyncFetch || props.showSearch ? RCE(MuiAutocompleteWidget, _objectSpread(_objectSpread({}, props), {}, {
                multiple: true
              })) : RCE(MuiMultiSelectWidget, props);
            }
          }),
          select: _objectSpread(_objectSpread({}, BasicConfig.widgets.select), {}, {
            factory: function factory(props, _ref18) {
              var RCE = _ref18.RCE,
                _ref18$W = _ref18.W,
                MuiAutocompleteWidget = _ref18$W.MuiAutocompleteWidget,
                MuiSelectWidget = _ref18$W.MuiSelectWidget;
              return props.asyncFetch || props.showSearch ? RCE(MuiAutocompleteWidget, props) : RCE(MuiSelectWidget, props);
            }
          }),
          slider: _objectSpread(_objectSpread({}, BasicConfig.widgets.slider), {}, {
            factory: function factory(props, _ref19) {
              var RCE = _ref19.RCE,
                MuiSliderWidget = _ref19.W.MuiSliderWidget;
              return RCE(MuiSliderWidget, props);
            }
          }),
          "boolean": _objectSpread(_objectSpread({}, BasicConfig.widgets["boolean"]), {}, {
            factory: function factory(props, _ref20) {
              var RCE = _ref20.RCE,
                MuiBooleanWidget = _ref20.W.MuiBooleanWidget;
              return RCE(MuiBooleanWidget, props);
            }
          }),
          date: _objectSpread(_objectSpread({}, BasicConfig.widgets.date), {}, {
            factory: function factory(props, _ref21) {
              var RCE = _ref21.RCE,
                MuiDateWidget = _ref21.W.MuiDateWidget;
              return RCE(MuiDateWidget, props);
            }
          }),
          time: _objectSpread(_objectSpread({}, BasicConfig.widgets.time), {}, {
            factory: function factory(props, _ref22) {
              var RCE = _ref22.RCE,
                MuiTimeWidget = _ref22.W.MuiTimeWidget;
              return RCE(MuiTimeWidget, props);
            }
          }),
          datetime: _objectSpread(_objectSpread({}, BasicConfig.widgets.datetime), {}, {
            factory: function factory(props, _ref23) {
              var RCE = _ref23.RCE,
                MuiDateTimeWidget = _ref23.W.MuiDateTimeWidget;
              return RCE(MuiDateTimeWidget, props);
            }
          }),
          rangeslider: _objectSpread(_objectSpread({}, BasicConfig.widgets.rangeslider), {}, {
            factory: function factory(props, _ref24) {
              var RCE = _ref24.RCE,
                MuiRangeWidget = _ref24.W.MuiRangeWidget;
              return RCE(MuiRangeWidget, props);
            }
          })
        });
        var types$1 = _objectSpread({}, BasicConfig.types);
        var ctx = _objectSpread(_objectSpread({}, BasicConfig.ctx), {}, {
          W: _objectSpread(_objectSpread({}, BasicConfig.ctx.W), MuiWidgets)
        });
        var config$1 = _objectSpread(_objectSpread({}, BasicConfig), {}, {
          ctx: ctx,
          types: types$1,
          widgets: widgets$1,
          settings: settings$1
        });
        config$1 = Utils.ConfigMixins.addMixins(config$1, ["rangeslider"]);
        const MuiConfig = config$1;
        const InitialConfig = MuiConfig;
        const wrapField = field => {
          return '<span class="logicField">' + field + "</span>";
        };
        const wrapOperator = op => {
          return '<span class="logicOp">' + op + "</span>";
        };
        const wrapValue = (value, valueTypes) => {
          return '<span class="logicValue">' + (valueTypes == "text" ? '"' + value + '"' : value) + "</span>";
        };
        const conjunctions = {
          AND: InitialConfig.conjunctions.AND,
          OR: InitialConfig.conjunctions.OR
        };
        const operators = _objectSpread3(_objectSpread3({}, InitialConfig.operators), {}, {
          less: _objectSpread3(_objectSpread3({}, InitialConfig.operators.less), {}, {
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              return `${wrapField(field)} ${wrapOperator("<")} ${wrapValue(value, valueTypes)}`;
            }
          }),
          less_or_equal: _objectSpread3(_objectSpread3({}, InitialConfig.operators.less_or_equal), {}, {
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              return `${wrapField(field)} ${wrapOperator("<=")} ${wrapValue(value, valueTypes)}`;
            }
          }),
          greater: _objectSpread3(_objectSpread3({}, InitialConfig.operators.greater), {}, {
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              return `${wrapField(field)} ${wrapOperator(">")} ${wrapValue(value, valueTypes)}`;
            }
          }),
          greater_or_equal: _objectSpread3(_objectSpread3({}, InitialConfig.operators.greater_or_equal), {}, {
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              return `${wrapField(field)} ${wrapOperator(">=")} ${wrapValue(value, valueTypes)}`;
            }
          }),
          equal: _objectSpread3(_objectSpread3({}, InitialConfig.operators.equal), {}, {
            label: "Equals",
            jsonLogic: "==",
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              const opStr = isForDisplay ? "equals" : opDef.label;
              return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(value, valueTypes)}`;
            }
          }),
          not_equal: _objectSpread3(_objectSpread3({}, InitialConfig.operators.not_equal), {}, {
            label: "Not Equals",
            jsonLogic: "!=",
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              const opStr = isForDisplay ? "not equals" : opDef.label;
              return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(value, valueTypes)}`;
            }
          }),
          starts_with: _objectSpread3(_objectSpread3({}, InitialConfig.operators.starts_with), {}, {
            jsonLogic: "startsWith",
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              const opStr = isForDisplay ? "starts with" : opDef.label;
              return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(value, valueTypes)}`;
            }
          }),
          ends_with: _objectSpread3(_objectSpread3({}, InitialConfig.operators.ends_with), {}, {
            jsonLogic: "endsWith",
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              const opStr = isForDisplay ? "ends with" : opDef.label;
              return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(value, valueTypes)}`;
            }
          }),
          between: _objectSpread3(_objectSpread3({}, InitialConfig.operators.between), {}, {
            label: "Between",
            jsonLogic: "between",
            formatOp: (field, op, values, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) => {
              let valFrom = values.first();
              let valTo = values.get(1);
              if (isForDisplay) return `${wrapField(field)} ${wrapOperator("between")} ${wrapValue(valFrom, valueTypes)} ${wrapOperator("and")} ${wrapValue(valTo, valueTypes)}`;else return `${field} >= ${valFrom} && ${field} <= ${valTo}`;
            }
          }),
          not_between: _objectSpread3(_objectSpread3({}, InitialConfig.operators.not_between), {}, {
            label: "Not Between",
            jsonLogic: "not_between",
            formatOp: (field, op, values, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) => {
              let valFrom = values.first();
              let valTo = values.get(1);
              if (isForDisplay) return `${wrapField(field)} ${wrapOperator("not between")} ${wrapValue(valFrom, valueTypes)} ${wrapOperator("and")} ${wrapValue(valTo, valueTypes)}`;else return `${field} >= ${valFrom} && ${field} <= ${valTo}`;
            }
          }),
          like: _objectSpread3(_objectSpread3({}, InitialConfig.operators.like), {}, {
            label: "Contains",
            jsonLogic: "contains",
            _jsonLogicIsRevArgs: false,
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              const opStr = isForDisplay ? "contains" : opDef.label;
              return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(value, valueTypes)}`;
            }
          }),
          not_like: _objectSpread3(_objectSpread3({}, InitialConfig.operators.not_like), {}, {
            label: "Not Contains",
            jsonLogic: "not_contains",
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              const opStr = isForDisplay ? "does not containends with" : opDef.label;
              return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(value, valueTypes)}`;
            }
          }),
          select_any_in: _objectSpread3(_objectSpread3({}, InitialConfig.operators.select_any_in), {}, {
            label: "Any In",
            jsonLogic: "in",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              let formattedValues = values.join(", ");
              return `${wrapField(field)} ${wrapOperator("in")} (${wrapValue(formattedValues, "")})`;
            }
          }),
          select_not_any_in: _objectSpread3(_objectSpread3({}, InitialConfig.operators.select_not_any_in), {}, {
            label: "None In",
            jsonLogic: "not_in",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              let formattedValues = values.join(", ");
              return `${wrapField(field)} ${wrapOperator("not in")} (${wrapValue(formattedValues, "")})`;
            }
          }),
          multiselect_equals: _objectSpread3(_objectSpread3({}, InitialConfig.operators.multiselect_equals), {}, {
            label: "Any In",
            jsonLogic: "any_in",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              let formattedValues = values.join(", ");
              return `${wrapOperator("Any of")} (${wrapValue(formattedValues, "")}) in ${wrapField(field)} ${wrapOperator("is selected")}`;
            }
          }),
          multiselect_not_equals: _objectSpread3(_objectSpread3({}, InitialConfig.operators.multiselect_not_equals), {}, {
            label: "None In",
            jsonLogic: "none_in",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              let formattedValues = values.join(", ");
              return `${wrapOperator("None of")} (${wrapValue(formattedValues, "")}) in ${wrapField(field)} ${wrapOperator("is selected")}`;
            }
          }),
          is_relevant: {
            label: "Is Displayed",
            jsonLogic: "relevance",
            cardinality: 0,
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is shown")}`;
            }
          },
          is_not_relevant: {
            label: "Is Hidden",
            jsonLogic: "not_relevance",
            cardinality: 0,
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is not shown")}`;
            }
          },
          is_valid: {
            label: "Is Valid",
            jsonLogic: "validity",
            cardinality: 0,
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is valid")}`;
            }
          },
          is_not_valid: {
            label: "Is Not Valid",
            jsonLogic: "not_validity",
            cardinality: 0,
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is not valid")}`;
            }
          },
          is_void: {
            cardinality: 0,
            label: "Is Empty",
            jsonLogic: "is_void",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is empty")}`;
            }
          },
          is_online: {
            cardinality: 0,
            label: "Is Online",
            jsonLogic: "is_online",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is online")}`;
            }
          },
          is_offline: {
            cardinality: 0,
            label: "Is Offline",
            jsonLogic: "is_offline",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is Offline")}`;
            }
          },
          is_not_void: {
            cardinality: 0,
            label: "Is not Empty",
            jsonLogic: "is_not_void",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is not empty")}`;
            }
          },
          is_file_void: {
            cardinality: 0,
            label: "Is Empty",
            jsonLogic: "is_file_void",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is empty")}`;
            }
          },
          is_file_not_void: {
            cardinality: 0,
            label: "Is not Empty",
            jsonLogic: "is_file_not_void",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is not empty")}`;
            }
          }
        });
        const widgets = _objectSpread3(_objectSpread3({}, InitialConfig.widgets), {}, {
          // examples of  overriding
          text: _objectSpread3({}, InitialConfig.widgets.text),
          slider: _objectSpread3(_objectSpread3({}, InitialConfig.widgets.slider), {}, {
            customProps: {
              width: "300px"
            }
          }),
          rangeslider: _objectSpread3(_objectSpread3({}, InitialConfig.widgets.rangeslider), {}, {
            customProps: {
              width: "300px"
            }
          }),
          date: _objectSpread3(_objectSpread3({}, InitialConfig.widgets.date), {}, {
            dateFormat: "DD.MM.YYYY",
            valueFormat: "YYYY-MM-DD"
          }),
          time: _objectSpread3(_objectSpread3({}, InitialConfig.widgets.time), {}, {
            timeFormat: "HH:mm",
            valueFormat: "HH:mm:ss"
          }),
          datetime: _objectSpread3(_objectSpread3({}, InitialConfig.widgets.datetime), {}, {
            timeFormat: "HH:mm",
            dateFormat: "DD.MM.YYYY",
            valueFormat: "YYYY-MM-DD HH:mm:ss"
          }),
          func: _objectSpread3(_objectSpread3({}, InitialConfig.widgets.func), {}, {
            customProps: {
              showSearch: true
            }
          }),
          treeselect: _objectSpread3(_objectSpread3({}, InitialConfig.widgets.treeselect), {}, {
            customProps: {
              showSearch: true
            }
          })
        });
        const types = _objectSpread3(_objectSpread3({}, InitialConfig.types), {}, {
          boolean: merge$5(InitialConfig.types.boolean, {
            widgets: {
              boolean: {
                widgetProps: {
                  hideOperator: true,
                  operatorInlineLabel: "is"
                }
              }
            }
          })
        });
        const localeSettings = {
          valueLabel: "Value",
          valuePlaceholder: "Value",
          fieldLabel: "Field",
          operatorLabel: "Operator",
          fieldPlaceholder: "Select field",
          operatorPlaceholder: "Select operator",
          deleteLabel: null,
          addGroupLabel: "Add group",
          addRuleLabel: "Add rule",
          addSubRuleLabel: "Add sub rule",
          delGroupLabel: null,
          notLabel: "Not",
          valueSourcesPopupTitle: "Select value source",
          removeRuleConfirmOptions: {
            title: "Are you sure delete this rule?",
            okText: "Yes",
            okType: "danger"
          },
          removeGroupConfirmOptions: {
            title: "Are you sure delete this group?",
            okText: "Yes",
            okType: "danger"
          }
        };
        const settings = _objectSpread3(_objectSpread3(_objectSpread3({}, InitialConfig.settings), localeSettings), {}, {
          valueSourcesInfo: {
            value: {
              label: "Value"
            },
            field: {
              label: "Field",
              widget: "field"
            },
            func: {
              label: "Function",
              widget: "func"
            }
          },
          canReorder: false,
          showNot: false,
          maxNesting: 1,
          canLeaveEmptyGroup: false
          //after deletion
        });
        const funcs = {};
        const config = {
          ctx: MuiConfig.ctx,
          conjunctions,
          operators,
          widgets,
          types,
          settings,
          funcs
        };
        function LogicBuilder(props) {
          const jsonLogicFormat = Utils.jsonLogicFormat,
            queryString = Utils.queryString,
            loadTree = Utils.loadTree,
            uuid = Utils.uuid,
            loadFromJsonLogic = Utils.loadFromJsonLogic,
            checkTree = Utils.checkTree;
          const config$1 = _objectSpread3(_objectSpread3({}, config), {}, {
            fields: props.fields
          });
          const initTree = props.logic ? checkTree(loadFromJsonLogic(props.logic, config$1), config$1) : loadTree({
            id: uuid(),
            type: "group"
          });
          const _reactExports$useStat57 = reactExports.useState(initTree),
            _reactExports$useStat58 = _slicedToArray2(_reactExports$useStat57, 2),
            tree = _reactExports$useStat58[0],
            setTree = _reactExports$useStat58[1];
          const _reactExports$useStat59 = reactExports.useState(queryString(tree, config$1, true)),
            _reactExports$useStat60 = _slicedToArray2(_reactExports$useStat59, 2),
            html = _reactExports$useStat60[0],
            setHtml = _reactExports$useStat60[1];
          const renderBuilder = props2 => /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            jey: "builder",
            className: "query-builder-container",
            children: /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: "query-builder",
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Builder$1, _objectSpread3({}, props2))
            })
          });
          const onChange = immutableTree => {
            setTree(immutableTree);
          };
          const saveState = () => {
            const _jsonLogicFormat = jsonLogicFormat(tree, config$1),
              logic = _jsonLogicFormat.logic,
              errors = _jsonLogicFormat.errors;
            setHtml(queryString(tree, config$1, true));
            props.onChange(logic);
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: "query-builder-result",
              children: [props.logic && html ? /* @__PURE__ */jsxRuntimeExports.jsx("pre", {
                className: "condition-human-text",
                children: truncateWithEllipsis(stripTags(html), 50)
              }) : /* @__PURE__ */jsxRuntimeExports.jsx("pre", {
                className: "condition-human-text",
                children: props.t("no_condition")
              }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: "icon-container",
                children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  onClick: () => props.onDialogStateChanged(true),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(EditOutlined, {})
                })
              })]
            }, "result"), /* @__PURE__ */jsxRuntimeExports.jsxs(Dialog, {
              fullScreen: true,
              sx: {
                margin: "200px"
              },
              open: props.dialogOpen,
              onClose: () => props.onDialogStateChanged(false),
              "aria-labelledby": "alert-dialog-title-logic-builder",
              "aria-describedby": "alert-dialog-description",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(DialogTitle, {
                id: "alert-dialog-title-logic-builder",
                children: props.title
              }), /* @__PURE__ */jsxRuntimeExports.jsx(DialogContent, {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(QueryContainer, _objectSpread3(_objectSpread3({}, config$1), {}, {
                  value: tree,
                  onChange,
                  renderBuilder
                }))
              }), /* @__PURE__ */jsxRuntimeExports.jsx(DialogActions, {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  onClick: () => {
                    props.onDialogStateChanged(false);
                    saveState();
                  },
                  autoFocus: true,
                  variant: "contained",
                  children: "Agree"
                })
              })]
            })]
          });
        }
        const buildFields = (componentIndices, code, state, mainLang, langList) => {
          let dependencies = accessibleDependencies(componentIndices, code);
          let returnResult = {
            mode: {
              label: "Mode",
              type: "text",
              valueSources: ["value"],
              operators: ["is_offline", "is_online"]
            },
            survey_lang: {
              label: "Language",
              type: "select",
              valueSources: ["value"],
              operators: ["select_any_in", "select_not_any_in"],
              fieldSettings: {
                listValues: langList
              }
            }
          };
          dependencies.forEach(el => {
            if (state[el] && (isQuestion(el) || isGroup(el))) {
              returnResult = _objectSpread3(_objectSpread3({}, returnResult), buildField$1(el, state[el], state, mainLang));
            }
          });
          return returnResult;
        };
        const buildField$1 = (code, component, state, mainLang) => {
          var _component$content2, _component$children, _component$children2, _state$scqOther$quali, _component$children3, _component$children4, _state$mcqOther$quali, _component$children5, _component$children6, _component$children7, _component$children8;
          const label = code + ". " + stripTags(((_component$content2 = component.content) === null || _component$content2 === void 0 || (_component$content2 = _component$content2.label) === null || _component$content2 === void 0 ? void 0 : _component$content2[mainLang]) || "");
          if (isGroup(code)) {
            return {
              [code]: {
                label,
                type: "text",
                valueSources: ["value"],
                operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid"]
              }
            };
          }
          switch (component.type) {
            case "text":
            case "barcode":
            case "email":
              return {
                [code]: {
                  label,
                  type: "text",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "equal", "not_equal", "like", "not_like", "starts_with", "ends_with"]
                }
              };
            case "paragraph":
              return {
                [code]: {
                  label,
                  type: "text",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "like", "not_like", "starts_with", "ends_with"]
                }
              };
            case "number":
              return {
                [code]: {
                  label,
                  type: "number",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between"]
                }
              };
            case "file_upload":
              return {
                [code]: {
                  label,
                  type: "text",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_file_void", "is_file_not_void"]
                }
              };
            case "signature":
            case "photo_capture":
            case "video_capture":
              return {
                [code]: {
                  label,
                  type: "text",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_file_void", "is_file_not_void"]
                }
              };
            case "date":
              return {
                [code]: {
                  label,
                  type: "date",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "greater_or_equal", "less_or_equal", "between"]
                }
              };
            case "time":
              return {
                [code]: {
                  label,
                  type: "time",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "greater_or_equal", "less_or_equal", "between"]
                }
              };
            case "date_time":
              return {
                [code]: {
                  label,
                  type: "datetime",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "greater_or_equal", "less_or_equal", "between"]
                }
              };
            case "image_scq":
            case "icon_scq":
            case "scq":
              let scqReturnList = {};
              let scqListValues = {};
              (_component$children = component.children) === null || _component$children === void 0 || _component$children.forEach(element => {
                var _state$element$qualif2;
                const label2 = stripTags(((_state$element$qualif2 = state[element.qualifiedCode].content) === null || _state$element$qualif2 === void 0 || (_state$element$qualif2 = _state$element$qualif2.label) === null || _state$element$qualif2 === void 0 ? void 0 : _state$element$qualif2[mainLang]) || "");
                scqListValues[element.code] = label2 ? element.code + " - " + label2 : element.code;
              });
              scqReturnList[code] = {
                label,
                fieldSettings: {
                  listValues: scqListValues
                },
                type: "select",
                valueSources: ["value"],
                operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "select_any_in", "select_not_any_in"]
              };
              let scqOther = (_component$children2 = component.children) === null || _component$children2 === void 0 ? void 0 : _component$children2.find(el => el.code === "Aother");
              if (scqOther && (_state$scqOther$quali = state[scqOther.qualifiedCode].children) !== null && _state$scqOther$quali !== void 0 && _state$scqOther$quali.find(el => el.code === "Atext")) {
                var _state$scqOther$quali2;
                scqReturnList[code + "AotherAtext"] = {
                  label: `${label} [${((_state$scqOther$quali2 = state[scqOther.qualifiedCode].content) === null || _state$scqOther$quali2 === void 0 || (_state$scqOther$quali2 = _state$scqOther$quali2.label) === null || _state$scqOther$quali2 === void 0 ? void 0 : _state$scqOther$quali2[mainLang]) || ""}]`,
                  type: "text",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "equal", "not_equal", "like", "not_like", "starts_with", "ends_with"]
                };
              }
              return scqReturnList;
            case "image_mcq":
            case "icon_mcq":
            case "mcq":
              let mcqReturnList = {};
              let mcqListValues = {};
              (_component$children3 = component.children) === null || _component$children3 === void 0 || _component$children3.forEach(element => {
                var _state$element$qualif3;
                const label2 = stripTags(((_state$element$qualif3 = state[element.qualifiedCode].content) === null || _state$element$qualif3 === void 0 || (_state$element$qualif3 = _state$element$qualif3.label) === null || _state$element$qualif3 === void 0 ? void 0 : _state$element$qualif3[mainLang]) || "");
                mcqListValues[element.code] = label2 ? element.code + " - " + label2 : element.code;
              });
              mcqReturnList[code] = {
                label,
                fieldSettings: {
                  listValues: mcqListValues
                },
                type: "multiselect",
                valueSources: ["value"],
                operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "multiselect_equals", "multiselect_not_equals"]
              };
              let mcqOther = (_component$children4 = component.children) === null || _component$children4 === void 0 ? void 0 : _component$children4.find(el => el.code === "Aother");
              if (mcqOther && (_state$mcqOther$quali = state[mcqOther.qualifiedCode].children) !== null && _state$mcqOther$quali !== void 0 && _state$mcqOther$quali.find(el => el.code === "Atext")) {
                var _state$mcqOther$quali2;
                mcqReturnList[code + "AotherAtext"] = {
                  label: `${label} [${((_state$mcqOther$quali2 = state[mcqOther.qualifiedCode].content) === null || _state$mcqOther$quali2 === void 0 || (_state$mcqOther$quali2 = _state$mcqOther$quali2.label) === null || _state$mcqOther$quali2 === void 0 ? void 0 : _state$mcqOther$quali2[mainLang]) || ""}]`,
                  type: "text",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "equal", "not_equal", "like", "not_like", "starts_with", "ends_with"]
                };
              }
              return mcqReturnList;
            case "nps":
              let npsReturnList = {};
              (_component$children5 = component.children) === null || _component$children5 === void 0 || _component$children5.forEach(element => {
                var _state$element$qualif4;
                const label2 = stripTags(((_state$element$qualif4 = state[element.qualifiedCode].content) === null || _state$element$qualif4 === void 0 || (_state$element$qualif4 = _state$element$qualif4.label) === null || _state$element$qualif4 === void 0 ? void 0 : _state$element$qualif4[mainLang]) || "");
                mcqListValues[element.code] = label2 ? element.code + " - " + label2 : element.code;
              });
              npsReturnList[code] = {
                label,
                fieldSettings: {
                  min: 0,
                  max: 10
                },
                type: "number",
                valueSources: ["value"],
                operators: ["is_void", "is_not_void", "equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between"]
              };
              return npsReturnList;
            case "scq_icon_array":
            case "scq_array":
              let scqArrayReturnList = {};
              let scqArrayListValues = {};
              (_component$children6 = component.children) === null || _component$children6 === void 0 || _component$children6.filter(el => el.type == "column").forEach(element => {
                var _state$element$qualif5;
                const label2 = stripTags(((_state$element$qualif5 = state[element.qualifiedCode].content) === null || _state$element$qualif5 === void 0 || (_state$element$qualif5 = _state$element$qualif5.label) === null || _state$element$qualif5 === void 0 ? void 0 : _state$element$qualif5[mainLang]) || "");
                scqArrayListValues[element.code] = label2 ? element.code + " - " + label2 : element.code;
              });
              scqArrayReturnList[code] = {
                label,
                type: "text",
                valueSources: ["value"],
                operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid"]
              };
              (_component$children7 = component.children) === null || _component$children7 === void 0 || _component$children7.filter(el => el.type == "row").forEach(element => {
                var _state$element$qualif6;
                scqArrayReturnList[code + element.code] = {
                  label: label + " - " + stripTags(((_state$element$qualif6 = state[element.qualifiedCode].content) === null || _state$element$qualif6 === void 0 || (_state$element$qualif6 = _state$element$qualif6.label) === null || _state$element$qualif6 === void 0 ? void 0 : _state$element$qualif6[mainLang]) || ""),
                  type: "select",
                  valueSources: ["value"],
                  fieldSettings: {
                    listValues: scqArrayListValues
                  },
                  operators: ["select_any_in", "select_not_any_in"]
                };
              });
              return scqArrayReturnList;
            case "ranking":
            case "image_ranking":
              let rankingReturnList = {};
              (_component$children8 = component.children) === null || _component$children8 === void 0 || _component$children8.forEach(element => {
                var _state$element$qualif7;
                rankingReturnList[code + element.code] = {
                  label: label + " - " + stripTags(((_state$element$qualif7 = state[element.qualifiedCode].content) === null || _state$element$qualif7 === void 0 || (_state$element$qualif7 = _state$element$qualif7.label) === null || _state$element$qualif7 === void 0 ? void 0 : _state$element$qualif7[mainLang]) || ""),
                  type: "number",
                  fieldSettings: {
                    min: 1,
                    max: component.children.length
                  },
                  valueSources: ["value"],
                  operators: ["is_void", "is_not_void", "equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between"]
                };
              });
              return rankingReturnList;
            default:
              return [];
          }
        };
        const relevance = "_relevance_1j5a5_1";
        const relevanceError = "_relevanceError_1j5a5_5";
        const errorContainer = "_errorContainer_1j5a5_9";
        const styles$b = {
          relevance: relevance,
          relevanceError: relevanceError,
          errorContainer: errorContainer
        };
        function Relevance({
          code,
          t
        }) {
          var _state$instructionLis, _state$relevance, _state$relevance2;
          const dispatch = useDispatch();
          const _reactExports$useStat61 = reactExports.useState(false),
            _reactExports$useStat62 = _slicedToArray2(_reactExports$useStat61, 2),
            logicDialogOpen = _reactExports$useStat62[0],
            setLogicDialogOpen = _reactExports$useStat62[1];
          const designState = useSelector(state2 => {
            return state2.designState;
          });
          const langInfo = React.useMemo(() => designState.langInfo);
          const state = React.useMemo(() => designState[code]);
          const fields = React.useMemo(() => buildFields(designState.componentIndex, code, designState, langInfo.mainLang, langInfo.languagesList.map(lang => lang.code)), [designState]);
          const instruction = (_state$instructionLis = state.instructionList) === null || _state$instructionLis === void 0 ? void 0 : _state$instructionLis.find(instruction2 => instruction2.code == "conditional_relevance");
          const errors = (instruction === null || instruction === void 0 ? void 0 : instruction.errors) || [];
          const hasErrors = errors.length > 0;
          const logic = (_state$relevance = state.relevance) === null || _state$relevance === void 0 ? void 0 : _state$relevance.logic;
          const logicDisabled = !hasErrors && Object.keys(fields).length > 0;
          const _reactExports$useStat63 = reactExports.useState(((_state$relevance2 = state.relevance) === null || _state$relevance2 === void 0 ? void 0 : _state$relevance2.rule) || "show_always"),
            _reactExports$useStat64 = _slicedToArray2(_reactExports$useStat63, 2),
            rule = _reactExports$useStat64[0],
            setRule = _reactExports$useStat64[1];
          const shouldHaveLogic = rule == "show_if" || rule == "hide_if";
          const onRuleChange = rule2 => {
            setRule(rule2);
            switch (rule2) {
              case "show_always":
                reset();
                return;
              case "hide_always":
                dispatch(changeRelevance({
                  code,
                  key: "relevance",
                  value: {
                    logic: void 0,
                    rule: rule2
                  }
                }));
                return;
              case "show_if":
              case "hide_if":
                if ((logic === null || logic === void 0 ? void 0 : logic.rule) != "show_if" && (logic === null || logic === void 0 ? void 0 : logic.rule) != "hide_if") {
                  setLogicDialogOpen(true);
                }
                if (logic) {
                  dispatch(changeRelevance({
                    code,
                    key: "relevance",
                    value: {
                      logic,
                      rule: rule2
                    }
                  }));
                }
                return;
            }
          };
          const reset = () => dispatch(changeRelevance({
            code,
            key: "relevance",
            value: {
              logic: void 0,
              rule: "show_always"
            }
          }));
          const onLogicChange = logic2 => {
            setLogicDialogOpen(false);
            if (shouldHaveLogic) {
              dispatch(changeRelevance({
                code,
                key: "relevance",
                value: {
                  logic: logic2,
                  rule
                }
              }));
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: `${hasErrors ? styles$b.relevanceError : ""}`,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormControl, {
              variant: "standard",
              fullWidth: true,
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(Select, {
                id: "show-hide-select",
                value: rule,
                label: "Age",
                onChange: e => onRuleChange(e.target.value),
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                  disabled: hasErrors,
                  value: "show_always",
                  children: t("show_always")
                }, "show_always"), /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                  disabled: !logicDisabled,
                  value: "show_if",
                  children: t("show_if")
                }, "show_if"), /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                  disabled: !logicDisabled,
                  value: "hide_if",
                  children: t("hide_if")
                }, "hide_if"), /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                  disabled: hasErrors,
                  value: "hide_always",
                  children: t("hide_always")
                }, "hide_always")]
              })
            }), !hasErrors && shouldHaveLogic && /* @__PURE__ */jsxRuntimeExports.jsx(LogicBuilder, {
              title: rule == "show_if" ? t("condition_to_show") : t("condition_to_hide"),
              onChange: onLogicChange,
              onDialogStateChanged: state2 => setLogicDialogOpen(state2),
              fields,
              t,
              dialogOpen: logicDialogOpen,
              logic
            }), hasErrors ? /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$b.errorContainer,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
                t,
                i18nKey: "wrong_logic_err"
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                variant: "contained",
                onClick: () => reset(),
                children: "OK"
              })]
            }) : "", shouldHaveLogic && !logic ? /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
                t,
                i18nKey: "no_logic_err"
              })
            }) : ""]
          });
        }
        const buildField = (code, state, mainLang) => {
          var _component$content3;
          const component = state[code];
          const label = code + ". " + stripTags((_component$content3 = component.content) === null || _component$content3 === void 0 || (_component$content3 = _component$content3.label) === null || _component$content3 === void 0 ? void 0 : _component$content3[mainLang]);
          return {
            code: code,
            label: label
          };
        };
        const jumpDestinations = (componentIndices, code, state, mainLang) => {
          let dependencies = [];
          if (!componentIndices) {
            return dependencies;
          }
          let componentIndex = componentIndices.find(element => element.code === code);
          if (!componentIndex) {
            return dependencies;
          }
          dependencies = dependencies.concat(accessibleSiblings(componentIndices, componentIndex, state, mainLang));
          if (componentIndex.parent) {
            parents(componentIndices, componentIndex).filter(elem => isQuestion(elem.code) || isGroup(elem.code)).forEach(element => {
              dependencies = dependencies.concat(accessibleSiblings(componentIndices, element, state, mainLang));
            });
          }
          return dependencies;
        };
        const parents = (componentIndices, componentIndex) => {
          let result = [];
          let parent = componentIndices.find(element => element.code === componentIndex.parent);
          if (parent && parent.parent) {
            result.push(parent);
            result = result.concat(parents(componentIndices, parent));
          }
          return result;
        };
        const accessibleSiblings = (componentIndices, componentIndex, state, mainLang) => {
          let result = [];
          if (!isGroup(componentIndex.code) && !isQuestion(componentIndex.code)) {
            return result;
          }
          let accessibleSiblings = componentIndices.filter(elem => {
            return elem.parent == componentIndex.parent && elem.minIndex > componentIndex.maxIndex && (!componentIndex.prioritisedSiblings || componentIndex.prioritisedSiblings.indexOf(elem.code) === -1);
          });
          accessibleSiblings.forEach(sibling => {
            result = result.concat(buildField(sibling.code, state, mainLang));
            result = result.concat(childrenDependencies(componentIndices, sibling, state, mainLang));
          });
          return result;
        };
        const childrenDependencies = (componentIndices, componentIndex, state, mainLang) => {
          let result = [];
          if (!isGroup(componentIndex.code)) {
            return result;
          }
          if (componentIndex.children) {
            componentIndex.children.forEach(childCode => {
              let child = componentIndices.find(element => element.code === childCode);
              result = result.concat(buildField(child.code, state, mainLang));
              result = result.concat(childrenDependencies(componentIndices, child, state, mainLang));
            });
          }
          return result;
        };
        const skipItem = "_skipItem_1n8m2_1";
        const toEnd = "_toEnd_1n8m2_6";
        const styles$a = {
          skipItem: skipItem,
          toEnd: toEnd
        };
        function SkipLogic({
          code,
          t
        }) {
          const dispatch = useDispatch();
          const skipLogic = useSelector(state => {
            return state.designState[code].skip_logic || {};
          });
          const destinations = useSelector(state => {
            const mainLang = state.designState.langInfo.mainLang;
            return jumpDestinations(state.designState.componentIndex, code, state.designState, mainLang);
          });
          const instructions = useSelector(state => {
            return state.designState[code].instructionList.filter(el => el.code.startsWith("skip_to"));
          });
          const children = useSelector(state => {
            var _state$designState$co14;
            const lang = state.designState.langInfo.lang;
            return (_state$designState$co14 = state.designState[code]) === null || _state$designState$co14 === void 0 || (_state$designState$co14 = _state$designState$co14.children) === null || _state$designState$co14 === void 0 ? void 0 : _state$designState$co14.map(child => {
              var _state$designState$ch;
              return {
                code: child.code,
                label: ((_state$designState$ch = state.designState[child.qualifiedCode].content) === null || _state$designState$ch === void 0 || (_state$designState$ch = _state$designState$ch.label) === null || _state$designState$ch === void 0 ? void 0 : _state$designState$ch[lang]) || child.code
              };
            });
          });
          const onChange = (answerCode, targetCode) => {
            if (targetCode == "proceed") {
              dispatch(removeSkipDestination({
                code,
                answerCode
              }));
            } else {
              dispatch(editSkipDestination({
                code,
                answerCode,
                skipTo: targetCode
              }));
            }
          };
          const onToEndChanged = (answerCode, checked) => {
            dispatch(editSkipToEnd({
              code,
              answerCode,
              toEnd: checked
            }));
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: children === null || children === void 0 ? void 0 : children.map(element => {
              var _instructions$find;
              const code2 = element.code;
              const original = skipLogic === null || skipLogic === void 0 ? void 0 : skipLogic[code2];
              const skipTo = original === null || original === void 0 ? void 0 : original.skipTo;
              const skipToCode = skipTo || "proceed";
              const invalidSkipDestination = skipTo && (instructions === null || instructions === void 0 || (_instructions$find = instructions.find(el => el.code == "skip_to_on_" + code2)) === null || _instructions$find === void 0 || (_instructions$find = _instructions$find.errors) === null || _instructions$find === void 0 ? void 0 : _instructions$find.find(el => el.name == "InvalidSkipReference"));
              return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                className: styles$a.skipItem,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
                  t,
                  values: {
                    code: element.label
                  },
                  i18nKey: "if_answer_is"
                }), invalidSkipDestination ? skipValueError(code2, skipTo, onChange, t) : skipSelectValue(code2, destinations, skipToCode, original === null || original === void 0 ? void 0 : original.toEnd, onChange, onToEndChanged, t)]
              }, element.code);
            })
          });
        }
        function skipValueError(answerCode, skipToCode, onChange, t) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            className: styles$a.errorDisplay,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(ErrorOutlineOutlined, {
              style: {
                verticalAlign: "middle"
              }
            }), " ", /* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
              t,
              values: {
                code: skipToCode
              },
              i18nKey: "invalid_skip_destination_err"
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
              variant: "contained",
              onClick: () => onChange(answerCode, "proceed"),
              children: t("ok")
            })]
          });
        }
        function skipSelectValue(answerCode, destinations, skipToCode, toEnd, _onChange3, onToEndChanged, t) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormControl, {
              variant: "standard",
              fullWidth: true,
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(Select, {
                id: "skip-action",
                value: skipToCode,
                label: t("skip_to"),
                onChange: e => _onChange3(answerCode, e.target.value),
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                  value: "proceed",
                  children: t("proceed_as_usual")
                }, "proceed"), destinations && (destinations === null || destinations === void 0 ? void 0 : destinations.map(element => {
                  return /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                    value: element.code,
                    children: element.label
                  }, element.code);
                }))]
              })
            }), skipToCode && skipToCode.startsWith("G") && /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$a.toEnd,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
                children: t("to_group_end")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Switch, {
                checked: toEnd || false,
                onChange: event => onToEndChanged(answerCode, event.target.checked)
              })]
            })]
          });
        }
        const sectionTitle = "_sectionTitle_nmfqz_1";
        const rightContent = "_rightContent_nmfqz_6";
        const close = "_close_nmfqz_13";
        const accordionStyle = "_accordionStyle_nmfqz_17";
        const styles$9 = {
          sectionTitle: sectionTitle,
          rightContent: rightContent,
          close: close,
          accordionStyle: accordionStyle
        };
        const errorDisplay$1 = "_errorDisplay_1avr2_1";
        const styles$8 = {
          errorDisplay: errorDisplay$1
        };
        function RandomError({
          errors
        }) {
          const _useTranslation5 = useTranslation("design"),
            t = _useTranslation5.t;
          return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
            className: styles$8.errorDisplay,
            children: errors.map(error => {
              if (error.name == "PriorityGroupItemNotChild") {
                return /* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
                  t,
                  i18nKey: "err_priority_group_item_not_child",
                  values: {
                    items: error.items.join(", ")
                  }
                }, error.name);
              } else if (error.name == "DuplicatePriorityGroupItems") {
                return /* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
                  t,
                  i18nKey: "err_duplicate_priority_group_items",
                  values: {
                    items: error.items.join(", ")
                  }
                }, error.name);
              } else if (error.name == "PriorityLimitMismatch") {
                return t("err_priority_limit_mismatch");
              } else if (error.name == "RandomGroupItemNotChild") {
                return /* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
                  t,
                  i18nKey: "err_random_group_item_not_child",
                  values: {
                    items: error.items.join(", ")
                  }
                }, error.name);
              } else if (error.name == "DuplicateRandomGroupItems") {
                return /* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
                  t,
                  i18nKey: "err_duplicate_random_group_items",
                  values: {
                    items: error.items.join(", ")
                  }
                }, error.name);
              }
            })
          }, "box");
        }
        const randomHeader$1 = "_randomHeader_1pjix_1";
        const title$3 = "_title_1pjix_6";
        const action$1 = "_action_1pjix_11";
        const settingIcon$1 = "_settingIcon_1pjix_15";
        const randomBody$1 = "_randomBody_1pjix_19";
        const list$3 = "_list_1pjix_19";
        const weight$1 = "_weight_1pjix_30";
        const randomAction$3 = "_randomAction_1pjix_47";
        const listItem$3 = "_listItem_1pjix_53";
        const label$2 = "_label_1pjix_58";
        const input$3 = "_input_1pjix_64";
        const listItemError$1 = "_listItemError_1pjix_68";
        const randomItem$3 = "_randomItem_1pjix_84";
        const highlighted$1 = "_highlighted_1pjix_89";
        const styles$7 = {
          randomHeader: randomHeader$1,
          title: title$3,
          action: action$1,
          settingIcon: settingIcon$1,
          randomBody: randomBody$1,
          list: list$3,
          weight: weight$1,
          randomAction: randomAction$3,
          listItem: listItem$3,
          label: label$2,
          input: input$3,
          listItemError: listItemError$1,
          randomItem: randomItem$3,
          highlighted: highlighted$1
        };
        var Mode = {};
        var _interopRequireDefault$d = interopRequireDefaultExports;
        Object.defineProperty(Mode, "__esModule", {
          value: true
        });
        var default_1$5 = Mode.default = void 0;
        var _createSvgIcon$5 = _interopRequireDefault$d(requireCreateSvgIcon());
        var _jsxRuntime$5 = jsxRuntimeExports;
        default_1$5 = Mode.default = (0, _createSvgIcon$5.default)(/*#__PURE__*/(0, _jsxRuntime$5.jsx)("path", {
          d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 5.63l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83c.39-.39.39-1.02 0-1.41"
        }), 'Mode');
        function PriorityItemDisplay(props) {
          var _props$data$weights;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Card, {
            className: `${styles$7.randomItem} ${props.isBeingEdited ? styles$7.highlighted : ""}`,
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$7.randomHeader,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
                className: styles$7.title,
                children: props.t("prioritise")
              }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                className: styles$7.action,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  onClick: () => props.onEditClicked(props.index),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$5, {
                    className: styles$7.settingIcon
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  onClick: () => props.onDeleteClicked(props.index),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$q, {
                    className: styles$7.settingIcon
                  })
                })]
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$7.randomBody,
              children: [props.t("priority_show_limit_from_count", {
                limit: props.data.limit,
                count: (_props$data$weights = props.data.weights) === null || _props$data$weights === void 0 ? void 0 : _props$data$weights.length
              }), /* @__PURE__ */jsxRuntimeExports.jsx("ul", {
                className: styles$7.list,
                children: props.data && props.data.weights && props.data.weights.map((nestedItem, index) => {
                  return /* @__PURE__ */jsxRuntimeExports.jsx(PrioritisedChildDisplay$1, {
                    label: props.getChildLabelByCode(nestedItem.code),
                    code: nestedItem.code,
                    childrenCodes: props.childrenCodes,
                    weight: nestedItem.weight
                  }, index);
                })
              })]
            })]
          });
        }
        function PrioritisedChildDisplay$1({
          code,
          label,
          weight,
          childrenCodes
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs("li", {
            className: childrenCodes.indexOf(code) !== -1 ? styles$7.listItem : styles$7.listItemError,
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: `${styles$7.content} ${styles$7.label}`,
              children: [code, ": ", label]
            }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$7.weight,
              children: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                children: weight
              })
            })]
          });
        }
        const title$2 = "_title_5cg20_1";
        const randomBody = "_randomBody_5cg20_6";
        const list$2 = "_list_5cg20_6";
        const weight = "_weight_5cg20_18";
        const label$1 = "_label_5cg20_35";
        const randomAction$2 = "_randomAction_5cg20_39";
        const listItem$2 = "_listItem_5cg20_45";
        const input$2 = "_input_5cg20_50";
        const randomItem$2 = "_randomItem_5cg20_54";
        const styles$6 = {
          title: title$2,
          randomBody: randomBody,
          list: list$2,
          weight: weight,
          label: label$1,
          randomAction: randomAction$2,
          listItem: listItem$2,
          input: input$2,
          randomItem: randomItem$2
        };
        var RemoveCircle = {};
        var _interopRequireDefault$c = interopRequireDefaultExports;
        Object.defineProperty(RemoveCircle, "__esModule", {
          value: true
        });
        var default_1$4 = RemoveCircle.default = void 0;
        var _createSvgIcon$4 = _interopRequireDefault$c(requireCreateSvgIcon());
        var _jsxRuntime$4 = jsxRuntimeExports;
        default_1$4 = RemoveCircle.default = (0, _createSvgIcon$4.default)(/*#__PURE__*/(0, _jsxRuntime$4.jsx)("path", {
          d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m5 11H7v-2h10z"
        }), 'RemoveCircle');
        var AddCircle = {};
        var _interopRequireDefault$b = interopRequireDefaultExports;
        Object.defineProperty(AddCircle, "__esModule", {
          value: true
        });
        var default_1$3 = AddCircle.default = void 0;
        var _createSvgIcon$3 = _interopRequireDefault$b(requireCreateSvgIcon());
        var _jsxRuntime$3 = jsxRuntimeExports;
        default_1$3 = AddCircle.default = (0, _createSvgIcon$3.default)(/*#__PURE__*/(0, _jsxRuntime$3.jsx)("path", {
          d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m5 11h-4v4h-2v-4H7v-2h4V7h2v4h4z"
        }), 'AddCircle');
        function PriorityItemSetup(props) {
          const t = props.t;
          const _reactExports$useStat65 = reactExports.useState(props.checked),
            _reactExports$useStat66 = _slicedToArray2(_reactExports$useStat65, 2),
            checked = _reactExports$useStat66[0],
            setChecked = _reactExports$useStat66[1];
          const _reactExports$useStat67 = reactExports.useState(props.data),
            _reactExports$useStat68 = _slicedToArray2(_reactExports$useStat67, 2),
            data = _reactExports$useStat68[0],
            setData = _reactExports$useStat68[1];
          const isSubmitEnabled = () => {
            const checkCount = checked.filter(x => x).length;
            return checkCount >= 2 && data.limit <= checkCount - 1 && data.limit >= 1;
          };
          const onSubmit = () => {
            const selected = checked.filter(x => x).length;
            if (selected < 2) {
              return false;
            }
            const submitData = _objectSpread3({}, data);
            const weightsData = checked.reduce((sum, el, i) => {
              if (el) {
                sum.push(submitData.weights[i]);
              }
              return sum;
            }, []);
            props.onSubmit(_objectSpread3(_objectSpread3({}, submitData), {}, {
              weights: weightsData
            }));
          };
          const handleCheckboxChange = (e, i) => {
            const cloneChecked = [...checked];
            cloneChecked[i] = e;
            setChecked([...cloneChecked]);
          };
          const changeLimit = limit => {
            setData(_objectSpread3(_objectSpread3({}, data), {}, {
              limit
            }));
          };
          const changeWeight = (e, i) => {
            const newData = _objectSpread3({}, data);
            newData.weights = [...data.weights];
            newData.weights[i] = _objectSpread3(_objectSpread3({}, data.weights[i]), {}, {
              weight: e
            });
            setData(newData);
          };
          const decreaseLimit = limit => {
            if (limit === 1) {
              return false;
            }
            limit--;
            changeLimit(limit);
          };
          const increaseLimit = limit => {
            if (limit === data.weights.length - 1) {
              return false;
            }
            limit++;
            changeLimit(limit);
          };
          const _decreaseWeight = (e, i) => {
            if (e === 1) {
              return false;
            }
            e--;
            changeWeight(e, i);
          };
          const _increaseWeight = (e, i) => {
            e++;
            changeWeight(e, i);
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Card, {
            className: styles$6.randomItem,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              className: styles$6.title,
              children: props.title
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$6.randomBody,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(PriorityLimitController, {
                t,
                increaseLimit,
                decreaseLimit,
                limit: data.limit
              }), /* @__PURE__ */jsxRuntimeExports.jsx("ul", {
                className: `${styles$6.list} ${styles$6.active}`,
                children: data && data.weights && data.weights.map((nestedItem, index) => /* @__PURE__ */jsxRuntimeExports.jsx(PrioritisedChildDisplay, {
                  code: nestedItem.code,
                  weight: nestedItem.weight,
                  handleChange: checked2 => handleCheckboxChange(checked2, index),
                  decreaseWeight: weight => _decreaseWeight(weight, index),
                  increaseWeight: weight => _increaseWeight(weight, index),
                  checked: (checked === null || checked === void 0 ? void 0 : checked[index]) || false,
                  label: props.getChildLabelByCode(nestedItem.code)
                }, index))
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$6.randomAction,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                variant: "text",
                onClick: e => props.onCancel(),
                children: t("cancel")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                variant: "contained",
                onClick: e => onSubmit(),
                disabled: !isSubmitEnabled(),
                children: t("submit")
              })]
            })]
          });
        }
        function PrioritisedChildDisplay({
          code,
          checked,
          label,
          weight,
          handleChange,
          increaseWeight,
          decreaseWeight
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs("li", {
            className: styles$6.listItem,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Checkbox, {
              checked,
              onChange: e => handleChange(e.target.checked)
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: `${styles$6.content} ${styles$6.label}`,
              children: [code, ": ", label]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$6.weight,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                size: "small",
                onClick: e => decreaseWeight(weight),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$4, {})
              }), /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                children: weight
              }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                size: "small",
                onClick: e => increaseWeight(weight),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$3, {})
              })]
            })]
          });
        }
        function PriorityLimitController({
          limit,
          increaseLimit,
          decreaseLimit,
          t
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [t("priority_show"), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
              size: "small",
              onClick: e => decreaseLimit(limit),
              children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$4, {})
            }), limit, /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
              size: "small",
              onClick: e => increaseLimit(limit),
              children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$3, {})
            })]
          });
        }
        function CustomPriority({
          t,
          type,
          code,
          hideErrors
        }) {
          var _priorityInstruction$, _priorityInstruction$2;
          const dispatch = useDispatch();
          const _reactExports$useStat69 = reactExports.useState({}),
            _reactExports$useStat70 = _slicedToArray2(_reactExports$useStat69, 2),
            action = _reactExports$useStat70[0],
            setAction = _reactExports$useStat70[1];
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const childrenCodes = useSelector(state2 => {
            var _state2$designState$c;
            return ((_state2$designState$c = state2.designState[code]) === null || _state2$designState$c === void 0 || (_state2$designState$c = _state2$designState$c.children) === null || _state2$designState$c === void 0 || (_state2$designState$c = _state2$designState$c.filter(el => type ? el.type == type : true)) === null || _state2$designState$c === void 0 || (_state2$designState$c = _state2$designState$c.filter(el => {
              var _el$groupType, _el$groupType2;
              return ((_el$groupType = el.groupType) === null || _el$groupType === void 0 ? void 0 : _el$groupType.toLowerCase()) != "welcome" && ((_el$groupType2 = el.groupType) === null || _el$groupType2 === void 0 ? void 0 : _el$groupType2.toLowerCase()) != "end";
            })) === null || _state2$designState$c === void 0 ? void 0 : _state2$designState$c.map(el => el.code)) || [];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          const childrenLabels = useSelector(state2 => {
            var _state2$designState$c2;
            return ((_state2$designState$c2 = state2.designState[code]) === null || _state2$designState$c2 === void 0 || (_state2$designState$c2 = _state2$designState$c2.children) === null || _state2$designState$c2 === void 0 || (_state2$designState$c2 = _state2$designState$c2.filter(el => type ? el.type == type : true)) === null || _state2$designState$c2 === void 0 ? void 0 : _state2$designState$c2.map(child => {
              var _state2$designState$c3;
              return {
                code: child.code,
                label: (_state2$designState$c3 = state2.designState[child.qualifiedCode].content) === null || _state2$designState$c3 === void 0 || (_state2$designState$c3 = _state2$designState$c3.label) === null || _state2$designState$c3 === void 0 ? void 0 : _state2$designState$c3[lang]
              };
            })) || [];
          });
          const priorityInstruction = instructionByCode(state, "priority_groups");
          const priorities = (priorityInstruction === null || priorityInstruction === void 0 || (_priorityInstruction$ = priorityInstruction.priorities) === null || _priorityInstruction$ === void 0 ? void 0 : _priorityInstruction$.filter(priority => type ? priority.weights.some(el => childrenCodes.includes(el.code)) : true)) || [];
          let allCodesinPriority = priorities.map(priority => priority.weights).flat().map(weight => weight.code).flat();
          const priorityErrors = (priorityInstruction === null || priorityInstruction === void 0 || (_priorityInstruction$2 = priorityInstruction.errors) === null || _priorityInstruction$2 === void 0 ? void 0 : _priorityInstruction$2.filter(error => error.items.some(item => allCodesinPriority.includes(item)))) || [];
          const updatePriorities = priorities2 => {
            dispatch(type ? updatePriorityByType({
              code,
              priorities: priorities2,
              type
            }) : updatePriority({
              code,
              priorities: priorities2
            }));
          };
          const getChildLabelByCode = code2 => {
            var _childrenLabels$find;
            const label = (_childrenLabels$find = childrenLabels.find(el => el.code == code2)) === null || _childrenLabels$find === void 0 ? void 0 : _childrenLabels$find.label;
            return label === null || label === void 0 ? void 0 : label.replace(/<[^>]*>/g, "");
          };
          const getUnPrioritisedChildrenCodes = () => {
            return childrenCodes.filter(el => !allCodesinPriority.includes(el));
          };
          const _onDeleteClicked = index => {
            if (window.confirm(t("are_you_sure"))) {
              updatePriorities(priorities.filter((el, i) => i !== index));
            }
          };
          const isActionEmpty = !action || Object.keys(action).length == 0;
          const _onEditClicked = index => {
            let checked = [];
            let data = [];
            data.weights = [];
            const unPrioritised = getUnPrioritisedChildrenCodes();
            childrenCodes.forEach(code2 => {
              if (unPrioritised.includes(code2)) {
                data.weights.push({
                  code: code2,
                  weight: 1
                });
                checked.push(false);
              } else {
                let weightIndex = priorities[index].weights.findIndex(weight => weight.code == code2);
                if (weightIndex > -1) {
                  data.weights.push(priorities[index].weights[weightIndex]);
                  checked.push(true);
                }
              }
              data.limit = priorities[index].limit;
            });
            setAction({
              index,
              checked,
              title: t("edit_priority_rule"),
              data
            });
          };
          const resetData = () => {
            setAction({});
          };
          const _onSubmit = (value, index) => {
            const newPriorities = priorities ? [...priorities] : [];
            newPriorities[index] = _objectSpread3({}, value);
            updatePriorities(newPriorities);
            resetData();
          };
          const addNewPriority = () => {
            const listQuestionCode = getUnPrioritisedChildrenCodes();
            const weights = listQuestionCode.map(el => ({
              code: el,
              weight: 1
            }));
            setAction({
              title: t("add_priority_rule"),
              checked: listQuestionCode.map(el => false),
              data: {
                limit: 1,
                weights
              },
              index: priorities ? priorities.length : 0,
              icon: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$j, {})
            });
          };
          const sortPriorityItem = item => {
            let newWeights = [...item.weights].sort(function (a, b) {
              return childrenCodes.findIndex(x => x === a.code) - childrenCodes.findIndex(x => x === b.code);
            });
            return _objectSpread3(_objectSpread3({}, item), {}, {
              weights: newWeights
            });
          };
          const sanitize = (data, childrenCodes2) => {
            let weights = [...data.weights].filter(el => childrenCodes2.includes(el.code));
            if (weights.length <= 1) {
              resetData();
            }
            return {
              limit: Math.min(data.limit, weights.length - 1),
              weights
            };
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [priorities && priorities.map((item, i) => {
              return /* @__PURE__ */jsxRuntimeExports.jsx(PriorityItemDisplay, {
                t,
                data: sortPriorityItem(item),
                index: i,
                childrenCodes,
                isBeingEdited: action.index == i,
                onDeleteClicked: index => {
                  setAction({});
                  _onDeleteClicked(index);
                },
                onEditClicked: index => _onEditClicked(index),
                getChildLabelByCode
              }, i);
            }), !hideErrors && priorityErrors.length > 0 ? /* @__PURE__ */jsxRuntimeExports.jsx(RandomError, {
              errors: priorityErrors
            }) : "", isActionEmpty && /* @__PURE__ */jsxRuntimeExports.jsxs(Button, {
              variant: "contained",
              disabled: getUnPrioritisedChildrenCodes().length < 2,
              onClick: addNewPriority,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$j, {
                sx: {
                  paddingRight: "8px"
                }
              }), " ", t("add_priority_rule")]
            }), action && action.data && /* @__PURE__ */jsxRuntimeExports.jsx(PriorityItemSetup, {
              t,
              title: action.title,
              data: sanitize(action.data, childrenCodes),
              index: action.index,
              getChildLabelByCode,
              checked: action.checked,
              onSubmit: data => _onSubmit(data, action.index),
              onCancel: resetData
            })]
          });
        }
        const selectValue = "_selectValue_14l81_1";
        const styles$5 = {
          selectValue: selectValue
        };
        const errorDisplay = "_errorDisplay_1vtlj_1";
        const addNew = "_addNew_1vtlj_10";
        const styles$4 = {
          errorDisplay: errorDisplay,
          addNew: addNew
        };
        const title$1 = "_title_1p7e9_1";
        const list$1 = "_list_1p7e9_6";
        const randomAction$1 = "_randomAction_1p7e9_19";
        const listItem$1 = "_listItem_1p7e9_25";
        const input$1 = "_input_1p7e9_30";
        const randomItem$1 = "_randomItem_1p7e9_34";
        const styles$3 = {
          title: title$1,
          list: list$1,
          randomAction: randomAction$1,
          listItem: listItem$1,
          input: input$1,
          randomItem: randomItem$1
        };
        function RandomItemSetup(props) {
          const t = props.t;
          const _reactExports$useStat71 = reactExports.useState(props.checked),
            _reactExports$useStat72 = _slicedToArray2(_reactExports$useStat71, 2),
            checked = _reactExports$useStat72[0],
            setChecked = _reactExports$useStat72[1];
          const _reactExports$useStat73 = reactExports.useState(props.randomOption),
            _reactExports$useStat74 = _slicedToArray2(_reactExports$useStat73, 2),
            randomOption = _reactExports$useStat74[0],
            setRandomOption = _reactExports$useStat74[1];
          const isSubmitEnabled = () => {
            return checked.filter(x => x).length >= 2;
          };
          const labels = [t("random_order"), t("flip_order"), t("sort_by_label")];
          const values = ["RANDOM", "FLIP", "ALPHA"];
          const onSubmit = () => {
            const selected = checked.filter(x => x).length;
            if (selected < 2) {
              return false;
            }
            const submitList = checked.reduce((sum, el, i) => {
              if (el) {
                sum.push(props.data[i]);
              }
              return sum;
            }, []);
            props.onSubmit(submitList, randomOption);
          };
          const handleCheckboxChange = (e, i) => {
            const cloneChecked = [...checked];
            cloneChecked[i] = e;
            setChecked([...cloneChecked]);
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Card, {
            className: styles$3.randomItem,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              className: styles$3.title,
              children: props.title
            }), /* @__PURE__ */jsxRuntimeExports.jsx(FormControl, {
              variant: "standard",
              fullWidth: true,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Select, {
                id: "select-value",
                value: randomOption,
                label: "Select Value",
                onChange: e => {
                  setRandomOption(e.target.value);
                },
                children: labels.map((element, index) => {
                  return /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                    value: values[index],
                    children: element
                  }, element);
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx("ul", {
              className: styles$3.list,
              children: props.data && props.data.map((code, index) => /* @__PURE__ */jsxRuntimeExports.jsx(RandomisedChildDisplay$1, {
                code,
                handleChange: checked2 => handleCheckboxChange(checked2, index),
                checked: (checked === null || checked === void 0 ? void 0 : checked[index]) || false,
                label: props.getChildLabelByCode(code)
              }, index))
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$3.randomAction,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                variant: "text",
                onClick: e => props.onCancel(),
                children: t("cancel")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                variant: "contained",
                onClick: e => onSubmit(),
                disabled: !isSubmitEnabled(),
                children: t("submit")
              })]
            })]
          });
        }
        function RandomisedChildDisplay$1({
          code,
          label,
          checked,
          handleChange
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs("li", {
            className: styles$3.listItem,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Checkbox, {
              checked,
              onChange: e => handleChange(e.target.checked)
            }), code, ": ", label]
          });
        }
        const randomHeader = "_randomHeader_10d2m_1";
        const title = "_title_10d2m_6";
        const action = "_action_10d2m_11";
        const settingIcon = "_settingIcon_10d2m_15";
        const list = "_list_10d2m_19";
        const randomAction = "_randomAction_10d2m_30";
        const listItem = "_listItem_10d2m_36";
        const label = "_label_10d2m_41";
        const input = "_input_10d2m_47";
        const listItemError = "_listItemError_10d2m_51";
        const randomItem = "_randomItem_10d2m_63";
        const highlighted = "_highlighted_10d2m_68";
        const styles$2 = {
          randomHeader: randomHeader,
          title: title,
          action: action,
          settingIcon: settingIcon,
          list: list,
          randomAction: randomAction,
          listItem: listItem,
          label: label,
          input: input,
          listItemError: listItemError,
          randomItem: randomItem,
          highlighted: highlighted
        };
        const randomOptionToText = (randomOption, t) => {
          switch (randomOption) {
            case "ALPHA":
              return t("sort_by_label");
            case "RANDOM":
              return t("random_order");
            case "FLIP":
              return t("flip_order");
          }
          throw "unidentified randomOption: " + randomOption;
        };
        function RandomItemDisplay(props) {
          const t = props.t;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Card, {
            className: `${styles$2.randomItem} ${props.isBeingEdited ? styles$2.highlighted : ""}`,
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$2.randomHeader,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
                className: styles$2.title,
                children: randomOptionToText(props.randomOption, t)
              }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                className: styles$2.action,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  onClick: () => props.onEditClicked(props.index),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$5, {
                    className: styles$2.settingIcon
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  onClick: () => props.onDeleteClicked(props.index),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$q, {
                    className: styles$2.settingIcon
                  })
                })]
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx("ul", {
              className: styles$2.list,
              children: props.data && props.data.map((code, index) => {
                return /* @__PURE__ */jsxRuntimeExports.jsx(RandomisedChildDisplay, {
                  label: props.getChildLabelByCode(code),
                  code,
                  childrenCodes: props.childrenCodes
                }, index);
              })
            })]
          });
        }
        function RandomisedChildDisplay({
          code,
          label,
          childrenCodes
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsx("li", {
            className: childrenCodes.indexOf(code) !== -1 ? styles$2.listItem : styles$2.listItemError,
            children: /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: `${styles$2.content} ${styles$2.label}`,
              children: [code, ": ", label]
            })
          });
        }
        function CustomRandom({
          t,
          type,
          code,
          hideErrors
        }) {
          var _randomInstruction$gr, _randomInstruction$er;
          const dispatch = useDispatch();
          const _reactExports$useStat75 = reactExports.useState({}),
            _reactExports$useStat76 = _slicedToArray2(_reactExports$useStat75, 2),
            action = _reactExports$useStat76[0],
            setAction = _reactExports$useStat76[1];
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const childrenCodes = useSelector(state2 => {
            var _state2$designState$c4;
            return ((_state2$designState$c4 = state2.designState[code]) === null || _state2$designState$c4 === void 0 || (_state2$designState$c4 = _state2$designState$c4.children) === null || _state2$designState$c4 === void 0 || (_state2$designState$c4 = _state2$designState$c4.filter(el => type ? el.type == type : true)) === null || _state2$designState$c4 === void 0 || (_state2$designState$c4 = _state2$designState$c4.filter(el => {
              var _el$groupType3, _el$groupType4;
              return ((_el$groupType3 = el.groupType) === null || _el$groupType3 === void 0 ? void 0 : _el$groupType3.toLowerCase()) != "welcome" && ((_el$groupType4 = el.groupType) === null || _el$groupType4 === void 0 ? void 0 : _el$groupType4.toLowerCase()) != "end";
            })) === null || _state2$designState$c4 === void 0 ? void 0 : _state2$designState$c4.map(el => el.code)) || [];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          const childrenLabels = useSelector(state2 => {
            var _state2$designState$c5;
            return ((_state2$designState$c5 = state2.designState[code]) === null || _state2$designState$c5 === void 0 || (_state2$designState$c5 = _state2$designState$c5.children) === null || _state2$designState$c5 === void 0 || (_state2$designState$c5 = _state2$designState$c5.filter(el => type ? el.type == type : true)) === null || _state2$designState$c5 === void 0 ? void 0 : _state2$designState$c5.map(child => {
              var _state2$designState$c6;
              return {
                code: child.code,
                label: (_state2$designState$c6 = state2.designState[child.qualifiedCode].content) === null || _state2$designState$c6 === void 0 || (_state2$designState$c6 = _state2$designState$c6.label) === null || _state2$designState$c6 === void 0 ? void 0 : _state2$designState$c6[lang]
              };
            })) || [];
          });
          const randomInstruction = instructionByCode(state, "random_group");
          const randomOrders = (randomInstruction === null || randomInstruction === void 0 || (_randomInstruction$gr = randomInstruction.groups) === null || _randomInstruction$gr === void 0 ? void 0 : _randomInstruction$gr.filter(group => type ? group.codes.some(code2 => childrenCodes.includes(code2)) : true)) || [];
          const allCodesinRandomOrders = randomOrders.map(it => it.codes).flat();
          const randomErrors = (randomInstruction === null || randomInstruction === void 0 || (_randomInstruction$er = randomInstruction.errors) === null || _randomInstruction$er === void 0 ? void 0 : _randomInstruction$er.filter(error => error.items.some(item => allCodesinRandomOrders.includes(item)))) || [];
          const updateRandomOrders = groups => {
            dispatch(type ? updateRandomByType({
              code,
              groups,
              type
            }) : updateRandom({
              code,
              groups
            }));
          };
          const getChildLabelByCode = code2 => {
            var _childrenLabels$find2;
            const label = (_childrenLabels$find2 = childrenLabels.find(el => el.code == code2)) === null || _childrenLabels$find2 === void 0 ? void 0 : _childrenLabels$find2.label;
            return label === null || label === void 0 ? void 0 : label.replace(/<[^>]*>/g, "");
          };
          const getUnrandomisedChildrenCodes = data => {
            return childrenCodes.filter(el => !allCodesinRandomOrders.includes(el));
          };
          const _onDeleteClicked2 = index => {
            if (window.confirm(t("are_you_sure"))) {
              updateRandomOrders(randomOrders.filter((el, i) => i !== index));
            }
          };
          const sortRandomItem = item => {
            return [...item.codes].sort(function (a, b) {
              return childrenCodes.findIndex(x => x === a) - childrenCodes.findIndex(x => x === b);
            });
          };
          const _onEditClicked2 = index => {
            let checked = [];
            let data = [];
            let unrandomized = getUnrandomisedChildrenCodes();
            data = childrenCodes.filter(el => unrandomized.includes(el) || randomOrders[index].codes.includes(el));
            checked = data.map(el => randomOrders[index].codes.includes(el) ? true : false);
            setAction({
              index,
              checked,
              randomOption: randomOrders[index].randomOption || "RANDOM",
              title: t("edit_random_rule"),
              data
            });
          };
          const resetData = () => {
            setAction({});
          };
          const isActionEmpty = !action || Object.keys(action).length == 0;
          const _onSubmit2 = (value, randomOption, index) => {
            const newRandomOrders = randomOrders ? [...randomOrders] : [];
            newRandomOrders[index] = {
              codes: value,
              randomOption
            };
            updateRandomOrders(newRandomOrders);
            resetData();
          };
          const addNewRule = () => {
            const data = getUnrandomisedChildrenCodes();
            setAction({
              title: t("add_new_random_rule"),
              data,
              checked: [],
              randomOption: "RANDOM",
              index: randomOrders ? randomOrders.length : 0
            });
          };
          const sanitize = (data, childrenCodes2) => {
            let groups = [...data].filter(code2 => childrenCodes2.includes(code2));
            if (groups.length <= 1) {
              resetData();
            }
            return groups;
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [randomOrders && randomOrders.map((item, i) => {
              return /* @__PURE__ */jsxRuntimeExports.jsx(RandomItemDisplay, {
                t,
                data: sortRandomItem(item),
                randomOption: item.randomOption,
                index: i,
                isBeingEdited: action.index == i,
                childrenCodes,
                getChildLabelByCode,
                onDeleteClicked: index => {
                  setAction({});
                  _onDeleteClicked2(index);
                },
                onEditClicked: index => _onEditClicked2(index)
              }, i);
            }), !hideErrors && randomErrors.length > 0 ? /* @__PURE__ */jsxRuntimeExports.jsx(RandomError, {
              errors: randomErrors
            }) : "", isActionEmpty && /* @__PURE__ */jsxRuntimeExports.jsxs(Button, {
              className: styles$4.addNew,
              variant: "contained",
              disabled: getUnrandomisedChildrenCodes().length < 2,
              onClick: addNewRule,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$k, {
                sx: {
                  paddingRight: "8px"
                }
              }), " ", t("add_random_rule")]
            }), action && action.data && /* @__PURE__ */jsxRuntimeExports.jsx(RandomItemSetup, {
              t,
              title: action.title,
              data: sanitize(action.data, childrenCodes),
              randomOption: action.randomOption,
              getChildLabelByCode,
              checked: action.checked,
              onSubmit: (data, randomOption) => _onSubmit2(data, randomOption, action.index),
              onCancel: resetData
            })]
          });
        }
        function OrderPrioritySetup({
          t,
          rule,
          code
        }) {
          const dispatch = useDispatch();
          const value = useSelector(state => {
            return state.designState[code][rule] || "NONE";
          });
          let title = "";
          let labels = [];
          let values = [];
          switch (rule) {
            case "randomize_questions":
              title = t("questions_order");
              labels = [t("as_is"), t("random_order"), t("flip_order"), t("custom_random")];
              values = ["NONE", "RANDOM", "FLIP", "custom"];
              break;
            case "prioritize_questions":
              title = t("questions_priority");
              labels = [t("no_priority"), t("prioritise_questions")];
              values = ["NONE", "prioritize"];
              break;
            case "randomize_groups":
              title = t("groups_order");
              labels = [t("as_is"), t("random_order"), t("flip_order"), t("custom_random")];
              values = ["NONE", "RANDOM", "FLIP", "custom"];
              break;
            case "prioritize_groups":
              title = t("groups_priority");
              labels = [t("no_priority"), t("prioritise_groups")];
              values = ["NONE", "prioritize"];
              break;
            case "randomize_options":
              title = t("options_order");
              labels = [t("as_is"), t("random_order"), t("flip_order"), t("sort_by_label"), t("custom_random")];
              values = ["NONE", "RANDOM", "FLIP", "ALPHA", "custom"];
              break;
            case "prioritize_options":
              title = t("options_priority");
              labels = [t("no_priority"), t("prioritise_options")];
              values = ["NONE", "prioritize"];
              break;
            case "randomize_rows":
              title = t("rows_order");
              labels = [t("as_is"), t("random_order"), t("flip_order"), t("sort_by_label"), t("custom_random")];
              values = ["NONE", "RANDOM", "FLIP", "ALPHA", "custom"];
              break;
            case "prioritize_rows":
              title = t("rows_priority");
              labels = [t("no_priority"), t("prioritise_rows")];
              values = ["NONE", "prioritize"];
              break;
            case "randomize_columns":
              title = t("columns_order");
              labels = [t("as_is"), t("random_order"), t("flip_order"), t("sort_by_label"), t("custom_random")];
              values = ["NONE", "RANDOM", "FLIP", "ALPHA", "custom"];
              break;
            case "prioritize_columns":
              title = t("columns_priority");
              labels = [t("no_priority"), t("prioritise_columns")];
              values = ["NONE", "prioritize"];
              break;
          }
          const _onChange4 = value2 => {
            const finalValue = value2 == "NONE" ? void 0 : value2;
            dispatch(changeAttribute({
              code,
              key: rule,
              value: finalValue
            }));
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              children: title
            }), /* @__PURE__ */jsxRuntimeExports.jsx(FormControl, {
              className: styles$5.selectValue,
              variant: "standard",
              fullWidth: true,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Select, {
                id: "select-value",
                value,
                label: "Select Value",
                onChange: e => {
                  _onChange4(e.target.value);
                },
                children: labels.map((element, index) => {
                  return /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                    value: values[index],
                    children: element
                  }, element);
                })
              })
            }), value == "custom" && ["randomize_questions", "randomize_options", "randomize_groups"].indexOf(rule) !== -1 && /* @__PURE__ */jsxRuntimeExports.jsx(CustomRandom, {
              label: "",
              code,
              t
            }), value == "custom" && "randomize_rows" == rule && /* @__PURE__ */jsxRuntimeExports.jsx(CustomRandom, {
              label: "",
              type: "row",
              code,
              t
            }), value == "prioritize" && "prioritize_rows" == rule && /* @__PURE__ */jsxRuntimeExports.jsx(CustomPriority, {
              label: "",
              type: "row",
              code,
              t
            }), value == "custom" && "randomize_columns" == rule && /* @__PURE__ */jsxRuntimeExports.jsx(CustomRandom, {
              label: "",
              type: "column",
              code,
              t
            }), value == "prioritize" && "prioritize_columns" == rule && /* @__PURE__ */jsxRuntimeExports.jsx(CustomPriority, {
              label: "",
              type: "column",
              code,
              t
            }), value == "prioritize" && ["prioritize_questions", "prioritize_options", "prioritize_groups"].indexOf(rule) !== -1 && /* @__PURE__ */jsxRuntimeExports.jsx(CustomPriority, {
              label: "",
              code,
              t
            })]
          });
        }
        const NavigationMode = () => {
          const _useTranslation6 = useTranslation("design"),
            t = _useTranslation6.t;
          const dispatch = useDispatch();
          const value = useSelector(state => {
            return state.designState.Survey.navigationMode || NAVIGATION_MODE.GROUP_BY_GROUP;
          });
          const onNavigationModeChanged = event => {
            dispatch(changeAttribute({
              code: "Survey",
              key: "navigationMode",
              value: event.target.value
            }));
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
            fullWidth: true,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(InputLabel, {
              id: "navigation-mode-label",
              children: t("navigation_mode")
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Select, {
              labelId: "navigation-mode-label",
              id: "demo-simple-select",
              value,
              label: t("label.navigation_mode"),
              onChange: onNavigationModeChanged,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                value: NAVIGATION_MODE.GROUP_BY_GROUP,
                children: t("group_by_group")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                value: NAVIGATION_MODE.QUESTION_BY_QUESTION,
                children: t("question_by_question")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                value: NAVIGATION_MODE.ALL_IN_ONE,
                children: t("all_in_one")
              })]
            })]
          });
        };
        const theming = "_theming_1v217_1";
        const chooseImage = "_chooseImage_1v217_12";
        const resetButton = "_resetButton_1v217_21";
        const fontText = "_fontText_1v217_24";
        const selectDropdown$1 = "_selectDropdown_1v217_27";
        const colorBox = "_colorBox_1v217_33";
        const colorPickerContainer = "_colorPickerContainer_1v217_40";
        const styles$1 = {
          theming: theming,
          chooseImage: chooseImage,
          resetButton: resetButton,
          fontText: fontText,
          selectDropdown: selectDropdown$1,
          colorBox: colorBox,
          colorPickerContainer: colorPickerContainer
        };
        const themingItem = "_themingItem_11qn9_1";
        const themingItemBody = "_themingItemBody_11qn9_6";
        const selectDropdown = "_selectDropdown_11qn9_13";
        const styles = {
          themingItem: themingItem,
          themingItemBody: themingItemBody,
          selectDropdown: selectDropdown
        };
        function ThemingItem(props) {
          const listFontSize = Array.from({
            length: 12
          }, (_, index) => index * 2 + 10);
          function handleChange(key, value) {
            props.onChange(_objectSpread3(_objectSpread3({}, props.value), {}, {
              [key]: value
            }));
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles.themingItem,
            children: /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles.themingItemBody,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Select, {
                size: "small",
                value: props.value.size || props.default.size,
                onChange: e => handleChange("size", e.target.value),
                IconComponent: KeyboardArrowDown,
                className: styles.selectDropdown,
                sx: {
                  "& .MuiSvgIcon-root": {
                    color: "#16205b"
                  }
                },
                children: listFontSize && listFontSize.length > 0 && listFontSize.map((el, index) => /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                  value: el,
                  children: el
                }, `fontSize-${index}`))
              }, "fontSize")
            })
          });
        }
        var lib = {};
        var flattenNames$1 = {};
        var baseGetTag$1 = _baseGetTag,
          isArray$2 = isArray_1,
          isObjectLike$1 = isObjectLike_1;

        /** `Object#toString` result references. */
        var stringTag$2 = '[object String]';

        /**
         * Checks if `value` is classified as a `String` primitive or object.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a string, else `false`.
         * @example
         *
         * _.isString('abc');
         * // => true
         *
         * _.isString(1);
         * // => false
         */
        function isString(value) {
          return typeof value == 'string' || !isArray$2(value) && isObjectLike$1(value) && baseGetTag$1(value) == stringTag$2;
        }
        var isString_1 = isString;
        var identity$1 = identity_1;

        /**
         * Casts `value` to `identity` if it's not a function.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Function} Returns cast function.
         */
        function castFunction$2(value) {
          return typeof value == 'function' ? value : identity$1;
        }
        var _castFunction = castFunction$2;
        var baseForOwn$2 = _baseForOwn,
          castFunction$1 = _castFunction;

        /**
         * Iterates over own enumerable string keyed properties of an object and
         * invokes `iteratee` for each property. The iteratee is invoked with three
         * arguments: (value, key, object). Iteratee functions may exit iteration
         * early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 0.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forOwnRight
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forOwn(object, iteratee) {
          return object && baseForOwn$2(object, castFunction$1(iteratee));
        }
        var forOwn_1 = forOwn;
        var isArrayLike$2 = isArrayLike_1;

        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach$2(eachFunc, fromRight) {
          return function (collection, iteratee) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike$2(collection)) {
              return eachFunc(collection, iteratee);
            }
            var length = collection.length,
              index = fromRight ? length : -1,
              iterable = Object(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        var _createBaseEach = createBaseEach$2;
        var baseForOwn$1 = _baseForOwn,
          createBaseEach$1 = _createBaseEach;

        /**
         * The base implementation of `_.forEach` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEach$2 = createBaseEach$1(baseForOwn$1);
        var _baseEach = baseEach$2;
        var baseEach$1 = _baseEach,
          isArrayLike$1 = isArrayLike_1;

        /**
         * The base implementation of `_.map` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap$2(collection, iteratee) {
          var index = -1,
            result = isArrayLike$1(collection) ? Array(collection.length) : [];
          baseEach$1(collection, function (value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }
        var _baseMap = baseMap$2;
        var arrayMap$1 = _arrayMap,
          baseIteratee$1 = _baseIteratee,
          baseMap$1 = _baseMap,
          isArray$1 = isArray_1;

        /**
         * Creates an array of values by running each element in `collection` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
         * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
         * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
         * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * _.map([4, 8], square);
         * // => [16, 64]
         *
         * _.map({ 'a': 4, 'b': 8 }, square);
         * // => [16, 64] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map$1(collection, iteratee) {
          var func = isArray$1(collection) ? arrayMap$1 : baseMap$1;
          return func(collection, baseIteratee$1(iteratee));
        }
        var map_1 = map$1;
        Object.defineProperty(flattenNames$1, "__esModule", {
          value: true
        });
        flattenNames$1.flattenNames = undefined;
        var _isString2 = isString_1;
        var _isString3 = _interopRequireDefault$a(_isString2);
        var _forOwn2$2 = forOwn_1;
        var _forOwn3$2 = _interopRequireDefault$a(_forOwn2$2);
        var _isPlainObject2 = isPlainObject_1;
        var _isPlainObject3 = _interopRequireDefault$a(_isPlainObject2);
        var _map2 = map_1;
        var _map3 = _interopRequireDefault$a(_map2);
        function _interopRequireDefault$a(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        var flattenNames = flattenNames$1.flattenNames = function flattenNames() {
          var things = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var names = [];
          (0, _map3.default)(things, function (thing) {
            if (Array.isArray(thing)) {
              flattenNames(thing).map(function (name) {
                return names.push(name);
              });
            } else if ((0, _isPlainObject3.default)(thing)) {
              (0, _forOwn3$2.default)(thing, function (value, key) {
                value === true && names.push(key);
                names.push(key + '-' + value);
              });
            } else if ((0, _isString3.default)(thing)) {
              names.push(thing);
            }
          });
          return names;
        };
        flattenNames$1.default = flattenNames;
        var mergeClasses$1 = {};
        var baseClone = _baseClone;

        /** Used to compose bitmasks for cloning. */
        var CLONE_DEEP_FLAG = 1,
          CLONE_SYMBOLS_FLAG = 4;

        /**
         * This method is like `_.clone` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @returns {*} Returns the deep cloned value.
         * @see _.clone
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var deep = _.cloneDeep(objects);
         * console.log(deep[0] === objects[0]);
         * // => false
         */
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        var cloneDeep_1 = cloneDeep;
        Object.defineProperty(mergeClasses$1, "__esModule", {
          value: true
        });
        mergeClasses$1.mergeClasses = undefined;
        var _forOwn2$1 = forOwn_1;
        var _forOwn3$1 = _interopRequireDefault$9(_forOwn2$1);
        var _cloneDeep2 = cloneDeep_1;
        var _cloneDeep3 = _interopRequireDefault$9(_cloneDeep2);
        var _extends$e = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        function _interopRequireDefault$9(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        var mergeClasses = mergeClasses$1.mergeClasses = function mergeClasses(classes) {
          var activeNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          var styles = classes.default && (0, _cloneDeep3.default)(classes.default) || {};
          activeNames.map(function (name) {
            var toMerge = classes[name];
            if (toMerge) {
              (0, _forOwn3$1.default)(toMerge, function (value, key) {
                if (!styles[key]) {
                  styles[key] = {};
                }
                styles[key] = _extends$e({}, styles[key], toMerge[key]);
              });
            }
            return name;
          });
          return styles;
        };
        mergeClasses$1.default = mergeClasses;
        var autoprefix$1 = {};
        Object.defineProperty(autoprefix$1, "__esModule", {
          value: true
        });
        autoprefix$1.autoprefix = undefined;
        var _forOwn2 = forOwn_1;
        var _forOwn3 = _interopRequireDefault$8(_forOwn2);
        var _extends$d = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        function _interopRequireDefault$8(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        var transforms = {
          borderRadius: function borderRadius(value) {
            return {
              msBorderRadius: value,
              MozBorderRadius: value,
              OBorderRadius: value,
              WebkitBorderRadius: value,
              borderRadius: value
            };
          },
          boxShadow: function boxShadow(value) {
            return {
              msBoxShadow: value,
              MozBoxShadow: value,
              OBoxShadow: value,
              WebkitBoxShadow: value,
              boxShadow: value
            };
          },
          userSelect: function userSelect(value) {
            return {
              WebkitTouchCallout: value,
              KhtmlUserSelect: value,
              MozUserSelect: value,
              msUserSelect: value,
              WebkitUserSelect: value,
              userSelect: value
            };
          },
          flex: function flex(value) {
            return {
              WebkitBoxFlex: value,
              MozBoxFlex: value,
              WebkitFlex: value,
              msFlex: value,
              flex: value
            };
          },
          flexBasis: function flexBasis(value) {
            return {
              WebkitFlexBasis: value,
              flexBasis: value
            };
          },
          justifyContent: function justifyContent(value) {
            return {
              WebkitJustifyContent: value,
              justifyContent: value
            };
          },
          transition: function transition(value) {
            return {
              msTransition: value,
              MozTransition: value,
              OTransition: value,
              WebkitTransition: value,
              transition: value
            };
          },
          transform: function transform(value) {
            return {
              msTransform: value,
              MozTransform: value,
              OTransform: value,
              WebkitTransform: value,
              transform: value
            };
          },
          absolute: function absolute(value) {
            var direction = value && value.split(' ');
            return {
              position: 'absolute',
              top: direction && direction[0],
              right: direction && direction[1],
              bottom: direction && direction[2],
              left: direction && direction[3]
            };
          },
          extend: function extend(name, otherElementStyles) {
            var otherStyle = otherElementStyles[name];
            if (otherStyle) {
              return otherStyle;
            }
            return {
              'extend': name
            };
          }
        };
        var autoprefix = autoprefix$1.autoprefix = function autoprefix(elements) {
          var prefixed = {};
          (0, _forOwn3.default)(elements, function (styles, element) {
            var expanded = {};
            (0, _forOwn3.default)(styles, function (value, key) {
              var transform = transforms[key];
              if (transform) {
                expanded = _extends$d({}, expanded, transform(value));
              } else {
                expanded[key] = value;
              }
            });
            prefixed[element] = expanded;
          });
          return prefixed;
        };
        autoprefix$1.default = autoprefix;
        var hover$1 = {};
        Object.defineProperty(hover$1, "__esModule", {
          value: true
        });
        hover$1.hover = undefined;
        var _extends$c = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var _react$3 = reactExports;
        var _react2$3 = _interopRequireDefault$7(_react$3);
        function _interopRequireDefault$7(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        function _classCallCheck$9(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$9(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$9(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var hover = hover$1.hover = function hover(Component) {
          var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';
          return function (_React$Component) {
            _inherits$9(Hover, _React$Component);
            function Hover() {
              var _ref;
              var _temp, _this, _ret;
              _classCallCheck$9(this, Hover);
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return _ret = (_temp = (_this = _possibleConstructorReturn$9(this, (_ref = Hover.__proto__ || Object.getPrototypeOf(Hover)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
                hover: false
              }, _this.handleMouseOver = function () {
                return _this.setState({
                  hover: true
                });
              }, _this.handleMouseOut = function () {
                return _this.setState({
                  hover: false
                });
              }, _this.render = function () {
                return _react2$3.default.createElement(Span, {
                  onMouseOver: _this.handleMouseOver,
                  onMouseOut: _this.handleMouseOut
                }, _react2$3.default.createElement(Component, _extends$c({}, _this.props, _this.state)));
              }, _temp), _possibleConstructorReturn$9(_this, _ret);
            }
            return Hover;
          }(_react2$3.default.Component);
        };
        hover$1.default = hover;
        var active$1 = {};
        Object.defineProperty(active$1, "__esModule", {
          value: true
        });
        active$1.active = undefined;
        var _extends$b = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var _react$2 = reactExports;
        var _react2$2 = _interopRequireDefault$6(_react$2);
        function _interopRequireDefault$6(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        function _classCallCheck$8(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$8(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$8(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var active = active$1.active = function active(Component) {
          var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';
          return function (_React$Component) {
            _inherits$8(Active, _React$Component);
            function Active() {
              var _ref;
              var _temp, _this, _ret;
              _classCallCheck$8(this, Active);
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return _ret = (_temp = (_this = _possibleConstructorReturn$8(this, (_ref = Active.__proto__ || Object.getPrototypeOf(Active)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
                active: false
              }, _this.handleMouseDown = function () {
                return _this.setState({
                  active: true
                });
              }, _this.handleMouseUp = function () {
                return _this.setState({
                  active: false
                });
              }, _this.render = function () {
                return _react2$2.default.createElement(Span, {
                  onMouseDown: _this.handleMouseDown,
                  onMouseUp: _this.handleMouseUp
                }, _react2$2.default.createElement(Component, _extends$b({}, _this.props, _this.state)));
              }, _temp), _possibleConstructorReturn$8(_this, _ret);
            }
            return Active;
          }(_react2$2.default.Component);
        };
        active$1.default = active;
        var loop = {};
        Object.defineProperty(loop, "__esModule", {
          value: true
        });
        var loopable = function loopable(i, length) {
          var props = {};
          var setProp = function setProp(name) {
            var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            props[name] = value;
          };
          i === 0 && setProp('first-child');
          i === length - 1 && setProp('last-child');
          (i === 0 || i % 2 === 0) && setProp('even');
          Math.abs(i % 2) === 1 && setProp('odd');
          setProp('nth-child', i);
          return props;
        };
        loop.default = loopable;
        Object.defineProperty(lib, "__esModule", {
          value: true
        });
        lib.ReactCSS = lib.loop = lib.handleActive = handleHover = lib.handleHover = lib.hover = undefined;
        var _flattenNames = flattenNames$1;
        var _flattenNames2 = _interopRequireDefault$5(_flattenNames);
        var _mergeClasses = mergeClasses$1;
        var _mergeClasses2 = _interopRequireDefault$5(_mergeClasses);
        var _autoprefix = autoprefix$1;
        var _autoprefix2 = _interopRequireDefault$5(_autoprefix);
        var _hover2 = hover$1;
        var _hover3 = _interopRequireDefault$5(_hover2);
        var _active = active$1;
        var _active2 = _interopRequireDefault$5(_active);
        var _loop2 = loop;
        var _loop3 = _interopRequireDefault$5(_loop2);
        function _interopRequireDefault$5(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        lib.hover = _hover3.default;
        var handleHover = lib.handleHover = _hover3.default;
        lib.handleActive = _active2.default;
        lib.loop = _loop3.default;
        var ReactCSS = lib.ReactCSS = function ReactCSS(classes) {
          for (var _len = arguments.length, activations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            activations[_key - 1] = arguments[_key];
          }
          var activeNames = (0, _flattenNames2.default)(activations);
          var merged = (0, _mergeClasses2.default)(classes, activeNames);
          return (0, _autoprefix2.default)(merged);
        };
        var _default$2 = lib.default = ReactCSS;
        var calculateChange$2 = function calculateChange(e, hsl, direction, initialA, container) {
          var containerWidth = container.clientWidth;
          var containerHeight = container.clientHeight;
          var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
          var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
          var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
          var top = y - (container.getBoundingClientRect().top + window.pageYOffset);
          if (direction === 'vertical') {
            var a = void 0;
            if (top < 0) {
              a = 0;
            } else if (top > containerHeight) {
              a = 1;
            } else {
              a = Math.round(top * 100 / containerHeight) / 100;
            }
            if (hsl.a !== a) {
              return {
                h: hsl.h,
                s: hsl.s,
                l: hsl.l,
                a: a,
                source: 'rgb'
              };
            }
          } else {
            var _a = void 0;
            if (left < 0) {
              _a = 0;
            } else if (left > containerWidth) {
              _a = 1;
            } else {
              _a = Math.round(left * 100 / containerWidth) / 100;
            }
            if (initialA !== _a) {
              return {
                h: hsl.h,
                s: hsl.s,
                l: hsl.l,
                a: _a,
                source: 'rgb'
              };
            }
          }
          return null;
        };
        var checkboardCache = {};
        var render = function render(c1, c2, size, serverCanvas) {
          if (typeof document === 'undefined' && !serverCanvas) {
            return null;
          }
          var canvas = serverCanvas ? new serverCanvas() : document.createElement('canvas');
          canvas.width = size * 2;
          canvas.height = size * 2;
          var ctx = canvas.getContext('2d');
          if (!ctx) {
            return null;
          } // If no context can be found, return early.
          ctx.fillStyle = c1;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = c2;
          ctx.fillRect(0, 0, size, size);
          ctx.translate(size, size);
          ctx.fillRect(0, 0, size, size);
          return canvas.toDataURL();
        };
        var get$1 = function get(c1, c2, size, serverCanvas) {
          var key = c1 + '-' + c2 + '-' + size + (serverCanvas ? '-server' : '');
          if (checkboardCache[key]) {
            return checkboardCache[key];
          }
          var checkboard = render(c1, c2, size, serverCanvas);
          checkboardCache[key] = checkboard;
          return checkboard;
        };
        var _extends$a = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var Checkboard = function Checkboard(_ref) {
          var white = _ref.white,
            grey = _ref.grey,
            size = _ref.size,
            renderers = _ref.renderers,
            borderRadius = _ref.borderRadius,
            boxShadow = _ref.boxShadow,
            children = _ref.children;
          var styles = _default$2({
            'default': {
              grid: {
                borderRadius: borderRadius,
                boxShadow: boxShadow,
                absolute: '0px 0px 0px 0px',
                background: 'url(' + get$1(white, grey, size, renderers.canvas) + ') center left'
              }
            }
          });
          return reactExports.isValidElement(children) ? React.cloneElement(children, _extends$a({}, children.props, {
            style: _extends$a({}, children.props.style, styles.grid)
          })) : React.createElement('div', {
            style: styles.grid
          });
        };
        Checkboard.defaultProps = {
          size: 8,
          white: 'transparent',
          grey: 'rgba(0,0,0,.08)',
          renderers: {}
        };
        var _extends$9 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var _createClass$7 = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck$7(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$7(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$7(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Alpha = function (_ref) {
          _inherits$7(Alpha, _ref);
          function Alpha() {
            var _ref2;
            var _temp, _this, _ret;
            _classCallCheck$7(this, Alpha);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = _possibleConstructorReturn$7(this, (_ref2 = Alpha.__proto__ || Object.getPrototypeOf(Alpha)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function (e) {
              var change = calculateChange$2(e, _this.props.hsl, _this.props.direction, _this.props.a, _this.container);
              change && typeof _this.props.onChange === 'function' && _this.props.onChange(change, e);
            }, _this.handleMouseDown = function (e) {
              _this.handleChange(e);
              window.addEventListener('mousemove', _this.handleChange);
              window.addEventListener('mouseup', _this.handleMouseUp);
            }, _this.handleMouseUp = function () {
              _this.unbindEventListeners();
            }, _this.unbindEventListeners = function () {
              window.removeEventListener('mousemove', _this.handleChange);
              window.removeEventListener('mouseup', _this.handleMouseUp);
            }, _temp), _possibleConstructorReturn$7(_this, _ret);
          }
          _createClass$7(Alpha, [{
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
              this.unbindEventListeners();
            }
          }, {
            key: 'render',
            value: function render() {
              var _this2 = this;
              var rgb = this.props.rgb;
              var styles = _default$2({
                'default': {
                  alpha: {
                    absolute: '0px 0px 0px 0px',
                    borderRadius: this.props.radius
                  },
                  checkboard: {
                    absolute: '0px 0px 0px 0px',
                    overflow: 'hidden',
                    borderRadius: this.props.radius
                  },
                  gradient: {
                    absolute: '0px 0px 0px 0px',
                    background: 'linear-gradient(to right, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 0) 0%,\n           rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 1) 100%)',
                    boxShadow: this.props.shadow,
                    borderRadius: this.props.radius
                  },
                  container: {
                    position: 'relative',
                    height: '100%',
                    margin: '0 3px'
                  },
                  pointer: {
                    position: 'absolute',
                    left: rgb.a * 100 + '%'
                  },
                  slider: {
                    width: '4px',
                    borderRadius: '1px',
                    height: '8px',
                    boxShadow: '0 0 2px rgba(0, 0, 0, .6)',
                    background: '#fff',
                    marginTop: '1px',
                    transform: 'translateX(-2px)'
                  }
                },
                'vertical': {
                  gradient: {
                    background: 'linear-gradient(to bottom, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 0) 0%,\n           rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 1) 100%)'
                  },
                  pointer: {
                    left: 0,
                    top: rgb.a * 100 + '%'
                  }
                },
                'overwrite': _extends$9({}, this.props.style)
              }, {
                vertical: this.props.direction === 'vertical',
                overwrite: true
              });
              return React.createElement('div', {
                style: styles.alpha
              }, React.createElement('div', {
                style: styles.checkboard
              }, React.createElement(Checkboard, {
                renderers: this.props.renderers
              })), React.createElement('div', {
                style: styles.gradient
              }), React.createElement('div', {
                style: styles.container,
                ref: function ref(container) {
                  return _this2.container = container;
                },
                onMouseDown: this.handleMouseDown,
                onTouchMove: this.handleChange,
                onTouchStart: this.handleChange
              }, React.createElement('div', {
                style: styles.pointer
              }, this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement('div', {
                style: styles.slider
              }))));
            }
          }]);
          return Alpha;
        }(reactExports.PureComponent || reactExports.Component);
        var _createClass$6 = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _classCallCheck$6(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$6(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$6(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var DEFAULT_ARROW_OFFSET = 1;
        var UP_KEY_CODE = 38;
        var DOWN_KEY_CODE = 40;
        var VALID_KEY_CODES = [UP_KEY_CODE, DOWN_KEY_CODE];
        var isValidKeyCode = function isValidKeyCode(keyCode) {
          return VALID_KEY_CODES.indexOf(keyCode) > -1;
        };
        var getNumberValue = function getNumberValue(value) {
          return Number(String(value).replace(/%/g, ''));
        };
        var idCounter = 1;
        var EditableInput = function (_ref) {
          _inherits$6(EditableInput, _ref);
          function EditableInput(props) {
            _classCallCheck$6(this, EditableInput);
            var _this = _possibleConstructorReturn$6(this, (EditableInput.__proto__ || Object.getPrototypeOf(EditableInput)).call(this));
            _this.handleBlur = function () {
              if (_this.state.blurValue) {
                _this.setState({
                  value: _this.state.blurValue,
                  blurValue: null
                });
              }
            };
            _this.handleChange = function (e) {
              _this.setUpdatedValue(e.target.value, e);
            };
            _this.handleKeyDown = function (e) {
              // In case `e.target.value` is a percentage remove the `%` character
              // and update accordingly with a percentage
              // https://github.com/casesandberg/react-color/issues/383
              var value = getNumberValue(e.target.value);
              if (!isNaN(value) && isValidKeyCode(e.keyCode)) {
                var offset = _this.getArrowOffset();
                var updatedValue = e.keyCode === UP_KEY_CODE ? value + offset : value - offset;
                _this.setUpdatedValue(updatedValue, e);
              }
            };
            _this.handleDrag = function (e) {
              if (_this.props.dragLabel) {
                var newValue = Math.round(_this.props.value + e.movementX);
                if (newValue >= 0 && newValue <= _this.props.dragMax) {
                  _this.props.onChange && _this.props.onChange(_this.getValueObjectWithLabel(newValue), e);
                }
              }
            };
            _this.handleMouseDown = function (e) {
              if (_this.props.dragLabel) {
                e.preventDefault();
                _this.handleDrag(e);
                window.addEventListener('mousemove', _this.handleDrag);
                window.addEventListener('mouseup', _this.handleMouseUp);
              }
            };
            _this.handleMouseUp = function () {
              _this.unbindEventListeners();
            };
            _this.unbindEventListeners = function () {
              window.removeEventListener('mousemove', _this.handleDrag);
              window.removeEventListener('mouseup', _this.handleMouseUp);
            };
            _this.state = {
              value: String(props.value).toUpperCase(),
              blurValue: String(props.value).toUpperCase()
            };
            _this.inputId = 'rc-editable-input-' + idCounter++;
            return _this;
          }
          _createClass$6(EditableInput, [{
            key: 'componentDidUpdate',
            value: function componentDidUpdate(prevProps, prevState) {
              if (this.props.value !== this.state.value && (prevProps.value !== this.props.value || prevState.value !== this.state.value)) {
                if (this.input === document.activeElement) {
                  this.setState({
                    blurValue: String(this.props.value).toUpperCase()
                  });
                } else {
                  this.setState({
                    value: String(this.props.value).toUpperCase(),
                    blurValue: !this.state.blurValue && String(this.props.value).toUpperCase()
                  });
                }
              }
            }
          }, {
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
              this.unbindEventListeners();
            }
          }, {
            key: 'getValueObjectWithLabel',
            value: function getValueObjectWithLabel(value) {
              return _defineProperty({}, this.props.label, value);
            }
          }, {
            key: 'getArrowOffset',
            value: function getArrowOffset() {
              return this.props.arrowOffset || DEFAULT_ARROW_OFFSET;
            }
          }, {
            key: 'setUpdatedValue',
            value: function setUpdatedValue(value, e) {
              var onChangeValue = this.props.label ? this.getValueObjectWithLabel(value) : value;
              this.props.onChange && this.props.onChange(onChangeValue, e);
              this.setState({
                value: value
              });
            }
          }, {
            key: 'render',
            value: function render() {
              var _this2 = this;
              var styles = _default$2({
                'default': {
                  wrap: {
                    position: 'relative'
                  }
                },
                'user-override': {
                  wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
                  input: this.props.style && this.props.style.input ? this.props.style.input : {},
                  label: this.props.style && this.props.style.label ? this.props.style.label : {}
                },
                'dragLabel-true': {
                  label: {
                    cursor: 'ew-resize'
                  }
                }
              }, {
                'user-override': true
              }, this.props);
              return React.createElement('div', {
                style: styles.wrap
              }, React.createElement('input', {
                id: this.inputId,
                style: styles.input,
                ref: function ref(input) {
                  return _this2.input = input;
                },
                value: this.state.value,
                onKeyDown: this.handleKeyDown,
                onChange: this.handleChange,
                onBlur: this.handleBlur,
                placeholder: this.props.placeholder,
                spellCheck: 'false'
              }), this.props.label && !this.props.hideLabel ? React.createElement('label', {
                htmlFor: this.inputId,
                style: styles.label,
                onMouseDown: this.handleMouseDown
              }, this.props.label) : null);
            }
          }]);
          return EditableInput;
        }(reactExports.PureComponent || reactExports.Component);
        var calculateChange$1 = function calculateChange(e, direction, hsl, container) {
          var containerWidth = container.clientWidth;
          var containerHeight = container.clientHeight;
          var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
          var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
          var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
          var top = y - (container.getBoundingClientRect().top + window.pageYOffset);
          if (direction === 'vertical') {
            var h = void 0;
            if (top < 0) {
              h = 359;
            } else if (top > containerHeight) {
              h = 0;
            } else {
              var percent = -(top * 100 / containerHeight) + 100;
              h = 360 * percent / 100;
            }
            if (hsl.h !== h) {
              return {
                h: h,
                s: hsl.s,
                l: hsl.l,
                a: hsl.a,
                source: 'hsl'
              };
            }
          } else {
            var _h = void 0;
            if (left < 0) {
              _h = 0;
            } else if (left > containerWidth) {
              _h = 359;
            } else {
              var _percent = left * 100 / containerWidth;
              _h = 360 * _percent / 100;
            }
            if (hsl.h !== _h) {
              return {
                h: _h,
                s: hsl.s,
                l: hsl.l,
                a: hsl.a,
                source: 'hsl'
              };
            }
          }
          return null;
        };
        var _createClass$5 = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck$5(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$5(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$5(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Hue = function (_ref) {
          _inherits$5(Hue, _ref);
          function Hue() {
            var _ref2;
            var _temp, _this, _ret;
            _classCallCheck$5(this, Hue);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = _possibleConstructorReturn$5(this, (_ref2 = Hue.__proto__ || Object.getPrototypeOf(Hue)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function (e) {
              var change = calculateChange$1(e, _this.props.direction, _this.props.hsl, _this.container);
              change && typeof _this.props.onChange === 'function' && _this.props.onChange(change, e);
            }, _this.handleMouseDown = function (e) {
              _this.handleChange(e);
              window.addEventListener('mousemove', _this.handleChange);
              window.addEventListener('mouseup', _this.handleMouseUp);
            }, _this.handleMouseUp = function () {
              _this.unbindEventListeners();
            }, _temp), _possibleConstructorReturn$5(_this, _ret);
          }
          _createClass$5(Hue, [{
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
              this.unbindEventListeners();
            }
          }, {
            key: 'unbindEventListeners',
            value: function unbindEventListeners() {
              window.removeEventListener('mousemove', this.handleChange);
              window.removeEventListener('mouseup', this.handleMouseUp);
            }
          }, {
            key: 'render',
            value: function render() {
              var _this2 = this;
              var _props$direction = this.props.direction,
                direction = _props$direction === undefined ? 'horizontal' : _props$direction;
              var styles = _default$2({
                'default': {
                  hue: {
                    absolute: '0px 0px 0px 0px',
                    borderRadius: this.props.radius,
                    boxShadow: this.props.shadow
                  },
                  container: {
                    padding: '0 2px',
                    position: 'relative',
                    height: '100%',
                    borderRadius: this.props.radius
                  },
                  pointer: {
                    position: 'absolute',
                    left: this.props.hsl.h * 100 / 360 + '%'
                  },
                  slider: {
                    marginTop: '1px',
                    width: '4px',
                    borderRadius: '1px',
                    height: '8px',
                    boxShadow: '0 0 2px rgba(0, 0, 0, .6)',
                    background: '#fff',
                    transform: 'translateX(-2px)'
                  }
                },
                'vertical': {
                  pointer: {
                    left: '0px',
                    top: -(this.props.hsl.h * 100 / 360) + 100 + '%'
                  }
                }
              }, {
                vertical: direction === 'vertical'
              });
              return React.createElement('div', {
                style: styles.hue
              }, React.createElement('div', {
                className: 'hue-' + direction,
                style: styles.container,
                ref: function ref(container) {
                  return _this2.container = container;
                },
                onMouseDown: this.handleMouseDown,
                onTouchMove: this.handleChange,
                onTouchStart: this.handleChange
              }, React.createElement('style', null, '\n            .hue-horizontal {\n              background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0\n                33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to right, #f00 0%, #ff0\n                17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n\n            .hue-vertical {\n              background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,\n                #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%,\n                #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n          '), React.createElement('div', {
                style: styles.pointer
              }, this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement('div', {
                style: styles.slider
              }))));
            }
          }]);
          return Hue;
        }(reactExports.PureComponent || reactExports.Component);

        /**
         * Removes all key-value entries from the list cache.
         *
         * @private
         * @name clear
         * @memberOf ListCache
         */
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }

        /**
         * Performs a
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }

        /**
         * Gets the index at which the `key` is found in `array` of key-value pairs.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} key The key to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }

        /** Used for built-in method references. */
        var arrayProto = Array.prototype;

        /** Built-in value references. */
        var splice = arrayProto.splice;

        /**
         * Removes `key` and its value from the list cache.
         *
         * @private
         * @name delete
         * @memberOf ListCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function listCacheDelete(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }

        /**
         * Gets the list cache value for `key`.
         *
         * @private
         * @name get
         * @memberOf ListCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function listCacheGet(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          return index < 0 ? undefined : data[index][1];
        }

        /**
         * Checks if a list cache value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf ListCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }

        /**
         * Sets the list cache `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf ListCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the list cache instance.
         */
        function listCacheSet(key, value) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }

        /**
         * Creates an list cache object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function ListCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        // Add methods to `ListCache`.
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype['delete'] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;

        /**
         * Removes all key-value entries from the stack.
         *
         * @private
         * @name clear
         * @memberOf Stack
         */
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the stack.
         *
         * @private
         * @name delete
         * @memberOf Stack
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function stackDelete(key) {
          var data = this.__data__,
            result = data['delete'](key);
          this.size = data.size;
          return result;
        }

        /**
         * Gets the stack value for `key`.
         *
         * @private
         * @name get
         * @memberOf Stack
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function stackGet(key) {
          return this.__data__.get(key);
        }

        /**
         * Checks if a stack value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Stack
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function stackHas(key) {
          return this.__data__.has(key);
        }

        /** Detect free variable `global` from Node.js. */
        var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

        /** Detect free variable `self`. */
        var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

        /** Used as a reference to the global object. */
        var root = freeGlobal || freeSelf || Function('return this')();

        /** Built-in value references. */
        var Symbol$1 = root.Symbol;

        /** Used for built-in method references. */
        var objectProto$e = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$b = objectProto$e.hasOwnProperty;

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString$1 = objectProto$e.toString;

        /** Built-in value references. */
        var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */
        function getRawTag(value) {
          var isOwn = hasOwnProperty$b.call(value, symToStringTag$1),
            tag = value[symToStringTag$1];
          try {
            value[symToStringTag$1] = undefined;
            var unmasked = true;
          } catch (e) {}
          var result = nativeObjectToString$1.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag$1] = tag;
            } else {
              delete value[symToStringTag$1];
            }
          }
          return result;
        }

        /** Used for built-in method references. */
        var objectProto$d = Object.prototype;

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString = objectProto$d.toString;

        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }

        /** `Object#toString` result references. */
        var nullTag = '[object Null]',
          undefinedTag = '[object Undefined]';

        /** Built-in value references. */
        var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }

        /**
         * Checks if `value` is the
         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == 'object' || type == 'function');
        }

        /** `Object#toString` result references. */
        var asyncTag = '[object AsyncFunction]',
          funcTag$1 = '[object Function]',
          genTag = '[object GeneratorFunction]',
          proxyTag = '[object Proxy]';

        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          // The use of `Object#toString` avoids issues with the `typeof` operator
          // in Safari 9 which returns 'object' for typed arrays and other constructors.
          var tag = baseGetTag(value);
          return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
        }

        /** Used to detect overreaching core-js shims. */
        var coreJsData = root['__core-js_shared__'];

        /** Used to detect methods masquerading as native. */
        var maskSrcKey = function () {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
          return uid ? 'Symbol(src)_1.' + uid : '';
        }();

        /**
         * Checks if `func` has its source masked.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
         */
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }

        /** Used for built-in method references. */
        var funcProto$2 = Function.prototype;

        /** Used to resolve the decompiled source of functions. */
        var funcToString$2 = funcProto$2.toString;

        /**
         * Converts `func` to its source code.
         *
         * @private
         * @param {Function} func The function to convert.
         * @returns {string} Returns the source code.
         */
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString$2.call(func);
            } catch (e) {}
            try {
              return func + '';
            } catch (e) {}
          }
          return '';
        }

        /**
         * Used to match `RegExp`
         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
         */
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

        /** Used to detect host constructors (Safari). */
        var reIsHostCtor = /^\[object .+?Constructor\]$/;

        /** Used for built-in method references. */
        var funcProto$1 = Function.prototype,
          objectProto$c = Object.prototype;

        /** Used to resolve the decompiled source of functions. */
        var funcToString$1 = funcProto$1.toString;

        /** Used to check objects for own properties. */
        var hasOwnProperty$a = objectProto$c.hasOwnProperty;

        /** Used to detect if a method is native. */
        var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

        /**
         * The base implementation of `_.isNative` without bad shim checks.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         */
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }

        /**
         * Gets the value at `key` of `object`.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function getValue(object, key) {
          return object == null ? undefined : object[key];
        }

        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined;
        }

        /* Built-in method references that are verified to be native. */
        var Map$1 = getNative(root, 'Map');

        /* Built-in method references that are verified to be native. */
        var nativeCreate = getNative(Object, 'create');

        /**
         * Removes all key-value entries from the hash.
         *
         * @private
         * @name clear
         * @memberOf Hash
         */
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the hash.
         *
         * @private
         * @name delete
         * @memberOf Hash
         * @param {Object} hash The hash to modify.
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function hashDelete(key) {
          var result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }

        /** Used to stand-in for `undefined` hash values. */
        var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

        /** Used for built-in method references. */
        var objectProto$b = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

        /**
         * Gets the hash value for `key`.
         *
         * @private
         * @name get
         * @memberOf Hash
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED$2 ? undefined : result;
          }
          return hasOwnProperty$9.call(data, key) ? data[key] : undefined;
        }

        /** Used for built-in method references. */
        var objectProto$a = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

        /**
         * Checks if a hash value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Hash
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined : hasOwnProperty$8.call(data, key);
        }

        /** Used to stand-in for `undefined` hash values. */
        var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

        /**
         * Sets the hash `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Hash
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the hash instance.
         */
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
          return this;
        }

        /**
         * Creates a hash object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Hash(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        // Add methods to `Hash`.
        Hash.prototype.clear = hashClear;
        Hash.prototype['delete'] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;

        /**
         * Removes all key-value entries from the map.
         *
         * @private
         * @name clear
         * @memberOf MapCache
         */
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            'hash': new Hash(),
            'map': new (Map$1 || ListCache)(),
            'string': new Hash()
          };
        }

        /**
         * Checks if `value` is suitable for use as unique object key.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
         */
        function isKeyable(value) {
          var type = typeof value;
          return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
        }

        /**
         * Gets the data for `map`.
         *
         * @private
         * @param {Object} map The map to query.
         * @param {string} key The reference key.
         * @returns {*} Returns the map data.
         */
        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
        }

        /**
         * Removes `key` and its value from the map.
         *
         * @private
         * @name delete
         * @memberOf MapCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function mapCacheDelete(key) {
          var result = getMapData(this, key)['delete'](key);
          this.size -= result ? 1 : 0;
          return result;
        }

        /**
         * Gets the map value for `key`.
         *
         * @private
         * @name get
         * @memberOf MapCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }

        /**
         * Checks if a map value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf MapCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }

        /**
         * Sets the map `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf MapCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the map cache instance.
         */
        function mapCacheSet(key, value) {
          var data = getMapData(this, key),
            size = data.size;
          data.set(key, value);
          this.size += data.size == size ? 0 : 1;
          return this;
        }

        /**
         * Creates a map cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function MapCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        // Add methods to `MapCache`.
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype['delete'] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;

        /** Used as the size to enable large array optimizations. */
        var LARGE_ARRAY_SIZE = 200;

        /**
         * Sets the stack `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Stack
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the stack cache instance.
         */
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }

        /**
         * Creates a stack cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }

        // Add methods to `Stack`.
        Stack.prototype.clear = stackClear;
        Stack.prototype['delete'] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        var defineProperty = function () {
          try {
            var func = getNative(Object, 'defineProperty');
            func({}, '', {});
            return func;
          } catch (e) {}
        }();

        /**
         * The base implementation of `assignValue` and `assignMergeValue` without
         * value checks.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function baseAssignValue(object, key, value) {
          if (key == '__proto__' && defineProperty) {
            defineProperty(object, key, {
              'configurable': true,
              'enumerable': true,
              'value': value,
              'writable': true
            });
          } else {
            object[key] = value;
          }
        }

        /**
         * This function is like `assignValue` except that it doesn't assign
         * `undefined` values.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignMergeValue(object, key, value) {
          if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }

        /**
         * Creates a base function for methods like `_.forIn` and `_.forOwn`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
          return function (object, iteratee, keysFunc) {
            var index = -1,
              iterable = Object(object),
              props = keysFunc(object),
              length = props.length;
            while (length--) {
              var key = props[++index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }

        /**
         * The base implementation of `baseForOwn` which iterates over `object`
         * properties returned by `keysFunc` and invokes `iteratee` for each property.
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseFor = createBaseFor();

        /** Detect free variable `exports`. */
        var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

        /** Detect free variable `module`. */
        var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

        /** Detect the popular CommonJS extension `module.exports`. */
        var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

        /** Built-in value references. */
        var Buffer$2 = moduleExports$2 ? root.Buffer : undefined;
        Buffer$2 ? Buffer$2.allocUnsafe : undefined;

        /**
         * Creates a clone of  `buffer`.
         *
         * @private
         * @param {Buffer} buffer The buffer to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Buffer} Returns the cloned buffer.
         */
        function cloneBuffer(buffer, isDeep) {
          {
            return buffer.slice();
          }
        }

        /** Built-in value references. */
        var Uint8Array$1 = root.Uint8Array;

        /**
         * Creates a clone of `arrayBuffer`.
         *
         * @private
         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */
        function cloneArrayBuffer(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
          return result;
        }

        /**
         * Creates a clone of `typedArray`.
         *
         * @private
         * @param {Object} typedArray The typed array to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned typed array.
         */
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = cloneArrayBuffer(typedArray.buffer);
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }

        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function copyArray(source, array) {
          var index = -1,
            length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }

        /** Built-in value references. */
        var objectCreate = Object.create;

        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} proto The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        var baseCreate = function () {
          function object() {}
          return function (proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result = new object();
            object.prototype = undefined;
            return result;
          };
        }();

        /**
         * Creates a unary function that invokes `func` with its argument transformed.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {Function} transform The argument transform.
         * @returns {Function} Returns the new function.
         */
        function overArg(func, transform) {
          return function (arg) {
            return func(transform(arg));
          };
        }

        /** Built-in value references. */
        var getPrototype = overArg(Object.getPrototypeOf, Object);

        /** Used for built-in method references. */
        var objectProto$9 = Object.prototype;

        /**
         * Checks if `value` is likely a prototype object.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
         */
        function isPrototype(value) {
          var Ctor = value && value.constructor,
            proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$9;
          return value === proto;
        }

        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneObject(object) {
          return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }

        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        function isObjectLike(value) {
          return value != null && typeof value == 'object';
        }

        /** `Object#toString` result references. */
        var argsTag$2 = '[object Arguments]';

        /**
         * The base implementation of `_.isArguments`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         */
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag$2;
        }

        /** Used for built-in method references. */
        var objectProto$8 = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

        /** Built-in value references. */
        var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;

        /**
         * Checks if `value` is likely an `arguments` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         *  else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        var isArguments = baseIsArguments(function () {
          return arguments;
        }()) ? baseIsArguments : function (value) {
          return isObjectLike(value) && hasOwnProperty$7.call(value, 'callee') && !propertyIsEnumerable$1.call(value, 'callee');
        };

        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */
        var isArray = Array.isArray;

        /** Used as references for various `Number` constants. */
        var MAX_SAFE_INTEGER$1 = 9007199254740991;

        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This method is loosely based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
        }

        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }

        /**
         * This method is like `_.isArrayLike` except that it also checks if `value`
         * is an object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array-like object,
         *  else `false`.
         * @example
         *
         * _.isArrayLikeObject([1, 2, 3]);
         * // => true
         *
         * _.isArrayLikeObject(document.body.children);
         * // => true
         *
         * _.isArrayLikeObject('abc');
         * // => false
         *
         * _.isArrayLikeObject(_.noop);
         * // => false
         */
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }

        /**
         * This method returns `false`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `false`.
         * @example
         *
         * _.times(2, _.stubFalse);
         * // => [false, false]
         */
        function stubFalse() {
          return false;
        }

        /** Detect free variable `exports`. */
        var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

        /** Detect free variable `module`. */
        var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

        /** Detect the popular CommonJS extension `module.exports`. */
        var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

        /** Built-in value references. */
        var Buffer$1 = moduleExports$1 ? root.Buffer : undefined;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

        /**
         * Checks if `value` is a buffer.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
         * @example
         *
         * _.isBuffer(new Buffer(2));
         * // => true
         *
         * _.isBuffer(new Uint8Array(2));
         * // => false
         */
        var isBuffer = nativeIsBuffer || stubFalse;

        /** `Object#toString` result references. */
        var objectTag$3 = '[object Object]';

        /** Used for built-in method references. */
        var funcProto = Function.prototype,
          objectProto$7 = Object.prototype;

        /** Used to resolve the decompiled source of functions. */
        var funcToString = funcProto.toString;

        /** Used to check objects for own properties. */
        var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

        /** Used to infer the `Object` constructor. */
        var objectCtorString = funcToString.call(Object);

        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * @static
         * @memberOf _
         * @since 0.8.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty$6.call(proto, 'constructor') && proto.constructor;
          return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }

        /** `Object#toString` result references. */
        var argsTag$1 = '[object Arguments]',
          arrayTag$1 = '[object Array]',
          boolTag$1 = '[object Boolean]',
          dateTag$1 = '[object Date]',
          errorTag$1 = '[object Error]',
          funcTag = '[object Function]',
          mapTag$2 = '[object Map]',
          numberTag$1 = '[object Number]',
          objectTag$2 = '[object Object]',
          regexpTag$1 = '[object RegExp]',
          setTag$2 = '[object Set]',
          stringTag$1 = '[object String]',
          weakMapTag$1 = '[object WeakMap]';
        var arrayBufferTag$1 = '[object ArrayBuffer]',
          dataViewTag$2 = '[object DataView]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';

        /** Used to identify `toStringTag` values of typed arrays. */
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;

        /**
         * The base implementation of `_.isTypedArray` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         */
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }

        /**
         * The base implementation of `_.unary` without support for storing metadata.
         *
         * @private
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         */
        function baseUnary(func) {
          return function (value) {
            return func(value);
          };
        }

        /** Detect free variable `exports`. */
        var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

        /** Detect free variable `module`. */
        var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

        /** Detect the popular CommonJS extension `module.exports`. */
        var moduleExports = freeModule && freeModule.exports === freeExports;

        /** Detect free variable `process` from Node.js. */
        var freeProcess = moduleExports && freeGlobal.process;

        /** Used to access faster Node.js helpers. */
        var nodeUtil = function () {
          try {
            // Use `util.types` for Node.js 10+.
            var types = freeModule && freeModule.require && freeModule.require('util').types;
            if (types) {
              return types;
            }

            // Legacy `process.binding('util')` for Node.js < 10.
            return freeProcess && freeProcess.binding && freeProcess.binding('util');
          } catch (e) {}
        }();

        /* Node.js helper references. */
        var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

        /**
         * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function safeGet(object, key) {
          if (key === 'constructor' && typeof object[key] === 'function') {
            return;
          }
          if (key == '__proto__') {
            return;
          }
          return object[key];
        }

        /** Used for built-in method references. */
        var objectProto$6 = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

        /**
         * Assigns `value` to `key` of `object` if the existing value is not equivalent
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }

        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property identifiers to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @param {Function} [customizer] The function to customize copied values.
         * @returns {Object} Returns `object`.
         */
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1,
            length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = undefined;
            if (newValue === undefined) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }

        /**
         * The base implementation of `_.times` without support for iteratee shorthands
         * or max array length checks.
         *
         * @private
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         */
        function baseTimes(n, iteratee) {
          var index = -1,
            result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }

        /** Used as references for various `Number` constants. */
        var MAX_SAFE_INTEGER = 9007199254740991;

        /** Used to detect unsigned integer values. */
        var reIsUint = /^(?:0|[1-9]\d*)$/;

        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }

        /** Used for built-in method references. */
        var objectProto$5 = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

        /**
         * Creates an array of the enumerable property names of the array-like `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @param {boolean} inherited Specify returning inherited property names.
         * @returns {Array} Returns the array of property names.
         */
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value),
            isArg = !isArr && isArguments(value),
            isBuff = !isArr && !isArg && isBuffer(value),
            isType = !isArr && !isArg && !isBuff && isTypedArray(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result = skipIndexes ? baseTimes(value.length, String) : [],
            length = result.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && (
            // Safari 9 has enumerable `arguments.length` in strict mode.
            key == 'length' ||
            // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == 'offset' || key == 'parent') ||
            // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
            // Skip index properties.
            isIndex(key, length)))) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * This function is like
         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * except that it includes inherited enumerable properties.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function nativeKeysIn(object) {
          var result = [];
          if (object != null) {
            for (var key in Object(object)) {
              result.push(key);
            }
          }
          return result;
        }

        /** Used for built-in method references. */
        var objectProto$4 = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

        /**
         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object),
            result = [];
          for (var key in object) {
            if (!(key == 'constructor' && (isProto || !hasOwnProperty$3.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }

        /**
         * Converts `value` to a plain object flattening inherited enumerable string
         * keyed properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }

        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key),
            srcValue = safeGet(source, key),
            stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
          var isCommon = newValue === undefined;
          if (isCommon) {
            var isArr = isArray(srcValue),
              isBuff = !isArr && isBuffer(srcValue),
              isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack['delete'](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }

        /**
         * The base implementation of `_.merge` without support for multiple sources.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function (srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;
              if (newValue === undefined) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }

        /**
         * This method returns the first argument it receives.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'a': 1 };
         *
         * console.log(_.identity(object) === object);
         * // => true
         */
        function identity(value) {
          return value;
        }

        /**
         * A faster alternative to `Function#apply`, this function invokes `func`
         * with the `this` binding of `thisArg` and the arguments of `args`.
         *
         * @private
         * @param {Function} func The function to invoke.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} args The arguments to invoke `func` with.
         * @returns {*} Returns the result of `func`.
         */
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeMax$1 = Math.max;

        /**
         * A specialized version of `baseRest` which transforms the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @param {Function} transform The rest array transform.
         * @returns {Function} Returns the new function.
         */
        function overRest(func, start, transform) {
          start = nativeMax$1(start === undefined ? func.length - 1 : start, 0);
          return function () {
            var args = arguments,
              index = -1,
              length = nativeMax$1(args.length - start, 0),
              array = Array(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform(array);
            return apply(func, this, otherArgs);
          };
        }

        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new constant function.
         * @example
         *
         * var objects = _.times(2, _.constant({ 'a': 1 }));
         *
         * console.log(objects);
         * // => [{ 'a': 1 }, { 'a': 1 }]
         *
         * console.log(objects[0] === objects[1]);
         * // => true
         */
        function constant(value) {
          return function () {
            return value;
          };
        }

        /**
         * The base implementation of `setToString` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var baseSetToString = !defineProperty ? identity : function (func, string) {
          return defineProperty(func, 'toString', {
            'configurable': true,
            'enumerable': false,
            'value': constant(string),
            'writable': true
          });
        };

        /** Used to detect hot functions by number of calls within a span of milliseconds. */
        var HOT_COUNT = 800,
          HOT_SPAN = 16;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeNow = Date.now;

        /**
         * Creates a function that'll short out and invoke `identity` instead
         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
         * milliseconds.
         *
         * @private
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new shortable function.
         */
        function shortOut(func) {
          var count = 0,
            lastCalled = 0;
          return function () {
            var stamp = nativeNow(),
              remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined, arguments);
          };
        }

        /**
         * Sets the `toString` method of `func` to return `string`.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var setToString = shortOut(baseSetToString);

        /**
         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         */
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + '');
        }

        /**
         * Checks if the given arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
         *  else `false`.
         */
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
            return eq(object[index], value);
          }
          return false;
        }

        /**
         * Creates a function like `_.assign`.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner(assigner) {
          return baseRest(function (object, sources) {
            var index = -1,
              length = sources.length,
              customizer = length > 1 ? sources[length - 1] : undefined,
              guard = length > 2 ? sources[2] : undefined;
            customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            object = Object(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }

        /**
         * This method is like `_.assign` except that it recursively merges own and
         * inherited enumerable string keyed properties of source objects into the
         * destination object. Source properties that resolve to `undefined` are
         * skipped if a destination value exists. Array and plain object properties
         * are merged recursively. Other objects and value types are overridden by
         * assignment. Source objects are applied from left to right. Subsequent
         * sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {
         *   'a': [{ 'b': 2 }, { 'd': 4 }]
         * };
         *
         * var other = {
         *   'a': [{ 'c': 3 }, { 'e': 5 }]
         * };
         *
         * _.merge(object, other);
         * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
         */
        var merge = createAssigner(function (object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var Raised = function Raised(_ref) {
          var zDepth = _ref.zDepth,
            radius = _ref.radius,
            background = _ref.background,
            children = _ref.children,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles;
          var styles = _default$2(merge({
            'default': {
              wrap: {
                position: 'relative',
                display: 'inline-block'
              },
              content: {
                position: 'relative'
              },
              bg: {
                absolute: '0px 0px 0px 0px',
                boxShadow: '0 ' + zDepth + 'px ' + zDepth * 4 + 'px rgba(0,0,0,.24)',
                borderRadius: radius,
                background: background
              }
            },
            'zDepth-0': {
              bg: {
                boxShadow: 'none'
              }
            },
            'zDepth-1': {
              bg: {
                boxShadow: '0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)'
              }
            },
            'zDepth-2': {
              bg: {
                boxShadow: '0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)'
              }
            },
            'zDepth-3': {
              bg: {
                boxShadow: '0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)'
              }
            },
            'zDepth-4': {
              bg: {
                boxShadow: '0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)'
              }
            },
            'zDepth-5': {
              bg: {
                boxShadow: '0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)'
              }
            },
            'square': {
              bg: {
                borderRadius: '0'
              }
            },
            'circle': {
              bg: {
                borderRadius: '50%'
              }
            }
          }, passedStyles), {
            'zDepth-1': zDepth === 1
          });
          return React.createElement('div', {
            style: styles.wrap
          }, React.createElement('div', {
            style: styles.bg
          }), React.createElement('div', {
            style: styles.content
          }, children));
        };
        Raised.propTypes = {
          background: PropTypes.string,
          zDepth: PropTypes.oneOf([0, 1, 2, 3, 4, 5]),
          radius: PropTypes.number,
          styles: PropTypes.object
        };
        Raised.defaultProps = {
          background: '#fff',
          zDepth: 1,
          radius: 2,
          styles: {}
        };

        /**
         * Gets the timestamp of the number of milliseconds that have elapsed since
         * the Unix epoch (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Date
         * @returns {number} Returns the timestamp.
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => Logs the number of milliseconds it took for the deferred invocation.
         */
        var now = function now() {
          return root.Date.now();
        };

        /** Used to match a single whitespace character. */
        var reWhitespace = /\s/;

        /**
         * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
         * character of `string`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {number} Returns the index of the last non-whitespace character.
         */
        function trimmedEndIndex(string) {
          var index = string.length;
          while (index-- && reWhitespace.test(string.charAt(index))) {}
          return index;
        }

        /** Used to match leading whitespace. */
        var reTrimStart = /^\s+/;

        /**
         * The base implementation of `_.trim`.
         *
         * @private
         * @param {string} string The string to trim.
         * @returns {string} Returns the trimmed string.
         */
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
        }

        /** `Object#toString` result references. */
        var symbolTag$1 = '[object Symbol]';

        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */
        function isSymbol(value) {
          return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
        }

        /** Used as references for various `Number` constants. */
        var NAN = 0 / 0;

        /** Used to detect bad signed hexadecimal string values. */
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

        /** Used to detect binary string values. */
        var reIsBinary = /^0b[01]+$/i;

        /** Used to detect octal string values. */
        var reIsOctal = /^0o[0-7]+$/i;

        /** Built-in method references without a dependency on `root`. */
        var freeParseInt = parseInt;

        /**
         * Converts `value` to a number.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         * @example
         *
         * _.toNumber(3.2);
         * // => 3.2
         *
         * _.toNumber(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toNumber(Infinity);
         * // => Infinity
         *
         * _.toNumber('3.2');
         * // => 3.2
         */
        function toNumber(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
            value = isObject(other) ? other + '' : other;
          }
          if (typeof value != 'string') {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }

        /** Error message constants. */
        var FUNC_ERROR_TEXT$2 = 'Expected a function';

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeMax = Math.max,
          nativeMin = Math.min;

        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed `func` invocations and a `flush` method to immediately invoke them.
         * Provide `options` to indicate whether `func` should be invoked on the
         * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
         * with the last arguments provided to the debounced function. Subsequent
         * calls to the debounced function return the result of the last `func`
         * invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the debounced function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=false]
         *  Specify invoking on the leading edge of the timeout.
         * @param {number} [options.maxWait]
         *  The maximum time `func` is allowed to be delayed before it's invoked.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // Avoid costly calculations while the window size is in flux.
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // Invoke `sendMail` when clicked, debouncing subsequent calls.
         * jQuery(element).on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
         * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', debounced);
         *
         * // Cancel the trailing debounced invocation.
         * jQuery(window).on('popstate', debounced.cancel);
         */
        function debounce(func, wait, options) {
          var lastArgs,
            lastThis,
            maxWait,
            result,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT$2);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = 'maxWait' in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs,
              thisArg = lastThis;
            lastArgs = lastThis = undefined;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
          }
          function leadingEdge(time) {
            // Reset any `maxWait` timer.
            lastInvokeTime = time;
            // Start the timer for the trailing edge.
            timerId = setTimeout(timerExpired, wait);
            // Invoke the leading edge.
            return leading ? invokeFunc(time) : result;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime;

            // Either this is the first call, activity has stopped and we're at the
            // trailing edge, the system time has gone backwards and we're treating
            // it as the trailing edge, or we've hit the `maxWait` limit.
            return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            // Restart the timer.
            timerId = setTimeout(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined;

            // Only invoke if we have `lastArgs` which means `func` has been
            // debounced at least once.
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined;
            return result;
          }
          function cancel() {
            if (timerId !== undefined) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined;
          }
          function flush() {
            return timerId === undefined ? result : trailingEdge(now());
          }
          function debounced() {
            var time = now(),
              isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                // Handle invocations in a tight loop.
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }

        /** Error message constants. */
        var FUNC_ERROR_TEXT$1 = 'Expected a function';

        /**
         * Creates a throttled function that only invokes `func` at most once per
         * every `wait` milliseconds. The throttled function comes with a `cancel`
         * method to cancel delayed `func` invocations and a `flush` method to
         * immediately invoke them. Provide `options` to indicate whether `func`
         * should be invoked on the leading and/or trailing edge of the `wait`
         * timeout. The `func` is invoked with the last arguments provided to the
         * throttled function. Subsequent calls to the throttled function return the
         * result of the last `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the throttled function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.throttle` and `_.debounce`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to throttle.
         * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=true]
         *  Specify invoking on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new throttled function.
         * @example
         *
         * // Avoid excessively updating the position while scrolling.
         * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
         *
         * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
         * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
         * jQuery(element).on('click', throttled);
         *
         * // Cancel the trailing throttled invocation.
         * jQuery(window).on('popstate', throttled.cancel);
         */
        function throttle(func, wait, options) {
          var leading = true,
            trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT$1);
          }
          if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            'leading': leading,
            'maxWait': wait,
            'trailing': trailing
          });
        }
        var calculateChange = function calculateChange(e, hsl, container) {
          var _container$getBoundin = container.getBoundingClientRect(),
            containerWidth = _container$getBoundin.width,
            containerHeight = _container$getBoundin.height;
          var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
          var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
          var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
          var top = y - (container.getBoundingClientRect().top + window.pageYOffset);
          if (left < 0) {
            left = 0;
          } else if (left > containerWidth) {
            left = containerWidth;
          }
          if (top < 0) {
            top = 0;
          } else if (top > containerHeight) {
            top = containerHeight;
          }
          var saturation = left / containerWidth;
          var bright = 1 - top / containerHeight;
          return {
            h: hsl.h,
            s: saturation,
            v: bright,
            a: hsl.a,
            source: 'hsv'
          };
        };
        var _createClass$4 = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck$4(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$4(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$4(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Saturation = function (_ref) {
          _inherits$4(Saturation, _ref);
          function Saturation(props) {
            _classCallCheck$4(this, Saturation);
            var _this = _possibleConstructorReturn$4(this, (Saturation.__proto__ || Object.getPrototypeOf(Saturation)).call(this, props));
            _this.handleChange = function (e) {
              typeof _this.props.onChange === 'function' && _this.throttle(_this.props.onChange, calculateChange(e, _this.props.hsl, _this.container), e);
            };
            _this.handleMouseDown = function (e) {
              _this.handleChange(e);
              var renderWindow = _this.getContainerRenderWindow();
              renderWindow.addEventListener('mousemove', _this.handleChange);
              renderWindow.addEventListener('mouseup', _this.handleMouseUp);
            };
            _this.handleMouseUp = function () {
              _this.unbindEventListeners();
            };
            _this.throttle = throttle(function (fn, data, e) {
              fn(data, e);
            }, 50);
            return _this;
          }
          _createClass$4(Saturation, [{
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
              this.throttle.cancel();
              this.unbindEventListeners();
            }
          }, {
            key: 'getContainerRenderWindow',
            value: function getContainerRenderWindow() {
              var container = this.container;
              var renderWindow = window;
              while (!renderWindow.document.contains(container) && renderWindow.parent !== renderWindow) {
                renderWindow = renderWindow.parent;
              }
              return renderWindow;
            }
          }, {
            key: 'unbindEventListeners',
            value: function unbindEventListeners() {
              var renderWindow = this.getContainerRenderWindow();
              renderWindow.removeEventListener('mousemove', this.handleChange);
              renderWindow.removeEventListener('mouseup', this.handleMouseUp);
            }
          }, {
            key: 'render',
            value: function render() {
              var _this2 = this;
              var _ref2 = this.props.style || {},
                color = _ref2.color,
                white = _ref2.white,
                black = _ref2.black,
                pointer = _ref2.pointer,
                circle = _ref2.circle;
              var styles = _default$2({
                'default': {
                  color: {
                    absolute: '0px 0px 0px 0px',
                    background: 'hsl(' + this.props.hsl.h + ',100%, 50%)',
                    borderRadius: this.props.radius
                  },
                  white: {
                    absolute: '0px 0px 0px 0px',
                    borderRadius: this.props.radius
                  },
                  black: {
                    absolute: '0px 0px 0px 0px',
                    boxShadow: this.props.shadow,
                    borderRadius: this.props.radius
                  },
                  pointer: {
                    position: 'absolute',
                    top: -(this.props.hsv.v * 100) + 100 + '%',
                    left: this.props.hsv.s * 100 + '%',
                    cursor: 'default'
                  },
                  circle: {
                    width: '4px',
                    height: '4px',
                    boxShadow: '0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),\n            0 0 1px 2px rgba(0,0,0,.4)',
                    borderRadius: '50%',
                    cursor: 'hand',
                    transform: 'translate(-2px, -2px)'
                  }
                },
                'custom': {
                  color: color,
                  white: white,
                  black: black,
                  pointer: pointer,
                  circle: circle
                }
              }, {
                'custom': !!this.props.style
              });
              return React.createElement('div', {
                style: styles.color,
                ref: function ref(container) {
                  return _this2.container = container;
                },
                onMouseDown: this.handleMouseDown,
                onTouchMove: this.handleChange,
                onTouchStart: this.handleChange
              }, React.createElement('style', null, '\n          .saturation-white {\n            background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0));\n            background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n          }\n          .saturation-black {\n            background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0));\n            background: linear-gradient(to top, #000, rgba(0,0,0,0));\n          }\n        '), React.createElement('div', {
                style: styles.white,
                className: 'saturation-white'
              }, React.createElement('div', {
                style: styles.black,
                className: 'saturation-black'
              }), React.createElement('div', {
                style: styles.pointer
              }, this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement('div', {
                style: styles.circle
              }))));
            }
          }]);
          return Saturation;
        }(reactExports.PureComponent || reactExports.Component);

        /**
         * A specialized version of `_.forEach` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */
        function arrayEach(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeKeys = overArg(Object.keys, Object);

        /** Used for built-in method references. */
        var objectProto$3 = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

        /**
         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result = [];
          for (var key in Object(object)) {
            if (hasOwnProperty$2.call(object, key) && key != 'constructor') {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }

        /**
         * The base implementation of `_.forOwn` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn(object, iteratee) {
          return object && baseFor(object, iteratee, keys);
        }

        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach(eachFunc, fromRight) {
          return function (collection, iteratee) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee);
            }
            var length = collection.length,
              index = -1,
              iterable = Object(collection);
            while (++index < length) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }

        /**
         * The base implementation of `_.forEach` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEach = createBaseEach(baseForOwn);

        /**
         * Casts `value` to `identity` if it's not a function.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Function} Returns cast function.
         */
        function castFunction(value) {
          return typeof value == 'function' ? value : identity;
        }

        /**
         * Iterates over elements of `collection` and invokes `iteratee` for each element.
         * The iteratee is invoked with three arguments: (value, index|key, collection).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * **Note:** As with other "Collections" methods, objects with a "length"
         * property are iterated like arrays. To avoid this behavior use `_.forIn`
         * or `_.forOwn` for object iteration.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @alias each
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @see _.forEachRight
         * @example
         *
         * _.forEach([1, 2], function(value) {
         *   console.log(value);
         * });
         * // => Logs `1` then `2`.
         *
         * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forEach(collection, iteratee) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, castFunction(iteratee));
        }

        // This file is autogenerated. It's used to publish ESM to npm.
        function _typeof(obj) {
          "@babel/helpers - typeof";

          return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          }, _typeof(obj);
        }

        // https://github.com/bgrins/TinyColor
        // Brian Grinstead, MIT License

        var trimLeft = /^\s+/;
        var trimRight = /\s+$/;
        function tinycolor(color, opts) {
          color = color ? color : "";
          opts = opts || {};

          // If input is already a tinycolor, return itself
          if (color instanceof tinycolor) {
            return color;
          }
          // If we are called as a function, call using new instead
          if (!(this instanceof tinycolor)) {
            return new tinycolor(color, opts);
          }
          var rgb = inputToRGB(color);
          this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
          this._gradientType = opts.gradientType;

          // Don't let the range of [0,255] come back in [0,1].
          // Potentially lose a little bit of precision here, but will fix issues where
          // .5 gets interpreted as half of the total, instead of half of 1
          // If it was supposed to be 128, this was already taken care of by `inputToRgb`
          if (this._r < 1) this._r = Math.round(this._r);
          if (this._g < 1) this._g = Math.round(this._g);
          if (this._b < 1) this._b = Math.round(this._b);
          this._ok = rgb.ok;
        }
        tinycolor.prototype = {
          isDark: function isDark() {
            return this.getBrightness() < 128;
          },
          isLight: function isLight() {
            return !this.isDark();
          },
          isValid: function isValid() {
            return this._ok;
          },
          getOriginalInput: function getOriginalInput() {
            return this._originalInput;
          },
          getFormat: function getFormat() {
            return this._format;
          },
          getAlpha: function getAlpha() {
            return this._a;
          },
          getBrightness: function getBrightness() {
            //http://www.w3.org/TR/AERT#color-contrast
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
          },
          getLuminance: function getLuminance() {
            //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
            var rgb = this.toRgb();
            var RsRGB, GsRGB, BsRGB, R, G, B;
            RsRGB = rgb.r / 255;
            GsRGB = rgb.g / 255;
            BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) R = RsRGB / 12.92;else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            if (GsRGB <= 0.03928) G = GsRGB / 12.92;else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            if (BsRGB <= 0.03928) B = BsRGB / 12.92;else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
            return 0.2126 * R + 0.7152 * G + 0.0722 * B;
          },
          setAlpha: function setAlpha(value) {
            this._a = boundAlpha(value);
            this._roundA = Math.round(100 * this._a) / 100;
            return this;
          },
          toHsv: function toHsv() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            return {
              h: hsv.h * 360,
              s: hsv.s,
              v: hsv.v,
              a: this._a
            };
          },
          toHsvString: function toHsvString() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            var h = Math.round(hsv.h * 360),
              s = Math.round(hsv.s * 100),
              v = Math.round(hsv.v * 100);
            return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
          },
          toHsl: function toHsl() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            return {
              h: hsl.h * 360,
              s: hsl.s,
              l: hsl.l,
              a: this._a
            };
          },
          toHslString: function toHslString() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            var h = Math.round(hsl.h * 360),
              s = Math.round(hsl.s * 100),
              l = Math.round(hsl.l * 100);
            return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
          },
          toHex: function toHex(allow3Char) {
            return rgbToHex(this._r, this._g, this._b, allow3Char);
          },
          toHexString: function toHexString(allow3Char) {
            return "#" + this.toHex(allow3Char);
          },
          toHex8: function toHex8(allow4Char) {
            return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
          },
          toHex8String: function toHex8String(allow4Char) {
            return "#" + this.toHex8(allow4Char);
          },
          toRgb: function toRgb() {
            return {
              r: Math.round(this._r),
              g: Math.round(this._g),
              b: Math.round(this._b),
              a: this._a
            };
          },
          toRgbString: function toRgbString() {
            return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
          },
          toPercentageRgb: function toPercentageRgb() {
            return {
              r: Math.round(bound01(this._r, 255) * 100) + "%",
              g: Math.round(bound01(this._g, 255) * 100) + "%",
              b: Math.round(bound01(this._b, 255) * 100) + "%",
              a: this._a
            };
          },
          toPercentageRgbString: function toPercentageRgbString() {
            return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
          },
          toName: function toName() {
            if (this._a === 0) {
              return "transparent";
            }
            if (this._a < 1) {
              return false;
            }
            return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
          },
          toFilter: function toFilter(secondColor) {
            var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
            var secondHex8String = hex8String;
            var gradientType = this._gradientType ? "GradientType = 1, " : "";
            if (secondColor) {
              var s = tinycolor(secondColor);
              secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
            }
            return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
          },
          toString: function toString(format) {
            var formatSet = !!format;
            format = format || this._format;
            var formattedString = false;
            var hasAlpha = this._a < 1 && this._a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
            if (needsAlphaFormat) {
              // Special case for "transparent", all other non-alpha formats
              // will return rgba when there is transparency.
              if (format === "name" && this._a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
              formattedString = this.toHexString();
            }
            if (format === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format === "name") {
              formattedString = this.toName();
            }
            if (format === "hsl") {
              formattedString = this.toHslString();
            }
            if (format === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          },
          clone: function clone() {
            return tinycolor(this.toString());
          },
          _applyModification: function _applyModification(fn, args) {
            var color = fn.apply(null, [this].concat([].slice.call(args)));
            this._r = color._r;
            this._g = color._g;
            this._b = color._b;
            this.setAlpha(color._a);
            return this;
          },
          lighten: function lighten() {
            return this._applyModification(_lighten, arguments);
          },
          brighten: function brighten() {
            return this._applyModification(_brighten, arguments);
          },
          darken: function darken() {
            return this._applyModification(_darken, arguments);
          },
          desaturate: function desaturate() {
            return this._applyModification(_desaturate, arguments);
          },
          saturate: function saturate() {
            return this._applyModification(_saturate, arguments);
          },
          greyscale: function greyscale() {
            return this._applyModification(_greyscale, arguments);
          },
          spin: function spin() {
            return this._applyModification(_spin, arguments);
          },
          _applyCombination: function _applyCombination(fn, args) {
            return fn.apply(null, [this].concat([].slice.call(args)));
          },
          analogous: function analogous() {
            return this._applyCombination(_analogous, arguments);
          },
          complement: function complement() {
            return this._applyCombination(_complement, arguments);
          },
          monochromatic: function monochromatic() {
            return this._applyCombination(_monochromatic, arguments);
          },
          splitcomplement: function splitcomplement() {
            return this._applyCombination(_splitcomplement, arguments);
          },
          // Disabled until https://github.com/bgrins/TinyColor/issues/254
          // polyad: function (number) {
          //   return this._applyCombination(polyad, [number]);
          // },
          triad: function triad() {
            return this._applyCombination(polyad, [3]);
          },
          tetrad: function tetrad() {
            return this._applyCombination(polyad, [4]);
          }
        };

        // If input is an object, force 1 into "1.0" to handle ratios properly
        // String input requires "1.0" as input, so 1 will be treated as 1
        tinycolor.fromRatio = function (color, opts) {
          if (_typeof(color) == "object") {
            var newColor = {};
            for (var i in color) {
              if (color.hasOwnProperty(i)) {
                if (i === "a") {
                  newColor[i] = color[i];
                } else {
                  newColor[i] = convertToPercentage(color[i]);
                }
              }
            }
            color = newColor;
          }
          return tinycolor(color, opts);
        };

        // Given a string or object, convert that input to RGB
        // Possible string inputs:
        //
        //     "red"
        //     "#f00" or "f00"
        //     "#ff0000" or "ff0000"
        //     "#ff000000" or "ff000000"
        //     "rgb 255 0 0" or "rgb (255, 0, 0)"
        //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
        //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
        //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
        //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
        //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
        //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
        //
        function inputToRGB(color) {
          var rgb = {
            r: 0,
            g: 0,
            b: 0
          };
          var a = 1;
          var s = null;
          var v = null;
          var l = null;
          var ok = false;
          var format = false;
          if (typeof color == "string") {
            color = stringInputToObject(color);
          }
          if (_typeof(color) == "object") {
            if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
              rgb = rgbToRgb(color.r, color.g, color.b);
              ok = true;
              format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
            } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
              s = convertToPercentage(color.s);
              v = convertToPercentage(color.v);
              rgb = hsvToRgb(color.h, s, v);
              ok = true;
              format = "hsv";
            } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
              s = convertToPercentage(color.s);
              l = convertToPercentage(color.l);
              rgb = hslToRgb(color.h, s, l);
              ok = true;
              format = "hsl";
            }
            if (color.hasOwnProperty("a")) {
              a = color.a;
            }
          }
          a = boundAlpha(a);
          return {
            ok: ok,
            format: color.format || format,
            r: Math.min(255, Math.max(rgb.r, 0)),
            g: Math.min(255, Math.max(rgb.g, 0)),
            b: Math.min(255, Math.max(rgb.b, 0)),
            a: a
          };
        }

        // Conversion Functions
        // --------------------

        // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
        // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

        // `rgbToRgb`
        // Handle bounds / percentage checking to conform to CSS color spec
        // <http://www.w3.org/TR/css3-color/>
        // *Assumes:* r, g, b in [0, 255] or [0, 1]
        // *Returns:* { r, g, b } in [0, 255]
        function rgbToRgb(r, g, b) {
          return {
            r: bound01(r, 255) * 255,
            g: bound01(g, 255) * 255,
            b: bound01(b, 255) * 255
          };
        }

        // `rgbToHsl`
        // Converts an RGB color value to HSL.
        // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
        // *Returns:* { h, s, l } in [0,1]
        function rgbToHsl(r, g, b) {
          r = bound01(r, 255);
          g = bound01(g, 255);
          b = bound01(b, 255);
          var max = Math.max(r, g, b),
            min = Math.min(r, g, b);
          var h,
            s,
            l = (max + min) / 2;
          if (max == min) {
            h = s = 0; // achromatic
          } else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return {
            h: h,
            s: s,
            l: l
          };
        }

        // `hslToRgb`
        // Converts an HSL color value to RGB.
        // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
        // *Returns:* { r, g, b } in the set [0, 255]
        function hslToRgb(h, s, l) {
          var r, g, b;
          h = bound01(h, 360);
          s = bound01(s, 100);
          l = bound01(l, 100);
          function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          }
          if (s === 0) {
            r = g = b = l; // achromatic
          } else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }
          return {
            r: r * 255,
            g: g * 255,
            b: b * 255
          };
        }

        // `rgbToHsv`
        // Converts an RGB color value to HSV
        // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
        // *Returns:* { h, s, v } in [0,1]
        function rgbToHsv(r, g, b) {
          r = bound01(r, 255);
          g = bound01(g, 255);
          b = bound01(b, 255);
          var max = Math.max(r, g, b),
            min = Math.min(r, g, b);
          var h,
            s,
            v = max;
          var d = max - min;
          s = max === 0 ? 0 : d / max;
          if (max == min) {
            h = 0; // achromatic
          } else {
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return {
            h: h,
            s: s,
            v: v
          };
        }

        // `hsvToRgb`
        // Converts an HSV color value to RGB.
        // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
        // *Returns:* { r, g, b } in the set [0, 255]
        function hsvToRgb(h, s, v) {
          h = bound01(h, 360) * 6;
          s = bound01(s, 100);
          v = bound01(v, 100);
          var i = Math.floor(h),
            f = h - i,
            p = v * (1 - s),
            q = v * (1 - f * s),
            t = v * (1 - (1 - f) * s),
            mod = i % 6,
            r = [v, q, p, p, t, v][mod],
            g = [t, v, v, q, p, p][mod],
            b = [p, p, t, v, v, q][mod];
          return {
            r: r * 255,
            g: g * 255,
            b: b * 255
          };
        }

        // `rgbToHex`
        // Converts an RGB color to hex
        // Assumes r, g, and b are contained in the set [0, 255]
        // Returns a 3 or 6 character hex
        function rgbToHex(r, g, b, allow3Char) {
          var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];

          // Return a 3 character hex if possible
          if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
          }
          return hex.join("");
        }

        // `rgbaToHex`
        // Converts an RGBA color plus alpha transparency to hex
        // Assumes r, g, b are contained in the set [0, 255] and
        // a in [0, 1]. Returns a 4 or 8 character rgba hex
        function rgbaToHex(r, g, b, a, allow4Char) {
          var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];

          // Return a 4 character hex if possible
          if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
          }
          return hex.join("");
        }

        // `rgbaToArgbHex`
        // Converts an RGBA color to an ARGB Hex8 string
        // Rarely used, but required for "toFilter()"
        function rgbaToArgbHex(r, g, b, a) {
          var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
          return hex.join("");
        }

        // `equals`
        // Can be called with any tinycolor input
        tinycolor.equals = function (color1, color2) {
          if (!color1 || !color2) return false;
          return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
        };
        tinycolor.random = function () {
          return tinycolor.fromRatio({
            r: Math.random(),
            g: Math.random(),
            b: Math.random()
          });
        };

        // Modification Functions
        // ----------------------
        // Thanks to less.js for some of the basics here
        // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

        function _desaturate(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.s -= amount / 100;
          hsl.s = clamp01(hsl.s);
          return tinycolor(hsl);
        }
        function _saturate(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.s += amount / 100;
          hsl.s = clamp01(hsl.s);
          return tinycolor(hsl);
        }
        function _greyscale(color) {
          return tinycolor(color).desaturate(100);
        }
        function _lighten(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.l += amount / 100;
          hsl.l = clamp01(hsl.l);
          return tinycolor(hsl);
        }
        function _brighten(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var rgb = tinycolor(color).toRgb();
          rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
          rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
          rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
          return tinycolor(rgb);
        }
        function _darken(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.l -= amount / 100;
          hsl.l = clamp01(hsl.l);
          return tinycolor(hsl);
        }

        // Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
        // Values outside of this range will be wrapped into this range.
        function _spin(color, amount) {
          var hsl = tinycolor(color).toHsl();
          var hue = (hsl.h + amount) % 360;
          hsl.h = hue < 0 ? 360 + hue : hue;
          return tinycolor(hsl);
        }

        // Combination Functions
        // ---------------------
        // Thanks to jQuery xColor for some of the ideas behind these
        // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

        function _complement(color) {
          var hsl = tinycolor(color).toHsl();
          hsl.h = (hsl.h + 180) % 360;
          return tinycolor(hsl);
        }
        function polyad(color, number) {
          if (isNaN(number) || number <= 0) {
            throw new Error("Argument to polyad must be a positive number");
          }
          var hsl = tinycolor(color).toHsl();
          var result = [tinycolor(color)];
          var step = 360 / number;
          for (var i = 1; i < number; i++) {
            result.push(tinycolor({
              h: (hsl.h + i * step) % 360,
              s: hsl.s,
              l: hsl.l
            }));
          }
          return result;
        }
        function _splitcomplement(color) {
          var hsl = tinycolor(color).toHsl();
          var h = hsl.h;
          return [tinycolor(color), tinycolor({
            h: (h + 72) % 360,
            s: hsl.s,
            l: hsl.l
          }), tinycolor({
            h: (h + 216) % 360,
            s: hsl.s,
            l: hsl.l
          })];
        }
        function _analogous(color, results, slices) {
          results = results || 6;
          slices = slices || 30;
          var hsl = tinycolor(color).toHsl();
          var part = 360 / slices;
          var ret = [tinycolor(color)];
          for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(tinycolor(hsl));
          }
          return ret;
        }
        function _monochromatic(color, results) {
          results = results || 6;
          var hsv = tinycolor(color).toHsv();
          var h = hsv.h,
            s = hsv.s,
            v = hsv.v;
          var ret = [];
          var modification = 1 / results;
          while (results--) {
            ret.push(tinycolor({
              h: h,
              s: s,
              v: v
            }));
            v = (v + modification) % 1;
          }
          return ret;
        }

        // Utility Functions
        // ---------------------

        tinycolor.mix = function (color1, color2, amount) {
          amount = amount === 0 ? 0 : amount || 50;
          var rgb1 = tinycolor(color1).toRgb();
          var rgb2 = tinycolor(color2).toRgb();
          var p = amount / 100;
          var rgba = {
            r: (rgb2.r - rgb1.r) * p + rgb1.r,
            g: (rgb2.g - rgb1.g) * p + rgb1.g,
            b: (rgb2.b - rgb1.b) * p + rgb1.b,
            a: (rgb2.a - rgb1.a) * p + rgb1.a
          };
          return tinycolor(rgba);
        };

        // Readability Functions
        // ---------------------
        // <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

        // `contrast`
        // Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
        tinycolor.readability = function (color1, color2) {
          var c1 = tinycolor(color1);
          var c2 = tinycolor(color2);
          return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
        };

        // `isReadable`
        // Ensure that foreground and background color combinations meet WCAG2 guidelines.
        // The third argument is an optional Object.
        //      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
        //      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
        // If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

        // *Example*
        //    tinycolor.isReadable("#000", "#111") => false
        //    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
        tinycolor.isReadable = function (color1, color2, wcag2) {
          var readability = tinycolor.readability(color1, color2);
          var wcag2Parms, out;
          out = false;
          wcag2Parms = validateWCAG2Parms(wcag2);
          switch (wcag2Parms.level + wcag2Parms.size) {
            case "AAsmall":
            case "AAAlarge":
              out = readability >= 4.5;
              break;
            case "AAlarge":
              out = readability >= 3;
              break;
            case "AAAsmall":
              out = readability >= 7;
              break;
          }
          return out;
        };

        // `mostReadable`
        // Given a base color and a list of possible foreground or background
        // colors for that base, returns the most readable color.
        // Optionally returns Black or White if the most readable color is unreadable.
        // *Example*
        //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
        //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
        //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
        //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
        tinycolor.mostReadable = function (baseColor, colorList, args) {
          var bestColor = null;
          var bestScore = 0;
          var readability;
          var includeFallbackColors, level, size;
          args = args || {};
          includeFallbackColors = args.includeFallbackColors;
          level = args.level;
          size = args.size;
          for (var i = 0; i < colorList.length; i++) {
            readability = tinycolor.readability(baseColor, colorList[i]);
            if (readability > bestScore) {
              bestScore = readability;
              bestColor = tinycolor(colorList[i]);
            }
          }
          if (tinycolor.isReadable(baseColor, bestColor, {
            level: level,
            size: size
          }) || !includeFallbackColors) {
            return bestColor;
          } else {
            args.includeFallbackColors = false;
            return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
          }
        };

        // Big List of Colors
        // ------------------
        // <https://www.w3.org/TR/css-color-4/#named-colors>
        var names = tinycolor.names = {
          aliceblue: "f0f8ff",
          antiquewhite: "faebd7",
          aqua: "0ff",
          aquamarine: "7fffd4",
          azure: "f0ffff",
          beige: "f5f5dc",
          bisque: "ffe4c4",
          black: "000",
          blanchedalmond: "ffebcd",
          blue: "00f",
          blueviolet: "8a2be2",
          brown: "a52a2a",
          burlywood: "deb887",
          burntsienna: "ea7e5d",
          cadetblue: "5f9ea0",
          chartreuse: "7fff00",
          chocolate: "d2691e",
          coral: "ff7f50",
          cornflowerblue: "6495ed",
          cornsilk: "fff8dc",
          crimson: "dc143c",
          cyan: "0ff",
          darkblue: "00008b",
          darkcyan: "008b8b",
          darkgoldenrod: "b8860b",
          darkgray: "a9a9a9",
          darkgreen: "006400",
          darkgrey: "a9a9a9",
          darkkhaki: "bdb76b",
          darkmagenta: "8b008b",
          darkolivegreen: "556b2f",
          darkorange: "ff8c00",
          darkorchid: "9932cc",
          darkred: "8b0000",
          darksalmon: "e9967a",
          darkseagreen: "8fbc8f",
          darkslateblue: "483d8b",
          darkslategray: "2f4f4f",
          darkslategrey: "2f4f4f",
          darkturquoise: "00ced1",
          darkviolet: "9400d3",
          deeppink: "ff1493",
          deepskyblue: "00bfff",
          dimgray: "696969",
          dimgrey: "696969",
          dodgerblue: "1e90ff",
          firebrick: "b22222",
          floralwhite: "fffaf0",
          forestgreen: "228b22",
          fuchsia: "f0f",
          gainsboro: "dcdcdc",
          ghostwhite: "f8f8ff",
          gold: "ffd700",
          goldenrod: "daa520",
          gray: "808080",
          green: "008000",
          greenyellow: "adff2f",
          grey: "808080",
          honeydew: "f0fff0",
          hotpink: "ff69b4",
          indianred: "cd5c5c",
          indigo: "4b0082",
          ivory: "fffff0",
          khaki: "f0e68c",
          lavender: "e6e6fa",
          lavenderblush: "fff0f5",
          lawngreen: "7cfc00",
          lemonchiffon: "fffacd",
          lightblue: "add8e6",
          lightcoral: "f08080",
          lightcyan: "e0ffff",
          lightgoldenrodyellow: "fafad2",
          lightgray: "d3d3d3",
          lightgreen: "90ee90",
          lightgrey: "d3d3d3",
          lightpink: "ffb6c1",
          lightsalmon: "ffa07a",
          lightseagreen: "20b2aa",
          lightskyblue: "87cefa",
          lightslategray: "789",
          lightslategrey: "789",
          lightsteelblue: "b0c4de",
          lightyellow: "ffffe0",
          lime: "0f0",
          limegreen: "32cd32",
          linen: "faf0e6",
          magenta: "f0f",
          maroon: "800000",
          mediumaquamarine: "66cdaa",
          mediumblue: "0000cd",
          mediumorchid: "ba55d3",
          mediumpurple: "9370db",
          mediumseagreen: "3cb371",
          mediumslateblue: "7b68ee",
          mediumspringgreen: "00fa9a",
          mediumturquoise: "48d1cc",
          mediumvioletred: "c71585",
          midnightblue: "191970",
          mintcream: "f5fffa",
          mistyrose: "ffe4e1",
          moccasin: "ffe4b5",
          navajowhite: "ffdead",
          navy: "000080",
          oldlace: "fdf5e6",
          olive: "808000",
          olivedrab: "6b8e23",
          orange: "ffa500",
          orangered: "ff4500",
          orchid: "da70d6",
          palegoldenrod: "eee8aa",
          palegreen: "98fb98",
          paleturquoise: "afeeee",
          palevioletred: "db7093",
          papayawhip: "ffefd5",
          peachpuff: "ffdab9",
          peru: "cd853f",
          pink: "ffc0cb",
          plum: "dda0dd",
          powderblue: "b0e0e6",
          purple: "800080",
          rebeccapurple: "663399",
          red: "f00",
          rosybrown: "bc8f8f",
          royalblue: "4169e1",
          saddlebrown: "8b4513",
          salmon: "fa8072",
          sandybrown: "f4a460",
          seagreen: "2e8b57",
          seashell: "fff5ee",
          sienna: "a0522d",
          silver: "c0c0c0",
          skyblue: "87ceeb",
          slateblue: "6a5acd",
          slategray: "708090",
          slategrey: "708090",
          snow: "fffafa",
          springgreen: "00ff7f",
          steelblue: "4682b4",
          tan: "d2b48c",
          teal: "008080",
          thistle: "d8bfd8",
          tomato: "ff6347",
          turquoise: "40e0d0",
          violet: "ee82ee",
          wheat: "f5deb3",
          white: "fff",
          whitesmoke: "f5f5f5",
          yellow: "ff0",
          yellowgreen: "9acd32"
        };

        // Make it easy to access colors via `hexNames[hex]`
        var hexNames = tinycolor.hexNames = flip(names);

        // Utilities
        // ---------

        // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
        function flip(o) {
          var flipped = {};
          for (var i in o) {
            if (o.hasOwnProperty(i)) {
              flipped[o[i]] = i;
            }
          }
          return flipped;
        }

        // Return a valid alpha value [0,1] with all invalid values being set to 1
        function boundAlpha(a) {
          a = parseFloat(a);
          if (isNaN(a) || a < 0 || a > 1) {
            a = 1;
          }
          return a;
        }

        // Take input from [0, n] and return it as [0, 1]
        function bound01(n, max) {
          if (isOnePointZero(n)) n = "100%";
          var processPercent = isPercentage(n);
          n = Math.min(max, Math.max(0, parseFloat(n)));

          // Automatically convert percentage into number
          if (processPercent) {
            n = parseInt(n * max, 10) / 100;
          }

          // Handle floating point rounding errors
          if (Math.abs(n - max) < 0.000001) {
            return 1;
          }

          // Convert into [0, 1] range if it isn't already
          return n % max / parseFloat(max);
        }

        // Force a number between 0 and 1
        function clamp01(val) {
          return Math.min(1, Math.max(0, val));
        }

        // Parse a base-16 hex value into a base-10 integer
        function parseIntFromHex(val) {
          return parseInt(val, 16);
        }

        // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
        // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
        function isOnePointZero(n) {
          return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
        }

        // Check to see if string passed in is a percentage
        function isPercentage(n) {
          return typeof n === "string" && n.indexOf("%") != -1;
        }

        // Force a hex value to have 2 characters
        function pad2(c) {
          return c.length == 1 ? "0" + c : "" + c;
        }

        // Replace a decimal with it's percentage value
        function convertToPercentage(n) {
          if (n <= 1) {
            n = n * 100 + "%";
          }
          return n;
        }

        // Converts a decimal to a hex value
        function convertDecimalToHex(d) {
          return Math.round(parseFloat(d) * 255).toString(16);
        }
        // Converts a hex value to a decimal
        function convertHexToDecimal(h) {
          return parseIntFromHex(h) / 255;
        }
        var matchers = function () {
          // <http://www.w3.org/TR/css3-values/#integers>
          var CSS_INTEGER = "[-\\+]?\\d+%?";

          // <http://www.w3.org/TR/css3-values/#number-value>
          var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

          // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
          var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

          // Actual matching.
          // Parentheses and commas are optional, but not required.
          // Whitespace can take the place of commas or opening paren
          var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
          var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
          return {
            CSS_UNIT: new RegExp(CSS_UNIT),
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
          };
        }();

        // `isValidCSSUnit`
        // Take in a single string / number and check to see if it looks like a CSS unit
        // (see `matchers` above for definition).
        function isValidCSSUnit(color) {
          return !!matchers.CSS_UNIT.exec(color);
        }

        // `stringInputToObject`
        // Permissive string parsing.  Take in a number of formats, and output an object
        // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
        function stringInputToObject(color) {
          color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
          var named = false;
          if (names[color]) {
            color = names[color];
            named = true;
          } else if (color == "transparent") {
            return {
              r: 0,
              g: 0,
              b: 0,
              a: 0,
              format: "name"
            };
          }

          // Try to match string input using regular expressions.
          // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
          // Just return an object and let the conversion functions handle that.
          // This way the result will be the same whether the tinycolor is initialized with string or object.
          var match;
          if (match = matchers.rgb.exec(color)) {
            return {
              r: match[1],
              g: match[2],
              b: match[3]
            };
          }
          if (match = matchers.rgba.exec(color)) {
            return {
              r: match[1],
              g: match[2],
              b: match[3],
              a: match[4]
            };
          }
          if (match = matchers.hsl.exec(color)) {
            return {
              h: match[1],
              s: match[2],
              l: match[3]
            };
          }
          if (match = matchers.hsla.exec(color)) {
            return {
              h: match[1],
              s: match[2],
              l: match[3],
              a: match[4]
            };
          }
          if (match = matchers.hsv.exec(color)) {
            return {
              h: match[1],
              s: match[2],
              v: match[3]
            };
          }
          if (match = matchers.hsva.exec(color)) {
            return {
              h: match[1],
              s: match[2],
              v: match[3],
              a: match[4]
            };
          }
          if (match = matchers.hex8.exec(color)) {
            return {
              r: parseIntFromHex(match[1]),
              g: parseIntFromHex(match[2]),
              b: parseIntFromHex(match[3]),
              a: convertHexToDecimal(match[4]),
              format: named ? "name" : "hex8"
            };
          }
          if (match = matchers.hex6.exec(color)) {
            return {
              r: parseIntFromHex(match[1]),
              g: parseIntFromHex(match[2]),
              b: parseIntFromHex(match[3]),
              format: named ? "name" : "hex"
            };
          }
          if (match = matchers.hex4.exec(color)) {
            return {
              r: parseIntFromHex(match[1] + "" + match[1]),
              g: parseIntFromHex(match[2] + "" + match[2]),
              b: parseIntFromHex(match[3] + "" + match[3]),
              a: convertHexToDecimal(match[4] + "" + match[4]),
              format: named ? "name" : "hex8"
            };
          }
          if (match = matchers.hex3.exec(color)) {
            return {
              r: parseIntFromHex(match[1] + "" + match[1]),
              g: parseIntFromHex(match[2] + "" + match[2]),
              b: parseIntFromHex(match[3] + "" + match[3]),
              format: named ? "name" : "hex"
            };
          }
          return false;
        }
        function validateWCAG2Parms(parms) {
          // return valid WCAG2 parms for isReadable.
          // If input parms are invalid, return {"level":"AA", "size":"small"}
          var level, size;
          parms = parms || {
            level: "AA",
            size: "small"
          };
          level = (parms.level || "AA").toUpperCase();
          size = (parms.size || "small").toLowerCase();
          if (level !== "AA" && level !== "AAA") {
            level = "AA";
          }
          if (size !== "small" && size !== "large") {
            size = "small";
          }
          return {
            level: level,
            size: size
          };
        }
        var simpleCheckForValidColor = function simpleCheckForValidColor(data) {
          var keysToCheck = ['r', 'g', 'b', 'a', 'h', 's', 'l', 'v'];
          var checked = 0;
          var passed = 0;
          forEach(keysToCheck, function (letter) {
            if (data[letter]) {
              checked += 1;
              if (!isNaN(data[letter])) {
                passed += 1;
              }
              if (letter === 's' || letter === 'l') {
                var percentPatt = /^\d+%$/;
                if (percentPatt.test(data[letter])) {
                  passed += 1;
                }
              }
            }
          });
          return checked === passed ? data : false;
        };
        var toState = function toState(data, oldHue) {
          var color = data.hex ? tinycolor(data.hex) : tinycolor(data);
          var hsl = color.toHsl();
          var hsv = color.toHsv();
          var rgb = color.toRgb();
          var hex = color.toHex();
          if (hsl.s === 0) {
            hsl.h = oldHue || 0;
            hsv.h = oldHue || 0;
          }
          var transparent = hex === '000000' && rgb.a === 0;
          return {
            hsl: hsl,
            hex: transparent ? 'transparent' : '#' + hex,
            rgb: rgb,
            hsv: hsv,
            oldHue: data.h || oldHue || hsl.h,
            source: data.source
          };
        };
        var isValidHex = function isValidHex(hex) {
          if (hex === 'transparent') {
            return true;
          }
          // disable hex4 and hex8
          var lh = String(hex).charAt(0) === '#' ? 1 : 0;
          return hex.length !== 4 + lh && hex.length < 7 + lh && tinycolor(hex).isValid();
        };
        var getContrastingColor = function getContrastingColor(data) {
          if (!data) {
            return '#fff';
          }
          var col = toState(data);
          if (col.hex === 'transparent') {
            return 'rgba(0,0,0,0.4)';
          }
          var yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1000;
          return yiq >= 128 ? '#000' : '#fff';
        };
        var isvalidColorString = function isvalidColorString(string, type) {
          var stringWithoutDegree = string.replace('°', '');
          return tinycolor(type + ' (' + stringWithoutDegree + ')')._ok;
        };
        var _extends$8 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var _createClass$3 = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck$3(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$3(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$3(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var ColorWrap = function ColorWrap(Picker) {
          var ColorPicker = function (_ref) {
            _inherits$3(ColorPicker, _ref);
            function ColorPicker(props) {
              _classCallCheck$3(this, ColorPicker);
              var _this = _possibleConstructorReturn$3(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this));
              _this.handleChange = function (data, event) {
                var isValidColor = simpleCheckForValidColor(data);
                if (isValidColor) {
                  var colors = toState(data, data.h || _this.state.oldHue);
                  _this.setState(colors);
                  _this.props.onChangeComplete && _this.debounce(_this.props.onChangeComplete, colors, event);
                  _this.props.onChange && _this.props.onChange(colors, event);
                }
              };
              _this.handleSwatchHover = function (data, event) {
                var isValidColor = simpleCheckForValidColor(data);
                if (isValidColor) {
                  var colors = toState(data, data.h || _this.state.oldHue);
                  _this.props.onSwatchHover && _this.props.onSwatchHover(colors, event);
                }
              };
              _this.state = _extends$8({}, toState(props.color, 0));
              _this.debounce = debounce(function (fn, data, event) {
                fn(data, event);
              }, 100);
              return _this;
            }
            _createClass$3(ColorPicker, [{
              key: 'render',
              value: function render() {
                var optionalEvents = {};
                if (this.props.onSwatchHover) {
                  optionalEvents.onSwatchHover = this.handleSwatchHover;
                }
                return React.createElement(Picker, _extends$8({}, this.props, this.state, {
                  onChange: this.handleChange
                }, optionalEvents));
              }
            }], [{
              key: 'getDerivedStateFromProps',
              value: function getDerivedStateFromProps(nextProps, state) {
                return _extends$8({}, toState(nextProps.color, state.oldHue));
              }
            }]);
            return ColorPicker;
          }(reactExports.PureComponent || reactExports.Component);
          ColorPicker.propTypes = _extends$8({}, Picker.propTypes);
          ColorPicker.defaultProps = _extends$8({}, Picker.defaultProps, {
            color: {
              h: 250,
              s: 0.50,
              l: 0.20,
              a: 1
            }
          });
          return ColorPicker;
        };
        var _extends$7 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var _createClass$2 = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck$2(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$2(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$2(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var handleFocus = function handleFocus(Component) {
          var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';
          return function (_React$Component) {
            _inherits$2(Focus, _React$Component);
            function Focus() {
              var _ref;
              var _temp, _this, _ret;
              _classCallCheck$2(this, Focus);
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return _ret = (_temp = (_this = _possibleConstructorReturn$2(this, (_ref = Focus.__proto__ || Object.getPrototypeOf(Focus)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
                focus: false
              }, _this.handleFocus = function () {
                return _this.setState({
                  focus: true
                });
              }, _this.handleBlur = function () {
                return _this.setState({
                  focus: false
                });
              }, _temp), _possibleConstructorReturn$2(_this, _ret);
            }
            _createClass$2(Focus, [{
              key: 'render',
              value: function render() {
                return React.createElement(Span, {
                  onFocus: this.handleFocus,
                  onBlur: this.handleBlur
                }, React.createElement(Component, _extends$7({}, this.props, this.state)));
              }
            }]);
            return Focus;
          }(React.Component);
        };
        var _extends$6 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var ENTER = 13;
        var Swatch = function Swatch(_ref) {
          var color = _ref.color,
            style = _ref.style,
            _ref$onClick = _ref.onClick,
            onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
            onHover = _ref.onHover,
            _ref$title = _ref.title,
            title = _ref$title === undefined ? color : _ref$title,
            children = _ref.children,
            focus = _ref.focus,
            _ref$focusStyle = _ref.focusStyle,
            focusStyle = _ref$focusStyle === undefined ? {} : _ref$focusStyle;
          var transparent = color === 'transparent';
          var styles = _default$2({
            default: {
              swatch: _extends$6({
                background: color,
                height: '100%',
                width: '100%',
                cursor: 'pointer',
                position: 'relative',
                outline: 'none'
              }, style, focus ? focusStyle : {})
            }
          });
          var handleClick = function handleClick(e) {
            return onClick(color, e);
          };
          var handleKeyDown = function handleKeyDown(e) {
            return e.keyCode === ENTER && onClick(color, e);
          };
          var handleHover = function handleHover(e) {
            return onHover(color, e);
          };
          var optionalEvents = {};
          if (onHover) {
            optionalEvents.onMouseOver = handleHover;
          }
          return React.createElement('div', _extends$6({
            style: styles.swatch,
            onClick: handleClick,
            title: title,
            tabIndex: 0,
            onKeyDown: handleKeyDown
          }, optionalEvents), children, transparent && React.createElement(Checkboard, {
            borderRadius: styles.swatch.borderRadius,
            boxShadow: 'inset 0 0 0 1px rgba(0,0,0,0.1)'
          }));
        };
        const Swatch$1 = handleFocus(Swatch);
        var AlphaPointer = function AlphaPointer(_ref) {
          var direction = _ref.direction;
          var styles = _default$2({
            'default': {
              picker: {
                width: '18px',
                height: '18px',
                borderRadius: '50%',
                transform: 'translate(-9px, -1px)',
                backgroundColor: 'rgb(248, 248, 248)',
                boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
              }
            },
            'vertical': {
              picker: {
                transform: 'translate(-3px, -9px)'
              }
            }
          }, {
            vertical: direction === 'vertical'
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        var _extends$5 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var AlphaPicker = function AlphaPicker(_ref) {
          var rgb = _ref.rgb,
            hsl = _ref.hsl,
            width = _ref.width,
            height = _ref.height,
            onChange = _ref.onChange,
            direction = _ref.direction,
            style = _ref.style,
            renderers = _ref.renderers,
            pointer = _ref.pointer,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$2({
            'default': {
              picker: {
                position: 'relative',
                width: width,
                height: height
              },
              alpha: {
                radius: '2px',
                style: style
              }
            }
          });
          return React.createElement('div', {
            style: styles.picker,
            className: 'alpha-picker ' + className
          }, React.createElement(Alpha, _extends$5({}, styles.alpha, {
            rgb: rgb,
            hsl: hsl,
            pointer: pointer,
            renderers: renderers,
            onChange: onChange,
            direction: direction
          })));
        };
        AlphaPicker.defaultProps = {
          width: '316px',
          height: '16px',
          direction: 'horizontal',
          pointer: AlphaPointer
        };
        ColorWrap(AlphaPicker);

        /**
         * A specialized version of `_.map` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function arrayMap(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }

        /** Used to stand-in for `undefined` hash values. */
        var HASH_UNDEFINED = '__lodash_hash_undefined__';

        /**
         * Adds `value` to the array cache.
         *
         * @private
         * @name add
         * @memberOf SetCache
         * @alias push
         * @param {*} value The value to cache.
         * @returns {Object} Returns the cache instance.
         */
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }

        /**
         * Checks if `value` is in the array cache.
         *
         * @private
         * @name has
         * @memberOf SetCache
         * @param {*} value The value to search for.
         * @returns {number} Returns `true` if `value` is found, else `false`.
         */
        function setCacheHas(value) {
          return this.__data__.has(value);
        }

        /**
         *
         * Creates an array cache object to store unique values.
         *
         * @private
         * @constructor
         * @param {Array} [values] The values to cache.
         */
        function SetCache(values) {
          var index = -1,
            length = values == null ? 0 : values.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values[index]);
          }
        }

        // Add methods to `SetCache`.
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;

        /**
         * A specialized version of `_.some` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function arraySome(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }

        /**
         * Checks if a `cache` value for `key` exists.
         *
         * @private
         * @param {Object} cache The cache to query.
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function cacheHas(cache, key) {
          return cache.has(key);
        }

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$5 = 1,
          COMPARE_UNORDERED_FLAG$3 = 2;

        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `array` and `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
            arrLength = array.length,
            othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          // Check that cyclic values are equal.
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1,
            result = true,
            seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : undefined;
          stack.set(array, other);
          stack.set(other, array);

          // Ignore non-index properties.
          while (++index < arrLength) {
            var arrValue = array[index],
              othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (seen) {
              if (!arraySome(other, function (othValue, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result = false;
              break;
            }
          }
          stack['delete'](array);
          stack['delete'](other);
          return result;
        }

        /**
         * Converts `map` to its key-value pairs.
         *
         * @private
         * @param {Object} map The map to convert.
         * @returns {Array} Returns the key-value pairs.
         */
        function mapToArray(map) {
          var index = -1,
            result = Array(map.size);
          map.forEach(function (value, key) {
            result[++index] = [key, value];
          });
          return result;
        }

        /**
         * Converts `set` to an array of its values.
         *
         * @private
         * @param {Object} set The set to convert.
         * @returns {Array} Returns the values.
         */
        function setToArray(set) {
          var index = -1,
            result = Array(set.size);
          set.forEach(function (value) {
            result[++index] = value;
          });
          return result;
        }

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$4 = 1,
          COMPARE_UNORDERED_FLAG$2 = 2;

        /** `Object#toString` result references. */
        var boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          mapTag$1 = '[object Map]',
          numberTag = '[object Number]',
          regexpTag = '[object RegExp]',
          setTag$1 = '[object Set]',
          stringTag = '[object String]',
          symbolTag = '[object Symbol]';
        var arrayBufferTag = '[object ArrayBuffer]',
          dataViewTag$1 = '[object DataView]';

        /** Used to convert symbols to primitives and strings. */
        var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
          symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag$1:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              // Coerce booleans to `1` or `0` and dates to milliseconds.
              // Invalid dates are coerced to `NaN`.
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              // Coerce regexes to strings and treat strings, primitives and objects,
              // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
              // for more details.
              return object == other + '';
            case mapTag$1:
              var convert = mapToArray;
            case setTag$1:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              // Assume cyclic values are equal.
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG$2;

              // Recursively compare objects (susceptible to call stack limits).
              stack.set(object, other);
              var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack['delete'](object);
              return result;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }

        /**
         * Appends the elements of `values` to `array`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to append.
         * @returns {Array} Returns `array`.
         */
        function arrayPush(array, values) {
          var index = -1,
            length = values.length,
            offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }

        /**
         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @param {Function} symbolsFunc The function to get the symbols of `object`.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }

        /**
         * A specialized version of `_.filter` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function arrayFilter(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }

        /**
         * This method returns a new empty array.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Array} Returns the new empty array.
         * @example
         *
         * var arrays = _.times(2, _.stubArray);
         *
         * console.log(arrays);
         * // => [[], []]
         *
         * console.log(arrays[0] === arrays[1]);
         * // => false
         */
        function stubArray() {
          return [];
        }

        /** Used for built-in method references. */
        var objectProto$2 = Object.prototype;

        /** Built-in value references. */
        var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeGetSymbols = Object.getOwnPropertySymbols;

        /**
         * Creates an array of the own enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
          if (object == null) {
            return [];
          }
          object = Object(object);
          return arrayFilter(nativeGetSymbols(object), function (symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };

        /**
         * Creates an array of own enumerable property names and symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$3 = 1;

        /** Used for built-in method references. */
        var objectProto$1 = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
            objProps = getAllKeys(object),
            objLength = objProps.length,
            othProps = getAllKeys(other),
            othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
              return false;
            }
          }
          // Check that cyclic values are equal.
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
              othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            // Recursively compare objects (susceptible to call stack limits).
            if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (result && !skipCtor) {
            var objCtor = object.constructor,
              othCtor = other.constructor;

            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack['delete'](object);
          stack['delete'](other);
          return result;
        }

        /* Built-in method references that are verified to be native. */
        var DataView$1 = getNative(root, 'DataView');

        /* Built-in method references that are verified to be native. */
        var Promise$1 = getNative(root, 'Promise');

        /* Built-in method references that are verified to be native. */
        var Set$1 = getNative(root, 'Set');

        /* Built-in method references that are verified to be native. */
        var WeakMap$1 = getNative(root, 'WeakMap');

        /** `Object#toString` result references. */
        var mapTag = '[object Map]',
          objectTag$1 = '[object Object]',
          promiseTag = '[object Promise]',
          setTag = '[object Set]',
          weakMapTag = '[object WeakMap]';
        var dataViewTag = '[object DataView]';

        /** Used to detect maps, sets, and weakmaps. */
        var dataViewCtorString = toSource(DataView$1),
          mapCtorString = toSource(Map$1),
          promiseCtorString = toSource(Promise$1),
          setCtorString = toSource(Set$1),
          weakMapCtorString = toSource(WeakMap$1);

        /**
         * Gets the `toStringTag` of `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        var getTag = baseGetTag;

        // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
        if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag(new Map$1()) != mapTag || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
          getTag = function getTag(value) {
            var result = baseGetTag(value),
              Ctor = result == objectTag$1 ? value.constructor : undefined,
              ctorString = Ctor ? toSource(Ctor) : '';
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result;
          };
        }

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$2 = 1;

        /** `Object#toString` result references. */
        var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          objectTag = '[object Object]';

        /** Used for built-in method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} [stack] Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object),
            othIsArr = isArray(other),
            objTag = objIsArr ? arrayTag : getTag(object),
            othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag,
            othIsObj = othTag == objectTag,
            isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
              othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object,
                othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }

        /**
         * The base implementation of `_.isEqual` which supports partial comparisons
         * and tracks traversed objects.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Unordered comparison
         *  2 - Partial comparison
         * @param {Function} [customizer] The function to customize comparisons.
         * @param {Object} [stack] Tracks traversed `value` and `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$1 = 1,
          COMPARE_UNORDERED_FLAG$1 = 2;

        /**
         * The base implementation of `_.isMatch` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Array} matchData The property names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length,
            length = index;
          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (index--) {
            var data = matchData[index];
            if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
              objValue = object[key],
              srcValue = data[1];
            if (data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              var result;
              if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
                return false;
              }
            }
          }
          return true;
        }

        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }

        /**
         * Gets the property names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData(object) {
          var result = keys(object),
            length = result.length;
          while (length--) {
            var key = result[length],
              value = object[key];
            result[length] = [key, value, isStrictComparable(value)];
          }
          return result;
        }

        /**
         * A specialized version of `matchesProperty` for source values suitable
         * for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function matchesStrictComparable(key, srcValue) {
          return function (object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
          };
        }

        /**
         * The base implementation of `_.matches` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function (object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }

        /** Used to match property names within property paths. */
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/;

        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
        }

        /** Error message constants. */
        var FUNC_ERROR_TEXT = 'Expected a function';

        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided, it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is used as the map cache key. The `func`
         * is invoked with the `this` binding of the memoized function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the
         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `clear`, `delete`, `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoized function.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         * var other = { 'c': 3, 'd': 4 };
         *
         * var values = _.memoize(_.values);
         * values(object);
         * // => [1, 2]
         *
         * values(other);
         * // => [3, 4]
         *
         * object.a = 2;
         * values(object);
         * // => [1, 2]
         *
         * // Modify the result cache.
         * values.cache.set(object, ['a', 'b']);
         * values(object);
         * // => ['a', 'b']
         *
         * // Replace `_.memoize.Cache`.
         * _.memoize.Cache = WeakMap;
         */
        function memoize(func, resolver) {
          if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var _memoized2 = function memoized() {
            var args = arguments,
              key = resolver ? resolver.apply(this, args) : args[0],
              cache = _memoized2.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            _memoized2.cache = cache.set(key, result) || cache;
            return result;
          };
          _memoized2.cache = new (memoize.Cache || MapCache)();
          return _memoized2;
        }

        // Expose `MapCache`.
        memoize.Cache = MapCache;

        /** Used as the maximum memoize cache size. */
        var MAX_MEMOIZE_SIZE = 500;

        /**
         * A specialized version of `_.memoize` which clears the memoized function's
         * cache when it exceeds `MAX_MEMOIZE_SIZE`.
         *
         * @private
         * @param {Function} func The function to have its output memoized.
         * @returns {Function} Returns the new memoized function.
         */
        function memoizeCapped(func) {
          var result = memoize(func, function (key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result.cache;
          return result;
        }

        /** Used to match property names within property paths. */
        var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

        /** Used to match backslashes in property paths. */
        var reEscapeChar = /\\(\\)?/g;

        /**
         * Converts `string` to a property path array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the property path array.
         */
        var stringToPath = memoizeCapped(function (string) {
          var result = [];
          if (string.charCodeAt(0) === 46 /* . */) {
            result.push('');
          }
          string.replace(rePropName, function (match, number, quote, subString) {
            result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
          });
          return result;
        });

        /** Used as references for various `Number` constants. */
        var INFINITY$1 = 1 / 0;

        /** Used to convert symbols to primitives and strings. */
        var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
          symbolToString = symbolProto ? symbolProto.toString : undefined;

        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString(value) {
          // Exit early for strings to avoid a performance hit in some environments.
          if (typeof value == 'string') {
            return value;
          }
          if (isArray(value)) {
            // Recursively convert values (susceptible to call stack limits).
            return arrayMap(value, baseToString) + '';
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : '';
          }
          var result = value + '';
          return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
        }

        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */
        function toString(value) {
          return value == null ? '' : baseToString(value);
        }

        /**
         * Casts `value` to a path array if it's not one.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {Object} [object] The object to query keys on.
         * @returns {Array} Returns the cast property path array.
         */
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }

        /** Used as references for various `Number` constants. */
        var INFINITY = 1 / 0;

        /**
         * Converts `value` to a string key if it's not a string or symbol.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {string|symbol} Returns the key.
         */
        function toKey(value) {
          if (typeof value == 'string' || isSymbol(value)) {
            return value;
          }
          var result = value + '';
          return result == '0' && 1 / value == -INFINITY ? '-0' : result;
        }

        /**
         * The base implementation of `_.get` without support for default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @returns {*} Returns the resolved value.
         */
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0,
            length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined;
        }

        /**
         * Gets the value at `path` of `object`. If the resolved value is
         * `undefined`, the `defaultValue` is returned in its place.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.get(object, 'a[0].b.c');
         * // => 3
         *
         * _.get(object, ['a', '0', 'b', 'c']);
         * // => 3
         *
         * _.get(object, 'a.b.c', 'default');
         * // => 'default'
         */
        function get(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet(object, path);
          return result === undefined ? defaultValue : result;
        }

        /**
         * The base implementation of `_.hasIn` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHasIn(object, key) {
          return object != null && key in Object(object);
        }

        /**
         * Checks if `path` exists on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @param {Function} hasFunc The function to check properties.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         */
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1,
            length = path.length,
            result = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result || ++index != length) {
            return result;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }

        /**
         * Checks if `path` is a direct or inherited property of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.hasIn(object, 'a');
         * // => true
         *
         * _.hasIn(object, 'a.b');
         * // => true
         *
         * _.hasIn(object, ['a', 'b']);
         * // => true
         *
         * _.hasIn(object, 'b');
         * // => false
         */
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG = 1,
          COMPARE_UNORDERED_FLAG = 2;

        /**
         * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function (object) {
            var objValue = get(object, path);
            return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }

        /**
         * The base implementation of `_.property` without support for deep paths.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @returns {Function} Returns the new accessor function.
         */
        function baseProperty(key) {
          return function (object) {
            return object == null ? undefined : object[key];
          };
        }

        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         */
        function basePropertyDeep(path) {
          return function (object) {
            return baseGet(object, path);
          };
        }

        /**
         * Creates a function that returns the value at `path` of a given object.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': 2 } },
         *   { 'a': { 'b': 1 } }
         * ];
         *
         * _.map(objects, _.property('a.b'));
         * // => [2, 1]
         *
         * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
         * // => [1, 2]
         */
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }

        /**
         * The base implementation of `_.iteratee`.
         *
         * @private
         * @param {*} [value=_.identity] The value to convert to an iteratee.
         * @returns {Function} Returns the iteratee.
         */
        function baseIteratee(value) {
          // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
          // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
          if (typeof value == 'function') {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == 'object') {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }

        /**
         * The base implementation of `_.map` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap(collection, iteratee) {
          var index = -1,
            result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function (value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }

        /**
         * Creates an array of values by running each element in `collection` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
         * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
         * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
         * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * _.map([4, 8], square);
         * // => [16, 64]
         *
         * _.map({ 'a': 4, 'b': 8 }, square);
         * // => [16, 64] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map(collection, iteratee) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, baseIteratee(iteratee));
        }
        var BlockSwatches = function BlockSwatches(_ref) {
          var colors = _ref.colors,
            onClick = _ref.onClick,
            onSwatchHover = _ref.onSwatchHover;
          var styles = _default$2({
            'default': {
              swatches: {
                marginRight: '-10px'
              },
              swatch: {
                width: '22px',
                height: '22px',
                float: 'left',
                marginRight: '10px',
                marginBottom: '10px',
                borderRadius: '4px'
              },
              clear: {
                clear: 'both'
              }
            }
          });
          return React.createElement('div', {
            style: styles.swatches
          }, map(colors, function (c) {
            return React.createElement(Swatch$1, {
              key: c,
              color: c,
              style: styles.swatch,
              onClick: onClick,
              onHover: onSwatchHover,
              focusStyle: {
                boxShadow: '0 0 4px ' + c
              }
            });
          }), React.createElement('div', {
            style: styles.clear
          }));
        };
        var Block = function Block(_ref) {
          var onChange = _ref.onChange,
            onSwatchHover = _ref.onSwatchHover,
            hex = _ref.hex,
            colors = _ref.colors,
            width = _ref.width,
            triangle = _ref.triangle,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var transparent = hex === 'transparent';
          var handleChange = function handleChange(hexCode, e) {
            isValidHex(hexCode) && onChange({
              hex: hexCode,
              source: 'hex'
            }, e);
          };
          var styles = _default$2(merge({
            'default': {
              card: {
                width: width,
                background: '#fff',
                boxShadow: '0 1px rgba(0,0,0,.1)',
                borderRadius: '6px',
                position: 'relative'
              },
              head: {
                height: '110px',
                background: hex,
                borderRadius: '6px 6px 0 0',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                position: 'relative'
              },
              body: {
                padding: '10px'
              },
              label: {
                fontSize: '18px',
                color: getContrastingColor(hex),
                position: 'relative'
              },
              triangle: {
                width: '0px',
                height: '0px',
                borderStyle: 'solid',
                borderWidth: '0 10px 10px 10px',
                borderColor: 'transparent transparent ' + hex + ' transparent',
                position: 'absolute',
                top: '-10px',
                left: '50%',
                marginLeft: '-10px'
              },
              input: {
                width: '100%',
                fontSize: '12px',
                color: '#666',
                border: '0px',
                outline: 'none',
                height: '22px',
                boxShadow: 'inset 0 0 0 1px #ddd',
                borderRadius: '4px',
                padding: '0 7px',
                boxSizing: 'border-box'
              }
            },
            'hide-triangle': {
              triangle: {
                display: 'none'
              }
            }
          }, passedStyles), {
            'hide-triangle': triangle === 'hide'
          });
          return React.createElement('div', {
            style: styles.card,
            className: 'block-picker ' + className
          }, React.createElement('div', {
            style: styles.triangle
          }), React.createElement('div', {
            style: styles.head
          }, transparent && React.createElement(Checkboard, {
            borderRadius: '6px 6px 0 0'
          }), React.createElement('div', {
            style: styles.label
          }, hex)), React.createElement('div', {
            style: styles.body
          }, React.createElement(BlockSwatches, {
            colors: colors,
            onClick: handleChange,
            onSwatchHover: onSwatchHover
          }), React.createElement(EditableInput, {
            style: {
              input: styles.input
            },
            value: hex,
            onChange: handleChange
          })));
        };
        Block.propTypes = {
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          colors: PropTypes.arrayOf(PropTypes.string),
          triangle: PropTypes.oneOf(['top', 'hide']),
          styles: PropTypes.object
        };
        Block.defaultProps = {
          width: 170,
          colors: ['#D9E3F0', '#F47373', '#697689', '#37D67A', '#2CCCE4', '#555555', '#dce775', '#ff8a65', '#ba68c8'],
          triangle: 'top',
          styles: {}
        };
        ColorWrap(Block);
        var red = {
          "50": "#ffebee",
          "100": "#ffcdd2",
          "200": "#ef9a9a",
          "300": "#e57373",
          "400": "#ef5350",
          "500": "#f44336",
          "600": "#e53935",
          "700": "#d32f2f",
          "800": "#c62828",
          "900": "#b71c1c",
          "a100": "#ff8a80",
          "a200": "#ff5252",
          "a400": "#ff1744",
          "a700": "#d50000"
        };
        var pink = {
          "50": "#fce4ec",
          "100": "#f8bbd0",
          "200": "#f48fb1",
          "300": "#f06292",
          "400": "#ec407a",
          "500": "#e91e63",
          "600": "#d81b60",
          "700": "#c2185b",
          "800": "#ad1457",
          "900": "#880e4f",
          "a100": "#ff80ab",
          "a200": "#ff4081",
          "a400": "#f50057",
          "a700": "#c51162"
        };
        var purple = {
          "50": "#f3e5f5",
          "100": "#e1bee7",
          "200": "#ce93d8",
          "300": "#ba68c8",
          "400": "#ab47bc",
          "500": "#9c27b0",
          "600": "#8e24aa",
          "700": "#7b1fa2",
          "800": "#6a1b9a",
          "900": "#4a148c",
          "a100": "#ea80fc",
          "a200": "#e040fb",
          "a400": "#d500f9",
          "a700": "#aa00ff"
        };
        var deepPurple = {
          "50": "#ede7f6",
          "100": "#d1c4e9",
          "200": "#b39ddb",
          "300": "#9575cd",
          "400": "#7e57c2",
          "500": "#673ab7",
          "600": "#5e35b1",
          "700": "#512da8",
          "800": "#4527a0",
          "900": "#311b92",
          "a100": "#b388ff",
          "a200": "#7c4dff",
          "a400": "#651fff",
          "a700": "#6200ea"
        };
        var indigo = {
          "50": "#e8eaf6",
          "100": "#c5cae9",
          "200": "#9fa8da",
          "300": "#7986cb",
          "400": "#5c6bc0",
          "500": "#3f51b5",
          "600": "#3949ab",
          "700": "#303f9f",
          "800": "#283593",
          "900": "#1a237e",
          "a100": "#8c9eff",
          "a200": "#536dfe",
          "a400": "#3d5afe",
          "a700": "#304ffe"
        };
        var blue = {
          "50": "#e3f2fd",
          "100": "#bbdefb",
          "200": "#90caf9",
          "300": "#64b5f6",
          "400": "#42a5f5",
          "500": "#2196f3",
          "600": "#1e88e5",
          "700": "#1976d2",
          "800": "#1565c0",
          "900": "#0d47a1",
          "a100": "#82b1ff",
          "a200": "#448aff",
          "a400": "#2979ff",
          "a700": "#2962ff"
        };
        var lightBlue = {
          "50": "#e1f5fe",
          "100": "#b3e5fc",
          "200": "#81d4fa",
          "300": "#4fc3f7",
          "400": "#29b6f6",
          "500": "#03a9f4",
          "600": "#039be5",
          "700": "#0288d1",
          "800": "#0277bd",
          "900": "#01579b",
          "a100": "#80d8ff",
          "a200": "#40c4ff",
          "a400": "#00b0ff",
          "a700": "#0091ea"
        };
        var cyan = {
          "50": "#e0f7fa",
          "100": "#b2ebf2",
          "200": "#80deea",
          "300": "#4dd0e1",
          "400": "#26c6da",
          "500": "#00bcd4",
          "600": "#00acc1",
          "700": "#0097a7",
          "800": "#00838f",
          "900": "#006064",
          "a100": "#84ffff",
          "a200": "#18ffff",
          "a400": "#00e5ff",
          "a700": "#00b8d4"
        };
        var teal = {
          "50": "#e0f2f1",
          "100": "#b2dfdb",
          "200": "#80cbc4",
          "300": "#4db6ac",
          "400": "#26a69a",
          "500": "#009688",
          "600": "#00897b",
          "700": "#00796b",
          "800": "#00695c",
          "900": "#004d40",
          "a100": "#a7ffeb",
          "a200": "#64ffda",
          "a400": "#1de9b6",
          "a700": "#00bfa5"
        };
        var green = {
          "50": "#e8f5e9",
          "100": "#c8e6c9",
          "200": "#a5d6a7",
          "300": "#81c784",
          "400": "#66bb6a",
          "500": "#4caf50",
          "600": "#43a047",
          "700": "#388e3c",
          "800": "#2e7d32",
          "900": "#1b5e20",
          "a100": "#b9f6ca",
          "a200": "#69f0ae",
          "a400": "#00e676",
          "a700": "#00c853"
        };
        var lightGreen = {
          "50": "#f1f8e9",
          "100": "#dcedc8",
          "200": "#c5e1a5",
          "300": "#aed581",
          "400": "#9ccc65",
          "500": "#8bc34a",
          "600": "#7cb342",
          "700": "#689f38",
          "800": "#558b2f",
          "900": "#33691e",
          "a100": "#ccff90",
          "a200": "#b2ff59",
          "a400": "#76ff03",
          "a700": "#64dd17"
        };
        var lime = {
          "50": "#f9fbe7",
          "100": "#f0f4c3",
          "200": "#e6ee9c",
          "300": "#dce775",
          "400": "#d4e157",
          "500": "#cddc39",
          "600": "#c0ca33",
          "700": "#afb42b",
          "800": "#9e9d24",
          "900": "#827717",
          "a100": "#f4ff81",
          "a200": "#eeff41",
          "a400": "#c6ff00",
          "a700": "#aeea00"
        };
        var yellow = {
          "50": "#fffde7",
          "100": "#fff9c4",
          "200": "#fff59d",
          "300": "#fff176",
          "400": "#ffee58",
          "500": "#ffeb3b",
          "600": "#fdd835",
          "700": "#fbc02d",
          "800": "#f9a825",
          "900": "#f57f17",
          "a100": "#ffff8d",
          "a200": "#ffff00",
          "a400": "#ffea00",
          "a700": "#ffd600"
        };
        var amber = {
          "50": "#fff8e1",
          "100": "#ffecb3",
          "200": "#ffe082",
          "300": "#ffd54f",
          "400": "#ffca28",
          "500": "#ffc107",
          "600": "#ffb300",
          "700": "#ffa000",
          "800": "#ff8f00",
          "900": "#ff6f00",
          "a100": "#ffe57f",
          "a200": "#ffd740",
          "a400": "#ffc400",
          "a700": "#ffab00"
        };
        var orange = {
          "50": "#fff3e0",
          "100": "#ffe0b2",
          "200": "#ffcc80",
          "300": "#ffb74d",
          "400": "#ffa726",
          "500": "#ff9800",
          "600": "#fb8c00",
          "700": "#f57c00",
          "800": "#ef6c00",
          "900": "#e65100",
          "a100": "#ffd180",
          "a200": "#ffab40",
          "a400": "#ff9100",
          "a700": "#ff6d00"
        };
        var deepOrange = {
          "50": "#fbe9e7",
          "100": "#ffccbc",
          "200": "#ffab91",
          "300": "#ff8a65",
          "400": "#ff7043",
          "500": "#ff5722",
          "600": "#f4511e",
          "700": "#e64a19",
          "800": "#d84315",
          "900": "#bf360c",
          "a100": "#ff9e80",
          "a200": "#ff6e40",
          "a400": "#ff3d00",
          "a700": "#dd2c00"
        };
        var brown = {
          "50": "#efebe9",
          "100": "#d7ccc8",
          "200": "#bcaaa4",
          "300": "#a1887f",
          "400": "#8d6e63",
          "500": "#795548",
          "600": "#6d4c41",
          "700": "#5d4037",
          "800": "#4e342e",
          "900": "#3e2723"
        };
        var blueGrey = {
          "50": "#eceff1",
          "100": "#cfd8dc",
          "200": "#b0bec5",
          "300": "#90a4ae",
          "400": "#78909c",
          "500": "#607d8b",
          "600": "#546e7a",
          "700": "#455a64",
          "800": "#37474f",
          "900": "#263238"
        };
        var CircleSwatch = function CircleSwatch(_ref) {
          var color = _ref.color,
            onClick = _ref.onClick,
            onSwatchHover = _ref.onSwatchHover,
            hover = _ref.hover,
            active = _ref.active,
            circleSize = _ref.circleSize,
            circleSpacing = _ref.circleSpacing;
          var styles = _default$2({
            'default': {
              swatch: {
                width: circleSize,
                height: circleSize,
                marginRight: circleSpacing,
                marginBottom: circleSpacing,
                transform: 'scale(1)',
                transition: '100ms transform ease'
              },
              Swatch: {
                borderRadius: '50%',
                background: 'transparent',
                boxShadow: 'inset 0 0 0 ' + (circleSize / 2 + 1) + 'px ' + color,
                transition: '100ms box-shadow ease'
              }
            },
            'hover': {
              swatch: {
                transform: 'scale(1.2)'
              }
            },
            'active': {
              Swatch: {
                boxShadow: 'inset 0 0 0 3px ' + color
              }
            }
          }, {
            hover: hover,
            active: active
          });
          return React.createElement('div', {
            style: styles.swatch
          }, React.createElement(Swatch$1, {
            style: styles.Swatch,
            color: color,
            onClick: onClick,
            onHover: onSwatchHover,
            focusStyle: {
              boxShadow: styles.Swatch.boxShadow + ', 0 0 5px ' + color
            }
          }));
        };
        CircleSwatch.defaultProps = {
          circleSize: 28,
          circleSpacing: 14
        };
        const CircleSwatch$1 = handleHover(CircleSwatch);
        var Circle = function Circle(_ref) {
          var width = _ref.width,
            onChange = _ref.onChange,
            onSwatchHover = _ref.onSwatchHover,
            colors = _ref.colors,
            hex = _ref.hex,
            circleSize = _ref.circleSize,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            circleSpacing = _ref.circleSpacing,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$2(merge({
            'default': {
              card: {
                width: width,
                display: 'flex',
                flexWrap: 'wrap',
                marginRight: -circleSpacing,
                marginBottom: -circleSpacing
              }
            }
          }, passedStyles));
          var handleChange = function handleChange(hexCode, e) {
            return onChange({
              hex: hexCode,
              source: 'hex'
            }, e);
          };
          return React.createElement('div', {
            style: styles.card,
            className: 'circle-picker ' + className
          }, map(colors, function (c) {
            return React.createElement(CircleSwatch$1, {
              key: c,
              color: c,
              onClick: handleChange,
              onSwatchHover: onSwatchHover,
              active: hex === c.toLowerCase(),
              circleSize: circleSize,
              circleSpacing: circleSpacing
            });
          }));
        };
        Circle.propTypes = {
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          circleSize: PropTypes.number,
          circleSpacing: PropTypes.number,
          styles: PropTypes.object
        };
        Circle.defaultProps = {
          width: 252,
          circleSize: 28,
          circleSpacing: 14,
          colors: [red['500'], pink['500'], purple['500'], deepPurple['500'], indigo['500'], blue['500'], lightBlue['500'], cyan['500'], teal['500'], green['500'], lightGreen['500'], lime['500'], yellow['500'], amber['500'], orange['500'], deepOrange['500'], brown['500'], blueGrey['500']],
          styles: {}
        };
        ColorWrap(Circle);

        /**
         * Checks if `value` is `undefined`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
         * @example
         *
         * _.isUndefined(void 0);
         * // => true
         *
         * _.isUndefined(null);
         * // => false
         */
        function isUndefined(value) {
          return value === undefined;
        }
        var UnfoldMoreHorizontalIcon = {};
        Object.defineProperty(UnfoldMoreHorizontalIcon, "__esModule", {
          value: true
        });
        var _extends$4 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var _react$1 = reactExports;
        var _react2$1 = _interopRequireDefault$4(_react$1);
        function _interopRequireDefault$4(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        function _objectWithoutProperties$1(obj, keys) {
          var target = {};
          for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
          }
          return target;
        }
        var DEFAULT_SIZE$1 = 24;
        var _default$1 = UnfoldMoreHorizontalIcon.default = function (_ref) {
          var _ref$fill = _ref.fill,
            fill = _ref$fill === undefined ? 'currentColor' : _ref$fill,
            _ref$width = _ref.width,
            width = _ref$width === undefined ? DEFAULT_SIZE$1 : _ref$width,
            _ref$height = _ref.height,
            height = _ref$height === undefined ? DEFAULT_SIZE$1 : _ref$height,
            _ref$style = _ref.style,
            style = _ref$style === undefined ? {} : _ref$style,
            props = _objectWithoutProperties$1(_ref, ['fill', 'width', 'height', 'style']);
          return _react2$1.default.createElement('svg', _extends$4({
            viewBox: '0 0 ' + DEFAULT_SIZE$1 + ' ' + DEFAULT_SIZE$1,
            style: _extends$4({
              fill: fill,
              width: width,
              height: height
            }, style)
          }, props), _react2$1.default.createElement('path', {
            d: 'M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z'
          }));
        };
        var _createClass$1 = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck$1(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$1(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$1(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var ChromeFields = function (_React$Component) {
          _inherits$1(ChromeFields, _React$Component);
          function ChromeFields(props) {
            _classCallCheck$1(this, ChromeFields);
            var _this = _possibleConstructorReturn$1(this, (ChromeFields.__proto__ || Object.getPrototypeOf(ChromeFields)).call(this));
            _this.toggleViews = function () {
              if (_this.state.view === 'hex') {
                _this.setState({
                  view: 'rgb'
                });
              } else if (_this.state.view === 'rgb') {
                _this.setState({
                  view: 'hsl'
                });
              } else if (_this.state.view === 'hsl') {
                if (_this.props.hsl.a === 1) {
                  _this.setState({
                    view: 'hex'
                  });
                } else {
                  _this.setState({
                    view: 'rgb'
                  });
                }
              }
            };
            _this.handleChange = function (data, e) {
              if (data.hex) {
                isValidHex(data.hex) && _this.props.onChange({
                  hex: data.hex,
                  source: 'hex'
                }, e);
              } else if (data.r || data.g || data.b) {
                _this.props.onChange({
                  r: data.r || _this.props.rgb.r,
                  g: data.g || _this.props.rgb.g,
                  b: data.b || _this.props.rgb.b,
                  source: 'rgb'
                }, e);
              } else if (data.a) {
                if (data.a < 0) {
                  data.a = 0;
                } else if (data.a > 1) {
                  data.a = 1;
                }
                _this.props.onChange({
                  h: _this.props.hsl.h,
                  s: _this.props.hsl.s,
                  l: _this.props.hsl.l,
                  a: Math.round(data.a * 100) / 100,
                  source: 'rgb'
                }, e);
              } else if (data.h || data.s || data.l) {
                // Remove any occurances of '%'.
                if (typeof data.s === 'string' && data.s.includes('%')) {
                  data.s = data.s.replace('%', '');
                }
                if (typeof data.l === 'string' && data.l.includes('%')) {
                  data.l = data.l.replace('%', '');
                }

                // We store HSL as a unit interval so we need to override the 1 input to 0.01
                if (data.s == 1) {
                  data.s = 0.01;
                } else if (data.l == 1) {
                  data.l = 0.01;
                }
                _this.props.onChange({
                  h: data.h || _this.props.hsl.h,
                  s: Number(!isUndefined(data.s) ? data.s : _this.props.hsl.s),
                  l: Number(!isUndefined(data.l) ? data.l : _this.props.hsl.l),
                  source: 'hsl'
                }, e);
              }
            };
            _this.showHighlight = function (e) {
              e.currentTarget.style.background = '#eee';
            };
            _this.hideHighlight = function (e) {
              e.currentTarget.style.background = 'transparent';
            };
            if (props.hsl.a !== 1 && props.view === "hex") {
              _this.state = {
                view: "rgb"
              };
            } else {
              _this.state = {
                view: props.view
              };
            }
            return _this;
          }
          _createClass$1(ChromeFields, [{
            key: 'render',
            value: function render() {
              var _this2 = this;
              var styles = _default$2({
                'default': {
                  wrap: {
                    paddingTop: '16px',
                    display: 'flex'
                  },
                  fields: {
                    flex: '1',
                    display: 'flex',
                    marginLeft: '-6px'
                  },
                  field: {
                    paddingLeft: '6px',
                    width: '100%'
                  },
                  alpha: {
                    paddingLeft: '6px',
                    width: '100%'
                  },
                  toggle: {
                    width: '32px',
                    textAlign: 'right',
                    position: 'relative'
                  },
                  icon: {
                    marginRight: '-4px',
                    marginTop: '12px',
                    cursor: 'pointer',
                    position: 'relative'
                  },
                  iconHighlight: {
                    position: 'absolute',
                    width: '24px',
                    height: '28px',
                    background: '#eee',
                    borderRadius: '4px',
                    top: '10px',
                    left: '12px',
                    display: 'none'
                  },
                  input: {
                    fontSize: '11px',
                    color: '#333',
                    width: '100%',
                    borderRadius: '2px',
                    border: 'none',
                    boxShadow: 'inset 0 0 0 1px #dadada',
                    height: '21px',
                    textAlign: 'center'
                  },
                  label: {
                    textTransform: 'uppercase',
                    fontSize: '11px',
                    lineHeight: '11px',
                    color: '#969696',
                    textAlign: 'center',
                    display: 'block',
                    marginTop: '12px'
                  },
                  svg: {
                    fill: '#333',
                    width: '24px',
                    height: '24px',
                    border: '1px transparent solid',
                    borderRadius: '5px'
                  }
                },
                'disableAlpha': {
                  alpha: {
                    display: 'none'
                  }
                }
              }, this.props, this.state);
              var fields = void 0;
              if (this.state.view === 'hex') {
                fields = React.createElement('div', {
                  style: styles.fields,
                  className: 'flexbox-fix'
                }, React.createElement('div', {
                  style: styles.field
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'hex',
                  value: this.props.hex,
                  onChange: this.handleChange
                })));
              } else if (this.state.view === 'rgb') {
                fields = React.createElement('div', {
                  style: styles.fields,
                  className: 'flexbox-fix'
                }, React.createElement('div', {
                  style: styles.field
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'r',
                  value: this.props.rgb.r,
                  onChange: this.handleChange
                })), React.createElement('div', {
                  style: styles.field
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'g',
                  value: this.props.rgb.g,
                  onChange: this.handleChange
                })), React.createElement('div', {
                  style: styles.field
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'b',
                  value: this.props.rgb.b,
                  onChange: this.handleChange
                })), React.createElement('div', {
                  style: styles.alpha
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'a',
                  value: this.props.rgb.a,
                  arrowOffset: 0.01,
                  onChange: this.handleChange
                })));
              } else if (this.state.view === 'hsl') {
                fields = React.createElement('div', {
                  style: styles.fields,
                  className: 'flexbox-fix'
                }, React.createElement('div', {
                  style: styles.field
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'h',
                  value: Math.round(this.props.hsl.h),
                  onChange: this.handleChange
                })), React.createElement('div', {
                  style: styles.field
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 's',
                  value: Math.round(this.props.hsl.s * 100) + '%',
                  onChange: this.handleChange
                })), React.createElement('div', {
                  style: styles.field
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'l',
                  value: Math.round(this.props.hsl.l * 100) + '%',
                  onChange: this.handleChange
                })), React.createElement('div', {
                  style: styles.alpha
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'a',
                  value: this.props.hsl.a,
                  arrowOffset: 0.01,
                  onChange: this.handleChange
                })));
              }
              return React.createElement('div', {
                style: styles.wrap,
                className: 'flexbox-fix'
              }, fields, React.createElement('div', {
                style: styles.toggle
              }, React.createElement('div', {
                style: styles.icon,
                onClick: this.toggleViews,
                ref: function ref(icon) {
                  return _this2.icon = icon;
                }
              }, React.createElement(_default$1, {
                style: styles.svg,
                onMouseOver: this.showHighlight,
                onMouseEnter: this.showHighlight,
                onMouseOut: this.hideHighlight
              }))));
            }
          }], [{
            key: 'getDerivedStateFromProps',
            value: function getDerivedStateFromProps(nextProps, state) {
              if (nextProps.hsl.a !== 1 && state.view === 'hex') {
                return {
                  view: 'rgb'
                };
              }
              return null;
            }
          }]);
          return ChromeFields;
        }(React.Component);
        ChromeFields.defaultProps = {
          view: "hex"
        };
        var ChromePointer = function ChromePointer() {
          var styles = _default$2({
            'default': {
              picker: {
                width: '12px',
                height: '12px',
                borderRadius: '6px',
                transform: 'translate(-6px, -1px)',
                backgroundColor: 'rgb(248, 248, 248)',
                boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
              }
            }
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        var ChromePointerCircle = function ChromePointerCircle() {
          var styles = _default$2({
            'default': {
              picker: {
                width: '12px',
                height: '12px',
                borderRadius: '6px',
                boxShadow: 'inset 0 0 0 1px #fff',
                transform: 'translate(-6px, -6px)'
              }
            }
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        var Chrome = function Chrome(_ref) {
          var width = _ref.width,
            onChange = _ref.onChange,
            disableAlpha = _ref.disableAlpha,
            rgb = _ref.rgb,
            hsl = _ref.hsl,
            hsv = _ref.hsv,
            hex = _ref.hex,
            renderers = _ref.renderers,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className,
            defaultView = _ref.defaultView;
          var styles = _default$2(merge({
            'default': {
              picker: {
                width: width,
                background: '#fff',
                borderRadius: '2px',
                boxShadow: '0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)',
                boxSizing: 'initial',
                fontFamily: 'Menlo'
              },
              saturation: {
                width: '100%',
                paddingBottom: '55%',
                position: 'relative',
                borderRadius: '2px 2px 0 0',
                overflow: 'hidden'
              },
              Saturation: {
                radius: '2px 2px 0 0'
              },
              body: {
                padding: '16px 16px 12px'
              },
              controls: {
                display: 'flex'
              },
              color: {
                width: '32px'
              },
              swatch: {
                marginTop: '6px',
                width: '16px',
                height: '16px',
                borderRadius: '8px',
                position: 'relative',
                overflow: 'hidden'
              },
              active: {
                absolute: '0px 0px 0px 0px',
                borderRadius: '8px',
                boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.1)',
                background: 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', ' + rgb.a + ')',
                zIndex: '2'
              },
              toggles: {
                flex: '1'
              },
              hue: {
                height: '10px',
                position: 'relative',
                marginBottom: '8px'
              },
              Hue: {
                radius: '2px'
              },
              alpha: {
                height: '10px',
                position: 'relative'
              },
              Alpha: {
                radius: '2px'
              }
            },
            'disableAlpha': {
              color: {
                width: '22px'
              },
              alpha: {
                display: 'none'
              },
              hue: {
                marginBottom: '0px'
              },
              swatch: {
                width: '10px',
                height: '10px',
                marginTop: '0px'
              }
            }
          }, passedStyles), {
            disableAlpha: disableAlpha
          });
          return React.createElement('div', {
            style: styles.picker,
            className: 'chrome-picker ' + className
          }, React.createElement('div', {
            style: styles.saturation
          }, React.createElement(Saturation, {
            style: styles.Saturation,
            hsl: hsl,
            hsv: hsv,
            pointer: ChromePointerCircle,
            onChange: onChange
          })), React.createElement('div', {
            style: styles.body
          }, React.createElement('div', {
            style: styles.controls,
            className: 'flexbox-fix'
          }, React.createElement('div', {
            style: styles.color
          }, React.createElement('div', {
            style: styles.swatch
          }, React.createElement('div', {
            style: styles.active
          }), React.createElement(Checkboard, {
            renderers: renderers
          }))), React.createElement('div', {
            style: styles.toggles
          }, React.createElement('div', {
            style: styles.hue
          }, React.createElement(Hue, {
            style: styles.Hue,
            hsl: hsl,
            pointer: ChromePointer,
            onChange: onChange
          })), React.createElement('div', {
            style: styles.alpha
          }, React.createElement(Alpha, {
            style: styles.Alpha,
            rgb: rgb,
            hsl: hsl,
            pointer: ChromePointer,
            renderers: renderers,
            onChange: onChange
          })))), React.createElement(ChromeFields, {
            rgb: rgb,
            hsl: hsl,
            hex: hex,
            view: defaultView,
            onChange: onChange,
            disableAlpha: disableAlpha
          })));
        };
        Chrome.propTypes = {
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          disableAlpha: PropTypes.bool,
          styles: PropTypes.object,
          defaultView: PropTypes.oneOf(["hex", "rgb", "hsl"])
        };
        Chrome.defaultProps = {
          width: 225,
          disableAlpha: false,
          styles: {}
        };
        const ChromePicker = ColorWrap(Chrome);
        var CompactColor = function CompactColor(_ref) {
          var color = _ref.color,
            _ref$onClick = _ref.onClick,
            onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
            onSwatchHover = _ref.onSwatchHover,
            active = _ref.active;
          var styles = _default$2({
            'default': {
              color: {
                background: color,
                width: '15px',
                height: '15px',
                float: 'left',
                marginRight: '5px',
                marginBottom: '5px',
                position: 'relative',
                cursor: 'pointer'
              },
              dot: {
                absolute: '5px 5px 5px 5px',
                background: getContrastingColor(color),
                borderRadius: '50%',
                opacity: '0'
              }
            },
            'active': {
              dot: {
                opacity: '1'
              }
            },
            'color-#FFFFFF': {
              color: {
                boxShadow: 'inset 0 0 0 1px #ddd'
              },
              dot: {
                background: '#000'
              }
            },
            'transparent': {
              dot: {
                background: '#000'
              }
            }
          }, {
            active: active,
            'color-#FFFFFF': color === '#FFFFFF',
            'transparent': color === 'transparent'
          });
          return React.createElement(Swatch$1, {
            style: styles.color,
            color: color,
            onClick: onClick,
            onHover: onSwatchHover,
            focusStyle: {
              boxShadow: '0 0 4px ' + color
            }
          }, React.createElement('div', {
            style: styles.dot
          }));
        };
        var CompactFields = function CompactFields(_ref) {
          var hex = _ref.hex,
            rgb = _ref.rgb,
            onChange = _ref.onChange;
          var styles = _default$2({
            'default': {
              fields: {
                display: 'flex',
                paddingBottom: '6px',
                paddingRight: '5px',
                position: 'relative'
              },
              active: {
                position: 'absolute',
                top: '6px',
                left: '5px',
                height: '9px',
                width: '9px',
                background: hex
              },
              HEXwrap: {
                flex: '6',
                position: 'relative'
              },
              HEXinput: {
                width: '80%',
                padding: '0px',
                paddingLeft: '20%',
                border: 'none',
                outline: 'none',
                background: 'none',
                fontSize: '12px',
                color: '#333',
                height: '16px'
              },
              HEXlabel: {
                display: 'none'
              },
              RGBwrap: {
                flex: '3',
                position: 'relative'
              },
              RGBinput: {
                width: '70%',
                padding: '0px',
                paddingLeft: '30%',
                border: 'none',
                outline: 'none',
                background: 'none',
                fontSize: '12px',
                color: '#333',
                height: '16px'
              },
              RGBlabel: {
                position: 'absolute',
                top: '3px',
                left: '0px',
                lineHeight: '16px',
                textTransform: 'uppercase',
                fontSize: '12px',
                color: '#999'
              }
            }
          });
          var handleChange = function handleChange(data, e) {
            if (data.r || data.g || data.b) {
              onChange({
                r: data.r || rgb.r,
                g: data.g || rgb.g,
                b: data.b || rgb.b,
                source: 'rgb'
              }, e);
            } else {
              onChange({
                hex: data.hex,
                source: 'hex'
              }, e);
            }
          };
          return React.createElement('div', {
            style: styles.fields,
            className: 'flexbox-fix'
          }, React.createElement('div', {
            style: styles.active
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.HEXwrap,
              input: styles.HEXinput,
              label: styles.HEXlabel
            },
            label: 'hex',
            value: hex,
            onChange: handleChange
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'r',
            value: rgb.r,
            onChange: handleChange
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'g',
            value: rgb.g,
            onChange: handleChange
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'b',
            value: rgb.b,
            onChange: handleChange
          }));
        };
        var Compact = function Compact(_ref) {
          var onChange = _ref.onChange,
            onSwatchHover = _ref.onSwatchHover,
            colors = _ref.colors,
            hex = _ref.hex,
            rgb = _ref.rgb,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$2(merge({
            'default': {
              Compact: {
                background: '#f6f6f6',
                radius: '4px'
              },
              compact: {
                paddingTop: '5px',
                paddingLeft: '5px',
                boxSizing: 'initial',
                width: '240px'
              },
              clear: {
                clear: 'both'
              }
            }
          }, passedStyles));
          var handleChange = function handleChange(data, e) {
            if (data.hex) {
              isValidHex(data.hex) && onChange({
                hex: data.hex,
                source: 'hex'
              }, e);
            } else {
              onChange(data, e);
            }
          };
          return React.createElement(Raised, {
            style: styles.Compact,
            styles: passedStyles
          }, React.createElement('div', {
            style: styles.compact,
            className: 'compact-picker ' + className
          }, React.createElement('div', null, map(colors, function (c) {
            return React.createElement(CompactColor, {
              key: c,
              color: c,
              active: c.toLowerCase() === hex,
              onClick: handleChange,
              onSwatchHover: onSwatchHover
            });
          }), React.createElement('div', {
            style: styles.clear
          })), React.createElement(CompactFields, {
            hex: hex,
            rgb: rgb,
            onChange: handleChange
          })));
        };
        Compact.propTypes = {
          colors: PropTypes.arrayOf(PropTypes.string),
          styles: PropTypes.object
        };
        Compact.defaultProps = {
          colors: ['#4D4D4D', '#999999', '#FFFFFF', '#F44E3B', '#FE9200', '#FCDC00', '#DBDF00', '#A4DD00', '#68CCCA', '#73D8FF', '#AEA1FF', '#FDA1FF', '#333333', '#808080', '#cccccc', '#D33115', '#E27300', '#FCC400', '#B0BC00', '#68BC00', '#16A5A5', '#009CE0', '#7B64FF', '#FA28FF', '#000000', '#666666', '#B3B3B3', '#9F0500', '#C45100', '#FB9E00', '#808900', '#194D33', '#0C797D', '#0062B1', '#653294', '#AB149E'],
          styles: {}
        };
        ColorWrap(Compact);
        var GithubSwatch = function GithubSwatch(_ref) {
          var hover = _ref.hover,
            color = _ref.color,
            onClick = _ref.onClick,
            onSwatchHover = _ref.onSwatchHover;
          var hoverSwatch = {
            position: 'relative',
            zIndex: '2',
            outline: '2px solid #fff',
            boxShadow: '0 0 5px 2px rgba(0,0,0,0.25)'
          };
          var styles = _default$2({
            'default': {
              swatch: {
                width: '25px',
                height: '25px',
                fontSize: '0'
              }
            },
            'hover': {
              swatch: hoverSwatch
            }
          }, {
            hover: hover
          });
          return React.createElement('div', {
            style: styles.swatch
          }, React.createElement(Swatch$1, {
            color: color,
            onClick: onClick,
            onHover: onSwatchHover,
            focusStyle: hoverSwatch
          }));
        };
        const GithubSwatch$1 = handleHover(GithubSwatch);
        var Github = function Github(_ref) {
          var width = _ref.width,
            colors = _ref.colors,
            onChange = _ref.onChange,
            onSwatchHover = _ref.onSwatchHover,
            triangle = _ref.triangle,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$2(merge({
            'default': {
              card: {
                width: width,
                background: '#fff',
                border: '1px solid rgba(0,0,0,0.2)',
                boxShadow: '0 3px 12px rgba(0,0,0,0.15)',
                borderRadius: '4px',
                position: 'relative',
                padding: '5px',
                display: 'flex',
                flexWrap: 'wrap'
              },
              triangle: {
                position: 'absolute',
                border: '7px solid transparent',
                borderBottomColor: '#fff'
              },
              triangleShadow: {
                position: 'absolute',
                border: '8px solid transparent',
                borderBottomColor: 'rgba(0,0,0,0.15)'
              }
            },
            'hide-triangle': {
              triangle: {
                display: 'none'
              },
              triangleShadow: {
                display: 'none'
              }
            },
            'top-left-triangle': {
              triangle: {
                top: '-14px',
                left: '10px'
              },
              triangleShadow: {
                top: '-16px',
                left: '9px'
              }
            },
            'top-right-triangle': {
              triangle: {
                top: '-14px',
                right: '10px'
              },
              triangleShadow: {
                top: '-16px',
                right: '9px'
              }
            },
            'bottom-left-triangle': {
              triangle: {
                top: '35px',
                left: '10px',
                transform: 'rotate(180deg)'
              },
              triangleShadow: {
                top: '37px',
                left: '9px',
                transform: 'rotate(180deg)'
              }
            },
            'bottom-right-triangle': {
              triangle: {
                top: '35px',
                right: '10px',
                transform: 'rotate(180deg)'
              },
              triangleShadow: {
                top: '37px',
                right: '9px',
                transform: 'rotate(180deg)'
              }
            }
          }, passedStyles), {
            'hide-triangle': triangle === 'hide',
            'top-left-triangle': triangle === 'top-left',
            'top-right-triangle': triangle === 'top-right',
            'bottom-left-triangle': triangle === 'bottom-left',
            'bottom-right-triangle': triangle === 'bottom-right'
          });
          var handleChange = function handleChange(hex, e) {
            return onChange({
              hex: hex,
              source: 'hex'
            }, e);
          };
          return React.createElement('div', {
            style: styles.card,
            className: 'github-picker ' + className
          }, React.createElement('div', {
            style: styles.triangleShadow
          }), React.createElement('div', {
            style: styles.triangle
          }), map(colors, function (c) {
            return React.createElement(GithubSwatch$1, {
              color: c,
              key: c,
              onClick: handleChange,
              onSwatchHover: onSwatchHover
            });
          }));
        };
        Github.propTypes = {
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          colors: PropTypes.arrayOf(PropTypes.string),
          triangle: PropTypes.oneOf(['hide', 'top-left', 'top-right', 'bottom-left', 'bottom-right']),
          styles: PropTypes.object
        };
        Github.defaultProps = {
          width: 200,
          colors: ['#B80000', '#DB3E00', '#FCCB00', '#008B02', '#006B76', '#1273DE', '#004DCF', '#5300EB', '#EB9694', '#FAD0C3', '#FEF3BD', '#C1E1C5', '#BEDADC', '#C4DEF6', '#BED3F3', '#D4C4FB'],
          triangle: 'top-left',
          styles: {}
        };
        ColorWrap(Github);
        var SliderPointer$1 = function SliderPointer(_ref) {
          var direction = _ref.direction;
          var styles = _default$2({
            'default': {
              picker: {
                width: '18px',
                height: '18px',
                borderRadius: '50%',
                transform: 'translate(-9px, -1px)',
                backgroundColor: 'rgb(248, 248, 248)',
                boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
              }
            },
            'vertical': {
              picker: {
                transform: 'translate(-3px, -9px)'
              }
            }
          }, {
            vertical: direction === 'vertical'
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        var _extends$3 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var HuePicker = function HuePicker(_ref) {
          var width = _ref.width,
            height = _ref.height,
            onChange = _ref.onChange,
            hsl = _ref.hsl,
            direction = _ref.direction,
            pointer = _ref.pointer,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$2(merge({
            'default': {
              picker: {
                position: 'relative',
                width: width,
                height: height
              },
              hue: {
                radius: '2px'
              }
            }
          }, passedStyles));

          // Overwrite to provide pure hue color
          var handleChange = function handleChange(data) {
            return onChange({
              a: 1,
              h: data.h,
              l: 0.5,
              s: 1
            });
          };
          return React.createElement('div', {
            style: styles.picker,
            className: 'hue-picker ' + className
          }, React.createElement(Hue, _extends$3({}, styles.hue, {
            hsl: hsl,
            pointer: pointer,
            onChange: handleChange,
            direction: direction
          })));
        };
        HuePicker.propTypes = {
          styles: PropTypes.object
        };
        HuePicker.defaultProps = {
          width: '316px',
          height: '16px',
          direction: 'horizontal',
          pointer: SliderPointer$1,
          styles: {}
        };
        ColorWrap(HuePicker);
        var Material = function Material(_ref) {
          var onChange = _ref.onChange,
            hex = _ref.hex,
            rgb = _ref.rgb,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$2(merge({
            'default': {
              material: {
                width: '98px',
                height: '98px',
                padding: '16px',
                fontFamily: 'Roboto'
              },
              HEXwrap: {
                position: 'relative'
              },
              HEXinput: {
                width: '100%',
                marginTop: '12px',
                fontSize: '15px',
                color: '#333',
                padding: '0px',
                border: '0px',
                borderBottom: '2px solid ' + hex,
                outline: 'none',
                height: '30px'
              },
              HEXlabel: {
                position: 'absolute',
                top: '0px',
                left: '0px',
                fontSize: '11px',
                color: '#999999',
                textTransform: 'capitalize'
              },
              Hex: {
                style: {}
              },
              RGBwrap: {
                position: 'relative'
              },
              RGBinput: {
                width: '100%',
                marginTop: '12px',
                fontSize: '15px',
                color: '#333',
                padding: '0px',
                border: '0px',
                borderBottom: '1px solid #eee',
                outline: 'none',
                height: '30px'
              },
              RGBlabel: {
                position: 'absolute',
                top: '0px',
                left: '0px',
                fontSize: '11px',
                color: '#999999',
                textTransform: 'capitalize'
              },
              split: {
                display: 'flex',
                marginRight: '-10px',
                paddingTop: '11px'
              },
              third: {
                flex: '1',
                paddingRight: '10px'
              }
            }
          }, passedStyles));
          var handleChange = function handleChange(data, e) {
            if (data.hex) {
              isValidHex(data.hex) && onChange({
                hex: data.hex,
                source: 'hex'
              }, e);
            } else if (data.r || data.g || data.b) {
              onChange({
                r: data.r || rgb.r,
                g: data.g || rgb.g,
                b: data.b || rgb.b,
                source: 'rgb'
              }, e);
            }
          };
          return React.createElement(Raised, {
            styles: passedStyles
          }, React.createElement('div', {
            style: styles.material,
            className: 'material-picker ' + className
          }, React.createElement(EditableInput, {
            style: {
              wrap: styles.HEXwrap,
              input: styles.HEXinput,
              label: styles.HEXlabel
            },
            label: 'hex',
            value: hex,
            onChange: handleChange
          }), React.createElement('div', {
            style: styles.split,
            className: 'flexbox-fix'
          }, React.createElement('div', {
            style: styles.third
          }, React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'r',
            value: rgb.r,
            onChange: handleChange
          })), React.createElement('div', {
            style: styles.third
          }, React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'g',
            value: rgb.g,
            onChange: handleChange
          })), React.createElement('div', {
            style: styles.third
          }, React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'b',
            value: rgb.b,
            onChange: handleChange
          })))));
        };
        ColorWrap(Material);
        var PhotoshopPicker = function PhotoshopPicker(_ref) {
          var onChange = _ref.onChange,
            rgb = _ref.rgb,
            hsv = _ref.hsv,
            hex = _ref.hex;
          var styles = _default$2({
            'default': {
              fields: {
                paddingTop: '5px',
                paddingBottom: '9px',
                width: '80px',
                position: 'relative'
              },
              divider: {
                height: '5px'
              },
              RGBwrap: {
                position: 'relative'
              },
              RGBinput: {
                marginLeft: '40%',
                width: '40%',
                height: '18px',
                border: '1px solid #888888',
                boxShadow: 'inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC',
                marginBottom: '5px',
                fontSize: '13px',
                paddingLeft: '3px',
                marginRight: '10px'
              },
              RGBlabel: {
                left: '0px',
                top: '0px',
                width: '34px',
                textTransform: 'uppercase',
                fontSize: '13px',
                height: '18px',
                lineHeight: '22px',
                position: 'absolute'
              },
              HEXwrap: {
                position: 'relative'
              },
              HEXinput: {
                marginLeft: '20%',
                width: '80%',
                height: '18px',
                border: '1px solid #888888',
                boxShadow: 'inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC',
                marginBottom: '6px',
                fontSize: '13px',
                paddingLeft: '3px'
              },
              HEXlabel: {
                position: 'absolute',
                top: '0px',
                left: '0px',
                width: '14px',
                textTransform: 'uppercase',
                fontSize: '13px',
                height: '18px',
                lineHeight: '22px'
              },
              fieldSymbols: {
                position: 'absolute',
                top: '5px',
                right: '-7px',
                fontSize: '13px'
              },
              symbol: {
                height: '20px',
                lineHeight: '22px',
                paddingBottom: '7px'
              }
            }
          });
          var handleChange = function handleChange(data, e) {
            if (data['#']) {
              isValidHex(data['#']) && onChange({
                hex: data['#'],
                source: 'hex'
              }, e);
            } else if (data.r || data.g || data.b) {
              onChange({
                r: data.r || rgb.r,
                g: data.g || rgb.g,
                b: data.b || rgb.b,
                source: 'rgb'
              }, e);
            } else if (data.h || data.s || data.v) {
              onChange({
                h: data.h || hsv.h,
                s: data.s || hsv.s,
                v: data.v || hsv.v,
                source: 'hsv'
              }, e);
            }
          };
          return React.createElement('div', {
            style: styles.fields
          }, React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'h',
            value: Math.round(hsv.h),
            onChange: handleChange
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 's',
            value: Math.round(hsv.s * 100),
            onChange: handleChange
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'v',
            value: Math.round(hsv.v * 100),
            onChange: handleChange
          }), React.createElement('div', {
            style: styles.divider
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'r',
            value: rgb.r,
            onChange: handleChange
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'g',
            value: rgb.g,
            onChange: handleChange
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'b',
            value: rgb.b,
            onChange: handleChange
          }), React.createElement('div', {
            style: styles.divider
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.HEXwrap,
              input: styles.HEXinput,
              label: styles.HEXlabel
            },
            label: '#',
            value: hex.replace('#', ''),
            onChange: handleChange
          }), React.createElement('div', {
            style: styles.fieldSymbols
          }, React.createElement('div', {
            style: styles.symbol
          }, '\xB0'), React.createElement('div', {
            style: styles.symbol
          }, '%'), React.createElement('div', {
            style: styles.symbol
          }, '%')));
        };
        var PhotoshopPointerCircle$1 = function PhotoshopPointerCircle(_ref) {
          var hsl = _ref.hsl;
          var styles = _default$2({
            'default': {
              picker: {
                width: '12px',
                height: '12px',
                borderRadius: '6px',
                boxShadow: 'inset 0 0 0 1px #fff',
                transform: 'translate(-6px, -6px)'
              }
            },
            'black-outline': {
              picker: {
                boxShadow: 'inset 0 0 0 1px #000'
              }
            }
          }, {
            'black-outline': hsl.l > 0.5
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        var PhotoshopPointerCircle = function PhotoshopPointerCircle() {
          var styles = _default$2({
            'default': {
              triangle: {
                width: 0,
                height: 0,
                borderStyle: 'solid',
                borderWidth: '4px 0 4px 6px',
                borderColor: 'transparent transparent transparent #fff',
                position: 'absolute',
                top: '1px',
                left: '1px'
              },
              triangleBorder: {
                width: 0,
                height: 0,
                borderStyle: 'solid',
                borderWidth: '5px 0 5px 8px',
                borderColor: 'transparent transparent transparent #555'
              },
              left: {
                Extend: 'triangleBorder',
                transform: 'translate(-13px, -4px)'
              },
              leftInside: {
                Extend: 'triangle',
                transform: 'translate(-8px, -5px)'
              },
              right: {
                Extend: 'triangleBorder',
                transform: 'translate(20px, -14px) rotate(180deg)'
              },
              rightInside: {
                Extend: 'triangle',
                transform: 'translate(-8px, -5px)'
              }
            }
          });
          return React.createElement('div', {
            style: styles.pointer
          }, React.createElement('div', {
            style: styles.left
          }, React.createElement('div', {
            style: styles.leftInside
          })), React.createElement('div', {
            style: styles.right
          }, React.createElement('div', {
            style: styles.rightInside
          })));
        };
        var PhotoshopButton = function PhotoshopButton(_ref) {
          var onClick = _ref.onClick,
            label = _ref.label,
            children = _ref.children,
            active = _ref.active;
          var styles = _default$2({
            'default': {
              button: {
                backgroundImage: 'linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)',
                border: '1px solid #878787',
                borderRadius: '2px',
                height: '20px',
                boxShadow: '0 1px 0 0 #EAEAEA',
                fontSize: '14px',
                color: '#000',
                lineHeight: '20px',
                textAlign: 'center',
                marginBottom: '10px',
                cursor: 'pointer'
              }
            },
            'active': {
              button: {
                boxShadow: '0 0 0 1px #878787'
              }
            }
          }, {
            active: active
          });
          return React.createElement('div', {
            style: styles.button,
            onClick: onClick
          }, label || children);
        };
        var PhotoshopPreviews = function PhotoshopPreviews(_ref) {
          var rgb = _ref.rgb,
            currentColor = _ref.currentColor;
          var styles = _default$2({
            'default': {
              swatches: {
                border: '1px solid #B3B3B3',
                borderBottom: '1px solid #F0F0F0',
                marginBottom: '2px',
                marginTop: '1px'
              },
              new: {
                height: '34px',
                background: 'rgb(' + rgb.r + ',' + rgb.g + ', ' + rgb.b + ')',
                boxShadow: 'inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000'
              },
              current: {
                height: '34px',
                background: currentColor,
                boxShadow: 'inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000'
              },
              label: {
                fontSize: '14px',
                color: '#000',
                textAlign: 'center'
              }
            }
          });
          return React.createElement('div', null, React.createElement('div', {
            style: styles.label
          }, 'new'), React.createElement('div', {
            style: styles.swatches
          }, React.createElement('div', {
            style: styles.new
          }), React.createElement('div', {
            style: styles.current
          })), React.createElement('div', {
            style: styles.label
          }, 'current'));
        };
        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Photoshop = function (_React$Component) {
          _inherits(Photoshop, _React$Component);
          function Photoshop(props) {
            _classCallCheck(this, Photoshop);
            var _this = _possibleConstructorReturn(this, (Photoshop.__proto__ || Object.getPrototypeOf(Photoshop)).call(this));
            _this.state = {
              currentColor: props.hex
            };
            return _this;
          }
          _createClass(Photoshop, [{
            key: 'render',
            value: function render() {
              var _props = this.props,
                _props$styles = _props.styles,
                passedStyles = _props$styles === undefined ? {} : _props$styles,
                _props$className = _props.className,
                className = _props$className === undefined ? '' : _props$className;
              var styles = _default$2(merge({
                'default': {
                  picker: {
                    background: '#DCDCDC',
                    borderRadius: '4px',
                    boxShadow: '0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)',
                    boxSizing: 'initial',
                    width: '513px'
                  },
                  head: {
                    backgroundImage: 'linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)',
                    borderBottom: '1px solid #B1B1B1',
                    boxShadow: 'inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)',
                    height: '23px',
                    lineHeight: '24px',
                    borderRadius: '4px 4px 0 0',
                    fontSize: '13px',
                    color: '#4D4D4D',
                    textAlign: 'center'
                  },
                  body: {
                    padding: '15px 15px 0',
                    display: 'flex'
                  },
                  saturation: {
                    width: '256px',
                    height: '256px',
                    position: 'relative',
                    border: '2px solid #B3B3B3',
                    borderBottom: '2px solid #F0F0F0',
                    overflow: 'hidden'
                  },
                  hue: {
                    position: 'relative',
                    height: '256px',
                    width: '19px',
                    marginLeft: '10px',
                    border: '2px solid #B3B3B3',
                    borderBottom: '2px solid #F0F0F0'
                  },
                  controls: {
                    width: '180px',
                    marginLeft: '10px'
                  },
                  top: {
                    display: 'flex'
                  },
                  previews: {
                    width: '60px'
                  },
                  actions: {
                    flex: '1',
                    marginLeft: '20px'
                  }
                }
              }, passedStyles));
              return React.createElement('div', {
                style: styles.picker,
                className: 'photoshop-picker ' + className
              }, React.createElement('div', {
                style: styles.head
              }, this.props.header), React.createElement('div', {
                style: styles.body,
                className: 'flexbox-fix'
              }, React.createElement('div', {
                style: styles.saturation
              }, React.createElement(Saturation, {
                hsl: this.props.hsl,
                hsv: this.props.hsv,
                pointer: PhotoshopPointerCircle$1,
                onChange: this.props.onChange
              })), React.createElement('div', {
                style: styles.hue
              }, React.createElement(Hue, {
                direction: 'vertical',
                hsl: this.props.hsl,
                pointer: PhotoshopPointerCircle,
                onChange: this.props.onChange
              })), React.createElement('div', {
                style: styles.controls
              }, React.createElement('div', {
                style: styles.top,
                className: 'flexbox-fix'
              }, React.createElement('div', {
                style: styles.previews
              }, React.createElement(PhotoshopPreviews, {
                rgb: this.props.rgb,
                currentColor: this.state.currentColor
              })), React.createElement('div', {
                style: styles.actions
              }, React.createElement(PhotoshopButton, {
                label: 'OK',
                onClick: this.props.onAccept,
                active: true
              }), React.createElement(PhotoshopButton, {
                label: 'Cancel',
                onClick: this.props.onCancel
              }), React.createElement(PhotoshopPicker, {
                onChange: this.props.onChange,
                rgb: this.props.rgb,
                hsv: this.props.hsv,
                hex: this.props.hex
              }))))));
            }
          }]);
          return Photoshop;
        }(React.Component);
        Photoshop.propTypes = {
          header: PropTypes.string,
          styles: PropTypes.object
        };
        Photoshop.defaultProps = {
          header: 'Color Picker',
          styles: {}
        };
        ColorWrap(Photoshop);

        /* eslint-disable no-param-reassign */

        var SketchFields = function SketchFields(_ref) {
          var onChange = _ref.onChange,
            rgb = _ref.rgb,
            hsl = _ref.hsl,
            hex = _ref.hex,
            disableAlpha = _ref.disableAlpha;
          var styles = _default$2({
            'default': {
              fields: {
                display: 'flex',
                paddingTop: '4px'
              },
              single: {
                flex: '1',
                paddingLeft: '6px'
              },
              alpha: {
                flex: '1',
                paddingLeft: '6px'
              },
              double: {
                flex: '2'
              },
              input: {
                width: '80%',
                padding: '4px 10% 3px',
                border: 'none',
                boxShadow: 'inset 0 0 0 1px #ccc',
                fontSize: '11px'
              },
              label: {
                display: 'block',
                textAlign: 'center',
                fontSize: '11px',
                color: '#222',
                paddingTop: '3px',
                paddingBottom: '4px',
                textTransform: 'capitalize'
              }
            },
            'disableAlpha': {
              alpha: {
                display: 'none'
              }
            }
          }, {
            disableAlpha: disableAlpha
          });
          var handleChange = function handleChange(data, e) {
            if (data.hex) {
              isValidHex(data.hex) && onChange({
                hex: data.hex,
                source: 'hex'
              }, e);
            } else if (data.r || data.g || data.b) {
              onChange({
                r: data.r || rgb.r,
                g: data.g || rgb.g,
                b: data.b || rgb.b,
                a: rgb.a,
                source: 'rgb'
              }, e);
            } else if (data.a) {
              if (data.a < 0) {
                data.a = 0;
              } else if (data.a > 100) {
                data.a = 100;
              }
              data.a /= 100;
              onChange({
                h: hsl.h,
                s: hsl.s,
                l: hsl.l,
                a: data.a,
                source: 'rgb'
              }, e);
            }
          };
          return React.createElement('div', {
            style: styles.fields,
            className: 'flexbox-fix'
          }, React.createElement('div', {
            style: styles.double
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input,
              label: styles.label
            },
            label: 'hex',
            value: hex.replace('#', ''),
            onChange: handleChange
          })), React.createElement('div', {
            style: styles.single
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input,
              label: styles.label
            },
            label: 'r',
            value: rgb.r,
            onChange: handleChange,
            dragLabel: 'true',
            dragMax: '255'
          })), React.createElement('div', {
            style: styles.single
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input,
              label: styles.label
            },
            label: 'g',
            value: rgb.g,
            onChange: handleChange,
            dragLabel: 'true',
            dragMax: '255'
          })), React.createElement('div', {
            style: styles.single
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input,
              label: styles.label
            },
            label: 'b',
            value: rgb.b,
            onChange: handleChange,
            dragLabel: 'true',
            dragMax: '255'
          })), React.createElement('div', {
            style: styles.alpha
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input,
              label: styles.label
            },
            label: 'a',
            value: Math.round(rgb.a * 100),
            onChange: handleChange,
            dragLabel: 'true',
            dragMax: '100'
          })));
        };
        var _extends$2 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var SketchPresetColors = function SketchPresetColors(_ref) {
          var colors = _ref.colors,
            _ref$onClick = _ref.onClick,
            onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
            onSwatchHover = _ref.onSwatchHover;
          var styles = _default$2({
            'default': {
              colors: {
                margin: '0 -10px',
                padding: '10px 0 0 10px',
                borderTop: '1px solid #eee',
                display: 'flex',
                flexWrap: 'wrap',
                position: 'relative'
              },
              swatchWrap: {
                width: '16px',
                height: '16px',
                margin: '0 10px 10px 0'
              },
              swatch: {
                borderRadius: '3px',
                boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15)'
              }
            },
            'no-presets': {
              colors: {
                display: 'none'
              }
            }
          }, {
            'no-presets': !colors || !colors.length
          });
          var handleClick = function handleClick(hex, e) {
            onClick({
              hex: hex,
              source: 'hex'
            }, e);
          };
          return React.createElement('div', {
            style: styles.colors,
            className: 'flexbox-fix'
          }, colors.map(function (colorObjOrString) {
            var c = typeof colorObjOrString === 'string' ? {
              color: colorObjOrString
            } : colorObjOrString;
            var key = '' + c.color + (c.title || '');
            return React.createElement('div', {
              key: key,
              style: styles.swatchWrap
            }, React.createElement(Swatch$1, _extends$2({}, c, {
              style: styles.swatch,
              onClick: handleClick,
              onHover: onSwatchHover,
              focusStyle: {
                boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px ' + c.color
              }
            })));
          }));
        };
        SketchPresetColors.propTypes = {
          colors: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
            color: PropTypes.string,
            title: PropTypes.string
          })])).isRequired
        };
        var _extends$1 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var Sketch = function Sketch(_ref) {
          var width = _ref.width,
            rgb = _ref.rgb,
            hex = _ref.hex,
            hsv = _ref.hsv,
            hsl = _ref.hsl,
            onChange = _ref.onChange,
            onSwatchHover = _ref.onSwatchHover,
            disableAlpha = _ref.disableAlpha,
            presetColors = _ref.presetColors,
            renderers = _ref.renderers,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$2(merge({
            'default': _extends$1({
              picker: {
                width: width,
                padding: '10px 10px 0',
                boxSizing: 'initial',
                background: '#fff',
                borderRadius: '4px',
                boxShadow: '0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)'
              },
              saturation: {
                width: '100%',
                paddingBottom: '75%',
                position: 'relative',
                overflow: 'hidden'
              },
              Saturation: {
                radius: '3px',
                shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
              },
              controls: {
                display: 'flex'
              },
              sliders: {
                padding: '4px 0',
                flex: '1'
              },
              color: {
                width: '24px',
                height: '24px',
                position: 'relative',
                marginTop: '4px',
                marginLeft: '4px',
                borderRadius: '3px'
              },
              activeColor: {
                absolute: '0px 0px 0px 0px',
                borderRadius: '2px',
                background: 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + rgb.a + ')',
                boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
              },
              hue: {
                position: 'relative',
                height: '10px',
                overflow: 'hidden'
              },
              Hue: {
                radius: '2px',
                shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
              },
              alpha: {
                position: 'relative',
                height: '10px',
                marginTop: '4px',
                overflow: 'hidden'
              },
              Alpha: {
                radius: '2px',
                shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
              }
            }, passedStyles),
            'disableAlpha': {
              color: {
                height: '10px'
              },
              hue: {
                height: '10px'
              },
              alpha: {
                display: 'none'
              }
            }
          }, passedStyles), {
            disableAlpha: disableAlpha
          });
          return React.createElement('div', {
            style: styles.picker,
            className: 'sketch-picker ' + className
          }, React.createElement('div', {
            style: styles.saturation
          }, React.createElement(Saturation, {
            style: styles.Saturation,
            hsl: hsl,
            hsv: hsv,
            onChange: onChange
          })), React.createElement('div', {
            style: styles.controls,
            className: 'flexbox-fix'
          }, React.createElement('div', {
            style: styles.sliders
          }, React.createElement('div', {
            style: styles.hue
          }, React.createElement(Hue, {
            style: styles.Hue,
            hsl: hsl,
            onChange: onChange
          })), React.createElement('div', {
            style: styles.alpha
          }, React.createElement(Alpha, {
            style: styles.Alpha,
            rgb: rgb,
            hsl: hsl,
            renderers: renderers,
            onChange: onChange
          }))), React.createElement('div', {
            style: styles.color
          }, React.createElement(Checkboard, null), React.createElement('div', {
            style: styles.activeColor
          }))), React.createElement(SketchFields, {
            rgb: rgb,
            hsl: hsl,
            hex: hex,
            onChange: onChange,
            disableAlpha: disableAlpha
          }), React.createElement(SketchPresetColors, {
            colors: presetColors,
            onClick: onChange,
            onSwatchHover: onSwatchHover
          }));
        };
        Sketch.propTypes = {
          disableAlpha: PropTypes.bool,
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          styles: PropTypes.object
        };
        Sketch.defaultProps = {
          disableAlpha: false,
          width: 200,
          styles: {},
          presetColors: ['#D0021B', '#F5A623', '#F8E71C', '#8B572A', '#7ED321', '#417505', '#BD10E0', '#9013FE', '#4A90E2', '#50E3C2', '#B8E986', '#000000', '#4A4A4A', '#9B9B9B', '#FFFFFF']
        };
        ColorWrap(Sketch);
        var SliderSwatch = function SliderSwatch(_ref) {
          var hsl = _ref.hsl,
            offset = _ref.offset,
            _ref$onClick = _ref.onClick,
            onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
            active = _ref.active,
            first = _ref.first,
            last = _ref.last;
          var styles = _default$2({
            'default': {
              swatch: {
                height: '12px',
                background: 'hsl(' + hsl.h + ', 50%, ' + offset * 100 + '%)',
                cursor: 'pointer'
              }
            },
            'first': {
              swatch: {
                borderRadius: '2px 0 0 2px'
              }
            },
            'last': {
              swatch: {
                borderRadius: '0 2px 2px 0'
              }
            },
            'active': {
              swatch: {
                transform: 'scaleY(1.8)',
                borderRadius: '3.6px/2px'
              }
            }
          }, {
            active: active,
            first: first,
            last: last
          });
          var handleClick = function handleClick(e) {
            return onClick({
              h: hsl.h,
              s: 0.5,
              l: offset,
              source: 'hsl'
            }, e);
          };
          return React.createElement('div', {
            style: styles.swatch,
            onClick: handleClick
          });
        };
        var SliderSwatches = function SliderSwatches(_ref) {
          var onClick = _ref.onClick,
            hsl = _ref.hsl;
          var styles = _default$2({
            'default': {
              swatches: {
                marginTop: '20px'
              },
              swatch: {
                boxSizing: 'border-box',
                width: '20%',
                paddingRight: '1px',
                float: 'left'
              },
              clear: {
                clear: 'both'
              }
            }
          });

          // Acceptible difference in floating point equality
          var epsilon = 0.1;
          return React.createElement('div', {
            style: styles.swatches
          }, React.createElement('div', {
            style: styles.swatch
          }, React.createElement(SliderSwatch, {
            hsl: hsl,
            offset: '.80',
            active: Math.abs(hsl.l - 0.80) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
            onClick: onClick,
            first: true
          })), React.createElement('div', {
            style: styles.swatch
          }, React.createElement(SliderSwatch, {
            hsl: hsl,
            offset: '.65',
            active: Math.abs(hsl.l - 0.65) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
            onClick: onClick
          })), React.createElement('div', {
            style: styles.swatch
          }, React.createElement(SliderSwatch, {
            hsl: hsl,
            offset: '.50',
            active: Math.abs(hsl.l - 0.50) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
            onClick: onClick
          })), React.createElement('div', {
            style: styles.swatch
          }, React.createElement(SliderSwatch, {
            hsl: hsl,
            offset: '.35',
            active: Math.abs(hsl.l - 0.35) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
            onClick: onClick
          })), React.createElement('div', {
            style: styles.swatch
          }, React.createElement(SliderSwatch, {
            hsl: hsl,
            offset: '.20',
            active: Math.abs(hsl.l - 0.20) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
            onClick: onClick,
            last: true
          })), React.createElement('div', {
            style: styles.clear
          }));
        };
        var SliderPointer = function SliderPointer() {
          var styles = _default$2({
            'default': {
              picker: {
                width: '14px',
                height: '14px',
                borderRadius: '6px',
                transform: 'translate(-7px, -1px)',
                backgroundColor: 'rgb(248, 248, 248)',
                boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
              }
            }
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        var Slider = function Slider(_ref) {
          var hsl = _ref.hsl,
            onChange = _ref.onChange,
            pointer = _ref.pointer,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$2(merge({
            'default': {
              hue: {
                height: '12px',
                position: 'relative'
              },
              Hue: {
                radius: '2px'
              }
            }
          }, passedStyles));
          return React.createElement('div', {
            style: styles.wrap || {},
            className: 'slider-picker ' + className
          }, React.createElement('div', {
            style: styles.hue
          }, React.createElement(Hue, {
            style: styles.Hue,
            hsl: hsl,
            pointer: pointer,
            onChange: onChange
          })), React.createElement('div', {
            style: styles.swatches
          }, React.createElement(SliderSwatches, {
            hsl: hsl,
            onClick: onChange
          })));
        };
        Slider.propTypes = {
          styles: PropTypes.object
        };
        Slider.defaultProps = {
          pointer: SliderPointer,
          styles: {}
        };
        ColorWrap(Slider);
        var CheckIcon = {};
        Object.defineProperty(CheckIcon, "__esModule", {
          value: true
        });
        var _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var _react = reactExports;
        var _react2 = _interopRequireDefault$3(_react);
        function _interopRequireDefault$3(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        function _objectWithoutProperties(obj, keys) {
          var target = {};
          for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
          }
          return target;
        }
        var DEFAULT_SIZE = 24;
        var _default = CheckIcon.default = function (_ref) {
          var _ref$fill = _ref.fill,
            fill = _ref$fill === undefined ? 'currentColor' : _ref$fill,
            _ref$width = _ref.width,
            width = _ref$width === undefined ? DEFAULT_SIZE : _ref$width,
            _ref$height = _ref.height,
            height = _ref$height === undefined ? DEFAULT_SIZE : _ref$height,
            _ref$style = _ref.style,
            style = _ref$style === undefined ? {} : _ref$style,
            props = _objectWithoutProperties(_ref, ['fill', 'width', 'height', 'style']);
          return _react2.default.createElement('svg', _extends({
            viewBox: '0 0 ' + DEFAULT_SIZE + ' ' + DEFAULT_SIZE,
            style: _extends({
              fill: fill,
              width: width,
              height: height
            }, style)
          }, props), _react2.default.createElement('path', {
            d: 'M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z'
          }));
        };
        var SwatchesColor = function SwatchesColor(_ref) {
          var color = _ref.color,
            _ref$onClick = _ref.onClick,
            onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
            onSwatchHover = _ref.onSwatchHover,
            first = _ref.first,
            last = _ref.last,
            active = _ref.active;
          var styles = _default$2({
            'default': {
              color: {
                width: '40px',
                height: '24px',
                cursor: 'pointer',
                background: color,
                marginBottom: '1px'
              },
              check: {
                color: getContrastingColor(color),
                marginLeft: '8px',
                display: 'none'
              }
            },
            'first': {
              color: {
                overflow: 'hidden',
                borderRadius: '2px 2px 0 0'
              }
            },
            'last': {
              color: {
                overflow: 'hidden',
                borderRadius: '0 0 2px 2px'
              }
            },
            'active': {
              check: {
                display: 'block'
              }
            },
            'color-#FFFFFF': {
              color: {
                boxShadow: 'inset 0 0 0 1px #ddd'
              },
              check: {
                color: '#333'
              }
            },
            'transparent': {
              check: {
                color: '#333'
              }
            }
          }, {
            first: first,
            last: last,
            active: active,
            'color-#FFFFFF': color === '#FFFFFF',
            'transparent': color === 'transparent'
          });
          return React.createElement(Swatch$1, {
            color: color,
            style: styles.color,
            onClick: onClick,
            onHover: onSwatchHover,
            focusStyle: {
              boxShadow: '0 0 4px ' + color
            }
          }, React.createElement('div', {
            style: styles.check
          }, React.createElement(_default, null)));
        };
        var SwatchesGroup = function SwatchesGroup(_ref) {
          var onClick = _ref.onClick,
            onSwatchHover = _ref.onSwatchHover,
            group = _ref.group,
            active = _ref.active;
          var styles = _default$2({
            'default': {
              group: {
                paddingBottom: '10px',
                width: '40px',
                float: 'left',
                marginRight: '10px'
              }
            }
          });
          return React.createElement('div', {
            style: styles.group
          }, map(group, function (color, i) {
            return React.createElement(SwatchesColor, {
              key: color,
              color: color,
              active: color.toLowerCase() === active,
              first: i === 0,
              last: i === group.length - 1,
              onClick: onClick,
              onSwatchHover: onSwatchHover
            });
          }));
        };
        var Swatches = function Swatches(_ref) {
          var width = _ref.width,
            height = _ref.height,
            onChange = _ref.onChange,
            onSwatchHover = _ref.onSwatchHover,
            colors = _ref.colors,
            hex = _ref.hex,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$2(merge({
            'default': {
              picker: {
                width: width,
                height: height
              },
              overflow: {
                height: height,
                overflowY: 'scroll'
              },
              body: {
                padding: '16px 0 6px 16px'
              },
              clear: {
                clear: 'both'
              }
            }
          }, passedStyles));
          var handleChange = function handleChange(data, e) {
            return onChange({
              hex: data,
              source: 'hex'
            }, e);
          };
          return React.createElement('div', {
            style: styles.picker,
            className: 'swatches-picker ' + className
          }, React.createElement(Raised, null, React.createElement('div', {
            style: styles.overflow
          }, React.createElement('div', {
            style: styles.body
          }, map(colors, function (group) {
            return React.createElement(SwatchesGroup, {
              key: group.toString(),
              group: group,
              active: hex,
              onClick: handleChange,
              onSwatchHover: onSwatchHover
            });
          }), React.createElement('div', {
            style: styles.clear
          })))));
        };
        Swatches.propTypes = {
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          colors: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),
          styles: PropTypes.object

          /* eslint-disable max-len */
        };
        Swatches.defaultProps = {
          width: 320,
          height: 240,
          colors: [[red['900'], red['700'], red['500'], red['300'], red['100']], [pink['900'], pink['700'], pink['500'], pink['300'], pink['100']], [purple['900'], purple['700'], purple['500'], purple['300'], purple['100']], [deepPurple['900'], deepPurple['700'], deepPurple['500'], deepPurple['300'], deepPurple['100']], [indigo['900'], indigo['700'], indigo['500'], indigo['300'], indigo['100']], [blue['900'], blue['700'], blue['500'], blue['300'], blue['100']], [lightBlue['900'], lightBlue['700'], lightBlue['500'], lightBlue['300'], lightBlue['100']], [cyan['900'], cyan['700'], cyan['500'], cyan['300'], cyan['100']], [teal['900'], teal['700'], teal['500'], teal['300'], teal['100']], ['#194D33', green['700'], green['500'], green['300'], green['100']], [lightGreen['900'], lightGreen['700'], lightGreen['500'], lightGreen['300'], lightGreen['100']], [lime['900'], lime['700'], lime['500'], lime['300'], lime['100']], [yellow['900'], yellow['700'], yellow['500'], yellow['300'], yellow['100']], [amber['900'], amber['700'], amber['500'], amber['300'], amber['100']], [orange['900'], orange['700'], orange['500'], orange['300'], orange['100']], [deepOrange['900'], deepOrange['700'], deepOrange['500'], deepOrange['300'], deepOrange['100']], [brown['900'], brown['700'], brown['500'], brown['300'], brown['100']], [blueGrey['900'], blueGrey['700'], blueGrey['500'], blueGrey['300'], blueGrey['100']], ['#000000', '#525252', '#969696', '#D9D9D9', '#FFFFFF']],
          styles: {}
        };
        ColorWrap(Swatches);
        var Twitter = function Twitter(_ref) {
          var onChange = _ref.onChange,
            onSwatchHover = _ref.onSwatchHover,
            hex = _ref.hex,
            colors = _ref.colors,
            width = _ref.width,
            triangle = _ref.triangle,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$2(merge({
            'default': {
              card: {
                width: width,
                background: '#fff',
                border: '0 solid rgba(0,0,0,0.25)',
                boxShadow: '0 1px 4px rgba(0,0,0,0.25)',
                borderRadius: '4px',
                position: 'relative'
              },
              body: {
                padding: '15px 9px 9px 15px'
              },
              label: {
                fontSize: '18px',
                color: '#fff'
              },
              triangle: {
                width: '0px',
                height: '0px',
                borderStyle: 'solid',
                borderWidth: '0 9px 10px 9px',
                borderColor: 'transparent transparent #fff transparent',
                position: 'absolute'
              },
              triangleShadow: {
                width: '0px',
                height: '0px',
                borderStyle: 'solid',
                borderWidth: '0 9px 10px 9px',
                borderColor: 'transparent transparent rgba(0,0,0,.1) transparent',
                position: 'absolute'
              },
              hash: {
                background: '#F0F0F0',
                height: '30px',
                width: '30px',
                borderRadius: '4px 0 0 4px',
                float: 'left',
                color: '#98A1A4',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              },
              input: {
                width: '100px',
                fontSize: '14px',
                color: '#666',
                border: '0px',
                outline: 'none',
                height: '28px',
                boxShadow: 'inset 0 0 0 1px #F0F0F0',
                boxSizing: 'content-box',
                borderRadius: '0 4px 4px 0',
                float: 'left',
                paddingLeft: '8px'
              },
              swatch: {
                width: '30px',
                height: '30px',
                float: 'left',
                borderRadius: '4px',
                margin: '0 6px 6px 0'
              },
              clear: {
                clear: 'both'
              }
            },
            'hide-triangle': {
              triangle: {
                display: 'none'
              },
              triangleShadow: {
                display: 'none'
              }
            },
            'top-left-triangle': {
              triangle: {
                top: '-10px',
                left: '12px'
              },
              triangleShadow: {
                top: '-11px',
                left: '12px'
              }
            },
            'top-right-triangle': {
              triangle: {
                top: '-10px',
                right: '12px'
              },
              triangleShadow: {
                top: '-11px',
                right: '12px'
              }
            }
          }, passedStyles), {
            'hide-triangle': triangle === 'hide',
            'top-left-triangle': triangle === 'top-left',
            'top-right-triangle': triangle === 'top-right'
          });
          var handleChange = function handleChange(hexcode, e) {
            isValidHex(hexcode) && onChange({
              hex: hexcode,
              source: 'hex'
            }, e);
          };
          return React.createElement('div', {
            style: styles.card,
            className: 'twitter-picker ' + className
          }, React.createElement('div', {
            style: styles.triangleShadow
          }), React.createElement('div', {
            style: styles.triangle
          }), React.createElement('div', {
            style: styles.body
          }, map(colors, function (c, i) {
            return React.createElement(Swatch$1, {
              key: i,
              color: c,
              hex: c,
              style: styles.swatch,
              onClick: handleChange,
              onHover: onSwatchHover,
              focusStyle: {
                boxShadow: '0 0 4px ' + c
              }
            });
          }), React.createElement('div', {
            style: styles.hash
          }, '#'), React.createElement(EditableInput, {
            label: null,
            style: {
              input: styles.input
            },
            value: hex.replace('#', ''),
            onChange: handleChange
          }), React.createElement('div', {
            style: styles.clear
          })));
        };
        Twitter.propTypes = {
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          triangle: PropTypes.oneOf(['hide', 'top-left', 'top-right']),
          colors: PropTypes.arrayOf(PropTypes.string),
          styles: PropTypes.object
        };
        Twitter.defaultProps = {
          width: 276,
          colors: ['#FF6900', '#FCB900', '#7BDCB5', '#00D084', '#8ED1FC', '#0693E3', '#ABB8C3', '#EB144C', '#F78DA7', '#9900EF'],
          triangle: 'top-left',
          styles: {}
        };
        ColorWrap(Twitter);
        var GooglePointerCircle = function GooglePointerCircle(props) {
          var styles = _default$2({
            'default': {
              picker: {
                width: '20px',
                height: '20px',
                borderRadius: '22px',
                border: '2px #fff solid',
                transform: 'translate(-12px, -13px)',
                background: 'hsl(' + Math.round(props.hsl.h) + ', ' + Math.round(props.hsl.s * 100) + '%, ' + Math.round(props.hsl.l * 100) + '%)'
              }
            }
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        GooglePointerCircle.propTypes = {
          hsl: PropTypes.shape({
            h: PropTypes.number,
            s: PropTypes.number,
            l: PropTypes.number,
            a: PropTypes.number
          })
        };
        GooglePointerCircle.defaultProps = {
          hsl: {
            a: 1,
            h: 249.94,
            l: 0.2,
            s: 0.50
          }
        };
        var GooglePointer = function GooglePointer(props) {
          var styles = _default$2({
            'default': {
              picker: {
                width: '20px',
                height: '20px',
                borderRadius: '22px',
                transform: 'translate(-10px, -7px)',
                background: 'hsl(' + Math.round(props.hsl.h) + ', 100%, 50%)',
                border: '2px white solid'
              }
            }
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        GooglePointer.propTypes = {
          hsl: PropTypes.shape({
            h: PropTypes.number,
            s: PropTypes.number,
            l: PropTypes.number,
            a: PropTypes.number
          })
        };
        GooglePointer.defaultProps = {
          hsl: {
            a: 1,
            h: 249.94,
            l: 0.2,
            s: 0.50
          }
        };
        var GoogleFields = function GoogleFields(_ref) {
          var onChange = _ref.onChange,
            rgb = _ref.rgb,
            hsl = _ref.hsl,
            hex = _ref.hex,
            hsv = _ref.hsv;
          var handleChange = function handleChange(data, e) {
            if (data.hex) {
              isValidHex(data.hex) && onChange({
                hex: data.hex,
                source: 'hex'
              }, e);
            } else if (data.rgb) {
              var values = data.rgb.split(',');
              isvalidColorString(data.rgb, 'rgb') && onChange({
                r: values[0],
                g: values[1],
                b: values[2],
                a: 1,
                source: 'rgb'
              }, e);
            } else if (data.hsv) {
              var _values = data.hsv.split(',');
              if (isvalidColorString(data.hsv, 'hsv')) {
                _values[2] = _values[2].replace('%', '');
                _values[1] = _values[1].replace('%', '');
                _values[0] = _values[0].replace('°', '');
                if (_values[1] == 1) {
                  _values[1] = 0.01;
                } else if (_values[2] == 1) {
                  _values[2] = 0.01;
                }
                onChange({
                  h: Number(_values[0]),
                  s: Number(_values[1]),
                  v: Number(_values[2]),
                  source: 'hsv'
                }, e);
              }
            } else if (data.hsl) {
              var _values2 = data.hsl.split(',');
              if (isvalidColorString(data.hsl, 'hsl')) {
                _values2[2] = _values2[2].replace('%', '');
                _values2[1] = _values2[1].replace('%', '');
                _values2[0] = _values2[0].replace('°', '');
                if (hsvValue[1] == 1) {
                  hsvValue[1] = 0.01;
                } else if (hsvValue[2] == 1) {
                  hsvValue[2] = 0.01;
                }
                onChange({
                  h: Number(_values2[0]),
                  s: Number(_values2[1]),
                  v: Number(_values2[2]),
                  source: 'hsl'
                }, e);
              }
            }
          };
          var styles = _default$2({
            'default': {
              wrap: {
                display: 'flex',
                height: '100px',
                marginTop: '4px'
              },
              fields: {
                width: '100%'
              },
              column: {
                paddingTop: '10px',
                display: 'flex',
                justifyContent: 'space-between'
              },
              double: {
                padding: '0px 4.4px',
                boxSizing: 'border-box'
              },
              input: {
                width: '100%',
                height: '38px',
                boxSizing: 'border-box',
                padding: '4px 10% 3px',
                textAlign: 'center',
                border: '1px solid #dadce0',
                fontSize: '11px',
                textTransform: 'lowercase',
                borderRadius: '5px',
                outline: 'none',
                fontFamily: 'Roboto,Arial,sans-serif'
              },
              input2: {
                height: '38px',
                width: '100%',
                border: '1px solid #dadce0',
                boxSizing: 'border-box',
                fontSize: '11px',
                textTransform: 'lowercase',
                borderRadius: '5px',
                outline: 'none',
                paddingLeft: '10px',
                fontFamily: 'Roboto,Arial,sans-serif'
              },
              label: {
                textAlign: 'center',
                fontSize: '12px',
                background: '#fff',
                position: 'absolute',
                textTransform: 'uppercase',
                color: '#3c4043',
                width: '35px',
                top: '-6px',
                left: '0',
                right: '0',
                marginLeft: 'auto',
                marginRight: 'auto',
                fontFamily: 'Roboto,Arial,sans-serif'
              },
              label2: {
                left: '10px',
                textAlign: 'center',
                fontSize: '12px',
                background: '#fff',
                position: 'absolute',
                textTransform: 'uppercase',
                color: '#3c4043',
                width: '32px',
                top: '-6px',
                fontFamily: 'Roboto,Arial,sans-serif'
              },
              single: {
                flexGrow: '1',
                margin: '0px 4.4px'
              }
            }
          });
          var rgbValue = rgb.r + ', ' + rgb.g + ', ' + rgb.b;
          var hslValue = Math.round(hsl.h) + '\xB0, ' + Math.round(hsl.s * 100) + '%, ' + Math.round(hsl.l * 100) + '%';
          var hsvValue = Math.round(hsv.h) + '\xB0, ' + Math.round(hsv.s * 100) + '%, ' + Math.round(hsv.v * 100) + '%';
          return React.createElement('div', {
            style: styles.wrap,
            className: 'flexbox-fix'
          }, React.createElement('div', {
            style: styles.fields
          }, React.createElement('div', {
            style: styles.double
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input,
              label: styles.label
            },
            label: 'hex',
            value: hex,
            onChange: handleChange
          })), React.createElement('div', {
            style: styles.column
          }, React.createElement('div', {
            style: styles.single
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input2,
              label: styles.label2
            },
            label: 'rgb',
            value: rgbValue,
            onChange: handleChange
          })), React.createElement('div', {
            style: styles.single
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input2,
              label: styles.label2
            },
            label: 'hsv',
            value: hsvValue,
            onChange: handleChange
          })), React.createElement('div', {
            style: styles.single
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input2,
              label: styles.label2
            },
            label: 'hsl',
            value: hslValue,
            onChange: handleChange
          })))));
        };
        var Google = function Google(_ref) {
          var width = _ref.width,
            onChange = _ref.onChange,
            rgb = _ref.rgb,
            hsl = _ref.hsl,
            hsv = _ref.hsv,
            hex = _ref.hex,
            header = _ref.header,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$2(merge({
            'default': {
              picker: {
                width: width,
                background: '#fff',
                border: '1px solid #dfe1e5',
                boxSizing: 'initial',
                display: 'flex',
                flexWrap: 'wrap',
                borderRadius: '8px 8px 0px 0px'
              },
              head: {
                height: '57px',
                width: '100%',
                paddingTop: '16px',
                paddingBottom: '16px',
                paddingLeft: '16px',
                fontSize: '20px',
                boxSizing: 'border-box',
                fontFamily: 'Roboto-Regular,HelveticaNeue,Arial,sans-serif'
              },
              saturation: {
                width: '70%',
                padding: '0px',
                position: 'relative',
                overflow: 'hidden'
              },
              swatch: {
                width: '30%',
                height: '228px',
                padding: '0px',
                background: 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', 1)',
                position: 'relative',
                overflow: 'hidden'
              },
              body: {
                margin: 'auto',
                width: '95%'
              },
              controls: {
                display: 'flex',
                boxSizing: 'border-box',
                height: '52px',
                paddingTop: '22px'
              },
              color: {
                width: '32px'
              },
              hue: {
                height: '8px',
                position: 'relative',
                margin: '0px 16px 0px 16px',
                width: '100%'
              },
              Hue: {
                radius: '2px'
              }
            }
          }, passedStyles));
          return React.createElement('div', {
            style: styles.picker,
            className: 'google-picker ' + className
          }, React.createElement('div', {
            style: styles.head
          }, header), React.createElement('div', {
            style: styles.swatch
          }), React.createElement('div', {
            style: styles.saturation
          }, React.createElement(Saturation, {
            hsl: hsl,
            hsv: hsv,
            pointer: GooglePointerCircle,
            onChange: onChange
          })), React.createElement('div', {
            style: styles.body
          }, React.createElement('div', {
            style: styles.controls,
            className: 'flexbox-fix'
          }, React.createElement('div', {
            style: styles.hue
          }, React.createElement(Hue, {
            style: styles.Hue,
            hsl: hsl,
            radius: '4px',
            pointer: GooglePointer,
            onChange: onChange
          }))), React.createElement(GoogleFields, {
            rgb: rgb,
            hsl: hsl,
            hex: hex,
            hsv: hsv,
            onChange: onChange
          })));
        };
        Google.propTypes = {
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          styles: PropTypes.object,
          header: PropTypes.string
        };
        Google.defaultProps = {
          width: 652,
          styles: {},
          header: 'Color picker'
        };
        ColorWrap(Google);
        const listFont = ["Merriweather", "Roboto", "Open Sans", "Lato", "Poppins", "Raleway", "Rubik", "Times New Roman", "Arial", "Courier New", "Georgia"];
        function Theming({
          t
        }) {
          const designService = useService("design");
          const dispatch = useDispatch();
          const theme = useSelector(state => {
            return state.designState.Survey.theme;
          });
          function handleChange(key, val) {
            if (key === "font") {
              const updatedTextStyles = _objectSpread3({}, theme.textStyles);
              updatedTextStyles.group = _objectSpread3(_objectSpread3({}, updatedTextStyles.group), {}, {
                font: val
              });
              updatedTextStyles.question = _objectSpread3(_objectSpread3({}, updatedTextStyles.question), {}, {
                font: val
              });
              updatedTextStyles.text = _objectSpread3(_objectSpread3({}, updatedTextStyles.text), {}, {
                font: val
              });
              dispatch(changeAttribute({
                code: "Survey",
                key: "theme",
                value: _objectSpread3(_objectSpread3({}, theme), {}, {
                  textStyles: updatedTextStyles
                })
              }));
            } else if (key === "textColor") {
              const updatedTextStyles = _objectSpread3({}, theme.textStyles);
              updatedTextStyles.group = _objectSpread3(_objectSpread3({}, updatedTextStyles.group), {}, {
                color: val
              });
              updatedTextStyles.question = _objectSpread3(_objectSpread3({}, updatedTextStyles.question), {}, {
                color: val
              });
              updatedTextStyles.text = _objectSpread3(_objectSpread3({}, updatedTextStyles.text), {}, {
                color: val
              });
              dispatch(changeAttribute({
                code: "Survey",
                key: "theme",
                value: _objectSpread3(_objectSpread3({}, theme), {}, {
                  textStyles: updatedTextStyles
                })
              }));
            } else if (key === "bgColor") {
              const rgbaMatch = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),?\s*(\d?\.?\d+)?\)/);
              if (rgbaMatch) {
                const r = rgbaMatch[1];
                const g = rgbaMatch[2];
                const b = rgbaMatch[3];
                let a = rgbaMatch[4];
                if (!a || a === "0" || a === "0.0") {
                  a = "1";
                }
                const newVal = `rgba(${r}, ${g}, ${b}, ${a})`;
                dispatch(changeAttribute({
                  code: "Survey",
                  key: "theme",
                  value: _objectSpread3(_objectSpread3({}, theme), {}, {
                    bgColor: newVal
                  })
                }));
              } else {
                dispatch(changeAttribute({
                  code: "Survey",
                  key: "theme",
                  value: _objectSpread3(_objectSpread3({}, theme), {}, {
                    bgColor: val
                  })
                }));
              }
            } else {
              dispatch(changeAttribute({
                code: "Survey",
                key: "theme",
                value: _objectSpread3(_objectSpread3({}, theme), {}, {
                  [key]: val
                })
              }));
            }
          }
          function handleBannerUpload(e) {
            e.preventDefault();
            let file = e.target.files[0];
            designService.uploadResource(file).then(response => {
              dispatch(changeResources({
                code: "Survey",
                key: "headerImage",
                value: response.name
              }));
            }).catch(err => {
              console.error(err);
            });
          }
          const handleBannerReset = () => {
            dispatch(changeResources({
              code: "Survey",
              key: "headerImage",
              value: null
            }));
          };
          function handleBackgroundUpload(e) {
            e.preventDefault();
            let file = e.target.files[0];
            designService.uploadResource(file).then(response => {
              dispatch(changeResources({
                code: "Survey",
                key: "backgroundImage",
                value: response.name
              }));
              dispatch(changeAttribute({
                code: "Survey",
                key: "theme",
                value: _objectSpread3(_objectSpread3({}, theme), {}, {
                  bgColor: "rgba(0, 0, 0, 0)"
                })
              }));
            }).catch(err => {
              console.error(err);
            });
          }
          const handleBackgroundReset = () => {
            dispatch(changeResources({
              code: "Survey",
              key: "backgroundImage",
              value: null
            }));
          };
          const showPrimaryPicker = useBoolean();
          const showBgPicker = useBoolean();
          const showPaperPicker = useBoolean();
          const showTextPicker = useBoolean();
          const closeAllPickers = () => {
            showPrimaryPicker.onFalse();
            showBgPicker.onFalse();
            showPaperPicker.onFalse();
            showTextPicker.onFalse();
          };
          const primaryPickerRef = reactExports.useRef();
          const bgPickerRef = reactExports.useRef();
          const paperPickerRef = reactExports.useRef();
          const textPickerRef = reactExports.useRef();
          function useClickOutside(ref, callback) {
            reactExports.useEffect(() => {
              function handleClickOutside(event) {
                if (ref.current && !ref.current.contains(event.target)) {
                  callback();
                }
              }
              document.addEventListener("mousedown", handleClickOutside);
              return () => {
                document.removeEventListener("mousedown", handleClickOutside);
              };
            }, [ref, callback]);
          }
          useClickOutside(primaryPickerRef, closeAllPickers);
          useClickOutside(bgPickerRef, closeAllPickers);
          useClickOutside(paperPickerRef, closeAllPickers);
          useClickOutside(textPickerRef, closeAllPickers);
          const togglePicker = picker => {
            if (picker.value) {
              picker.onFalse();
            } else {
              closeAllPickers();
              picker.onToggle();
            }
          };
          const backgroundImage = useSelector(state => {
            var _state$designState$Su4;
            return (_state$designState$Su4 = state.designState["Survey"]) === null || _state$designState$Su4 === void 0 || (_state$designState$Su4 = _state$designState$Su4.resources) === null || _state$designState$Su4 === void 0 ? void 0 : _state$designState$Su4.backgroundImage;
          });
          const bannerImage = useSelector(state => {
            var _state$designState$Su5;
            return (_state$designState$Su5 = state.designState["Survey"]) === null || _state$designState$Su5 === void 0 || (_state$designState$Su5 = _state$designState$Su5.resources) === null || _state$designState$Su5 === void 0 ? void 0 : _state$designState$Su5.headerImage;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$1.theming,
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("span", {
              className: styles$1.fontText,
              children: [" ", t("font")]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Select, {
              sx: {
                "& .MuiSvgIcon-root": {
                  color: "#16205b"
                }
              },
              IconComponent: KeyboardArrowDown,
              size: "small",
              className: styles$1.selectDropdown,
              value: theme.textStyles.group.font,
              onChange: e => handleChange("font", e.target.value),
              children: listFont && listFont.length > 0 && listFont.map((el, index) => /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                sx: {
                  fontFamily: el
                },
                value: el,
                children: el
              }, `fontFamily-${index}`))
            }, "fontFamily"), /* @__PURE__ */jsxRuntimeExports.jsxs(Stack$7, {
              display: "flex",
              justifyContent: "space-between",
              width: "100%",
              flexDirection: "row",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Typography, {
                variant: "subtitle2",
                alignSelf: "center",
                children: t("group_title")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(ThemingItem, {
                value: theme.textStyles.group,
                default: defaultSurveyTheme.textStyles.group,
                onChange: val => {
                  handleChange("textStyles", _objectSpread3(_objectSpread3({}, theme.textStyles), {}, {
                    ["group"]: val
                  }));
                }
              }, "group")]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Stack$7, {
              display: "flex",
              justifyContent: "space-between",
              width: "100%",
              flexDirection: "row",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Typography, {
                variant: "subtitle2",
                alignSelf: "center",
                children: t("question_title")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(ThemingItem, {
                value: theme.textStyles.question,
                default: defaultSurveyTheme.textStyles.question,
                onChange: val => handleChange("textStyles", _objectSpread3(_objectSpread3({}, theme.textStyles), {}, {
                  ["question"]: val
                }))
              }, "question")]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Stack$7, {
              display: "flex",
              justifyContent: "space-between",
              width: "100%",
              flexDirection: "row",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Typography, {
                variant: "subtitle2",
                alignSelf: "center",
                children: t("theme_text")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(ThemingItem, {
                value: theme.textStyles.text,
                default: defaultSurveyTheme.textStyles.text,
                onChange: val => handleChange("textStyles", _objectSpread3(_objectSpread3({}, theme.textStyles), {}, {
                  ["text"]: val
                }))
              }, "text")]
            }), /* @__PURE__ */jsxRuntimeExports.jsx("hr", {}), /* @__PURE__ */jsxRuntimeExports.jsxs(Stack$7, {
              display: "flex",
              justifyContent: "space-between",
              width: "100%",
              flexDirection: "row",
              position: "relative",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Typography, {
                variant: "subtitle2",
                alignSelf: "center",
                children: t("highlight_color")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                onClick: () => togglePicker(showPrimaryPicker),
                style: {
                  backgroundColor: theme.primaryColor
                },
                className: styles$1.colorBox
              }), showPrimaryPicker.value && /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                ref: primaryPickerRef,
                className: styles$1.colorPickerContainer,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  onClick: () => togglePicker(showPrimaryPicker),
                  style: {
                    marginLeft: "auto",
                    color: "#333"
                  },
                  "aria-label": "close",
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$o, {})
                }), /* @__PURE__ */jsxRuntimeExports.jsx(ChromePicker, {
                  color: theme.primaryColor,
                  onChange: color => {
                    handleChange("primaryColor", `rgba(${color.rgb.r}, ${color.rgb.g}, ${color.rgb.b}, ${color.rgb.a})`);
                  }
                })]
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Stack$7, {
              display: "flex",
              justifyContent: "space-between",
              width: "100%",
              flexDirection: "row",
              position: "relative",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Typography, {
                variant: "subtitle2",
                alignSelf: "center",
                children: t("background_color")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                onClick: () => togglePicker(showBgPicker),
                style: {
                  backgroundColor: theme.bgColor
                },
                className: styles$1.colorBox
              }), showBgPicker.value && /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                ref: bgPickerRef,
                className: styles$1.colorPickerContainer,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  onClick: () => togglePicker(showBgPicker),
                  style: {
                    marginLeft: "auto",
                    color: "#333"
                  },
                  "aria-label": "close",
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$o, {})
                }), /* @__PURE__ */jsxRuntimeExports.jsx(ChromePicker, {
                  color: theme.bgColor,
                  onChange: color => {
                    handleChange("bgColor", `rgba(${color.rgb.r}, ${color.rgb.g}, ${color.rgb.b}, ${color.rgb.a})`);
                  }
                })]
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Stack$7, {
              display: "flex",
              justifyContent: "space-between",
              width: "100%",
              flexDirection: "row",
              position: "relative",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Typography, {
                variant: "subtitle2",
                alignSelf: "center",
                children: t("foreground_color")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                onClick: () => togglePicker(showPaperPicker),
                style: {
                  backgroundColor: theme.paperColor
                },
                className: styles$1.colorBox
              }), showPaperPicker.value && /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                ref: paperPickerRef,
                className: styles$1.colorPickerContainer,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  onClick: () => togglePicker(showPaperPicker),
                  style: {
                    marginLeft: "auto",
                    color: "#333"
                  },
                  "aria-label": "close",
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$o, {})
                }), /* @__PURE__ */jsxRuntimeExports.jsx(ChromePicker, {
                  color: theme.paperColor,
                  onChange: color => {
                    handleChange("paperColor", `rgba(${color.rgb.r}, ${color.rgb.g}, ${color.rgb.b}, ${color.rgb.a})`);
                  }
                })]
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Stack$7, {
              display: "flex",
              justifyContent: "space-between",
              width: "100%",
              flexDirection: "row",
              position: "relative",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Typography, {
                variant: "subtitle2",
                alignSelf: "center",
                children: t("text_color")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                onClick: () => togglePicker(showTextPicker),
                style: {
                  backgroundColor: theme.textStyles.group.color
                },
                className: styles$1.colorBox
              }), showTextPicker.value && /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                ref: textPickerRef,
                className: styles$1.colorPickerContainer,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  onClick: () => togglePicker(showTextPicker),
                  style: {
                    marginLeft: "auto",
                    color: "#333"
                  },
                  "aria-label": "close",
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$o, {})
                }), /* @__PURE__ */jsxRuntimeExports.jsx(ChromePicker, {
                  color: theme.textStyles.group.color,
                  onChange: color => {
                    handleChange("textColor", `rgba(${color.rgb.r}, ${color.rgb.g}, ${color.rgb.b}, ${color.rgb.a})`);
                  }
                })]
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Stack$7, {
              display: "flex",
              justifyContent: "space-between",
              width: "100%",
              flexDirection: "row",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Typography, {
                variant: "subtitle2",
                alignSelf: "center",
                children: t("upload_banner")
              }), /* @__PURE__ */jsxRuntimeExports.jsxs(Button, {
                component: "label",
                className: styles$1.chooseImage,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$r, {}), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                  hidden: true,
                  accept: "image/*",
                  type: "file",
                  onChange: handleBannerUpload
                })]
              }), bannerImage && /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                className: styles$1.resetButton,
                onClick: handleBannerReset,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Close, {})
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Stack$7, {
              display: "flex",
              justifyContent: "space-between",
              width: "100%",
              flexDirection: "row",
              gap: 1,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Typography, {
                variant: "subtitle2",
                alignSelf: "center",
                children: t("upload_background")
              }), /* @__PURE__ */jsxRuntimeExports.jsxs(Button, {
                component: "label",
                className: styles$1.chooseImage,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$r, {}), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                  hidden: true,
                  accept: "image/*",
                  type: "file",
                  onChange: handleBackgroundUpload
                })]
              }), backgroundImage && /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                className: styles$1.resetButton,
                onClick: handleBackgroundReset,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Close, {})
              })]
            })]
          });
        }
        function SetupPanel({
          t
        }) {
          const dispatch = useDispatch();
          const toggleExpand = reactExports.useCallback(key => {
            dispatch(setupToggleExpand(key));
          });
          const theme = useTheme$1();
          const selectSetupInfo = state => state.designState.setup || {};
          const selectSetupData = createSelector([selectSetupInfo], setupInfo => {
            var _setupInfo$rules;
            return {
              code: setupInfo.code,
              expanded: setupInfo.expanded,
              highlighted: setupInfo.highlighted,
              rules: setupInfo.rules,
              isSingleRule: ((_setupInfo$rules = setupInfo.rules) === null || _setupInfo$rules === void 0 ? void 0 : _setupInfo$rules.length) === 1
            };
          });
          const _useSelector2 = useSelector(selectSetupData),
            code = _useSelector2.code,
            expanded = _useSelector2.expanded,
            highlighted = _useSelector2.highlighted,
            rules = _useSelector2.rules,
            isSingleRule = _useSelector2.isSingleRule;
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$9.rightContent,
            style: {
              left: theme.direction == "rtl" ? "0px" : ""
            },
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$9.close,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                onClick: () => {
                  dispatch(resetSetup());
                },
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$o, {})
              })
            }), rules === null || rules === void 0 ? void 0 : rules.map(rule => /* @__PURE__ */jsxRuntimeExports.jsx(SetupSection, {
              expanded: (expanded === null || expanded === void 0 ? void 0 : expanded.includes(rule.key)) || isSingleRule || false,
              isSingleRule,
              code,
              t,
              toggleExpand,
              highlighted: rule.key == highlighted,
              rule
            }, code + rule.title))]
          });
        }
        const SetupPanel$1 = React.memo(SetupPanel);
        const SetupComponent = React.memo(({
          code,
          rule,
          t
        }) => {
          if (rule.startsWith("validation_")) {
            return /* @__PURE__ */jsxRuntimeExports.jsx(ValidationSetupItem$1, {
              t,
              rule,
              code
            }, code + rule);
          }
          switch (rule) {
            case "theme":
              return /* @__PURE__ */jsxRuntimeExports.jsx(Theming, {
                t
              }, code + rule);
            case "language":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ManageLanguages, {
                t
              }, code + rule);
            case "maxChars":
              return /* @__PURE__ */jsxRuntimeExports.jsx(FieldSize$1, {
                label: t("text_field_size"),
                rule,
                lowerBound: 1,
                t,
                upperBound: 500,
                defaultValue: 20,
                code
              }, code + rule);
            case "minRows":
              return /* @__PURE__ */jsxRuntimeExports.jsx(FieldSize$1, {
                label: t("textarea_lines"),
                lowerBound: 1,
                t,
                upperBound: 500,
                code,
                defaultValue: 20
              }, code + rule);
            case "hideText":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ToggleValue, {
                label: t("hide_text"),
                rule,
                code
              }, code + rule);
            case "showDescription":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ToggleValue, {
                label: t("show_description"),
                rule,
                code
              }, code + rule);
            case "showWordCount":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ToggleValue, {
                label: t("show_word_count"),
                rule,
                code
              }, code + rule);
            case "navigationMode":
              return /* @__PURE__ */jsxRuntimeExports.jsx(NavigationMode, {}, code + rule);
            case "allowPrevious":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ToggleValue, {
                label: t("allow_previous"),
                rule,
                code
              }, code + rule);
            case "allowIncomplete":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ToggleValue, {
                label: t("allow_incomplete"),
                rule,
                code
              }, code + rule);
            case "allowJump":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ToggleValue, {
                label: t("allow_jump"),
                rule,
                code
              }, code + rule);
            case "skipInvalid":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ToggleValue, {
                label: t("skip_invalid"),
                rule,
                code
              }, code + rule);
            case "hint":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ShowHint, {
                t,
                code
              }, code + rule);
            case "lower_bound_hint":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ContentEditor, {
                title: t("lower_bound_hint"),
                objectName: "lower_bound_hint",
                code
              }, code + rule);
            case "higher_bound_hint":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ContentEditor, {
                title: t("upper_bound_hint"),
                objectName: "higher_bound_hint",
                code
              }, code + rule);
            case "loop":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ToggleValue, {
                rule,
                code,
                label: t("loop_video")
              }, code + rule);
            case "audio_only":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ToggleValue, {
                rule,
                code,
                label: t("audio_only")
              }, code + rule);
            case "fullDayFormat":
              return /* @__PURE__ */jsxRuntimeExports.jsx(ToggleValue, {
                rule,
                code,
                label: t("fullday_format")
              }, code + rule);
            case "randomize_questions":
            case "prioritize_questions":
            case "randomize_options":
            case "prioritize_options":
            case "randomize_groups":
            case "prioritize_groups":
            case "randomize_rows":
            case "prioritize_rows":
            case "randomize_columns":
            case "prioritize_columns":
              return /* @__PURE__ */jsxRuntimeExports.jsx(OrderPrioritySetup, {
                t,
                rule,
                code
              }, code + rule);
            case "maxDate":
              return /* @__PURE__ */jsxRuntimeExports.jsx(SelectDate, {
                lowerBound: 1,
                code,
                label: t("max_date"),
                rule
              }, code + rule);
            case "minDate":
              return /* @__PURE__ */jsxRuntimeExports.jsx(SelectDate, {
                label: t("min_date"),
                rule,
                code
              }, code + rule);
            case "dateFormat":
              const listDateFormat = ["DD.MM.YYYY", "MM.DD.YYYY", "YYYY.MM.DD", "DD/MM/YYYY", "MM/DD/YYYY", "YYYY/MM/DD"];
              return /* @__PURE__ */jsxRuntimeExports.jsx(SelectValue, {
                values: listDateFormat,
                defaultValue: "DD.MM.YYYY",
                label: t("date_format"),
                rule,
                code
              }, code + rule);
            case "decimal_separator":
              const decimalValues = ["", ",", "."];
              const labels = [t("no_decimals_allowed"), ",", "."];
              return /* @__PURE__ */jsxRuntimeExports.jsx(SelectValue, {
                values: decimalValues,
                labels,
                defaultValue: "",
                label: t("decimal_separator"),
                rule,
                code
              }, code + rule);
            case "imageAspectRatio":
              const aspectLabels = ["1:1", "16:9", "4:3", "3:2", "9:16", "3:4", "2:3"];
              const aspectValues = [1, 1.7778, 1.3333, 1.5, 0.562, 0.75, 0.6667];
              return /* @__PURE__ */jsxRuntimeExports.jsx(SelectValue, {
                values: aspectValues,
                labels: aspectLabels,
                defaultValue: "1:1",
                label: t("image_aspect_ratio"),
                rule,
                code
              }, code + rule);
            case "reorder_setup":
              const reorderLabels = [t("collapse_groups"), t("collapse_questions")];
              const reorderValues = ["collapse_groups", "collapse_questions"];
              return /* @__PURE__ */jsxRuntimeExports.jsx(SelectValue, {
                values: reorderValues,
                labels: reorderLabels,
                defaultValue: "collapse_none",
                label: t("order_mode"),
                rule,
                code
              }, code + rule);
            case "iconSize":
              const iconSizes = ["50", "100", "150", "200"];
              return /* @__PURE__ */jsxRuntimeExports.jsx(SelectValue, {
                values: iconSizes,
                defaultValue: "1:1",
                label: t("image_icon_size"),
                rule,
                code
              }, code + rule);
            case "columns":
              const columnsOptions = ["1", "2", "3", "4", "6"];
              return /* @__PURE__ */jsxRuntimeExports.jsx(SelectValue, {
                values: columnsOptions,
                defaultValue: "2",
                label: t("columns_number"),
                rule,
                code
              }, code + rule);
            case "imageHeight":
              return /* @__PURE__ */jsxRuntimeExports.jsx(FieldSize$1, {
                label: t("image_height"),
                lowerBound: 50,
                upperBound: 500,
                t,
                code,
                defaultValue: 250,
                rule
              }, code + rule);
            case "spacing":
              return /* @__PURE__ */jsxRuntimeExports.jsx(FieldSize$1, {
                label: t("spacing"),
                lowerBound: 2,
                upperBound: 32,
                code,
                t,
                defaultValue: 8,
                rule
              }, code + rule);
            case "skip_logic":
              return /* @__PURE__ */jsxRuntimeExports.jsx(SkipLogic, {
                t,
                code
              }, code + rule);
            case "relevance":
              return /* @__PURE__ */jsxRuntimeExports.jsx(Relevance, {
                t,
                code
              }, code + rule);
            default:
              return "";
          }
        });
        const SetupSection = React.memo(({
          expanded,
          highlighted,
          code,
          rule,
          isSingleRule,
          t,
          toggleExpand
        }) => {
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Accordion, {
            expanded,
            className: styles$9.accordionStyle,
            slotProps: {
              transition: {
                unmountOnExit: true
              }
            },
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(AccordionSummary, {
              onClick: () => toggleExpand(rule.key),
              className: styles$9.setupHeader,
              expandIcon: isSingleRule ? null : /* @__PURE__ */jsxRuntimeExports.jsx(default_1$s, {}),
              children: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                className: styles$9.sectionTitle,
                children: t(rule.title)
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(AccordionDetails, {
              sx: {
                backgroundColor: highlighted ? "#fff" : "background.paper"
              },
              children: rule.rules.map(el => /* @__PURE__ */jsxRuntimeExports.jsx(SetupComponent, {
                code,
                rule: el,
                t
              }, el))
            })]
          });
        });
        function LeftPanel({
          t
        }) {
          const show = useSelector(state => {
            var _state$designState;
            return (((_state$designState = state.designState) === null || _state$designState === void 0 ? void 0 : _state$designState.designMode) || DESIGN_SURVEY_MODE.DESIGN) == DESIGN_SURVEY_MODE.DESIGN && (!state.designState.setup || Object.keys(state.designState.setup) == 0);
          });
          const setup = useSelector(state => {
            var _state$designState2;
            return ((_state$designState2 = state.designState) === null || _state$designState2 === void 0 ? void 0 : _state$designState2.setup) || {};
          });
          const hasSetup = Object.keys(setup).length > 0;
          useTheme$1();
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            sx: {
              width: "22rem",
              flex: "0 0 auto"
            },
            children: [show && /* @__PURE__ */jsxRuntimeExports.jsx(NewComponentsPanel, {
              t
            }), hasSetup && /* @__PURE__ */jsxRuntimeExports.jsx(SetupPanel$1, {
              t
            })]
          });
        }
        const LeftPanel$1 = React.memo(LeftPanel);
        var Translate = {};
        var _interopRequireDefault$2 = interopRequireDefaultExports;
        Object.defineProperty(Translate, "__esModule", {
          value: true
        });
        var default_1$2 = Translate.default = void 0;
        var _createSvgIcon$2 = _interopRequireDefault$2(requireCreateSvgIcon());
        var _jsxRuntime$2 = jsxRuntimeExports;
        default_1$2 = Translate.default = (0, _createSvgIcon$2.default)(/*#__PURE__*/(0, _jsxRuntime$2.jsx)("path", {
          d: "m12.87 15.07-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2zm-2.62 7 1.62-4.33L19.12 17z"
        }), 'Translate');
        var Reorder = {};
        var _interopRequireDefault$1 = interopRequireDefaultExports;
        Object.defineProperty(Reorder, "__esModule", {
          value: true
        });
        var default_1$1 = Reorder.default = void 0;
        var _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon());
        var _jsxRuntime$1 = jsxRuntimeExports;
        default_1$1 = Reorder.default = (0, _createSvgIcon$1.default)(/*#__PURE__*/(0, _jsxRuntime$1.jsx)("path", {
          d: "M3 15h18v-2H3zm0 4h18v-2H3zm0-8h18V9H3zm0-6v2h18V5z"
        }), 'Reorder');
        var MoreHoriz = {};
        var _interopRequireDefault = interopRequireDefaultExports;
        Object.defineProperty(MoreHoriz, "__esModule", {
          value: true
        });
        var default_1 = MoreHoriz.default = void 0;
        var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
        var _jsxRuntime = jsxRuntimeExports;
        default_1 = MoreHoriz.default = (0, _createSvgIcon.default)(/*#__PURE__*/(0, _jsxRuntime.jsx)("path", {
          d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
        }), 'MoreHoriz');
        function RightPanel({
          t
        }) {
          const setup = useSelector(state => {
            var _state$designState3;
            return ((_state$designState3 = state.designState) === null || _state$designState3 === void 0 ? void 0 : _state$designState3.setup) || {};
          });
          useTheme$1();
          const hasSetup = Object.keys(setup).length > 0;
          return /* @__PURE__ */jsxRuntimeExports.jsx(Collapse, {
            in: hasSetup,
            sx: {
              flex: "0 0 auto"
            },
            orientation: "horizontal",
            timeout: 200,
            easing: {
              enter: "linear",
              // Easing for the "entering" animation
              exit: "linear"
              // Easing for the "exiting" animation
            },
            unmountOnExit: true,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(SetupPanel$1, {
              t
            })
          });
        }
        React.memo(RightPanel);
        function DesignSurvey() {
          const _useTranslation7 = useTranslation(["design", "run"]),
            t = _useTranslation7.t,
            i18n = _useTranslation7.i18n;
          const childI18n = i18n.cloneInstance();
          const contentRef = reactExports.useRef(null);
          const _React$useState21 = React.useState(false),
            _React$useState22 = _slicedToArray2(_React$useState21, 2),
            optionsOpen = _React$useState22[0],
            setOptionsOpen = _React$useState22[1];
          const containerRef = reactExports.useRef();
          const langInfo = useSelector(state => {
            return state.designState.langInfo;
          });
          const dispatch = useDispatch();
          const designMode = useSelector(state => {
            return state.designState.designMode;
          });
          const toDesign = () => {
            dispatch(resetSetup());
          };
          const lang = langInfo === null || langInfo === void 0 ? void 0 : langInfo.lang;
          const isRtl = isSessionRtl();
          console.log(isRtl);
          const theme = useSelector(state => {
            var _state$designState$Su6;
            return (_state$designState$Su6 = state.designState["Survey"]) === null || _state$designState$Su6 === void 0 ? void 0 : _state$designState$Su6.theme;
          });
          function changeLanguage(lang2) {
            return new Promise((resolve, reject) => {
              const dir = rtlLanguage.includes(lang2) ? "rtl" : "ltr";
              const contentPanel = contentRef.current;
              if (contentPanel.dir != dir) {
                contentPanel.dir = dir;
              }
              contentPanel.scrollTop = 0;
              if (lang2 && childI18n && lang2 != childI18n.language) {
                childI18n.changeLanguage(lang2);
              }
              resolve();
            });
          }
          reactExports.useEffect(() => {
            if (contentRef.current) {
              changeLanguage(lang);
            }
          }, [lang, contentRef]);
          const cacheRtlMemo = reactExports.useMemo(() => cacheRtl(lang), [lang]);
          const surveyTheme = React.useCallback(createTheme(_objectSpread3(_objectSpread3({}, defualtTheme(theme)), {}, {
            direction: rtlLanguage.includes(lang) ? "rtl" : "ltr"
          })), [theme]);
          const backgroundImage = useSelector(state => {
            var _state$designState$Su7;
            return (_state$designState$Su7 = state.designState["Survey"]) === null || _state$designState$Su7 === void 0 || (_state$designState$Su7 = _state$designState$Su7.resources) === null || _state$designState$Su7 === void 0 ? void 0 : _state$designState$Su7.backgroundImage;
          });
          const backgroundStyle = backgroundImage ? {
            backgroundImage: `url(${buildResourceUrl(backgroundImage)})`,
            backgroundSize: "cover",
            backgroundRepeat: "no-repeat",
            // backgroundSize: "100% 100%",
            backgroundPosition: "center"
          } : {};
          return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
            className: styles$K.mainContainer,
            ref: containerRef,
            sx: backgroundStyle,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(DndProvider, {
              backend: isTouchDevice() ? TouchBackend : HTML5Backend,
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(CacheProvider, {
                value: cacheRtlMemo,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(LeftPanel$1, {
                  t
                }), /* @__PURE__ */jsxRuntimeExports.jsx(ThemeProvider, {
                  theme: surveyTheme,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(I18nextProvider, {
                    i18n: childI18n,
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(ContentPanel$1, {
                      designMode,
                      ref: contentRef,
                      className: styles$K.contentPanel
                    })
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx(DesignChip, {
                  onCancel: toDesign,
                  designMode,
                  isRtl
                }), /* @__PURE__ */jsxRuntimeExports.jsx(DesignOptions, {
                  designMode,
                  isRtl,
                  optionsOpen,
                  setOptionsOpen
                })]
              })
            })
          });
        }
        const index = exports("default", React.memo(DesignSurvey));
        function DesignOptions({
          setOptionsOpen,
          optionsOpen,
          designMode,
          isRtl
        }) {
          const dispatch = useDispatch();
          const actions = [{
            icon: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$2, {}),
            name: "Language",
            onClick: () => {
              setOptionsOpen(false);
              dispatch(setDesignModeToLang());
            }
          }, {
            icon: /* @__PURE__ */jsxRuntimeExports.jsx(Palette, {}),
            name: "Theme",
            onClick: () => {
              setOptionsOpen(false);
              dispatch(setDesignModeToTheme());
            }
          }, {
            icon: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$1, {}),
            name: "Reorder",
            onClick: () => {
              setOptionsOpen(false);
              dispatch(setDesignModeToReorder());
            }
          }];
          return designMode == DESIGN_SURVEY_MODE.DESIGN && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Backdrop, {
              style: {
                zIndex: 1
              },
              open: optionsOpen
            }), /* @__PURE__ */jsxRuntimeExports.jsx(SpeedDial, {
              open: optionsOpen,
              dir: "rtl",
              onClick: () => setOptionsOpen(!optionsOpen),
              ariaLabel: "SpeedDial basic example",
              sx: isRtl ? {
                position: "absolute",
                bottom: 16,
                left: 16
              } : {
                position: "absolute",
                bottom: 16,
                right: 16
              },
              icon: /* @__PURE__ */jsxRuntimeExports.jsx(default_1, {}),
              children: actions.map(action => /* @__PURE__ */jsxRuntimeExports.jsx(SpeedDialAction, {
                onClick: action.onClick,
                dir: "rtl",
                icon: action.icon,
                tooltipOpen: true,
                tooltipTitle: action.name
              }, action.name))
            })]
          });
        }
        function DesignChip({
          designMode,
          onCancel,
          isRtl
        }) {
          return designMode != DESIGN_SURVEY_MODE.DESIGN && /* @__PURE__ */jsxRuntimeExports.jsx(Chip, {
            sx: {
              borderRadius: "48px",
              height: "48px",
              fontSize: "24px",
              padding: "8px"
            },
            style: isRtl ? {
              position: "absolute",
              bottom: 16,
              left: 16
            } : {
              position: "absolute",
              bottom: 16,
              right: 16
            },
            label: "Back to Design",
            icon: /* @__PURE__ */jsxRuntimeExports.jsx(Cancel, {}),
            color: "primary",
            onClick: onCancel
          });
        }
      }
    };
  });
})();
//# sourceMappingURL=index-legacy-BmQ2dgSa.js.map

import { b as _objectWithoutPropertiesLoose, w as getDefaultExportFromCjs, r as reactExports, J as I18nContext, M as getDefaults, O as _defineProperty$4, an as _typeof$3, P as getI18n, _ as _extends$h, g as generateUtilityClass, f as generateUtilityClasses, h as capitalize$1, j as jsxRuntimeExports, d as clsx, k as alpha_1, a1 as clamp, l as lighten_1, i as darken_1, o as emphasize_1, q as interopRequireDefaultExports, B as Box, p as commonjsGlobal, ai as reactDomExports, R as React, y as useTheme$1, A as LoadingDots, ag as ReactDOM, ao as _arrayLikeToArray$h, ap as _iterableToArray, H as _unsupportedIterableToArray$h, aq as _toArray, ar as _inherits$b, as as _createClass$9, at as _classCallCheck$b, au as _getPrototypeOf$1, av as _possibleConstructorReturn$b, x as createTheme, C as CacheProvider, aw as I18nextProvider } from "./index-X8N9IRh7.js";
import { bZ as warnOnce, b_ as warn$1, C as useId, A as useControlled, k as useEventCallback, b$ as setRef, f as styled, j as useDefaultProps, c as composeClasses, c0 as inputClasses, al as inputBaseClasses, am as outlinedInputClasses, an as filledInputClasses, I as IconButton, h as Paper, c1 as ArrowDropDownIcon, b as useForkRef, bR as ButtonGroupContext, c2 as ButtonGroupButtonContext, T as Typography, l as rootShouldForwardProp, B as ButtonBase, c3 as listItemTextClasses, L as ListContext, c4 as getListItemTextUtilityClass, D as useIsFocusVisible, n as useEnhancedEffect, o as ownerDocument, v as extractEventHandlers, p as isHostComponent, c5 as slotShouldForwardProp, z as useRtl, x as useSlotProps, w as useTheme, be as Transition, bf as reflow, bg as getTransitionProps, t as useTimeout, i as isMuiElement, bM as useDragDropManager, c6 as useCollector, e as createSvgIcon, K as requireCreateSvgIcon, M as useTranslation, U as useDispatch, H as useSelector, c7 as isGroup, c8 as isQuestion, c9 as setup, ca as setupOptions, cb as surveySetup$1, bi as stripTags, aw as manageStore, cc as isNotEmptyHtml, cd as changeContent, ap as rtlLanguage, aP as SurveyIcon, ce as TextareaAutosize, cf as inDesign, aD as Button, b8 as useDrag, cg as removeAnswer, ch as onDrag, R as useService, ci as changeResources, ba as getContrastColor, cj as contentEditable, ck as axios, cl as DESIGN_SURVEY_MODE, cm as hasMajorSetup, cn as deleteQuestion, co as cloneQuestion, cp as nextId, cq as addNewAnswer, bl as questionIconByType, cr as isDisplay, cs as deleteGroup, ct as changeAttribute, cu as changeValidationValue, ax as FormControl, S as Select, N as MenuItem, cv as _slicedToArray$1, a2 as PropTypes, cw as connect$1, P as Provider, bA as createStore, W as Menu, ar as ThemeProvider, bc as truncateWithEllipsis, cx as changeRelevance, cy as removeSkipDestination, cz as editSkipDestination, cA as editSkipToEnd, cB as instructionByCode, cC as updatePriorityByType, cD as updatePriority, cE as updateRandomByType, cF as updateRandom, aL as Stack$7, cG as defaultSurveyTheme, cH as setupToggleExpand, aF as resetSetup, cI as NewComponentsPanel, cJ as isSessionRtl, av as cacheRtl, bt as defualtTheme, aW as Backdrop, cK as setDesignModeToLang, cL as setDesignModeToTheme, cM as setDesignModeToReorder } from "./use-service-CuBoVPEx.js";
import { b as buildResourceUrl } from "./common-B0QmLEBc.js";
import { G as autocompleteClasses, H as ClearIcon, J as Chip, L as getAutocompleteUtilityClass, M as buttonGroupClasses, N as getButtonGroupUtilityClass, O as fabClasses, P as getFabUtilityClass, Q as sliderClasses, T as getSliderUtilityClass, U as Tooltip, v as default_1$o, C as CustomTooltip, D as DialogTitle, V as Switch, m as CircularProgress, W as ListItemIcon, X as merge$5, K as KeyboardArrowDown, Y as ManageLanguages } from "./Web-D9a6B_N2.js";
import { c as createSelector, E as ErrorOutlineOutlined, D as DndProvider, i as isTouchDevice, T as TouchBackend, H as HTML5Backend } from "./isTouchDevice-CpP8rLyq.js";
import { u as usePreviousProps, a as default_1$p, D as DeleteModal, d as default_1$r } from "./Image-C57uL_fA.js";
import { T as TextField, F as FormLabel, I as InputLabel } from "./TextField-D-dIAL0B.js";
import { T as TableContainer, a as Table, b as TableRow, c as TableBody } from "./TableRow-5Q_VhcUf.js";
import { T as TableHead } from "./TableHead-CXvtxyxz.js";
import { T as TableCell } from "./TableCell-BolArTiL.js";
import { R as Radio } from "./Radio-Dsj3N256.js";
import { u as useDrop } from "./useDrop-DFTK97V-.js";
import { R as ReactPlayer } from "./index-DOsmkVcc.js";
import { G as Grid$1, q as DialogActions, D as DateTimePicker, L as LocalizationProvider } from "./DateTimePicker-CDB7ps45.js";
import { P as Popper, a as Dialog, b as DialogContent } from "./Tabs-CLdH6uZ6.js";
import { D as DynamicSvg } from "./index-ChTMAND8.js";
import { C as Collapse, H as HelpOutline, c as classNames, A as Accordion, a as AccordionSummary, d as default_1$s, b as AccordionDetails } from "./index-ZrKKhhhQ.js";
import { C as CardMedia, a as Close } from "./Close-DY1WrJHS.js";
import { F as FormControlLabel } from "./FormControlLabel-1NyMPPRG.js";
import { C as Checkbox } from "./Checkbox-CWvCRXaG.js";
import { D as DatePicker, T as TimePicker } from "./DatePicker-UkMUSWgH.js";
import { d as default_1$q } from "./Delete-CegMG_AQ.js";
import { C as Card } from "./Card-CH4VnLZu.js";
import { N as NAVIGATION_MODE } from "./survey-B8WvHOv0.js";
import { u as useBoolean } from "./use-boolean-yT2WGMvb.js";
import "./radioClasses-Djyx9JBx.js";
import "./tableRowClasses-BrmlRMuN.js";
import "./SwitchBase-Dmam6tVo.js";
import "./RadioGroupContext-D81a66YO.js";
import "./InputAdornment-AZrcp9XE.js";
const BasicFuncs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get LINEAR_REGRESSION() {
    return LINEAR_REGRESSION;
  },
  get LOWER() {
    return LOWER;
  },
  get NOW() {
    return NOW;
  },
  get RELATIVE_DATETIME() {
    return RELATIVE_DATETIME;
  },
  get UPPER() {
    return UPPER;
  }
}, Symbol.toStringTag, { value: "Module" }));
function _objectWithoutProperties$2(e2, t2) {
  if (null == e2) return {};
  var o, r2, i2 = _objectWithoutPropertiesLoose(e2, t2);
  if (Object.getOwnPropertySymbols) {
    var s2 = Object.getOwnPropertySymbols(e2);
    for (r2 = 0; r2 < s2.length; r2++) o = s2[r2], t2.includes(o) || {}.propertyIsEnumerable.call(e2, o) && (i2[o] = e2[o]);
  }
  return i2;
}
var voidElements = {
  "area": true,
  "base": true,
  "br": true,
  "col": true,
  "embed": true,
  "hr": true,
  "img": true,
  "input": true,
  "link": true,
  "meta": true,
  "param": true,
  "source": true,
  "track": true,
  "wbr": true
};
const e = /* @__PURE__ */ getDefaultExportFromCjs(voidElements);
var t = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
function n(n2) {
  var r2 = { type: "tag", name: "", voidElement: false, attrs: {}, children: [] }, i2 = n2.match(/<\/?([^\s]+?)[/\s>]/);
  if (i2 && (r2.name = i2[1], (e[i2[1]] || "/" === n2.charAt(n2.length - 2)) && (r2.voidElement = true), r2.name.startsWith("!--"))) {
    var s2 = n2.indexOf("-->");
    return { type: "comment", comment: -1 !== s2 ? n2.slice(4, s2) : "" };
  }
  for (var a2 = new RegExp(t), c2 = null; null !== (c2 = a2.exec(n2)); ) if (c2[0].trim()) if (c2[1]) {
    var o = c2[1].trim(), l = [o, ""];
    o.indexOf("=") > -1 && (l = o.split("=")), r2.attrs[l[0]] = l[1], a2.lastIndex--;
  } else c2[2] && (r2.attrs[c2[2]] = c2[3].trim().substring(1, c2[3].length - 1));
  return r2;
}
var r = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g, i = /^\s*$/, s = /* @__PURE__ */ Object.create(null);
function a(e2, t2) {
  switch (t2.type) {
    case "text":
      return e2 + t2.content;
    case "tag":
      return e2 += "<" + t2.name + (t2.attrs ? function(e3) {
        var t3 = [];
        for (var n2 in e3) t3.push(n2 + '="' + e3[n2] + '"');
        return t3.length ? " " + t3.join(" ") : "";
      }(t2.attrs) : "") + (t2.voidElement ? "/>" : ">"), t2.voidElement ? e2 : e2 + t2.children.reduce(a, "") + "</" + t2.name + ">";
    case "comment":
      return e2 + "<!--" + t2.comment + "-->";
  }
}
var c = { parse: function(e2, t2) {
  t2 || (t2 = {}), t2.components || (t2.components = s);
  var a2, c2 = [], o = [], l = -1, m = false;
  if (0 !== e2.indexOf("<")) {
    var u = e2.indexOf("<");
    c2.push({ type: "text", content: -1 === u ? e2 : e2.substring(0, u) });
  }
  return e2.replace(r, function(r2, s2) {
    if (m) {
      if (r2 !== "</" + a2.name + ">") return;
      m = false;
    }
    var u2, f = "/" !== r2.charAt(1), h = r2.startsWith("<!--"), p = s2 + r2.length, d = e2.charAt(p);
    if (h) {
      var v = n(r2);
      return l < 0 ? (c2.push(v), c2) : ((u2 = o[l]).children.push(v), c2);
    }
    if (f && (l++, "tag" === (a2 = n(r2)).type && t2.components[a2.name] && (a2.type = "component", m = true), a2.voidElement || m || !d || "<" === d || a2.children.push({ type: "text", content: e2.slice(p, e2.indexOf("<", p)) }), 0 === l && c2.push(a2), (u2 = o[l - 1]) && u2.children.push(a2), o[l] = a2), (!f || a2.voidElement) && (l > -1 && (a2.voidElement || a2.name === r2.slice(2, -1)) && (l--, a2 = -1 === l ? c2 : o[l]), !m && "<" !== d && d)) {
      u2 = -1 === l ? c2 : o[l].children;
      var x = e2.indexOf("<", p), g = e2.slice(p, -1 === x ? void 0 : x);
      i.test(g) && (g = " "), (x > -1 && l + u2.length >= 0 || " " !== g) && u2.push({ type: "text", content: g });
    }
  }), c2;
}, stringify: function(e2) {
  return e2.reduce(function(e3, t2) {
    return e3 + a("", t2);
  }, "");
} };
var _excluded$l = ["format"], _excluded2$3 = ["children", "count", "parent", "i18nKey", "context", "tOptions", "values", "defaults", "components", "ns", "i18n", "t", "shouldUnescape"];
function ownKeys$G(object, enumerableOnly) {
  var keys4 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$E(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$G(Object(source), true).forEach(function(key) {
        _defineProperty$4(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$G(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function hasChildren$1(node, checkLength) {
  if (!node) return false;
  var base = node.props ? node.props.children : node.children;
  if (checkLength) return base.length > 0;
  return !!base;
}
function getChildren(node) {
  if (!node) return [];
  return node.props ? node.props.children : node.children;
}
function hasValidReactChildren(children) {
  if (Object.prototype.toString.call(children) !== "[object Array]") return false;
  return children.every(function(child) {
    return reactExports.isValidElement(child);
  });
}
function getAsArray(data) {
  return Array.isArray(data) ? data : [data];
}
function mergeProps(source, target) {
  var newTarget = _objectSpread$E({}, target);
  newTarget.props = Object.assign(source.props, target.props);
  return newTarget;
}
function nodesToString(children, i18nOptions) {
  if (!children) return "";
  var stringNode = "";
  var childrenArray = getAsArray(children);
  var keepArray = i18nOptions.transSupportBasicHtmlNodes && i18nOptions.transKeepBasicHtmlNodesFor ? i18nOptions.transKeepBasicHtmlNodesFor : [];
  childrenArray.forEach(function(child, childIndex) {
    if (typeof child === "string") {
      stringNode += "".concat(child);
    } else if (reactExports.isValidElement(child)) {
      var childPropsCount = Object.keys(child.props).length;
      var shouldKeepChild = keepArray.indexOf(child.type) > -1;
      var childChildren = child.props.children;
      if (!childChildren && shouldKeepChild && childPropsCount === 0) {
        stringNode += "<".concat(child.type, "/>");
      } else if (!childChildren && (!shouldKeepChild || childPropsCount !== 0)) {
        stringNode += "<".concat(childIndex, "></").concat(childIndex, ">");
      } else if (child.props.i18nIsDynamicList) {
        stringNode += "<".concat(childIndex, "></").concat(childIndex, ">");
      } else if (shouldKeepChild && childPropsCount === 1 && typeof childChildren === "string") {
        stringNode += "<".concat(child.type, ">").concat(childChildren, "</").concat(child.type, ">");
      } else {
        var content = nodesToString(childChildren, i18nOptions);
        stringNode += "<".concat(childIndex, ">").concat(content, "</").concat(childIndex, ">");
      }
    } else if (child === null) {
      warn$1("Trans: the passed in value is invalid - seems you passed in a null child.");
    } else if (_typeof$3(child) === "object") {
      var format2 = child.format, clone3 = _objectWithoutProperties$2(child, _excluded$l);
      var keys4 = Object.keys(clone3);
      if (keys4.length === 1) {
        var value = format2 ? "".concat(keys4[0], ", ").concat(format2) : keys4[0];
        stringNode += "{{".concat(value, "}}");
      } else {
        warn$1("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", child);
      }
    } else {
      warn$1("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", child);
    }
  });
  return stringNode;
}
function renderNodes(children, targetString, i18n2, i18nOptions, combinedTOpts, shouldUnescape) {
  if (targetString === "") return [];
  var keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];
  var emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.join("|")).test(targetString);
  if (!children && !emptyChildrenButNeedsHandling) return [targetString];
  var data = {};
  function getData(childs) {
    var childrenArray = getAsArray(childs);
    childrenArray.forEach(function(child) {
      if (typeof child === "string") return;
      if (hasChildren$1(child)) getData(getChildren(child));
      else if (_typeof$3(child) === "object" && !reactExports.isValidElement(child)) Object.assign(data, child);
    });
  }
  getData(children);
  var ast = c.parse("<0>".concat(targetString, "</0>"));
  var opts = _objectSpread$E(_objectSpread$E({}, data), combinedTOpts);
  function renderInner(child, node, rootReactNode) {
    var childs = getChildren(child);
    var mappedChildren = mapAST(childs, node.children, rootReactNode);
    return hasValidReactChildren(childs) && mappedChildren.length === 0 ? childs : mappedChildren;
  }
  function pushTranslatedJSX(child, inner, mem, i2, isVoid) {
    if (child.dummy) child.children = inner;
    mem.push(reactExports.cloneElement(child, _objectSpread$E(_objectSpread$E({}, child.props), {}, {
      key: i2
    }), isVoid ? void 0 : inner));
  }
  function mapAST(reactNode, astNode, rootReactNode) {
    var reactNodes = getAsArray(reactNode);
    var astNodes = getAsArray(astNode);
    return astNodes.reduce(function(mem, node, i2) {
      var translationContent = node.children && node.children[0] && node.children[0].content && i18n2.services.interpolator.interpolate(node.children[0].content, opts, i18n2.language);
      if (node.type === "tag") {
        var tmp = reactNodes[parseInt(node.name, 10)];
        if (!tmp && rootReactNode.length === 1 && rootReactNode[0][node.name]) tmp = rootReactNode[0][node.name];
        if (!tmp) tmp = {};
        var child = Object.keys(node.attrs).length !== 0 ? mergeProps({
          props: node.attrs
        }, tmp) : tmp;
        var isElement = reactExports.isValidElement(child);
        var isValidTranslationWithChildren = isElement && hasChildren$1(node, true) && !node.voidElement;
        var isEmptyTransWithHTML = emptyChildrenButNeedsHandling && _typeof$3(child) === "object" && child.dummy && !isElement;
        var isKnownComponent = _typeof$3(children) === "object" && children !== null && Object.hasOwnProperty.call(children, node.name);
        if (typeof child === "string") {
          var value = i18n2.services.interpolator.interpolate(child, opts, i18n2.language);
          mem.push(value);
        } else if (hasChildren$1(child) || isValidTranslationWithChildren) {
          var inner = renderInner(child, node, rootReactNode);
          pushTranslatedJSX(child, inner, mem, i2);
        } else if (isEmptyTransWithHTML) {
          var _inner = mapAST(reactNodes, node.children, rootReactNode);
          mem.push(reactExports.cloneElement(child, _objectSpread$E(_objectSpread$E({}, child.props), {}, {
            key: i2
          }), _inner));
        } else if (Number.isNaN(parseFloat(node.name))) {
          if (isKnownComponent) {
            var _inner2 = renderInner(child, node, rootReactNode);
            pushTranslatedJSX(child, _inner2, mem, i2, node.voidElement);
          } else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) {
            if (node.voidElement) {
              mem.push(reactExports.createElement(node.name, {
                key: "".concat(node.name, "-").concat(i2)
              }));
            } else {
              var _inner3 = mapAST(reactNodes, node.children, rootReactNode);
              mem.push(reactExports.createElement(node.name, {
                key: "".concat(node.name, "-").concat(i2)
              }, _inner3));
            }
          } else if (node.voidElement) {
            mem.push("<".concat(node.name, " />"));
          } else {
            var _inner4 = mapAST(reactNodes, node.children, rootReactNode);
            mem.push("<".concat(node.name, ">").concat(_inner4, "</").concat(node.name, ">"));
          }
        } else if (_typeof$3(child) === "object" && !isElement) {
          var content = node.children[0] ? translationContent : null;
          if (content) mem.push(content);
        } else if (node.children.length === 1 && translationContent) {
          mem.push(reactExports.cloneElement(child, _objectSpread$E(_objectSpread$E({}, child.props), {}, {
            key: i2
          }), translationContent));
        } else {
          mem.push(reactExports.cloneElement(child, _objectSpread$E(_objectSpread$E({}, child.props), {}, {
            key: i2
          })));
        }
      } else if (node.type === "text") {
        var wrapTextNodes = i18nOptions.transWrapTextNodes;
        var _content = shouldUnescape ? i18nOptions.unescape(i18n2.services.interpolator.interpolate(node.content, opts, i18n2.language)) : i18n2.services.interpolator.interpolate(node.content, opts, i18n2.language);
        if (wrapTextNodes) {
          mem.push(reactExports.createElement(wrapTextNodes, {
            key: "".concat(node.name, "-").concat(i2)
          }, _content));
        } else {
          mem.push(_content);
        }
      }
      return mem;
    }, []);
  }
  var result = mapAST([{
    dummy: true,
    children: children || []
  }], ast, getAsArray(children || []));
  return getChildren(result[0]);
}
function Trans(_ref) {
  var children = _ref.children, count2 = _ref.count, parent2 = _ref.parent, i18nKey = _ref.i18nKey, context2 = _ref.context, _ref$tOptions = _ref.tOptions, tOptions = _ref$tOptions === void 0 ? {} : _ref$tOptions, values2 = _ref.values, defaults2 = _ref.defaults, components = _ref.components, ns = _ref.ns, i18nFromProps = _ref.i18n, tFromProps = _ref.t, shouldUnescape = _ref.shouldUnescape, additionalProps = _objectWithoutProperties$2(_ref, _excluded2$3);
  var _ref2 = reactExports.useContext(I18nContext) || {}, i18nFromContext = _ref2.i18n, defaultNSFromContext = _ref2.defaultNS;
  var i18n2 = i18nFromProps || i18nFromContext || getI18n();
  if (!i18n2) {
    warnOnce("You will need to pass in an i18next instance by using i18nextReactModule");
    return children;
  }
  var t2 = tFromProps || i18n2.t.bind(i18n2) || function(k) {
    return k;
  };
  if (context2) tOptions.context = context2;
  var reactI18nextOptions = _objectSpread$E(_objectSpread$E({}, getDefaults()), i18n2.options && i18n2.options.react);
  var namespaces = ns || t2.ns || defaultNSFromContext || i18n2.options && i18n2.options.defaultNS;
  namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
  var defaultValue = defaults2 || nodesToString(children, reactI18nextOptions) || reactI18nextOptions.transEmptyNodeValue || i18nKey;
  var hashTransKey = reactI18nextOptions.hashTransKey;
  var key = i18nKey || (hashTransKey ? hashTransKey(defaultValue) : defaultValue);
  var interpolationOverride = values2 ? tOptions.interpolation : {
    interpolation: _objectSpread$E(_objectSpread$E({}, tOptions.interpolation), {}, {
      prefix: "#$?",
      suffix: "?$#"
    })
  };
  var combinedTOpts = _objectSpread$E(_objectSpread$E(_objectSpread$E(_objectSpread$E({}, tOptions), {}, {
    count: count2
  }, values2), interpolationOverride), {}, {
    defaultValue,
    ns: namespaces
  });
  var translation = key ? t2(key, combinedTOpts) : defaultValue;
  var content = renderNodes(components || children, translation, i18n2, reactI18nextOptions, combinedTOpts, shouldUnescape);
  var useAsParent = parent2 !== void 0 ? parent2 : reactI18nextOptions.defaultTransParent;
  return useAsParent ? reactExports.createElement(useAsParent, additionalProps, content) : content;
}
function getValidReactChildren(children) {
  return reactExports.Children.toArray(children).filter((child) => /* @__PURE__ */ reactExports.isValidElement(child));
}
const visuallyHidden = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  whiteSpace: "nowrap",
  width: "1px"
};
function stripDiacritics(string) {
  return typeof string.normalize !== "undefined" ? string.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : string;
}
function createFilterOptions(config2 = {}) {
  const {
    ignoreAccents = true,
    ignoreCase = true,
    limit,
    matchFrom = "any",
    stringify,
    trim = false
  } = config2;
  return (options, {
    inputValue: inputValue2,
    getOptionLabel
  }) => {
    let input2 = trim ? inputValue2.trim() : inputValue2;
    if (ignoreCase) {
      input2 = input2.toLowerCase();
    }
    if (ignoreAccents) {
      input2 = stripDiacritics(input2);
    }
    const filteredOptions = !input2 ? options : options.filter((option) => {
      let candidate = (stringify || getOptionLabel)(option);
      if (ignoreCase) {
        candidate = candidate.toLowerCase();
      }
      if (ignoreAccents) {
        candidate = stripDiacritics(candidate);
      }
      return matchFrom === "start" ? candidate.indexOf(input2) === 0 : candidate.indexOf(input2) > -1;
    });
    return typeof limit === "number" ? filteredOptions.slice(0, limit) : filteredOptions;
  };
}
function findIndex(array, comp) {
  for (let i2 = 0; i2 < array.length; i2 += 1) {
    if (comp(array[i2])) {
      return i2;
    }
  }
  return -1;
}
const defaultFilterOptions = createFilterOptions();
const pageSize = 5;
const defaultIsActiveElementInListbox = (listboxRef) => {
  var _listboxRef$current$p;
  return listboxRef.current !== null && ((_listboxRef$current$p = listboxRef.current.parentElement) == null ? void 0 : _listboxRef$current$p.contains(document.activeElement));
};
function useAutocomplete(props) {
  const {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_isActiveElementInListbox = defaultIsActiveElementInListbox,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_classNamePrefix = "Mui",
    autoComplete = false,
    autoHighlight = false,
    autoSelect = false,
    blurOnSelect = false,
    clearOnBlur = !props.freeSolo,
    clearOnEscape = false,
    componentName: componentName2 = "useAutocomplete",
    defaultValue = props.multiple ? [] : null,
    disableClearable = false,
    disableCloseOnSelect = false,
    disabled: disabledProp,
    disabledItemsFocusable = false,
    disableListWrap = false,
    filterOptions = defaultFilterOptions,
    filterSelectedOptions = false,
    freeSolo = false,
    getOptionDisabled,
    getOptionKey,
    getOptionLabel: getOptionLabelProp = (option) => {
      var _option$label;
      return (_option$label = option.label) != null ? _option$label : option;
    },
    groupBy: groupBy2,
    handleHomeEndKeys = !props.freeSolo,
    id: idProp,
    includeInputInList = false,
    inputValue: inputValueProp,
    isOptionEqualToValue = (option, value2) => option === value2,
    multiple = false,
    onChange,
    onClose,
    onHighlightChange,
    onInputChange,
    onOpen,
    open: openProp,
    openOnFocus = false,
    options,
    readOnly = false,
    selectOnFocus = !props.freeSolo,
    value: valueProp
  } = props;
  const id2 = useId(idProp);
  let getOptionLabel = getOptionLabelProp;
  getOptionLabel = (option) => {
    const optionLabel = getOptionLabelProp(option);
    if (typeof optionLabel !== "string") {
      return String(optionLabel);
    }
    return optionLabel;
  };
  const ignoreFocus = reactExports.useRef(false);
  const firstFocus = reactExports.useRef(true);
  const inputRef = reactExports.useRef(null);
  const listboxRef = reactExports.useRef(null);
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  const [focusedTag, setFocusedTag] = reactExports.useState(-1);
  const defaultHighlighted = autoHighlight ? 0 : -1;
  const highlightedIndexRef = reactExports.useRef(defaultHighlighted);
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: componentName2
  });
  const [inputValue2, setInputValueState] = useControlled({
    controlled: inputValueProp,
    default: "",
    name: componentName2,
    state: "inputValue"
  });
  const [focused, setFocused] = reactExports.useState(false);
  const resetInputValue = reactExports.useCallback((event, newValue) => {
    const isOptionSelected = multiple ? value.length < newValue.length : newValue !== null;
    if (!isOptionSelected && !clearOnBlur) {
      return;
    }
    let newInputValue;
    if (multiple) {
      newInputValue = "";
    } else if (newValue == null) {
      newInputValue = "";
    } else {
      const optionLabel = getOptionLabel(newValue);
      newInputValue = typeof optionLabel === "string" ? optionLabel : "";
    }
    if (inputValue2 === newInputValue) {
      return;
    }
    setInputValueState(newInputValue);
    if (onInputChange) {
      onInputChange(event, newInputValue, "reset");
    }
  }, [getOptionLabel, inputValue2, multiple, onInputChange, setInputValueState, clearOnBlur, value]);
  const [open, setOpenState] = useControlled({
    controlled: openProp,
    default: false,
    name: componentName2,
    state: "open"
  });
  const [inputPristine, setInputPristine] = reactExports.useState(true);
  const inputValueIsSelectedValue = !multiple && value != null && inputValue2 === getOptionLabel(value);
  const popupOpen = open && !readOnly;
  const filteredOptions = popupOpen ? filterOptions(
    options.filter((option) => {
      if (filterSelectedOptions && (multiple ? value : [value]).some((value2) => value2 !== null && isOptionEqualToValue(option, value2))) {
        return false;
      }
      return true;
    }),
    // we use the empty string to manipulate `filterOptions` to not filter any options
    // i.e. the filter predicate always returns true
    {
      inputValue: inputValueIsSelectedValue && inputPristine ? "" : inputValue2,
      getOptionLabel
    }
  ) : [];
  const previousProps = usePreviousProps({
    filteredOptions,
    value,
    inputValue: inputValue2
  });
  reactExports.useEffect(() => {
    const valueChange = value !== previousProps.value;
    if (focused && !valueChange) {
      return;
    }
    if (freeSolo && !valueChange) {
      return;
    }
    resetInputValue(null, value);
  }, [value, resetInputValue, focused, previousProps.value, freeSolo]);
  const listboxAvailable = open && filteredOptions.length > 0 && !readOnly;
  const focusTag = useEventCallback((tagToFocus) => {
    if (tagToFocus === -1) {
      inputRef.current.focus();
    } else {
      anchorEl.querySelector('[data-tag-index="'.concat(tagToFocus, '"]')).focus();
    }
  });
  reactExports.useEffect(() => {
    if (multiple && focusedTag > value.length - 1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
  }, [value, multiple, focusedTag, focusTag]);
  function validOptionIndex(index2, direction) {
    if (!listboxRef.current || index2 < 0 || index2 >= filteredOptions.length) {
      return -1;
    }
    let nextFocus = index2;
    while (true) {
      const option = listboxRef.current.querySelector('[data-option-index="'.concat(nextFocus, '"]'));
      const nextFocusDisabled = disabledItemsFocusable ? false : !option || option.disabled || option.getAttribute("aria-disabled") === "true";
      if (option && option.hasAttribute("tabindex") && !nextFocusDisabled) {
        return nextFocus;
      }
      if (direction === "next") {
        nextFocus = (nextFocus + 1) % filteredOptions.length;
      } else {
        nextFocus = (nextFocus - 1 + filteredOptions.length) % filteredOptions.length;
      }
      if (nextFocus === index2) {
        return -1;
      }
    }
  }
  const setHighlightedIndex = useEventCallback(({
    event,
    index: index2,
    reason = "auto"
  }) => {
    highlightedIndexRef.current = index2;
    if (index2 === -1) {
      inputRef.current.removeAttribute("aria-activedescendant");
    } else {
      inputRef.current.setAttribute("aria-activedescendant", "".concat(id2, "-option-").concat(index2));
    }
    if (onHighlightChange) {
      onHighlightChange(event, index2 === -1 ? null : filteredOptions[index2], reason);
    }
    if (!listboxRef.current) {
      return;
    }
    const prev = listboxRef.current.querySelector('[role="option"].'.concat(unstable_classNamePrefix, "-focused"));
    if (prev) {
      prev.classList.remove("".concat(unstable_classNamePrefix, "-focused"));
      prev.classList.remove("".concat(unstable_classNamePrefix, "-focusVisible"));
    }
    let listboxNode = listboxRef.current;
    if (listboxRef.current.getAttribute("role") !== "listbox") {
      listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]');
    }
    if (!listboxNode) {
      return;
    }
    if (index2 === -1) {
      listboxNode.scrollTop = 0;
      return;
    }
    const option = listboxRef.current.querySelector('[data-option-index="'.concat(index2, '"]'));
    if (!option) {
      return;
    }
    option.classList.add("".concat(unstable_classNamePrefix, "-focused"));
    if (reason === "keyboard") {
      option.classList.add("".concat(unstable_classNamePrefix, "-focusVisible"));
    }
    if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== "mouse" && reason !== "touch") {
      const element = option;
      const scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
      const elementBottom = element.offsetTop + element.offsetHeight;
      if (elementBottom > scrollBottom) {
        listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
      } else if (element.offsetTop - element.offsetHeight * (groupBy2 ? 1.3 : 0) < listboxNode.scrollTop) {
        listboxNode.scrollTop = element.offsetTop - element.offsetHeight * (groupBy2 ? 1.3 : 0);
      }
    }
  });
  const changeHighlightedIndex = useEventCallback(({
    event,
    diff: diff2,
    direction = "next",
    reason = "auto"
  }) => {
    if (!popupOpen) {
      return;
    }
    const getNextIndex = () => {
      const maxIndex = filteredOptions.length - 1;
      if (diff2 === "reset") {
        return defaultHighlighted;
      }
      if (diff2 === "start") {
        return 0;
      }
      if (diff2 === "end") {
        return maxIndex;
      }
      const newIndex = highlightedIndexRef.current + diff2;
      if (newIndex < 0) {
        if (newIndex === -1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap && highlightedIndexRef.current !== -1 || Math.abs(diff2) > 1) {
          return 0;
        }
        return maxIndex;
      }
      if (newIndex > maxIndex) {
        if (newIndex === maxIndex + 1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap || Math.abs(diff2) > 1) {
          return maxIndex;
        }
        return 0;
      }
      return newIndex;
    };
    const nextIndex = validOptionIndex(getNextIndex(), direction);
    setHighlightedIndex({
      index: nextIndex,
      reason,
      event
    });
    if (autoComplete && diff2 !== "reset") {
      if (nextIndex === -1) {
        inputRef.current.value = inputValue2;
      } else {
        const option = getOptionLabel(filteredOptions[nextIndex]);
        inputRef.current.value = option;
        const index2 = option.toLowerCase().indexOf(inputValue2.toLowerCase());
        if (index2 === 0 && inputValue2.length > 0) {
          inputRef.current.setSelectionRange(inputValue2.length, option.length);
        }
      }
    }
  });
  const getPreviousHighlightedOptionIndex = () => {
    const isSameValue = (value1, value2) => {
      const label1 = value1 ? getOptionLabel(value1) : "";
      const label2 = value2 ? getOptionLabel(value2) : "";
      return label1 === label2;
    };
    if (highlightedIndexRef.current !== -1 && previousProps.filteredOptions && previousProps.filteredOptions.length !== filteredOptions.length && previousProps.inputValue === inputValue2 && (multiple ? value.length === previousProps.value.length && previousProps.value.every((val, i2) => getOptionLabel(value[i2]) === getOptionLabel(val)) : isSameValue(previousProps.value, value))) {
      const previousHighlightedOption = previousProps.filteredOptions[highlightedIndexRef.current];
      if (previousHighlightedOption) {
        return findIndex(filteredOptions, (option) => {
          return getOptionLabel(option) === getOptionLabel(previousHighlightedOption);
        });
      }
    }
    return -1;
  };
  const syncHighlightedIndex = reactExports.useCallback(() => {
    if (!popupOpen) {
      return;
    }
    const previousHighlightedOptionIndex = getPreviousHighlightedOptionIndex();
    if (previousHighlightedOptionIndex !== -1) {
      highlightedIndexRef.current = previousHighlightedOptionIndex;
      return;
    }
    const valueItem = multiple ? value[0] : value;
    if (filteredOptions.length === 0 || valueItem == null) {
      changeHighlightedIndex({
        diff: "reset"
      });
      return;
    }
    if (!listboxRef.current) {
      return;
    }
    if (valueItem != null) {
      const currentOption = filteredOptions[highlightedIndexRef.current];
      if (multiple && currentOption && findIndex(value, (val) => isOptionEqualToValue(currentOption, val)) !== -1) {
        return;
      }
      const itemIndex = findIndex(filteredOptions, (optionItem) => isOptionEqualToValue(optionItem, valueItem));
      if (itemIndex === -1) {
        changeHighlightedIndex({
          diff: "reset"
        });
      } else {
        setHighlightedIndex({
          index: itemIndex
        });
      }
      return;
    }
    if (highlightedIndexRef.current >= filteredOptions.length - 1) {
      setHighlightedIndex({
        index: filteredOptions.length - 1
      });
      return;
    }
    setHighlightedIndex({
      index: highlightedIndexRef.current
    });
  }, [
    // Only sync the highlighted index when the option switch between empty and not
    filteredOptions.length,
    // Don't sync the highlighted index with the value when multiple
    // eslint-disable-next-line react-hooks/exhaustive-deps
    multiple ? false : value,
    filterSelectedOptions,
    changeHighlightedIndex,
    setHighlightedIndex,
    popupOpen,
    inputValue2,
    multiple
  ]);
  const handleListboxRef = useEventCallback((node) => {
    setRef(listboxRef, node);
    if (!node) {
      return;
    }
    syncHighlightedIndex();
  });
  reactExports.useEffect(() => {
    syncHighlightedIndex();
  }, [syncHighlightedIndex]);
  const handleOpen = (event) => {
    if (open) {
      return;
    }
    setOpenState(true);
    setInputPristine(true);
    if (onOpen) {
      onOpen(event);
    }
  };
  const handleClose = (event, reason) => {
    if (!open) {
      return;
    }
    setOpenState(false);
    if (onClose) {
      onClose(event, reason);
    }
  };
  const handleValue = (event, newValue, reason, details) => {
    if (multiple) {
      if (value.length === newValue.length && value.every((val, i2) => val === newValue[i2])) {
        return;
      }
    } else if (value === newValue) {
      return;
    }
    if (onChange) {
      onChange(event, newValue, reason, details);
    }
    setValueState(newValue);
  };
  const isTouch = reactExports.useRef(false);
  const selectNewValue = (event, option, reasonProp = "selectOption", origin = "options") => {
    let reason = reasonProp;
    let newValue = option;
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = findIndex(newValue, (valueItem) => isOptionEqualToValue(option, valueItem));
      if (itemIndex === -1) {
        newValue.push(option);
      } else if (origin !== "freeSolo") {
        newValue.splice(itemIndex, 1);
        reason = "removeOption";
      }
    }
    resetInputValue(event, newValue);
    handleValue(event, newValue, reason, {
      option
    });
    if (!disableCloseOnSelect && (!event || !event.ctrlKey && !event.metaKey)) {
      handleClose(event, reason);
    }
    if (blurOnSelect === true || blurOnSelect === "touch" && isTouch.current || blurOnSelect === "mouse" && !isTouch.current) {
      inputRef.current.blur();
    }
  };
  function validTagIndex(index2, direction) {
    if (index2 === -1) {
      return -1;
    }
    let nextFocus = index2;
    while (true) {
      if (direction === "next" && nextFocus === value.length || direction === "previous" && nextFocus === -1) {
        return -1;
      }
      const option = anchorEl.querySelector('[data-tag-index="'.concat(nextFocus, '"]'));
      if (!option || !option.hasAttribute("tabindex") || option.disabled || option.getAttribute("aria-disabled") === "true") {
        nextFocus += direction === "next" ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }
  const handleFocusTag = (event, direction) => {
    if (!multiple) {
      return;
    }
    if (inputValue2 === "") {
      handleClose(event, "toggleInput");
    }
    let nextTag = focusedTag;
    if (focusedTag === -1) {
      if (inputValue2 === "" && direction === "previous") {
        nextTag = value.length - 1;
      }
    } else {
      nextTag += direction === "next" ? 1 : -1;
      if (nextTag < 0) {
        nextTag = 0;
      }
      if (nextTag === value.length) {
        nextTag = -1;
      }
    }
    nextTag = validTagIndex(nextTag, direction);
    setFocusedTag(nextTag);
    focusTag(nextTag);
  };
  const handleClear = (event) => {
    ignoreFocus.current = true;
    setInputValueState("");
    if (onInputChange) {
      onInputChange(event, "", "clear");
    }
    handleValue(event, multiple ? [] : null, "clear");
  };
  const handleKeyDown = (other) => (event) => {
    if (other.onKeyDown) {
      other.onKeyDown(event);
    }
    if (event.defaultMuiPrevented) {
      return;
    }
    if (focusedTag !== -1 && ["ArrowLeft", "ArrowRight"].indexOf(event.key) === -1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
    if (event.which !== 229) {
      switch (event.key) {
        case "Home":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "start",
              direction: "next",
              reason: "keyboard",
              event
            });
          }
          break;
        case "End":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "end",
              direction: "previous",
              reason: "keyboard",
              event
            });
          }
          break;
        case "PageUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -pageSize,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "PageDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: pageSize,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: 1,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -1,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowLeft":
          handleFocusTag(event, "previous");
          break;
        case "ArrowRight":
          handleFocusTag(event, "next");
          break;
        case "Enter":
          if (highlightedIndexRef.current !== -1 && popupOpen) {
            const option = filteredOptions[highlightedIndexRef.current];
            const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
            event.preventDefault();
            if (disabled) {
              return;
            }
            selectNewValue(event, option, "selectOption");
            if (autoComplete) {
              inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
            }
          } else if (freeSolo && inputValue2 !== "" && inputValueIsSelectedValue === false) {
            if (multiple) {
              event.preventDefault();
            }
            selectNewValue(event, inputValue2, "createOption", "freeSolo");
          }
          break;
        case "Escape":
          if (popupOpen) {
            event.preventDefault();
            event.stopPropagation();
            handleClose(event, "escape");
          } else if (clearOnEscape && (inputValue2 !== "" || multiple && value.length > 0)) {
            event.preventDefault();
            event.stopPropagation();
            handleClear(event);
          }
          break;
        case "Backspace":
          if (multiple && !readOnly && inputValue2 === "" && value.length > 0) {
            const index2 = focusedTag === -1 ? value.length - 1 : focusedTag;
            const newValue = value.slice();
            newValue.splice(index2, 1);
            handleValue(event, newValue, "removeOption", {
              option: value[index2]
            });
          }
          break;
        case "Delete":
          if (multiple && !readOnly && inputValue2 === "" && value.length > 0 && focusedTag !== -1) {
            const index2 = focusedTag;
            const newValue = value.slice();
            newValue.splice(index2, 1);
            handleValue(event, newValue, "removeOption", {
              option: value[index2]
            });
          }
          break;
      }
    }
  };
  const handleFocus3 = (event) => {
    setFocused(true);
    if (openOnFocus && !ignoreFocus.current) {
      handleOpen(event);
    }
  };
  const handleBlur = (event) => {
    if (unstable_isActiveElementInListbox(listboxRef)) {
      inputRef.current.focus();
      return;
    }
    setFocused(false);
    firstFocus.current = true;
    ignoreFocus.current = false;
    if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
      selectNewValue(event, filteredOptions[highlightedIndexRef.current], "blur");
    } else if (autoSelect && freeSolo && inputValue2 !== "") {
      selectNewValue(event, inputValue2, "blur", "freeSolo");
    } else if (clearOnBlur) {
      resetInputValue(event, value);
    }
    handleClose(event, "blur");
  };
  const handleInputChange = (event) => {
    const newValue = event.target.value;
    if (inputValue2 !== newValue) {
      setInputValueState(newValue);
      setInputPristine(false);
      if (onInputChange) {
        onInputChange(event, newValue, "input");
      }
    }
    if (newValue === "") {
      if (!disableClearable && !multiple) {
        handleValue(event, null, "clear");
      }
    } else {
      handleOpen(event);
    }
  };
  const handleOptionMouseMove = (event) => {
    const index2 = Number(event.currentTarget.getAttribute("data-option-index"));
    if (highlightedIndexRef.current !== index2) {
      setHighlightedIndex({
        event,
        index: index2,
        reason: "mouse"
      });
    }
  };
  const handleOptionTouchStart = (event) => {
    setHighlightedIndex({
      event,
      index: Number(event.currentTarget.getAttribute("data-option-index")),
      reason: "touch"
    });
    isTouch.current = true;
  };
  const handleOptionClick = (event) => {
    const index2 = Number(event.currentTarget.getAttribute("data-option-index"));
    selectNewValue(event, filteredOptions[index2], "selectOption");
    isTouch.current = false;
  };
  const handleTagDelete = (index2) => (event) => {
    const newValue = value.slice();
    newValue.splice(index2, 1);
    handleValue(event, newValue, "removeOption", {
      option: value[index2]
    });
  };
  const handlePopupIndicator = (event) => {
    if (open) {
      handleClose(event, "toggleInput");
    } else {
      handleOpen(event);
    }
  };
  const handleMouseDown = (event) => {
    if (!event.currentTarget.contains(event.target)) {
      return;
    }
    if (event.target.getAttribute("id") !== id2) {
      event.preventDefault();
    }
  };
  const handleClick = (event) => {
    if (!event.currentTarget.contains(event.target)) {
      return;
    }
    inputRef.current.focus();
    if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
      inputRef.current.select();
    }
    firstFocus.current = false;
  };
  const handleInputMouseDown = (event) => {
    if (!disabledProp && (inputValue2 === "" || !open)) {
      handlePopupIndicator(event);
    }
  };
  let dirty = freeSolo && inputValue2.length > 0;
  dirty = dirty || (multiple ? value.length > 0 : value !== null);
  let groupedOptions = filteredOptions;
  if (groupBy2) {
    groupedOptions = filteredOptions.reduce((acc, option, index2) => {
      const group3 = groupBy2(option);
      if (acc.length > 0 && acc[acc.length - 1].group === group3) {
        acc[acc.length - 1].options.push(option);
      } else {
        acc.push({
          key: index2,
          index: index2,
          group: group3,
          options: [option]
        });
      }
      return acc;
    }, []);
  }
  if (disabledProp && focused) {
    handleBlur();
  }
  return {
    getRootProps: (other = {}) => _extends$h({
      "aria-owns": listboxAvailable ? "".concat(id2, "-listbox") : null
    }, other, {
      onKeyDown: handleKeyDown(other),
      onMouseDown: handleMouseDown,
      onClick: handleClick
    }),
    getInputLabelProps: () => ({
      id: "".concat(id2, "-label"),
      htmlFor: id2
    }),
    getInputProps: () => ({
      id: id2,
      value: inputValue2,
      onBlur: handleBlur,
      onFocus: handleFocus3,
      onChange: handleInputChange,
      onMouseDown: handleInputMouseDown,
      // if open then this is handled imperatively so don't let react override
      // only have an opinion about this when closed
      "aria-activedescendant": popupOpen ? "" : null,
      "aria-autocomplete": autoComplete ? "both" : "list",
      "aria-controls": listboxAvailable ? "".concat(id2, "-listbox") : void 0,
      "aria-expanded": listboxAvailable,
      // Disable browser's suggestion that might overlap with the popup.
      // Handle autocomplete but not autofill.
      autoComplete: "off",
      ref: inputRef,
      autoCapitalize: "none",
      spellCheck: "false",
      role: "combobox",
      disabled: disabledProp
    }),
    getClearProps: () => ({
      tabIndex: -1,
      type: "button",
      onClick: handleClear
    }),
    getPopupIndicatorProps: () => ({
      tabIndex: -1,
      type: "button",
      onClick: handlePopupIndicator
    }),
    getTagProps: ({
      index: index2
    }) => _extends$h({
      key: index2,
      "data-tag-index": index2,
      tabIndex: -1
    }, !readOnly && {
      onDelete: handleTagDelete(index2)
    }),
    getListboxProps: () => ({
      role: "listbox",
      id: "".concat(id2, "-listbox"),
      "aria-labelledby": "".concat(id2, "-label"),
      ref: handleListboxRef,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }),
    getOptionProps: ({
      index: index2,
      option
    }) => {
      var _getOptionKey;
      const selected = (multiple ? value : [value]).some((value2) => value2 != null && isOptionEqualToValue(option, value2));
      const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
      return {
        key: (_getOptionKey = getOptionKey == null ? void 0 : getOptionKey(option)) != null ? _getOptionKey : getOptionLabel(option),
        tabIndex: -1,
        role: "option",
        id: "".concat(id2, "-option-").concat(index2),
        onMouseMove: handleOptionMouseMove,
        onClick: handleOptionClick,
        onTouchStart: handleOptionTouchStart,
        "data-option-index": index2,
        "aria-disabled": disabled,
        "aria-selected": selected
      };
    },
    id: id2,
    inputValue: inputValue2,
    value,
    dirty,
    expanded: popupOpen && anchorEl,
    popupOpen,
    focused: focused || focusedTag !== -1,
    anchorEl,
    setAnchorEl,
    focusedTag,
    groupedOptions
  };
}
function getListSubheaderUtilityClass(slot) {
  return generateUtilityClass("MuiListSubheader", slot);
}
generateUtilityClasses("MuiListSubheader", ["root", "colorPrimary", "colorInherit", "gutters", "inset", "sticky"]);
const _excluded$k = ["className", "color", "component", "disableGutters", "disableSticky", "inset"];
const useUtilityClasses$9 = (ownerState) => {
  const {
    classes,
    color,
    disableGutters,
    inset,
    disableSticky
  } = ownerState;
  const slots = {
    root: ["root", color !== "default" && "color".concat(capitalize$1(color)), !disableGutters && "gutters", inset && "inset", !disableSticky && "sticky"]
  };
  return composeClasses(slots, getListSubheaderUtilityClass, classes);
};
const ListSubheaderRoot = styled("li", {
  name: "MuiListSubheader",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "default" && styles2["color".concat(capitalize$1(ownerState.color))], !ownerState.disableGutters && styles2.gutters, ownerState.inset && styles2.inset, !ownerState.disableSticky && styles2.sticky];
  }
})(({
  theme,
  ownerState
}) => _extends$h({
  boxSizing: "border-box",
  lineHeight: "48px",
  listStyle: "none",
  color: (theme.vars || theme).palette.text.secondary,
  fontFamily: theme.typography.fontFamily,
  fontWeight: theme.typography.fontWeightMedium,
  fontSize: theme.typography.pxToRem(14)
}, ownerState.color === "primary" && {
  color: (theme.vars || theme).palette.primary.main
}, ownerState.color === "inherit" && {
  color: "inherit"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.inset && {
  paddingLeft: 72
}, !ownerState.disableSticky && {
  position: "sticky",
  top: 0,
  zIndex: 1,
  backgroundColor: (theme.vars || theme).palette.background.paper
}));
const ListSubheader = /* @__PURE__ */ reactExports.forwardRef(function ListSubheader2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListSubheader"
  });
  const {
    className,
    color = "default",
    component = "li",
    disableGutters = false,
    disableSticky = false,
    inset = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$k);
  const ownerState = _extends$h({}, props, {
    color,
    component,
    disableGutters,
    disableSticky,
    inset
  });
  const classes = useUtilityClasses$9(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListSubheaderRoot, _extends$h({
    as: component,
    className: clsx(classes.root, className),
    ref: ref2,
    ownerState
  }, other));
});
ListSubheader.muiSkipListHighlight = true;
var _ClearIcon, _ArrowDropDownIcon;
const _excluded$j = ["autoComplete", "autoHighlight", "autoSelect", "blurOnSelect", "ChipProps", "className", "clearIcon", "clearOnBlur", "clearOnEscape", "clearText", "closeText", "componentsProps", "defaultValue", "disableClearable", "disableCloseOnSelect", "disabled", "disabledItemsFocusable", "disableListWrap", "disablePortal", "filterOptions", "filterSelectedOptions", "forcePopupIcon", "freeSolo", "fullWidth", "getLimitTagsText", "getOptionDisabled", "getOptionKey", "getOptionLabel", "isOptionEqualToValue", "groupBy", "handleHomeEndKeys", "id", "includeInputInList", "inputValue", "limitTags", "ListboxComponent", "ListboxProps", "loading", "loadingText", "multiple", "noOptionsText", "onChange", "onClose", "onHighlightChange", "onInputChange", "onOpen", "open", "openOnFocus", "openText", "options", "PaperComponent", "PopperComponent", "popupIcon", "readOnly", "renderGroup", "renderInput", "renderOption", "renderTags", "selectOnFocus", "size", "slotProps", "value"], _excluded2$2 = ["ref"], _excluded3$1 = ["key"], _excluded4 = ["key"];
const useUtilityClasses$8 = (ownerState) => {
  const {
    classes,
    disablePortal,
    expanded,
    focused,
    fullWidth: fullWidth2,
    hasClearIcon,
    hasPopupIcon,
    inputFocused,
    popupOpen,
    size
  } = ownerState;
  const slots = {
    root: ["root", expanded && "expanded", focused && "focused", fullWidth2 && "fullWidth", hasClearIcon && "hasClearIcon", hasPopupIcon && "hasPopupIcon"],
    inputRoot: ["inputRoot"],
    input: ["input", inputFocused && "inputFocused"],
    tag: ["tag", "tagSize".concat(capitalize$1(size))],
    endAdornment: ["endAdornment"],
    clearIndicator: ["clearIndicator"],
    popupIndicator: ["popupIndicator", popupOpen && "popupIndicatorOpen"],
    popper: ["popper", disablePortal && "popperDisablePortal"],
    paper: ["paper"],
    listbox: ["listbox"],
    loading: ["loading"],
    noOptions: ["noOptions"],
    option: ["option"],
    groupLabel: ["groupLabel"],
    groupUl: ["groupUl"]
  };
  return composeClasses(slots, getAutocompleteUtilityClass, classes);
};
const AutocompleteRoot = styled("div", {
  name: "MuiAutocomplete",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      fullWidth: fullWidth2,
      hasClearIcon,
      hasPopupIcon,
      inputFocused,
      size
    } = ownerState;
    return [{
      ["& .".concat(autocompleteClasses.tag)]: styles2.tag
    }, {
      ["& .".concat(autocompleteClasses.tag)]: styles2["tagSize".concat(capitalize$1(size))]
    }, {
      ["& .".concat(autocompleteClasses.inputRoot)]: styles2.inputRoot
    }, {
      ["& .".concat(autocompleteClasses.input)]: styles2.input
    }, {
      ["& .".concat(autocompleteClasses.input)]: inputFocused && styles2.inputFocused
    }, styles2.root, fullWidth2 && styles2.fullWidth, hasPopupIcon && styles2.hasPopupIcon, hasClearIcon && styles2.hasClearIcon];
  }
})({
  ["&.".concat(autocompleteClasses.focused, " .").concat(autocompleteClasses.clearIndicator)]: {
    visibility: "visible"
  },
  /* Avoid double tap issue on iOS */
  "@media (pointer: fine)": {
    ["&:hover .".concat(autocompleteClasses.clearIndicator)]: {
      visibility: "visible"
    }
  },
  ["& .".concat(autocompleteClasses.tag)]: {
    margin: 3,
    maxWidth: "calc(100% - 6px)"
  },
  ["& .".concat(autocompleteClasses.inputRoot)]: {
    [".".concat(autocompleteClasses.hasPopupIcon, "&, .").concat(autocompleteClasses.hasClearIcon, "&")]: {
      paddingRight: 26 + 4
    },
    [".".concat(autocompleteClasses.hasPopupIcon, ".").concat(autocompleteClasses.hasClearIcon, "&")]: {
      paddingRight: 52 + 4
    },
    ["& .".concat(autocompleteClasses.input)]: {
      width: 0,
      minWidth: 30
    }
  },
  ["& .".concat(inputClasses.root)]: {
    paddingBottom: 1,
    "& .MuiInput-input": {
      padding: "4px 4px 4px 0px"
    }
  },
  ["& .".concat(inputClasses.root, ".").concat(inputBaseClasses.sizeSmall)]: {
    ["& .".concat(inputClasses.input)]: {
      padding: "2px 4px 3px 0"
    }
  },
  ["& .".concat(outlinedInputClasses.root)]: {
    padding: 9,
    [".".concat(autocompleteClasses.hasPopupIcon, "&, .").concat(autocompleteClasses.hasClearIcon, "&")]: {
      paddingRight: 26 + 4 + 9
    },
    [".".concat(autocompleteClasses.hasPopupIcon, ".").concat(autocompleteClasses.hasClearIcon, "&")]: {
      paddingRight: 52 + 4 + 9
    },
    ["& .".concat(autocompleteClasses.input)]: {
      padding: "7.5px 4px 7.5px 5px"
    },
    ["& .".concat(autocompleteClasses.endAdornment)]: {
      right: 9
    }
  },
  ["& .".concat(outlinedInputClasses.root, ".").concat(inputBaseClasses.sizeSmall)]: {
    // Don't specify paddingRight, as it overrides the default value set when there is only
    // one of the popup or clear icon as the specificity is equal so the latter one wins
    paddingTop: 6,
    paddingBottom: 6,
    paddingLeft: 6,
    ["& .".concat(autocompleteClasses.input)]: {
      padding: "2.5px 4px 2.5px 8px"
    }
  },
  ["& .".concat(filledInputClasses.root)]: {
    paddingTop: 19,
    paddingLeft: 8,
    [".".concat(autocompleteClasses.hasPopupIcon, "&, .").concat(autocompleteClasses.hasClearIcon, "&")]: {
      paddingRight: 26 + 4 + 9
    },
    [".".concat(autocompleteClasses.hasPopupIcon, ".").concat(autocompleteClasses.hasClearIcon, "&")]: {
      paddingRight: 52 + 4 + 9
    },
    ["& .".concat(filledInputClasses.input)]: {
      padding: "7px 4px"
    },
    ["& .".concat(autocompleteClasses.endAdornment)]: {
      right: 9
    }
  },
  ["& .".concat(filledInputClasses.root, ".").concat(inputBaseClasses.sizeSmall)]: {
    paddingBottom: 1,
    ["& .".concat(filledInputClasses.input)]: {
      padding: "2.5px 4px"
    }
  },
  ["& .".concat(inputBaseClasses.hiddenLabel)]: {
    paddingTop: 8
  },
  ["& .".concat(filledInputClasses.root, ".").concat(inputBaseClasses.hiddenLabel)]: {
    paddingTop: 0,
    paddingBottom: 0,
    ["& .".concat(autocompleteClasses.input)]: {
      paddingTop: 16,
      paddingBottom: 17
    }
  },
  ["& .".concat(filledInputClasses.root, ".").concat(inputBaseClasses.hiddenLabel, ".").concat(inputBaseClasses.sizeSmall)]: {
    ["& .".concat(autocompleteClasses.input)]: {
      paddingTop: 8,
      paddingBottom: 9
    }
  },
  ["& .".concat(autocompleteClasses.input)]: {
    flexGrow: 1,
    textOverflow: "ellipsis",
    opacity: 0
  },
  variants: [{
    props: {
      fullWidth: true
    },
    style: {
      width: "100%"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      ["& .".concat(autocompleteClasses.tag)]: {
        margin: 2,
        maxWidth: "calc(100% - 4px)"
      }
    }
  }, {
    props: {
      inputFocused: true
    },
    style: {
      ["& .".concat(autocompleteClasses.input)]: {
        opacity: 1
      }
    }
  }, {
    props: {
      multiple: true
    },
    style: {
      ["& .".concat(autocompleteClasses.inputRoot)]: {
        flexWrap: "wrap"
      }
    }
  }]
});
const AutocompleteEndAdornment = styled("div", {
  name: "MuiAutocomplete",
  slot: "EndAdornment",
  overridesResolver: (props, styles2) => styles2.endAdornment
})({
  // We use a position absolute to support wrapping tags.
  position: "absolute",
  right: 0,
  top: "50%",
  transform: "translate(0, -50%)"
});
const AutocompleteClearIndicator = styled(IconButton, {
  name: "MuiAutocomplete",
  slot: "ClearIndicator",
  overridesResolver: (props, styles2) => styles2.clearIndicator
})({
  marginRight: -2,
  padding: 4,
  visibility: "hidden"
});
const AutocompletePopupIndicator = styled(IconButton, {
  name: "MuiAutocomplete",
  slot: "PopupIndicator",
  overridesResolver: ({
    ownerState
  }, styles2) => _extends$h({}, styles2.popupIndicator, ownerState.popupOpen && styles2.popupIndicatorOpen)
})({
  padding: 2,
  marginRight: -2,
  variants: [{
    props: {
      popupOpen: true
    },
    style: {
      transform: "rotate(180deg)"
    }
  }]
});
const AutocompletePopper = styled(Popper, {
  name: "MuiAutocomplete",
  slot: "Popper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      ["& .".concat(autocompleteClasses.option)]: styles2.option
    }, styles2.popper, ownerState.disablePortal && styles2.popperDisablePortal];
  }
})(({
  theme
}) => ({
  zIndex: (theme.vars || theme).zIndex.modal,
  variants: [{
    props: {
      disablePortal: true
    },
    style: {
      position: "absolute"
    }
  }]
}));
const AutocompletePaper = styled(Paper, {
  name: "MuiAutocomplete",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})(({
  theme
}) => _extends$h({}, theme.typography.body1, {
  overflow: "auto"
}));
const AutocompleteLoading = styled("div", {
  name: "MuiAutocomplete",
  slot: "Loading",
  overridesResolver: (props, styles2) => styles2.loading
})(({
  theme
}) => ({
  color: (theme.vars || theme).palette.text.secondary,
  padding: "14px 16px"
}));
const AutocompleteNoOptions = styled("div", {
  name: "MuiAutocomplete",
  slot: "NoOptions",
  overridesResolver: (props, styles2) => styles2.noOptions
})(({
  theme
}) => ({
  color: (theme.vars || theme).palette.text.secondary,
  padding: "14px 16px"
}));
const AutocompleteListbox = styled("div", {
  name: "MuiAutocomplete",
  slot: "Listbox",
  overridesResolver: (props, styles2) => styles2.listbox
})(({
  theme
}) => ({
  listStyle: "none",
  margin: 0,
  padding: "8px 0",
  maxHeight: "40vh",
  overflow: "auto",
  position: "relative",
  ["& .".concat(autocompleteClasses.option)]: {
    minHeight: 48,
    display: "flex",
    overflow: "hidden",
    justifyContent: "flex-start",
    alignItems: "center",
    cursor: "pointer",
    paddingTop: 6,
    boxSizing: "border-box",
    outline: "0",
    WebkitTapHighlightColor: "transparent",
    paddingBottom: 6,
    paddingLeft: 16,
    paddingRight: 16,
    [theme.breakpoints.up("sm")]: {
      minHeight: "auto"
    },
    ["&.".concat(autocompleteClasses.focused)]: {
      backgroundColor: (theme.vars || theme).palette.action.hover,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    '&[aria-disabled="true"]': {
      opacity: (theme.vars || theme).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    ["&.".concat(autocompleteClasses.focusVisible)]: {
      backgroundColor: (theme.vars || theme).palette.action.focus
    },
    '&[aria-selected="true"]': {
      backgroundColor: theme.vars ? "rgba(".concat(theme.vars.palette.primary.mainChannel, " / ").concat(theme.vars.palette.action.selectedOpacity, ")") : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity),
      ["&.".concat(autocompleteClasses.focused)]: {
        backgroundColor: theme.vars ? "rgba(".concat(theme.vars.palette.primary.mainChannel, " / calc(").concat(theme.vars.palette.action.selectedOpacity, " + ").concat(theme.vars.palette.action.hoverOpacity, "))") : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: (theme.vars || theme).palette.action.selected
        }
      },
      ["&.".concat(autocompleteClasses.focusVisible)]: {
        backgroundColor: theme.vars ? "rgba(".concat(theme.vars.palette.primary.mainChannel, " / calc(").concat(theme.vars.palette.action.selectedOpacity, " + ").concat(theme.vars.palette.action.focusOpacity, "))") : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
      }
    }
  }
}));
const AutocompleteGroupLabel = styled(ListSubheader, {
  name: "MuiAutocomplete",
  slot: "GroupLabel",
  overridesResolver: (props, styles2) => styles2.groupLabel
})(({
  theme
}) => ({
  backgroundColor: (theme.vars || theme).palette.background.paper,
  top: -8
}));
const AutocompleteGroupUl = styled("ul", {
  name: "MuiAutocomplete",
  slot: "GroupUl",
  overridesResolver: (props, styles2) => styles2.groupUl
})({
  padding: 0,
  ["& .".concat(autocompleteClasses.option)]: {
    paddingLeft: 24
  }
});
const Autocomplete = /* @__PURE__ */ reactExports.forwardRef(function Autocomplete2(inProps, ref2) {
  var _slotProps$clearIndic, _slotProps$paper, _slotProps$popper, _slotProps$popupIndic;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAutocomplete"
  });
  const {
    autoComplete = false,
    autoHighlight = false,
    autoSelect = false,
    blurOnSelect = false,
    ChipProps,
    className,
    clearIcon = _ClearIcon || (_ClearIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(ClearIcon, {
      fontSize: "small"
    })),
    clearOnBlur = !props.freeSolo,
    clearOnEscape = false,
    clearText = "Clear",
    closeText = "Close",
    componentsProps = {},
    defaultValue = props.multiple ? [] : null,
    disableClearable = false,
    disableCloseOnSelect = false,
    disabled = false,
    disabledItemsFocusable = false,
    disableListWrap = false,
    disablePortal = false,
    filterSelectedOptions = false,
    forcePopupIcon = "auto",
    freeSolo = false,
    fullWidth: fullWidth2 = false,
    getLimitTagsText = (more) => "+".concat(more),
    getOptionLabel: getOptionLabelProp,
    groupBy: groupBy2,
    handleHomeEndKeys = !props.freeSolo,
    includeInputInList = false,
    limitTags = -1,
    ListboxComponent = "ul",
    ListboxProps,
    loading = false,
    loadingText = "Loading…",
    multiple = false,
    noOptionsText = "No options",
    openOnFocus = false,
    openText = "Open",
    PaperComponent = Paper,
    PopperComponent = Popper,
    popupIcon = _ArrowDropDownIcon || (_ArrowDropDownIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDropDownIcon, {})),
    readOnly = false,
    renderGroup: renderGroupProp,
    renderInput,
    renderOption: renderOptionProp,
    renderTags,
    selectOnFocus = !props.freeSolo,
    size = "medium",
    slotProps = {}
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$j);
  const {
    getRootProps,
    getInputProps,
    getInputLabelProps,
    getPopupIndicatorProps,
    getClearProps,
    getTagProps,
    getListboxProps,
    getOptionProps,
    value,
    dirty,
    expanded,
    id: id2,
    popupOpen,
    focused,
    focusedTag,
    anchorEl,
    setAnchorEl,
    inputValue: inputValue2,
    groupedOptions
  } = useAutocomplete(_extends$h({}, props, {
    componentName: "Autocomplete"
  }));
  const hasClearIcon = !disableClearable && !disabled && dirty && !readOnly;
  const hasPopupIcon = (!freeSolo || forcePopupIcon === true) && forcePopupIcon !== false;
  const {
    onMouseDown: handleInputMouseDown
  } = getInputProps();
  const {
    ref: externalListboxRef
  } = ListboxProps != null ? ListboxProps : {};
  const _getListboxProps = getListboxProps(), {
    ref: listboxRef
  } = _getListboxProps, otherListboxProps = _objectWithoutPropertiesLoose(_getListboxProps, _excluded2$2);
  const combinedListboxRef = useForkRef(listboxRef, externalListboxRef);
  const defaultGetOptionLabel = (option) => {
    var _option$label;
    return (_option$label = option.label) != null ? _option$label : option;
  };
  const getOptionLabel = getOptionLabelProp || defaultGetOptionLabel;
  const ownerState = _extends$h({}, props, {
    disablePortal,
    expanded,
    focused,
    fullWidth: fullWidth2,
    getOptionLabel,
    hasClearIcon,
    hasPopupIcon,
    inputFocused: focusedTag === -1,
    popupOpen,
    size
  });
  const classes = useUtilityClasses$8(ownerState);
  let startAdornment;
  if (multiple && value.length > 0) {
    const getCustomizedTagProps = (params) => _extends$h({
      className: classes.tag,
      disabled
    }, getTagProps(params));
    if (renderTags) {
      startAdornment = renderTags(value, getCustomizedTagProps, ownerState);
    } else {
      startAdornment = value.map((option, index2) => {
        const _getCustomizedTagProp = getCustomizedTagProps({
          index: index2
        }), {
          key
        } = _getCustomizedTagProp, customTagProps = _objectWithoutPropertiesLoose(_getCustomizedTagProp, _excluded3$1);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, _extends$h({
          label: getOptionLabel(option),
          size
        }, customTagProps, ChipProps), key);
      });
    }
  }
  if (limitTags > -1 && Array.isArray(startAdornment)) {
    const more = startAdornment.length - limitTags;
    if (!focused && more > 0) {
      startAdornment = startAdornment.splice(0, limitTags);
      startAdornment.push(/* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes.tag,
        children: getLimitTagsText(more)
      }, startAdornment.length));
    }
  }
  const defaultRenderGroup = (params) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteGroupLabel, {
      className: classes.groupLabel,
      ownerState,
      component: "div",
      children: params.group
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteGroupUl, {
      className: classes.groupUl,
      ownerState,
      children: params.children
    })]
  }, params.key);
  const renderGroup = renderGroupProp || defaultRenderGroup;
  const defaultRenderOption = (props2, option) => {
    const {
      key
    } = props2, otherProps = _objectWithoutPropertiesLoose(props2, _excluded4);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("li", _extends$h({}, otherProps, {
      children: getOptionLabel(option)
    }), key);
  };
  const renderOption = renderOptionProp || defaultRenderOption;
  const renderListOption = (option, index2) => {
    const optionProps = getOptionProps({
      option,
      index: index2
    });
    return renderOption(_extends$h({}, optionProps, {
      className: classes.option
    }), option, {
      selected: optionProps["aria-selected"],
      index: index2,
      inputValue: inputValue2
    }, ownerState);
  };
  const clearIndicatorSlotProps = (_slotProps$clearIndic = slotProps.clearIndicator) != null ? _slotProps$clearIndic : componentsProps.clearIndicator;
  const paperSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : componentsProps.paper;
  const popperSlotProps = (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper;
  const popupIndicatorSlotProps = (_slotProps$popupIndic = slotProps.popupIndicator) != null ? _slotProps$popupIndic : componentsProps.popupIndicator;
  const renderAutocompletePopperChildren = (children) => /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompletePopper, _extends$h({
    as: PopperComponent,
    disablePortal,
    style: {
      width: anchorEl ? anchorEl.clientWidth : null
    },
    ownerState,
    role: "presentation",
    anchorEl,
    open: popupOpen
  }, popperSlotProps, {
    className: clsx(classes.popper, popperSlotProps == null ? void 0 : popperSlotProps.className),
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompletePaper, _extends$h({
      ownerState,
      as: PaperComponent
    }, paperSlotProps, {
      className: clsx(classes.paper, paperSlotProps == null ? void 0 : paperSlotProps.className),
      children
    }))
  }));
  let autocompletePopper = null;
  if (groupedOptions.length > 0) {
    autocompletePopper = renderAutocompletePopperChildren(/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteListbox, _extends$h({
      as: ListboxComponent,
      className: classes.listbox,
      ownerState
    }, otherListboxProps, ListboxProps, {
      ref: combinedListboxRef,
      children: groupedOptions.map((option, index2) => {
        if (groupBy2) {
          return renderGroup({
            key: option.key,
            group: option.group,
            children: option.options.map((option2, index22) => renderListOption(option2, option.index + index22))
          });
        }
        return renderListOption(option, index2);
      })
    })));
  } else if (loading && groupedOptions.length === 0) {
    autocompletePopper = renderAutocompletePopperChildren(/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteLoading, {
      className: classes.loading,
      ownerState,
      children: loadingText
    }));
  } else if (groupedOptions.length === 0 && !freeSolo && !loading) {
    autocompletePopper = renderAutocompletePopperChildren(/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteNoOptions, {
      className: classes.noOptions,
      ownerState,
      role: "presentation",
      onMouseDown: (event) => {
        event.preventDefault();
      },
      children: noOptionsText
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteRoot, _extends$h({
      ref: ref2,
      className: clsx(classes.root, className),
      ownerState
    }, getRootProps(other), {
      children: renderInput({
        id: id2,
        disabled,
        fullWidth: true,
        size: size === "small" ? "small" : void 0,
        InputLabelProps: getInputLabelProps(),
        InputProps: _extends$h({
          ref: setAnchorEl,
          className: classes.inputRoot,
          startAdornment,
          onClick: (event) => {
            if (event.target === event.currentTarget) {
              handleInputMouseDown(event);
            }
          }
        }, (hasClearIcon || hasPopupIcon) && {
          endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsxs(AutocompleteEndAdornment, {
            className: classes.endAdornment,
            ownerState,
            children: [hasClearIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteClearIndicator, _extends$h({}, getClearProps(), {
              "aria-label": clearText,
              title: clearText,
              ownerState
            }, clearIndicatorSlotProps, {
              className: clsx(classes.clearIndicator, clearIndicatorSlotProps == null ? void 0 : clearIndicatorSlotProps.className),
              children: clearIcon
            })) : null, hasPopupIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompletePopupIndicator, _extends$h({}, getPopupIndicatorProps(), {
              disabled,
              "aria-label": popupOpen ? closeText : openText,
              title: popupOpen ? closeText : openText,
              ownerState
            }, popupIndicatorSlotProps, {
              className: clsx(classes.popupIndicator, popupIndicatorSlotProps == null ? void 0 : popupIndicatorSlotProps.className),
              children: popupIcon
            })) : null]
          })
        }),
        inputProps: _extends$h({
          className: classes.input,
          disabled,
          readOnly
        }, getInputProps())
      })
    })), anchorEl ? autocompletePopper : null]
  });
});
const _excluded$i = ["children", "className", "color", "component", "disabled", "disableElevation", "disableFocusRipple", "disableRipple", "fullWidth", "orientation", "size", "variant"];
const overridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [{
    ["& .".concat(buttonGroupClasses.grouped)]: styles2.grouped
  }, {
    ["& .".concat(buttonGroupClasses.grouped)]: styles2["grouped".concat(capitalize$1(ownerState.orientation))]
  }, {
    ["& .".concat(buttonGroupClasses.grouped)]: styles2["grouped".concat(capitalize$1(ownerState.variant))]
  }, {
    ["& .".concat(buttonGroupClasses.grouped)]: styles2["grouped".concat(capitalize$1(ownerState.variant)).concat(capitalize$1(ownerState.orientation))]
  }, {
    ["& .".concat(buttonGroupClasses.grouped)]: styles2["grouped".concat(capitalize$1(ownerState.variant)).concat(capitalize$1(ownerState.color))]
  }, {
    ["& .".concat(buttonGroupClasses.firstButton)]: styles2.firstButton
  }, {
    ["& .".concat(buttonGroupClasses.lastButton)]: styles2.lastButton
  }, {
    ["& .".concat(buttonGroupClasses.middleButton)]: styles2.middleButton
  }, styles2.root, styles2[ownerState.variant], ownerState.disableElevation === true && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth, ownerState.orientation === "vertical" && styles2.vertical];
};
const useUtilityClasses$7 = (ownerState) => {
  const {
    classes,
    color,
    disabled,
    disableElevation,
    fullWidth: fullWidth2,
    orientation,
    variant
  } = ownerState;
  const slots = {
    root: ["root", variant, orientation === "vertical" && "vertical", fullWidth2 && "fullWidth", disableElevation && "disableElevation"],
    grouped: ["grouped", "grouped".concat(capitalize$1(orientation)), "grouped".concat(capitalize$1(variant)), "grouped".concat(capitalize$1(variant)).concat(capitalize$1(orientation)), "grouped".concat(capitalize$1(variant)).concat(capitalize$1(color)), disabled && "disabled"],
    firstButton: ["firstButton"],
    lastButton: ["lastButton"],
    middleButton: ["middleButton"]
  };
  return composeClasses(slots, getButtonGroupUtilityClass, classes);
};
const ButtonGroupRoot = styled("div", {
  name: "MuiButtonGroup",
  slot: "Root",
  overridesResolver
})(({
  theme,
  ownerState
}) => _extends$h({
  display: "inline-flex",
  borderRadius: (theme.vars || theme).shape.borderRadius
}, ownerState.variant === "contained" && {
  boxShadow: (theme.vars || theme).shadows[2]
}, ownerState.disableElevation && {
  boxShadow: "none"
}, ownerState.fullWidth && {
  width: "100%"
}, ownerState.orientation === "vertical" && {
  flexDirection: "column"
}, {
  ["& .".concat(buttonGroupClasses.grouped)]: _extends$h({
    minWidth: 40,
    "&:hover": _extends$h({}, ownerState.variant === "contained" && {
      boxShadow: "none"
    })
  }, ownerState.variant === "contained" && {
    boxShadow: "none"
  }),
  ["& .".concat(buttonGroupClasses.firstButton, ",& .").concat(buttonGroupClasses.middleButton)]: _extends$h({}, ownerState.orientation === "horizontal" && {
    borderTopRightRadius: 0,
    borderBottomRightRadius: 0
  }, ownerState.orientation === "vertical" && {
    borderBottomRightRadius: 0,
    borderBottomLeftRadius: 0
  }, ownerState.variant === "text" && ownerState.orientation === "horizontal" && {
    borderRight: theme.vars ? "1px solid rgba(".concat(theme.vars.palette.common.onBackgroundChannel, " / 0.23)") : "1px solid ".concat(theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"),
    ["&.".concat(buttonGroupClasses.disabled)]: {
      borderRight: "1px solid ".concat((theme.vars || theme).palette.action.disabled)
    }
  }, ownerState.variant === "text" && ownerState.orientation === "vertical" && {
    borderBottom: theme.vars ? "1px solid rgba(".concat(theme.vars.palette.common.onBackgroundChannel, " / 0.23)") : "1px solid ".concat(theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"),
    ["&.".concat(buttonGroupClasses.disabled)]: {
      borderBottom: "1px solid ".concat((theme.vars || theme).palette.action.disabled)
    }
  }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
    borderColor: theme.vars ? "rgba(".concat(theme.vars.palette[ownerState.color].mainChannel, " / 0.5)") : alpha_1(theme.palette[ownerState.color].main, 0.5)
  }, ownerState.variant === "outlined" && ownerState.orientation === "horizontal" && {
    borderRightColor: "transparent"
  }, ownerState.variant === "outlined" && ownerState.orientation === "vertical" && {
    borderBottomColor: "transparent"
  }, ownerState.variant === "contained" && ownerState.orientation === "horizontal" && {
    borderRight: "1px solid ".concat((theme.vars || theme).palette.grey[400]),
    ["&.".concat(buttonGroupClasses.disabled)]: {
      borderRight: "1px solid ".concat((theme.vars || theme).palette.action.disabled)
    }
  }, ownerState.variant === "contained" && ownerState.orientation === "vertical" && {
    borderBottom: "1px solid ".concat((theme.vars || theme).palette.grey[400]),
    ["&.".concat(buttonGroupClasses.disabled)]: {
      borderBottom: "1px solid ".concat((theme.vars || theme).palette.action.disabled)
    }
  }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
    borderColor: (theme.vars || theme).palette[ownerState.color].dark
  }, {
    "&:hover": _extends$h({}, ownerState.variant === "outlined" && ownerState.orientation === "horizontal" && {
      borderRightColor: "currentColor"
    }, ownerState.variant === "outlined" && ownerState.orientation === "vertical" && {
      borderBottomColor: "currentColor"
    })
  }),
  ["& .".concat(buttonGroupClasses.lastButton, ",& .").concat(buttonGroupClasses.middleButton)]: _extends$h({}, ownerState.orientation === "horizontal" && {
    borderTopLeftRadius: 0,
    borderBottomLeftRadius: 0
  }, ownerState.orientation === "vertical" && {
    borderTopRightRadius: 0,
    borderTopLeftRadius: 0
  }, ownerState.variant === "outlined" && ownerState.orientation === "horizontal" && {
    marginLeft: -1
  }, ownerState.variant === "outlined" && ownerState.orientation === "vertical" && {
    marginTop: -1
  })
}));
const ButtonGroup = /* @__PURE__ */ reactExports.forwardRef(function ButtonGroup2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiButtonGroup"
  });
  const {
    children,
    className,
    color = "primary",
    component = "div",
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    disableRipple = false,
    fullWidth: fullWidth2 = false,
    orientation = "horizontal",
    size = "medium",
    variant = "outlined"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$i);
  const ownerState = _extends$h({}, props, {
    color,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    disableRipple,
    fullWidth: fullWidth2,
    orientation,
    size,
    variant
  });
  const classes = useUtilityClasses$7(ownerState);
  const context2 = reactExports.useMemo(() => ({
    className: classes.grouped,
    color,
    disabled,
    disableElevation,
    disableFocusRipple,
    disableRipple,
    fullWidth: fullWidth2,
    size,
    variant
  }), [color, disabled, disableElevation, disableFocusRipple, disableRipple, fullWidth2, size, variant, classes.grouped]);
  const validChildren = getValidReactChildren(children);
  const childrenCount = validChildren.length;
  const getButtonPositionClassName = (index2) => {
    const isFirstButton = index2 === 0;
    const isLastButton = index2 === childrenCount - 1;
    if (isFirstButton && isLastButton) {
      return "";
    }
    if (isFirstButton) {
      return classes.firstButton;
    }
    if (isLastButton) {
      return classes.lastButton;
    }
    return classes.middleButton;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroupRoot, _extends$h({
    as: component,
    role: "group",
    className: clsx(classes.root, className),
    ref: ref2,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroupContext.Provider, {
      value: context2,
      children: validChildren.map((child, index2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroupButtonContext.Provider, {
          value: getButtonPositionClassName(index2),
          children: child
        }, index2);
      })
    })
  }));
});
function getDialogContentTextUtilityClass(slot) {
  return generateUtilityClass("MuiDialogContentText", slot);
}
generateUtilityClasses("MuiDialogContentText", ["root"]);
const _excluded$h = ["children", "className"];
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  const composedClasses = composeClasses(slots, getDialogContentTextUtilityClass, classes);
  return _extends$h({}, classes, composedClasses);
};
const DialogContentTextRoot = styled(Typography, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiDialogContentText",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const DialogContentText = /* @__PURE__ */ reactExports.forwardRef(function DialogContentText2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogContentText"
  });
  const {
    className
  } = props, ownerState = _objectWithoutPropertiesLoose(props, _excluded$h);
  const classes = useUtilityClasses$6(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentTextRoot, _extends$h({
    component: "p",
    variant: "body1",
    color: "text.secondary",
    ref: ref2,
    ownerState,
    className: clsx(classes.root, className)
  }, props, {
    classes
  }));
});
const _excluded$g = ["children", "className", "color", "component", "disabled", "disableFocusRipple", "focusVisibleClassName", "size", "variant"];
const useUtilityClasses$5 = (ownerState) => {
  const {
    color,
    variant,
    classes,
    size
  } = ownerState;
  const slots = {
    root: ["root", variant, "size".concat(capitalize$1(size)), color === "inherit" ? "colorInherit" : color]
  };
  const composedClasses = composeClasses(slots, getFabUtilityClass, classes);
  return _extends$h({}, classes, composedClasses);
};
const FabRoot = styled(ButtonBase, {
  name: "MuiFab",
  slot: "Root",
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2["size".concat(capitalize$1(ownerState.size))], ownerState.color === "inherit" && styles2.colorInherit, styles2[capitalize$1(ownerState.size)], styles2[ownerState.color]];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$palette$getCon, _theme$palette;
  return _extends$h({}, theme.typography.button, {
    minHeight: 36,
    transition: theme.transitions.create(["background-color", "box-shadow", "border-color"], {
      duration: theme.transitions.duration.short
    }),
    borderRadius: "50%",
    padding: 0,
    minWidth: 0,
    width: 56,
    height: 56,
    zIndex: (theme.vars || theme).zIndex.fab,
    boxShadow: (theme.vars || theme).shadows[6],
    "&:active": {
      boxShadow: (theme.vars || theme).shadows[12]
    },
    color: theme.vars ? theme.vars.palette.text.primary : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
    backgroundColor: (theme.vars || theme).palette.grey[300],
    "&:hover": {
      backgroundColor: (theme.vars || theme).palette.grey.A100,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: (theme.vars || theme).palette.grey[300]
      },
      textDecoration: "none"
    },
    ["&.".concat(fabClasses.focusVisible)]: {
      boxShadow: (theme.vars || theme).shadows[6]
    }
  }, ownerState.size === "small" && {
    width: 40,
    height: 40
  }, ownerState.size === "medium" && {
    width: 48,
    height: 48
  }, ownerState.variant === "extended" && {
    borderRadius: 48 / 2,
    padding: "0 16px",
    width: "auto",
    minHeight: "auto",
    minWidth: 48,
    height: 48
  }, ownerState.variant === "extended" && ownerState.size === "small" && {
    width: "auto",
    padding: "0 8px",
    borderRadius: 34 / 2,
    minWidth: 34,
    height: 34
  }, ownerState.variant === "extended" && ownerState.size === "medium" && {
    width: "auto",
    padding: "0 16px",
    borderRadius: 40 / 2,
    minWidth: 40,
    height: 40
  }, ownerState.color === "inherit" && {
    color: "inherit"
  });
}, ({
  theme,
  ownerState
}) => _extends$h({}, ownerState.color !== "inherit" && ownerState.color !== "default" && (theme.vars || theme).palette[ownerState.color] != null && {
  color: (theme.vars || theme).palette[ownerState.color].contrastText,
  backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
  "&:hover": {
    backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].main
    }
  }
}), ({
  theme
}) => ({
  ["&.".concat(fabClasses.disabled)]: {
    color: (theme.vars || theme).palette.action.disabled,
    boxShadow: (theme.vars || theme).shadows[0],
    backgroundColor: (theme.vars || theme).palette.action.disabledBackground
  }
}));
const Fab = /* @__PURE__ */ reactExports.forwardRef(function Fab2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFab"
  });
  const {
    children,
    className,
    color = "default",
    component = "button",
    disabled = false,
    disableFocusRipple = false,
    focusVisibleClassName,
    size = "large",
    variant = "circular"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$g);
  const ownerState = _extends$h({}, props, {
    color,
    component,
    disabled,
    disableFocusRipple,
    size,
    variant
  });
  const classes = useUtilityClasses$5(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FabRoot, _extends$h({
    className: clsx(classes.root, className),
    component,
    disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ownerState,
    ref: ref2
  }, other, {
    classes,
    children
  }));
});
function getIconUtilityClass(slot) {
  return generateUtilityClass("MuiIcon", slot);
}
generateUtilityClasses("MuiIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _excluded$f = ["baseClassName", "className", "color", "component", "fontSize"];
const useUtilityClasses$4 = (ownerState) => {
  const {
    color,
    fontSize,
    classes
  } = ownerState;
  const slots = {
    root: ["root", color !== "inherit" && "color".concat(capitalize$1(color)), "fontSize".concat(capitalize$1(fontSize))]
  };
  return composeClasses(slots, getIconUtilityClass, classes);
};
const IconRoot = styled("span", {
  name: "MuiIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2["color".concat(capitalize$1(ownerState.color))], styles2["fontSize".concat(capitalize$1(ownerState.fontSize))]];
  }
})(({
  theme,
  ownerState
}) => ({
  userSelect: "none",
  width: "1em",
  height: "1em",
  // Chrome fix for https://bugs.chromium.org/p/chromium/issues/detail?id=820541
  // To remove at some point.
  overflow: "hidden",
  display: "inline-block",
  // allow overflow hidden to take action
  textAlign: "center",
  // support non-square icon
  flexShrink: 0,
  fontSize: {
    inherit: "inherit",
    small: theme.typography.pxToRem(20),
    medium: theme.typography.pxToRem(24),
    large: theme.typography.pxToRem(36)
  }[ownerState.fontSize],
  // TODO v5 deprecate, v6 remove for sx
  color: {
    primary: (theme.vars || theme).palette.primary.main,
    secondary: (theme.vars || theme).palette.secondary.main,
    info: (theme.vars || theme).palette.info.main,
    success: (theme.vars || theme).palette.success.main,
    warning: (theme.vars || theme).palette.warning.main,
    action: (theme.vars || theme).palette.action.active,
    error: (theme.vars || theme).palette.error.main,
    disabled: (theme.vars || theme).palette.action.disabled,
    inherit: void 0
  }[ownerState.color]
}));
const Icon = /* @__PURE__ */ reactExports.forwardRef(function Icon2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiIcon"
  });
  const {
    baseClassName = "material-icons",
    className,
    color = "inherit",
    component: Component = "span",
    fontSize = "medium"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$f);
  const ownerState = _extends$h({}, props, {
    baseClassName,
    color,
    component: Component,
    fontSize
  });
  const classes = useUtilityClasses$4(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IconRoot, _extends$h({
    as: Component,
    className: clsx(
      baseClassName,
      // Prevent the translation of the text content.
      // The font relies on the exact text content to render the icon.
      "notranslate",
      classes.root,
      className
    ),
    ownerState,
    "aria-hidden": true,
    ref: ref2
  }, other));
});
Icon.muiName = "Icon";
const _excluded$e = ["children", "className", "disableTypography", "inset", "primary", "primaryTypographyProps", "secondary", "secondaryTypographyProps"];
const useUtilityClasses$3 = (ownerState) => {
  const {
    classes,
    inset,
    primary,
    secondary,
    dense
  } = ownerState;
  const slots = {
    root: ["root", inset && "inset", dense && "dense", primary && secondary && "multiline"],
    primary: ["primary"],
    secondary: ["secondary"]
  };
  return composeClasses(slots, getListItemTextUtilityClass, classes);
};
const ListItemTextRoot = styled("div", {
  name: "MuiListItemText",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      ["& .".concat(listItemTextClasses.primary)]: styles2.primary
    }, {
      ["& .".concat(listItemTextClasses.secondary)]: styles2.secondary
    }, styles2.root, ownerState.inset && styles2.inset, ownerState.primary && ownerState.secondary && styles2.multiline, ownerState.dense && styles2.dense];
  }
})(({
  ownerState
}) => _extends$h({
  flex: "1 1 auto",
  minWidth: 0,
  marginTop: 4,
  marginBottom: 4
}, ownerState.primary && ownerState.secondary && {
  marginTop: 6,
  marginBottom: 6
}, ownerState.inset && {
  paddingLeft: 56
}));
const ListItemText = /* @__PURE__ */ reactExports.forwardRef(function ListItemText2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemText"
  });
  const {
    children,
    className,
    disableTypography = false,
    inset = false,
    primary: primaryProp,
    primaryTypographyProps,
    secondary: secondaryProp,
    secondaryTypographyProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$e);
  const {
    dense
  } = reactExports.useContext(ListContext);
  let primary = primaryProp != null ? primaryProp : children;
  let secondary = secondaryProp;
  const ownerState = _extends$h({}, props, {
    disableTypography,
    inset,
    primary: !!primary,
    secondary: !!secondary,
    dense
  });
  const classes = useUtilityClasses$3(ownerState);
  if (primary != null && primary.type !== Typography && !disableTypography) {
    primary = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, _extends$h({
      variant: dense ? "body2" : "body1",
      className: classes.primary,
      component: primaryTypographyProps != null && primaryTypographyProps.variant ? void 0 : "span",
      display: "block"
    }, primaryTypographyProps, {
      children: primary
    }));
  }
  if (secondary != null && secondary.type !== Typography && !disableTypography) {
    secondary = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, _extends$h({
      variant: "body2",
      className: classes.secondary,
      color: "text.secondary",
      display: "block"
    }, secondaryTypographyProps, {
      children: secondary
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItemTextRoot, _extends$h({
    className: clsx(classes.root, className),
    ownerState,
    ref: ref2
  }, other, {
    children: [primary, secondary]
  }));
});
function areArraysEqual(array1, array2, itemComparer = (a2, b) => a2 === b) {
  return array1.length === array2.length && array1.every((value, index2) => itemComparer(value, array2[index2]));
}
const INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;
function asc(a2, b) {
  return a2 - b;
}
function findClosest(values2, currentValue) {
  var _values$reduce;
  const {
    index: closestIndex
  } = (_values$reduce = values2.reduce((acc, value, index2) => {
    const distance = Math.abs(currentValue - value);
    if (acc === null || distance < acc.distance || distance === acc.distance) {
      return {
        distance,
        index: index2
      };
    }
    return acc;
  }, null)) != null ? _values$reduce : {};
  return closestIndex;
}
function trackFinger(event, touchId) {
  if (touchId.current !== void 0 && event.changedTouches) {
    const touchEvent = event;
    for (let i2 = 0; i2 < touchEvent.changedTouches.length; i2 += 1) {
      const touch = touchEvent.changedTouches[i2];
      if (touch.identifier === touchId.current) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }
    return false;
  }
  return {
    x: event.clientX,
    y: event.clientY
  };
}
function valueToPercent(value, min3, max3) {
  return (value - min3) * 100 / (max3 - min3);
}
function percentToValue(percent, min3, max3) {
  return (max3 - min3) * percent + min3;
}
function getDecimalPrecision(num) {
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split("e-");
    const matissaDecimalPart = parts[0].split(".")[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToStep(value, step, min3) {
  const nearest = Math.round((value - min3) / step) * step + min3;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}
function setValueIndex({
  values: values2,
  newValue,
  index: index2
}) {
  const output = values2.slice();
  output[index2] = newValue;
  return output.sort(asc);
}
function focusThumb({
  sliderRef,
  activeIndex,
  setActive
}) {
  var _sliderRef$current, _doc$activeElement;
  const doc = ownerDocument(sliderRef.current);
  if (!((_sliderRef$current = sliderRef.current) != null && _sliderRef$current.contains(doc.activeElement)) || Number(doc == null || (_doc$activeElement = doc.activeElement) == null ? void 0 : _doc$activeElement.getAttribute("data-index")) !== activeIndex) {
    var _sliderRef$current2;
    (_sliderRef$current2 = sliderRef.current) == null || _sliderRef$current2.querySelector('[type="range"][data-index="'.concat(activeIndex, '"]')).focus();
  }
  if (setActive) {
    setActive(activeIndex);
  }
}
function areValuesEqual(newValue, oldValue) {
  if (typeof newValue === "number" && typeof oldValue === "number") {
    return newValue === oldValue;
  }
  if (typeof newValue === "object" && typeof oldValue === "object") {
    return areArraysEqual(newValue, oldValue);
  }
  return false;
}
const axisProps = {
  horizontal: {
    offset: (percent) => ({
      left: "".concat(percent, "%")
    }),
    leap: (percent) => ({
      width: "".concat(percent, "%")
    })
  },
  "horizontal-reverse": {
    offset: (percent) => ({
      right: "".concat(percent, "%")
    }),
    leap: (percent) => ({
      width: "".concat(percent, "%")
    })
  },
  vertical: {
    offset: (percent) => ({
      bottom: "".concat(percent, "%")
    }),
    leap: (percent) => ({
      height: "".concat(percent, "%")
    })
  }
};
const Identity$1 = (x) => x;
let cachedSupportsTouchActionNone;
function doesSupportTouchActionNone() {
  if (cachedSupportsTouchActionNone === void 0) {
    if (typeof CSS !== "undefined" && typeof CSS.supports === "function") {
      cachedSupportsTouchActionNone = CSS.supports("touch-action", "none");
    } else {
      cachedSupportsTouchActionNone = true;
    }
  }
  return cachedSupportsTouchActionNone;
}
function useSlider(parameters) {
  const {
    "aria-labelledby": ariaLabelledby,
    defaultValue,
    disabled = false,
    disableSwap = false,
    isRtl = false,
    marks: marksProp = false,
    max: max3 = 100,
    min: min3 = 0,
    name: name2,
    onChange,
    onChangeCommitted,
    orientation = "horizontal",
    rootRef: ref2,
    scale = Identity$1,
    step = 1,
    shiftStep = 10,
    tabIndex,
    value: valueProp
  } = parameters;
  const touchId = reactExports.useRef();
  const [active3, setActive] = reactExports.useState(-1);
  const [open, setOpen] = reactExports.useState(-1);
  const [dragging, setDragging] = reactExports.useState(false);
  const moveCount = reactExports.useRef(0);
  const [valueDerived, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue != null ? defaultValue : min3,
    name: "Slider"
  });
  const handleChange = onChange && ((event, value, thumbIndex) => {
    const nativeEvent = event.nativeEvent || event;
    const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
    Object.defineProperty(clonedEvent, "target", {
      writable: true,
      value: {
        value,
        name: name2
      }
    });
    onChange(clonedEvent, value, thumbIndex);
  });
  const range2 = Array.isArray(valueDerived);
  let values2 = range2 ? valueDerived.slice().sort(asc) : [valueDerived];
  values2 = values2.map((value) => value == null ? min3 : clamp(value, min3, max3));
  const marks = marksProp === true && step !== null ? [...Array(Math.floor((max3 - min3) / step) + 1)].map((_, index2) => ({
    value: min3 + step * index2
  })) : marksProp || [];
  const marksValues = marks.map((mark) => mark.value);
  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusedThumbIndex, setFocusedThumbIndex] = reactExports.useState(-1);
  const sliderRef = reactExports.useRef();
  const handleFocusRef = useForkRef(focusVisibleRef, sliderRef);
  const handleRef = useForkRef(ref2, handleFocusRef);
  const createHandleHiddenInputFocus = (otherHandlers) => (event) => {
    var _otherHandlers$onFocu;
    const index2 = Number(event.currentTarget.getAttribute("data-index"));
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusedThumbIndex(index2);
    }
    setOpen(index2);
    otherHandlers == null || (_otherHandlers$onFocu = otherHandlers.onFocus) == null || _otherHandlers$onFocu.call(otherHandlers, event);
  };
  const createHandleHiddenInputBlur = (otherHandlers) => (event) => {
    var _otherHandlers$onBlur;
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusedThumbIndex(-1);
    }
    setOpen(-1);
    otherHandlers == null || (_otherHandlers$onBlur = otherHandlers.onBlur) == null || _otherHandlers$onBlur.call(otherHandlers, event);
  };
  const changeValue = (event, valueInput) => {
    const index2 = Number(event.currentTarget.getAttribute("data-index"));
    const value = values2[index2];
    const marksIndex = marksValues.indexOf(value);
    let newValue = valueInput;
    if (marks && step == null) {
      const maxMarksValue = marksValues[marksValues.length - 1];
      if (newValue > maxMarksValue) {
        newValue = maxMarksValue;
      } else if (newValue < marksValues[0]) {
        newValue = marksValues[0];
      } else {
        newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];
      }
    }
    newValue = clamp(newValue, min3, max3);
    if (range2) {
      if (disableSwap) {
        newValue = clamp(newValue, values2[index2 - 1] || -Infinity, values2[index2 + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values: values2,
        newValue,
        index: index2
      });
      let activeIndex = index2;
      if (!disableSwap) {
        activeIndex = newValue.indexOf(previousValue);
      }
      focusThumb({
        sliderRef,
        activeIndex
      });
    }
    setValueState(newValue);
    setFocusedThumbIndex(index2);
    if (handleChange && !areValuesEqual(newValue, valueDerived)) {
      handleChange(event, newValue, index2);
    }
    if (onChangeCommitted) {
      onChangeCommitted(event, newValue);
    }
  };
  const createHandleHiddenInputKeyDown = (otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    if (step !== null) {
      const index2 = Number(event.currentTarget.getAttribute("data-index"));
      const value = values2[index2];
      let newValue = null;
      if ((event.key === "ArrowLeft" || event.key === "ArrowDown") && event.shiftKey || event.key === "PageDown") {
        newValue = Math.max(value - shiftStep, min3);
      } else if ((event.key === "ArrowRight" || event.key === "ArrowUp") && event.shiftKey || event.key === "PageUp") {
        newValue = Math.min(value + shiftStep, max3);
      }
      if (newValue !== null) {
        changeValue(event, newValue);
        event.preventDefault();
      }
    }
    otherHandlers == null || (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
  };
  useEnhancedEffect(() => {
    if (disabled && sliderRef.current.contains(document.activeElement)) {
      var _document$activeEleme;
      (_document$activeEleme = document.activeElement) == null || _document$activeEleme.blur();
    }
  }, [disabled]);
  if (disabled && active3 !== -1) {
    setActive(-1);
  }
  if (disabled && focusedThumbIndex !== -1) {
    setFocusedThumbIndex(-1);
  }
  const createHandleHiddenInputChange = (otherHandlers) => (event) => {
    var _otherHandlers$onChan;
    (_otherHandlers$onChan = otherHandlers.onChange) == null || _otherHandlers$onChan.call(otherHandlers, event);
    changeValue(event, event.target.valueAsNumber);
  };
  const previousIndex = reactExports.useRef();
  let axis = orientation;
  if (isRtl && orientation === "horizontal") {
    axis += "-reverse";
  }
  const getFingerNewValue = ({
    finger,
    move = false
  }) => {
    const {
      current: slider
    } = sliderRef;
    const {
      width,
      height,
      bottom,
      left
    } = slider.getBoundingClientRect();
    let percent;
    if (axis.indexOf("vertical") === 0) {
      percent = (bottom - finger.y) / height;
    } else {
      percent = (finger.x - left) / width;
    }
    if (axis.indexOf("-reverse") !== -1) {
      percent = 1 - percent;
    }
    let newValue;
    newValue = percentToValue(percent, min3, max3);
    if (step) {
      newValue = roundValueToStep(newValue, step, min3);
    } else {
      const closestIndex = findClosest(marksValues, newValue);
      newValue = marksValues[closestIndex];
    }
    newValue = clamp(newValue, min3, max3);
    let activeIndex = 0;
    if (range2) {
      if (!move) {
        activeIndex = findClosest(values2, newValue);
      } else {
        activeIndex = previousIndex.current;
      }
      if (disableSwap) {
        newValue = clamp(newValue, values2[activeIndex - 1] || -Infinity, values2[activeIndex + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values: values2,
        newValue,
        index: activeIndex
      });
      if (!(disableSwap && move)) {
        activeIndex = newValue.indexOf(previousValue);
        previousIndex.current = activeIndex;
      }
    }
    return {
      newValue,
      activeIndex
    };
  };
  const handleTouchMove = useEventCallback((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    if (!finger) {
      return;
    }
    moveCount.current += 1;
    if (nativeEvent.type === "mousemove" && nativeEvent.buttons === 0) {
      handleTouchEnd(nativeEvent);
      return;
    }
    const {
      newValue,
      activeIndex
    } = getFingerNewValue({
      finger,
      move: true
    });
    focusThumb({
      sliderRef,
      activeIndex,
      setActive
    });
    setValueState(newValue);
    if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
      setDragging(true);
    }
    if (handleChange && !areValuesEqual(newValue, valueDerived)) {
      handleChange(nativeEvent, newValue, activeIndex);
    }
  });
  const handleTouchEnd = useEventCallback((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    setDragging(false);
    if (!finger) {
      return;
    }
    const {
      newValue
    } = getFingerNewValue({
      finger,
      move: true
    });
    setActive(-1);
    if (nativeEvent.type === "touchend") {
      setOpen(-1);
    }
    if (onChangeCommitted) {
      onChangeCommitted(nativeEvent, newValue);
    }
    touchId.current = void 0;
    stopListening();
  });
  const handleTouchStart = useEventCallback((nativeEvent) => {
    if (disabled) {
      return;
    }
    if (!doesSupportTouchActionNone()) {
      nativeEvent.preventDefault();
    }
    const touch = nativeEvent.changedTouches[0];
    if (touch != null) {
      touchId.current = touch.identifier;
    }
    const finger = trackFinger(nativeEvent, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange && !areValuesEqual(newValue, valueDerived)) {
        handleChange(nativeEvent, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("touchmove", handleTouchMove, {
      passive: true
    });
    doc.addEventListener("touchend", handleTouchEnd, {
      passive: true
    });
  });
  const stopListening = reactExports.useCallback(() => {
    const doc = ownerDocument(sliderRef.current);
    doc.removeEventListener("mousemove", handleTouchMove);
    doc.removeEventListener("mouseup", handleTouchEnd);
    doc.removeEventListener("touchmove", handleTouchMove);
    doc.removeEventListener("touchend", handleTouchEnd);
  }, [handleTouchEnd, handleTouchMove]);
  reactExports.useEffect(() => {
    const {
      current: slider
    } = sliderRef;
    slider.addEventListener("touchstart", handleTouchStart, {
      passive: doesSupportTouchActionNone()
    });
    return () => {
      slider.removeEventListener("touchstart", handleTouchStart);
      stopListening();
    };
  }, [stopListening, handleTouchStart]);
  reactExports.useEffect(() => {
    if (disabled) {
      stopListening();
    }
  }, [disabled, stopListening]);
  const createHandleMouseDown = (otherHandlers) => (event) => {
    var _otherHandlers$onMous;
    (_otherHandlers$onMous = otherHandlers.onMouseDown) == null || _otherHandlers$onMous.call(otherHandlers, event);
    if (disabled) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    const finger = trackFinger(event, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange && !areValuesEqual(newValue, valueDerived)) {
        handleChange(event, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("mousemove", handleTouchMove, {
      passive: true
    });
    doc.addEventListener("mouseup", handleTouchEnd);
  };
  const trackOffset = valueToPercent(range2 ? values2[0] : min3, min3, max3);
  const trackLeap = valueToPercent(values2[values2.length - 1], min3, max3) - trackOffset;
  const getRootProps = (externalProps = {}) => {
    const externalHandlers = extractEventHandlers(externalProps);
    const ownEventHandlers = {
      onMouseDown: createHandleMouseDown(externalHandlers || {})
    };
    const mergedEventHandlers = _extends$h({}, externalHandlers, ownEventHandlers);
    return _extends$h({}, externalProps, {
      ref: handleRef
    }, mergedEventHandlers);
  };
  const createHandleMouseOver = (otherHandlers) => (event) => {
    var _otherHandlers$onMous2;
    (_otherHandlers$onMous2 = otherHandlers.onMouseOver) == null || _otherHandlers$onMous2.call(otherHandlers, event);
    const index2 = Number(event.currentTarget.getAttribute("data-index"));
    setOpen(index2);
  };
  const createHandleMouseLeave = (otherHandlers) => (event) => {
    var _otherHandlers$onMous3;
    (_otherHandlers$onMous3 = otherHandlers.onMouseLeave) == null || _otherHandlers$onMous3.call(otherHandlers, event);
    setOpen(-1);
  };
  const getThumbProps = (externalProps = {}) => {
    const externalHandlers = extractEventHandlers(externalProps);
    const ownEventHandlers = {
      onMouseOver: createHandleMouseOver(externalHandlers || {}),
      onMouseLeave: createHandleMouseLeave(externalHandlers || {})
    };
    return _extends$h({}, externalProps, externalHandlers, ownEventHandlers);
  };
  const getThumbStyle = (index2) => {
    return {
      // So the non active thumb doesn't show its label on hover.
      pointerEvents: active3 !== -1 && active3 !== index2 ? "none" : void 0
    };
  };
  const getHiddenInputProps = (externalProps = {}) => {
    var _parameters$step;
    const externalHandlers = extractEventHandlers(externalProps);
    const ownEventHandlers = {
      onChange: createHandleHiddenInputChange(externalHandlers || {}),
      onFocus: createHandleHiddenInputFocus(externalHandlers || {}),
      onBlur: createHandleHiddenInputBlur(externalHandlers || {}),
      onKeyDown: createHandleHiddenInputKeyDown(externalHandlers || {})
    };
    const mergedEventHandlers = _extends$h({}, externalHandlers, ownEventHandlers);
    return _extends$h({
      tabIndex,
      "aria-labelledby": ariaLabelledby,
      "aria-orientation": orientation,
      "aria-valuemax": scale(max3),
      "aria-valuemin": scale(min3),
      name: name2,
      type: "range",
      min: parameters.min,
      max: parameters.max,
      step: parameters.step === null && parameters.marks ? "any" : (_parameters$step = parameters.step) != null ? _parameters$step : void 0,
      disabled
    }, externalProps, mergedEventHandlers, {
      style: _extends$h({}, visuallyHidden, {
        direction: isRtl ? "rtl" : "ltr",
        // So that VoiceOver's focus indicator matches the thumb's dimensions
        width: "100%",
        height: "100%"
      })
    });
  };
  return {
    active: active3,
    axis,
    axisProps,
    dragging,
    focusedThumbIndex,
    getHiddenInputProps,
    getRootProps,
    getThumbProps,
    marks,
    open,
    range: range2,
    rootRef: handleRef,
    trackLeap,
    trackOffset,
    values: values2,
    getThumbStyle
  };
}
const shouldSpreadAdditionalProps = (Slot) => {
  return !Slot || !isHostComponent(Slot);
};
const useValueLabelClasses = (props) => {
  const {
    open
  } = props;
  const utilityClasses = {
    offset: clsx(open && sliderClasses.valueLabelOpen),
    circle: sliderClasses.valueLabelCircle,
    label: sliderClasses.valueLabelLabel
  };
  return utilityClasses;
};
function SliderValueLabel$1(props) {
  const {
    children,
    className,
    value
  } = props;
  const classes = useValueLabelClasses(props);
  if (!children) {
    return null;
  }
  return /* @__PURE__ */ reactExports.cloneElement(children, {
    className: clsx(children.props.className)
  }, /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [children.props.children, /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: clsx(classes.offset, className),
      "aria-hidden": true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes.circle,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: classes.label,
          children: value
        })
      })
    })]
  }));
}
const _excluded$d = ["aria-label", "aria-valuetext", "aria-labelledby", "component", "components", "componentsProps", "color", "classes", "className", "disableSwap", "disabled", "getAriaLabel", "getAriaValueText", "marks", "max", "min", "name", "onChange", "onChangeCommitted", "orientation", "shiftStep", "size", "step", "scale", "slotProps", "slots", "tabIndex", "track", "value", "valueLabelDisplay", "valueLabelFormat"];
function Identity(x) {
  return x;
}
const SliderRoot = styled("span", {
  name: "MuiSlider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2["color".concat(capitalize$1(ownerState.color))], ownerState.size !== "medium" && styles2["size".concat(capitalize$1(ownerState.size))], ownerState.marked && styles2.marked, ownerState.orientation === "vertical" && styles2.vertical, ownerState.track === "inverted" && styles2.trackInverted, ownerState.track === false && styles2.trackFalse];
  }
})(({
  theme
}) => {
  var _theme$vars;
  return {
    borderRadius: 12,
    boxSizing: "content-box",
    display: "inline-block",
    position: "relative",
    cursor: "pointer",
    touchAction: "none",
    WebkitTapHighlightColor: "transparent",
    "@media print": {
      colorAdjust: "exact"
    },
    ["&.".concat(sliderClasses.disabled)]: {
      pointerEvents: "none",
      cursor: "default",
      color: (theme.vars || theme).palette.grey[400]
    },
    ["&.".concat(sliderClasses.dragging)]: {
      ["& .".concat(sliderClasses.thumb, ", & .").concat(sliderClasses.track)]: {
        transition: "none"
      }
    },
    variants: [...Object.keys(((_theme$vars = theme.vars) != null ? _theme$vars : theme).palette).filter((key) => {
      var _theme$vars2;
      return ((_theme$vars2 = theme.vars) != null ? _theme$vars2 : theme).palette[key].main;
    }).map((color) => ({
      props: {
        color
      },
      style: {
        color: (theme.vars || theme).palette[color].main
      }
    })), {
      props: {
        orientation: "horizontal"
      },
      style: {
        height: 4,
        width: "100%",
        padding: "13px 0",
        // The primary input mechanism of the device includes a pointing device of limited accuracy.
        "@media (pointer: coarse)": {
          // Reach 42px touch target, about ~8mm on screen.
          padding: "20px 0"
        }
      }
    }, {
      props: {
        orientation: "horizontal",
        size: "small"
      },
      style: {
        height: 2
      }
    }, {
      props: {
        orientation: "horizontal",
        marked: true
      },
      style: {
        marginBottom: 20
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        height: "100%",
        width: 4,
        padding: "0 13px",
        // The primary input mechanism of the device includes a pointing device of limited accuracy.
        "@media (pointer: coarse)": {
          // Reach 42px touch target, about ~8mm on screen.
          padding: "0 20px"
        }
      }
    }, {
      props: {
        orientation: "vertical",
        size: "small"
      },
      style: {
        width: 2
      }
    }, {
      props: {
        orientation: "vertical",
        marked: true
      },
      style: {
        marginRight: 44
      }
    }]
  };
});
const SliderRail = styled("span", {
  name: "MuiSlider",
  slot: "Rail",
  overridesResolver: (props, styles2) => styles2.rail
})({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  backgroundColor: "currentColor",
  opacity: 0.38,
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      width: "100%",
      height: "inherit",
      top: "50%",
      transform: "translateY(-50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: "inherit",
      left: "50%",
      transform: "translateX(-50%)"
    }
  }, {
    props: {
      track: "inverted"
    },
    style: {
      opacity: 1
    }
  }]
});
const SliderTrack = styled("span", {
  name: "MuiSlider",
  slot: "Track",
  overridesResolver: (props, styles2) => styles2.track
})(({
  theme
}) => {
  var _theme$vars3;
  return {
    display: "block",
    position: "absolute",
    borderRadius: "inherit",
    border: "1px solid currentColor",
    backgroundColor: "currentColor",
    transition: theme.transitions.create(["left", "width", "bottom", "height"], {
      duration: theme.transitions.duration.shortest
    }),
    variants: [{
      props: {
        size: "small"
      },
      style: {
        border: "none"
      }
    }, {
      props: {
        orientation: "horizontal"
      },
      style: {
        height: "inherit",
        top: "50%",
        transform: "translateY(-50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        width: "inherit",
        left: "50%",
        transform: "translateX(-50%)"
      }
    }, {
      props: {
        track: false
      },
      style: {
        display: "none"
      }
    }, ...Object.keys(((_theme$vars3 = theme.vars) != null ? _theme$vars3 : theme).palette).filter((key) => {
      var _theme$vars4;
      return ((_theme$vars4 = theme.vars) != null ? _theme$vars4 : theme).palette[key].main;
    }).map((color) => ({
      props: {
        color,
        track: "inverted"
      },
      style: _extends$h({}, theme.vars ? {
        backgroundColor: theme.vars.palette.Slider["".concat(color, "Track")],
        borderColor: theme.vars.palette.Slider["".concat(color, "Track")]
      } : _extends$h({
        backgroundColor: lighten_1(theme.palette[color].main, 0.62),
        borderColor: lighten_1(theme.palette[color].main, 0.62)
      }, theme.applyStyles("dark", {
        backgroundColor: darken_1(theme.palette[color].main, 0.5)
      }), theme.applyStyles("dark", {
        borderColor: darken_1(theme.palette[color].main, 0.5)
      })))
    }))]
  };
});
const SliderThumb = styled("span", {
  name: "MuiSlider",
  slot: "Thumb",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.thumb, styles2["thumbColor".concat(capitalize$1(ownerState.color))], ownerState.size !== "medium" && styles2["thumbSize".concat(capitalize$1(ownerState.size))]];
  }
})(({
  theme
}) => {
  var _theme$vars5;
  return {
    position: "absolute",
    width: 20,
    height: 20,
    boxSizing: "border-box",
    borderRadius: "50%",
    outline: 0,
    backgroundColor: "currentColor",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    transition: theme.transitions.create(["box-shadow", "left", "bottom"], {
      duration: theme.transitions.duration.shortest
    }),
    "&::before": {
      position: "absolute",
      content: '""',
      borderRadius: "inherit",
      width: "100%",
      height: "100%",
      boxShadow: (theme.vars || theme).shadows[2]
    },
    "&::after": {
      position: "absolute",
      content: '""',
      borderRadius: "50%",
      // 42px is the hit target
      width: 42,
      height: 42,
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)"
    },
    ["&.".concat(sliderClasses.disabled)]: {
      "&:hover": {
        boxShadow: "none"
      }
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        width: 12,
        height: 12,
        "&::before": {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        orientation: "horizontal"
      },
      style: {
        top: "50%",
        transform: "translate(-50%, -50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        left: "50%",
        transform: "translate(-50%, 50%)"
      }
    }, ...Object.keys(((_theme$vars5 = theme.vars) != null ? _theme$vars5 : theme).palette).filter((key) => {
      var _theme$vars6;
      return ((_theme$vars6 = theme.vars) != null ? _theme$vars6 : theme).palette[key].main;
    }).map((color) => ({
      props: {
        color
      },
      style: {
        ["&:hover, &.".concat(sliderClasses.focusVisible)]: _extends$h({}, theme.vars ? {
          boxShadow: "0px 0px 0px 8px rgba(".concat(theme.vars.palette[color].mainChannel, " / 0.16)")
        } : {
          boxShadow: "0px 0px 0px 8px ".concat(alpha_1(theme.palette[color].main, 0.16))
        }, {
          "@media (hover: none)": {
            boxShadow: "none"
          }
        }),
        ["&.".concat(sliderClasses.active)]: _extends$h({}, theme.vars ? {
          boxShadow: "0px 0px 0px 14px rgba(".concat(theme.vars.palette[color].mainChannel, " / 0.16)")
        } : {
          boxShadow: "0px 0px 0px 14px ".concat(alpha_1(theme.palette[color].main, 0.16))
        })
      }
    }))]
  };
});
const SliderValueLabel = styled(SliderValueLabel$1, {
  name: "MuiSlider",
  slot: "ValueLabel",
  overridesResolver: (props, styles2) => styles2.valueLabel
})(({
  theme
}) => _extends$h({
  zIndex: 1,
  whiteSpace: "nowrap"
}, theme.typography.body2, {
  fontWeight: 500,
  transition: theme.transitions.create(["transform"], {
    duration: theme.transitions.duration.shortest
  }),
  position: "absolute",
  backgroundColor: (theme.vars || theme).palette.grey[600],
  borderRadius: 2,
  color: (theme.vars || theme).palette.common.white,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: "0.25rem 0.75rem",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      transform: "translateY(-100%) scale(0)",
      top: "-10px",
      transformOrigin: "bottom center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, 50%) rotate(45deg)",
        backgroundColor: "inherit",
        bottom: 0,
        left: "50%"
      },
      ["&.".concat(sliderClasses.valueLabelOpen)]: {
        transform: "translateY(-100%) scale(1)"
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      transform: "translateY(-50%) scale(0)",
      right: "30px",
      top: "50%",
      transformOrigin: "right center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, -50%) rotate(45deg)",
        backgroundColor: "inherit",
        right: -8,
        top: "50%"
      },
      ["&.".concat(sliderClasses.valueLabelOpen)]: {
        transform: "translateY(-50%) scale(1)"
      }
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      fontSize: theme.typography.pxToRem(12),
      padding: "0.25rem 0.5rem"
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      right: "20px"
    }
  }]
}));
const SliderMark = styled("span", {
  name: "MuiSlider",
  slot: "Mark",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markActive",
  overridesResolver: (props, styles2) => {
    const {
      markActive
    } = props;
    return [styles2.mark, markActive && styles2.markActive];
  }
})(({
  theme
}) => ({
  position: "absolute",
  width: 2,
  height: 2,
  borderRadius: 1,
  backgroundColor: "currentColor",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-1px, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 1px)"
    }
  }, {
    props: {
      markActive: true
    },
    style: {
      backgroundColor: (theme.vars || theme).palette.background.paper,
      opacity: 0.8
    }
  }]
}));
const SliderMarkLabel = styled("span", {
  name: "MuiSlider",
  slot: "MarkLabel",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markLabelActive",
  overridesResolver: (props, styles2) => styles2.markLabel
})(({
  theme
}) => _extends$h({}, theme.typography.body2, {
  color: (theme.vars || theme).palette.text.secondary,
  position: "absolute",
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: 30,
      transform: "translateX(-50%)",
      "@media (pointer: coarse)": {
        top: 40
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: 36,
      transform: "translateY(50%)",
      "@media (pointer: coarse)": {
        left: 44
      }
    }
  }, {
    props: {
      markLabelActive: true
    },
    style: {
      color: (theme.vars || theme).palette.text.primary
    }
  }]
}));
const useUtilityClasses$2 = (ownerState) => {
  const {
    disabled,
    dragging,
    marked,
    orientation,
    track,
    classes,
    color,
    size
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", dragging && "dragging", marked && "marked", orientation === "vertical" && "vertical", track === "inverted" && "trackInverted", track === false && "trackFalse", color && "color".concat(capitalize$1(color)), size && "size".concat(capitalize$1(size))],
    rail: ["rail"],
    track: ["track"],
    mark: ["mark"],
    markActive: ["markActive"],
    markLabel: ["markLabel"],
    markLabelActive: ["markLabelActive"],
    valueLabel: ["valueLabel"],
    thumb: ["thumb", disabled && "disabled", size && "thumbSize".concat(capitalize$1(size)), color && "thumbColor".concat(capitalize$1(color))],
    active: ["active"],
    disabled: ["disabled"],
    focusVisible: ["focusVisible"]
  };
  return composeClasses(slots, getSliderUtilityClass, classes);
};
const Forward = ({
  children
}) => children;
const Slider$1 = /* @__PURE__ */ reactExports.forwardRef(function Slider2(inputProps, ref2) {
  var _ref, _slots$root, _ref2, _slots$rail, _ref3, _slots$track, _ref4, _slots$thumb, _ref5, _slots$valueLabel, _ref6, _slots$mark, _ref7, _slots$markLabel, _ref8, _slots$input, _slotProps$root, _slotProps$rail, _slotProps$track, _slotProps$thumb, _slotProps$valueLabel, _slotProps$mark, _slotProps$markLabel, _slotProps$input;
  const props = useDefaultProps({
    props: inputProps,
    name: "MuiSlider"
  });
  const isRtl = useRtl();
  const {
    "aria-label": ariaLabel,
    "aria-valuetext": ariaValuetext,
    "aria-labelledby": ariaLabelledby,
    // eslint-disable-next-line react/prop-types
    component = "span",
    components = {},
    componentsProps = {},
    color = "primary",
    classes: classesProp,
    className,
    disableSwap = false,
    disabled = false,
    getAriaLabel,
    getAriaValueText,
    marks: marksProp = false,
    max: max3 = 100,
    min: min3 = 0,
    orientation = "horizontal",
    shiftStep = 10,
    size = "medium",
    step = 1,
    scale = Identity,
    slotProps,
    slots,
    track = "normal",
    valueLabelDisplay = "off",
    valueLabelFormat = Identity
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$d);
  const ownerState = _extends$h({}, props, {
    isRtl,
    max: max3,
    min: min3,
    classes: classesProp,
    disabled,
    disableSwap,
    orientation,
    marks: marksProp,
    color,
    size,
    step,
    shiftStep,
    scale,
    track,
    valueLabelDisplay,
    valueLabelFormat
  });
  const {
    axisProps: axisProps2,
    getRootProps,
    getHiddenInputProps,
    getThumbProps,
    open,
    active: active3,
    axis,
    focusedThumbIndex,
    range: range2,
    dragging,
    marks,
    values: values2,
    trackOffset,
    trackLeap,
    getThumbStyle
  } = useSlider(_extends$h({}, ownerState, {
    rootRef: ref2
  }));
  ownerState.marked = marks.length > 0 && marks.some((mark) => mark.label);
  ownerState.dragging = dragging;
  ownerState.focusedThumbIndex = focusedThumbIndex;
  const classes = useUtilityClasses$2(ownerState);
  const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : SliderRoot;
  const RailSlot = (_ref2 = (_slots$rail = slots == null ? void 0 : slots.rail) != null ? _slots$rail : components.Rail) != null ? _ref2 : SliderRail;
  const TrackSlot = (_ref3 = (_slots$track = slots == null ? void 0 : slots.track) != null ? _slots$track : components.Track) != null ? _ref3 : SliderTrack;
  const ThumbSlot = (_ref4 = (_slots$thumb = slots == null ? void 0 : slots.thumb) != null ? _slots$thumb : components.Thumb) != null ? _ref4 : SliderThumb;
  const ValueLabelSlot = (_ref5 = (_slots$valueLabel = slots == null ? void 0 : slots.valueLabel) != null ? _slots$valueLabel : components.ValueLabel) != null ? _ref5 : SliderValueLabel;
  const MarkSlot = (_ref6 = (_slots$mark = slots == null ? void 0 : slots.mark) != null ? _slots$mark : components.Mark) != null ? _ref6 : SliderMark;
  const MarkLabelSlot = (_ref7 = (_slots$markLabel = slots == null ? void 0 : slots.markLabel) != null ? _slots$markLabel : components.MarkLabel) != null ? _ref7 : SliderMarkLabel;
  const InputSlot = (_ref8 = (_slots$input = slots == null ? void 0 : slots.input) != null ? _slots$input : components.Input) != null ? _ref8 : "input";
  const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
  const railSlotProps = (_slotProps$rail = slotProps == null ? void 0 : slotProps.rail) != null ? _slotProps$rail : componentsProps.rail;
  const trackSlotProps = (_slotProps$track = slotProps == null ? void 0 : slotProps.track) != null ? _slotProps$track : componentsProps.track;
  const thumbSlotProps = (_slotProps$thumb = slotProps == null ? void 0 : slotProps.thumb) != null ? _slotProps$thumb : componentsProps.thumb;
  const valueLabelSlotProps = (_slotProps$valueLabel = slotProps == null ? void 0 : slotProps.valueLabel) != null ? _slotProps$valueLabel : componentsProps.valueLabel;
  const markSlotProps = (_slotProps$mark = slotProps == null ? void 0 : slotProps.mark) != null ? _slotProps$mark : componentsProps.mark;
  const markLabelSlotProps = (_slotProps$markLabel = slotProps == null ? void 0 : slotProps.markLabel) != null ? _slotProps$markLabel : componentsProps.markLabel;
  const inputSlotProps = (_slotProps$input = slotProps == null ? void 0 : slotProps.input) != null ? _slotProps$input : componentsProps.input;
  const rootProps = useSlotProps({
    elementType: RootSlot,
    getSlotProps: getRootProps,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    additionalProps: _extends$h({}, shouldSpreadAdditionalProps(RootSlot) && {
      as: component
    }),
    ownerState: _extends$h({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
    className: [classes.root, className]
  });
  const railProps = useSlotProps({
    elementType: RailSlot,
    externalSlotProps: railSlotProps,
    ownerState,
    className: classes.rail
  });
  const trackProps = useSlotProps({
    elementType: TrackSlot,
    externalSlotProps: trackSlotProps,
    additionalProps: {
      style: _extends$h({}, axisProps2[axis].offset(trackOffset), axisProps2[axis].leap(trackLeap))
    },
    ownerState: _extends$h({}, ownerState, trackSlotProps == null ? void 0 : trackSlotProps.ownerState),
    className: classes.track
  });
  const thumbProps = useSlotProps({
    elementType: ThumbSlot,
    getSlotProps: getThumbProps,
    externalSlotProps: thumbSlotProps,
    ownerState: _extends$h({}, ownerState, thumbSlotProps == null ? void 0 : thumbSlotProps.ownerState),
    className: classes.thumb
  });
  const valueLabelProps = useSlotProps({
    elementType: ValueLabelSlot,
    externalSlotProps: valueLabelSlotProps,
    ownerState: _extends$h({}, ownerState, valueLabelSlotProps == null ? void 0 : valueLabelSlotProps.ownerState),
    className: classes.valueLabel
  });
  const markProps = useSlotProps({
    elementType: MarkSlot,
    externalSlotProps: markSlotProps,
    ownerState,
    className: classes.mark
  });
  const markLabelProps = useSlotProps({
    elementType: MarkLabelSlot,
    externalSlotProps: markLabelSlotProps,
    ownerState,
    className: classes.markLabel
  });
  const inputSliderProps = useSlotProps({
    elementType: InputSlot,
    getSlotProps: getHiddenInputProps,
    externalSlotProps: inputSlotProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends$h({}, rootProps, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(RailSlot, _extends$h({}, railProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(TrackSlot, _extends$h({}, trackProps)), marks.filter((mark) => mark.value >= min3 && mark.value <= max3).map((mark, index2) => {
      const percent = valueToPercent(mark.value, min3, max3);
      const style = axisProps2[axis].offset(percent);
      let markActive;
      if (track === false) {
        markActive = values2.indexOf(mark.value) !== -1;
      } else {
        markActive = track === "normal" && (range2 ? mark.value >= values2[0] && mark.value <= values2[values2.length - 1] : mark.value <= values2[0]) || track === "inverted" && (range2 ? mark.value <= values2[0] || mark.value >= values2[values2.length - 1] : mark.value >= values2[0]);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(MarkSlot, _extends$h({
          "data-index": index2
        }, markProps, !isHostComponent(MarkSlot) && {
          markActive
        }, {
          style: _extends$h({}, style, markProps.style),
          className: clsx(markProps.className, markActive && classes.markActive)
        })), mark.label != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(MarkLabelSlot, _extends$h({
          "aria-hidden": true,
          "data-index": index2
        }, markLabelProps, !isHostComponent(MarkLabelSlot) && {
          markLabelActive: markActive
        }, {
          style: _extends$h({}, style, markLabelProps.style),
          className: clsx(classes.markLabel, markLabelProps.className, markActive && classes.markLabelActive),
          children: mark.label
        })) : null]
      }, index2);
    }), values2.map((value, index2) => {
      const percent = valueToPercent(value, min3, max3);
      const style = axisProps2[axis].offset(percent);
      const ValueLabelComponent = valueLabelDisplay === "off" ? Forward : ValueLabelSlot;
      return (
        /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
        /* @__PURE__ */ jsxRuntimeExports.jsx(ValueLabelComponent, _extends$h({}, !isHostComponent(ValueLabelComponent) && {
          valueLabelFormat,
          valueLabelDisplay,
          value: typeof valueLabelFormat === "function" ? valueLabelFormat(scale(value), index2) : valueLabelFormat,
          index: index2,
          open: open === index2 || active3 === index2 || valueLabelDisplay === "on",
          disabled
        }, valueLabelProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThumbSlot, _extends$h({
            "data-index": index2
          }, thumbProps, {
            className: clsx(classes.thumb, thumbProps.className, active3 === index2 && classes.active, focusedThumbIndex === index2 && classes.focusVisible),
            style: _extends$h({}, style, getThumbStyle(index2), thumbProps.style),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputSlot, _extends$h({
              "data-index": index2,
              "aria-label": getAriaLabel ? getAriaLabel(index2) : ariaLabel,
              "aria-valuenow": scale(value),
              "aria-labelledby": ariaLabelledby,
              "aria-valuetext": getAriaValueText ? getAriaValueText(scale(value), index2) : ariaValuetext,
              value: values2[index2]
            }, inputSliderProps))
          }))
        }), index2)
      );
    })]
  }));
});
const _excluded$c = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
const styles$M = {
  entering: {
    transform: "none"
  },
  entered: {
    transform: "none"
  }
};
const Zoom = /* @__PURE__ */ reactExports.forwardRef(function Zoom2(props, ref2) {
  const theme = useTheme();
  const defaultTimeout = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
    addEndListener,
    appear = true,
    children,
    easing,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style,
    timeout = defaultTimeout,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$c);
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, children.ref, ref2);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node);
      } else {
        callback(node, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node, isAppearing) => {
    reflow(node);
    const transitionProps = getTransitionProps({
      style,
      timeout,
      easing
    }, {
      mode: "enter"
    });
    node.style.webkitTransition = theme.transitions.create("transform", transitionProps);
    node.style.transition = theme.transitions.create("transform", transitionProps);
    if (onEnter) {
      onEnter(node, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node) => {
    const transitionProps = getTransitionProps({
      style,
      timeout,
      easing
    }, {
      mode: "exit"
    });
    node.style.webkitTransition = theme.transitions.create("transform", transitionProps);
    node.style.transition = theme.transitions.create("transform", transitionProps);
    if (onExit) {
      onExit(node);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next) => {
    if (addEndListener) {
      addEndListener(nodeRef.current, next);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$h({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout
  }, other, {
    children: (state, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends$h({
        style: _extends$h({
          transform: "scale(0)",
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, styles$M[state], style, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
function getSpeedDialUtilityClass(slot) {
  return generateUtilityClass("MuiSpeedDial", slot);
}
const speedDialClasses = generateUtilityClasses("MuiSpeedDial", ["root", "fab", "directionUp", "directionDown", "directionLeft", "directionRight", "actions", "actionsClosed"]);
const _excluded$b = ["ref"], _excluded2$1 = ["ariaLabel", "FabProps", "children", "className", "direction", "hidden", "icon", "onBlur", "onClose", "onFocus", "onKeyDown", "onMouseEnter", "onMouseLeave", "onOpen", "open", "openIcon", "TransitionComponent", "transitionDuration", "TransitionProps"], _excluded3 = ["ref"];
const useUtilityClasses$1 = (ownerState) => {
  const {
    classes,
    open,
    direction
  } = ownerState;
  const slots = {
    root: ["root", "direction".concat(capitalize$1(direction))],
    fab: ["fab"],
    actions: ["actions", !open && "actionsClosed"]
  };
  return composeClasses(slots, getSpeedDialUtilityClass, classes);
};
function getOrientation(direction) {
  if (direction === "up" || direction === "down") {
    return "vertical";
  }
  if (direction === "right" || direction === "left") {
    return "horizontal";
  }
  return void 0;
}
const dialRadius = 32;
const spacingActions = 16;
const SpeedDialRoot = styled("div", {
  name: "MuiSpeedDial",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2["direction".concat(capitalize$1(ownerState.direction))]];
  }
})(({
  theme,
  ownerState
}) => _extends$h({
  zIndex: (theme.vars || theme).zIndex.speedDial,
  display: "flex",
  alignItems: "center",
  pointerEvents: "none"
}, ownerState.direction === "up" && {
  flexDirection: "column-reverse",
  ["& .".concat(speedDialClasses.actions)]: {
    flexDirection: "column-reverse",
    marginBottom: -dialRadius,
    paddingBottom: spacingActions + dialRadius
  }
}, ownerState.direction === "down" && {
  flexDirection: "column",
  ["& .".concat(speedDialClasses.actions)]: {
    flexDirection: "column",
    marginTop: -dialRadius,
    paddingTop: spacingActions + dialRadius
  }
}, ownerState.direction === "left" && {
  flexDirection: "row-reverse",
  ["& .".concat(speedDialClasses.actions)]: {
    flexDirection: "row-reverse",
    marginRight: -dialRadius,
    paddingRight: spacingActions + dialRadius
  }
}, ownerState.direction === "right" && {
  flexDirection: "row",
  ["& .".concat(speedDialClasses.actions)]: {
    flexDirection: "row",
    marginLeft: -dialRadius,
    paddingLeft: spacingActions + dialRadius
  }
}));
const SpeedDialFab = styled(Fab, {
  name: "MuiSpeedDial",
  slot: "Fab",
  overridesResolver: (props, styles2) => styles2.fab
})(() => ({
  pointerEvents: "auto"
}));
const SpeedDialActions = styled("div", {
  name: "MuiSpeedDial",
  slot: "Actions",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.actions, !ownerState.open && styles2.actionsClosed];
  }
})(({
  ownerState
}) => _extends$h({
  display: "flex",
  pointerEvents: "auto"
}, !ownerState.open && {
  transition: "top 0s linear 0.2s",
  pointerEvents: "none"
}));
const SpeedDial = /* @__PURE__ */ reactExports.forwardRef(function SpeedDial2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSpeedDial"
  });
  const theme = useTheme();
  const defaultTransitionDuration = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
    ariaLabel,
    FabProps: {
      ref: origDialButtonRef
    } = {},
    children: childrenProp,
    className,
    direction = "up",
    hidden: hidden2 = false,
    icon,
    onBlur,
    onClose,
    onFocus,
    onKeyDown,
    onMouseEnter,
    onMouseLeave,
    onOpen,
    open: openProp,
    TransitionComponent = Zoom,
    transitionDuration = defaultTransitionDuration,
    TransitionProps
  } = props, FabProps = _objectWithoutPropertiesLoose(props.FabProps, _excluded$b), other = _objectWithoutPropertiesLoose(props, _excluded2$1);
  const [open, setOpenState] = useControlled({
    controlled: openProp,
    default: false,
    name: "SpeedDial",
    state: "open"
  });
  const ownerState = _extends$h({}, props, {
    open,
    direction
  });
  const classes = useUtilityClasses$1(ownerState);
  const eventTimer = useTimeout();
  const focusedAction = reactExports.useRef(0);
  const nextItemArrowKey = reactExports.useRef();
  const actions = reactExports.useRef([]);
  actions.current = [actions.current[0]];
  const handleOwnFabRef = reactExports.useCallback((fabFef) => {
    actions.current[0] = fabFef;
  }, []);
  const handleFabRef = useForkRef(origDialButtonRef, handleOwnFabRef);
  const createHandleSpeedDialActionButtonRef = (dialActionIndex, origButtonRef) => {
    return (buttonRef) => {
      actions.current[dialActionIndex + 1] = buttonRef;
      if (origButtonRef) {
        origButtonRef(buttonRef);
      }
    };
  };
  const handleKeyDown = (event) => {
    if (onKeyDown) {
      onKeyDown(event);
    }
    const key = event.key.replace("Arrow", "").toLowerCase();
    const {
      current: nextItemArrowKeyCurrent = key
    } = nextItemArrowKey;
    if (event.key === "Escape") {
      setOpenState(false);
      actions.current[0].focus();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
      return;
    }
    if (getOrientation(key) === getOrientation(nextItemArrowKeyCurrent) && getOrientation(key) !== void 0) {
      event.preventDefault();
      const actionStep = key === nextItemArrowKeyCurrent ? 1 : -1;
      const nextAction = clamp(focusedAction.current + actionStep, 0, actions.current.length - 1);
      actions.current[nextAction].focus();
      focusedAction.current = nextAction;
      nextItemArrowKey.current = nextItemArrowKeyCurrent;
    }
  };
  reactExports.useEffect(() => {
    if (!open) {
      focusedAction.current = 0;
      nextItemArrowKey.current = void 0;
    }
  }, [open]);
  const handleClose = (event) => {
    if (event.type === "mouseleave" && onMouseLeave) {
      onMouseLeave(event);
    }
    if (event.type === "blur" && onBlur) {
      onBlur(event);
    }
    eventTimer.clear();
    if (event.type === "blur") {
      eventTimer.start(0, () => {
        setOpenState(false);
        if (onClose) {
          onClose(event, "blur");
        }
      });
    } else {
      setOpenState(false);
      if (onClose) {
        onClose(event, "mouseLeave");
      }
    }
  };
  const handleClick = (event) => {
    if (FabProps.onClick) {
      FabProps.onClick(event);
    }
    eventTimer.clear();
    if (open) {
      setOpenState(false);
      if (onClose) {
        onClose(event, "toggle");
      }
    } else {
      setOpenState(true);
      if (onOpen) {
        onOpen(event, "toggle");
      }
    }
  };
  const handleOpen = (event) => {
    if (event.type === "mouseenter" && onMouseEnter) {
      onMouseEnter(event);
    }
    if (event.type === "focus" && onFocus) {
      onFocus(event);
    }
    eventTimer.clear();
    if (!open) {
      eventTimer.start(0, () => {
        setOpenState(true);
        if (onOpen) {
          const eventMap = {
            focus: "focus",
            mouseenter: "mouseEnter"
          };
          onOpen(event, eventMap[event.type]);
        }
      });
    }
  };
  const id2 = ariaLabel.replace(/^[^a-z]+|[^\w:.-]+/gi, "");
  const allItems = reactExports.Children.toArray(childrenProp).filter((child) => {
    return /* @__PURE__ */ reactExports.isValidElement(child);
  });
  const children = allItems.map((child, index2) => {
    const _child$props = child.props, {
      FabProps: {
        ref: origButtonRef
      } = {},
      tooltipPlacement: tooltipPlacementProp
    } = _child$props, ChildFabProps = _objectWithoutPropertiesLoose(_child$props.FabProps, _excluded3);
    const tooltipPlacement = tooltipPlacementProp || (getOrientation(direction) === "vertical" ? "left" : "top");
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      FabProps: _extends$h({}, ChildFabProps, {
        ref: createHandleSpeedDialActionButtonRef(index2, origButtonRef)
      }),
      delay: 30 * (open ? index2 : allItems.length - index2),
      open,
      tooltipPlacement,
      id: "".concat(id2, "-action-").concat(index2)
    });
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SpeedDialRoot, _extends$h({
    className: clsx(classes.root, className),
    ref: ref2,
    role: "presentation",
    onKeyDown: handleKeyDown,
    onBlur: handleClose,
    onFocus: handleOpen,
    onMouseEnter: handleOpen,
    onMouseLeave: handleClose,
    ownerState
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$h({
      in: !hidden2,
      timeout: transitionDuration,
      unmountOnExit: true
    }, TransitionProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(SpeedDialFab, _extends$h({
        color: "primary",
        "aria-label": ariaLabel,
        "aria-haspopup": "true",
        "aria-expanded": open,
        "aria-controls": "".concat(id2, "-actions")
      }, FabProps, {
        onClick: handleClick,
        className: clsx(classes.fab, FabProps.className),
        ref: handleFabRef,
        ownerState,
        children: /* @__PURE__ */ reactExports.isValidElement(icon) && isMuiElement(icon, ["SpeedDialIcon"]) ? /* @__PURE__ */ reactExports.cloneElement(icon, {
          open
        }) : icon
      }))
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(SpeedDialActions, {
      id: "".concat(id2, "-actions"),
      role: "menu",
      "aria-orientation": getOrientation(direction),
      className: clsx(classes.actions, !open && classes.actionsClosed),
      ownerState,
      children
    })]
  }));
});
function getSpeedDialActionUtilityClass(slot) {
  return generateUtilityClass("MuiSpeedDialAction", slot);
}
const speedDialActionClasses = generateUtilityClasses("MuiSpeedDialAction", ["fab", "fabClosed", "staticTooltip", "staticTooltipClosed", "staticTooltipLabel", "tooltipPlacementLeft", "tooltipPlacementRight"]);
const _excluded$a = ["className", "delay", "FabProps", "icon", "id", "open", "TooltipClasses", "tooltipOpen", "tooltipPlacement", "tooltipTitle"];
const useUtilityClasses = (ownerState) => {
  const {
    open,
    tooltipPlacement,
    classes
  } = ownerState;
  const slots = {
    fab: ["fab", !open && "fabClosed"],
    staticTooltip: ["staticTooltip", "tooltipPlacement".concat(capitalize$1(tooltipPlacement)), !open && "staticTooltipClosed"],
    staticTooltipLabel: ["staticTooltipLabel"]
  };
  return composeClasses(slots, getSpeedDialActionUtilityClass, classes);
};
const SpeedDialActionFab = styled(Fab, {
  name: "MuiSpeedDialAction",
  slot: "Fab",
  skipVariantsResolver: false,
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.fab, !ownerState.open && styles2.fabClosed];
  }
})(({
  theme,
  ownerState
}) => _extends$h({
  margin: 8,
  color: (theme.vars || theme).palette.text.secondary,
  backgroundColor: (theme.vars || theme).palette.background.paper,
  "&:hover": {
    backgroundColor: theme.vars ? theme.vars.palette.SpeedDialAction.fabHoverBg : emphasize_1(theme.palette.background.paper, 0.15)
  },
  transition: "".concat(theme.transitions.create("transform", {
    duration: theme.transitions.duration.shorter
  }), ", opacity 0.8s"),
  opacity: 1
}, !ownerState.open && {
  opacity: 0,
  transform: "scale(0)"
}));
const SpeedDialActionStaticTooltip = styled("span", {
  name: "MuiSpeedDialAction",
  slot: "StaticTooltip",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.staticTooltip, !ownerState.open && styles2.staticTooltipClosed, styles2["tooltipPlacement".concat(capitalize$1(ownerState.tooltipPlacement))]];
  }
})(({
  theme,
  ownerState
}) => ({
  position: "relative",
  display: "flex",
  alignItems: "center",
  ["& .".concat(speedDialActionClasses.staticTooltipLabel)]: _extends$h({
    transition: theme.transitions.create(["transform", "opacity"], {
      duration: theme.transitions.duration.shorter
    }),
    opacity: 1
  }, !ownerState.open && {
    opacity: 0,
    transform: "scale(0.5)"
  }, ownerState.tooltipPlacement === "left" && {
    transformOrigin: "100% 50%",
    right: "100%",
    marginRight: 8
  }, ownerState.tooltipPlacement === "right" && {
    transformOrigin: "0% 50%",
    left: "100%",
    marginLeft: 8
  })
}));
const SpeedDialActionStaticTooltipLabel = styled("span", {
  name: "MuiSpeedDialAction",
  slot: "StaticTooltipLabel",
  overridesResolver: (props, styles2) => styles2.staticTooltipLabel
})(({
  theme
}) => _extends$h({
  position: "absolute"
}, theme.typography.body1, {
  backgroundColor: (theme.vars || theme).palette.background.paper,
  borderRadius: (theme.vars || theme).shape.borderRadius,
  boxShadow: (theme.vars || theme).shadows[1],
  color: (theme.vars || theme).palette.text.secondary,
  padding: "4px 16px",
  wordBreak: "keep-all"
}));
const SpeedDialAction = /* @__PURE__ */ reactExports.forwardRef(function SpeedDialAction2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSpeedDialAction"
  });
  const {
    className,
    delay = 0,
    FabProps = {},
    icon,
    id: id2,
    open,
    TooltipClasses,
    tooltipOpen: tooltipOpenProp = false,
    tooltipPlacement = "left",
    tooltipTitle
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$a);
  const ownerState = _extends$h({}, props, {
    tooltipPlacement
  });
  const classes = useUtilityClasses(ownerState);
  const [tooltipOpen, setTooltipOpen] = reactExports.useState(tooltipOpenProp);
  const handleTooltipClose = () => {
    setTooltipOpen(false);
  };
  const handleTooltipOpen = () => {
    setTooltipOpen(true);
  };
  const transitionStyle = {
    transitionDelay: "".concat(delay, "ms")
  };
  const fab = /* @__PURE__ */ jsxRuntimeExports.jsx(SpeedDialActionFab, _extends$h({
    size: "small",
    className: clsx(classes.fab, className),
    tabIndex: -1,
    role: "menuitem",
    ownerState
  }, FabProps, {
    style: _extends$h({}, transitionStyle, FabProps.style),
    children: icon
  }));
  if (tooltipOpenProp) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SpeedDialActionStaticTooltip, _extends$h({
      id: id2,
      ref: ref2,
      className: classes.staticTooltip,
      ownerState
    }, other, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SpeedDialActionStaticTooltipLabel, {
        style: transitionStyle,
        id: "".concat(id2, "-label"),
        className: classes.staticTooltipLabel,
        ownerState,
        children: tooltipTitle
      }), /* @__PURE__ */ reactExports.cloneElement(fab, {
        "aria-labelledby": "".concat(id2, "-label")
      })]
    }));
  }
  if (!open && tooltipOpen) {
    setTooltipOpen(false);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, _extends$h({
    id: id2,
    ref: ref2,
    title: tooltipTitle,
    placement: tooltipPlacement,
    onClose: handleTooltipClose,
    onOpen: handleTooltipOpen,
    open: open && tooltipOpen,
    classes: TooltipClasses
  }, other, {
    children: fab
  }));
});
function useDragLayer(collect) {
  const dragDropManager = useDragDropManager();
  const monitor = dragDropManager.getMonitor();
  const [collected, updateCollected] = useCollector(monitor, collect);
  reactExports.useEffect(
    () => monitor.subscribeToOffsetChange(updateCollected)
  );
  reactExports.useEffect(
    () => monitor.subscribeToStateChange(updateCollected)
  );
  return collected;
}
const Cancel = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2m5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12z"
}), "Cancel");
const EditOutlined = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m14.06 9.02.92.92L5.92 19H5v-.92zM17.66 3c-.25 0-.51.1-.7.29l-1.83 1.83 3.75 3.75 1.83-1.83c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.2-.2-.45-.29-.71-.29m-3.6 3.19L3 17.25V21h3.75L17.81 9.94z"
}), "EditOutlined");
const Palette = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.49 2 2 6.49 2 12s4.49 10 10 10c1.38 0 2.5-1.12 2.5-2.5 0-.61-.23-1.2-.64-1.67-.08-.1-.13-.21-.13-.33 0-.28.22-.5.5-.5H16c3.31 0 6-2.69 6-6 0-4.96-4.49-9-10-9m5.5 11c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5m-3-4c-.83 0-1.5-.67-1.5-1.5S13.67 6 14.5 6s1.5.67 1.5 1.5S15.33 9 14.5 9M5 11.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5S7.33 13 6.5 13 5 12.33 5 11.5m6-4c0 .83-.67 1.5-1.5 1.5S8 8.33 8 7.5 8.67 6 9.5 6s1.5.67 1.5 1.5"
}), "Palette");
const noPadding$1 = "_noPadding_1ii70_1";
const addRow = "_addRow_1ii70_5";
const addColumn = "_addColumn_1ii70_9";
const addIcon = "_addIcon_1ii70_13";
const svgContainer$1 = "_svgContainer_1ii70_23";
const addButton = "_addButton_1ii70_31";
const styles$L = {
  noPadding: noPadding$1,
  addRow,
  addColumn,
  addIcon,
  svgContainer: svgContainer$1,
  addButton
};
const mainContainer = "_mainContainer_as1f9_1";
const updateButtons = "_updateButtons_as1f9_5";
const save = "_save_as1f9_14";
const header = "_header_as1f9_18";
const styles$K = {
  mainContainer,
  updateButtons,
  save,
  header
};
const groupEmptyHint$1 = "_groupEmptyHint_1pku9_2";
const groupEmptyHintHover$1 = "_groupEmptyHintHover_1pku9_14";
const footer = "_footer_1pku9_18";
const contentPanel = "_contentPanel_1pku9_22";
const cardImage = "_cardImage_1pku9_30";
const customScrollBar = "_customScrollBar_1pku9_38";
const virtuosoStyle = "_virtuosoStyle_1pku9_42";
const cardMediaContent = "_cardMediaContent_1pku9_47";
const buttonContainer$2 = "_buttonContainer_1pku9_55";
const button = "_button_1pku9_55";
const styles$J = {
  groupEmptyHint: groupEmptyHint$1,
  groupEmptyHintHover: groupEmptyHintHover$1,
  footer,
  contentPanel,
  cardImage,
  customScrollBar,
  virtuosoStyle,
  cardMediaContent,
  buttonContainer: buttonContainer$2,
  button
};
const errorDisplay$2 = "_errorDisplay_1joy4_1";
const clickable = "_clickable_1joy4_10";
const styles$I = {
  errorDisplay: errorDisplay$2,
  clickable
};
var ErrorOutline = {};
var _interopRequireDefault$v = interopRequireDefaultExports;
Object.defineProperty(ErrorOutline, "__esModule", {
  value: true
});
var default_1$n = ErrorOutline.default = void 0;
var _createSvgIcon$n = _interopRequireDefault$v(requireCreateSvgIcon());
var _jsxRuntime$n = jsxRuntimeExports;
default_1$n = ErrorOutline.default = (0, _createSvgIcon$n.default)(/* @__PURE__ */ (0, _jsxRuntime$n.jsx)("path", {
  d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2M12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8"
}), "ErrorOutline");
function ErrorDisplay(props) {
  const { t: t2 } = useTranslation("design");
  const dispatch = useDispatch();
  const selectDesignState = (state) => state.designState[props.code] || {};
  const selectErrorsAndInstructions = createSelector(
    [selectDesignState],
    (designState) => {
      var _a;
      const instructionsWithErrors = (_a = designState.instructionList) == null ? void 0 : _a.filter(
        (instruction) => {
          var _a2;
          return ((_a2 = instruction.errors) == null ? void 0 : _a2.length) > 0;
        }
      );
      return {
        errors: designState.errors,
        designErrors: designState.designErrors,
        instructions: (instructionsWithErrors == null ? void 0 : instructionsWithErrors.length) ? instructionsWithErrors : void 0
      };
    }
  );
  const { errors, designErrors, instructions } = useSelector(
    selectErrorsAndInstructions
  );
  const hasErrors = (errors == null ? void 0 : errors.length) > 0 || (designErrors == null ? void 0 : designErrors.length) > 0 || (instructions == null ? void 0 : instructions.length) > 0;
  const type2 = useSelector((state) => {
    var _a;
    return props.code == "Survey" ? "" : isGroup(props.code) ? ((_a = state.designState[props.code].groupType) == null ? void 0 : _a.toLowerCase()) || "group" : state.designState[props.code].type;
  });
  const onErrClick = (instruction) => {
    if (instruction.code === "conditional_relevance") {
      dispatch(
        setup({
          code: props.code,
          rules: setupOptions(type2),
          highlighted: "relevance",
          expanded: ["relevance"]
        })
      );
    } else if (instruction.code === "random_group" || instruction.code === "priority_groups") {
      if (props.code == "Survey") {
        dispatch(setup({ ...surveySetup$1, highlighted: "random" }));
      } else {
        dispatch(
          setup({
            code: props.code,
            rules: setupOptions(type2),
            highlighted: "random",
            expanded: ["random"]
          })
        );
      }
    } else if (instruction.code.startsWith("skip_to")) {
      dispatch(
        setup({
          code: props.code,
          rules: setupOptions(type2),
          highlighted: "skip_logic",
          expanded: ["skip_logic"]
        })
      );
    }
    return "";
  };
  const isClickable = (instruction) => {
    return instruction.code === "conditional_relevance" || instruction.code === "random_group" || instruction.code === "priority_groups" || instruction.code.startsWith("skip_to");
  };
  return hasErrors ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$I.errorDisplay, children: [
    errors && errors.map((el) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, { style: { verticalAlign: "middle" } }),
        mapComponentError(props.code, el, t2)
      ] }, el);
    }),
    designErrors && designErrors.map((el) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, { style: { verticalAlign: "middle" } }),
        el.message
      ] }, el.code);
    }),
    instructions && instructions.map((el) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: isClickable(el) ? styles$I.clickable : "",
          onClick: () => onErrClick(el),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$n, { style: { verticalAlign: "middle" } }),
            mapInstructionError(el, t2)
          ]
        },
        el.code
      );
    })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
}
const mapComponentError = (code, error2, t2) => {
  if (error2 === "EMPTY_PARENT") {
    return t2("err_empty_parent", {
      component_name: componentName(code, t2),
      child_name: componentChildName(code, t2)
    });
  } else if (error2 === "DUPLICATE_CODE") {
    return t2("err_duplicate_code"), { component_name: componentName(code, t2) };
  } else if (error2 === "NO_END_GROUP") {
    return t2("err_no_end_group");
  } else if (error2 === "MISPLACED_END_GROUP") {
    return t2("err_misplaced_end_group");
  } else if (error2 === "MISPLACED_WELCOME_GROUP") {
    return t2("err_misplaced_welcome_group");
  }
  return "";
};
const mapInstructionError = (instruction, t2) => {
  if (instruction.code === "value" && instruction.errors[0].name == "InvalidInstructionInEndGroup") {
    return t2("err_value_in_end_group");
  } else if (instruction.code === "conditional_relevance") {
    return t2("err_relevance");
  } else if (instruction.code === "random_group") {
    return t2("err_random");
  } else if (instruction.code === "priority_groups") {
    return t2("err_priority");
  } else if (instruction.code.startsWith("reference")) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Trans,
      {
        t: t2,
        values: {
          codes: instruction.errors.map((error2) => {
            var _a;
            return (_a = error2.dependency) == null ? void 0 : _a.componentCode;
          }).join(", "),
          lang: instruction.lang
        },
        i18nKey: "err_reference"
      }
    );
  } else if (instruction.code.startsWith("skip_to")) {
    return t2("err_skip");
  }
  return "";
};
const componentName = (code, t2) => {
  if (code == "Survey") {
    return t2("survey");
  } else if (isQuestion(code)) {
    return t2("question");
  } else if (isGroup(code)) {
    return t2("group");
  }
  return t2("option");
};
const componentChildName = (code, t2) => {
  if (isGroup(code)) {
    return t2("question");
  } else if (code == "Survey") {
    return t2("group");
  }
  return t2("option");
};
const ErrorDisplay$1 = reactExports.memo(ErrorDisplay);
var ViewCompact = {};
var _interopRequireDefault$u = interopRequireDefaultExports;
Object.defineProperty(ViewCompact, "__esModule", {
  value: true
});
var default_1$m = ViewCompact.default = void 0;
var _createSvgIcon$m = _interopRequireDefault$u(requireCreateSvgIcon());
var _jsxRuntime$m = jsxRuntimeExports;
default_1$m = ViewCompact.default = (0, _createSvgIcon$m.default)(/* @__PURE__ */ (0, _jsxRuntime$m.jsx)("path", {
  d: "M4 18h2.5v-2.5H4zm0-4.75h2.5v-2.5H4zM4 8.5h2.5V6H4zM17.5 6v2.5H20V6zM13 8.5h2.5V6H13zm4.5 9.5H20v-2.5h-2.5zm0-4.75H20v-2.5h-2.5zM8.5 18H11v-2.5H8.5zm4.5 0h2.5v-2.5H13zM8.5 8.5H11V6H8.5zm4.5 4.75h2.5v-2.5H13zm-4.5 0H11v-2.5H8.5z"
}), "ViewCompact");
const textDescriptionContent = "_textDescriptionContent_o9cn8_1";
const moveBox$1 = "_moveBox_o9cn8_7";
const groupQuestion = "_groupQuestion_o9cn8_13";
const titleContainer = "_titleContainer_o9cn8_22";
const titleQuestion = "_titleQuestion_o9cn8_29";
const iconBox = "_iconBox_o9cn8_39";
const actionToolbarVisible$1 = "_actionToolbarVisible_o9cn8_59";
const fadeInMoveRight$1 = "_fadeInMoveRight_o9cn8_1";
const contentContainer$1 = "_contentContainer_o9cn8_64";
const styles$H = {
  textDescriptionContent,
  moveBox: moveBox$1,
  groupQuestion,
  titleContainer,
  titleQuestion,
  iconBox,
  actionToolbarVisible: actionToolbarVisible$1,
  fadeInMoveRight: fadeInMoveRight$1,
  contentContainer: contentContainer$1
};
const fullWidth = "_fullWidth_1dvff_1";
const toolbarClass = "_toolbarClass_1dvff_6";
const noPadding = "_noPadding_1dvff_12";
const placeholder$2 = "_placeholder_1dvff_25";
const styles$G = {
  fullWidth,
  toolbarClass,
  "rdw-editor-toolbar": "_rdw-editor-toolbar_1dvff_6",
  noPadding,
  placeholder: placeholder$2
};
function listCacheClear$2() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$2;
function eq$6(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$6;
var eq$5 = eq_1;
function assocIndexOf$5(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$5(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$5;
var assocIndexOf$4 = _assocIndexOf;
var arrayProto$1 = Array.prototype;
var splice$1 = arrayProto$1.splice;
function listCacheDelete$2(key) {
  var data = this.__data__, index2 = assocIndexOf$4(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$2;
var assocIndexOf$3 = _assocIndexOf;
function listCacheGet$2(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$2;
var assocIndexOf$2 = _assocIndexOf;
function listCacheHas$2(key) {
  return assocIndexOf$2(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$2;
var assocIndexOf$1 = _assocIndexOf;
function listCacheSet$2(key, value) {
  var data = this.__data__, index2 = assocIndexOf$1(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$2;
var listCacheClear$1 = _listCacheClear, listCacheDelete$1 = _listCacheDelete, listCacheGet$1 = _listCacheGet, listCacheHas$1 = _listCacheHas, listCacheSet$1 = _listCacheSet;
function ListCache$5(entries3) {
  var index2 = -1, length = entries3 == null ? 0 : entries3.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries3[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$5.prototype.clear = listCacheClear$1;
ListCache$5.prototype["delete"] = listCacheDelete$1;
ListCache$5.prototype.get = listCacheGet$1;
ListCache$5.prototype.has = listCacheHas$1;
ListCache$5.prototype.set = listCacheSet$1;
var _ListCache = ListCache$5;
var ListCache$4 = _ListCache;
function stackClear$2() {
  this.__data__ = new ListCache$4();
  this.size = 0;
}
var _stackClear = stackClear$2;
function stackDelete$2(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$2;
function stackGet$2(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$2;
function stackHas$2(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$2;
var freeGlobal$2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$2;
var freeGlobal$1 = _freeGlobal;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$a = freeGlobal$1 || freeSelf$1 || Function("return this")();
var _root = root$a;
var root$9 = _root;
var Symbol$8 = root$9.Symbol;
var _Symbol = Symbol$8;
var Symbol$7 = _Symbol;
var objectProto$u = Object.prototype;
var hasOwnProperty$p = objectProto$u.hasOwnProperty;
var nativeObjectToString$3 = objectProto$u.toString;
var symToStringTag$3 = Symbol$7 ? Symbol$7.toStringTag : void 0;
function getRawTag$2(value) {
  var isOwn = hasOwnProperty$p.call(value, symToStringTag$3), tag = value[symToStringTag$3];
  try {
    value[symToStringTag$3] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$3.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$3] = tag;
    } else {
      delete value[symToStringTag$3];
    }
  }
  return result;
}
var _getRawTag = getRawTag$2;
var objectProto$t = Object.prototype;
var nativeObjectToString$2 = objectProto$t.toString;
function objectToString$2(value) {
  return nativeObjectToString$2.call(value);
}
var _objectToString = objectToString$2;
var Symbol$6 = _Symbol, getRawTag$1 = _getRawTag, objectToString$1 = _objectToString;
var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
var symToStringTag$2 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function baseGetTag$8(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag$1 : nullTag$1;
  }
  return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$1(value) : objectToString$1(value);
}
var _baseGetTag = baseGetTag$8;
function isObject$k(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var isObject_1 = isObject$k;
var baseGetTag$7 = _baseGetTag, isObject$j = isObject_1;
var asyncTag$1 = "[object AsyncFunction]", funcTag$4 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
function isFunction$6(value) {
  if (!isObject$j(value)) {
    return false;
  }
  var tag = baseGetTag$7(value);
  return tag == funcTag$4 || tag == genTag$2 || tag == asyncTag$1 || tag == proxyTag$1;
}
var isFunction_1 = isFunction$6;
var root$8 = _root;
var coreJsData$2 = root$8["__core-js_shared__"];
var _coreJsData = coreJsData$2;
var coreJsData$1 = _coreJsData;
var maskSrcKey$1 = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$2(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
var _isMasked = isMasked$2;
var funcProto$5 = Function.prototype;
var funcToString$5 = funcProto$5.toString;
function toSource$3(func) {
  if (func != null) {
    try {
      return funcToString$5.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$3;
var isFunction$5 = isFunction_1, isMasked$1 = _isMasked, isObject$i = isObject_1, toSource$2 = _toSource;
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var funcProto$4 = Function.prototype, objectProto$s = Object.prototype;
var funcToString$4 = funcProto$4.toString;
var hasOwnProperty$o = objectProto$s.hasOwnProperty;
var reIsNative$1 = RegExp(
  "^" + funcToString$4.call(hasOwnProperty$o).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$2(value) {
  if (!isObject$i(value) || isMasked$1(value)) {
    return false;
  }
  var pattern = isFunction$5(value) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$2(value));
}
var _baseIsNative = baseIsNative$2;
function getValue$3(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$3;
var baseIsNative$1 = _baseIsNative, getValue$2 = _getValue;
function getNative$8(object, key) {
  var value = getValue$2(object, key);
  return baseIsNative$1(value) ? value : void 0;
}
var _getNative = getNative$8;
var getNative$7 = _getNative, root$7 = _root;
var Map$6 = getNative$7(root$7, "Map");
var _Map = Map$6;
var getNative$6 = _getNative;
var nativeCreate$5 = getNative$6(Object, "create");
var _nativeCreate = nativeCreate$5;
var nativeCreate$4 = _nativeCreate;
function hashClear$2() {
  this.__data__ = nativeCreate$4 ? nativeCreate$4(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$2;
function hashDelete$2(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$2;
var nativeCreate$3 = _nativeCreate;
var HASH_UNDEFINED$5 = "__lodash_hash_undefined__";
var objectProto$r = Object.prototype;
var hasOwnProperty$n = objectProto$r.hasOwnProperty;
function hashGet$2(key) {
  var data = this.__data__;
  if (nativeCreate$3) {
    var result = data[key];
    return result === HASH_UNDEFINED$5 ? void 0 : result;
  }
  return hasOwnProperty$n.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$2;
var nativeCreate$2 = _nativeCreate;
var objectProto$q = Object.prototype;
var hasOwnProperty$m = objectProto$q.hasOwnProperty;
function hashHas$2(key) {
  var data = this.__data__;
  return nativeCreate$2 ? data[key] !== void 0 : hasOwnProperty$m.call(data, key);
}
var _hashHas = hashHas$2;
var nativeCreate$1 = _nativeCreate;
var HASH_UNDEFINED$4 = "__lodash_hash_undefined__";
function hashSet$2(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$4 : value;
  return this;
}
var _hashSet = hashSet$2;
var hashClear$1 = _hashClear, hashDelete$1 = _hashDelete, hashGet$1 = _hashGet, hashHas$1 = _hashHas, hashSet$1 = _hashSet;
function Hash$2(entries3) {
  var index2 = -1, length = entries3 == null ? 0 : entries3.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries3[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$2.prototype.clear = hashClear$1;
Hash$2.prototype["delete"] = hashDelete$1;
Hash$2.prototype.get = hashGet$1;
Hash$2.prototype.has = hashHas$1;
Hash$2.prototype.set = hashSet$1;
var _Hash = Hash$2;
var Hash$1 = _Hash, ListCache$3 = _ListCache, Map$5 = _Map;
function mapCacheClear$2() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash$1(),
    "map": new (Map$5 || ListCache$3)(),
    "string": new Hash$1()
  };
}
var _mapCacheClear = mapCacheClear$2;
function isKeyable$2(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$2;
var isKeyable$1 = _isKeyable;
function getMapData$5(map3, key) {
  var data = map3.__data__;
  return isKeyable$1(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$5;
var getMapData$4 = _getMapData;
function mapCacheDelete$2(key) {
  var result = getMapData$4(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$2;
var getMapData$3 = _getMapData;
function mapCacheGet$2(key) {
  return getMapData$3(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$2;
var getMapData$2 = _getMapData;
function mapCacheHas$2(key) {
  return getMapData$2(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$2;
var getMapData$1 = _getMapData;
function mapCacheSet$2(key, value) {
  var data = getMapData$1(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$2;
var mapCacheClear$1 = _mapCacheClear, mapCacheDelete$1 = _mapCacheDelete, mapCacheGet$1 = _mapCacheGet, mapCacheHas$1 = _mapCacheHas, mapCacheSet$1 = _mapCacheSet;
function MapCache$4(entries3) {
  var index2 = -1, length = entries3 == null ? 0 : entries3.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries3[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$4.prototype.clear = mapCacheClear$1;
MapCache$4.prototype["delete"] = mapCacheDelete$1;
MapCache$4.prototype.get = mapCacheGet$1;
MapCache$4.prototype.has = mapCacheHas$1;
MapCache$4.prototype.set = mapCacheSet$1;
var _MapCache = MapCache$4;
var ListCache$2 = _ListCache, Map$4 = _Map, MapCache$3 = _MapCache;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet$2(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$2) {
    var pairs = data.__data__;
    if (!Map$4 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$3(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$2;
var ListCache$1 = _ListCache, stackClear$1 = _stackClear, stackDelete$1 = _stackDelete, stackGet$1 = _stackGet, stackHas$1 = _stackHas, stackSet$1 = _stackSet;
function Stack$6(entries3) {
  var data = this.__data__ = new ListCache$1(entries3);
  this.size = data.size;
}
Stack$6.prototype.clear = stackClear$1;
Stack$6.prototype["delete"] = stackDelete$1;
Stack$6.prototype.get = stackGet$1;
Stack$6.prototype.has = stackHas$1;
Stack$6.prototype.set = stackSet$1;
var _Stack = Stack$6;
var HASH_UNDEFINED$3 = "__lodash_hash_undefined__";
function setCacheAdd$2(value) {
  this.__data__.set(value, HASH_UNDEFINED$3);
  return this;
}
var _setCacheAdd = setCacheAdd$2;
function setCacheHas$2(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$2;
var MapCache$2 = _MapCache, setCacheAdd$1 = _setCacheAdd, setCacheHas$1 = _setCacheHas;
function SetCache$2(values2) {
  var index2 = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache$2();
  while (++index2 < length) {
    this.add(values2[index2]);
  }
}
SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd$1;
SetCache$2.prototype.has = setCacheHas$1;
var _SetCache = SetCache$2;
function arraySome$2(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$2;
function cacheHas$2(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$2;
var SetCache$1 = _SetCache, arraySome$1 = _arraySome, cacheHas$1 = _cacheHas;
var COMPARE_PARTIAL_FLAG$b = 1, COMPARE_UNORDERED_FLAG$7 = 2;
function equalArrays$3(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$b, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$7 ? new SetCache$1() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome$1(other, function(othValue2, othIndex) {
        if (!cacheHas$1(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$3;
var root$6 = _root;
var Uint8Array$4 = root$6.Uint8Array;
var _Uint8Array = Uint8Array$4;
function mapToArray$2(map3) {
  var index2 = -1, result = Array(map3.size);
  map3.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$2;
function setToArray$2(set3) {
  var index2 = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray$2;
var Symbol$5 = _Symbol, Uint8Array$3 = _Uint8Array, eq$4 = eq_1, equalArrays$2 = _equalArrays, mapToArray$1 = _mapToArray, setToArray$1 = _setToArray;
var COMPARE_PARTIAL_FLAG$a = 1, COMPARE_UNORDERED_FLAG$6 = 2;
var boolTag$5 = "[object Boolean]", dateTag$5 = "[object Date]", errorTag$4 = "[object Error]", mapTag$8 = "[object Map]", numberTag$5 = "[object Number]", regexpTag$5 = "[object RegExp]", setTag$8 = "[object Set]", stringTag$6 = "[object String]", symbolTag$5 = "[object Symbol]";
var arrayBufferTag$5 = "[object ArrayBuffer]", dataViewTag$7 = "[object DataView]";
var symbolProto$4 = Symbol$5 ? Symbol$5.prototype : void 0, symbolValueOf$2 = symbolProto$4 ? symbolProto$4.valueOf : void 0;
function equalByTag$2(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$7:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag$5:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$3(object), new Uint8Array$3(other))) {
        return false;
      }
      return true;
    case boolTag$5:
    case dateTag$5:
    case numberTag$5:
      return eq$4(+object, +other);
    case errorTag$4:
      return object.name == other.name && object.message == other.message;
    case regexpTag$5:
    case stringTag$6:
      return object == other + "";
    case mapTag$8:
      var convert = mapToArray$1;
    case setTag$8:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$a;
      convert || (convert = setToArray$1);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$6;
      stack.set(object, other);
      var result = equalArrays$2(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag$5:
      if (symbolValueOf$2) {
        return symbolValueOf$2.call(object) == symbolValueOf$2.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$2;
function arrayPush$4(array, values2) {
  var index2 = -1, length = values2.length, offset2 = array.length;
  while (++index2 < length) {
    array[offset2 + index2] = values2[index2];
  }
  return array;
}
var _arrayPush = arrayPush$4;
var isArray$g = Array.isArray;
var isArray_1 = isArray$g;
var arrayPush$3 = _arrayPush, isArray$f = isArray_1;
function baseGetAllKeys$3(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$f(object) ? result : arrayPush$3(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$3;
function arrayFilter$2(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$2;
function stubArray$3() {
  return [];
}
var stubArray_1 = stubArray$3;
var arrayFilter$1 = _arrayFilter, stubArray$2 = stubArray_1;
var objectProto$p = Object.prototype;
var propertyIsEnumerable$3 = objectProto$p.propertyIsEnumerable;
var nativeGetSymbols$2 = Object.getOwnPropertySymbols;
var getSymbols$4 = !nativeGetSymbols$2 ? stubArray$2 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter$1(nativeGetSymbols$2(object), function(symbol) {
    return propertyIsEnumerable$3.call(object, symbol);
  });
};
var _getSymbols = getSymbols$4;
function baseTimes$2(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$2;
function isObjectLike$b(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$b;
var baseGetTag$6 = _baseGetTag, isObjectLike$a = isObjectLike_1;
var argsTag$6 = "[object Arguments]";
function baseIsArguments$2(value) {
  return isObjectLike$a(value) && baseGetTag$6(value) == argsTag$6;
}
var _baseIsArguments = baseIsArguments$2;
var baseIsArguments$1 = _baseIsArguments, isObjectLike$9 = isObjectLike_1;
var objectProto$o = Object.prototype;
var hasOwnProperty$l = objectProto$o.hasOwnProperty;
var propertyIsEnumerable$2 = objectProto$o.propertyIsEnumerable;
var isArguments$8 = baseIsArguments$1(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments$1 : function(value) {
  return isObjectLike$9(value) && hasOwnProperty$l.call(value, "callee") && !propertyIsEnumerable$2.call(value, "callee");
};
var isArguments_1 = isArguments$8;
var isBuffer$6 = { exports: {} };
function stubFalse$1() {
  return false;
}
var stubFalse_1 = stubFalse$1;
isBuffer$6.exports;
(function(module2, exports2) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var Buffer2 = moduleExports2 ? root2.Buffer : void 0;
  var nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer2 || stubFalse2;
  module2.exports = isBuffer2;
})(isBuffer$6, isBuffer$6.exports);
var isBufferExports = isBuffer$6.exports;
var MAX_SAFE_INTEGER$3 = 9007199254740991;
var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$5(value, length) {
  var type2 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$3 : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint$1.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$5;
var MAX_SAFE_INTEGER$2 = 9007199254740991;
function isLength$4(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
}
var isLength_1 = isLength$4;
var baseGetTag$5 = _baseGetTag, isLength$3 = isLength_1, isObjectLike$8 = isObjectLike_1;
var argsTag$5 = "[object Arguments]", arrayTag$4 = "[object Array]", boolTag$4 = "[object Boolean]", dateTag$4 = "[object Date]", errorTag$3 = "[object Error]", funcTag$3 = "[object Function]", mapTag$7 = "[object Map]", numberTag$4 = "[object Number]", objectTag$8 = "[object Object]", regexpTag$4 = "[object RegExp]", setTag$7 = "[object Set]", stringTag$5 = "[object String]", weakMapTag$4 = "[object WeakMap]";
var arrayBufferTag$4 = "[object ArrayBuffer]", dataViewTag$6 = "[object DataView]", float32Tag$3 = "[object Float32Array]", float64Tag$3 = "[object Float64Array]", int8Tag$3 = "[object Int8Array]", int16Tag$3 = "[object Int16Array]", int32Tag$3 = "[object Int32Array]", uint8Tag$3 = "[object Uint8Array]", uint8ClampedTag$3 = "[object Uint8ClampedArray]", uint16Tag$3 = "[object Uint16Array]", uint32Tag$3 = "[object Uint32Array]";
var typedArrayTags$1 = {};
typedArrayTags$1[float32Tag$3] = typedArrayTags$1[float64Tag$3] = typedArrayTags$1[int8Tag$3] = typedArrayTags$1[int16Tag$3] = typedArrayTags$1[int32Tag$3] = typedArrayTags$1[uint8Tag$3] = typedArrayTags$1[uint8ClampedTag$3] = typedArrayTags$1[uint16Tag$3] = typedArrayTags$1[uint32Tag$3] = true;
typedArrayTags$1[argsTag$5] = typedArrayTags$1[arrayTag$4] = typedArrayTags$1[arrayBufferTag$4] = typedArrayTags$1[boolTag$4] = typedArrayTags$1[dataViewTag$6] = typedArrayTags$1[dateTag$4] = typedArrayTags$1[errorTag$3] = typedArrayTags$1[funcTag$3] = typedArrayTags$1[mapTag$7] = typedArrayTags$1[numberTag$4] = typedArrayTags$1[objectTag$8] = typedArrayTags$1[regexpTag$4] = typedArrayTags$1[setTag$7] = typedArrayTags$1[stringTag$5] = typedArrayTags$1[weakMapTag$4] = false;
function baseIsTypedArray$2(value) {
  return isObjectLike$8(value) && isLength$3(value.length) && !!typedArrayTags$1[baseGetTag$5(value)];
}
var _baseIsTypedArray = baseIsTypedArray$2;
function baseUnary$4(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$4;
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(module2, exports2) {
  var freeGlobal2 = _freeGlobal;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var freeProcess2 = moduleExports2 && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule2 && freeModule2.require && freeModule2.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
    } catch (e2) {
    }
  }();
  module2.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray$1 = _baseIsTypedArray, baseUnary$3 = _baseUnary, nodeUtil$3 = _nodeUtilExports;
var nodeIsTypedArray$1 = nodeUtil$3 && nodeUtil$3.isTypedArray;
var isTypedArray$4 = nodeIsTypedArray$1 ? baseUnary$3(nodeIsTypedArray$1) : baseIsTypedArray$1;
var isTypedArray_1 = isTypedArray$4;
var baseTimes$1 = _baseTimes, isArguments$7 = isArguments_1, isArray$e = isArray_1, isBuffer$5 = isBufferExports, isIndex$4 = _isIndex, isTypedArray$3 = isTypedArray_1;
var objectProto$n = Object.prototype;
var hasOwnProperty$k = objectProto$n.hasOwnProperty;
function arrayLikeKeys$3(value, inherited) {
  var isArr = isArray$e(value), isArg = !isArr && isArguments$7(value), isBuff = !isArr && !isArg && isBuffer$5(value), isType = !isArr && !isArg && !isBuff && isTypedArray$3(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes$1(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$k.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$4(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$3;
var objectProto$m = Object.prototype;
function isPrototype$4(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$m;
  return value === proto2;
}
var _isPrototype = isPrototype$4;
function overArg$3(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var _overArg = overArg$3;
var overArg$2 = _overArg;
var nativeKeys$2 = overArg$2(Object.keys, Object);
var _nativeKeys = nativeKeys$2;
var isPrototype$3 = _isPrototype, nativeKeys$1 = _nativeKeys;
var objectProto$l = Object.prototype;
var hasOwnProperty$j = objectProto$l.hasOwnProperty;
function baseKeys$2(object) {
  if (!isPrototype$3(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$j.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$2;
var isFunction$4 = isFunction_1, isLength$2 = isLength_1;
function isArrayLike$8(value) {
  return value != null && isLength$2(value.length) && !isFunction$4(value);
}
var isArrayLike_1 = isArrayLike$8;
var arrayLikeKeys$2 = _arrayLikeKeys, baseKeys$1 = _baseKeys, isArrayLike$7 = isArrayLike_1;
function keys$8(object) {
  return isArrayLike$7(object) ? arrayLikeKeys$2(object) : baseKeys$1(object);
}
var keys_1 = keys$8;
const keys$9 = /* @__PURE__ */ getDefaultExportFromCjs(keys_1);
var baseGetAllKeys$2 = _baseGetAllKeys, getSymbols$3 = _getSymbols, keys$7 = keys_1;
function getAllKeys$3(object) {
  return baseGetAllKeys$2(object, keys$7, getSymbols$3);
}
var _getAllKeys = getAllKeys$3;
var getAllKeys$2 = _getAllKeys;
var COMPARE_PARTIAL_FLAG$9 = 1;
var objectProto$k = Object.prototype;
var hasOwnProperty$i = objectProto$k.hasOwnProperty;
function equalObjects$2(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$9, objProps = getAllKeys$2(object), objLength = objProps.length, othProps = getAllKeys$2(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$i.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$2;
var getNative$5 = _getNative, root$5 = _root;
var DataView$3 = getNative$5(root$5, "DataView");
var _DataView = DataView$3;
var getNative$4 = _getNative, root$4 = _root;
var Promise$3 = getNative$4(root$4, "Promise");
var _Promise = Promise$3;
var getNative$3 = _getNative, root$3 = _root;
var Set$4 = getNative$3(root$3, "Set");
var _Set = Set$4;
var getNative$2 = _getNative, root$2 = _root;
var WeakMap$3 = getNative$2(root$2, "WeakMap");
var _WeakMap = WeakMap$3;
var DataView$2 = _DataView, Map$3 = _Map, Promise$2 = _Promise, Set$3 = _Set, WeakMap$2 = _WeakMap, baseGetTag$4 = _baseGetTag, toSource$1 = _toSource;
var mapTag$6 = "[object Map]", objectTag$7 = "[object Object]", promiseTag$1 = "[object Promise]", setTag$6 = "[object Set]", weakMapTag$3 = "[object WeakMap]";
var dataViewTag$5 = "[object DataView]";
var dataViewCtorString$1 = toSource$1(DataView$2), mapCtorString$1 = toSource$1(Map$3), promiseCtorString$1 = toSource$1(Promise$2), setCtorString$1 = toSource$1(Set$3), weakMapCtorString$1 = toSource$1(WeakMap$2);
var getTag$5 = baseGetTag$4;
if (DataView$2 && getTag$5(new DataView$2(new ArrayBuffer(1))) != dataViewTag$5 || Map$3 && getTag$5(new Map$3()) != mapTag$6 || Promise$2 && getTag$5(Promise$2.resolve()) != promiseTag$1 || Set$3 && getTag$5(new Set$3()) != setTag$6 || WeakMap$2 && getTag$5(new WeakMap$2()) != weakMapTag$3) {
  getTag$5 = function(value) {
    var result = baseGetTag$4(value), Ctor = result == objectTag$7 ? value.constructor : void 0, ctorString = Ctor ? toSource$1(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString$1:
          return dataViewTag$5;
        case mapCtorString$1:
          return mapTag$6;
        case promiseCtorString$1:
          return promiseTag$1;
        case setCtorString$1:
          return setTag$6;
        case weakMapCtorString$1:
          return weakMapTag$3;
      }
    }
    return result;
  };
}
var _getTag = getTag$5;
var Stack$5 = _Stack, equalArrays$1 = _equalArrays, equalByTag$1 = _equalByTag, equalObjects$1 = _equalObjects, getTag$4 = _getTag, isArray$d = isArray_1, isBuffer$4 = isBufferExports, isTypedArray$2 = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$8 = 1;
var argsTag$4 = "[object Arguments]", arrayTag$3 = "[object Array]", objectTag$6 = "[object Object]";
var objectProto$j = Object.prototype;
var hasOwnProperty$h = objectProto$j.hasOwnProperty;
function baseIsEqualDeep$2(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$d(object), othIsArr = isArray$d(other), objTag = objIsArr ? arrayTag$3 : getTag$4(object), othTag = othIsArr ? arrayTag$3 : getTag$4(other);
  objTag = objTag == argsTag$4 ? objectTag$6 : objTag;
  othTag = othTag == argsTag$4 ? objectTag$6 : othTag;
  var objIsObj = objTag == objectTag$6, othIsObj = othTag == objectTag$6, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$4(object)) {
    if (!isBuffer$4(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$5());
    return objIsArr || isTypedArray$2(object) ? equalArrays$1(object, other, bitmask, customizer, equalFunc, stack) : equalByTag$1(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$8)) {
    var objIsWrapped = objIsObj && hasOwnProperty$h.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$h.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$5());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$5());
  return equalObjects$1(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$2;
var baseIsEqualDeep$1 = _baseIsEqualDeep, isObjectLike$7 = isObjectLike_1;
function baseIsEqual$4(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$7(value) && !isObjectLike$7(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep$1(value, other, bitmask, customizer, baseIsEqual$4, stack);
}
var _baseIsEqual = baseIsEqual$4;
var baseIsEqual$3 = _baseIsEqual;
function isEqual(value, other) {
  return baseIsEqual$3(value, other);
}
var isEqual_1$1 = isEqual;
var quill = { exports: {} };
/*!
 * Quill Editor v1.3.7
 * https://quilljs.com/
 * Copyright (c) 2014, Jason Chen
 * Copyright (c) 2013, salesforce.com
 */
(function(module2, exports2) {
  (function webpackUniversalModuleDefinition(root2, factory26) {
    module2.exports = factory26();
  })(typeof self !== "undefined" ? self : commonjsGlobal, function() {
    return (
      /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module3 = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.l = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports3, name2, getter) {
          if (!__webpack_require__.o(exports3, name2)) {
            Object.defineProperty(exports3, name2, {
              /******/
              configurable: false,
              /******/
              enumerable: true,
              /******/
              get: getter
              /******/
            });
          }
        };
        __webpack_require__.n = function(module3) {
          var getter = module3 && module3.__esModule ? (
            /******/
            function getDefault() {
              return module3["default"];
            }
          ) : (
            /******/
            function getModuleExports() {
              return module3;
            }
          );
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property2) {
          return Object.prototype.hasOwnProperty.call(object, property2);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 109);
      }([
        /* 0 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var container_1 = __webpack_require__(17);
          var format_1 = __webpack_require__(18);
          var leaf_1 = __webpack_require__(19);
          var scroll_1 = __webpack_require__(45);
          var inline_1 = __webpack_require__(46);
          var block_1 = __webpack_require__(47);
          var embed_1 = __webpack_require__(48);
          var text_1 = __webpack_require__(49);
          var attributor_1 = __webpack_require__(12);
          var class_1 = __webpack_require__(32);
          var style_1 = __webpack_require__(33);
          var store_1 = __webpack_require__(31);
          var Registry = __webpack_require__(1);
          var Parchment = {
            Scope: Registry.Scope,
            create: Registry.create,
            find: Registry.find,
            query: Registry.query,
            register: Registry.register,
            Container: container_1.default,
            Format: format_1.default,
            Leaf: leaf_1.default,
            Embed: embed_1.default,
            Scroll: scroll_1.default,
            Block: block_1.default,
            Inline: inline_1.default,
            Text: text_1.default,
            Attributor: {
              Attribute: attributor_1.default,
              Class: class_1.default,
              Style: style_1.default,
              Store: store_1.default
            }
          };
          exports3.default = Parchment;
        },
        /* 1 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
              d.__proto__ = b;
            } || function(d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var ParchmentError = (
            /** @class */
            function(_super) {
              __extends2(ParchmentError2, _super);
              function ParchmentError2(message) {
                var _this = this;
                message = "[Parchment] " + message;
                _this = _super.call(this, message) || this;
                _this.message = message;
                _this.name = _this.constructor.name;
                return _this;
              }
              return ParchmentError2;
            }(Error)
          );
          exports3.ParchmentError = ParchmentError;
          var attributes = {};
          var classes = {};
          var tags = {};
          var types2 = {};
          exports3.DATA_KEY = "__blot";
          var Scope;
          (function(Scope2) {
            Scope2[Scope2["TYPE"] = 3] = "TYPE";
            Scope2[Scope2["LEVEL"] = 12] = "LEVEL";
            Scope2[Scope2["ATTRIBUTE"] = 13] = "ATTRIBUTE";
            Scope2[Scope2["BLOT"] = 14] = "BLOT";
            Scope2[Scope2["INLINE"] = 7] = "INLINE";
            Scope2[Scope2["BLOCK"] = 11] = "BLOCK";
            Scope2[Scope2["BLOCK_BLOT"] = 10] = "BLOCK_BLOT";
            Scope2[Scope2["INLINE_BLOT"] = 6] = "INLINE_BLOT";
            Scope2[Scope2["BLOCK_ATTRIBUTE"] = 9] = "BLOCK_ATTRIBUTE";
            Scope2[Scope2["INLINE_ATTRIBUTE"] = 5] = "INLINE_ATTRIBUTE";
            Scope2[Scope2["ANY"] = 15] = "ANY";
          })(Scope = exports3.Scope || (exports3.Scope = {}));
          function create(input2, value) {
            var match = query(input2);
            if (match == null) {
              throw new ParchmentError("Unable to create " + input2 + " blot");
            }
            var BlotClass = match;
            var node = (
              // @ts-ignore
              input2 instanceof Node || input2["nodeType"] === Node.TEXT_NODE ? input2 : BlotClass.create(value)
            );
            return new BlotClass(node, value);
          }
          exports3.create = create;
          function find3(node, bubble2) {
            if (bubble2 === void 0) {
              bubble2 = false;
            }
            if (node == null)
              return null;
            if (node[exports3.DATA_KEY] != null)
              return node[exports3.DATA_KEY].blot;
            if (bubble2)
              return find3(node.parentNode, bubble2);
            return null;
          }
          exports3.find = find3;
          function query(query2, scope) {
            if (scope === void 0) {
              scope = Scope.ANY;
            }
            var match;
            if (typeof query2 === "string") {
              match = types2[query2] || attributes[query2];
            } else if (query2 instanceof Text || query2["nodeType"] === Node.TEXT_NODE) {
              match = types2["text"];
            } else if (typeof query2 === "number") {
              if (query2 & Scope.LEVEL & Scope.BLOCK) {
                match = types2["block"];
              } else if (query2 & Scope.LEVEL & Scope.INLINE) {
                match = types2["inline"];
              }
            } else if (query2 instanceof HTMLElement) {
              var names2 = (query2.getAttribute("class") || "").split(/\s+/);
              for (var i2 in names2) {
                match = classes[names2[i2]];
                if (match)
                  break;
              }
              match = match || tags[query2.tagName];
            }
            if (match == null)
              return null;
            if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope)
              return match;
            return null;
          }
          exports3.query = query;
          function register() {
            var Definitions = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              Definitions[_i] = arguments[_i];
            }
            if (Definitions.length > 1) {
              return Definitions.map(function(d) {
                return register(d);
              });
            }
            var Definition = Definitions[0];
            if (typeof Definition.blotName !== "string" && typeof Definition.attrName !== "string") {
              throw new ParchmentError("Invalid definition");
            } else if (Definition.blotName === "abstract") {
              throw new ParchmentError("Cannot register abstract class");
            }
            types2[Definition.blotName || Definition.attrName] = Definition;
            if (typeof Definition.keyName === "string") {
              attributes[Definition.keyName] = Definition;
            } else {
              if (Definition.className != null) {
                classes[Definition.className] = Definition;
              }
              if (Definition.tagName != null) {
                if (Array.isArray(Definition.tagName)) {
                  Definition.tagName = Definition.tagName.map(function(tagName) {
                    return tagName.toUpperCase();
                  });
                } else {
                  Definition.tagName = Definition.tagName.toUpperCase();
                }
                var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [Definition.tagName];
                tagNames.forEach(function(tag) {
                  if (tags[tag] == null || Definition.className == null) {
                    tags[tag] = Definition;
                  }
                });
              }
            }
            return Definition;
          }
          exports3.register = register;
        },
        /* 2 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var diff2 = __webpack_require__(51);
          var equal2 = __webpack_require__(11);
          var extend4 = __webpack_require__(3);
          var op2 = __webpack_require__(20);
          var NULL_CHARACTER2 = String.fromCharCode(0);
          var Delta2 = function(ops) {
            if (Array.isArray(ops)) {
              this.ops = ops;
            } else if (ops != null && Array.isArray(ops.ops)) {
              this.ops = ops.ops;
            } else {
              this.ops = [];
            }
          };
          Delta2.prototype.insert = function(text, attributes) {
            var newOp = {};
            if (text.length === 0) return this;
            newOp.insert = text;
            if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
              newOp.attributes = attributes;
            }
            return this.push(newOp);
          };
          Delta2.prototype["delete"] = function(length) {
            if (length <= 0) return this;
            return this.push({ "delete": length });
          };
          Delta2.prototype.retain = function(length, attributes) {
            if (length <= 0) return this;
            var newOp = { retain: length };
            if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
              newOp.attributes = attributes;
            }
            return this.push(newOp);
          };
          Delta2.prototype.push = function(newOp) {
            var index2 = this.ops.length;
            var lastOp = this.ops[index2 - 1];
            newOp = extend4(true, {}, newOp);
            if (typeof lastOp === "object") {
              if (typeof newOp["delete"] === "number" && typeof lastOp["delete"] === "number") {
                this.ops[index2 - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
                return this;
              }
              if (typeof lastOp["delete"] === "number" && newOp.insert != null) {
                index2 -= 1;
                lastOp = this.ops[index2 - 1];
                if (typeof lastOp !== "object") {
                  this.ops.unshift(newOp);
                  return this;
                }
              }
              if (equal2(newOp.attributes, lastOp.attributes)) {
                if (typeof newOp.insert === "string" && typeof lastOp.insert === "string") {
                  this.ops[index2 - 1] = { insert: lastOp.insert + newOp.insert };
                  if (typeof newOp.attributes === "object") this.ops[index2 - 1].attributes = newOp.attributes;
                  return this;
                } else if (typeof newOp.retain === "number" && typeof lastOp.retain === "number") {
                  this.ops[index2 - 1] = { retain: lastOp.retain + newOp.retain };
                  if (typeof newOp.attributes === "object") this.ops[index2 - 1].attributes = newOp.attributes;
                  return this;
                }
              }
            }
            if (index2 === this.ops.length) {
              this.ops.push(newOp);
            } else {
              this.ops.splice(index2, 0, newOp);
            }
            return this;
          };
          Delta2.prototype.chop = function() {
            var lastOp = this.ops[this.ops.length - 1];
            if (lastOp && lastOp.retain && !lastOp.attributes) {
              this.ops.pop();
            }
            return this;
          };
          Delta2.prototype.filter = function(predicate) {
            return this.ops.filter(predicate);
          };
          Delta2.prototype.forEach = function(predicate) {
            this.ops.forEach(predicate);
          };
          Delta2.prototype.map = function(predicate) {
            return this.ops.map(predicate);
          };
          Delta2.prototype.partition = function(predicate) {
            var passed = [], failed = [];
            this.forEach(function(op3) {
              var target = predicate(op3) ? passed : failed;
              target.push(op3);
            });
            return [passed, failed];
          };
          Delta2.prototype.reduce = function(predicate, initial) {
            return this.ops.reduce(predicate, initial);
          };
          Delta2.prototype.changeLength = function() {
            return this.reduce(function(length, elem) {
              if (elem.insert) {
                return length + op2.length(elem);
              } else if (elem.delete) {
                return length - elem.delete;
              }
              return length;
            }, 0);
          };
          Delta2.prototype.length = function() {
            return this.reduce(function(length, elem) {
              return length + op2.length(elem);
            }, 0);
          };
          Delta2.prototype.slice = function(start, end) {
            start = start || 0;
            if (typeof end !== "number") end = Infinity;
            var ops = [];
            var iter = op2.iterator(this.ops);
            var index2 = 0;
            while (index2 < end && iter.hasNext()) {
              var nextOp;
              if (index2 < start) {
                nextOp = iter.next(start - index2);
              } else {
                nextOp = iter.next(end - index2);
                ops.push(nextOp);
              }
              index2 += op2.length(nextOp);
            }
            return new Delta2(ops);
          };
          Delta2.prototype.compose = function(other) {
            var thisIter = op2.iterator(this.ops);
            var otherIter = op2.iterator(other.ops);
            var ops = [];
            var firstOther = otherIter.peek();
            if (firstOther != null && typeof firstOther.retain === "number" && firstOther.attributes == null) {
              var firstLeft = firstOther.retain;
              while (thisIter.peekType() === "insert" && thisIter.peekLength() <= firstLeft) {
                firstLeft -= thisIter.peekLength();
                ops.push(thisIter.next());
              }
              if (firstOther.retain - firstLeft > 0) {
                otherIter.next(firstOther.retain - firstLeft);
              }
            }
            var delta2 = new Delta2(ops);
            while (thisIter.hasNext() || otherIter.hasNext()) {
              if (otherIter.peekType() === "insert") {
                delta2.push(otherIter.next());
              } else if (thisIter.peekType() === "delete") {
                delta2.push(thisIter.next());
              } else {
                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                var thisOp = thisIter.next(length);
                var otherOp = otherIter.next(length);
                if (typeof otherOp.retain === "number") {
                  var newOp = {};
                  if (typeof thisOp.retain === "number") {
                    newOp.retain = length;
                  } else {
                    newOp.insert = thisOp.insert;
                  }
                  var attributes = op2.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === "number");
                  if (attributes) newOp.attributes = attributes;
                  delta2.push(newOp);
                  if (!otherIter.hasNext() && equal2(delta2.ops[delta2.ops.length - 1], newOp)) {
                    var rest2 = new Delta2(thisIter.rest());
                    return delta2.concat(rest2).chop();
                  }
                } else if (typeof otherOp["delete"] === "number" && typeof thisOp.retain === "number") {
                  delta2.push(otherOp);
                }
              }
            }
            return delta2.chop();
          };
          Delta2.prototype.concat = function(other) {
            var delta2 = new Delta2(this.ops.slice());
            if (other.ops.length > 0) {
              delta2.push(other.ops[0]);
              delta2.ops = delta2.ops.concat(other.ops.slice(1));
            }
            return delta2;
          };
          Delta2.prototype.diff = function(other, index2) {
            if (this.ops === other.ops) {
              return new Delta2();
            }
            var strings = [this, other].map(function(delta3) {
              return delta3.map(function(op3) {
                if (op3.insert != null) {
                  return typeof op3.insert === "string" ? op3.insert : NULL_CHARACTER2;
                }
                var prep = delta3 === other ? "on" : "with";
                throw new Error("diff() called " + prep + " non-document");
              }).join("");
            });
            var delta2 = new Delta2();
            var diffResult = diff2(strings[0], strings[1], index2);
            var thisIter = op2.iterator(this.ops);
            var otherIter = op2.iterator(other.ops);
            diffResult.forEach(function(component) {
              var length = component[1].length;
              while (length > 0) {
                var opLength = 0;
                switch (component[0]) {
                  case diff2.INSERT:
                    opLength = Math.min(otherIter.peekLength(), length);
                    delta2.push(otherIter.next(opLength));
                    break;
                  case diff2.DELETE:
                    opLength = Math.min(length, thisIter.peekLength());
                    thisIter.next(opLength);
                    delta2["delete"](opLength);
                    break;
                  case diff2.EQUAL:
                    opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
                    var thisOp = thisIter.next(opLength);
                    var otherOp = otherIter.next(opLength);
                    if (equal2(thisOp.insert, otherOp.insert)) {
                      delta2.retain(opLength, op2.attributes.diff(thisOp.attributes, otherOp.attributes));
                    } else {
                      delta2.push(otherOp)["delete"](opLength);
                    }
                    break;
                }
                length -= opLength;
              }
            });
            return delta2.chop();
          };
          Delta2.prototype.eachLine = function(predicate, newline) {
            newline = newline || "\n";
            var iter = op2.iterator(this.ops);
            var line = new Delta2();
            var i2 = 0;
            while (iter.hasNext()) {
              if (iter.peekType() !== "insert") return;
              var thisOp = iter.peek();
              var start = op2.length(thisOp) - iter.peekLength();
              var index2 = typeof thisOp.insert === "string" ? thisOp.insert.indexOf(newline, start) - start : -1;
              if (index2 < 0) {
                line.push(iter.next());
              } else if (index2 > 0) {
                line.push(iter.next(index2));
              } else {
                if (predicate(line, iter.next(1).attributes || {}, i2) === false) {
                  return;
                }
                i2 += 1;
                line = new Delta2();
              }
            }
            if (line.length() > 0) {
              predicate(line, {}, i2);
            }
          };
          Delta2.prototype.transform = function(other, priority) {
            priority = !!priority;
            if (typeof other === "number") {
              return this.transformPosition(other, priority);
            }
            var thisIter = op2.iterator(this.ops);
            var otherIter = op2.iterator(other.ops);
            var delta2 = new Delta2();
            while (thisIter.hasNext() || otherIter.hasNext()) {
              if (thisIter.peekType() === "insert" && (priority || otherIter.peekType() !== "insert")) {
                delta2.retain(op2.length(thisIter.next()));
              } else if (otherIter.peekType() === "insert") {
                delta2.push(otherIter.next());
              } else {
                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                var thisOp = thisIter.next(length);
                var otherOp = otherIter.next(length);
                if (thisOp["delete"]) {
                  continue;
                } else if (otherOp["delete"]) {
                  delta2.push(otherOp);
                } else {
                  delta2.retain(length, op2.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
                }
              }
            }
            return delta2.chop();
          };
          Delta2.prototype.transformPosition = function(index2, priority) {
            priority = !!priority;
            var thisIter = op2.iterator(this.ops);
            var offset2 = 0;
            while (thisIter.hasNext() && offset2 <= index2) {
              var length = thisIter.peekLength();
              var nextType = thisIter.peekType();
              thisIter.next();
              if (nextType === "delete") {
                index2 -= Math.min(length, index2 - offset2);
                continue;
              } else if (nextType === "insert" && (offset2 < index2 || !priority)) {
                index2 += length;
              }
              offset2 += length;
            }
            return index2;
          };
          module3.exports = Delta2;
        },
        /* 3 */
        /***/
        function(module3, exports3) {
          var hasOwn2 = Object.prototype.hasOwnProperty;
          var toStr2 = Object.prototype.toString;
          var defineProperty2 = Object.defineProperty;
          var gOPD2 = Object.getOwnPropertyDescriptor;
          var isArray3 = function isArray4(arr) {
            if (typeof Array.isArray === "function") {
              return Array.isArray(arr);
            }
            return toStr2.call(arr) === "[object Array]";
          };
          var isPlainObject3 = function isPlainObject4(obj) {
            if (!obj || toStr2.call(obj) !== "[object Object]") {
              return false;
            }
            var hasOwnConstructor = hasOwn2.call(obj, "constructor");
            var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn2.call(obj.constructor.prototype, "isPrototypeOf");
            if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
              return false;
            }
            var key;
            for (key in obj) {
            }
            return typeof key === "undefined" || hasOwn2.call(obj, key);
          };
          var setProperty3 = function setProperty4(target, options) {
            if (defineProperty2 && options.name === "__proto__") {
              defineProperty2(target, options.name, {
                enumerable: true,
                configurable: true,
                value: options.newValue,
                writable: true
              });
            } else {
              target[options.name] = options.newValue;
            }
          };
          var getProperty3 = function getProperty4(obj, name2) {
            if (name2 === "__proto__") {
              if (!hasOwn2.call(obj, name2)) {
                return void 0;
              } else if (gOPD2) {
                return gOPD2(obj, name2).value;
              }
            }
            return obj[name2];
          };
          module3.exports = function extend4() {
            var options, name2, src, copy2, copyIsArray, clone3;
            var target = arguments[0];
            var i2 = 1;
            var length = arguments.length;
            var deep = false;
            if (typeof target === "boolean") {
              deep = target;
              target = arguments[1] || {};
              i2 = 2;
            }
            if (target == null || typeof target !== "object" && typeof target !== "function") {
              target = {};
            }
            for (; i2 < length; ++i2) {
              options = arguments[i2];
              if (options != null) {
                for (name2 in options) {
                  src = getProperty3(target, name2);
                  copy2 = getProperty3(options, name2);
                  if (target !== copy2) {
                    if (deep && copy2 && (isPlainObject3(copy2) || (copyIsArray = isArray3(copy2)))) {
                      if (copyIsArray) {
                        copyIsArray = false;
                        clone3 = src && isArray3(src) ? src : [];
                      } else {
                        clone3 = src && isPlainObject3(src) ? src : {};
                      }
                      setProperty3(target, { name: name2, newValue: extend4(deep, clone3, copy2) });
                    } else if (typeof copy2 !== "undefined") {
                      setProperty3(target, { name: name2, newValue: copy2 });
                    }
                  }
                }
              }
            }
            return target;
          };
        },
        /* 4 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.BlockEmbed = exports3.bubbleFormats = void 0;
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _extend = __webpack_require__(3);
          var _extend2 = _interopRequireDefault2(_extend);
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _break = __webpack_require__(16);
          var _break2 = _interopRequireDefault2(_break);
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          var _text = __webpack_require__(7);
          var _text2 = _interopRequireDefault2(_text);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var NEWLINE_LENGTH = 1;
          var BlockEmbed = function(_Parchment$Embed) {
            _inherits2(BlockEmbed2, _Parchment$Embed);
            function BlockEmbed2() {
              _classCallCheck2(this, BlockEmbed2);
              return _possibleConstructorReturn2(this, (BlockEmbed2.__proto__ || Object.getPrototypeOf(BlockEmbed2)).apply(this, arguments));
            }
            _createClass2(BlockEmbed2, [{
              key: "attach",
              value: function attach() {
                _get2(BlockEmbed2.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed2.prototype), "attach", this).call(this);
                this.attributes = new _parchment2.default.Attributor.Store(this.domNode);
              }
            }, {
              key: "delta",
              value: function delta2() {
                return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));
              }
            }, {
              key: "format",
              value: function format2(name2, value) {
                var attribute = _parchment2.default.query(name2, _parchment2.default.Scope.BLOCK_ATTRIBUTE);
                if (attribute != null) {
                  this.attributes.attribute(attribute, value);
                }
              }
            }, {
              key: "formatAt",
              value: function formatAt(index2, length, name2, value) {
                this.format(name2, value);
              }
            }, {
              key: "insertAt",
              value: function insertAt(index2, value, def) {
                if (typeof value === "string" && value.endsWith("\n")) {
                  var block = _parchment2.default.create(Block3.blotName);
                  this.parent.insertBefore(block, index2 === 0 ? this : this.next);
                  block.insertAt(0, value.slice(0, -1));
                } else {
                  _get2(BlockEmbed2.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed2.prototype), "insertAt", this).call(this, index2, value, def);
                }
              }
            }]);
            return BlockEmbed2;
          }(_parchment2.default.Embed);
          BlockEmbed.scope = _parchment2.default.Scope.BLOCK_BLOT;
          var Block3 = function(_Parchment$Block) {
            _inherits2(Block4, _Parchment$Block);
            function Block4(domNode) {
              _classCallCheck2(this, Block4);
              var _this2 = _possibleConstructorReturn2(this, (Block4.__proto__ || Object.getPrototypeOf(Block4)).call(this, domNode));
              _this2.cache = {};
              return _this2;
            }
            _createClass2(Block4, [{
              key: "delta",
              value: function delta2() {
                if (this.cache.delta == null) {
                  this.cache.delta = this.descendants(_parchment2.default.Leaf).reduce(function(delta3, leaf) {
                    if (leaf.length() === 0) {
                      return delta3;
                    } else {
                      return delta3.insert(leaf.value(), bubbleFormats(leaf));
                    }
                  }, new _quillDelta2.default()).insert("\n", bubbleFormats(this));
                }
                return this.cache.delta;
              }
            }, {
              key: "deleteAt",
              value: function deleteAt(index2, length) {
                _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "deleteAt", this).call(this, index2, length);
                this.cache = {};
              }
            }, {
              key: "formatAt",
              value: function formatAt(index2, length, name2, value) {
                if (length <= 0) return;
                if (_parchment2.default.query(name2, _parchment2.default.Scope.BLOCK)) {
                  if (index2 + length === this.length()) {
                    this.format(name2, value);
                  }
                } else {
                  _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "formatAt", this).call(this, index2, Math.min(length, this.length() - index2 - 1), name2, value);
                }
                this.cache = {};
              }
            }, {
              key: "insertAt",
              value: function insertAt(index2, value, def) {
                if (def != null) return _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "insertAt", this).call(this, index2, value, def);
                if (value.length === 0) return;
                var lines = value.split("\n");
                var text = lines.shift();
                if (text.length > 0) {
                  if (index2 < this.length() - 1 || this.children.tail == null) {
                    _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "insertAt", this).call(this, Math.min(index2, this.length() - 1), text);
                  } else {
                    this.children.tail.insertAt(this.children.tail.length(), text);
                  }
                  this.cache = {};
                }
                var block = this;
                lines.reduce(function(index3, line) {
                  block = block.split(index3, true);
                  block.insertAt(0, line);
                  return line.length;
                }, index2 + text.length);
              }
            }, {
              key: "insertBefore",
              value: function insertBefore(blot, ref2) {
                var head = this.children.head;
                _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "insertBefore", this).call(this, blot, ref2);
                if (head instanceof _break2.default) {
                  head.remove();
                }
                this.cache = {};
              }
            }, {
              key: "length",
              value: function length() {
                if (this.cache.length == null) {
                  this.cache.length = _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "length", this).call(this) + NEWLINE_LENGTH;
                }
                return this.cache.length;
              }
            }, {
              key: "moveChildren",
              value: function moveChildren(target, ref2) {
                _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "moveChildren", this).call(this, target, ref2);
                this.cache = {};
              }
            }, {
              key: "optimize",
              value: function optimize(context2) {
                _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "optimize", this).call(this, context2);
                this.cache = {};
              }
            }, {
              key: "path",
              value: function path(index2) {
                return _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "path", this).call(this, index2, true);
              }
            }, {
              key: "removeChild",
              value: function removeChild(child) {
                _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "removeChild", this).call(this, child);
                this.cache = {};
              }
            }, {
              key: "split",
              value: function split2(index2) {
                var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (force && (index2 === 0 || index2 >= this.length() - NEWLINE_LENGTH)) {
                  var clone3 = this.clone();
                  if (index2 === 0) {
                    this.parent.insertBefore(clone3, this);
                    return this;
                  } else {
                    this.parent.insertBefore(clone3, this.next);
                    return clone3;
                  }
                } else {
                  var next = _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "split", this).call(this, index2, force);
                  this.cache = {};
                  return next;
                }
              }
            }]);
            return Block4;
          }(_parchment2.default.Block);
          Block3.blotName = "block";
          Block3.tagName = "P";
          Block3.defaultChild = "break";
          Block3.allowedChildren = [_inline2.default, _parchment2.default.Embed, _text2.default];
          function bubbleFormats(blot) {
            var formats = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (blot == null) return formats;
            if (typeof blot.formats === "function") {
              formats = (0, _extend2.default)(formats, blot.formats());
            }
            if (blot.parent == null || blot.parent.blotName == "scroll" || blot.parent.statics.scope !== blot.statics.scope) {
              return formats;
            }
            return bubbleFormats(blot.parent, formats);
          }
          exports3.bubbleFormats = bubbleFormats;
          exports3.BlockEmbed = BlockEmbed;
          exports3.default = Block3;
        },
        /* 5 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.overload = exports3.expandConfig = void 0;
          var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _slicedToArray2 = /* @__PURE__ */ function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          __webpack_require__(50);
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _editor = __webpack_require__(14);
          var _editor2 = _interopRequireDefault2(_editor);
          var _emitter3 = __webpack_require__(8);
          var _emitter4 = _interopRequireDefault2(_emitter3);
          var _module = __webpack_require__(9);
          var _module2 = _interopRequireDefault2(_module);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _selection = __webpack_require__(15);
          var _selection2 = _interopRequireDefault2(_selection);
          var _extend = __webpack_require__(3);
          var _extend2 = _interopRequireDefault2(_extend);
          var _logger = __webpack_require__(10);
          var _logger2 = _interopRequireDefault2(_logger);
          var _theme = __webpack_require__(34);
          var _theme2 = _interopRequireDefault2(_theme);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _defineProperty2(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var debug = (0, _logger2.default)("quill");
          var Quill2 = function() {
            _createClass2(Quill3, null, [{
              key: "debug",
              value: function debug2(limit) {
                if (limit === true) {
                  limit = "log";
                }
                _logger2.default.level(limit);
              }
            }, {
              key: "find",
              value: function find3(node) {
                return node.__quill || _parchment2.default.find(node);
              }
            }, {
              key: "import",
              value: function _import(name2) {
                if (this.imports[name2] == null) {
                  debug.error("Cannot import " + name2 + ". Are you sure it was registered?");
                }
                return this.imports[name2];
              }
            }, {
              key: "register",
              value: function register(path, target) {
                var _this = this;
                var overwrite = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                if (typeof path !== "string") {
                  var name2 = path.attrName || path.blotName;
                  if (typeof name2 === "string") {
                    this.register("formats/" + name2, path, target);
                  } else {
                    Object.keys(path).forEach(function(key) {
                      _this.register(key, path[key], target);
                    });
                  }
                } else {
                  if (this.imports[path] != null && !overwrite) {
                    debug.warn("Overwriting " + path + " with", target);
                  }
                  this.imports[path] = target;
                  if ((path.startsWith("blots/") || path.startsWith("formats/")) && target.blotName !== "abstract") {
                    _parchment2.default.register(target);
                  } else if (path.startsWith("modules") && typeof target.register === "function") {
                    target.register();
                  }
                }
              }
            }]);
            function Quill3(container2) {
              var _this2 = this;
              var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              _classCallCheck2(this, Quill3);
              this.options = expandConfig(container2, options);
              this.container = this.options.container;
              if (this.container == null) {
                return debug.error("Invalid Quill container", container2);
              }
              if (this.options.debug) {
                Quill3.debug(this.options.debug);
              }
              var html = this.container.innerHTML.trim();
              this.container.classList.add("ql-container");
              this.container.innerHTML = "";
              this.container.__quill = this;
              this.root = this.addContainer("ql-editor");
              this.root.classList.add("ql-blank");
              this.root.setAttribute("data-gramm", false);
              this.scrollingContainer = this.options.scrollingContainer || this.root;
              this.emitter = new _emitter4.default();
              this.scroll = _parchment2.default.create(this.root, {
                emitter: this.emitter,
                whitelist: this.options.formats
              });
              this.editor = new _editor2.default(this.scroll);
              this.selection = new _selection2.default(this.scroll, this.emitter);
              this.theme = new this.options.theme(this, this.options);
              this.keyboard = this.theme.addModule("keyboard");
              this.clipboard = this.theme.addModule("clipboard");
              this.history = this.theme.addModule("history");
              this.theme.init();
              this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function(type2) {
                if (type2 === _emitter4.default.events.TEXT_CHANGE) {
                  _this2.root.classList.toggle("ql-blank", _this2.editor.isBlank());
                }
              });
              this.emitter.on(_emitter4.default.events.SCROLL_UPDATE, function(source, mutations) {
                var range2 = _this2.selection.lastRange;
                var index2 = range2 && range2.length === 0 ? range2.index : void 0;
                modify.call(_this2, function() {
                  return _this2.editor.update(null, mutations, index2);
                }, source);
              });
              var contents = this.clipboard.convert("<div class='ql-editor' style=\"white-space: normal;\">" + html + "<p><br></p></div>");
              this.setContents(contents);
              this.history.clear();
              if (this.options.placeholder) {
                this.root.setAttribute("data-placeholder", this.options.placeholder);
              }
              if (this.options.readOnly) {
                this.disable();
              }
            }
            _createClass2(Quill3, [{
              key: "addContainer",
              value: function addContainer(container2) {
                var refNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                if (typeof container2 === "string") {
                  var className = container2;
                  container2 = document.createElement("div");
                  container2.classList.add(className);
                }
                this.container.insertBefore(container2, refNode);
                return container2;
              }
            }, {
              key: "blur",
              value: function blur() {
                this.selection.setRange(null);
              }
            }, {
              key: "deleteText",
              value: function deleteText(index2, length, source) {
                var _this3 = this;
                var _overload = overload(index2, length, source);
                var _overload2 = _slicedToArray2(_overload, 4);
                index2 = _overload2[0];
                length = _overload2[1];
                source = _overload2[3];
                return modify.call(this, function() {
                  return _this3.editor.deleteText(index2, length);
                }, source, index2, -1 * length);
              }
            }, {
              key: "disable",
              value: function disable() {
                this.enable(false);
              }
            }, {
              key: "enable",
              value: function enable() {
                var enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                this.scroll.enable(enabled);
                this.container.classList.toggle("ql-disabled", !enabled);
              }
            }, {
              key: "focus",
              value: function focus() {
                var scrollTop = this.scrollingContainer.scrollTop;
                this.selection.focus();
                this.scrollingContainer.scrollTop = scrollTop;
                this.scrollIntoView();
              }
            }, {
              key: "format",
              value: function format2(name2, value) {
                var _this4 = this;
                var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _emitter4.default.sources.API;
                return modify.call(this, function() {
                  var range2 = _this4.getSelection(true);
                  var change = new _quillDelta2.default();
                  if (range2 == null) {
                    return change;
                  } else if (_parchment2.default.query(name2, _parchment2.default.Scope.BLOCK)) {
                    change = _this4.editor.formatLine(range2.index, range2.length, _defineProperty2({}, name2, value));
                  } else if (range2.length === 0) {
                    _this4.selection.format(name2, value);
                    return change;
                  } else {
                    change = _this4.editor.formatText(range2.index, range2.length, _defineProperty2({}, name2, value));
                  }
                  _this4.setSelection(range2, _emitter4.default.sources.SILENT);
                  return change;
                }, source);
              }
            }, {
              key: "formatLine",
              value: function formatLine(index2, length, name2, value, source) {
                var _this5 = this;
                var formats = void 0;
                var _overload3 = overload(index2, length, name2, value, source);
                var _overload4 = _slicedToArray2(_overload3, 4);
                index2 = _overload4[0];
                length = _overload4[1];
                formats = _overload4[2];
                source = _overload4[3];
                return modify.call(this, function() {
                  return _this5.editor.formatLine(index2, length, formats);
                }, source, index2, 0);
              }
            }, {
              key: "formatText",
              value: function formatText(index2, length, name2, value, source) {
                var _this6 = this;
                var formats = void 0;
                var _overload5 = overload(index2, length, name2, value, source);
                var _overload6 = _slicedToArray2(_overload5, 4);
                index2 = _overload6[0];
                length = _overload6[1];
                formats = _overload6[2];
                source = _overload6[3];
                return modify.call(this, function() {
                  return _this6.editor.formatText(index2, length, formats);
                }, source, index2, 0);
              }
            }, {
              key: "getBounds",
              value: function getBounds(index2) {
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                var bounds = void 0;
                if (typeof index2 === "number") {
                  bounds = this.selection.getBounds(index2, length);
                } else {
                  bounds = this.selection.getBounds(index2.index, index2.length);
                }
                var containerBounds = this.container.getBoundingClientRect();
                return {
                  bottom: bounds.bottom - containerBounds.top,
                  height: bounds.height,
                  left: bounds.left - containerBounds.left,
                  right: bounds.right - containerBounds.left,
                  top: bounds.top - containerBounds.top,
                  width: bounds.width
                };
              }
            }, {
              key: "getContents",
              value: function getContents() {
                var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getLength() - index2;
                var _overload7 = overload(index2, length);
                var _overload8 = _slicedToArray2(_overload7, 2);
                index2 = _overload8[0];
                length = _overload8[1];
                return this.editor.getContents(index2, length);
              }
            }, {
              key: "getFormat",
              value: function getFormat2() {
                var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getSelection(true);
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                if (typeof index2 === "number") {
                  return this.editor.getFormat(index2, length);
                } else {
                  return this.editor.getFormat(index2.index, index2.length);
                }
              }
            }, {
              key: "getIndex",
              value: function getIndex(blot) {
                return blot.offset(this.scroll);
              }
            }, {
              key: "getLength",
              value: function getLength() {
                return this.scroll.length();
              }
            }, {
              key: "getLeaf",
              value: function getLeaf(index2) {
                return this.scroll.leaf(index2);
              }
            }, {
              key: "getLine",
              value: function getLine(index2) {
                return this.scroll.line(index2);
              }
            }, {
              key: "getLines",
              value: function getLines() {
                var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
                if (typeof index2 !== "number") {
                  return this.scroll.lines(index2.index, index2.length);
                } else {
                  return this.scroll.lines(index2, length);
                }
              }
            }, {
              key: "getModule",
              value: function getModule(name2) {
                return this.theme.modules[name2];
              }
            }, {
              key: "getSelection",
              value: function getSelection() {
                var focus = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                if (focus) this.focus();
                this.update();
                return this.selection.getRange()[0];
              }
            }, {
              key: "getText",
              value: function getText() {
                var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getLength() - index2;
                var _overload9 = overload(index2, length);
                var _overload10 = _slicedToArray2(_overload9, 2);
                index2 = _overload10[0];
                length = _overload10[1];
                return this.editor.getText(index2, length);
              }
            }, {
              key: "hasFocus",
              value: function hasFocus() {
                return this.selection.hasFocus();
              }
            }, {
              key: "insertEmbed",
              value: function insertEmbed(index2, embed, value) {
                var _this7 = this;
                var source = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Quill3.sources.API;
                return modify.call(this, function() {
                  return _this7.editor.insertEmbed(index2, embed, value);
                }, source, index2);
              }
            }, {
              key: "insertText",
              value: function insertText(index2, text, name2, value, source) {
                var _this8 = this;
                var formats = void 0;
                var _overload11 = overload(index2, 0, name2, value, source);
                var _overload12 = _slicedToArray2(_overload11, 4);
                index2 = _overload12[0];
                formats = _overload12[2];
                source = _overload12[3];
                return modify.call(this, function() {
                  return _this8.editor.insertText(index2, text, formats);
                }, source, index2, text.length);
              }
            }, {
              key: "isEnabled",
              value: function isEnabled() {
                return !this.container.classList.contains("ql-disabled");
              }
            }, {
              key: "off",
              value: function off() {
                return this.emitter.off.apply(this.emitter, arguments);
              }
            }, {
              key: "on",
              value: function on() {
                return this.emitter.on.apply(this.emitter, arguments);
              }
            }, {
              key: "once",
              value: function once() {
                return this.emitter.once.apply(this.emitter, arguments);
              }
            }, {
              key: "pasteHTML",
              value: function pasteHTML(index2, html, source) {
                this.clipboard.dangerouslyPasteHTML(index2, html, source);
              }
            }, {
              key: "removeFormat",
              value: function removeFormat(index2, length, source) {
                var _this9 = this;
                var _overload13 = overload(index2, length, source);
                var _overload14 = _slicedToArray2(_overload13, 4);
                index2 = _overload14[0];
                length = _overload14[1];
                source = _overload14[3];
                return modify.call(this, function() {
                  return _this9.editor.removeFormat(index2, length);
                }, source, index2);
              }
            }, {
              key: "scrollIntoView",
              value: function scrollIntoView() {
                this.selection.scrollIntoView(this.scrollingContainer);
              }
            }, {
              key: "setContents",
              value: function setContents(delta2) {
                var _this10 = this;
                var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _emitter4.default.sources.API;
                return modify.call(this, function() {
                  delta2 = new _quillDelta2.default(delta2);
                  var length = _this10.getLength();
                  var deleted = _this10.editor.deleteText(0, length);
                  var applied = _this10.editor.applyDelta(delta2);
                  var lastOp = applied.ops[applied.ops.length - 1];
                  if (lastOp != null && typeof lastOp.insert === "string" && lastOp.insert[lastOp.insert.length - 1] === "\n") {
                    _this10.editor.deleteText(_this10.getLength() - 1, 1);
                    applied.delete(1);
                  }
                  var ret = deleted.compose(applied);
                  return ret;
                }, source);
              }
            }, {
              key: "setSelection",
              value: function setSelection(index2, length, source) {
                if (index2 == null) {
                  this.selection.setRange(null, length || Quill3.sources.API);
                } else {
                  var _overload15 = overload(index2, length, source);
                  var _overload16 = _slicedToArray2(_overload15, 4);
                  index2 = _overload16[0];
                  length = _overload16[1];
                  source = _overload16[3];
                  this.selection.setRange(new _selection.Range(index2, length), source);
                  if (source !== _emitter4.default.sources.SILENT) {
                    this.selection.scrollIntoView(this.scrollingContainer);
                  }
                }
              }
            }, {
              key: "setText",
              value: function setText(text) {
                var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _emitter4.default.sources.API;
                var delta2 = new _quillDelta2.default().insert(text);
                return this.setContents(delta2, source);
              }
            }, {
              key: "update",
              value: function update8() {
                var source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _emitter4.default.sources.USER;
                var change = this.scroll.update(source);
                this.selection.update(source);
                return change;
              }
            }, {
              key: "updateContents",
              value: function updateContents(delta2) {
                var _this11 = this;
                var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _emitter4.default.sources.API;
                return modify.call(this, function() {
                  delta2 = new _quillDelta2.default(delta2);
                  return _this11.editor.applyDelta(delta2, source);
                }, source, true);
              }
            }]);
            return Quill3;
          }();
          Quill2.DEFAULTS = {
            bounds: null,
            formats: null,
            modules: {},
            placeholder: "",
            readOnly: false,
            scrollingContainer: null,
            strict: true,
            theme: "default"
          };
          Quill2.events = _emitter4.default.events;
          Quill2.sources = _emitter4.default.sources;
          Quill2.version = "1.3.7";
          Quill2.imports = {
            "delta": _quillDelta2.default,
            "parchment": _parchment2.default,
            "core/module": _module2.default,
            "core/theme": _theme2.default
          };
          function expandConfig(container2, userConfig) {
            userConfig = (0, _extend2.default)(true, {
              container: container2,
              modules: {
                clipboard: true,
                keyboard: true,
                history: true
              }
            }, userConfig);
            if (!userConfig.theme || userConfig.theme === Quill2.DEFAULTS.theme) {
              userConfig.theme = _theme2.default;
            } else {
              userConfig.theme = Quill2.import("themes/" + userConfig.theme);
              if (userConfig.theme == null) {
                throw new Error("Invalid theme " + userConfig.theme + ". Did you register it?");
              }
            }
            var themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);
            [themeConfig, userConfig].forEach(function(config2) {
              config2.modules = config2.modules || {};
              Object.keys(config2.modules).forEach(function(module4) {
                if (config2.modules[module4] === true) {
                  config2.modules[module4] = {};
                }
              });
            });
            var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));
            var moduleConfig = moduleNames.reduce(function(config2, name2) {
              var moduleClass = Quill2.import("modules/" + name2);
              if (moduleClass == null) {
                debug.error("Cannot load " + name2 + " module. Are you sure you registered it?");
              } else {
                config2[name2] = moduleClass.DEFAULTS || {};
              }
              return config2;
            }, {});
            if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {
              userConfig.modules.toolbar = {
                container: userConfig.modules.toolbar
              };
            }
            userConfig = (0, _extend2.default)(true, {}, Quill2.DEFAULTS, { modules: moduleConfig }, themeConfig, userConfig);
            ["bounds", "container", "scrollingContainer"].forEach(function(key) {
              if (typeof userConfig[key] === "string") {
                userConfig[key] = document.querySelector(userConfig[key]);
              }
            });
            userConfig.modules = Object.keys(userConfig.modules).reduce(function(config2, name2) {
              if (userConfig.modules[name2]) {
                config2[name2] = userConfig.modules[name2];
              }
              return config2;
            }, {});
            return userConfig;
          }
          function modify(modifier, source, index2, shift) {
            if (this.options.strict && !this.isEnabled() && source === _emitter4.default.sources.USER) {
              return new _quillDelta2.default();
            }
            var range2 = index2 == null ? null : this.getSelection();
            var oldDelta = this.editor.delta;
            var change = modifier();
            if (range2 != null) {
              if (index2 === true) index2 = range2.index;
              if (shift == null) {
                range2 = shiftRange(range2, change, source);
              } else if (shift !== 0) {
                range2 = shiftRange(range2, index2, shift, source);
              }
              this.setSelection(range2, _emitter4.default.sources.SILENT);
            }
            if (change.length() > 0) {
              var _emitter;
              var args = [_emitter4.default.events.TEXT_CHANGE, change, oldDelta, source];
              (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
              if (source !== _emitter4.default.sources.SILENT) {
                var _emitter2;
                (_emitter2 = this.emitter).emit.apply(_emitter2, args);
              }
            }
            return change;
          }
          function overload(index2, length, name2, value, source) {
            var formats = {};
            if (typeof index2.index === "number" && typeof index2.length === "number") {
              if (typeof length !== "number") {
                source = value, value = name2, name2 = length, length = index2.length, index2 = index2.index;
              } else {
                length = index2.length, index2 = index2.index;
              }
            } else if (typeof length !== "number") {
              source = value, value = name2, name2 = length, length = 0;
            }
            if ((typeof name2 === "undefined" ? "undefined" : _typeof2(name2)) === "object") {
              formats = name2;
              source = value;
            } else if (typeof name2 === "string") {
              if (value != null) {
                formats[name2] = value;
              } else {
                source = name2;
              }
            }
            source = source || _emitter4.default.sources.API;
            return [index2, length, formats, source];
          }
          function shiftRange(range2, index2, length, source) {
            if (range2 == null) return null;
            var start = void 0, end = void 0;
            if (index2 instanceof _quillDelta2.default) {
              var _map = [range2.index, range2.index + range2.length].map(function(pos) {
                return index2.transformPosition(pos, source !== _emitter4.default.sources.USER);
              });
              var _map22 = _slicedToArray2(_map, 2);
              start = _map22[0];
              end = _map22[1];
            } else {
              var _map32 = [range2.index, range2.index + range2.length].map(function(pos) {
                if (pos < index2 || pos === index2 && source === _emitter4.default.sources.USER) return pos;
                if (length >= 0) {
                  return pos + length;
                } else {
                  return Math.max(index2, pos + length);
                }
              });
              var _map4 = _slicedToArray2(_map32, 2);
              start = _map4[0];
              end = _map4[1];
            }
            return new _selection.Range(start, end - start);
          }
          exports3.expandConfig = expandConfig;
          exports3.overload = overload;
          exports3.default = Quill2;
        },
        /* 6 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _text = __webpack_require__(7);
          var _text2 = _interopRequireDefault2(_text);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Inline = function(_Parchment$Inline) {
            _inherits2(Inline2, _Parchment$Inline);
            function Inline2() {
              _classCallCheck2(this, Inline2);
              return _possibleConstructorReturn2(this, (Inline2.__proto__ || Object.getPrototypeOf(Inline2)).apply(this, arguments));
            }
            _createClass2(Inline2, [{
              key: "formatAt",
              value: function formatAt(index2, length, name2, value) {
                if (Inline2.compare(this.statics.blotName, name2) < 0 && _parchment2.default.query(name2, _parchment2.default.Scope.BLOT)) {
                  var blot = this.isolate(index2, length);
                  if (value) {
                    blot.wrap(name2, value);
                  }
                } else {
                  _get2(Inline2.prototype.__proto__ || Object.getPrototypeOf(Inline2.prototype), "formatAt", this).call(this, index2, length, name2, value);
                }
              }
            }, {
              key: "optimize",
              value: function optimize(context2) {
                _get2(Inline2.prototype.__proto__ || Object.getPrototypeOf(Inline2.prototype), "optimize", this).call(this, context2);
                if (this.parent instanceof Inline2 && Inline2.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
                  var parent2 = this.parent.isolate(this.offset(), this.length());
                  this.moveChildren(parent2);
                  parent2.wrap(this);
                }
              }
            }], [{
              key: "compare",
              value: function compare(self2, other) {
                var selfIndex = Inline2.order.indexOf(self2);
                var otherIndex = Inline2.order.indexOf(other);
                if (selfIndex >= 0 || otherIndex >= 0) {
                  return selfIndex - otherIndex;
                } else if (self2 === other) {
                  return 0;
                } else if (self2 < other) {
                  return -1;
                } else {
                  return 1;
                }
              }
            }]);
            return Inline2;
          }(_parchment2.default.Inline);
          Inline.allowedChildren = [Inline, _parchment2.default.Embed, _text2.default];
          Inline.order = [
            "cursor",
            "inline",
            // Must be lower
            "underline",
            "strike",
            "italic",
            "bold",
            "script",
            "link",
            "code"
            // Must be higher
          ];
          exports3.default = Inline;
        },
        /* 7 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var TextBlot = function(_Parchment$Text) {
            _inherits2(TextBlot2, _Parchment$Text);
            function TextBlot2() {
              _classCallCheck2(this, TextBlot2);
              return _possibleConstructorReturn2(this, (TextBlot2.__proto__ || Object.getPrototypeOf(TextBlot2)).apply(this, arguments));
            }
            return TextBlot2;
          }(_parchment2.default.Text);
          exports3.default = TextBlot;
        },
        /* 8 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _eventemitter = __webpack_require__(54);
          var _eventemitter2 = _interopRequireDefault2(_eventemitter);
          var _logger = __webpack_require__(10);
          var _logger2 = _interopRequireDefault2(_logger);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var debug = (0, _logger2.default)("quill:events");
          var EVENTS = ["selectionchange", "mousedown", "mouseup", "click"];
          EVENTS.forEach(function(eventName) {
            document.addEventListener(eventName, function() {
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              [].slice.call(document.querySelectorAll(".ql-container")).forEach(function(node) {
                if (node.__quill && node.__quill.emitter) {
                  var _node$__quill$emitter;
                  (_node$__quill$emitter = node.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);
                }
              });
            });
          });
          var Emitter = function(_EventEmitter) {
            _inherits2(Emitter2, _EventEmitter);
            function Emitter2() {
              _classCallCheck2(this, Emitter2);
              var _this = _possibleConstructorReturn2(this, (Emitter2.__proto__ || Object.getPrototypeOf(Emitter2)).call(this));
              _this.listeners = {};
              _this.on("error", debug.error);
              return _this;
            }
            _createClass2(Emitter2, [{
              key: "emit",
              value: function emit() {
                debug.log.apply(debug, arguments);
                _get2(Emitter2.prototype.__proto__ || Object.getPrototypeOf(Emitter2.prototype), "emit", this).apply(this, arguments);
              }
            }, {
              key: "handleDOM",
              value: function handleDOM(event) {
                for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                (this.listeners[event.type] || []).forEach(function(_ref) {
                  var node = _ref.node, handler = _ref.handler;
                  if (event.target === node || node.contains(event.target)) {
                    handler.apply(void 0, [event].concat(args));
                  }
                });
              }
            }, {
              key: "listenDOM",
              value: function listenDOM(eventName, node, handler) {
                if (!this.listeners[eventName]) {
                  this.listeners[eventName] = [];
                }
                this.listeners[eventName].push({ node, handler });
              }
            }]);
            return Emitter2;
          }(_eventemitter2.default);
          Emitter.events = {
            EDITOR_CHANGE: "editor-change",
            SCROLL_BEFORE_UPDATE: "scroll-before-update",
            SCROLL_OPTIMIZE: "scroll-optimize",
            SCROLL_UPDATE: "scroll-update",
            SELECTION_CHANGE: "selection-change",
            TEXT_CHANGE: "text-change"
          };
          Emitter.sources = {
            API: "api",
            SILENT: "silent",
            USER: "user"
          };
          exports3.default = Emitter;
        },
        /* 9 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var Module = function Module2(quill2) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            _classCallCheck2(this, Module2);
            this.quill = quill2;
            this.options = options;
          };
          Module.DEFAULTS = {};
          exports3.default = Module;
        },
        /* 10 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var levels = ["error", "warn", "log", "info"];
          var level = "warn";
          function debug(method) {
            if (levels.indexOf(method) <= levels.indexOf(level)) {
              var _console;
              for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              (_console = console)[method].apply(_console, args);
            }
          }
          function namespace(ns) {
            return levels.reduce(function(logger2, method) {
              logger2[method] = debug.bind(console, method, ns);
              return logger2;
            }, {});
          }
          debug.level = namespace.level = function(newLevel) {
            level = newLevel;
          };
          exports3.default = namespace;
        },
        /* 11 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var pSlice = Array.prototype.slice;
          var objectKeys2 = __webpack_require__(52);
          var isArguments5 = __webpack_require__(53);
          var deepEqual3 = module3.exports = function(actual, expected, opts) {
            if (!opts) opts = {};
            if (actual === expected) {
              return true;
            } else if (actual instanceof Date && expected instanceof Date) {
              return actual.getTime() === expected.getTime();
            } else if (!actual || !expected || typeof actual != "object" && typeof expected != "object") {
              return opts.strict ? actual === expected : actual == expected;
            } else {
              return objEquiv2(actual, expected, opts);
            }
          };
          function isUndefinedOrNull2(value) {
            return value === null || value === void 0;
          }
          function isBuffer2(x) {
            if (!x || typeof x !== "object" || typeof x.length !== "number") return false;
            if (typeof x.copy !== "function" || typeof x.slice !== "function") {
              return false;
            }
            if (x.length > 0 && typeof x[0] !== "number") return false;
            return true;
          }
          function objEquiv2(a2, b, opts) {
            var i2, key;
            if (isUndefinedOrNull2(a2) || isUndefinedOrNull2(b))
              return false;
            if (a2.prototype !== b.prototype) return false;
            if (isArguments5(a2)) {
              if (!isArguments5(b)) {
                return false;
              }
              a2 = pSlice.call(a2);
              b = pSlice.call(b);
              return deepEqual3(a2, b, opts);
            }
            if (isBuffer2(a2)) {
              if (!isBuffer2(b)) {
                return false;
              }
              if (a2.length !== b.length) return false;
              for (i2 = 0; i2 < a2.length; i2++) {
                if (a2[i2] !== b[i2]) return false;
              }
              return true;
            }
            try {
              var ka = objectKeys2(a2), kb = objectKeys2(b);
            } catch (e2) {
              return false;
            }
            if (ka.length != kb.length)
              return false;
            ka.sort();
            kb.sort();
            for (i2 = ka.length - 1; i2 >= 0; i2--) {
              if (ka[i2] != kb[i2])
                return false;
            }
            for (i2 = ka.length - 1; i2 >= 0; i2--) {
              key = ka[i2];
              if (!deepEqual3(a2[key], b[key], opts)) return false;
            }
            return typeof a2 === typeof b;
          }
        },
        /* 12 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var Registry = __webpack_require__(1);
          var Attributor = (
            /** @class */
            function() {
              function Attributor2(attrName, keyName, options) {
                if (options === void 0) {
                  options = {};
                }
                this.attrName = attrName;
                this.keyName = keyName;
                var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;
                if (options.scope != null) {
                  this.scope = options.scope & Registry.Scope.LEVEL | attributeBit;
                } else {
                  this.scope = Registry.Scope.ATTRIBUTE;
                }
                if (options.whitelist != null)
                  this.whitelist = options.whitelist;
              }
              Attributor2.keys = function(node) {
                return [].map.call(node.attributes, function(item) {
                  return item.name;
                });
              };
              Attributor2.prototype.add = function(node, value) {
                if (!this.canAdd(node, value))
                  return false;
                node.setAttribute(this.keyName, value);
                return true;
              };
              Attributor2.prototype.canAdd = function(node, value) {
                var match = Registry.query(node, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));
                if (match == null)
                  return false;
                if (this.whitelist == null)
                  return true;
                if (typeof value === "string") {
                  return this.whitelist.indexOf(value.replace(/["']/g, "")) > -1;
                } else {
                  return this.whitelist.indexOf(value) > -1;
                }
              };
              Attributor2.prototype.remove = function(node) {
                node.removeAttribute(this.keyName);
              };
              Attributor2.prototype.value = function(node) {
                var value = node.getAttribute(this.keyName);
                if (this.canAdd(node, value) && value) {
                  return value;
                }
                return "";
              };
              return Attributor2;
            }()
          );
          exports3.default = Attributor;
        },
        /* 13 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.Code = void 0;
          var _slicedToArray2 = /* @__PURE__ */ function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          var _text = __webpack_require__(7);
          var _text2 = _interopRequireDefault2(_text);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Code = function(_Inline) {
            _inherits2(Code2, _Inline);
            function Code2() {
              _classCallCheck2(this, Code2);
              return _possibleConstructorReturn2(this, (Code2.__proto__ || Object.getPrototypeOf(Code2)).apply(this, arguments));
            }
            return Code2;
          }(_inline2.default);
          Code.blotName = "code";
          Code.tagName = "CODE";
          var CodeBlock = function(_Block) {
            _inherits2(CodeBlock2, _Block);
            function CodeBlock2() {
              _classCallCheck2(this, CodeBlock2);
              return _possibleConstructorReturn2(this, (CodeBlock2.__proto__ || Object.getPrototypeOf(CodeBlock2)).apply(this, arguments));
            }
            _createClass2(CodeBlock2, [{
              key: "delta",
              value: function delta2() {
                var _this3 = this;
                var text = this.domNode.textContent;
                if (text.endsWith("\n")) {
                  text = text.slice(0, -1);
                }
                return text.split("\n").reduce(function(delta3, frag) {
                  return delta3.insert(frag).insert("\n", _this3.formats());
                }, new _quillDelta2.default());
              }
            }, {
              key: "format",
              value: function format2(name2, value) {
                if (name2 === this.statics.blotName && value) return;
                var _descendant = this.descendant(_text2.default, this.length() - 1), _descendant2 = _slicedToArray2(_descendant, 1), text = _descendant2[0];
                if (text != null) {
                  text.deleteAt(text.length() - 1, 1);
                }
                _get2(CodeBlock2.prototype.__proto__ || Object.getPrototypeOf(CodeBlock2.prototype), "format", this).call(this, name2, value);
              }
            }, {
              key: "formatAt",
              value: function formatAt(index2, length, name2, value) {
                if (length === 0) return;
                if (_parchment2.default.query(name2, _parchment2.default.Scope.BLOCK) == null || name2 === this.statics.blotName && value === this.statics.formats(this.domNode)) {
                  return;
                }
                var nextNewline = this.newlineIndex(index2);
                if (nextNewline < 0 || nextNewline >= index2 + length) return;
                var prevNewline = this.newlineIndex(index2, true) + 1;
                var isolateLength = nextNewline - prevNewline + 1;
                var blot = this.isolate(prevNewline, isolateLength);
                var next = blot.next;
                blot.format(name2, value);
                if (next instanceof CodeBlock2) {
                  next.formatAt(0, index2 - prevNewline + length - isolateLength, name2, value);
                }
              }
            }, {
              key: "insertAt",
              value: function insertAt(index2, value, def) {
                if (def != null) return;
                var _descendant3 = this.descendant(_text2.default, index2), _descendant4 = _slicedToArray2(_descendant3, 2), text = _descendant4[0], offset2 = _descendant4[1];
                text.insertAt(offset2, value);
              }
            }, {
              key: "length",
              value: function length() {
                var length2 = this.domNode.textContent.length;
                if (!this.domNode.textContent.endsWith("\n")) {
                  return length2 + 1;
                }
                return length2;
              }
            }, {
              key: "newlineIndex",
              value: function newlineIndex(searchIndex) {
                var reverse3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (!reverse3) {
                  var offset2 = this.domNode.textContent.slice(searchIndex).indexOf("\n");
                  return offset2 > -1 ? searchIndex + offset2 : -1;
                } else {
                  return this.domNode.textContent.slice(0, searchIndex).lastIndexOf("\n");
                }
              }
            }, {
              key: "optimize",
              value: function optimize(context2) {
                if (!this.domNode.textContent.endsWith("\n")) {
                  this.appendChild(_parchment2.default.create("text", "\n"));
                }
                _get2(CodeBlock2.prototype.__proto__ || Object.getPrototypeOf(CodeBlock2.prototype), "optimize", this).call(this, context2);
                var next = this.next;
                if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {
                  next.optimize(context2);
                  next.moveChildren(this);
                  next.remove();
                }
              }
            }, {
              key: "replace",
              value: function replace(target) {
                _get2(CodeBlock2.prototype.__proto__ || Object.getPrototypeOf(CodeBlock2.prototype), "replace", this).call(this, target);
                [].slice.call(this.domNode.querySelectorAll("*")).forEach(function(node) {
                  var blot = _parchment2.default.find(node);
                  if (blot == null) {
                    node.parentNode.removeChild(node);
                  } else if (blot instanceof _parchment2.default.Embed) {
                    blot.remove();
                  } else {
                    blot.unwrap();
                  }
                });
              }
            }], [{
              key: "create",
              value: function create(value) {
                var domNode = _get2(CodeBlock2.__proto__ || Object.getPrototypeOf(CodeBlock2), "create", this).call(this, value);
                domNode.setAttribute("spellcheck", false);
                return domNode;
              }
            }, {
              key: "formats",
              value: function formats() {
                return true;
              }
            }]);
            return CodeBlock2;
          }(_block2.default);
          CodeBlock.blotName = "code-block";
          CodeBlock.tagName = "PRE";
          CodeBlock.TAB = "  ";
          exports3.Code = Code;
          exports3.default = CodeBlock;
        },
        /* 14 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _slicedToArray2 = /* @__PURE__ */ function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _op = __webpack_require__(20);
          var _op2 = _interopRequireDefault2(_op);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _code = __webpack_require__(13);
          var _code2 = _interopRequireDefault2(_code);
          var _cursor = __webpack_require__(24);
          var _cursor2 = _interopRequireDefault2(_cursor);
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          var _break = __webpack_require__(16);
          var _break2 = _interopRequireDefault2(_break);
          var _clone = __webpack_require__(21);
          var _clone2 = _interopRequireDefault2(_clone);
          var _deepEqual = __webpack_require__(11);
          var _deepEqual2 = _interopRequireDefault2(_deepEqual);
          var _extend = __webpack_require__(3);
          var _extend2 = _interopRequireDefault2(_extend);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _defineProperty2(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var ASCII = /^[ -~]*$/;
          var Editor = function() {
            function Editor2(scroll) {
              _classCallCheck2(this, Editor2);
              this.scroll = scroll;
              this.delta = this.getDelta();
            }
            _createClass2(Editor2, [{
              key: "applyDelta",
              value: function applyDelta(delta2) {
                var _this = this;
                var consumeNextNewline = false;
                this.scroll.update();
                var scrollLength = this.scroll.length();
                this.scroll.batchStart();
                delta2 = normalizeDelta(delta2);
                delta2.reduce(function(index2, op2) {
                  var length = op2.retain || op2.delete || op2.insert.length || 1;
                  var attributes = op2.attributes || {};
                  if (op2.insert != null) {
                    if (typeof op2.insert === "string") {
                      var text = op2.insert;
                      if (text.endsWith("\n") && consumeNextNewline) {
                        consumeNextNewline = false;
                        text = text.slice(0, -1);
                      }
                      if (index2 >= scrollLength && !text.endsWith("\n")) {
                        consumeNextNewline = true;
                      }
                      _this.scroll.insertAt(index2, text);
                      var _scroll$line = _this.scroll.line(index2), _scroll$line2 = _slicedToArray2(_scroll$line, 2), line = _scroll$line2[0], offset2 = _scroll$line2[1];
                      var formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));
                      if (line instanceof _block2.default) {
                        var _line$descendant = line.descendant(_parchment2.default.Leaf, offset2), _line$descendant2 = _slicedToArray2(_line$descendant, 1), leaf = _line$descendant2[0];
                        formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));
                      }
                      attributes = _op2.default.attributes.diff(formats, attributes) || {};
                    } else if (_typeof2(op2.insert) === "object") {
                      var key = Object.keys(op2.insert)[0];
                      if (key == null) return index2;
                      _this.scroll.insertAt(index2, key, op2.insert[key]);
                    }
                    scrollLength += length;
                  }
                  Object.keys(attributes).forEach(function(name2) {
                    _this.scroll.formatAt(index2, length, name2, attributes[name2]);
                  });
                  return index2 + length;
                }, 0);
                delta2.reduce(function(index2, op2) {
                  if (typeof op2.delete === "number") {
                    _this.scroll.deleteAt(index2, op2.delete);
                    return index2;
                  }
                  return index2 + (op2.retain || op2.insert.length || 1);
                }, 0);
                this.scroll.batchEnd();
                return this.update(delta2);
              }
            }, {
              key: "deleteText",
              value: function deleteText(index2, length) {
                this.scroll.deleteAt(index2, length);
                return this.update(new _quillDelta2.default().retain(index2).delete(length));
              }
            }, {
              key: "formatLine",
              value: function formatLine(index2, length) {
                var _this2 = this;
                var formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                this.scroll.update();
                Object.keys(formats).forEach(function(format2) {
                  if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format2]) return;
                  var lines = _this2.scroll.lines(index2, Math.max(length, 1));
                  var lengthRemaining = length;
                  lines.forEach(function(line) {
                    var lineLength = line.length();
                    if (!(line instanceof _code2.default)) {
                      line.format(format2, formats[format2]);
                    } else {
                      var codeIndex = index2 - line.offset(_this2.scroll);
                      var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;
                      line.formatAt(codeIndex, codeLength, format2, formats[format2]);
                    }
                    lengthRemaining -= lineLength;
                  });
                });
                this.scroll.optimize();
                return this.update(new _quillDelta2.default().retain(index2).retain(length, (0, _clone2.default)(formats)));
              }
            }, {
              key: "formatText",
              value: function formatText(index2, length) {
                var _this3 = this;
                var formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                Object.keys(formats).forEach(function(format2) {
                  _this3.scroll.formatAt(index2, length, format2, formats[format2]);
                });
                return this.update(new _quillDelta2.default().retain(index2).retain(length, (0, _clone2.default)(formats)));
              }
            }, {
              key: "getContents",
              value: function getContents(index2, length) {
                return this.delta.slice(index2, index2 + length);
              }
            }, {
              key: "getDelta",
              value: function getDelta() {
                return this.scroll.lines().reduce(function(delta2, line) {
                  return delta2.concat(line.delta());
                }, new _quillDelta2.default());
              }
            }, {
              key: "getFormat",
              value: function getFormat2(index2) {
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                var lines = [], leaves = [];
                if (length === 0) {
                  this.scroll.path(index2).forEach(function(path) {
                    var _path = _slicedToArray2(path, 1), blot = _path[0];
                    if (blot instanceof _block2.default) {
                      lines.push(blot);
                    } else if (blot instanceof _parchment2.default.Leaf) {
                      leaves.push(blot);
                    }
                  });
                } else {
                  lines = this.scroll.lines(index2, length);
                  leaves = this.scroll.descendants(_parchment2.default.Leaf, index2, length);
                }
                var formatsArr = [lines, leaves].map(function(blots) {
                  if (blots.length === 0) return {};
                  var formats = (0, _block.bubbleFormats)(blots.shift());
                  while (Object.keys(formats).length > 0) {
                    var blot = blots.shift();
                    if (blot == null) return formats;
                    formats = combineFormats((0, _block.bubbleFormats)(blot), formats);
                  }
                  return formats;
                });
                return _extend2.default.apply(_extend2.default, formatsArr);
              }
            }, {
              key: "getText",
              value: function getText(index2, length) {
                return this.getContents(index2, length).filter(function(op2) {
                  return typeof op2.insert === "string";
                }).map(function(op2) {
                  return op2.insert;
                }).join("");
              }
            }, {
              key: "insertEmbed",
              value: function insertEmbed(index2, embed, value) {
                this.scroll.insertAt(index2, embed, value);
                return this.update(new _quillDelta2.default().retain(index2).insert(_defineProperty2({}, embed, value)));
              }
            }, {
              key: "insertText",
              value: function insertText(index2, text) {
                var _this4 = this;
                var formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                this.scroll.insertAt(index2, text);
                Object.keys(formats).forEach(function(format2) {
                  _this4.scroll.formatAt(index2, text.length, format2, formats[format2]);
                });
                return this.update(new _quillDelta2.default().retain(index2).insert(text, (0, _clone2.default)(formats)));
              }
            }, {
              key: "isBlank",
              value: function isBlank() {
                if (this.scroll.children.length == 0) return true;
                if (this.scroll.children.length > 1) return false;
                var block = this.scroll.children.head;
                if (block.statics.blotName !== _block2.default.blotName) return false;
                if (block.children.length > 1) return false;
                return block.children.head instanceof _break2.default;
              }
            }, {
              key: "removeFormat",
              value: function removeFormat(index2, length) {
                var text = this.getText(index2, length);
                var _scroll$line3 = this.scroll.line(index2 + length), _scroll$line4 = _slicedToArray2(_scroll$line3, 2), line = _scroll$line4[0], offset2 = _scroll$line4[1];
                var suffixLength = 0, suffix = new _quillDelta2.default();
                if (line != null) {
                  if (!(line instanceof _code2.default)) {
                    suffixLength = line.length() - offset2;
                  } else {
                    suffixLength = line.newlineIndex(offset2) - offset2 + 1;
                  }
                  suffix = line.delta().slice(offset2, offset2 + suffixLength - 1).insert("\n");
                }
                var contents = this.getContents(index2, length + suffixLength);
                var diff2 = contents.diff(new _quillDelta2.default().insert(text).concat(suffix));
                var delta2 = new _quillDelta2.default().retain(index2).concat(diff2);
                return this.applyDelta(delta2);
              }
            }, {
              key: "update",
              value: function update8(change) {
                var mutations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                var cursorIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
                var oldDelta = this.delta;
                if (mutations.length === 1 && mutations[0].type === "characterData" && mutations[0].target.data.match(ASCII) && _parchment2.default.find(mutations[0].target)) {
                  var textBlot = _parchment2.default.find(mutations[0].target);
                  var formats = (0, _block.bubbleFormats)(textBlot);
                  var index2 = textBlot.offset(this.scroll);
                  var oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, "");
                  var oldText = new _quillDelta2.default().insert(oldValue);
                  var newText = new _quillDelta2.default().insert(textBlot.value());
                  var diffDelta = new _quillDelta2.default().retain(index2).concat(oldText.diff(newText, cursorIndex));
                  change = diffDelta.reduce(function(delta2, op2) {
                    if (op2.insert) {
                      return delta2.insert(op2.insert, formats);
                    } else {
                      return delta2.push(op2);
                    }
                  }, new _quillDelta2.default());
                  this.delta = oldDelta.compose(change);
                } else {
                  this.delta = this.getDelta();
                  if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {
                    change = oldDelta.diff(this.delta, cursorIndex);
                  }
                }
                return change;
              }
            }]);
            return Editor2;
          }();
          function combineFormats(formats, combined) {
            return Object.keys(combined).reduce(function(merged, name2) {
              if (formats[name2] == null) return merged;
              if (combined[name2] === formats[name2]) {
                merged[name2] = combined[name2];
              } else if (Array.isArray(combined[name2])) {
                if (combined[name2].indexOf(formats[name2]) < 0) {
                  merged[name2] = combined[name2].concat([formats[name2]]);
                }
              } else {
                merged[name2] = [combined[name2], formats[name2]];
              }
              return merged;
            }, {});
          }
          function normalizeDelta(delta2) {
            return delta2.reduce(function(delta3, op2) {
              if (op2.insert === 1) {
                var attributes = (0, _clone2.default)(op2.attributes);
                delete attributes["image"];
                return delta3.insert({ image: op2.attributes.image }, attributes);
              }
              if (op2.attributes != null && (op2.attributes.list === true || op2.attributes.bullet === true)) {
                op2 = (0, _clone2.default)(op2);
                if (op2.attributes.list) {
                  op2.attributes.list = "ordered";
                } else {
                  op2.attributes.list = "bullet";
                  delete op2.attributes.bullet;
                }
              }
              if (typeof op2.insert === "string") {
                var text = op2.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                return delta3.insert(text, op2.attributes);
              }
              return delta3.push(op2);
            }, new _quillDelta2.default());
          }
          exports3.default = Editor;
        },
        /* 15 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.Range = void 0;
          var _slicedToArray2 = /* @__PURE__ */ function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _clone = __webpack_require__(21);
          var _clone2 = _interopRequireDefault2(_clone);
          var _deepEqual = __webpack_require__(11);
          var _deepEqual2 = _interopRequireDefault2(_deepEqual);
          var _emitter3 = __webpack_require__(8);
          var _emitter4 = _interopRequireDefault2(_emitter3);
          var _logger = __webpack_require__(10);
          var _logger2 = _interopRequireDefault2(_logger);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _toConsumableArray2(arr) {
            if (Array.isArray(arr)) {
              for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
                arr2[i2] = arr[i2];
              }
              return arr2;
            } else {
              return Array.from(arr);
            }
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var debug = (0, _logger2.default)("quill:selection");
          var Range2 = function Range3(index2) {
            var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            _classCallCheck2(this, Range3);
            this.index = index2;
            this.length = length;
          };
          var Selection = function() {
            function Selection2(scroll, emitter) {
              var _this = this;
              _classCallCheck2(this, Selection2);
              this.emitter = emitter;
              this.scroll = scroll;
              this.composing = false;
              this.mouseDown = false;
              this.root = this.scroll.domNode;
              this.cursor = _parchment2.default.create("cursor", this);
              this.lastRange = this.savedRange = new Range2(0, 0);
              this.handleComposition();
              this.handleDragging();
              this.emitter.listenDOM("selectionchange", document, function() {
                if (!_this.mouseDown) {
                  setTimeout(_this.update.bind(_this, _emitter4.default.sources.USER), 1);
                }
              });
              this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function(type2, delta2) {
                if (type2 === _emitter4.default.events.TEXT_CHANGE && delta2.length() > 0) {
                  _this.update(_emitter4.default.sources.SILENT);
                }
              });
              this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE, function() {
                if (!_this.hasFocus()) return;
                var native = _this.getNativeRange();
                if (native == null) return;
                if (native.start.node === _this.cursor.textNode) return;
                _this.emitter.once(_emitter4.default.events.SCROLL_UPDATE, function() {
                  try {
                    _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);
                  } catch (ignored) {
                  }
                });
              });
              this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE, function(mutations, context2) {
                if (context2.range) {
                  var _context$range = context2.range, startNode = _context$range.startNode, startOffset = _context$range.startOffset, endNode = _context$range.endNode, endOffset = _context$range.endOffset;
                  _this.setNativeRange(startNode, startOffset, endNode, endOffset);
                }
              });
              this.update(_emitter4.default.sources.SILENT);
            }
            _createClass2(Selection2, [{
              key: "handleComposition",
              value: function handleComposition() {
                var _this2 = this;
                this.root.addEventListener("compositionstart", function() {
                  _this2.composing = true;
                });
                this.root.addEventListener("compositionend", function() {
                  _this2.composing = false;
                  if (_this2.cursor.parent) {
                    var range2 = _this2.cursor.restore();
                    if (!range2) return;
                    setTimeout(function() {
                      _this2.setNativeRange(range2.startNode, range2.startOffset, range2.endNode, range2.endOffset);
                    }, 1);
                  }
                });
              }
            }, {
              key: "handleDragging",
              value: function handleDragging() {
                var _this3 = this;
                this.emitter.listenDOM("mousedown", document.body, function() {
                  _this3.mouseDown = true;
                });
                this.emitter.listenDOM("mouseup", document.body, function() {
                  _this3.mouseDown = false;
                  _this3.update(_emitter4.default.sources.USER);
                });
              }
            }, {
              key: "focus",
              value: function focus() {
                if (this.hasFocus()) return;
                this.root.focus();
                this.setRange(this.savedRange);
              }
            }, {
              key: "format",
              value: function format2(_format, value) {
                if (this.scroll.whitelist != null && !this.scroll.whitelist[_format]) return;
                this.scroll.update();
                var nativeRange = this.getNativeRange();
                if (nativeRange == null || !nativeRange.native.collapsed || _parchment2.default.query(_format, _parchment2.default.Scope.BLOCK)) return;
                if (nativeRange.start.node !== this.cursor.textNode) {
                  var blot = _parchment2.default.find(nativeRange.start.node, false);
                  if (blot == null) return;
                  if (blot instanceof _parchment2.default.Leaf) {
                    var after = blot.split(nativeRange.start.offset);
                    blot.parent.insertBefore(this.cursor, after);
                  } else {
                    blot.insertBefore(this.cursor, nativeRange.start.node);
                  }
                  this.cursor.attach();
                }
                this.cursor.format(_format, value);
                this.scroll.optimize();
                this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
                this.update();
              }
            }, {
              key: "getBounds",
              value: function getBounds(index2) {
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                var scrollLength = this.scroll.length();
                index2 = Math.min(index2, scrollLength - 1);
                length = Math.min(index2 + length, scrollLength - 1) - index2;
                var node = void 0, _scroll$leaf = this.scroll.leaf(index2), _scroll$leaf2 = _slicedToArray2(_scroll$leaf, 2), leaf = _scroll$leaf2[0], offset2 = _scroll$leaf2[1];
                if (leaf == null) return null;
                var _leaf$position = leaf.position(offset2, true);
                var _leaf$position2 = _slicedToArray2(_leaf$position, 2);
                node = _leaf$position2[0];
                offset2 = _leaf$position2[1];
                var range2 = document.createRange();
                if (length > 0) {
                  range2.setStart(node, offset2);
                  var _scroll$leaf3 = this.scroll.leaf(index2 + length);
                  var _scroll$leaf4 = _slicedToArray2(_scroll$leaf3, 2);
                  leaf = _scroll$leaf4[0];
                  offset2 = _scroll$leaf4[1];
                  if (leaf == null) return null;
                  var _leaf$position3 = leaf.position(offset2, true);
                  var _leaf$position4 = _slicedToArray2(_leaf$position3, 2);
                  node = _leaf$position4[0];
                  offset2 = _leaf$position4[1];
                  range2.setEnd(node, offset2);
                  return range2.getBoundingClientRect();
                } else {
                  var side = "left";
                  var rect = void 0;
                  if (node instanceof Text) {
                    if (offset2 < node.data.length) {
                      range2.setStart(node, offset2);
                      range2.setEnd(node, offset2 + 1);
                    } else {
                      range2.setStart(node, offset2 - 1);
                      range2.setEnd(node, offset2);
                      side = "right";
                    }
                    rect = range2.getBoundingClientRect();
                  } else {
                    rect = leaf.domNode.getBoundingClientRect();
                    if (offset2 > 0) side = "right";
                  }
                  return {
                    bottom: rect.top + rect.height,
                    height: rect.height,
                    left: rect[side],
                    right: rect[side],
                    top: rect.top,
                    width: 0
                  };
                }
              }
            }, {
              key: "getNativeRange",
              value: function getNativeRange() {
                var selection = document.getSelection();
                if (selection == null || selection.rangeCount <= 0) return null;
                var nativeRange = selection.getRangeAt(0);
                if (nativeRange == null) return null;
                var range2 = this.normalizeNative(nativeRange);
                debug.info("getNativeRange", range2);
                return range2;
              }
            }, {
              key: "getRange",
              value: function getRange() {
                var normalized = this.getNativeRange();
                if (normalized == null) return [null, null];
                var range2 = this.normalizedToRange(normalized);
                return [range2, normalized];
              }
            }, {
              key: "hasFocus",
              value: function hasFocus() {
                return document.activeElement === this.root;
              }
            }, {
              key: "normalizedToRange",
              value: function normalizedToRange(range2) {
                var _this4 = this;
                var positions = [[range2.start.node, range2.start.offset]];
                if (!range2.native.collapsed) {
                  positions.push([range2.end.node, range2.end.offset]);
                }
                var indexes = positions.map(function(position) {
                  var _position = _slicedToArray2(position, 2), node = _position[0], offset2 = _position[1];
                  var blot = _parchment2.default.find(node, true);
                  var index2 = blot.offset(_this4.scroll);
                  if (offset2 === 0) {
                    return index2;
                  } else if (blot instanceof _parchment2.default.Container) {
                    return index2 + blot.length();
                  } else {
                    return index2 + blot.index(node, offset2);
                  }
                });
                var end = Math.min(Math.max.apply(Math, _toConsumableArray2(indexes)), this.scroll.length() - 1);
                var start = Math.min.apply(Math, [end].concat(_toConsumableArray2(indexes)));
                return new Range2(start, end - start);
              }
            }, {
              key: "normalizeNative",
              value: function normalizeNative(nativeRange) {
                if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {
                  return null;
                }
                var range2 = {
                  start: { node: nativeRange.startContainer, offset: nativeRange.startOffset },
                  end: { node: nativeRange.endContainer, offset: nativeRange.endOffset },
                  native: nativeRange
                };
                [range2.start, range2.end].forEach(function(position) {
                  var node = position.node, offset2 = position.offset;
                  while (!(node instanceof Text) && node.childNodes.length > 0) {
                    if (node.childNodes.length > offset2) {
                      node = node.childNodes[offset2];
                      offset2 = 0;
                    } else if (node.childNodes.length === offset2) {
                      node = node.lastChild;
                      offset2 = node instanceof Text ? node.data.length : node.childNodes.length + 1;
                    } else {
                      break;
                    }
                  }
                  position.node = node, position.offset = offset2;
                });
                return range2;
              }
            }, {
              key: "rangeToNative",
              value: function rangeToNative(range2) {
                var _this5 = this;
                var indexes = range2.collapsed ? [range2.index] : [range2.index, range2.index + range2.length];
                var args = [];
                var scrollLength = this.scroll.length();
                indexes.forEach(function(index2, i2) {
                  index2 = Math.min(scrollLength - 1, index2);
                  var node = void 0, _scroll$leaf5 = _this5.scroll.leaf(index2), _scroll$leaf6 = _slicedToArray2(_scroll$leaf5, 2), leaf = _scroll$leaf6[0], offset2 = _scroll$leaf6[1];
                  var _leaf$position5 = leaf.position(offset2, i2 !== 0);
                  var _leaf$position6 = _slicedToArray2(_leaf$position5, 2);
                  node = _leaf$position6[0];
                  offset2 = _leaf$position6[1];
                  args.push(node, offset2);
                });
                if (args.length < 2) {
                  args = args.concat(args);
                }
                return args;
              }
            }, {
              key: "scrollIntoView",
              value: function scrollIntoView(scrollingContainer) {
                var range2 = this.lastRange;
                if (range2 == null) return;
                var bounds = this.getBounds(range2.index, range2.length);
                if (bounds == null) return;
                var limit = this.scroll.length() - 1;
                var _scroll$line = this.scroll.line(Math.min(range2.index, limit)), _scroll$line2 = _slicedToArray2(_scroll$line, 1), first3 = _scroll$line2[0];
                var last4 = first3;
                if (range2.length > 0) {
                  var _scroll$line3 = this.scroll.line(Math.min(range2.index + range2.length, limit));
                  var _scroll$line4 = _slicedToArray2(_scroll$line3, 1);
                  last4 = _scroll$line4[0];
                }
                if (first3 == null || last4 == null) return;
                var scrollBounds = scrollingContainer.getBoundingClientRect();
                if (bounds.top < scrollBounds.top) {
                  scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;
                } else if (bounds.bottom > scrollBounds.bottom) {
                  scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;
                }
              }
            }, {
              key: "setNativeRange",
              value: function setNativeRange(startNode, startOffset) {
                var endNode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : startNode;
                var endOffset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : startOffset;
                var force = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                debug.info("setNativeRange", startNode, startOffset, endNode, endOffset);
                if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {
                  return;
                }
                var selection = document.getSelection();
                if (selection == null) return;
                if (startNode != null) {
                  if (!this.hasFocus()) this.root.focus();
                  var native = (this.getNativeRange() || {}).native;
                  if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {
                    if (startNode.tagName == "BR") {
                      startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);
                      startNode = startNode.parentNode;
                    }
                    if (endNode.tagName == "BR") {
                      endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);
                      endNode = endNode.parentNode;
                    }
                    var range2 = document.createRange();
                    range2.setStart(startNode, startOffset);
                    range2.setEnd(endNode, endOffset);
                    selection.removeAllRanges();
                    selection.addRange(range2);
                  }
                } else {
                  selection.removeAllRanges();
                  this.root.blur();
                  document.body.focus();
                }
              }
            }, {
              key: "setRange",
              value: function setRange(range2) {
                var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _emitter4.default.sources.API;
                if (typeof force === "string") {
                  source = force;
                  force = false;
                }
                debug.info("setRange", range2);
                if (range2 != null) {
                  var args = this.rangeToNative(range2);
                  this.setNativeRange.apply(this, _toConsumableArray2(args).concat([force]));
                } else {
                  this.setNativeRange(null);
                }
                this.update(source);
              }
            }, {
              key: "update",
              value: function update8() {
                var source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _emitter4.default.sources.USER;
                var oldRange = this.lastRange;
                var _getRange = this.getRange(), _getRange2 = _slicedToArray2(_getRange, 2), lastRange = _getRange2[0], nativeRange = _getRange2[1];
                this.lastRange = lastRange;
                if (this.lastRange != null) {
                  this.savedRange = this.lastRange;
                }
                if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {
                  var _emitter;
                  if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {
                    this.cursor.restore();
                  }
                  var args = [_emitter4.default.events.SELECTION_CHANGE, (0, _clone2.default)(this.lastRange), (0, _clone2.default)(oldRange), source];
                  (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
                  if (source !== _emitter4.default.sources.SILENT) {
                    var _emitter2;
                    (_emitter2 = this.emitter).emit.apply(_emitter2, args);
                  }
                }
              }
            }]);
            return Selection2;
          }();
          function contains(parent2, descendant) {
            try {
              descendant.parentNode;
            } catch (e2) {
              return false;
            }
            if (descendant instanceof Text) {
              descendant = descendant.parentNode;
            }
            return parent2.contains(descendant);
          }
          exports3.Range = Range2;
          exports3.default = Selection;
        },
        /* 16 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Break = function(_Parchment$Embed) {
            _inherits2(Break2, _Parchment$Embed);
            function Break2() {
              _classCallCheck2(this, Break2);
              return _possibleConstructorReturn2(this, (Break2.__proto__ || Object.getPrototypeOf(Break2)).apply(this, arguments));
            }
            _createClass2(Break2, [{
              key: "insertInto",
              value: function insertInto(parent2, ref2) {
                if (parent2.children.length === 0) {
                  _get2(Break2.prototype.__proto__ || Object.getPrototypeOf(Break2.prototype), "insertInto", this).call(this, parent2, ref2);
                } else {
                  this.remove();
                }
              }
            }, {
              key: "length",
              value: function length() {
                return 0;
              }
            }, {
              key: "value",
              value: function value() {
                return "";
              }
            }], [{
              key: "value",
              value: function value() {
                return void 0;
              }
            }]);
            return Break2;
          }(_parchment2.default.Embed);
          Break.blotName = "break";
          Break.tagName = "BR";
          exports3.default = Break;
        },
        /* 17 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
              d.__proto__ = b;
            } || function(d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var linked_list_1 = __webpack_require__(44);
          var shadow_1 = __webpack_require__(30);
          var Registry = __webpack_require__(1);
          var ContainerBlot = (
            /** @class */
            function(_super) {
              __extends2(ContainerBlot2, _super);
              function ContainerBlot2(domNode) {
                var _this = _super.call(this, domNode) || this;
                _this.build();
                return _this;
              }
              ContainerBlot2.prototype.appendChild = function(other) {
                this.insertBefore(other);
              };
              ContainerBlot2.prototype.attach = function() {
                _super.prototype.attach.call(this);
                this.children.forEach(function(child) {
                  child.attach();
                });
              };
              ContainerBlot2.prototype.build = function() {
                var _this = this;
                this.children = new linked_list_1.default();
                [].slice.call(this.domNode.childNodes).reverse().forEach(function(node) {
                  try {
                    var child = makeBlot(node);
                    _this.insertBefore(child, _this.children.head || void 0);
                  } catch (err) {
                    if (err instanceof Registry.ParchmentError)
                      return;
                    else
                      throw err;
                  }
                });
              };
              ContainerBlot2.prototype.deleteAt = function(index2, length) {
                if (index2 === 0 && length === this.length()) {
                  return this.remove();
                }
                this.children.forEachAt(index2, length, function(child, offset2, length2) {
                  child.deleteAt(offset2, length2);
                });
              };
              ContainerBlot2.prototype.descendant = function(criteria, index2) {
                var _a = this.children.find(index2), child = _a[0], offset2 = _a[1];
                if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
                  return [child, offset2];
                } else if (child instanceof ContainerBlot2) {
                  return child.descendant(criteria, offset2);
                } else {
                  return [null, -1];
                }
              };
              ContainerBlot2.prototype.descendants = function(criteria, index2, length) {
                if (index2 === void 0) {
                  index2 = 0;
                }
                if (length === void 0) {
                  length = Number.MAX_VALUE;
                }
                var descendants = [];
                var lengthLeft = length;
                this.children.forEachAt(index2, length, function(child, index3, length2) {
                  if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
                    descendants.push(child);
                  }
                  if (child instanceof ContainerBlot2) {
                    descendants = descendants.concat(child.descendants(criteria, index3, lengthLeft));
                  }
                  lengthLeft -= length2;
                });
                return descendants;
              };
              ContainerBlot2.prototype.detach = function() {
                this.children.forEach(function(child) {
                  child.detach();
                });
                _super.prototype.detach.call(this);
              };
              ContainerBlot2.prototype.formatAt = function(index2, length, name2, value) {
                this.children.forEachAt(index2, length, function(child, offset2, length2) {
                  child.formatAt(offset2, length2, name2, value);
                });
              };
              ContainerBlot2.prototype.insertAt = function(index2, value, def) {
                var _a = this.children.find(index2), child = _a[0], offset2 = _a[1];
                if (child) {
                  child.insertAt(offset2, value, def);
                } else {
                  var blot = def == null ? Registry.create("text", value) : Registry.create(value, def);
                  this.appendChild(blot);
                }
              };
              ContainerBlot2.prototype.insertBefore = function(childBlot, refBlot) {
                if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(function(child) {
                  return childBlot instanceof child;
                })) {
                  throw new Registry.ParchmentError("Cannot insert " + childBlot.statics.blotName + " into " + this.statics.blotName);
                }
                childBlot.insertInto(this, refBlot);
              };
              ContainerBlot2.prototype.length = function() {
                return this.children.reduce(function(memo, child) {
                  return memo + child.length();
                }, 0);
              };
              ContainerBlot2.prototype.moveChildren = function(targetParent, refNode) {
                this.children.forEach(function(child) {
                  targetParent.insertBefore(child, refNode);
                });
              };
              ContainerBlot2.prototype.optimize = function(context2) {
                _super.prototype.optimize.call(this, context2);
                if (this.children.length === 0) {
                  if (this.statics.defaultChild != null) {
                    var child = Registry.create(this.statics.defaultChild);
                    this.appendChild(child);
                    child.optimize(context2);
                  } else {
                    this.remove();
                  }
                }
              };
              ContainerBlot2.prototype.path = function(index2, inclusive) {
                if (inclusive === void 0) {
                  inclusive = false;
                }
                var _a = this.children.find(index2, inclusive), child = _a[0], offset2 = _a[1];
                var position = [[this, index2]];
                if (child instanceof ContainerBlot2) {
                  return position.concat(child.path(offset2, inclusive));
                } else if (child != null) {
                  position.push([child, offset2]);
                }
                return position;
              };
              ContainerBlot2.prototype.removeChild = function(child) {
                this.children.remove(child);
              };
              ContainerBlot2.prototype.replace = function(target) {
                if (target instanceof ContainerBlot2) {
                  target.moveChildren(this);
                }
                _super.prototype.replace.call(this, target);
              };
              ContainerBlot2.prototype.split = function(index2, force) {
                if (force === void 0) {
                  force = false;
                }
                if (!force) {
                  if (index2 === 0)
                    return this;
                  if (index2 === this.length())
                    return this.next;
                }
                var after = this.clone();
                this.parent.insertBefore(after, this.next);
                this.children.forEachAt(index2, this.length(), function(child, offset2, length) {
                  child = child.split(offset2, force);
                  after.appendChild(child);
                });
                return after;
              };
              ContainerBlot2.prototype.unwrap = function() {
                this.moveChildren(this.parent, this.next);
                this.remove();
              };
              ContainerBlot2.prototype.update = function(mutations, context2) {
                var _this = this;
                var addedNodes = [];
                var removedNodes = [];
                mutations.forEach(function(mutation) {
                  if (mutation.target === _this.domNode && mutation.type === "childList") {
                    addedNodes.push.apply(addedNodes, mutation.addedNodes);
                    removedNodes.push.apply(removedNodes, mutation.removedNodes);
                  }
                });
                removedNodes.forEach(function(node) {
                  if (node.parentNode != null && // @ts-ignore
                  node.tagName !== "IFRAME" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                    return;
                  }
                  var blot = Registry.find(node);
                  if (blot == null)
                    return;
                  if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {
                    blot.detach();
                  }
                });
                addedNodes.filter(function(node) {
                  return node.parentNode == _this.domNode;
                }).sort(function(a2, b) {
                  if (a2 === b)
                    return 0;
                  if (a2.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {
                    return 1;
                  }
                  return -1;
                }).forEach(function(node) {
                  var refBlot = null;
                  if (node.nextSibling != null) {
                    refBlot = Registry.find(node.nextSibling);
                  }
                  var blot = makeBlot(node);
                  if (blot.next != refBlot || blot.next == null) {
                    if (blot.parent != null) {
                      blot.parent.removeChild(_this);
                    }
                    _this.insertBefore(blot, refBlot || void 0);
                  }
                });
              };
              return ContainerBlot2;
            }(shadow_1.default)
          );
          function makeBlot(node) {
            var blot = Registry.find(node);
            if (blot == null) {
              try {
                blot = Registry.create(node);
              } catch (e2) {
                blot = Registry.create(Registry.Scope.INLINE);
                [].slice.call(node.childNodes).forEach(function(child) {
                  blot.domNode.appendChild(child);
                });
                if (node.parentNode) {
                  node.parentNode.replaceChild(blot.domNode, node);
                }
                blot.attach();
              }
            }
            return blot;
          }
          exports3.default = ContainerBlot;
        },
        /* 18 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
              d.__proto__ = b;
            } || function(d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var attributor_1 = __webpack_require__(12);
          var store_1 = __webpack_require__(31);
          var container_1 = __webpack_require__(17);
          var Registry = __webpack_require__(1);
          var FormatBlot = (
            /** @class */
            function(_super) {
              __extends2(FormatBlot2, _super);
              function FormatBlot2(domNode) {
                var _this = _super.call(this, domNode) || this;
                _this.attributes = new store_1.default(_this.domNode);
                return _this;
              }
              FormatBlot2.formats = function(domNode) {
                if (typeof this.tagName === "string") {
                  return true;
                } else if (Array.isArray(this.tagName)) {
                  return domNode.tagName.toLowerCase();
                }
                return void 0;
              };
              FormatBlot2.prototype.format = function(name2, value) {
                var format2 = Registry.query(name2);
                if (format2 instanceof attributor_1.default) {
                  this.attributes.attribute(format2, value);
                } else if (value) {
                  if (format2 != null && (name2 !== this.statics.blotName || this.formats()[name2] !== value)) {
                    this.replaceWith(name2, value);
                  }
                }
              };
              FormatBlot2.prototype.formats = function() {
                var formats = this.attributes.values();
                var format2 = this.statics.formats(this.domNode);
                if (format2 != null) {
                  formats[this.statics.blotName] = format2;
                }
                return formats;
              };
              FormatBlot2.prototype.replaceWith = function(name2, value) {
                var replacement = _super.prototype.replaceWith.call(this, name2, value);
                this.attributes.copy(replacement);
                return replacement;
              };
              FormatBlot2.prototype.update = function(mutations, context2) {
                var _this = this;
                _super.prototype.update.call(this, mutations, context2);
                if (mutations.some(function(mutation) {
                  return mutation.target === _this.domNode && mutation.type === "attributes";
                })) {
                  this.attributes.build();
                }
              };
              FormatBlot2.prototype.wrap = function(name2, value) {
                var wrapper = _super.prototype.wrap.call(this, name2, value);
                if (wrapper instanceof FormatBlot2 && wrapper.statics.scope === this.statics.scope) {
                  this.attributes.move(wrapper);
                }
                return wrapper;
              };
              return FormatBlot2;
            }(container_1.default)
          );
          exports3.default = FormatBlot;
        },
        /* 19 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
              d.__proto__ = b;
            } || function(d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var shadow_1 = __webpack_require__(30);
          var Registry = __webpack_require__(1);
          var LeafBlot = (
            /** @class */
            function(_super) {
              __extends2(LeafBlot2, _super);
              function LeafBlot2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              LeafBlot2.value = function(domNode) {
                return true;
              };
              LeafBlot2.prototype.index = function(node, offset2) {
                if (this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                  return Math.min(offset2, 1);
                }
                return -1;
              };
              LeafBlot2.prototype.position = function(index2, inclusive) {
                var offset2 = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);
                if (index2 > 0)
                  offset2 += 1;
                return [this.parent.domNode, offset2];
              };
              LeafBlot2.prototype.value = function() {
                var _a;
                return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;
              };
              LeafBlot2.scope = Registry.Scope.INLINE_BLOT;
              return LeafBlot2;
            }(shadow_1.default)
          );
          exports3.default = LeafBlot;
        },
        /* 20 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var equal2 = __webpack_require__(11);
          var extend4 = __webpack_require__(3);
          var lib2 = {
            attributes: {
              compose: function(a2, b, keepNull) {
                if (typeof a2 !== "object") a2 = {};
                if (typeof b !== "object") b = {};
                var attributes = extend4(true, {}, b);
                if (!keepNull) {
                  attributes = Object.keys(attributes).reduce(function(copy2, key2) {
                    if (attributes[key2] != null) {
                      copy2[key2] = attributes[key2];
                    }
                    return copy2;
                  }, {});
                }
                for (var key in a2) {
                  if (a2[key] !== void 0 && b[key] === void 0) {
                    attributes[key] = a2[key];
                  }
                }
                return Object.keys(attributes).length > 0 ? attributes : void 0;
              },
              diff: function(a2, b) {
                if (typeof a2 !== "object") a2 = {};
                if (typeof b !== "object") b = {};
                var attributes = Object.keys(a2).concat(Object.keys(b)).reduce(function(attributes2, key) {
                  if (!equal2(a2[key], b[key])) {
                    attributes2[key] = b[key] === void 0 ? null : b[key];
                  }
                  return attributes2;
                }, {});
                return Object.keys(attributes).length > 0 ? attributes : void 0;
              },
              transform: function(a2, b, priority) {
                if (typeof a2 !== "object") return b;
                if (typeof b !== "object") return void 0;
                if (!priority) return b;
                var attributes = Object.keys(b).reduce(function(attributes2, key) {
                  if (a2[key] === void 0) attributes2[key] = b[key];
                  return attributes2;
                }, {});
                return Object.keys(attributes).length > 0 ? attributes : void 0;
              }
            },
            iterator: function(ops) {
              return new Iterator3(ops);
            },
            length: function(op2) {
              if (typeof op2["delete"] === "number") {
                return op2["delete"];
              } else if (typeof op2.retain === "number") {
                return op2.retain;
              } else {
                return typeof op2.insert === "string" ? op2.insert.length : 1;
              }
            }
          };
          function Iterator3(ops) {
            this.ops = ops;
            this.index = 0;
            this.offset = 0;
          }
          Iterator3.prototype.hasNext = function() {
            return this.peekLength() < Infinity;
          };
          Iterator3.prototype.next = function(length) {
            if (!length) length = Infinity;
            var nextOp = this.ops[this.index];
            if (nextOp) {
              var offset2 = this.offset;
              var opLength = lib2.length(nextOp);
              if (length >= opLength - offset2) {
                length = opLength - offset2;
                this.index += 1;
                this.offset = 0;
              } else {
                this.offset += length;
              }
              if (typeof nextOp["delete"] === "number") {
                return { "delete": length };
              } else {
                var retOp = {};
                if (nextOp.attributes) {
                  retOp.attributes = nextOp.attributes;
                }
                if (typeof nextOp.retain === "number") {
                  retOp.retain = length;
                } else if (typeof nextOp.insert === "string") {
                  retOp.insert = nextOp.insert.substr(offset2, length);
                } else {
                  retOp.insert = nextOp.insert;
                }
                return retOp;
              }
            } else {
              return { retain: Infinity };
            }
          };
          Iterator3.prototype.peek = function() {
            return this.ops[this.index];
          };
          Iterator3.prototype.peekLength = function() {
            if (this.ops[this.index]) {
              return lib2.length(this.ops[this.index]) - this.offset;
            } else {
              return Infinity;
            }
          };
          Iterator3.prototype.peekType = function() {
            if (this.ops[this.index]) {
              if (typeof this.ops[this.index]["delete"] === "number") {
                return "delete";
              } else if (typeof this.ops[this.index].retain === "number") {
                return "retain";
              } else {
                return "insert";
              }
            }
            return "retain";
          };
          Iterator3.prototype.rest = function() {
            if (!this.hasNext()) {
              return [];
            } else if (this.offset === 0) {
              return this.ops.slice(this.index);
            } else {
              var offset2 = this.offset;
              var index2 = this.index;
              var next = this.next();
              var rest2 = this.ops.slice(this.index);
              this.offset = offset2;
              this.index = index2;
              return [next].concat(rest2);
            }
          };
          module3.exports = lib2;
        },
        /* 21 */
        /***/
        function(module3, exports3) {
          var clone3 = function() {
            function _instanceof(obj, type2) {
              return type2 != null && obj instanceof type2;
            }
            var nativeMap;
            try {
              nativeMap = Map;
            } catch (_) {
              nativeMap = function() {
              };
            }
            var nativeSet;
            try {
              nativeSet = Set;
            } catch (_) {
              nativeSet = function() {
              };
            }
            var nativePromise;
            try {
              nativePromise = Promise;
            } catch (_) {
              nativePromise = function() {
              };
            }
            function clone4(parent2, circular, depth, prototype, includeNonEnumerable) {
              if (typeof circular === "object") {
                depth = circular.depth;
                prototype = circular.prototype;
                includeNonEnumerable = circular.includeNonEnumerable;
                circular = circular.circular;
              }
              var allParents = [];
              var allChildren = [];
              var useBuffer = typeof Buffer != "undefined";
              if (typeof circular == "undefined")
                circular = true;
              if (typeof depth == "undefined")
                depth = Infinity;
              function _clone(parent3, depth2) {
                if (parent3 === null)
                  return null;
                if (depth2 === 0)
                  return parent3;
                var child;
                var proto2;
                if (typeof parent3 != "object") {
                  return parent3;
                }
                if (_instanceof(parent3, nativeMap)) {
                  child = new nativeMap();
                } else if (_instanceof(parent3, nativeSet)) {
                  child = new nativeSet();
                } else if (_instanceof(parent3, nativePromise)) {
                  child = new nativePromise(function(resolve, reject) {
                    parent3.then(function(value) {
                      resolve(_clone(value, depth2 - 1));
                    }, function(err) {
                      reject(_clone(err, depth2 - 1));
                    });
                  });
                } else if (clone4.__isArray(parent3)) {
                  child = [];
                } else if (clone4.__isRegExp(parent3)) {
                  child = new RegExp(parent3.source, __getRegExpFlags(parent3));
                  if (parent3.lastIndex) child.lastIndex = parent3.lastIndex;
                } else if (clone4.__isDate(parent3)) {
                  child = new Date(parent3.getTime());
                } else if (useBuffer && Buffer.isBuffer(parent3)) {
                  if (Buffer.allocUnsafe) {
                    child = Buffer.allocUnsafe(parent3.length);
                  } else {
                    child = new Buffer(parent3.length);
                  }
                  parent3.copy(child);
                  return child;
                } else if (_instanceof(parent3, Error)) {
                  child = Object.create(parent3);
                } else {
                  if (typeof prototype == "undefined") {
                    proto2 = Object.getPrototypeOf(parent3);
                    child = Object.create(proto2);
                  } else {
                    child = Object.create(prototype);
                    proto2 = prototype;
                  }
                }
                if (circular) {
                  var index2 = allParents.indexOf(parent3);
                  if (index2 != -1) {
                    return allChildren[index2];
                  }
                  allParents.push(parent3);
                  allChildren.push(child);
                }
                if (_instanceof(parent3, nativeMap)) {
                  parent3.forEach(function(value, key) {
                    var keyChild = _clone(key, depth2 - 1);
                    var valueChild = _clone(value, depth2 - 1);
                    child.set(keyChild, valueChild);
                  });
                }
                if (_instanceof(parent3, nativeSet)) {
                  parent3.forEach(function(value) {
                    var entryChild = _clone(value, depth2 - 1);
                    child.add(entryChild);
                  });
                }
                for (var i2 in parent3) {
                  var attrs;
                  if (proto2) {
                    attrs = Object.getOwnPropertyDescriptor(proto2, i2);
                  }
                  if (attrs && attrs.set == null) {
                    continue;
                  }
                  child[i2] = _clone(parent3[i2], depth2 - 1);
                }
                if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(parent3);
                  for (var i2 = 0; i2 < symbols.length; i2++) {
                    var symbol = symbols[i2];
                    var descriptor = Object.getOwnPropertyDescriptor(parent3, symbol);
                    if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                      continue;
                    }
                    child[symbol] = _clone(parent3[symbol], depth2 - 1);
                    if (!descriptor.enumerable) {
                      Object.defineProperty(child, symbol, {
                        enumerable: false
                      });
                    }
                  }
                }
                if (includeNonEnumerable) {
                  var allPropertyNames = Object.getOwnPropertyNames(parent3);
                  for (var i2 = 0; i2 < allPropertyNames.length; i2++) {
                    var propertyName = allPropertyNames[i2];
                    var descriptor = Object.getOwnPropertyDescriptor(parent3, propertyName);
                    if (descriptor && descriptor.enumerable) {
                      continue;
                    }
                    child[propertyName] = _clone(parent3[propertyName], depth2 - 1);
                    Object.defineProperty(child, propertyName, {
                      enumerable: false
                    });
                  }
                }
                return child;
              }
              return _clone(parent2, depth);
            }
            clone4.clonePrototype = function clonePrototype(parent2) {
              if (parent2 === null)
                return null;
              var c2 = function() {
              };
              c2.prototype = parent2;
              return new c2();
            };
            function __objToStr(o) {
              return Object.prototype.toString.call(o);
            }
            clone4.__objToStr = __objToStr;
            function __isDate(o) {
              return typeof o === "object" && __objToStr(o) === "[object Date]";
            }
            clone4.__isDate = __isDate;
            function __isArray(o) {
              return typeof o === "object" && __objToStr(o) === "[object Array]";
            }
            clone4.__isArray = __isArray;
            function __isRegExp(o) {
              return typeof o === "object" && __objToStr(o) === "[object RegExp]";
            }
            clone4.__isRegExp = __isRegExp;
            function __getRegExpFlags(re) {
              var flags3 = "";
              if (re.global) flags3 += "g";
              if (re.ignoreCase) flags3 += "i";
              if (re.multiline) flags3 += "m";
              return flags3;
            }
            clone4.__getRegExpFlags = __getRegExpFlags;
            return clone4;
          }();
          if (typeof module3 === "object" && module3.exports) {
            module3.exports = clone3;
          }
        },
        /* 22 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _slicedToArray2 = /* @__PURE__ */ function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _emitter = __webpack_require__(8);
          var _emitter2 = _interopRequireDefault2(_emitter);
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          var _break = __webpack_require__(16);
          var _break2 = _interopRequireDefault2(_break);
          var _code = __webpack_require__(13);
          var _code2 = _interopRequireDefault2(_code);
          var _container = __webpack_require__(25);
          var _container2 = _interopRequireDefault2(_container);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          function isLine(blot) {
            return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;
          }
          var Scroll = function(_Parchment$Scroll) {
            _inherits2(Scroll2, _Parchment$Scroll);
            function Scroll2(domNode, config2) {
              _classCallCheck2(this, Scroll2);
              var _this = _possibleConstructorReturn2(this, (Scroll2.__proto__ || Object.getPrototypeOf(Scroll2)).call(this, domNode));
              _this.emitter = config2.emitter;
              if (Array.isArray(config2.whitelist)) {
                _this.whitelist = config2.whitelist.reduce(function(whitelist, format2) {
                  whitelist[format2] = true;
                  return whitelist;
                }, {});
              }
              _this.domNode.addEventListener("DOMNodeInserted", function() {
              });
              _this.optimize();
              _this.enable();
              return _this;
            }
            _createClass2(Scroll2, [{
              key: "batchStart",
              value: function batchStart() {
                this.batch = true;
              }
            }, {
              key: "batchEnd",
              value: function batchEnd() {
                this.batch = false;
                this.optimize();
              }
            }, {
              key: "deleteAt",
              value: function deleteAt(index2, length) {
                var _line = this.line(index2), _line2 = _slicedToArray2(_line, 2), first3 = _line2[0], offset2 = _line2[1];
                var _line3 = this.line(index2 + length), _line4 = _slicedToArray2(_line3, 1), last4 = _line4[0];
                _get2(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "deleteAt", this).call(this, index2, length);
                if (last4 != null && first3 !== last4 && offset2 > 0) {
                  if (first3 instanceof _block.BlockEmbed || last4 instanceof _block.BlockEmbed) {
                    this.optimize();
                    return;
                  }
                  if (first3 instanceof _code2.default) {
                    var newlineIndex = first3.newlineIndex(first3.length(), true);
                    if (newlineIndex > -1) {
                      first3 = first3.split(newlineIndex + 1);
                      if (first3 === last4) {
                        this.optimize();
                        return;
                      }
                    }
                  } else if (last4 instanceof _code2.default) {
                    var _newlineIndex = last4.newlineIndex(0);
                    if (_newlineIndex > -1) {
                      last4.split(_newlineIndex + 1);
                    }
                  }
                  var ref2 = last4.children.head instanceof _break2.default ? null : last4.children.head;
                  first3.moveChildren(last4, ref2);
                  first3.remove();
                }
                this.optimize();
              }
            }, {
              key: "enable",
              value: function enable() {
                var enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                this.domNode.setAttribute("contenteditable", enabled);
              }
            }, {
              key: "formatAt",
              value: function formatAt(index2, length, format2, value) {
                if (this.whitelist != null && !this.whitelist[format2]) return;
                _get2(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "formatAt", this).call(this, index2, length, format2, value);
                this.optimize();
              }
            }, {
              key: "insertAt",
              value: function insertAt(index2, value, def) {
                if (def != null && this.whitelist != null && !this.whitelist[value]) return;
                if (index2 >= this.length()) {
                  if (def == null || _parchment2.default.query(value, _parchment2.default.Scope.BLOCK) == null) {
                    var blot = _parchment2.default.create(this.statics.defaultChild);
                    this.appendChild(blot);
                    if (def == null && value.endsWith("\n")) {
                      value = value.slice(0, -1);
                    }
                    blot.insertAt(0, value, def);
                  } else {
                    var embed = _parchment2.default.create(value, def);
                    this.appendChild(embed);
                  }
                } else {
                  _get2(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "insertAt", this).call(this, index2, value, def);
                }
                this.optimize();
              }
            }, {
              key: "insertBefore",
              value: function insertBefore(blot, ref2) {
                if (blot.statics.scope === _parchment2.default.Scope.INLINE_BLOT) {
                  var wrapper = _parchment2.default.create(this.statics.defaultChild);
                  wrapper.appendChild(blot);
                  blot = wrapper;
                }
                _get2(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "insertBefore", this).call(this, blot, ref2);
              }
            }, {
              key: "leaf",
              value: function leaf(index2) {
                return this.path(index2).pop() || [null, -1];
              }
            }, {
              key: "line",
              value: function line(index2) {
                if (index2 === this.length()) {
                  return this.line(index2 - 1);
                }
                return this.descendant(isLine, index2);
              }
            }, {
              key: "lines",
              value: function lines() {
                var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
                var getLines = function getLines2(blot, index3, length2) {
                  var lines2 = [], lengthLeft = length2;
                  blot.children.forEachAt(index3, length2, function(child, index4, length3) {
                    if (isLine(child)) {
                      lines2.push(child);
                    } else if (child instanceof _parchment2.default.Container) {
                      lines2 = lines2.concat(getLines2(child, index4, lengthLeft));
                    }
                    lengthLeft -= length3;
                  });
                  return lines2;
                };
                return getLines(this, index2, length);
              }
            }, {
              key: "optimize",
              value: function optimize() {
                var mutations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                var context2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                if (this.batch === true) return;
                _get2(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "optimize", this).call(this, mutations, context2);
                if (mutations.length > 0) {
                  this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context2);
                }
              }
            }, {
              key: "path",
              value: function path(index2) {
                return _get2(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "path", this).call(this, index2).slice(1);
              }
            }, {
              key: "update",
              value: function update8(mutations) {
                if (this.batch === true) return;
                var source = _emitter2.default.sources.USER;
                if (typeof mutations === "string") {
                  source = mutations;
                }
                if (!Array.isArray(mutations)) {
                  mutations = this.observer.takeRecords();
                }
                if (mutations.length > 0) {
                  this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);
                }
                _get2(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "update", this).call(this, mutations.concat([]));
                if (mutations.length > 0) {
                  this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);
                }
              }
            }]);
            return Scroll2;
          }(_parchment2.default.Scroll);
          Scroll.blotName = "scroll";
          Scroll.className = "ql-editor";
          Scroll.tagName = "DIV";
          Scroll.defaultChild = "block";
          Scroll.allowedChildren = [_block2.default, _block.BlockEmbed, _container2.default];
          exports3.default = Scroll;
        },
        /* 23 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.SHORTKEY = exports3.default = void 0;
          var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _slicedToArray2 = /* @__PURE__ */ function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _clone = __webpack_require__(21);
          var _clone2 = _interopRequireDefault2(_clone);
          var _deepEqual = __webpack_require__(11);
          var _deepEqual2 = _interopRequireDefault2(_deepEqual);
          var _extend = __webpack_require__(3);
          var _extend2 = _interopRequireDefault2(_extend);
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _op = __webpack_require__(20);
          var _op2 = _interopRequireDefault2(_op);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _quill = __webpack_require__(5);
          var _quill2 = _interopRequireDefault2(_quill);
          var _logger = __webpack_require__(10);
          var _logger2 = _interopRequireDefault2(_logger);
          var _module = __webpack_require__(9);
          var _module2 = _interopRequireDefault2(_module);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _defineProperty2(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var debug = (0, _logger2.default)("quill:keyboard");
          var SHORTKEY = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
          var Keyboard = function(_Module) {
            _inherits2(Keyboard2, _Module);
            _createClass2(Keyboard2, null, [{
              key: "match",
              value: function match(evt, binding) {
                binding = normalize(binding);
                if (["altKey", "ctrlKey", "metaKey", "shiftKey"].some(function(key) {
                  return !!binding[key] !== evt[key] && binding[key] !== null;
                })) {
                  return false;
                }
                return binding.key === (evt.which || evt.keyCode);
              }
            }]);
            function Keyboard2(quill2, options) {
              _classCallCheck2(this, Keyboard2);
              var _this = _possibleConstructorReturn2(this, (Keyboard2.__proto__ || Object.getPrototypeOf(Keyboard2)).call(this, quill2, options));
              _this.bindings = {};
              Object.keys(_this.options.bindings).forEach(function(name2) {
                if (name2 === "list autofill" && quill2.scroll.whitelist != null && !quill2.scroll.whitelist["list"]) {
                  return;
                }
                if (_this.options.bindings[name2]) {
                  _this.addBinding(_this.options.bindings[name2]);
                }
              });
              _this.addBinding({ key: Keyboard2.keys.ENTER, shiftKey: null }, handleEnter);
              _this.addBinding({ key: Keyboard2.keys.ENTER, metaKey: null, ctrlKey: null, altKey: null }, function() {
              });
              if (/Firefox/i.test(navigator.userAgent)) {
                _this.addBinding({ key: Keyboard2.keys.BACKSPACE }, { collapsed: true }, handleBackspace);
                _this.addBinding({ key: Keyboard2.keys.DELETE }, { collapsed: true }, handleDelete);
              } else {
                _this.addBinding({ key: Keyboard2.keys.BACKSPACE }, { collapsed: true, prefix: /^.?$/ }, handleBackspace);
                _this.addBinding({ key: Keyboard2.keys.DELETE }, { collapsed: true, suffix: /^.?$/ }, handleDelete);
              }
              _this.addBinding({ key: Keyboard2.keys.BACKSPACE }, { collapsed: false }, handleDeleteRange);
              _this.addBinding({ key: Keyboard2.keys.DELETE }, { collapsed: false }, handleDeleteRange);
              _this.addBinding({ key: Keyboard2.keys.BACKSPACE, altKey: null, ctrlKey: null, metaKey: null, shiftKey: null }, { collapsed: true, offset: 0 }, handleBackspace);
              _this.listen();
              return _this;
            }
            _createClass2(Keyboard2, [{
              key: "addBinding",
              value: function addBinding(key) {
                var context2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var handler = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                var binding = normalize(key);
                if (binding == null || binding.key == null) {
                  return debug.warn("Attempted to add invalid keyboard binding", binding);
                }
                if (typeof context2 === "function") {
                  context2 = { handler: context2 };
                }
                if (typeof handler === "function") {
                  handler = { handler };
                }
                binding = (0, _extend2.default)(binding, context2, handler);
                this.bindings[binding.key] = this.bindings[binding.key] || [];
                this.bindings[binding.key].push(binding);
              }
            }, {
              key: "listen",
              value: function listen() {
                var _this2 = this;
                this.quill.root.addEventListener("keydown", function(evt) {
                  if (evt.defaultPrevented) return;
                  var which = evt.which || evt.keyCode;
                  var bindings = (_this2.bindings[which] || []).filter(function(binding) {
                    return Keyboard2.match(evt, binding);
                  });
                  if (bindings.length === 0) return;
                  var range2 = _this2.quill.getSelection();
                  if (range2 == null || !_this2.quill.hasFocus()) return;
                  var _quill$getLine = _this2.quill.getLine(range2.index), _quill$getLine2 = _slicedToArray2(_quill$getLine, 2), line = _quill$getLine2[0], offset2 = _quill$getLine2[1];
                  var _quill$getLeaf = _this2.quill.getLeaf(range2.index), _quill$getLeaf2 = _slicedToArray2(_quill$getLeaf, 2), leafStart = _quill$getLeaf2[0], offsetStart = _quill$getLeaf2[1];
                  var _ref = range2.length === 0 ? [leafStart, offsetStart] : _this2.quill.getLeaf(range2.index + range2.length), _ref2 = _slicedToArray2(_ref, 2), leafEnd = _ref2[0], offsetEnd = _ref2[1];
                  var prefixText = leafStart instanceof _parchment2.default.Text ? leafStart.value().slice(0, offsetStart) : "";
                  var suffixText = leafEnd instanceof _parchment2.default.Text ? leafEnd.value().slice(offsetEnd) : "";
                  var curContext = {
                    collapsed: range2.length === 0,
                    empty: range2.length === 0 && line.length() <= 1,
                    format: _this2.quill.getFormat(range2),
                    offset: offset2,
                    prefix: prefixText,
                    suffix: suffixText
                  };
                  var prevented = bindings.some(function(binding) {
                    if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) return false;
                    if (binding.empty != null && binding.empty !== curContext.empty) return false;
                    if (binding.offset != null && binding.offset !== curContext.offset) return false;
                    if (Array.isArray(binding.format)) {
                      if (binding.format.every(function(name2) {
                        return curContext.format[name2] == null;
                      })) {
                        return false;
                      }
                    } else if (_typeof2(binding.format) === "object") {
                      if (!Object.keys(binding.format).every(function(name2) {
                        if (binding.format[name2] === true) return curContext.format[name2] != null;
                        if (binding.format[name2] === false) return curContext.format[name2] == null;
                        return (0, _deepEqual2.default)(binding.format[name2], curContext.format[name2]);
                      })) {
                        return false;
                      }
                    }
                    if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) return false;
                    if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) return false;
                    return binding.handler.call(_this2, range2, curContext) !== true;
                  });
                  if (prevented) {
                    evt.preventDefault();
                  }
                });
              }
            }]);
            return Keyboard2;
          }(_module2.default);
          Keyboard.keys = {
            BACKSPACE: 8,
            TAB: 9,
            ENTER: 13,
            ESCAPE: 27,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            DELETE: 46
          };
          Keyboard.DEFAULTS = {
            bindings: {
              "bold": makeFormatHandler("bold"),
              "italic": makeFormatHandler("italic"),
              "underline": makeFormatHandler("underline"),
              "indent": {
                // highlight tab or tab at beginning of list, indent or blockquote
                key: Keyboard.keys.TAB,
                format: ["blockquote", "indent", "list"],
                handler: function handler(range2, context2) {
                  if (context2.collapsed && context2.offset !== 0) return true;
                  this.quill.format("indent", "+1", _quill2.default.sources.USER);
                }
              },
              "outdent": {
                key: Keyboard.keys.TAB,
                shiftKey: true,
                format: ["blockquote", "indent", "list"],
                // highlight tab or tab at beginning of list, indent or blockquote
                handler: function handler(range2, context2) {
                  if (context2.collapsed && context2.offset !== 0) return true;
                  this.quill.format("indent", "-1", _quill2.default.sources.USER);
                }
              },
              "outdent backspace": {
                key: Keyboard.keys.BACKSPACE,
                collapsed: true,
                shiftKey: null,
                metaKey: null,
                ctrlKey: null,
                altKey: null,
                format: ["indent", "list"],
                offset: 0,
                handler: function handler(range2, context2) {
                  if (context2.format.indent != null) {
                    this.quill.format("indent", "-1", _quill2.default.sources.USER);
                  } else if (context2.format.list != null) {
                    this.quill.format("list", false, _quill2.default.sources.USER);
                  }
                }
              },
              "indent code-block": makeCodeBlockHandler(true),
              "outdent code-block": makeCodeBlockHandler(false),
              "remove tab": {
                key: Keyboard.keys.TAB,
                shiftKey: true,
                collapsed: true,
                prefix: /\t$/,
                handler: function handler(range2) {
                  this.quill.deleteText(range2.index - 1, 1, _quill2.default.sources.USER);
                }
              },
              "tab": {
                key: Keyboard.keys.TAB,
                handler: function handler(range2) {
                  this.quill.history.cutoff();
                  var delta2 = new _quillDelta2.default().retain(range2.index).delete(range2.length).insert("	");
                  this.quill.updateContents(delta2, _quill2.default.sources.USER);
                  this.quill.history.cutoff();
                  this.quill.setSelection(range2.index + 1, _quill2.default.sources.SILENT);
                }
              },
              "list empty enter": {
                key: Keyboard.keys.ENTER,
                collapsed: true,
                format: ["list"],
                empty: true,
                handler: function handler(range2, context2) {
                  this.quill.format("list", false, _quill2.default.sources.USER);
                  if (context2.format.indent) {
                    this.quill.format("indent", false, _quill2.default.sources.USER);
                  }
                }
              },
              "checklist enter": {
                key: Keyboard.keys.ENTER,
                collapsed: true,
                format: { list: "checked" },
                handler: function handler(range2) {
                  var _quill$getLine3 = this.quill.getLine(range2.index), _quill$getLine4 = _slicedToArray2(_quill$getLine3, 2), line = _quill$getLine4[0], offset2 = _quill$getLine4[1];
                  var formats = (0, _extend2.default)({}, line.formats(), { list: "checked" });
                  var delta2 = new _quillDelta2.default().retain(range2.index).insert("\n", formats).retain(line.length() - offset2 - 1).retain(1, { list: "unchecked" });
                  this.quill.updateContents(delta2, _quill2.default.sources.USER);
                  this.quill.setSelection(range2.index + 1, _quill2.default.sources.SILENT);
                  this.quill.scrollIntoView();
                }
              },
              "header enter": {
                key: Keyboard.keys.ENTER,
                collapsed: true,
                format: ["header"],
                suffix: /^$/,
                handler: function handler(range2, context2) {
                  var _quill$getLine5 = this.quill.getLine(range2.index), _quill$getLine6 = _slicedToArray2(_quill$getLine5, 2), line = _quill$getLine6[0], offset2 = _quill$getLine6[1];
                  var delta2 = new _quillDelta2.default().retain(range2.index).insert("\n", context2.format).retain(line.length() - offset2 - 1).retain(1, { header: null });
                  this.quill.updateContents(delta2, _quill2.default.sources.USER);
                  this.quill.setSelection(range2.index + 1, _quill2.default.sources.SILENT);
                  this.quill.scrollIntoView();
                }
              },
              "list autofill": {
                key: " ",
                collapsed: true,
                format: { list: false },
                prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
                handler: function handler(range2, context2) {
                  var length = context2.prefix.length;
                  var _quill$getLine7 = this.quill.getLine(range2.index), _quill$getLine8 = _slicedToArray2(_quill$getLine7, 2), line = _quill$getLine8[0], offset2 = _quill$getLine8[1];
                  if (offset2 > length) return true;
                  var value = void 0;
                  switch (context2.prefix.trim()) {
                    case "[]":
                    case "[ ]":
                      value = "unchecked";
                      break;
                    case "[x]":
                      value = "checked";
                      break;
                    case "-":
                    case "*":
                      value = "bullet";
                      break;
                    default:
                      value = "ordered";
                  }
                  this.quill.insertText(range2.index, " ", _quill2.default.sources.USER);
                  this.quill.history.cutoff();
                  var delta2 = new _quillDelta2.default().retain(range2.index - offset2).delete(length + 1).retain(line.length() - 2 - offset2).retain(1, { list: value });
                  this.quill.updateContents(delta2, _quill2.default.sources.USER);
                  this.quill.history.cutoff();
                  this.quill.setSelection(range2.index - length, _quill2.default.sources.SILENT);
                }
              },
              "code exit": {
                key: Keyboard.keys.ENTER,
                collapsed: true,
                format: ["code-block"],
                prefix: /\n\n$/,
                suffix: /^\s+$/,
                handler: function handler(range2) {
                  var _quill$getLine9 = this.quill.getLine(range2.index), _quill$getLine10 = _slicedToArray2(_quill$getLine9, 2), line = _quill$getLine10[0], offset2 = _quill$getLine10[1];
                  var delta2 = new _quillDelta2.default().retain(range2.index + line.length() - offset2 - 2).retain(1, { "code-block": null }).delete(1);
                  this.quill.updateContents(delta2, _quill2.default.sources.USER);
                }
              },
              "embed left": makeEmbedArrowHandler(Keyboard.keys.LEFT, false),
              "embed left shift": makeEmbedArrowHandler(Keyboard.keys.LEFT, true),
              "embed right": makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),
              "embed right shift": makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)
            }
          };
          function makeEmbedArrowHandler(key, shiftKey) {
            var _ref3;
            var where = key === Keyboard.keys.LEFT ? "prefix" : "suffix";
            return _ref3 = {
              key,
              shiftKey,
              altKey: null
            }, _defineProperty2(_ref3, where, /^$/), _defineProperty2(_ref3, "handler", function handler(range2) {
              var index2 = range2.index;
              if (key === Keyboard.keys.RIGHT) {
                index2 += range2.length + 1;
              }
              var _quill$getLeaf3 = this.quill.getLeaf(index2), _quill$getLeaf4 = _slicedToArray2(_quill$getLeaf3, 1), leaf = _quill$getLeaf4[0];
              if (!(leaf instanceof _parchment2.default.Embed)) return true;
              if (key === Keyboard.keys.LEFT) {
                if (shiftKey) {
                  this.quill.setSelection(range2.index - 1, range2.length + 1, _quill2.default.sources.USER);
                } else {
                  this.quill.setSelection(range2.index - 1, _quill2.default.sources.USER);
                }
              } else {
                if (shiftKey) {
                  this.quill.setSelection(range2.index, range2.length + 1, _quill2.default.sources.USER);
                } else {
                  this.quill.setSelection(range2.index + range2.length + 1, _quill2.default.sources.USER);
                }
              }
              return false;
            }), _ref3;
          }
          function handleBackspace(range2, context2) {
            if (range2.index === 0 || this.quill.getLength() <= 1) return;
            var _quill$getLine11 = this.quill.getLine(range2.index), _quill$getLine12 = _slicedToArray2(_quill$getLine11, 1), line = _quill$getLine12[0];
            var formats = {};
            if (context2.offset === 0) {
              var _quill$getLine13 = this.quill.getLine(range2.index - 1), _quill$getLine14 = _slicedToArray2(_quill$getLine13, 1), prev = _quill$getLine14[0];
              if (prev != null && prev.length() > 1) {
                var curFormats = line.formats();
                var prevFormats = this.quill.getFormat(range2.index - 1, 1);
                formats = _op2.default.attributes.diff(curFormats, prevFormats) || {};
              }
            }
            var length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context2.prefix) ? 2 : 1;
            this.quill.deleteText(range2.index - length, length, _quill2.default.sources.USER);
            if (Object.keys(formats).length > 0) {
              this.quill.formatLine(range2.index - length, length, formats, _quill2.default.sources.USER);
            }
            this.quill.focus();
          }
          function handleDelete(range2, context2) {
            var length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context2.suffix) ? 2 : 1;
            if (range2.index >= this.quill.getLength() - length) return;
            var formats = {}, nextLength = 0;
            var _quill$getLine15 = this.quill.getLine(range2.index), _quill$getLine16 = _slicedToArray2(_quill$getLine15, 1), line = _quill$getLine16[0];
            if (context2.offset >= line.length() - 1) {
              var _quill$getLine17 = this.quill.getLine(range2.index + 1), _quill$getLine18 = _slicedToArray2(_quill$getLine17, 1), next = _quill$getLine18[0];
              if (next) {
                var curFormats = line.formats();
                var nextFormats = this.quill.getFormat(range2.index, 1);
                formats = _op2.default.attributes.diff(curFormats, nextFormats) || {};
                nextLength = next.length();
              }
            }
            this.quill.deleteText(range2.index, length, _quill2.default.sources.USER);
            if (Object.keys(formats).length > 0) {
              this.quill.formatLine(range2.index + nextLength - 1, length, formats, _quill2.default.sources.USER);
            }
          }
          function handleDeleteRange(range2) {
            var lines = this.quill.getLines(range2);
            var formats = {};
            if (lines.length > 1) {
              var firstFormats = lines[0].formats();
              var lastFormats = lines[lines.length - 1].formats();
              formats = _op2.default.attributes.diff(lastFormats, firstFormats) || {};
            }
            this.quill.deleteText(range2, _quill2.default.sources.USER);
            if (Object.keys(formats).length > 0) {
              this.quill.formatLine(range2.index, 1, formats, _quill2.default.sources.USER);
            }
            this.quill.setSelection(range2.index, _quill2.default.sources.SILENT);
            this.quill.focus();
          }
          function handleEnter(range2, context2) {
            var _this3 = this;
            if (range2.length > 0) {
              this.quill.scroll.deleteAt(range2.index, range2.length);
            }
            var lineFormats = Object.keys(context2.format).reduce(function(lineFormats2, format2) {
              if (_parchment2.default.query(format2, _parchment2.default.Scope.BLOCK) && !Array.isArray(context2.format[format2])) {
                lineFormats2[format2] = context2.format[format2];
              }
              return lineFormats2;
            }, {});
            this.quill.insertText(range2.index, "\n", lineFormats, _quill2.default.sources.USER);
            this.quill.setSelection(range2.index + 1, _quill2.default.sources.SILENT);
            this.quill.focus();
            Object.keys(context2.format).forEach(function(name2) {
              if (lineFormats[name2] != null) return;
              if (Array.isArray(context2.format[name2])) return;
              if (name2 === "link") return;
              _this3.quill.format(name2, context2.format[name2], _quill2.default.sources.USER);
            });
          }
          function makeCodeBlockHandler(indent) {
            return {
              key: Keyboard.keys.TAB,
              shiftKey: !indent,
              format: { "code-block": true },
              handler: function handler(range2) {
                var CodeBlock = _parchment2.default.query("code-block");
                var index2 = range2.index, length = range2.length;
                var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index2), _quill$scroll$descend2 = _slicedToArray2(_quill$scroll$descend, 2), block = _quill$scroll$descend2[0], offset2 = _quill$scroll$descend2[1];
                if (block == null) return;
                var scrollIndex = this.quill.getIndex(block);
                var start = block.newlineIndex(offset2, true) + 1;
                var end = block.newlineIndex(scrollIndex + offset2 + length);
                var lines = block.domNode.textContent.slice(start, end).split("\n");
                offset2 = 0;
                lines.forEach(function(line, i2) {
                  if (indent) {
                    block.insertAt(start + offset2, CodeBlock.TAB);
                    offset2 += CodeBlock.TAB.length;
                    if (i2 === 0) {
                      index2 += CodeBlock.TAB.length;
                    } else {
                      length += CodeBlock.TAB.length;
                    }
                  } else if (line.startsWith(CodeBlock.TAB)) {
                    block.deleteAt(start + offset2, CodeBlock.TAB.length);
                    offset2 -= CodeBlock.TAB.length;
                    if (i2 === 0) {
                      index2 -= CodeBlock.TAB.length;
                    } else {
                      length -= CodeBlock.TAB.length;
                    }
                  }
                  offset2 += line.length + 1;
                });
                this.quill.update(_quill2.default.sources.USER);
                this.quill.setSelection(index2, length, _quill2.default.sources.SILENT);
              }
            };
          }
          function makeFormatHandler(format2) {
            return {
              key: format2[0].toUpperCase(),
              shortKey: true,
              handler: function handler(range2, context2) {
                this.quill.format(format2, !context2.format[format2], _quill2.default.sources.USER);
              }
            };
          }
          function normalize(binding) {
            if (typeof binding === "string" || typeof binding === "number") {
              return normalize({ key: binding });
            }
            if ((typeof binding === "undefined" ? "undefined" : _typeof2(binding)) === "object") {
              binding = (0, _clone2.default)(binding, false);
            }
            if (typeof binding.key === "string") {
              if (Keyboard.keys[binding.key.toUpperCase()] != null) {
                binding.key = Keyboard.keys[binding.key.toUpperCase()];
              } else if (binding.key.length === 1) {
                binding.key = binding.key.toUpperCase().charCodeAt(0);
              } else {
                return null;
              }
            }
            if (binding.shortKey) {
              binding[SHORTKEY] = binding.shortKey;
              delete binding.shortKey;
            }
            return binding;
          }
          exports3.default = Keyboard;
          exports3.SHORTKEY = SHORTKEY;
        },
        /* 24 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _slicedToArray2 = /* @__PURE__ */ function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _text = __webpack_require__(7);
          var _text2 = _interopRequireDefault2(_text);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Cursor = function(_Parchment$Embed) {
            _inherits2(Cursor2, _Parchment$Embed);
            _createClass2(Cursor2, null, [{
              key: "value",
              value: function value() {
                return void 0;
              }
            }]);
            function Cursor2(domNode, selection) {
              _classCallCheck2(this, Cursor2);
              var _this = _possibleConstructorReturn2(this, (Cursor2.__proto__ || Object.getPrototypeOf(Cursor2)).call(this, domNode));
              _this.selection = selection;
              _this.textNode = document.createTextNode(Cursor2.CONTENTS);
              _this.domNode.appendChild(_this.textNode);
              _this._length = 0;
              return _this;
            }
            _createClass2(Cursor2, [{
              key: "detach",
              value: function detach() {
                if (this.parent != null) this.parent.removeChild(this);
              }
            }, {
              key: "format",
              value: function format2(name2, value) {
                if (this._length !== 0) {
                  return _get2(Cursor2.prototype.__proto__ || Object.getPrototypeOf(Cursor2.prototype), "format", this).call(this, name2, value);
                }
                var target = this, index2 = 0;
                while (target != null && target.statics.scope !== _parchment2.default.Scope.BLOCK_BLOT) {
                  index2 += target.offset(target.parent);
                  target = target.parent;
                }
                if (target != null) {
                  this._length = Cursor2.CONTENTS.length;
                  target.optimize();
                  target.formatAt(index2, Cursor2.CONTENTS.length, name2, value);
                  this._length = 0;
                }
              }
            }, {
              key: "index",
              value: function index2(node, offset2) {
                if (node === this.textNode) return 0;
                return _get2(Cursor2.prototype.__proto__ || Object.getPrototypeOf(Cursor2.prototype), "index", this).call(this, node, offset2);
              }
            }, {
              key: "length",
              value: function length() {
                return this._length;
              }
            }, {
              key: "position",
              value: function position() {
                return [this.textNode, this.textNode.data.length];
              }
            }, {
              key: "remove",
              value: function remove3() {
                _get2(Cursor2.prototype.__proto__ || Object.getPrototypeOf(Cursor2.prototype), "remove", this).call(this);
                this.parent = null;
              }
            }, {
              key: "restore",
              value: function restore() {
                if (this.selection.composing || this.parent == null) return;
                var textNode = this.textNode;
                var range2 = this.selection.getNativeRange();
                var restoreText = void 0, start = void 0, end = void 0;
                if (range2 != null && range2.start.node === textNode && range2.end.node === textNode) {
                  var _ref = [textNode, range2.start.offset, range2.end.offset];
                  restoreText = _ref[0];
                  start = _ref[1];
                  end = _ref[2];
                }
                while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
                  this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
                }
                if (this.textNode.data !== Cursor2.CONTENTS) {
                  var text = this.textNode.data.split(Cursor2.CONTENTS).join("");
                  if (this.next instanceof _text2.default) {
                    restoreText = this.next.domNode;
                    this.next.insertAt(0, text);
                    this.textNode.data = Cursor2.CONTENTS;
                  } else {
                    this.textNode.data = text;
                    this.parent.insertBefore(_parchment2.default.create(this.textNode), this);
                    this.textNode = document.createTextNode(Cursor2.CONTENTS);
                    this.domNode.appendChild(this.textNode);
                  }
                }
                this.remove();
                if (start != null) {
                  var _map = [start, end].map(function(offset2) {
                    return Math.max(0, Math.min(restoreText.data.length, offset2 - 1));
                  });
                  var _map22 = _slicedToArray2(_map, 2);
                  start = _map22[0];
                  end = _map22[1];
                  return {
                    startNode: restoreText,
                    startOffset: start,
                    endNode: restoreText,
                    endOffset: end
                  };
                }
              }
            }, {
              key: "update",
              value: function update8(mutations, context2) {
                var _this2 = this;
                if (mutations.some(function(mutation) {
                  return mutation.type === "characterData" && mutation.target === _this2.textNode;
                })) {
                  var range2 = this.restore();
                  if (range2) context2.range = range2;
                }
              }
            }, {
              key: "value",
              value: function value() {
                return "";
              }
            }]);
            return Cursor2;
          }(_parchment2.default.Embed);
          Cursor.blotName = "cursor";
          Cursor.className = "ql-cursor";
          Cursor.tagName = "span";
          Cursor.CONTENTS = "\uFEFF";
          exports3.default = Cursor;
        },
        /* 25 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Container = function(_Parchment$Container) {
            _inherits2(Container2, _Parchment$Container);
            function Container2() {
              _classCallCheck2(this, Container2);
              return _possibleConstructorReturn2(this, (Container2.__proto__ || Object.getPrototypeOf(Container2)).apply(this, arguments));
            }
            return Container2;
          }(_parchment2.default.Container);
          Container.allowedChildren = [_block2.default, _block.BlockEmbed, Container];
          exports3.default = Container;
        },
        /* 26 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.ColorStyle = exports3.ColorClass = exports3.ColorAttributor = void 0;
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var ColorAttributor = function(_Parchment$Attributor) {
            _inherits2(ColorAttributor2, _Parchment$Attributor);
            function ColorAttributor2() {
              _classCallCheck2(this, ColorAttributor2);
              return _possibleConstructorReturn2(this, (ColorAttributor2.__proto__ || Object.getPrototypeOf(ColorAttributor2)).apply(this, arguments));
            }
            _createClass2(ColorAttributor2, [{
              key: "value",
              value: function value(domNode) {
                var value2 = _get2(ColorAttributor2.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor2.prototype), "value", this).call(this, domNode);
                if (!value2.startsWith("rgb(")) return value2;
                value2 = value2.replace(/^[^\d]+/, "").replace(/[^\d]+$/, "");
                return "#" + value2.split(",").map(function(component) {
                  return ("00" + parseInt(component).toString(16)).slice(-2);
                }).join("");
              }
            }]);
            return ColorAttributor2;
          }(_parchment2.default.Attributor.Style);
          var ColorClass = new _parchment2.default.Attributor.Class("color", "ql-color", {
            scope: _parchment2.default.Scope.INLINE
          });
          var ColorStyle = new ColorAttributor("color", "color", {
            scope: _parchment2.default.Scope.INLINE
          });
          exports3.ColorAttributor = ColorAttributor;
          exports3.ColorClass = ColorClass;
          exports3.ColorStyle = ColorStyle;
        },
        /* 27 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.sanitize = exports3.default = void 0;
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Link = function(_Inline) {
            _inherits2(Link2, _Inline);
            function Link2() {
              _classCallCheck2(this, Link2);
              return _possibleConstructorReturn2(this, (Link2.__proto__ || Object.getPrototypeOf(Link2)).apply(this, arguments));
            }
            _createClass2(Link2, [{
              key: "format",
              value: function format2(name2, value) {
                if (name2 !== this.statics.blotName || !value) return _get2(Link2.prototype.__proto__ || Object.getPrototypeOf(Link2.prototype), "format", this).call(this, name2, value);
                value = this.constructor.sanitize(value);
                this.domNode.setAttribute("href", value);
              }
            }], [{
              key: "create",
              value: function create(value) {
                var node = _get2(Link2.__proto__ || Object.getPrototypeOf(Link2), "create", this).call(this, value);
                value = this.sanitize(value);
                node.setAttribute("href", value);
                node.setAttribute("rel", "noopener noreferrer");
                node.setAttribute("target", "_blank");
                return node;
              }
            }, {
              key: "formats",
              value: function formats(domNode) {
                return domNode.getAttribute("href");
              }
            }, {
              key: "sanitize",
              value: function sanitize(url) {
                return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
              }
            }]);
            return Link2;
          }(_inline2.default);
          Link.blotName = "link";
          Link.tagName = "A";
          Link.SANITIZED_URL = "about:blank";
          Link.PROTOCOL_WHITELIST = ["http", "https", "mailto", "tel"];
          function _sanitize(url, protocols) {
            var anchor = document.createElement("a");
            anchor.href = url;
            var protocol = anchor.href.slice(0, anchor.href.indexOf(":"));
            return protocols.indexOf(protocol) > -1;
          }
          exports3.default = Link;
          exports3.sanitize = _sanitize;
        },
        /* 28 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _keyboard = __webpack_require__(23);
          var _keyboard2 = _interopRequireDefault2(_keyboard);
          var _dropdown = __webpack_require__(107);
          var _dropdown2 = _interopRequireDefault2(_dropdown);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var optionsCounter = 0;
          function toggleAriaAttribute(element, attribute) {
            element.setAttribute(attribute, !(element.getAttribute(attribute) === "true"));
          }
          var Picker = function() {
            function Picker2(select) {
              var _this = this;
              _classCallCheck2(this, Picker2);
              this.select = select;
              this.container = document.createElement("span");
              this.buildPicker();
              this.select.style.display = "none";
              this.select.parentNode.insertBefore(this.container, this.select);
              this.label.addEventListener("mousedown", function() {
                _this.togglePicker();
              });
              this.label.addEventListener("keydown", function(event) {
                switch (event.keyCode) {
                  case _keyboard2.default.keys.ENTER:
                    _this.togglePicker();
                    break;
                  case _keyboard2.default.keys.ESCAPE:
                    _this.escape();
                    event.preventDefault();
                    break;
                }
              });
              this.select.addEventListener("change", this.update.bind(this));
            }
            _createClass2(Picker2, [{
              key: "togglePicker",
              value: function togglePicker() {
                this.container.classList.toggle("ql-expanded");
                toggleAriaAttribute(this.label, "aria-expanded");
                toggleAriaAttribute(this.options, "aria-hidden");
              }
            }, {
              key: "buildItem",
              value: function buildItem(option) {
                var _this2 = this;
                var item = document.createElement("span");
                item.tabIndex = "0";
                item.setAttribute("role", "button");
                item.classList.add("ql-picker-item");
                if (option.hasAttribute("value")) {
                  item.setAttribute("data-value", option.getAttribute("value"));
                }
                if (option.textContent) {
                  item.setAttribute("data-label", option.textContent);
                }
                item.addEventListener("click", function() {
                  _this2.selectItem(item, true);
                });
                item.addEventListener("keydown", function(event) {
                  switch (event.keyCode) {
                    case _keyboard2.default.keys.ENTER:
                      _this2.selectItem(item, true);
                      event.preventDefault();
                      break;
                    case _keyboard2.default.keys.ESCAPE:
                      _this2.escape();
                      event.preventDefault();
                      break;
                  }
                });
                return item;
              }
            }, {
              key: "buildLabel",
              value: function buildLabel() {
                var label2 = document.createElement("span");
                label2.classList.add("ql-picker-label");
                label2.innerHTML = _dropdown2.default;
                label2.tabIndex = "0";
                label2.setAttribute("role", "button");
                label2.setAttribute("aria-expanded", "false");
                this.container.appendChild(label2);
                return label2;
              }
            }, {
              key: "buildOptions",
              value: function buildOptions3() {
                var _this3 = this;
                var options = document.createElement("span");
                options.classList.add("ql-picker-options");
                options.setAttribute("aria-hidden", "true");
                options.tabIndex = "-1";
                options.id = "ql-picker-options-" + optionsCounter;
                optionsCounter += 1;
                this.label.setAttribute("aria-controls", options.id);
                this.options = options;
                [].slice.call(this.select.options).forEach(function(option) {
                  var item = _this3.buildItem(option);
                  options.appendChild(item);
                  if (option.selected === true) {
                    _this3.selectItem(item);
                  }
                });
                this.container.appendChild(options);
              }
            }, {
              key: "buildPicker",
              value: function buildPicker() {
                var _this4 = this;
                [].slice.call(this.select.attributes).forEach(function(item) {
                  _this4.container.setAttribute(item.name, item.value);
                });
                this.container.classList.add("ql-picker");
                this.label = this.buildLabel();
                this.buildOptions();
              }
            }, {
              key: "escape",
              value: function escape2() {
                var _this5 = this;
                this.close();
                setTimeout(function() {
                  return _this5.label.focus();
                }, 1);
              }
            }, {
              key: "close",
              value: function close2() {
                this.container.classList.remove("ql-expanded");
                this.label.setAttribute("aria-expanded", "false");
                this.options.setAttribute("aria-hidden", "true");
              }
            }, {
              key: "selectItem",
              value: function selectItem(item) {
                var trigger = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                var selected = this.container.querySelector(".ql-selected");
                if (item === selected) return;
                if (selected != null) {
                  selected.classList.remove("ql-selected");
                }
                if (item == null) return;
                item.classList.add("ql-selected");
                this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);
                if (item.hasAttribute("data-value")) {
                  this.label.setAttribute("data-value", item.getAttribute("data-value"));
                } else {
                  this.label.removeAttribute("data-value");
                }
                if (item.hasAttribute("data-label")) {
                  this.label.setAttribute("data-label", item.getAttribute("data-label"));
                } else {
                  this.label.removeAttribute("data-label");
                }
                if (trigger) {
                  if (typeof Event === "function") {
                    this.select.dispatchEvent(new Event("change"));
                  } else if ((typeof Event === "undefined" ? "undefined" : _typeof2(Event)) === "object") {
                    var event = document.createEvent("Event");
                    event.initEvent("change", true, true);
                    this.select.dispatchEvent(event);
                  }
                  this.close();
                }
              }
            }, {
              key: "update",
              value: function update8() {
                var option = void 0;
                if (this.select.selectedIndex > -1) {
                  var item = this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex];
                  option = this.select.options[this.select.selectedIndex];
                  this.selectItem(item);
                } else {
                  this.selectItem(null);
                }
                var isActive = option != null && option !== this.select.querySelector("option[selected]");
                this.label.classList.toggle("ql-active", isActive);
              }
            }]);
            return Picker2;
          }();
          exports3.default = Picker;
        },
        /* 29 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _quill = __webpack_require__(5);
          var _quill2 = _interopRequireDefault2(_quill);
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          var _break = __webpack_require__(16);
          var _break2 = _interopRequireDefault2(_break);
          var _container = __webpack_require__(25);
          var _container2 = _interopRequireDefault2(_container);
          var _cursor = __webpack_require__(24);
          var _cursor2 = _interopRequireDefault2(_cursor);
          var _embed = __webpack_require__(35);
          var _embed2 = _interopRequireDefault2(_embed);
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          var _scroll = __webpack_require__(22);
          var _scroll2 = _interopRequireDefault2(_scroll);
          var _text = __webpack_require__(7);
          var _text2 = _interopRequireDefault2(_text);
          var _clipboard = __webpack_require__(55);
          var _clipboard2 = _interopRequireDefault2(_clipboard);
          var _history = __webpack_require__(42);
          var _history2 = _interopRequireDefault2(_history);
          var _keyboard = __webpack_require__(23);
          var _keyboard2 = _interopRequireDefault2(_keyboard);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          _quill2.default.register({
            "blots/block": _block2.default,
            "blots/block/embed": _block.BlockEmbed,
            "blots/break": _break2.default,
            "blots/container": _container2.default,
            "blots/cursor": _cursor2.default,
            "blots/embed": _embed2.default,
            "blots/inline": _inline2.default,
            "blots/scroll": _scroll2.default,
            "blots/text": _text2.default,
            "modules/clipboard": _clipboard2.default,
            "modules/history": _history2.default,
            "modules/keyboard": _keyboard2.default
          });
          _parchment2.default.register(_block2.default, _break2.default, _cursor2.default, _inline2.default, _scroll2.default, _text2.default);
          exports3.default = _quill2.default;
        },
        /* 30 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var Registry = __webpack_require__(1);
          var ShadowBlot = (
            /** @class */
            function() {
              function ShadowBlot2(domNode) {
                this.domNode = domNode;
                this.domNode[Registry.DATA_KEY] = { blot: this };
              }
              Object.defineProperty(ShadowBlot2.prototype, "statics", {
                // Hack for accessing inherited static methods
                get: function() {
                  return this.constructor;
                },
                enumerable: true,
                configurable: true
              });
              ShadowBlot2.create = function(value) {
                if (this.tagName == null) {
                  throw new Registry.ParchmentError("Blot definition missing tagName");
                }
                var node;
                if (Array.isArray(this.tagName)) {
                  if (typeof value === "string") {
                    value = value.toUpperCase();
                    if (parseInt(value).toString() === value) {
                      value = parseInt(value);
                    }
                  }
                  if (typeof value === "number") {
                    node = document.createElement(this.tagName[value - 1]);
                  } else if (this.tagName.indexOf(value) > -1) {
                    node = document.createElement(value);
                  } else {
                    node = document.createElement(this.tagName[0]);
                  }
                } else {
                  node = document.createElement(this.tagName);
                }
                if (this.className) {
                  node.classList.add(this.className);
                }
                return node;
              };
              ShadowBlot2.prototype.attach = function() {
                if (this.parent != null) {
                  this.scroll = this.parent.scroll;
                }
              };
              ShadowBlot2.prototype.clone = function() {
                var domNode = this.domNode.cloneNode(false);
                return Registry.create(domNode);
              };
              ShadowBlot2.prototype.detach = function() {
                if (this.parent != null)
                  this.parent.removeChild(this);
                delete this.domNode[Registry.DATA_KEY];
              };
              ShadowBlot2.prototype.deleteAt = function(index2, length) {
                var blot = this.isolate(index2, length);
                blot.remove();
              };
              ShadowBlot2.prototype.formatAt = function(index2, length, name2, value) {
                var blot = this.isolate(index2, length);
                if (Registry.query(name2, Registry.Scope.BLOT) != null && value) {
                  blot.wrap(name2, value);
                } else if (Registry.query(name2, Registry.Scope.ATTRIBUTE) != null) {
                  var parent2 = Registry.create(this.statics.scope);
                  blot.wrap(parent2);
                  parent2.format(name2, value);
                }
              };
              ShadowBlot2.prototype.insertAt = function(index2, value, def) {
                var blot = def == null ? Registry.create("text", value) : Registry.create(value, def);
                var ref2 = this.split(index2);
                this.parent.insertBefore(blot, ref2);
              };
              ShadowBlot2.prototype.insertInto = function(parentBlot, refBlot) {
                if (refBlot === void 0) {
                  refBlot = null;
                }
                if (this.parent != null) {
                  this.parent.children.remove(this);
                }
                var refDomNode = null;
                parentBlot.children.insertBefore(this, refBlot);
                if (refBlot != null) {
                  refDomNode = refBlot.domNode;
                }
                if (this.domNode.parentNode != parentBlot.domNode || this.domNode.nextSibling != refDomNode) {
                  parentBlot.domNode.insertBefore(this.domNode, refDomNode);
                }
                this.parent = parentBlot;
                this.attach();
              };
              ShadowBlot2.prototype.isolate = function(index2, length) {
                var target = this.split(index2);
                target.split(length);
                return target;
              };
              ShadowBlot2.prototype.length = function() {
                return 1;
              };
              ShadowBlot2.prototype.offset = function(root2) {
                if (root2 === void 0) {
                  root2 = this.parent;
                }
                if (this.parent == null || this == root2)
                  return 0;
                return this.parent.children.offset(this) + this.parent.offset(root2);
              };
              ShadowBlot2.prototype.optimize = function(context2) {
                if (this.domNode[Registry.DATA_KEY] != null) {
                  delete this.domNode[Registry.DATA_KEY].mutations;
                }
              };
              ShadowBlot2.prototype.remove = function() {
                if (this.domNode.parentNode != null) {
                  this.domNode.parentNode.removeChild(this.domNode);
                }
                this.detach();
              };
              ShadowBlot2.prototype.replace = function(target) {
                if (target.parent == null)
                  return;
                target.parent.insertBefore(this, target.next);
                target.remove();
              };
              ShadowBlot2.prototype.replaceWith = function(name2, value) {
                var replacement = typeof name2 === "string" ? Registry.create(name2, value) : name2;
                replacement.replace(this);
                return replacement;
              };
              ShadowBlot2.prototype.split = function(index2, force) {
                return index2 === 0 ? this : this.next;
              };
              ShadowBlot2.prototype.update = function(mutations, context2) {
              };
              ShadowBlot2.prototype.wrap = function(name2, value) {
                var wrapper = typeof name2 === "string" ? Registry.create(name2, value) : name2;
                if (this.parent != null) {
                  this.parent.insertBefore(wrapper, this.next);
                }
                wrapper.appendChild(this);
                return wrapper;
              };
              ShadowBlot2.blotName = "abstract";
              return ShadowBlot2;
            }()
          );
          exports3.default = ShadowBlot;
        },
        /* 31 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var attributor_1 = __webpack_require__(12);
          var class_1 = __webpack_require__(32);
          var style_1 = __webpack_require__(33);
          var Registry = __webpack_require__(1);
          var AttributorStore = (
            /** @class */
            function() {
              function AttributorStore2(domNode) {
                this.attributes = {};
                this.domNode = domNode;
                this.build();
              }
              AttributorStore2.prototype.attribute = function(attribute, value) {
                if (value) {
                  if (attribute.add(this.domNode, value)) {
                    if (attribute.value(this.domNode) != null) {
                      this.attributes[attribute.attrName] = attribute;
                    } else {
                      delete this.attributes[attribute.attrName];
                    }
                  }
                } else {
                  attribute.remove(this.domNode);
                  delete this.attributes[attribute.attrName];
                }
              };
              AttributorStore2.prototype.build = function() {
                var _this = this;
                this.attributes = {};
                var attributes = attributor_1.default.keys(this.domNode);
                var classes = class_1.default.keys(this.domNode);
                var styles2 = style_1.default.keys(this.domNode);
                attributes.concat(classes).concat(styles2).forEach(function(name2) {
                  var attr = Registry.query(name2, Registry.Scope.ATTRIBUTE);
                  if (attr instanceof attributor_1.default) {
                    _this.attributes[attr.attrName] = attr;
                  }
                });
              };
              AttributorStore2.prototype.copy = function(target) {
                var _this = this;
                Object.keys(this.attributes).forEach(function(key) {
                  var value = _this.attributes[key].value(_this.domNode);
                  target.format(key, value);
                });
              };
              AttributorStore2.prototype.move = function(target) {
                var _this = this;
                this.copy(target);
                Object.keys(this.attributes).forEach(function(key) {
                  _this.attributes[key].remove(_this.domNode);
                });
                this.attributes = {};
              };
              AttributorStore2.prototype.values = function() {
                var _this = this;
                return Object.keys(this.attributes).reduce(function(attributes, name2) {
                  attributes[name2] = _this.attributes[name2].value(_this.domNode);
                  return attributes;
                }, {});
              };
              return AttributorStore2;
            }()
          );
          exports3.default = AttributorStore;
        },
        /* 32 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
              d.__proto__ = b;
            } || function(d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var attributor_1 = __webpack_require__(12);
          function match(node, prefix) {
            var className = node.getAttribute("class") || "";
            return className.split(/\s+/).filter(function(name2) {
              return name2.indexOf(prefix + "-") === 0;
            });
          }
          var ClassAttributor = (
            /** @class */
            function(_super) {
              __extends2(ClassAttributor2, _super);
              function ClassAttributor2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              ClassAttributor2.keys = function(node) {
                return (node.getAttribute("class") || "").split(/\s+/).map(function(name2) {
                  return name2.split("-").slice(0, -1).join("-");
                });
              };
              ClassAttributor2.prototype.add = function(node, value) {
                if (!this.canAdd(node, value))
                  return false;
                this.remove(node);
                node.classList.add(this.keyName + "-" + value);
                return true;
              };
              ClassAttributor2.prototype.remove = function(node) {
                var matches = match(node, this.keyName);
                matches.forEach(function(name2) {
                  node.classList.remove(name2);
                });
                if (node.classList.length === 0) {
                  node.removeAttribute("class");
                }
              };
              ClassAttributor2.prototype.value = function(node) {
                var result = match(node, this.keyName)[0] || "";
                var value = result.slice(this.keyName.length + 1);
                return this.canAdd(node, value) ? value : "";
              };
              return ClassAttributor2;
            }(attributor_1.default)
          );
          exports3.default = ClassAttributor;
        },
        /* 33 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
              d.__proto__ = b;
            } || function(d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var attributor_1 = __webpack_require__(12);
          function camelize(name2) {
            var parts = name2.split("-");
            var rest2 = parts.slice(1).map(function(part) {
              return part[0].toUpperCase() + part.slice(1);
            }).join("");
            return parts[0] + rest2;
          }
          var StyleAttributor = (
            /** @class */
            function(_super) {
              __extends2(StyleAttributor2, _super);
              function StyleAttributor2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              StyleAttributor2.keys = function(node) {
                return (node.getAttribute("style") || "").split(";").map(function(value) {
                  var arr = value.split(":");
                  return arr[0].trim();
                });
              };
              StyleAttributor2.prototype.add = function(node, value) {
                if (!this.canAdd(node, value))
                  return false;
                node.style[camelize(this.keyName)] = value;
                return true;
              };
              StyleAttributor2.prototype.remove = function(node) {
                node.style[camelize(this.keyName)] = "";
                if (!node.getAttribute("style")) {
                  node.removeAttribute("style");
                }
              };
              StyleAttributor2.prototype.value = function(node) {
                var value = node.style[camelize(this.keyName)];
                return this.canAdd(node, value) ? value : "";
              };
              return StyleAttributor2;
            }(attributor_1.default)
          );
          exports3.default = StyleAttributor;
        },
        /* 34 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var Theme = function() {
            function Theme2(quill2, options) {
              _classCallCheck2(this, Theme2);
              this.quill = quill2;
              this.options = options;
              this.modules = {};
            }
            _createClass2(Theme2, [{
              key: "init",
              value: function init2() {
                var _this = this;
                Object.keys(this.options.modules).forEach(function(name2) {
                  if (_this.modules[name2] == null) {
                    _this.addModule(name2);
                  }
                });
              }
            }, {
              key: "addModule",
              value: function addModule(name2) {
                var moduleClass = this.quill.constructor.import("modules/" + name2);
                this.modules[name2] = new moduleClass(this.quill, this.options.modules[name2] || {});
                return this.modules[name2];
              }
            }]);
            return Theme2;
          }();
          Theme.DEFAULTS = {
            modules: {}
          };
          Theme.themes = {
            "default": Theme
          };
          exports3.default = Theme;
        },
        /* 35 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _text = __webpack_require__(7);
          var _text2 = _interopRequireDefault2(_text);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var GUARD_TEXT = "\uFEFF";
          var Embed2 = function(_Parchment$Embed) {
            _inherits2(Embed3, _Parchment$Embed);
            function Embed3(node) {
              _classCallCheck2(this, Embed3);
              var _this = _possibleConstructorReturn2(this, (Embed3.__proto__ || Object.getPrototypeOf(Embed3)).call(this, node));
              _this.contentNode = document.createElement("span");
              _this.contentNode.setAttribute("contenteditable", false);
              [].slice.call(_this.domNode.childNodes).forEach(function(childNode) {
                _this.contentNode.appendChild(childNode);
              });
              _this.leftGuard = document.createTextNode(GUARD_TEXT);
              _this.rightGuard = document.createTextNode(GUARD_TEXT);
              _this.domNode.appendChild(_this.leftGuard);
              _this.domNode.appendChild(_this.contentNode);
              _this.domNode.appendChild(_this.rightGuard);
              return _this;
            }
            _createClass2(Embed3, [{
              key: "index",
              value: function index2(node, offset2) {
                if (node === this.leftGuard) return 0;
                if (node === this.rightGuard) return 1;
                return _get2(Embed3.prototype.__proto__ || Object.getPrototypeOf(Embed3.prototype), "index", this).call(this, node, offset2);
              }
            }, {
              key: "restore",
              value: function restore(node) {
                var range2 = void 0, textNode = void 0;
                var text = node.data.split(GUARD_TEXT).join("");
                if (node === this.leftGuard) {
                  if (this.prev instanceof _text2.default) {
                    var prevLength = this.prev.length();
                    this.prev.insertAt(prevLength, text);
                    range2 = {
                      startNode: this.prev.domNode,
                      startOffset: prevLength + text.length
                    };
                  } else {
                    textNode = document.createTextNode(text);
                    this.parent.insertBefore(_parchment2.default.create(textNode), this);
                    range2 = {
                      startNode: textNode,
                      startOffset: text.length
                    };
                  }
                } else if (node === this.rightGuard) {
                  if (this.next instanceof _text2.default) {
                    this.next.insertAt(0, text);
                    range2 = {
                      startNode: this.next.domNode,
                      startOffset: text.length
                    };
                  } else {
                    textNode = document.createTextNode(text);
                    this.parent.insertBefore(_parchment2.default.create(textNode), this.next);
                    range2 = {
                      startNode: textNode,
                      startOffset: text.length
                    };
                  }
                }
                node.data = GUARD_TEXT;
                return range2;
              }
            }, {
              key: "update",
              value: function update8(mutations, context2) {
                var _this2 = this;
                mutations.forEach(function(mutation) {
                  if (mutation.type === "characterData" && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {
                    var range2 = _this2.restore(mutation.target);
                    if (range2) context2.range = range2;
                  }
                });
              }
            }]);
            return Embed3;
          }(_parchment2.default.Embed);
          exports3.default = Embed2;
        },
        /* 36 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.AlignStyle = exports3.AlignClass = exports3.AlignAttribute = void 0;
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var config2 = {
            scope: _parchment2.default.Scope.BLOCK,
            whitelist: ["right", "center", "justify"]
          };
          var AlignAttribute = new _parchment2.default.Attributor.Attribute("align", "align", config2);
          var AlignClass = new _parchment2.default.Attributor.Class("align", "ql-align", config2);
          var AlignStyle = new _parchment2.default.Attributor.Style("align", "text-align", config2);
          exports3.AlignAttribute = AlignAttribute;
          exports3.AlignClass = AlignClass;
          exports3.AlignStyle = AlignStyle;
        },
        /* 37 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.BackgroundStyle = exports3.BackgroundClass = void 0;
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _color = __webpack_require__(26);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var BackgroundClass = new _parchment2.default.Attributor.Class("background", "ql-bg", {
            scope: _parchment2.default.Scope.INLINE
          });
          var BackgroundStyle = new _color.ColorAttributor("background", "background-color", {
            scope: _parchment2.default.Scope.INLINE
          });
          exports3.BackgroundClass = BackgroundClass;
          exports3.BackgroundStyle = BackgroundStyle;
        },
        /* 38 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.DirectionStyle = exports3.DirectionClass = exports3.DirectionAttribute = void 0;
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var config2 = {
            scope: _parchment2.default.Scope.BLOCK,
            whitelist: ["rtl"]
          };
          var DirectionAttribute = new _parchment2.default.Attributor.Attribute("direction", "dir", config2);
          var DirectionClass = new _parchment2.default.Attributor.Class("direction", "ql-direction", config2);
          var DirectionStyle = new _parchment2.default.Attributor.Style("direction", "direction", config2);
          exports3.DirectionAttribute = DirectionAttribute;
          exports3.DirectionClass = DirectionClass;
          exports3.DirectionStyle = DirectionStyle;
        },
        /* 39 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.FontClass = exports3.FontStyle = void 0;
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var config2 = {
            scope: _parchment2.default.Scope.INLINE,
            whitelist: ["serif", "monospace"]
          };
          var FontClass = new _parchment2.default.Attributor.Class("font", "ql-font", config2);
          var FontStyleAttributor = function(_Parchment$Attributor) {
            _inherits2(FontStyleAttributor2, _Parchment$Attributor);
            function FontStyleAttributor2() {
              _classCallCheck2(this, FontStyleAttributor2);
              return _possibleConstructorReturn2(this, (FontStyleAttributor2.__proto__ || Object.getPrototypeOf(FontStyleAttributor2)).apply(this, arguments));
            }
            _createClass2(FontStyleAttributor2, [{
              key: "value",
              value: function value(node) {
                return _get2(FontStyleAttributor2.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor2.prototype), "value", this).call(this, node).replace(/["']/g, "");
              }
            }]);
            return FontStyleAttributor2;
          }(_parchment2.default.Attributor.Style);
          var FontStyle = new FontStyleAttributor("font", "font-family", config2);
          exports3.FontStyle = FontStyle;
          exports3.FontClass = FontClass;
        },
        /* 40 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.SizeStyle = exports3.SizeClass = void 0;
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var SizeClass = new _parchment2.default.Attributor.Class("size", "ql-size", {
            scope: _parchment2.default.Scope.INLINE,
            whitelist: ["small", "large", "huge"]
          });
          var SizeStyle = new _parchment2.default.Attributor.Style("size", "font-size", {
            scope: _parchment2.default.Scope.INLINE,
            whitelist: ["10px", "18px", "32px"]
          });
          exports3.SizeClass = SizeClass;
          exports3.SizeStyle = SizeStyle;
        },
        /* 41 */
        /***/
        function(module3, exports3, __webpack_require__) {
          module3.exports = {
            "align": {
              "": __webpack_require__(76),
              "center": __webpack_require__(77),
              "right": __webpack_require__(78),
              "justify": __webpack_require__(79)
            },
            "background": __webpack_require__(80),
            "blockquote": __webpack_require__(81),
            "bold": __webpack_require__(82),
            "clean": __webpack_require__(83),
            "code": __webpack_require__(58),
            "code-block": __webpack_require__(58),
            "color": __webpack_require__(84),
            "direction": {
              "": __webpack_require__(85),
              "rtl": __webpack_require__(86)
            },
            "float": {
              "center": __webpack_require__(87),
              "full": __webpack_require__(88),
              "left": __webpack_require__(89),
              "right": __webpack_require__(90)
            },
            "formula": __webpack_require__(91),
            "header": {
              "1": __webpack_require__(92),
              "2": __webpack_require__(93)
            },
            "italic": __webpack_require__(94),
            "image": __webpack_require__(95),
            "indent": {
              "+1": __webpack_require__(96),
              "-1": __webpack_require__(97)
            },
            "link": __webpack_require__(98),
            "list": {
              "ordered": __webpack_require__(99),
              "bullet": __webpack_require__(100),
              "check": __webpack_require__(101)
            },
            "script": {
              "sub": __webpack_require__(102),
              "super": __webpack_require__(103)
            },
            "strike": __webpack_require__(104),
            "underline": __webpack_require__(105),
            "video": __webpack_require__(106)
          };
        },
        /* 42 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.getLastChangeIndex = exports3.default = void 0;
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _quill = __webpack_require__(5);
          var _quill2 = _interopRequireDefault2(_quill);
          var _module = __webpack_require__(9);
          var _module2 = _interopRequireDefault2(_module);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var History = function(_Module) {
            _inherits2(History2, _Module);
            function History2(quill2, options) {
              _classCallCheck2(this, History2);
              var _this = _possibleConstructorReturn2(this, (History2.__proto__ || Object.getPrototypeOf(History2)).call(this, quill2, options));
              _this.lastRecorded = 0;
              _this.ignoreChange = false;
              _this.clear();
              _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function(eventName, delta2, oldDelta, source) {
                if (eventName !== _quill2.default.events.TEXT_CHANGE || _this.ignoreChange) return;
                if (!_this.options.userOnly || source === _quill2.default.sources.USER) {
                  _this.record(delta2, oldDelta);
                } else {
                  _this.transform(delta2);
                }
              });
              _this.quill.keyboard.addBinding({ key: "Z", shortKey: true }, _this.undo.bind(_this));
              _this.quill.keyboard.addBinding({ key: "Z", shortKey: true, shiftKey: true }, _this.redo.bind(_this));
              if (/Win/i.test(navigator.platform)) {
                _this.quill.keyboard.addBinding({ key: "Y", shortKey: true }, _this.redo.bind(_this));
              }
              return _this;
            }
            _createClass2(History2, [{
              key: "change",
              value: function change(source, dest) {
                if (this.stack[source].length === 0) return;
                var delta2 = this.stack[source].pop();
                this.stack[dest].push(delta2);
                this.lastRecorded = 0;
                this.ignoreChange = true;
                this.quill.updateContents(delta2[source], _quill2.default.sources.USER);
                this.ignoreChange = false;
                var index2 = getLastChangeIndex(delta2[source]);
                this.quill.setSelection(index2);
              }
            }, {
              key: "clear",
              value: function clear2() {
                this.stack = { undo: [], redo: [] };
              }
            }, {
              key: "cutoff",
              value: function cutoff() {
                this.lastRecorded = 0;
              }
            }, {
              key: "record",
              value: function record(changeDelta, oldDelta) {
                if (changeDelta.ops.length === 0) return;
                this.stack.redo = [];
                var undoDelta = this.quill.getContents().diff(oldDelta);
                var timestamp = Date.now();
                if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {
                  var delta2 = this.stack.undo.pop();
                  undoDelta = undoDelta.compose(delta2.undo);
                  changeDelta = delta2.redo.compose(changeDelta);
                } else {
                  this.lastRecorded = timestamp;
                }
                this.stack.undo.push({
                  redo: changeDelta,
                  undo: undoDelta
                });
                if (this.stack.undo.length > this.options.maxStack) {
                  this.stack.undo.shift();
                }
              }
            }, {
              key: "redo",
              value: function redo() {
                this.change("redo", "undo");
              }
            }, {
              key: "transform",
              value: function transform2(delta2) {
                this.stack.undo.forEach(function(change) {
                  change.undo = delta2.transform(change.undo, true);
                  change.redo = delta2.transform(change.redo, true);
                });
                this.stack.redo.forEach(function(change) {
                  change.undo = delta2.transform(change.undo, true);
                  change.redo = delta2.transform(change.redo, true);
                });
              }
            }, {
              key: "undo",
              value: function undo() {
                this.change("undo", "redo");
              }
            }]);
            return History2;
          }(_module2.default);
          History.DEFAULTS = {
            delay: 1e3,
            maxStack: 100,
            userOnly: false
          };
          function endsWithNewlineChange(delta2) {
            var lastOp = delta2.ops[delta2.ops.length - 1];
            if (lastOp == null) return false;
            if (lastOp.insert != null) {
              return typeof lastOp.insert === "string" && lastOp.insert.endsWith("\n");
            }
            if (lastOp.attributes != null) {
              return Object.keys(lastOp.attributes).some(function(attr) {
                return _parchment2.default.query(attr, _parchment2.default.Scope.BLOCK) != null;
              });
            }
            return false;
          }
          function getLastChangeIndex(delta2) {
            var deleteLength = delta2.reduce(function(length, op2) {
              length += op2.delete || 0;
              return length;
            }, 0);
            var changeIndex = delta2.length() - deleteLength;
            if (endsWithNewlineChange(delta2)) {
              changeIndex -= 1;
            }
            return changeIndex;
          }
          exports3.default = History;
          exports3.getLastChangeIndex = getLastChangeIndex;
        },
        /* 43 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.BaseTooltip = void 0;
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _extend = __webpack_require__(3);
          var _extend2 = _interopRequireDefault2(_extend);
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _emitter = __webpack_require__(8);
          var _emitter2 = _interopRequireDefault2(_emitter);
          var _keyboard = __webpack_require__(23);
          var _keyboard2 = _interopRequireDefault2(_keyboard);
          var _theme = __webpack_require__(34);
          var _theme2 = _interopRequireDefault2(_theme);
          var _colorPicker = __webpack_require__(59);
          var _colorPicker2 = _interopRequireDefault2(_colorPicker);
          var _iconPicker = __webpack_require__(60);
          var _iconPicker2 = _interopRequireDefault2(_iconPicker);
          var _picker = __webpack_require__(28);
          var _picker2 = _interopRequireDefault2(_picker);
          var _tooltip = __webpack_require__(61);
          var _tooltip2 = _interopRequireDefault2(_tooltip);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var ALIGNS = [false, "center", "right", "justify"];
          var COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];
          var FONTS = [false, "serif", "monospace"];
          var HEADERS = ["1", "2", "3", false];
          var SIZES = ["small", false, "large", "huge"];
          var BaseTheme = function(_Theme) {
            _inherits2(BaseTheme2, _Theme);
            function BaseTheme2(quill2, options) {
              _classCallCheck2(this, BaseTheme2);
              var _this = _possibleConstructorReturn2(this, (BaseTheme2.__proto__ || Object.getPrototypeOf(BaseTheme2)).call(this, quill2, options));
              var listener = function listener2(e2) {
                if (!document.body.contains(quill2.root)) {
                  return document.body.removeEventListener("click", listener2);
                }
                if (_this.tooltip != null && !_this.tooltip.root.contains(e2.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {
                  _this.tooltip.hide();
                }
                if (_this.pickers != null) {
                  _this.pickers.forEach(function(picker) {
                    if (!picker.container.contains(e2.target)) {
                      picker.close();
                    }
                  });
                }
              };
              quill2.emitter.listenDOM("click", document.body, listener);
              return _this;
            }
            _createClass2(BaseTheme2, [{
              key: "addModule",
              value: function addModule(name2) {
                var module4 = _get2(BaseTheme2.prototype.__proto__ || Object.getPrototypeOf(BaseTheme2.prototype), "addModule", this).call(this, name2);
                if (name2 === "toolbar") {
                  this.extendToolbar(module4);
                }
                return module4;
              }
            }, {
              key: "buildButtons",
              value: function buildButtons(buttons, icons) {
                buttons.forEach(function(button2) {
                  var className = button2.getAttribute("class") || "";
                  className.split(/\s+/).forEach(function(name2) {
                    if (!name2.startsWith("ql-")) return;
                    name2 = name2.slice("ql-".length);
                    if (icons[name2] == null) return;
                    if (name2 === "direction") {
                      button2.innerHTML = icons[name2][""] + icons[name2]["rtl"];
                    } else if (typeof icons[name2] === "string") {
                      button2.innerHTML = icons[name2];
                    } else {
                      var value = button2.value || "";
                      if (value != null && icons[name2][value]) {
                        button2.innerHTML = icons[name2][value];
                      }
                    }
                  });
                });
              }
            }, {
              key: "buildPickers",
              value: function buildPickers(selects, icons) {
                var _this2 = this;
                this.pickers = selects.map(function(select) {
                  if (select.classList.contains("ql-align")) {
                    if (select.querySelector("option") == null) {
                      fillSelect(select, ALIGNS);
                    }
                    return new _iconPicker2.default(select, icons.align);
                  } else if (select.classList.contains("ql-background") || select.classList.contains("ql-color")) {
                    var format2 = select.classList.contains("ql-background") ? "background" : "color";
                    if (select.querySelector("option") == null) {
                      fillSelect(select, COLORS, format2 === "background" ? "#ffffff" : "#000000");
                    }
                    return new _colorPicker2.default(select, icons[format2]);
                  } else {
                    if (select.querySelector("option") == null) {
                      if (select.classList.contains("ql-font")) {
                        fillSelect(select, FONTS);
                      } else if (select.classList.contains("ql-header")) {
                        fillSelect(select, HEADERS);
                      } else if (select.classList.contains("ql-size")) {
                        fillSelect(select, SIZES);
                      }
                    }
                    return new _picker2.default(select);
                  }
                });
                var update8 = function update9() {
                  _this2.pickers.forEach(function(picker) {
                    picker.update();
                  });
                };
                this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update8);
              }
            }]);
            return BaseTheme2;
          }(_theme2.default);
          BaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {
            modules: {
              toolbar: {
                handlers: {
                  formula: function formula() {
                    this.quill.theme.tooltip.edit("formula");
                  },
                  image: function image() {
                    var _this3 = this;
                    var fileInput = this.container.querySelector("input.ql-image[type=file]");
                    if (fileInput == null) {
                      fileInput = document.createElement("input");
                      fileInput.setAttribute("type", "file");
                      fileInput.setAttribute("accept", "image/png, image/gif, image/jpeg, image/bmp, image/x-icon");
                      fileInput.classList.add("ql-image");
                      fileInput.addEventListener("change", function() {
                        if (fileInput.files != null && fileInput.files[0] != null) {
                          var reader = new FileReader();
                          reader.onload = function(e2) {
                            var range2 = _this3.quill.getSelection(true);
                            _this3.quill.updateContents(new _quillDelta2.default().retain(range2.index).delete(range2.length).insert({ image: e2.target.result }), _emitter2.default.sources.USER);
                            _this3.quill.setSelection(range2.index + 1, _emitter2.default.sources.SILENT);
                            fileInput.value = "";
                          };
                          reader.readAsDataURL(fileInput.files[0]);
                        }
                      });
                      this.container.appendChild(fileInput);
                    }
                    fileInput.click();
                  },
                  video: function video() {
                    this.quill.theme.tooltip.edit("video");
                  }
                }
              }
            }
          });
          var BaseTooltip = function(_Tooltip) {
            _inherits2(BaseTooltip2, _Tooltip);
            function BaseTooltip2(quill2, boundsContainer) {
              _classCallCheck2(this, BaseTooltip2);
              var _this4 = _possibleConstructorReturn2(this, (BaseTooltip2.__proto__ || Object.getPrototypeOf(BaseTooltip2)).call(this, quill2, boundsContainer));
              _this4.textbox = _this4.root.querySelector('input[type="text"]');
              _this4.listen();
              return _this4;
            }
            _createClass2(BaseTooltip2, [{
              key: "listen",
              value: function listen() {
                var _this5 = this;
                this.textbox.addEventListener("keydown", function(event) {
                  if (_keyboard2.default.match(event, "enter")) {
                    _this5.save();
                    event.preventDefault();
                  } else if (_keyboard2.default.match(event, "escape")) {
                    _this5.cancel();
                    event.preventDefault();
                  }
                });
              }
            }, {
              key: "cancel",
              value: function cancel() {
                this.hide();
              }
            }, {
              key: "edit",
              value: function edit() {
                var mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "link";
                var preview = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                this.root.classList.remove("ql-hidden");
                this.root.classList.add("ql-editing");
                if (preview != null) {
                  this.textbox.value = preview;
                } else if (mode !== this.root.getAttribute("data-mode")) {
                  this.textbox.value = "";
                }
                this.position(this.quill.getBounds(this.quill.selection.savedRange));
                this.textbox.select();
                this.textbox.setAttribute("placeholder", this.textbox.getAttribute("data-" + mode) || "");
                this.root.setAttribute("data-mode", mode);
              }
            }, {
              key: "restoreFocus",
              value: function restoreFocus() {
                var scrollTop = this.quill.scrollingContainer.scrollTop;
                this.quill.focus();
                this.quill.scrollingContainer.scrollTop = scrollTop;
              }
            }, {
              key: "save",
              value: function save2() {
                var value = this.textbox.value;
                switch (this.root.getAttribute("data-mode")) {
                  case "link": {
                    var scrollTop = this.quill.root.scrollTop;
                    if (this.linkRange) {
                      this.quill.formatText(this.linkRange, "link", value, _emitter2.default.sources.USER);
                      delete this.linkRange;
                    } else {
                      this.restoreFocus();
                      this.quill.format("link", value, _emitter2.default.sources.USER);
                    }
                    this.quill.root.scrollTop = scrollTop;
                    break;
                  }
                  case "video": {
                    value = extractVideoUrl(value);
                  }
                  case "formula": {
                    if (!value) break;
                    var range2 = this.quill.getSelection(true);
                    if (range2 != null) {
                      var index2 = range2.index + range2.length;
                      this.quill.insertEmbed(index2, this.root.getAttribute("data-mode"), value, _emitter2.default.sources.USER);
                      if (this.root.getAttribute("data-mode") === "formula") {
                        this.quill.insertText(index2 + 1, " ", _emitter2.default.sources.USER);
                      }
                      this.quill.setSelection(index2 + 2, _emitter2.default.sources.USER);
                    }
                    break;
                  }
                }
                this.textbox.value = "";
                this.hide();
              }
            }]);
            return BaseTooltip2;
          }(_tooltip2.default);
          function extractVideoUrl(url) {
            var match = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
            if (match) {
              return (match[1] || "https") + "://www.youtube.com/embed/" + match[2] + "?showinfo=0";
            }
            if (match = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
              return (match[1] || "https") + "://player.vimeo.com/video/" + match[2] + "/";
            }
            return url;
          }
          function fillSelect(select, values2) {
            var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            values2.forEach(function(value) {
              var option = document.createElement("option");
              if (value === defaultValue) {
                option.setAttribute("selected", "selected");
              } else {
                option.setAttribute("value", value);
              }
              select.appendChild(option);
            });
          }
          exports3.BaseTooltip = BaseTooltip;
          exports3.default = BaseTheme;
        },
        /* 44 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var LinkedList = (
            /** @class */
            function() {
              function LinkedList2() {
                this.head = this.tail = null;
                this.length = 0;
              }
              LinkedList2.prototype.append = function() {
                var nodes = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  nodes[_i] = arguments[_i];
                }
                this.insertBefore(nodes[0], null);
                if (nodes.length > 1) {
                  this.append.apply(this, nodes.slice(1));
                }
              };
              LinkedList2.prototype.contains = function(node) {
                var cur, next = this.iterator();
                while (cur = next()) {
                  if (cur === node)
                    return true;
                }
                return false;
              };
              LinkedList2.prototype.insertBefore = function(node, refNode) {
                if (!node)
                  return;
                node.next = refNode;
                if (refNode != null) {
                  node.prev = refNode.prev;
                  if (refNode.prev != null) {
                    refNode.prev.next = node;
                  }
                  refNode.prev = node;
                  if (refNode === this.head) {
                    this.head = node;
                  }
                } else if (this.tail != null) {
                  this.tail.next = node;
                  node.prev = this.tail;
                  this.tail = node;
                } else {
                  node.prev = null;
                  this.head = this.tail = node;
                }
                this.length += 1;
              };
              LinkedList2.prototype.offset = function(target) {
                var index2 = 0, cur = this.head;
                while (cur != null) {
                  if (cur === target)
                    return index2;
                  index2 += cur.length();
                  cur = cur.next;
                }
                return -1;
              };
              LinkedList2.prototype.remove = function(node) {
                if (!this.contains(node))
                  return;
                if (node.prev != null)
                  node.prev.next = node.next;
                if (node.next != null)
                  node.next.prev = node.prev;
                if (node === this.head)
                  this.head = node.next;
                if (node === this.tail)
                  this.tail = node.prev;
                this.length -= 1;
              };
              LinkedList2.prototype.iterator = function(curNode) {
                if (curNode === void 0) {
                  curNode = this.head;
                }
                return function() {
                  var ret = curNode;
                  if (curNode != null)
                    curNode = curNode.next;
                  return ret;
                };
              };
              LinkedList2.prototype.find = function(index2, inclusive) {
                if (inclusive === void 0) {
                  inclusive = false;
                }
                var cur, next = this.iterator();
                while (cur = next()) {
                  var length = cur.length();
                  if (index2 < length || inclusive && index2 === length && (cur.next == null || cur.next.length() !== 0)) {
                    return [cur, index2];
                  }
                  index2 -= length;
                }
                return [null, 0];
              };
              LinkedList2.prototype.forEach = function(callback) {
                var cur, next = this.iterator();
                while (cur = next()) {
                  callback(cur);
                }
              };
              LinkedList2.prototype.forEachAt = function(index2, length, callback) {
                if (length <= 0)
                  return;
                var _a = this.find(index2), startNode = _a[0], offset2 = _a[1];
                var cur, curIndex = index2 - offset2, next = this.iterator(startNode);
                while ((cur = next()) && curIndex < index2 + length) {
                  var curLength = cur.length();
                  if (index2 > curIndex) {
                    callback(cur, index2 - curIndex, Math.min(length, curIndex + curLength - index2));
                  } else {
                    callback(cur, 0, Math.min(curLength, index2 + length - curIndex));
                  }
                  curIndex += curLength;
                }
              };
              LinkedList2.prototype.map = function(callback) {
                return this.reduce(function(memo, cur) {
                  memo.push(callback(cur));
                  return memo;
                }, []);
              };
              LinkedList2.prototype.reduce = function(callback, memo) {
                var cur, next = this.iterator();
                while (cur = next()) {
                  memo = callback(memo, cur);
                }
                return memo;
              };
              return LinkedList2;
            }()
          );
          exports3.default = LinkedList;
        },
        /* 45 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
              d.__proto__ = b;
            } || function(d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var container_1 = __webpack_require__(17);
          var Registry = __webpack_require__(1);
          var OBSERVER_CONFIG = {
            attributes: true,
            characterData: true,
            characterDataOldValue: true,
            childList: true,
            subtree: true
          };
          var MAX_OPTIMIZE_ITERATIONS = 100;
          var ScrollBlot = (
            /** @class */
            function(_super) {
              __extends2(ScrollBlot2, _super);
              function ScrollBlot2(node) {
                var _this = _super.call(this, node) || this;
                _this.scroll = _this;
                _this.observer = new MutationObserver(function(mutations) {
                  _this.update(mutations);
                });
                _this.observer.observe(_this.domNode, OBSERVER_CONFIG);
                _this.attach();
                return _this;
              }
              ScrollBlot2.prototype.detach = function() {
                _super.prototype.detach.call(this);
                this.observer.disconnect();
              };
              ScrollBlot2.prototype.deleteAt = function(index2, length) {
                this.update();
                if (index2 === 0 && length === this.length()) {
                  this.children.forEach(function(child) {
                    child.remove();
                  });
                } else {
                  _super.prototype.deleteAt.call(this, index2, length);
                }
              };
              ScrollBlot2.prototype.formatAt = function(index2, length, name2, value) {
                this.update();
                _super.prototype.formatAt.call(this, index2, length, name2, value);
              };
              ScrollBlot2.prototype.insertAt = function(index2, value, def) {
                this.update();
                _super.prototype.insertAt.call(this, index2, value, def);
              };
              ScrollBlot2.prototype.optimize = function(mutations, context2) {
                var _this = this;
                if (mutations === void 0) {
                  mutations = [];
                }
                if (context2 === void 0) {
                  context2 = {};
                }
                _super.prototype.optimize.call(this, context2);
                var records = [].slice.call(this.observer.takeRecords());
                while (records.length > 0)
                  mutations.push(records.pop());
                var mark = function(blot, markParent) {
                  if (markParent === void 0) {
                    markParent = true;
                  }
                  if (blot == null || blot === _this)
                    return;
                  if (blot.domNode.parentNode == null)
                    return;
                  if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                    blot.domNode[Registry.DATA_KEY].mutations = [];
                  }
                  if (markParent)
                    mark(blot.parent);
                };
                var optimize = function(blot) {
                  if (
                    // @ts-ignore
                    blot.domNode[Registry.DATA_KEY] == null || // @ts-ignore
                    blot.domNode[Registry.DATA_KEY].mutations == null
                  ) {
                    return;
                  }
                  if (blot instanceof container_1.default) {
                    blot.children.forEach(optimize);
                  }
                  blot.optimize(context2);
                };
                var remaining = mutations;
                for (var i2 = 0; remaining.length > 0; i2 += 1) {
                  if (i2 >= MAX_OPTIMIZE_ITERATIONS) {
                    throw new Error("[Parchment] Maximum optimize iterations reached");
                  }
                  remaining.forEach(function(mutation) {
                    var blot = Registry.find(mutation.target, true);
                    if (blot == null)
                      return;
                    if (blot.domNode === mutation.target) {
                      if (mutation.type === "childList") {
                        mark(Registry.find(mutation.previousSibling, false));
                        [].forEach.call(mutation.addedNodes, function(node) {
                          var child = Registry.find(node, false);
                          mark(child, false);
                          if (child instanceof container_1.default) {
                            child.children.forEach(function(grandChild) {
                              mark(grandChild, false);
                            });
                          }
                        });
                      } else if (mutation.type === "attributes") {
                        mark(blot.prev);
                      }
                    }
                    mark(blot);
                  });
                  this.children.forEach(optimize);
                  remaining = [].slice.call(this.observer.takeRecords());
                  records = remaining.slice();
                  while (records.length > 0)
                    mutations.push(records.pop());
                }
              };
              ScrollBlot2.prototype.update = function(mutations, context2) {
                var _this = this;
                if (context2 === void 0) {
                  context2 = {};
                }
                mutations = mutations || this.observer.takeRecords();
                mutations.map(function(mutation) {
                  var blot = Registry.find(mutation.target, true);
                  if (blot == null)
                    return null;
                  if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                    blot.domNode[Registry.DATA_KEY].mutations = [mutation];
                    return blot;
                  } else {
                    blot.domNode[Registry.DATA_KEY].mutations.push(mutation);
                    return null;
                  }
                }).forEach(function(blot) {
                  if (blot == null || blot === _this || //@ts-ignore
                  blot.domNode[Registry.DATA_KEY] == null)
                    return;
                  blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context2);
                });
                if (this.domNode[Registry.DATA_KEY].mutations != null) {
                  _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context2);
                }
                this.optimize(mutations, context2);
              };
              ScrollBlot2.blotName = "scroll";
              ScrollBlot2.defaultChild = "block";
              ScrollBlot2.scope = Registry.Scope.BLOCK_BLOT;
              ScrollBlot2.tagName = "DIV";
              return ScrollBlot2;
            }(container_1.default)
          );
          exports3.default = ScrollBlot;
        },
        /* 46 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
              d.__proto__ = b;
            } || function(d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var format_1 = __webpack_require__(18);
          var Registry = __webpack_require__(1);
          function isEqual2(obj1, obj2) {
            if (Object.keys(obj1).length !== Object.keys(obj2).length)
              return false;
            for (var prop in obj1) {
              if (obj1[prop] !== obj2[prop])
                return false;
            }
            return true;
          }
          var InlineBlot = (
            /** @class */
            function(_super) {
              __extends2(InlineBlot2, _super);
              function InlineBlot2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              InlineBlot2.formats = function(domNode) {
                if (domNode.tagName === InlineBlot2.tagName)
                  return void 0;
                return _super.formats.call(this, domNode);
              };
              InlineBlot2.prototype.format = function(name2, value) {
                var _this = this;
                if (name2 === this.statics.blotName && !value) {
                  this.children.forEach(function(child) {
                    if (!(child instanceof format_1.default)) {
                      child = child.wrap(InlineBlot2.blotName, true);
                    }
                    _this.attributes.copy(child);
                  });
                  this.unwrap();
                } else {
                  _super.prototype.format.call(this, name2, value);
                }
              };
              InlineBlot2.prototype.formatAt = function(index2, length, name2, value) {
                if (this.formats()[name2] != null || Registry.query(name2, Registry.Scope.ATTRIBUTE)) {
                  var blot = this.isolate(index2, length);
                  blot.format(name2, value);
                } else {
                  _super.prototype.formatAt.call(this, index2, length, name2, value);
                }
              };
              InlineBlot2.prototype.optimize = function(context2) {
                _super.prototype.optimize.call(this, context2);
                var formats = this.formats();
                if (Object.keys(formats).length === 0) {
                  return this.unwrap();
                }
                var next = this.next;
                if (next instanceof InlineBlot2 && next.prev === this && isEqual2(formats, next.formats())) {
                  next.moveChildren(this);
                  next.remove();
                }
              };
              InlineBlot2.blotName = "inline";
              InlineBlot2.scope = Registry.Scope.INLINE_BLOT;
              InlineBlot2.tagName = "SPAN";
              return InlineBlot2;
            }(format_1.default)
          );
          exports3.default = InlineBlot;
        },
        /* 47 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
              d.__proto__ = b;
            } || function(d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var format_1 = __webpack_require__(18);
          var Registry = __webpack_require__(1);
          var BlockBlot = (
            /** @class */
            function(_super) {
              __extends2(BlockBlot2, _super);
              function BlockBlot2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              BlockBlot2.formats = function(domNode) {
                var tagName = Registry.query(BlockBlot2.blotName).tagName;
                if (domNode.tagName === tagName)
                  return void 0;
                return _super.formats.call(this, domNode);
              };
              BlockBlot2.prototype.format = function(name2, value) {
                if (Registry.query(name2, Registry.Scope.BLOCK) == null) {
                  return;
                } else if (name2 === this.statics.blotName && !value) {
                  this.replaceWith(BlockBlot2.blotName);
                } else {
                  _super.prototype.format.call(this, name2, value);
                }
              };
              BlockBlot2.prototype.formatAt = function(index2, length, name2, value) {
                if (Registry.query(name2, Registry.Scope.BLOCK) != null) {
                  this.format(name2, value);
                } else {
                  _super.prototype.formatAt.call(this, index2, length, name2, value);
                }
              };
              BlockBlot2.prototype.insertAt = function(index2, value, def) {
                if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {
                  _super.prototype.insertAt.call(this, index2, value, def);
                } else {
                  var after = this.split(index2);
                  var blot = Registry.create(value, def);
                  after.parent.insertBefore(blot, after);
                }
              };
              BlockBlot2.prototype.update = function(mutations, context2) {
                if (navigator.userAgent.match(/Trident/)) {
                  this.build();
                } else {
                  _super.prototype.update.call(this, mutations, context2);
                }
              };
              BlockBlot2.blotName = "block";
              BlockBlot2.scope = Registry.Scope.BLOCK_BLOT;
              BlockBlot2.tagName = "P";
              return BlockBlot2;
            }(format_1.default)
          );
          exports3.default = BlockBlot;
        },
        /* 48 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
              d.__proto__ = b;
            } || function(d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var leaf_1 = __webpack_require__(19);
          var EmbedBlot = (
            /** @class */
            function(_super) {
              __extends2(EmbedBlot2, _super);
              function EmbedBlot2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              EmbedBlot2.formats = function(domNode) {
                return void 0;
              };
              EmbedBlot2.prototype.format = function(name2, value) {
                _super.prototype.formatAt.call(this, 0, this.length(), name2, value);
              };
              EmbedBlot2.prototype.formatAt = function(index2, length, name2, value) {
                if (index2 === 0 && length === this.length()) {
                  this.format(name2, value);
                } else {
                  _super.prototype.formatAt.call(this, index2, length, name2, value);
                }
              };
              EmbedBlot2.prototype.formats = function() {
                return this.statics.formats(this.domNode);
              };
              return EmbedBlot2;
            }(leaf_1.default)
          );
          exports3.default = EmbedBlot;
        },
        /* 49 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
              d.__proto__ = b;
            } || function(d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var leaf_1 = __webpack_require__(19);
          var Registry = __webpack_require__(1);
          var TextBlot = (
            /** @class */
            function(_super) {
              __extends2(TextBlot2, _super);
              function TextBlot2(node) {
                var _this = _super.call(this, node) || this;
                _this.text = _this.statics.value(_this.domNode);
                return _this;
              }
              TextBlot2.create = function(value) {
                return document.createTextNode(value);
              };
              TextBlot2.value = function(domNode) {
                var text = domNode.data;
                if (text["normalize"])
                  text = text["normalize"]();
                return text;
              };
              TextBlot2.prototype.deleteAt = function(index2, length) {
                this.domNode.data = this.text = this.text.slice(0, index2) + this.text.slice(index2 + length);
              };
              TextBlot2.prototype.index = function(node, offset2) {
                if (this.domNode === node) {
                  return offset2;
                }
                return -1;
              };
              TextBlot2.prototype.insertAt = function(index2, value, def) {
                if (def == null) {
                  this.text = this.text.slice(0, index2) + value + this.text.slice(index2);
                  this.domNode.data = this.text;
                } else {
                  _super.prototype.insertAt.call(this, index2, value, def);
                }
              };
              TextBlot2.prototype.length = function() {
                return this.text.length;
              };
              TextBlot2.prototype.optimize = function(context2) {
                _super.prototype.optimize.call(this, context2);
                this.text = this.statics.value(this.domNode);
                if (this.text.length === 0) {
                  this.remove();
                } else if (this.next instanceof TextBlot2 && this.next.prev === this) {
                  this.insertAt(this.length(), this.next.value());
                  this.next.remove();
                }
              };
              TextBlot2.prototype.position = function(index2, inclusive) {
                return [this.domNode, index2];
              };
              TextBlot2.prototype.split = function(index2, force) {
                if (force === void 0) {
                  force = false;
                }
                if (!force) {
                  if (index2 === 0)
                    return this;
                  if (index2 === this.length())
                    return this.next;
                }
                var after = Registry.create(this.domNode.splitText(index2));
                this.parent.insertBefore(after, this.next);
                this.text = this.statics.value(this.domNode);
                return after;
              };
              TextBlot2.prototype.update = function(mutations, context2) {
                var _this = this;
                if (mutations.some(function(mutation) {
                  return mutation.type === "characterData" && mutation.target === _this.domNode;
                })) {
                  this.text = this.statics.value(this.domNode);
                }
              };
              TextBlot2.prototype.value = function() {
                return this.text;
              };
              TextBlot2.blotName = "text";
              TextBlot2.scope = Registry.Scope.INLINE_BLOT;
              return TextBlot2;
            }(leaf_1.default)
          );
          exports3.default = TextBlot;
        },
        /* 50 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var elem = document.createElement("div");
          elem.classList.toggle("test-class", false);
          if (elem.classList.contains("test-class")) {
            var _toggle = DOMTokenList.prototype.toggle;
            DOMTokenList.prototype.toggle = function(token2, force) {
              if (arguments.length > 1 && !this.contains(token2) === !force) {
                return force;
              } else {
                return _toggle.call(this, token2);
              }
            };
          }
          if (!String.prototype.startsWith) {
            String.prototype.startsWith = function(searchString, position) {
              position = position || 0;
              return this.substr(position, searchString.length) === searchString;
            };
          }
          if (!String.prototype.endsWith) {
            String.prototype.endsWith = function(searchString, position) {
              var subjectString = this.toString();
              if (typeof position !== "number" || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
                position = subjectString.length;
              }
              position -= searchString.length;
              var lastIndex = subjectString.indexOf(searchString, position);
              return lastIndex !== -1 && lastIndex === position;
            };
          }
          if (!Array.prototype.find) {
            Object.defineProperty(Array.prototype, "find", {
              value: function value(predicate) {
                if (this === null) {
                  throw new TypeError("Array.prototype.find called on null or undefined");
                }
                if (typeof predicate !== "function") {
                  throw new TypeError("predicate must be a function");
                }
                var list2 = Object(this);
                var length = list2.length >>> 0;
                var thisArg = arguments[1];
                var value2;
                for (var i2 = 0; i2 < length; i2++) {
                  value2 = list2[i2];
                  if (predicate.call(thisArg, value2, i2, list2)) {
                    return value2;
                  }
                }
                return void 0;
              }
            });
          }
          document.addEventListener("DOMContentLoaded", function() {
            document.execCommand("enableObjectResizing", false, false);
            document.execCommand("autoUrlDetect", false, false);
          });
        },
        /* 51 */
        /***/
        function(module3, exports3) {
          var DIFF_DELETE2 = -1;
          var DIFF_INSERT2 = 1;
          var DIFF_EQUAL2 = 0;
          function diff_main2(text1, text2, cursor_pos) {
            if (text1 == text2) {
              if (text1) {
                return [[DIFF_EQUAL2, text1]];
              }
              return [];
            }
            if (cursor_pos < 0 || text1.length < cursor_pos) {
              cursor_pos = null;
            }
            var commonlength = diff_commonPrefix2(text1, text2);
            var commonprefix = text1.substring(0, commonlength);
            text1 = text1.substring(commonlength);
            text2 = text2.substring(commonlength);
            commonlength = diff_commonSuffix2(text1, text2);
            var commonsuffix = text1.substring(text1.length - commonlength);
            text1 = text1.substring(0, text1.length - commonlength);
            text2 = text2.substring(0, text2.length - commonlength);
            var diffs = diff_compute_2(text1, text2);
            if (commonprefix) {
              diffs.unshift([DIFF_EQUAL2, commonprefix]);
            }
            if (commonsuffix) {
              diffs.push([DIFF_EQUAL2, commonsuffix]);
            }
            diff_cleanupMerge2(diffs);
            if (cursor_pos != null) {
              diffs = fix_cursor2(diffs, cursor_pos);
            }
            diffs = fix_emoji2(diffs);
            return diffs;
          }
          function diff_compute_2(text1, text2) {
            var diffs;
            if (!text1) {
              return [[DIFF_INSERT2, text2]];
            }
            if (!text2) {
              return [[DIFF_DELETE2, text1]];
            }
            var longtext = text1.length > text2.length ? text1 : text2;
            var shorttext = text1.length > text2.length ? text2 : text1;
            var i2 = longtext.indexOf(shorttext);
            if (i2 != -1) {
              diffs = [
                [DIFF_INSERT2, longtext.substring(0, i2)],
                [DIFF_EQUAL2, shorttext],
                [DIFF_INSERT2, longtext.substring(i2 + shorttext.length)]
              ];
              if (text1.length > text2.length) {
                diffs[0][0] = diffs[2][0] = DIFF_DELETE2;
              }
              return diffs;
            }
            if (shorttext.length == 1) {
              return [[DIFF_DELETE2, text1], [DIFF_INSERT2, text2]];
            }
            var hm = diff_halfMatch_2(text1, text2);
            if (hm) {
              var text1_a = hm[0];
              var text1_b = hm[1];
              var text2_a = hm[2];
              var text2_b = hm[3];
              var mid_common = hm[4];
              var diffs_a = diff_main2(text1_a, text2_a);
              var diffs_b = diff_main2(text1_b, text2_b);
              return diffs_a.concat([[DIFF_EQUAL2, mid_common]], diffs_b);
            }
            return diff_bisect_2(text1, text2);
          }
          function diff_bisect_2(text1, text2) {
            var text1_length = text1.length;
            var text2_length = text2.length;
            var max_d = Math.ceil((text1_length + text2_length) / 2);
            var v_offset = max_d;
            var v_length = 2 * max_d;
            var v1 = new Array(v_length);
            var v2 = new Array(v_length);
            for (var x = 0; x < v_length; x++) {
              v1[x] = -1;
              v2[x] = -1;
            }
            v1[v_offset + 1] = 0;
            v2[v_offset + 1] = 0;
            var delta2 = text1_length - text2_length;
            var front = delta2 % 2 != 0;
            var k1start = 0;
            var k1end = 0;
            var k2start = 0;
            var k2end = 0;
            for (var d = 0; d < max_d; d++) {
              for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
                var k1_offset = v_offset + k1;
                var x1;
                if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
                  x1 = v1[k1_offset + 1];
                } else {
                  x1 = v1[k1_offset - 1] + 1;
                }
                var y1 = x1 - k1;
                while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
                  x1++;
                  y1++;
                }
                v1[k1_offset] = x1;
                if (x1 > text1_length) {
                  k1end += 2;
                } else if (y1 > text2_length) {
                  k1start += 2;
                } else if (front) {
                  var k2_offset = v_offset + delta2 - k1;
                  if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
                    var x2 = text1_length - v2[k2_offset];
                    if (x1 >= x2) {
                      return diff_bisectSplit_2(text1, text2, x1, y1);
                    }
                  }
                }
              }
              for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
                var k2_offset = v_offset + k2;
                var x2;
                if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
                  x2 = v2[k2_offset + 1];
                } else {
                  x2 = v2[k2_offset - 1] + 1;
                }
                var y2 = x2 - k2;
                while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
                  x2++;
                  y2++;
                }
                v2[k2_offset] = x2;
                if (x2 > text1_length) {
                  k2end += 2;
                } else if (y2 > text2_length) {
                  k2start += 2;
                } else if (!front) {
                  var k1_offset = v_offset + delta2 - k2;
                  if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                    var x1 = v1[k1_offset];
                    var y1 = v_offset + x1 - k1_offset;
                    x2 = text1_length - x2;
                    if (x1 >= x2) {
                      return diff_bisectSplit_2(text1, text2, x1, y1);
                    }
                  }
                }
              }
            }
            return [[DIFF_DELETE2, text1], [DIFF_INSERT2, text2]];
          }
          function diff_bisectSplit_2(text1, text2, x, y) {
            var text1a = text1.substring(0, x);
            var text2a = text2.substring(0, y);
            var text1b = text1.substring(x);
            var text2b = text2.substring(y);
            var diffs = diff_main2(text1a, text2a);
            var diffsb = diff_main2(text1b, text2b);
            return diffs.concat(diffsb);
          }
          function diff_commonPrefix2(text1, text2) {
            if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
              return 0;
            }
            var pointermin = 0;
            var pointermax = Math.min(text1.length, text2.length);
            var pointermid = pointermax;
            var pointerstart = 0;
            while (pointermin < pointermid) {
              if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
                pointermin = pointermid;
                pointerstart = pointermin;
              } else {
                pointermax = pointermid;
              }
              pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
            }
            return pointermid;
          }
          function diff_commonSuffix2(text1, text2) {
            if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
              return 0;
            }
            var pointermin = 0;
            var pointermax = Math.min(text1.length, text2.length);
            var pointermid = pointermax;
            var pointerend = 0;
            while (pointermin < pointermid) {
              if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
                pointermin = pointermid;
                pointerend = pointermin;
              } else {
                pointermax = pointermid;
              }
              pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
            }
            return pointermid;
          }
          function diff_halfMatch_2(text1, text2) {
            var longtext = text1.length > text2.length ? text1 : text2;
            var shorttext = text1.length > text2.length ? text2 : text1;
            if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
              return null;
            }
            function diff_halfMatchI_(longtext2, shorttext2, i2) {
              var seed = longtext2.substring(i2, i2 + Math.floor(longtext2.length / 4));
              var j = -1;
              var best_common = "";
              var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
              while ((j = shorttext2.indexOf(seed, j + 1)) != -1) {
                var prefixLength = diff_commonPrefix2(
                  longtext2.substring(i2),
                  shorttext2.substring(j)
                );
                var suffixLength = diff_commonSuffix2(
                  longtext2.substring(0, i2),
                  shorttext2.substring(0, j)
                );
                if (best_common.length < suffixLength + prefixLength) {
                  best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
                  best_longtext_a = longtext2.substring(0, i2 - suffixLength);
                  best_longtext_b = longtext2.substring(i2 + prefixLength);
                  best_shorttext_a = shorttext2.substring(0, j - suffixLength);
                  best_shorttext_b = shorttext2.substring(j + prefixLength);
                }
              }
              if (best_common.length * 2 >= longtext2.length) {
                return [
                  best_longtext_a,
                  best_longtext_b,
                  best_shorttext_a,
                  best_shorttext_b,
                  best_common
                ];
              } else {
                return null;
              }
            }
            var hm1 = diff_halfMatchI_(
              longtext,
              shorttext,
              Math.ceil(longtext.length / 4)
            );
            var hm2 = diff_halfMatchI_(
              longtext,
              shorttext,
              Math.ceil(longtext.length / 2)
            );
            var hm;
            if (!hm1 && !hm2) {
              return null;
            } else if (!hm2) {
              hm = hm1;
            } else if (!hm1) {
              hm = hm2;
            } else {
              hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
            }
            var text1_a, text1_b, text2_a, text2_b;
            if (text1.length > text2.length) {
              text1_a = hm[0];
              text1_b = hm[1];
              text2_a = hm[2];
              text2_b = hm[3];
            } else {
              text2_a = hm[0];
              text2_b = hm[1];
              text1_a = hm[2];
              text1_b = hm[3];
            }
            var mid_common = hm[4];
            return [text1_a, text1_b, text2_a, text2_b, mid_common];
          }
          function diff_cleanupMerge2(diffs) {
            diffs.push([DIFF_EQUAL2, ""]);
            var pointer = 0;
            var count_delete = 0;
            var count_insert = 0;
            var text_delete = "";
            var text_insert = "";
            var commonlength;
            while (pointer < diffs.length) {
              switch (diffs[pointer][0]) {
                case DIFF_INSERT2:
                  count_insert++;
                  text_insert += diffs[pointer][1];
                  pointer++;
                  break;
                case DIFF_DELETE2:
                  count_delete++;
                  text_delete += diffs[pointer][1];
                  pointer++;
                  break;
                case DIFF_EQUAL2:
                  if (count_delete + count_insert > 1) {
                    if (count_delete !== 0 && count_insert !== 0) {
                      commonlength = diff_commonPrefix2(text_insert, text_delete);
                      if (commonlength !== 0) {
                        if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL2) {
                          diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                        } else {
                          diffs.splice(0, 0, [
                            DIFF_EQUAL2,
                            text_insert.substring(0, commonlength)
                          ]);
                          pointer++;
                        }
                        text_insert = text_insert.substring(commonlength);
                        text_delete = text_delete.substring(commonlength);
                      }
                      commonlength = diff_commonSuffix2(text_insert, text_delete);
                      if (commonlength !== 0) {
                        diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                        text_insert = text_insert.substring(0, text_insert.length - commonlength);
                        text_delete = text_delete.substring(0, text_delete.length - commonlength);
                      }
                    }
                    if (count_delete === 0) {
                      diffs.splice(
                        pointer - count_insert,
                        count_delete + count_insert,
                        [DIFF_INSERT2, text_insert]
                      );
                    } else if (count_insert === 0) {
                      diffs.splice(
                        pointer - count_delete,
                        count_delete + count_insert,
                        [DIFF_DELETE2, text_delete]
                      );
                    } else {
                      diffs.splice(
                        pointer - count_delete - count_insert,
                        count_delete + count_insert,
                        [DIFF_DELETE2, text_delete],
                        [DIFF_INSERT2, text_insert]
                      );
                    }
                    pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
                  } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL2) {
                    diffs[pointer - 1][1] += diffs[pointer][1];
                    diffs.splice(pointer, 1);
                  } else {
                    pointer++;
                  }
                  count_insert = 0;
                  count_delete = 0;
                  text_delete = "";
                  text_insert = "";
                  break;
              }
            }
            if (diffs[diffs.length - 1][1] === "") {
              diffs.pop();
            }
            var changes = false;
            pointer = 1;
            while (pointer < diffs.length - 1) {
              if (diffs[pointer - 1][0] == DIFF_EQUAL2 && diffs[pointer + 1][0] == DIFF_EQUAL2) {
                if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                  diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                  diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                  diffs.splice(pointer - 1, 1);
                  changes = true;
                } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
                  diffs[pointer - 1][1] += diffs[pointer + 1][1];
                  diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                  diffs.splice(pointer + 1, 1);
                  changes = true;
                }
              }
              pointer++;
            }
            if (changes) {
              diff_cleanupMerge2(diffs);
            }
          }
          var diff2 = diff_main2;
          diff2.INSERT = DIFF_INSERT2;
          diff2.DELETE = DIFF_DELETE2;
          diff2.EQUAL = DIFF_EQUAL2;
          module3.exports = diff2;
          function cursor_normalize_diff2(diffs, cursor_pos) {
            if (cursor_pos === 0) {
              return [DIFF_EQUAL2, diffs];
            }
            for (var current_pos = 0, i2 = 0; i2 < diffs.length; i2++) {
              var d = diffs[i2];
              if (d[0] === DIFF_DELETE2 || d[0] === DIFF_EQUAL2) {
                var next_pos = current_pos + d[1].length;
                if (cursor_pos === next_pos) {
                  return [i2 + 1, diffs];
                } else if (cursor_pos < next_pos) {
                  diffs = diffs.slice();
                  var split_pos = cursor_pos - current_pos;
                  var d_left = [d[0], d[1].slice(0, split_pos)];
                  var d_right = [d[0], d[1].slice(split_pos)];
                  diffs.splice(i2, 1, d_left, d_right);
                  return [i2 + 1, diffs];
                } else {
                  current_pos = next_pos;
                }
              }
            }
            throw new Error("cursor_pos is out of bounds!");
          }
          function fix_cursor2(diffs, cursor_pos) {
            var norm = cursor_normalize_diff2(diffs, cursor_pos);
            var ndiffs = norm[1];
            var cursor_pointer = norm[0];
            var d = ndiffs[cursor_pointer];
            var d_next = ndiffs[cursor_pointer + 1];
            if (d == null) {
              return diffs;
            } else if (d[0] !== DIFF_EQUAL2) {
              return diffs;
            } else {
              if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
                ndiffs.splice(cursor_pointer, 2, d_next, d);
                return merge_tuples2(ndiffs, cursor_pointer, 2);
              } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
                ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
                var suffix = d_next[1].slice(d[1].length);
                if (suffix.length > 0) {
                  ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
                }
                return merge_tuples2(ndiffs, cursor_pointer, 3);
              } else {
                return diffs;
              }
            }
          }
          function fix_emoji2(diffs) {
            var compact = false;
            var starts_with_pair_end = function(str) {
              return str.charCodeAt(0) >= 56320 && str.charCodeAt(0) <= 57343;
            };
            var ends_with_pair_start = function(str) {
              return str.charCodeAt(str.length - 1) >= 55296 && str.charCodeAt(str.length - 1) <= 56319;
            };
            for (var i2 = 2; i2 < diffs.length; i2 += 1) {
              if (diffs[i2 - 2][0] === DIFF_EQUAL2 && ends_with_pair_start(diffs[i2 - 2][1]) && diffs[i2 - 1][0] === DIFF_DELETE2 && starts_with_pair_end(diffs[i2 - 1][1]) && diffs[i2][0] === DIFF_INSERT2 && starts_with_pair_end(diffs[i2][1])) {
                compact = true;
                diffs[i2 - 1][1] = diffs[i2 - 2][1].slice(-1) + diffs[i2 - 1][1];
                diffs[i2][1] = diffs[i2 - 2][1].slice(-1) + diffs[i2][1];
                diffs[i2 - 2][1] = diffs[i2 - 2][1].slice(0, -1);
              }
            }
            if (!compact) {
              return diffs;
            }
            var fixed_diffs = [];
            for (var i2 = 0; i2 < diffs.length; i2 += 1) {
              if (diffs[i2][1].length > 0) {
                fixed_diffs.push(diffs[i2]);
              }
            }
            return fixed_diffs;
          }
          function merge_tuples2(diffs, start, length) {
            for (var i2 = start + length - 1; i2 >= 0 && i2 >= start - 1; i2--) {
              if (i2 + 1 < diffs.length) {
                var left_d = diffs[i2];
                var right_d = diffs[i2 + 1];
                if (left_d[0] === right_d[1]) {
                  diffs.splice(i2, 2, [left_d[0], left_d[1] + right_d[1]]);
                }
              }
            }
            return diffs;
          }
        },
        /* 52 */
        /***/
        function(module3, exports3) {
          exports3 = module3.exports = typeof Object.keys === "function" ? Object.keys : shim2;
          exports3.shim = shim2;
          function shim2(obj) {
            var keys4 = [];
            for (var key in obj) keys4.push(key);
            return keys4;
          }
        },
        /* 53 */
        /***/
        function(module3, exports3) {
          var supportsArgumentsClass = function() {
            return Object.prototype.toString.call(arguments);
          }() == "[object Arguments]";
          exports3 = module3.exports = supportsArgumentsClass ? supported : unsupported;
          exports3.supported = supported;
          function supported(object) {
            return Object.prototype.toString.call(object) == "[object Arguments]";
          }
          exports3.unsupported = unsupported;
          function unsupported(object) {
            return object && typeof object == "object" && typeof object.length == "number" && Object.prototype.hasOwnProperty.call(object, "callee") && !Object.prototype.propertyIsEnumerable.call(object, "callee") || false;
          }
        },
        /* 54 */
        /***/
        function(module3, exports3) {
          var has5 = Object.prototype.hasOwnProperty, prefix = "~";
          function Events() {
          }
          if (Object.create) {
            Events.prototype = /* @__PURE__ */ Object.create(null);
            if (!new Events().__proto__) prefix = false;
          }
          function EE(fn, context2, once) {
            this.fn = fn;
            this.context = context2;
            this.once = once || false;
          }
          function EventEmitter2() {
            this._events = new Events();
            this._eventsCount = 0;
          }
          EventEmitter2.prototype.eventNames = function eventNames() {
            var names2 = [], events, name2;
            if (this._eventsCount === 0) return names2;
            for (name2 in events = this._events) {
              if (has5.call(events, name2)) names2.push(prefix ? name2.slice(1) : name2);
            }
            if (Object.getOwnPropertySymbols) {
              return names2.concat(Object.getOwnPropertySymbols(events));
            }
            return names2;
          };
          EventEmitter2.prototype.listeners = function listeners(event, exists) {
            var evt = prefix ? prefix + event : event, available = this._events[evt];
            if (exists) return !!available;
            if (!available) return [];
            if (available.fn) return [available.fn];
            for (var i2 = 0, l = available.length, ee = new Array(l); i2 < l; i2++) {
              ee[i2] = available[i2].fn;
            }
            return ee;
          };
          EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt]) return false;
            var listeners = this._events[evt], len = arguments.length, args, i2;
            if (listeners.fn) {
              if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
              switch (len) {
                case 1:
                  return listeners.fn.call(listeners.context), true;
                case 2:
                  return listeners.fn.call(listeners.context, a1), true;
                case 3:
                  return listeners.fn.call(listeners.context, a1, a2), true;
                case 4:
                  return listeners.fn.call(listeners.context, a1, a2, a3), true;
                case 5:
                  return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                case 6:
                  return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
              }
              for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
                args[i2 - 1] = arguments[i2];
              }
              listeners.fn.apply(listeners.context, args);
            } else {
              var length = listeners.length, j;
              for (i2 = 0; i2 < length; i2++) {
                if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
                switch (len) {
                  case 1:
                    listeners[i2].fn.call(listeners[i2].context);
                    break;
                  case 2:
                    listeners[i2].fn.call(listeners[i2].context, a1);
                    break;
                  case 3:
                    listeners[i2].fn.call(listeners[i2].context, a1, a2);
                    break;
                  case 4:
                    listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                    break;
                  default:
                    if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                      args[j - 1] = arguments[j];
                    }
                    listeners[i2].fn.apply(listeners[i2].context, args);
                }
              }
            }
            return true;
          };
          EventEmitter2.prototype.on = function on(event, fn, context2) {
            var listener = new EE(fn, context2 || this), evt = prefix ? prefix + event : event;
            if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
            else if (!this._events[evt].fn) this._events[evt].push(listener);
            else this._events[evt] = [this._events[evt], listener];
            return this;
          };
          EventEmitter2.prototype.once = function once(event, fn, context2) {
            var listener = new EE(fn, context2 || this, true), evt = prefix ? prefix + event : event;
            if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
            else if (!this._events[evt].fn) this._events[evt].push(listener);
            else this._events[evt] = [this._events[evt], listener];
            return this;
          };
          EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt]) return this;
            if (!fn) {
              if (--this._eventsCount === 0) this._events = new Events();
              else delete this._events[evt];
              return this;
            }
            var listeners = this._events[evt];
            if (listeners.fn) {
              if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
                if (--this._eventsCount === 0) this._events = new Events();
                else delete this._events[evt];
              }
            } else {
              for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
                if (listeners[i2].fn !== fn || once && !listeners[i2].once || context2 && listeners[i2].context !== context2) {
                  events.push(listeners[i2]);
                }
              }
              if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
              else if (--this._eventsCount === 0) this._events = new Events();
              else delete this._events[evt];
            }
            return this;
          };
          EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
            var evt;
            if (event) {
              evt = prefix ? prefix + event : event;
              if (this._events[evt]) {
                if (--this._eventsCount === 0) this._events = new Events();
                else delete this._events[evt];
              }
            } else {
              this._events = new Events();
              this._eventsCount = 0;
            }
            return this;
          };
          EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
          EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
          EventEmitter2.prototype.setMaxListeners = function setMaxListeners() {
            return this;
          };
          EventEmitter2.prefixed = prefix;
          EventEmitter2.EventEmitter = EventEmitter2;
          if ("undefined" !== typeof module3) {
            module3.exports = EventEmitter2;
          }
        },
        /* 55 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.matchText = exports3.matchSpacing = exports3.matchNewline = exports3.matchBlot = exports3.matchAttributor = exports3.default = void 0;
          var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _slicedToArray2 = /* @__PURE__ */ function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _extend2 = __webpack_require__(3);
          var _extend3 = _interopRequireDefault2(_extend2);
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _quill = __webpack_require__(5);
          var _quill2 = _interopRequireDefault2(_quill);
          var _logger = __webpack_require__(10);
          var _logger2 = _interopRequireDefault2(_logger);
          var _module = __webpack_require__(9);
          var _module2 = _interopRequireDefault2(_module);
          var _align = __webpack_require__(36);
          var _background = __webpack_require__(37);
          var _code = __webpack_require__(13);
          var _code2 = _interopRequireDefault2(_code);
          var _color = __webpack_require__(26);
          var _direction = __webpack_require__(38);
          var _font = __webpack_require__(39);
          var _size = __webpack_require__(40);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _defineProperty2(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var debug = (0, _logger2.default)("quill:clipboard");
          var DOM_KEY = "__ql-matcher";
          var CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ["br", matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchSpacing], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ["li", matchIndent], ["b", matchAlias.bind(matchAlias, "bold")], ["i", matchAlias.bind(matchAlias, "italic")], ["style", matchIgnore]];
          var ATTRIBUTE_ATTRIBUTORS = [_align.AlignAttribute, _direction.DirectionAttribute].reduce(function(memo, attr) {
            memo[attr.keyName] = attr;
            return memo;
          }, {});
          var STYLE_ATTRIBUTORS = [_align.AlignStyle, _background.BackgroundStyle, _color.ColorStyle, _direction.DirectionStyle, _font.FontStyle, _size.SizeStyle].reduce(function(memo, attr) {
            memo[attr.keyName] = attr;
            return memo;
          }, {});
          var Clipboard2 = function(_Module) {
            _inherits2(Clipboard3, _Module);
            function Clipboard3(quill2, options) {
              _classCallCheck2(this, Clipboard3);
              var _this = _possibleConstructorReturn2(this, (Clipboard3.__proto__ || Object.getPrototypeOf(Clipboard3)).call(this, quill2, options));
              _this.quill.root.addEventListener("paste", _this.onPaste.bind(_this));
              _this.container = _this.quill.addContainer("ql-clipboard");
              _this.container.setAttribute("contenteditable", true);
              _this.container.setAttribute("tabindex", -1);
              _this.matchers = [];
              CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function(_ref) {
                var _ref2 = _slicedToArray2(_ref, 2), selector = _ref2[0], matcher = _ref2[1];
                if (!options.matchVisual && matcher === matchSpacing) return;
                _this.addMatcher(selector, matcher);
              });
              return _this;
            }
            _createClass2(Clipboard3, [{
              key: "addMatcher",
              value: function addMatcher(selector, matcher) {
                this.matchers.push([selector, matcher]);
              }
            }, {
              key: "convert",
              value: function convert(html) {
                if (typeof html === "string") {
                  this.container.innerHTML = html.replace(/\>\r?\n +\</g, "><");
                  return this.convert();
                }
                var formats = this.quill.getFormat(this.quill.selection.savedRange.index);
                if (formats[_code2.default.blotName]) {
                  var text = this.container.innerText;
                  this.container.innerHTML = "";
                  return new _quillDelta2.default().insert(text, _defineProperty2({}, _code2.default.blotName, formats[_code2.default.blotName]));
                }
                var _prepareMatching = this.prepareMatching(), _prepareMatching2 = _slicedToArray2(_prepareMatching, 2), elementMatchers = _prepareMatching2[0], textMatchers = _prepareMatching2[1];
                var delta2 = traverse(this.container, elementMatchers, textMatchers);
                if (deltaEndsWith(delta2, "\n") && delta2.ops[delta2.ops.length - 1].attributes == null) {
                  delta2 = delta2.compose(new _quillDelta2.default().retain(delta2.length() - 1).delete(1));
                }
                debug.log("convert", this.container.innerHTML, delta2);
                this.container.innerHTML = "";
                return delta2;
              }
            }, {
              key: "dangerouslyPasteHTML",
              value: function dangerouslyPasteHTML(index2, html) {
                var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _quill2.default.sources.API;
                if (typeof index2 === "string") {
                  this.quill.setContents(this.convert(index2), html);
                  this.quill.setSelection(0, _quill2.default.sources.SILENT);
                } else {
                  var paste = this.convert(html);
                  this.quill.updateContents(new _quillDelta2.default().retain(index2).concat(paste), source);
                  this.quill.setSelection(index2 + paste.length(), _quill2.default.sources.SILENT);
                }
              }
            }, {
              key: "onPaste",
              value: function onPaste(e2) {
                var _this2 = this;
                if (e2.defaultPrevented || !this.quill.isEnabled()) return;
                var range2 = this.quill.getSelection();
                var delta2 = new _quillDelta2.default().retain(range2.index);
                var scrollTop = this.quill.scrollingContainer.scrollTop;
                this.container.focus();
                this.quill.selection.update(_quill2.default.sources.SILENT);
                setTimeout(function() {
                  delta2 = delta2.concat(_this2.convert()).delete(range2.length);
                  _this2.quill.updateContents(delta2, _quill2.default.sources.USER);
                  _this2.quill.setSelection(delta2.length() - range2.length, _quill2.default.sources.SILENT);
                  _this2.quill.scrollingContainer.scrollTop = scrollTop;
                  _this2.quill.focus();
                }, 1);
              }
            }, {
              key: "prepareMatching",
              value: function prepareMatching() {
                var _this3 = this;
                var elementMatchers = [], textMatchers = [];
                this.matchers.forEach(function(pair) {
                  var _pair = _slicedToArray2(pair, 2), selector = _pair[0], matcher = _pair[1];
                  switch (selector) {
                    case Node.TEXT_NODE:
                      textMatchers.push(matcher);
                      break;
                    case Node.ELEMENT_NODE:
                      elementMatchers.push(matcher);
                      break;
                    default:
                      [].forEach.call(_this3.container.querySelectorAll(selector), function(node) {
                        node[DOM_KEY] = node[DOM_KEY] || [];
                        node[DOM_KEY].push(matcher);
                      });
                      break;
                  }
                });
                return [elementMatchers, textMatchers];
              }
            }]);
            return Clipboard3;
          }(_module2.default);
          Clipboard2.DEFAULTS = {
            matchers: [],
            matchVisual: true
          };
          function applyFormat(delta2, format2, value) {
            if ((typeof format2 === "undefined" ? "undefined" : _typeof2(format2)) === "object") {
              return Object.keys(format2).reduce(function(delta3, key) {
                return applyFormat(delta3, key, format2[key]);
              }, delta2);
            } else {
              return delta2.reduce(function(delta3, op2) {
                if (op2.attributes && op2.attributes[format2]) {
                  return delta3.push(op2);
                } else {
                  return delta3.insert(op2.insert, (0, _extend3.default)({}, _defineProperty2({}, format2, value), op2.attributes));
                }
              }, new _quillDelta2.default());
            }
          }
          function computeStyle(node) {
            if (node.nodeType !== Node.ELEMENT_NODE) return {};
            var DOM_KEY2 = "__ql-computed-style";
            return node[DOM_KEY2] || (node[DOM_KEY2] = window.getComputedStyle(node));
          }
          function deltaEndsWith(delta2, text) {
            var endText = "";
            for (var i2 = delta2.ops.length - 1; i2 >= 0 && endText.length < text.length; --i2) {
              var op2 = delta2.ops[i2];
              if (typeof op2.insert !== "string") break;
              endText = op2.insert + endText;
            }
            return endText.slice(-1 * text.length) === text;
          }
          function isLine(node) {
            if (node.childNodes.length === 0) return false;
            var style = computeStyle(node);
            return ["block", "list-item"].indexOf(style.display) > -1;
          }
          function traverse(node, elementMatchers, textMatchers) {
            if (node.nodeType === node.TEXT_NODE) {
              return textMatchers.reduce(function(delta2, matcher) {
                return matcher(node, delta2);
              }, new _quillDelta2.default());
            } else if (node.nodeType === node.ELEMENT_NODE) {
              return [].reduce.call(node.childNodes || [], function(delta2, childNode) {
                var childrenDelta = traverse(childNode, elementMatchers, textMatchers);
                if (childNode.nodeType === node.ELEMENT_NODE) {
                  childrenDelta = elementMatchers.reduce(function(childrenDelta2, matcher) {
                    return matcher(childNode, childrenDelta2);
                  }, childrenDelta);
                  childrenDelta = (childNode[DOM_KEY] || []).reduce(function(childrenDelta2, matcher) {
                    return matcher(childNode, childrenDelta2);
                  }, childrenDelta);
                }
                return delta2.concat(childrenDelta);
              }, new _quillDelta2.default());
            } else {
              return new _quillDelta2.default();
            }
          }
          function matchAlias(format2, node, delta2) {
            return applyFormat(delta2, format2, true);
          }
          function matchAttributor(node, delta2) {
            var attributes = _parchment2.default.Attributor.Attribute.keys(node);
            var classes = _parchment2.default.Attributor.Class.keys(node);
            var styles2 = _parchment2.default.Attributor.Style.keys(node);
            var formats = {};
            attributes.concat(classes).concat(styles2).forEach(function(name2) {
              var attr = _parchment2.default.query(name2, _parchment2.default.Scope.ATTRIBUTE);
              if (attr != null) {
                formats[attr.attrName] = attr.value(node);
                if (formats[attr.attrName]) return;
              }
              attr = ATTRIBUTE_ATTRIBUTORS[name2];
              if (attr != null && (attr.attrName === name2 || attr.keyName === name2)) {
                formats[attr.attrName] = attr.value(node) || void 0;
              }
              attr = STYLE_ATTRIBUTORS[name2];
              if (attr != null && (attr.attrName === name2 || attr.keyName === name2)) {
                attr = STYLE_ATTRIBUTORS[name2];
                formats[attr.attrName] = attr.value(node) || void 0;
              }
            });
            if (Object.keys(formats).length > 0) {
              delta2 = applyFormat(delta2, formats);
            }
            return delta2;
          }
          function matchBlot(node, delta2) {
            var match = _parchment2.default.query(node);
            if (match == null) return delta2;
            if (match.prototype instanceof _parchment2.default.Embed) {
              var embed = {};
              var value = match.value(node);
              if (value != null) {
                embed[match.blotName] = value;
                delta2 = new _quillDelta2.default().insert(embed, match.formats(node));
              }
            } else if (typeof match.formats === "function") {
              delta2 = applyFormat(delta2, match.blotName, match.formats(node));
            }
            return delta2;
          }
          function matchBreak(node, delta2) {
            if (!deltaEndsWith(delta2, "\n")) {
              delta2.insert("\n");
            }
            return delta2;
          }
          function matchIgnore() {
            return new _quillDelta2.default();
          }
          function matchIndent(node, delta2) {
            var match = _parchment2.default.query(node);
            if (match == null || match.blotName !== "list-item" || !deltaEndsWith(delta2, "\n")) {
              return delta2;
            }
            var indent = -1, parent2 = node.parentNode;
            while (!parent2.classList.contains("ql-clipboard")) {
              if ((_parchment2.default.query(parent2) || {}).blotName === "list") {
                indent += 1;
              }
              parent2 = parent2.parentNode;
            }
            if (indent <= 0) return delta2;
            return delta2.compose(new _quillDelta2.default().retain(delta2.length() - 1).retain(1, { indent }));
          }
          function matchNewline(node, delta2) {
            if (!deltaEndsWith(delta2, "\n")) {
              if (isLine(node) || delta2.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {
                delta2.insert("\n");
              }
            }
            return delta2;
          }
          function matchSpacing(node, delta2) {
            if (isLine(node) && node.nextElementSibling != null && !deltaEndsWith(delta2, "\n\n")) {
              var nodeHeight = node.offsetHeight + parseFloat(computeStyle(node).marginTop) + parseFloat(computeStyle(node).marginBottom);
              if (node.nextElementSibling.offsetTop > node.offsetTop + nodeHeight * 1.5) {
                delta2.insert("\n");
              }
            }
            return delta2;
          }
          function matchStyles(node, delta2) {
            var formats = {};
            var style = node.style || {};
            if (style.fontStyle && computeStyle(node).fontStyle === "italic") {
              formats.italic = true;
            }
            if (style.fontWeight && (computeStyle(node).fontWeight.startsWith("bold") || parseInt(computeStyle(node).fontWeight) >= 700)) {
              formats.bold = true;
            }
            if (Object.keys(formats).length > 0) {
              delta2 = applyFormat(delta2, formats);
            }
            if (parseFloat(style.textIndent || 0) > 0) {
              delta2 = new _quillDelta2.default().insert("	").concat(delta2);
            }
            return delta2;
          }
          function matchText(node, delta2) {
            var text = node.data;
            if (node.parentNode.tagName === "O:P") {
              return delta2.insert(text.trim());
            }
            if (text.trim().length === 0 && node.parentNode.classList.contains("ql-clipboard")) {
              return delta2;
            }
            if (!computeStyle(node.parentNode).whiteSpace.startsWith("pre")) {
              var replacer = function replacer2(collapse, match) {
                match = match.replace(/[^\u00a0]/g, "");
                return match.length < 1 && collapse ? " " : match;
              };
              text = text.replace(/\r\n/g, " ").replace(/\n/g, " ");
              text = text.replace(/\s\s+/g, replacer.bind(replacer, true));
              if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {
                text = text.replace(/^\s+/, replacer.bind(replacer, false));
              }
              if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {
                text = text.replace(/\s+$/, replacer.bind(replacer, false));
              }
            }
            return delta2.insert(text);
          }
          exports3.default = Clipboard2;
          exports3.matchAttributor = matchAttributor;
          exports3.matchBlot = matchBlot;
          exports3.matchNewline = matchNewline;
          exports3.matchSpacing = matchSpacing;
          exports3.matchText = matchText;
        },
        /* 56 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Bold = function(_Inline) {
            _inherits2(Bold2, _Inline);
            function Bold2() {
              _classCallCheck2(this, Bold2);
              return _possibleConstructorReturn2(this, (Bold2.__proto__ || Object.getPrototypeOf(Bold2)).apply(this, arguments));
            }
            _createClass2(Bold2, [{
              key: "optimize",
              value: function optimize(context2) {
                _get2(Bold2.prototype.__proto__ || Object.getPrototypeOf(Bold2.prototype), "optimize", this).call(this, context2);
                if (this.domNode.tagName !== this.statics.tagName[0]) {
                  this.replaceWith(this.statics.blotName);
                }
              }
            }], [{
              key: "create",
              value: function create() {
                return _get2(Bold2.__proto__ || Object.getPrototypeOf(Bold2), "create", this).call(this);
              }
            }, {
              key: "formats",
              value: function formats() {
                return true;
              }
            }]);
            return Bold2;
          }(_inline2.default);
          Bold.blotName = "bold";
          Bold.tagName = ["STRONG", "B"];
          exports3.default = Bold;
        },
        /* 57 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.addControls = exports3.default = void 0;
          var _slicedToArray2 = /* @__PURE__ */ function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _quill = __webpack_require__(5);
          var _quill2 = _interopRequireDefault2(_quill);
          var _logger = __webpack_require__(10);
          var _logger2 = _interopRequireDefault2(_logger);
          var _module = __webpack_require__(9);
          var _module2 = _interopRequireDefault2(_module);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _defineProperty2(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var debug = (0, _logger2.default)("quill:toolbar");
          var Toolbar = function(_Module) {
            _inherits2(Toolbar2, _Module);
            function Toolbar2(quill2, options) {
              _classCallCheck2(this, Toolbar2);
              var _this = _possibleConstructorReturn2(this, (Toolbar2.__proto__ || Object.getPrototypeOf(Toolbar2)).call(this, quill2, options));
              if (Array.isArray(_this.options.container)) {
                var container2 = document.createElement("div");
                addControls(container2, _this.options.container);
                quill2.container.parentNode.insertBefore(container2, quill2.container);
                _this.container = container2;
              } else if (typeof _this.options.container === "string") {
                _this.container = document.querySelector(_this.options.container);
              } else {
                _this.container = _this.options.container;
              }
              if (!(_this.container instanceof HTMLElement)) {
                var _ret;
                return _ret = debug.error("Container required for toolbar", _this.options), _possibleConstructorReturn2(_this, _ret);
              }
              _this.container.classList.add("ql-toolbar");
              _this.controls = [];
              _this.handlers = {};
              Object.keys(_this.options.handlers).forEach(function(format2) {
                _this.addHandler(format2, _this.options.handlers[format2]);
              });
              [].forEach.call(_this.container.querySelectorAll("button, select"), function(input2) {
                _this.attach(input2);
              });
              _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function(type2, range2) {
                if (type2 === _quill2.default.events.SELECTION_CHANGE) {
                  _this.update(range2);
                }
              });
              _this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function() {
                var _this$quill$selection = _this.quill.selection.getRange(), _this$quill$selection2 = _slicedToArray2(_this$quill$selection, 1), range2 = _this$quill$selection2[0];
                _this.update(range2);
              });
              return _this;
            }
            _createClass2(Toolbar2, [{
              key: "addHandler",
              value: function addHandler(format2, handler) {
                this.handlers[format2] = handler;
              }
            }, {
              key: "attach",
              value: function attach(input2) {
                var _this2 = this;
                var format2 = [].find.call(input2.classList, function(className) {
                  return className.indexOf("ql-") === 0;
                });
                if (!format2) return;
                format2 = format2.slice("ql-".length);
                if (input2.tagName === "BUTTON") {
                  input2.setAttribute("type", "button");
                }
                if (this.handlers[format2] == null) {
                  if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format2] == null) {
                    debug.warn("ignoring attaching to disabled format", format2, input2);
                    return;
                  }
                  if (_parchment2.default.query(format2) == null) {
                    debug.warn("ignoring attaching to nonexistent format", format2, input2);
                    return;
                  }
                }
                var eventName = input2.tagName === "SELECT" ? "change" : "click";
                input2.addEventListener(eventName, function(e2) {
                  var value = void 0;
                  if (input2.tagName === "SELECT") {
                    if (input2.selectedIndex < 0) return;
                    var selected = input2.options[input2.selectedIndex];
                    if (selected.hasAttribute("selected")) {
                      value = false;
                    } else {
                      value = selected.value || false;
                    }
                  } else {
                    if (input2.classList.contains("ql-active")) {
                      value = false;
                    } else {
                      value = input2.value || !input2.hasAttribute("value");
                    }
                    e2.preventDefault();
                  }
                  _this2.quill.focus();
                  var _quill$selection$getR = _this2.quill.selection.getRange(), _quill$selection$getR2 = _slicedToArray2(_quill$selection$getR, 1), range2 = _quill$selection$getR2[0];
                  if (_this2.handlers[format2] != null) {
                    _this2.handlers[format2].call(_this2, value);
                  } else if (_parchment2.default.query(format2).prototype instanceof _parchment2.default.Embed) {
                    value = prompt("Enter " + format2);
                    if (!value) return;
                    _this2.quill.updateContents(new _quillDelta2.default().retain(range2.index).delete(range2.length).insert(_defineProperty2({}, format2, value)), _quill2.default.sources.USER);
                  } else {
                    _this2.quill.format(format2, value, _quill2.default.sources.USER);
                  }
                  _this2.update(range2);
                });
                this.controls.push([format2, input2]);
              }
            }, {
              key: "update",
              value: function update8(range2) {
                var formats = range2 == null ? {} : this.quill.getFormat(range2);
                this.controls.forEach(function(pair) {
                  var _pair = _slicedToArray2(pair, 2), format2 = _pair[0], input2 = _pair[1];
                  if (input2.tagName === "SELECT") {
                    var option = void 0;
                    if (range2 == null) {
                      option = null;
                    } else if (formats[format2] == null) {
                      option = input2.querySelector("option[selected]");
                    } else if (!Array.isArray(formats[format2])) {
                      var value = formats[format2];
                      if (typeof value === "string") {
                        value = value.replace(/\"/g, '\\"');
                      }
                      option = input2.querySelector('option[value="' + value + '"]');
                    }
                    if (option == null) {
                      input2.value = "";
                      input2.selectedIndex = -1;
                    } else {
                      option.selected = true;
                    }
                  } else {
                    if (range2 == null) {
                      input2.classList.remove("ql-active");
                    } else if (input2.hasAttribute("value")) {
                      var isActive = formats[format2] === input2.getAttribute("value") || formats[format2] != null && formats[format2].toString() === input2.getAttribute("value") || formats[format2] == null && !input2.getAttribute("value");
                      input2.classList.toggle("ql-active", isActive);
                    } else {
                      input2.classList.toggle("ql-active", formats[format2] != null);
                    }
                  }
                });
              }
            }]);
            return Toolbar2;
          }(_module2.default);
          Toolbar.DEFAULTS = {};
          function addButton2(container2, format2, value) {
            var input2 = document.createElement("button");
            input2.setAttribute("type", "button");
            input2.classList.add("ql-" + format2);
            if (value != null) {
              input2.value = value;
            }
            container2.appendChild(input2);
          }
          function addControls(container2, groups) {
            if (!Array.isArray(groups[0])) {
              groups = [groups];
            }
            groups.forEach(function(controls) {
              var group3 = document.createElement("span");
              group3.classList.add("ql-formats");
              controls.forEach(function(control) {
                if (typeof control === "string") {
                  addButton2(group3, control);
                } else {
                  var format2 = Object.keys(control)[0];
                  var value = control[format2];
                  if (Array.isArray(value)) {
                    addSelect(group3, format2, value);
                  } else {
                    addButton2(group3, format2, value);
                  }
                }
              });
              container2.appendChild(group3);
            });
          }
          function addSelect(container2, format2, values2) {
            var input2 = document.createElement("select");
            input2.classList.add("ql-" + format2);
            values2.forEach(function(value) {
              var option = document.createElement("option");
              if (value !== false) {
                option.setAttribute("value", value);
              } else {
                option.setAttribute("selected", "selected");
              }
              input2.appendChild(option);
            });
            container2.appendChild(input2);
          }
          Toolbar.DEFAULTS = {
            container: null,
            handlers: {
              clean: function clean() {
                var _this3 = this;
                var range2 = this.quill.getSelection();
                if (range2 == null) return;
                if (range2.length == 0) {
                  var formats = this.quill.getFormat();
                  Object.keys(formats).forEach(function(name2) {
                    if (_parchment2.default.query(name2, _parchment2.default.Scope.INLINE) != null) {
                      _this3.quill.format(name2, false);
                    }
                  });
                } else {
                  this.quill.removeFormat(range2, _quill2.default.sources.USER);
                }
              },
              direction: function direction(value) {
                var align = this.quill.getFormat()["align"];
                if (value === "rtl" && align == null) {
                  this.quill.format("align", "right", _quill2.default.sources.USER);
                } else if (!value && align === "right") {
                  this.quill.format("align", false, _quill2.default.sources.USER);
                }
                this.quill.format("direction", value, _quill2.default.sources.USER);
              },
              indent: function indent(value) {
                var range2 = this.quill.getSelection();
                var formats = this.quill.getFormat(range2);
                var indent2 = parseInt(formats.indent || 0);
                if (value === "+1" || value === "-1") {
                  var modifier = value === "+1" ? 1 : -1;
                  if (formats.direction === "rtl") modifier *= -1;
                  this.quill.format("indent", indent2 + modifier, _quill2.default.sources.USER);
                }
              },
              link: function link(value) {
                if (value === true) {
                  value = prompt("Enter link URL:");
                }
                this.quill.format("link", value, _quill2.default.sources.USER);
              },
              list: function list2(value) {
                var range2 = this.quill.getSelection();
                var formats = this.quill.getFormat(range2);
                if (value === "check") {
                  if (formats["list"] === "checked" || formats["list"] === "unchecked") {
                    this.quill.format("list", false, _quill2.default.sources.USER);
                  } else {
                    this.quill.format("list", "unchecked", _quill2.default.sources.USER);
                  }
                } else {
                  this.quill.format("list", value, _quill2.default.sources.USER);
                }
              }
            }
          };
          exports3.default = Toolbar;
          exports3.addControls = addControls;
        },
        /* 58 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"></polyline> <polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>';
        },
        /* 59 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _picker = __webpack_require__(28);
          var _picker2 = _interopRequireDefault2(_picker);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var ColorPicker = function(_Picker) {
            _inherits2(ColorPicker2, _Picker);
            function ColorPicker2(select, label2) {
              _classCallCheck2(this, ColorPicker2);
              var _this = _possibleConstructorReturn2(this, (ColorPicker2.__proto__ || Object.getPrototypeOf(ColorPicker2)).call(this, select));
              _this.label.innerHTML = label2;
              _this.container.classList.add("ql-color-picker");
              [].slice.call(_this.container.querySelectorAll(".ql-picker-item"), 0, 7).forEach(function(item) {
                item.classList.add("ql-primary");
              });
              return _this;
            }
            _createClass2(ColorPicker2, [{
              key: "buildItem",
              value: function buildItem(option) {
                var item = _get2(ColorPicker2.prototype.__proto__ || Object.getPrototypeOf(ColorPicker2.prototype), "buildItem", this).call(this, option);
                item.style.backgroundColor = option.getAttribute("value") || "";
                return item;
              }
            }, {
              key: "selectItem",
              value: function selectItem(item, trigger) {
                _get2(ColorPicker2.prototype.__proto__ || Object.getPrototypeOf(ColorPicker2.prototype), "selectItem", this).call(this, item, trigger);
                var colorLabel = this.label.querySelector(".ql-color-label");
                var value = item ? item.getAttribute("data-value") || "" : "";
                if (colorLabel) {
                  if (colorLabel.tagName === "line") {
                    colorLabel.style.stroke = value;
                  } else {
                    colorLabel.style.fill = value;
                  }
                }
              }
            }]);
            return ColorPicker2;
          }(_picker2.default);
          exports3.default = ColorPicker;
        },
        /* 60 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _picker = __webpack_require__(28);
          var _picker2 = _interopRequireDefault2(_picker);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var IconPicker = function(_Picker) {
            _inherits2(IconPicker2, _Picker);
            function IconPicker2(select, icons) {
              _classCallCheck2(this, IconPicker2);
              var _this = _possibleConstructorReturn2(this, (IconPicker2.__proto__ || Object.getPrototypeOf(IconPicker2)).call(this, select));
              _this.container.classList.add("ql-icon-picker");
              [].forEach.call(_this.container.querySelectorAll(".ql-picker-item"), function(item) {
                item.innerHTML = icons[item.getAttribute("data-value") || ""];
              });
              _this.defaultItem = _this.container.querySelector(".ql-selected");
              _this.selectItem(_this.defaultItem);
              return _this;
            }
            _createClass2(IconPicker2, [{
              key: "selectItem",
              value: function selectItem(item, trigger) {
                _get2(IconPicker2.prototype.__proto__ || Object.getPrototypeOf(IconPicker2.prototype), "selectItem", this).call(this, item, trigger);
                item = item || this.defaultItem;
                this.label.innerHTML = item.innerHTML;
              }
            }]);
            return IconPicker2;
          }(_picker2.default);
          exports3.default = IconPicker;
        },
        /* 61 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var Tooltip2 = function() {
            function Tooltip3(quill2, boundsContainer) {
              var _this = this;
              _classCallCheck2(this, Tooltip3);
              this.quill = quill2;
              this.boundsContainer = boundsContainer || document.body;
              this.root = quill2.addContainer("ql-tooltip");
              this.root.innerHTML = this.constructor.TEMPLATE;
              if (this.quill.root === this.quill.scrollingContainer) {
                this.quill.root.addEventListener("scroll", function() {
                  _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + "px";
                });
              }
              this.hide();
            }
            _createClass2(Tooltip3, [{
              key: "hide",
              value: function hide2() {
                this.root.classList.add("ql-hidden");
              }
            }, {
              key: "position",
              value: function position(reference) {
                var left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;
                var top = reference.bottom + this.quill.root.scrollTop;
                this.root.style.left = left + "px";
                this.root.style.top = top + "px";
                this.root.classList.remove("ql-flip");
                var containerBounds = this.boundsContainer.getBoundingClientRect();
                var rootBounds = this.root.getBoundingClientRect();
                var shift = 0;
                if (rootBounds.right > containerBounds.right) {
                  shift = containerBounds.right - rootBounds.right;
                  this.root.style.left = left + shift + "px";
                }
                if (rootBounds.left < containerBounds.left) {
                  shift = containerBounds.left - rootBounds.left;
                  this.root.style.left = left + shift + "px";
                }
                if (rootBounds.bottom > containerBounds.bottom) {
                  var height = rootBounds.bottom - rootBounds.top;
                  var verticalShift = reference.bottom - reference.top + height;
                  this.root.style.top = top - verticalShift + "px";
                  this.root.classList.add("ql-flip");
                }
                return shift;
              }
            }, {
              key: "show",
              value: function show() {
                this.root.classList.remove("ql-editing");
                this.root.classList.remove("ql-hidden");
              }
            }]);
            return Tooltip3;
          }();
          exports3.default = Tooltip2;
        },
        /* 62 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _slicedToArray2 = /* @__PURE__ */ function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _extend = __webpack_require__(3);
          var _extend2 = _interopRequireDefault2(_extend);
          var _emitter = __webpack_require__(8);
          var _emitter2 = _interopRequireDefault2(_emitter);
          var _base = __webpack_require__(43);
          var _base2 = _interopRequireDefault2(_base);
          var _link = __webpack_require__(27);
          var _link2 = _interopRequireDefault2(_link);
          var _selection = __webpack_require__(15);
          var _icons = __webpack_require__(41);
          var _icons2 = _interopRequireDefault2(_icons);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var TOOLBAR_CONFIG = [[{ header: ["1", "2", "3", false] }], ["bold", "italic", "underline", "link"], [{ list: "ordered" }, { list: "bullet" }], ["clean"]];
          var SnowTheme = function(_BaseTheme) {
            _inherits2(SnowTheme2, _BaseTheme);
            function SnowTheme2(quill2, options) {
              _classCallCheck2(this, SnowTheme2);
              if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
                options.modules.toolbar.container = TOOLBAR_CONFIG;
              }
              var _this = _possibleConstructorReturn2(this, (SnowTheme2.__proto__ || Object.getPrototypeOf(SnowTheme2)).call(this, quill2, options));
              _this.quill.container.classList.add("ql-snow");
              return _this;
            }
            _createClass2(SnowTheme2, [{
              key: "extendToolbar",
              value: function extendToolbar(toolbar) {
                toolbar.container.classList.add("ql-snow");
                this.buildButtons([].slice.call(toolbar.container.querySelectorAll("button")), _icons2.default);
                this.buildPickers([].slice.call(toolbar.container.querySelectorAll("select")), _icons2.default);
                this.tooltip = new SnowTooltip(this.quill, this.options.bounds);
                if (toolbar.container.querySelector(".ql-link")) {
                  this.quill.keyboard.addBinding({ key: "K", shortKey: true }, function(range2, context2) {
                    toolbar.handlers["link"].call(toolbar, !context2.format.link);
                  });
                }
              }
            }]);
            return SnowTheme2;
          }(_base2.default);
          SnowTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
            modules: {
              toolbar: {
                handlers: {
                  link: function link(value) {
                    if (value) {
                      var range2 = this.quill.getSelection();
                      if (range2 == null || range2.length == 0) return;
                      var preview = this.quill.getText(range2);
                      if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf("mailto:") !== 0) {
                        preview = "mailto:" + preview;
                      }
                      var tooltip = this.quill.theme.tooltip;
                      tooltip.edit("link", preview);
                    } else {
                      this.quill.format("link", false);
                    }
                  }
                }
              }
            }
          });
          var SnowTooltip = function(_BaseTooltip) {
            _inherits2(SnowTooltip2, _BaseTooltip);
            function SnowTooltip2(quill2, bounds) {
              _classCallCheck2(this, SnowTooltip2);
              var _this2 = _possibleConstructorReturn2(this, (SnowTooltip2.__proto__ || Object.getPrototypeOf(SnowTooltip2)).call(this, quill2, bounds));
              _this2.preview = _this2.root.querySelector("a.ql-preview");
              return _this2;
            }
            _createClass2(SnowTooltip2, [{
              key: "listen",
              value: function listen() {
                var _this3 = this;
                _get2(SnowTooltip2.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip2.prototype), "listen", this).call(this);
                this.root.querySelector("a.ql-action").addEventListener("click", function(event) {
                  if (_this3.root.classList.contains("ql-editing")) {
                    _this3.save();
                  } else {
                    _this3.edit("link", _this3.preview.textContent);
                  }
                  event.preventDefault();
                });
                this.root.querySelector("a.ql-remove").addEventListener("click", function(event) {
                  if (_this3.linkRange != null) {
                    var range2 = _this3.linkRange;
                    _this3.restoreFocus();
                    _this3.quill.formatText(range2, "link", false, _emitter2.default.sources.USER);
                    delete _this3.linkRange;
                  }
                  event.preventDefault();
                  _this3.hide();
                });
                this.quill.on(_emitter2.default.events.SELECTION_CHANGE, function(range2, oldRange, source) {
                  if (range2 == null) return;
                  if (range2.length === 0 && source === _emitter2.default.sources.USER) {
                    var _quill$scroll$descend = _this3.quill.scroll.descendant(_link2.default, range2.index), _quill$scroll$descend2 = _slicedToArray2(_quill$scroll$descend, 2), link = _quill$scroll$descend2[0], offset2 = _quill$scroll$descend2[1];
                    if (link != null) {
                      _this3.linkRange = new _selection.Range(range2.index - offset2, link.length());
                      var preview = _link2.default.formats(link.domNode);
                      _this3.preview.textContent = preview;
                      _this3.preview.setAttribute("href", preview);
                      _this3.show();
                      _this3.position(_this3.quill.getBounds(_this3.linkRange));
                      return;
                    }
                  } else {
                    delete _this3.linkRange;
                  }
                  _this3.hide();
                });
              }
            }, {
              key: "show",
              value: function show() {
                _get2(SnowTooltip2.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip2.prototype), "show", this).call(this);
                this.root.removeAttribute("data-mode");
              }
            }]);
            return SnowTooltip2;
          }(_base.BaseTooltip);
          SnowTooltip.TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join("");
          exports3.default = SnowTheme;
        },
        /* 63 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _core = __webpack_require__(29);
          var _core2 = _interopRequireDefault2(_core);
          var _align = __webpack_require__(36);
          var _direction = __webpack_require__(38);
          var _indent = __webpack_require__(64);
          var _blockquote = __webpack_require__(65);
          var _blockquote2 = _interopRequireDefault2(_blockquote);
          var _header = __webpack_require__(66);
          var _header2 = _interopRequireDefault2(_header);
          var _list = __webpack_require__(67);
          var _list2 = _interopRequireDefault2(_list);
          var _background = __webpack_require__(37);
          var _color = __webpack_require__(26);
          var _font = __webpack_require__(39);
          var _size = __webpack_require__(40);
          var _bold = __webpack_require__(56);
          var _bold2 = _interopRequireDefault2(_bold);
          var _italic = __webpack_require__(68);
          var _italic2 = _interopRequireDefault2(_italic);
          var _link = __webpack_require__(27);
          var _link2 = _interopRequireDefault2(_link);
          var _script = __webpack_require__(69);
          var _script2 = _interopRequireDefault2(_script);
          var _strike = __webpack_require__(70);
          var _strike2 = _interopRequireDefault2(_strike);
          var _underline = __webpack_require__(71);
          var _underline2 = _interopRequireDefault2(_underline);
          var _image = __webpack_require__(72);
          var _image2 = _interopRequireDefault2(_image);
          var _video = __webpack_require__(73);
          var _video2 = _interopRequireDefault2(_video);
          var _code = __webpack_require__(13);
          var _code2 = _interopRequireDefault2(_code);
          var _formula = __webpack_require__(74);
          var _formula2 = _interopRequireDefault2(_formula);
          var _syntax = __webpack_require__(75);
          var _syntax2 = _interopRequireDefault2(_syntax);
          var _toolbar = __webpack_require__(57);
          var _toolbar2 = _interopRequireDefault2(_toolbar);
          var _icons = __webpack_require__(41);
          var _icons2 = _interopRequireDefault2(_icons);
          var _picker = __webpack_require__(28);
          var _picker2 = _interopRequireDefault2(_picker);
          var _colorPicker = __webpack_require__(59);
          var _colorPicker2 = _interopRequireDefault2(_colorPicker);
          var _iconPicker = __webpack_require__(60);
          var _iconPicker2 = _interopRequireDefault2(_iconPicker);
          var _tooltip = __webpack_require__(61);
          var _tooltip2 = _interopRequireDefault2(_tooltip);
          var _bubble = __webpack_require__(108);
          var _bubble2 = _interopRequireDefault2(_bubble);
          var _snow = __webpack_require__(62);
          var _snow2 = _interopRequireDefault2(_snow);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          _core2.default.register({
            "attributors/attribute/direction": _direction.DirectionAttribute,
            "attributors/class/align": _align.AlignClass,
            "attributors/class/background": _background.BackgroundClass,
            "attributors/class/color": _color.ColorClass,
            "attributors/class/direction": _direction.DirectionClass,
            "attributors/class/font": _font.FontClass,
            "attributors/class/size": _size.SizeClass,
            "attributors/style/align": _align.AlignStyle,
            "attributors/style/background": _background.BackgroundStyle,
            "attributors/style/color": _color.ColorStyle,
            "attributors/style/direction": _direction.DirectionStyle,
            "attributors/style/font": _font.FontStyle,
            "attributors/style/size": _size.SizeStyle
          }, true);
          _core2.default.register({
            "formats/align": _align.AlignClass,
            "formats/direction": _direction.DirectionClass,
            "formats/indent": _indent.IndentClass,
            "formats/background": _background.BackgroundStyle,
            "formats/color": _color.ColorStyle,
            "formats/font": _font.FontClass,
            "formats/size": _size.SizeClass,
            "formats/blockquote": _blockquote2.default,
            "formats/code-block": _code2.default,
            "formats/header": _header2.default,
            "formats/list": _list2.default,
            "formats/bold": _bold2.default,
            "formats/code": _code.Code,
            "formats/italic": _italic2.default,
            "formats/link": _link2.default,
            "formats/script": _script2.default,
            "formats/strike": _strike2.default,
            "formats/underline": _underline2.default,
            "formats/image": _image2.default,
            "formats/video": _video2.default,
            "formats/list/item": _list.ListItem,
            "modules/formula": _formula2.default,
            "modules/syntax": _syntax2.default,
            "modules/toolbar": _toolbar2.default,
            "themes/bubble": _bubble2.default,
            "themes/snow": _snow2.default,
            "ui/icons": _icons2.default,
            "ui/picker": _picker2.default,
            "ui/icon-picker": _iconPicker2.default,
            "ui/color-picker": _colorPicker2.default,
            "ui/tooltip": _tooltip2.default
          }, true);
          exports3.default = _core2.default;
        },
        /* 64 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.IndentClass = void 0;
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var IdentAttributor = function(_Parchment$Attributor) {
            _inherits2(IdentAttributor2, _Parchment$Attributor);
            function IdentAttributor2() {
              _classCallCheck2(this, IdentAttributor2);
              return _possibleConstructorReturn2(this, (IdentAttributor2.__proto__ || Object.getPrototypeOf(IdentAttributor2)).apply(this, arguments));
            }
            _createClass2(IdentAttributor2, [{
              key: "add",
              value: function add2(node, value) {
                if (value === "+1" || value === "-1") {
                  var indent = this.value(node) || 0;
                  value = value === "+1" ? indent + 1 : indent - 1;
                }
                if (value === 0) {
                  this.remove(node);
                  return true;
                } else {
                  return _get2(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "add", this).call(this, node, value);
                }
              }
            }, {
              key: "canAdd",
              value: function canAdd(node, value) {
                return _get2(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "canAdd", this).call(this, node, value) || _get2(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "canAdd", this).call(this, node, parseInt(value));
              }
            }, {
              key: "value",
              value: function value(node) {
                return parseInt(_get2(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "value", this).call(this, node)) || void 0;
              }
            }]);
            return IdentAttributor2;
          }(_parchment2.default.Attributor.Class);
          var IndentClass = new IdentAttributor("indent", "ql-indent", {
            scope: _parchment2.default.Scope.BLOCK,
            whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
          });
          exports3.IndentClass = IndentClass;
        },
        /* 65 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Blockquote = function(_Block) {
            _inherits2(Blockquote2, _Block);
            function Blockquote2() {
              _classCallCheck2(this, Blockquote2);
              return _possibleConstructorReturn2(this, (Blockquote2.__proto__ || Object.getPrototypeOf(Blockquote2)).apply(this, arguments));
            }
            return Blockquote2;
          }(_block2.default);
          Blockquote.blotName = "blockquote";
          Blockquote.tagName = "blockquote";
          exports3.default = Blockquote;
        },
        /* 66 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Header2 = function(_Block) {
            _inherits2(Header3, _Block);
            function Header3() {
              _classCallCheck2(this, Header3);
              return _possibleConstructorReturn2(this, (Header3.__proto__ || Object.getPrototypeOf(Header3)).apply(this, arguments));
            }
            _createClass2(Header3, null, [{
              key: "formats",
              value: function formats(domNode) {
                return this.tagName.indexOf(domNode.tagName) + 1;
              }
            }]);
            return Header3;
          }(_block2.default);
          Header2.blotName = "header";
          Header2.tagName = ["H1", "H2", "H3", "H4", "H5", "H6"];
          exports3.default = Header2;
        },
        /* 67 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.ListItem = void 0;
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          var _container = __webpack_require__(25);
          var _container2 = _interopRequireDefault2(_container);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _defineProperty2(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var ListItem = function(_Block) {
            _inherits2(ListItem2, _Block);
            function ListItem2() {
              _classCallCheck2(this, ListItem2);
              return _possibleConstructorReturn2(this, (ListItem2.__proto__ || Object.getPrototypeOf(ListItem2)).apply(this, arguments));
            }
            _createClass2(ListItem2, [{
              key: "format",
              value: function format2(name2, value) {
                if (name2 === List2.blotName && !value) {
                  this.replaceWith(_parchment2.default.create(this.statics.scope));
                } else {
                  _get2(ListItem2.prototype.__proto__ || Object.getPrototypeOf(ListItem2.prototype), "format", this).call(this, name2, value);
                }
              }
            }, {
              key: "remove",
              value: function remove3() {
                if (this.prev == null && this.next == null) {
                  this.parent.remove();
                } else {
                  _get2(ListItem2.prototype.__proto__ || Object.getPrototypeOf(ListItem2.prototype), "remove", this).call(this);
                }
              }
            }, {
              key: "replaceWith",
              value: function replaceWith(name2, value) {
                this.parent.isolate(this.offset(this.parent), this.length());
                if (name2 === this.parent.statics.blotName) {
                  this.parent.replaceWith(name2, value);
                  return this;
                } else {
                  this.parent.unwrap();
                  return _get2(ListItem2.prototype.__proto__ || Object.getPrototypeOf(ListItem2.prototype), "replaceWith", this).call(this, name2, value);
                }
              }
            }], [{
              key: "formats",
              value: function formats(domNode) {
                return domNode.tagName === this.tagName ? void 0 : _get2(ListItem2.__proto__ || Object.getPrototypeOf(ListItem2), "formats", this).call(this, domNode);
              }
            }]);
            return ListItem2;
          }(_block2.default);
          ListItem.blotName = "list-item";
          ListItem.tagName = "LI";
          var List2 = function(_Container) {
            _inherits2(List3, _Container);
            _createClass2(List3, null, [{
              key: "create",
              value: function create(value) {
                var tagName = value === "ordered" ? "OL" : "UL";
                var node = _get2(List3.__proto__ || Object.getPrototypeOf(List3), "create", this).call(this, tagName);
                if (value === "checked" || value === "unchecked") {
                  node.setAttribute("data-checked", value === "checked");
                }
                return node;
              }
            }, {
              key: "formats",
              value: function formats(domNode) {
                if (domNode.tagName === "OL") return "ordered";
                if (domNode.tagName === "UL") {
                  if (domNode.hasAttribute("data-checked")) {
                    return domNode.getAttribute("data-checked") === "true" ? "checked" : "unchecked";
                  } else {
                    return "bullet";
                  }
                }
                return void 0;
              }
            }]);
            function List3(domNode) {
              _classCallCheck2(this, List3);
              var _this2 = _possibleConstructorReturn2(this, (List3.__proto__ || Object.getPrototypeOf(List3)).call(this, domNode));
              var listEventHandler = function listEventHandler2(e2) {
                if (e2.target.parentNode !== domNode) return;
                var format2 = _this2.statics.formats(domNode);
                var blot = _parchment2.default.find(e2.target);
                if (format2 === "checked") {
                  blot.format("list", "unchecked");
                } else if (format2 === "unchecked") {
                  blot.format("list", "checked");
                }
              };
              domNode.addEventListener("touchstart", listEventHandler);
              domNode.addEventListener("mousedown", listEventHandler);
              return _this2;
            }
            _createClass2(List3, [{
              key: "format",
              value: function format2(name2, value) {
                if (this.children.length > 0) {
                  this.children.tail.format(name2, value);
                }
              }
            }, {
              key: "formats",
              value: function formats() {
                return _defineProperty2({}, this.statics.blotName, this.statics.formats(this.domNode));
              }
            }, {
              key: "insertBefore",
              value: function insertBefore(blot, ref2) {
                if (blot instanceof ListItem) {
                  _get2(List3.prototype.__proto__ || Object.getPrototypeOf(List3.prototype), "insertBefore", this).call(this, blot, ref2);
                } else {
                  var index2 = ref2 == null ? this.length() : ref2.offset(this);
                  var after = this.split(index2);
                  after.parent.insertBefore(blot, after);
                }
              }
            }, {
              key: "optimize",
              value: function optimize(context2) {
                _get2(List3.prototype.__proto__ || Object.getPrototypeOf(List3.prototype), "optimize", this).call(this, context2);
                var next = this.next;
                if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName && next.domNode.getAttribute("data-checked") === this.domNode.getAttribute("data-checked")) {
                  next.moveChildren(this);
                  next.remove();
                }
              }
            }, {
              key: "replace",
              value: function replace(target) {
                if (target.statics.blotName !== this.statics.blotName) {
                  var item = _parchment2.default.create(this.statics.defaultChild);
                  target.moveChildren(item);
                  this.appendChild(item);
                }
                _get2(List3.prototype.__proto__ || Object.getPrototypeOf(List3.prototype), "replace", this).call(this, target);
              }
            }]);
            return List3;
          }(_container2.default);
          List2.blotName = "list";
          List2.scope = _parchment2.default.Scope.BLOCK_BLOT;
          List2.tagName = ["OL", "UL"];
          List2.defaultChild = "list-item";
          List2.allowedChildren = [ListItem];
          exports3.ListItem = ListItem;
          exports3.default = List2;
        },
        /* 68 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _bold = __webpack_require__(56);
          var _bold2 = _interopRequireDefault2(_bold);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Italic = function(_Bold) {
            _inherits2(Italic2, _Bold);
            function Italic2() {
              _classCallCheck2(this, Italic2);
              return _possibleConstructorReturn2(this, (Italic2.__proto__ || Object.getPrototypeOf(Italic2)).apply(this, arguments));
            }
            return Italic2;
          }(_bold2.default);
          Italic.blotName = "italic";
          Italic.tagName = ["EM", "I"];
          exports3.default = Italic;
        },
        /* 69 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Script = function(_Inline) {
            _inherits2(Script2, _Inline);
            function Script2() {
              _classCallCheck2(this, Script2);
              return _possibleConstructorReturn2(this, (Script2.__proto__ || Object.getPrototypeOf(Script2)).apply(this, arguments));
            }
            _createClass2(Script2, null, [{
              key: "create",
              value: function create(value) {
                if (value === "super") {
                  return document.createElement("sup");
                } else if (value === "sub") {
                  return document.createElement("sub");
                } else {
                  return _get2(Script2.__proto__ || Object.getPrototypeOf(Script2), "create", this).call(this, value);
                }
              }
            }, {
              key: "formats",
              value: function formats(domNode) {
                if (domNode.tagName === "SUB") return "sub";
                if (domNode.tagName === "SUP") return "super";
                return void 0;
              }
            }]);
            return Script2;
          }(_inline2.default);
          Script.blotName = "script";
          Script.tagName = ["SUB", "SUP"];
          exports3.default = Script;
        },
        /* 70 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Strike = function(_Inline) {
            _inherits2(Strike2, _Inline);
            function Strike2() {
              _classCallCheck2(this, Strike2);
              return _possibleConstructorReturn2(this, (Strike2.__proto__ || Object.getPrototypeOf(Strike2)).apply(this, arguments));
            }
            return Strike2;
          }(_inline2.default);
          Strike.blotName = "strike";
          Strike.tagName = "S";
          exports3.default = Strike;
        },
        /* 71 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Underline = function(_Inline) {
            _inherits2(Underline2, _Inline);
            function Underline2() {
              _classCallCheck2(this, Underline2);
              return _possibleConstructorReturn2(this, (Underline2.__proto__ || Object.getPrototypeOf(Underline2)).apply(this, arguments));
            }
            return Underline2;
          }(_inline2.default);
          Underline.blotName = "underline";
          Underline.tagName = "U";
          exports3.default = Underline;
        },
        /* 72 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _link = __webpack_require__(27);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var ATTRIBUTES = ["alt", "height", "width"];
          var Image = function(_Parchment$Embed) {
            _inherits2(Image2, _Parchment$Embed);
            function Image2() {
              _classCallCheck2(this, Image2);
              return _possibleConstructorReturn2(this, (Image2.__proto__ || Object.getPrototypeOf(Image2)).apply(this, arguments));
            }
            _createClass2(Image2, [{
              key: "format",
              value: function format2(name2, value) {
                if (ATTRIBUTES.indexOf(name2) > -1) {
                  if (value) {
                    this.domNode.setAttribute(name2, value);
                  } else {
                    this.domNode.removeAttribute(name2);
                  }
                } else {
                  _get2(Image2.prototype.__proto__ || Object.getPrototypeOf(Image2.prototype), "format", this).call(this, name2, value);
                }
              }
            }], [{
              key: "create",
              value: function create(value) {
                var node = _get2(Image2.__proto__ || Object.getPrototypeOf(Image2), "create", this).call(this, value);
                if (typeof value === "string") {
                  node.setAttribute("src", this.sanitize(value));
                }
                return node;
              }
            }, {
              key: "formats",
              value: function formats(domNode) {
                return ATTRIBUTES.reduce(function(formats2, attribute) {
                  if (domNode.hasAttribute(attribute)) {
                    formats2[attribute] = domNode.getAttribute(attribute);
                  }
                  return formats2;
                }, {});
              }
            }, {
              key: "match",
              value: function match(url) {
                return /\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url);
              }
            }, {
              key: "sanitize",
              value: function sanitize(url) {
                return (0, _link.sanitize)(url, ["http", "https", "data"]) ? url : "//:0";
              }
            }, {
              key: "value",
              value: function value(domNode) {
                return domNode.getAttribute("src");
              }
            }]);
            return Image2;
          }(_parchment2.default.Embed);
          Image.blotName = "image";
          Image.tagName = "IMG";
          exports3.default = Image;
        },
        /* 73 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _block = __webpack_require__(4);
          var _link = __webpack_require__(27);
          var _link2 = _interopRequireDefault2(_link);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var ATTRIBUTES = ["height", "width"];
          var Video = function(_BlockEmbed) {
            _inherits2(Video2, _BlockEmbed);
            function Video2() {
              _classCallCheck2(this, Video2);
              return _possibleConstructorReturn2(this, (Video2.__proto__ || Object.getPrototypeOf(Video2)).apply(this, arguments));
            }
            _createClass2(Video2, [{
              key: "format",
              value: function format2(name2, value) {
                if (ATTRIBUTES.indexOf(name2) > -1) {
                  if (value) {
                    this.domNode.setAttribute(name2, value);
                  } else {
                    this.domNode.removeAttribute(name2);
                  }
                } else {
                  _get2(Video2.prototype.__proto__ || Object.getPrototypeOf(Video2.prototype), "format", this).call(this, name2, value);
                }
              }
            }], [{
              key: "create",
              value: function create(value) {
                var node = _get2(Video2.__proto__ || Object.getPrototypeOf(Video2), "create", this).call(this, value);
                node.setAttribute("frameborder", "0");
                node.setAttribute("allowfullscreen", true);
                node.setAttribute("src", this.sanitize(value));
                return node;
              }
            }, {
              key: "formats",
              value: function formats(domNode) {
                return ATTRIBUTES.reduce(function(formats2, attribute) {
                  if (domNode.hasAttribute(attribute)) {
                    formats2[attribute] = domNode.getAttribute(attribute);
                  }
                  return formats2;
                }, {});
              }
            }, {
              key: "sanitize",
              value: function sanitize(url) {
                return _link2.default.sanitize(url);
              }
            }, {
              key: "value",
              value: function value(domNode) {
                return domNode.getAttribute("src");
              }
            }]);
            return Video2;
          }(_block.BlockEmbed);
          Video.blotName = "video";
          Video.className = "ql-video";
          Video.tagName = "IFRAME";
          exports3.default = Video;
        },
        /* 74 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.FormulaBlot = void 0;
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _embed = __webpack_require__(35);
          var _embed2 = _interopRequireDefault2(_embed);
          var _quill = __webpack_require__(5);
          var _quill2 = _interopRequireDefault2(_quill);
          var _module = __webpack_require__(9);
          var _module2 = _interopRequireDefault2(_module);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var FormulaBlot = function(_Embed) {
            _inherits2(FormulaBlot2, _Embed);
            function FormulaBlot2() {
              _classCallCheck2(this, FormulaBlot2);
              return _possibleConstructorReturn2(this, (FormulaBlot2.__proto__ || Object.getPrototypeOf(FormulaBlot2)).apply(this, arguments));
            }
            _createClass2(FormulaBlot2, null, [{
              key: "create",
              value: function create(value) {
                var node = _get2(FormulaBlot2.__proto__ || Object.getPrototypeOf(FormulaBlot2), "create", this).call(this, value);
                if (typeof value === "string") {
                  window.katex.render(value, node, {
                    throwOnError: false,
                    errorColor: "#f00"
                  });
                  node.setAttribute("data-value", value);
                }
                return node;
              }
            }, {
              key: "value",
              value: function value(domNode) {
                return domNode.getAttribute("data-value");
              }
            }]);
            return FormulaBlot2;
          }(_embed2.default);
          FormulaBlot.blotName = "formula";
          FormulaBlot.className = "ql-formula";
          FormulaBlot.tagName = "SPAN";
          var Formula = function(_Module) {
            _inherits2(Formula2, _Module);
            _createClass2(Formula2, null, [{
              key: "register",
              value: function register() {
                _quill2.default.register(FormulaBlot, true);
              }
            }]);
            function Formula2() {
              _classCallCheck2(this, Formula2);
              var _this2 = _possibleConstructorReturn2(this, (Formula2.__proto__ || Object.getPrototypeOf(Formula2)).call(this));
              if (window.katex == null) {
                throw new Error("Formula module requires KaTeX.");
              }
              return _this2;
            }
            return Formula2;
          }(_module2.default);
          exports3.FormulaBlot = FormulaBlot;
          exports3.default = Formula;
        },
        /* 75 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.CodeToken = exports3.CodeBlock = void 0;
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _quill = __webpack_require__(5);
          var _quill2 = _interopRequireDefault2(_quill);
          var _module = __webpack_require__(9);
          var _module2 = _interopRequireDefault2(_module);
          var _code = __webpack_require__(13);
          var _code2 = _interopRequireDefault2(_code);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var SyntaxCodeBlock = function(_CodeBlock) {
            _inherits2(SyntaxCodeBlock2, _CodeBlock);
            function SyntaxCodeBlock2() {
              _classCallCheck2(this, SyntaxCodeBlock2);
              return _possibleConstructorReturn2(this, (SyntaxCodeBlock2.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock2)).apply(this, arguments));
            }
            _createClass2(SyntaxCodeBlock2, [{
              key: "replaceWith",
              value: function replaceWith(block) {
                this.domNode.textContent = this.domNode.textContent;
                this.attach();
                _get2(SyntaxCodeBlock2.prototype.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock2.prototype), "replaceWith", this).call(this, block);
              }
            }, {
              key: "highlight",
              value: function highlight(_highlight) {
                var text = this.domNode.textContent;
                if (this.cachedText !== text) {
                  if (text.trim().length > 0 || this.cachedText == null) {
                    this.domNode.innerHTML = _highlight(text);
                    this.domNode.normalize();
                    this.attach();
                  }
                  this.cachedText = text;
                }
              }
            }]);
            return SyntaxCodeBlock2;
          }(_code2.default);
          SyntaxCodeBlock.className = "ql-syntax";
          var CodeToken = new _parchment2.default.Attributor.Class("token", "hljs", {
            scope: _parchment2.default.Scope.INLINE
          });
          var Syntax = function(_Module) {
            _inherits2(Syntax2, _Module);
            _createClass2(Syntax2, null, [{
              key: "register",
              value: function register() {
                _quill2.default.register(CodeToken, true);
                _quill2.default.register(SyntaxCodeBlock, true);
              }
            }]);
            function Syntax2(quill2, options) {
              _classCallCheck2(this, Syntax2);
              var _this2 = _possibleConstructorReturn2(this, (Syntax2.__proto__ || Object.getPrototypeOf(Syntax2)).call(this, quill2, options));
              if (typeof _this2.options.highlight !== "function") {
                throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
              }
              var timer = null;
              _this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function() {
                clearTimeout(timer);
                timer = setTimeout(function() {
                  _this2.highlight();
                  timer = null;
                }, _this2.options.interval);
              });
              _this2.highlight();
              return _this2;
            }
            _createClass2(Syntax2, [{
              key: "highlight",
              value: function highlight() {
                var _this3 = this;
                if (this.quill.selection.composing) return;
                this.quill.update(_quill2.default.sources.USER);
                var range2 = this.quill.getSelection();
                this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function(code) {
                  code.highlight(_this3.options.highlight);
                });
                this.quill.update(_quill2.default.sources.SILENT);
                if (range2 != null) {
                  this.quill.setSelection(range2, _quill2.default.sources.SILENT);
                }
              }
            }]);
            return Syntax2;
          }(_module2.default);
          Syntax.DEFAULTS = {
            highlight: function() {
              if (window.hljs == null) return null;
              return function(text) {
                var result = window.hljs.highlightAuto(text);
                return result.value;
              };
            }(),
            interval: 1e3
          };
          exports3.CodeBlock = SyntaxCodeBlock;
          exports3.CodeToken = CodeToken;
          exports3.default = Syntax;
        },
        /* 76 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>';
        },
        /* 77 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>';
        },
        /* 78 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>';
        },
        /* 79 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>';
        },
        /* 80 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <g class="ql-fill ql-color-label"> <polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points="12 6.868 12 6 11.62 6 12 6.868"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points="5.5 13 9 5 12.5 13"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>';
        },
        /* 81 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <rect class="ql-fill ql-stroke" height=3 width=3 x=4 y=5></rect> <rect class="ql-fill ql-stroke" height=3 width=3 x=11 y=5></rect> <path class="ql-even ql-fill ql-stroke" d=M7,8c0,4.031-3,5-3,5></path> <path class="ql-even ql-fill ql-stroke" d=M14,8c0,4.031-3,5-3,5></path> </svg>';
        },
        /* 82 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>';
        },
        /* 83 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>';
        },
        /* 84 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class="ql-color-label ql-stroke ql-transparent" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points="5.5 11 9 3 12.5 11"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>';
        },
        /* 85 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"></polygon> <line class="ql-stroke ql-fill" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>';
        },
        /* 86 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"></polygon> <line class="ql-stroke ql-fill" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>';
        },
        /* 87 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>';
        },
        /* 88 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>';
        },
        /* 89 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>';
        },
        /* 90 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform="translate(24 18) rotate(-180)"/> </svg>';
        },
        /* 91 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>';
        },
        /* 92 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewBox="0 0 18 18"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>';
        },
        /* 93 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewBox="0 0 18 18"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>';
        },
        /* 94 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>';
        },
        /* 95 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"></polyline> </svg>';
        },
        /* 96 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"></polyline> </svg>';
        },
        /* 97 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="5 7 5 11 3 9 5 7"></polyline> </svg>';
        },
        /* 98 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class="ql-even ql-stroke" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class="ql-even ql-stroke" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>';
        },
        /* 99 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class="ql-stroke ql-thin" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class="ql-stroke ql-thin" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class="ql-stroke ql-thin" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>';
        },
        /* 100 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>';
        },
        /* 101 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points="3 4 4 5 6 3"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points="3 14 4 15 6 13"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="3 9 4 10 6 8"></polyline> </svg>';
        },
        /* 102 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>';
        },
        /* 103 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>';
        },
        /* 104 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class="ql-stroke ql-thin" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>';
        },
        /* 105 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>';
        },
        /* 106 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>';
        },
        /* 107 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <polygon class=ql-stroke points="7 11 9 13 11 11 7 11"></polygon> <polygon class=ql-stroke points="7 7 9 5 11 7 7 7"></polygon> </svg>';
        },
        /* 108 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.BubbleTooltip = void 0;
          var _get2 = function get12(object, property2, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get12(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _createClass2 = /* @__PURE__ */ function() {
            function defineProperties2(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties2(Constructor.prototype, protoProps);
              if (staticProps) defineProperties2(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _extend = __webpack_require__(3);
          var _extend2 = _interopRequireDefault2(_extend);
          var _emitter = __webpack_require__(8);
          var _emitter2 = _interopRequireDefault2(_emitter);
          var _base = __webpack_require__(43);
          var _base2 = _interopRequireDefault2(_base);
          var _selection = __webpack_require__(15);
          var _icons = __webpack_require__(41);
          var _icons2 = _interopRequireDefault2(_icons);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance2, Constructor) {
            if (!(instance2 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var TOOLBAR_CONFIG = [["bold", "italic", "link"], [{ header: 1 }, { header: 2 }, "blockquote"]];
          var BubbleTheme = function(_BaseTheme) {
            _inherits2(BubbleTheme2, _BaseTheme);
            function BubbleTheme2(quill2, options) {
              _classCallCheck2(this, BubbleTheme2);
              if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
                options.modules.toolbar.container = TOOLBAR_CONFIG;
              }
              var _this = _possibleConstructorReturn2(this, (BubbleTheme2.__proto__ || Object.getPrototypeOf(BubbleTheme2)).call(this, quill2, options));
              _this.quill.container.classList.add("ql-bubble");
              return _this;
            }
            _createClass2(BubbleTheme2, [{
              key: "extendToolbar",
              value: function extendToolbar(toolbar) {
                this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
                this.tooltip.root.appendChild(toolbar.container);
                this.buildButtons([].slice.call(toolbar.container.querySelectorAll("button")), _icons2.default);
                this.buildPickers([].slice.call(toolbar.container.querySelectorAll("select")), _icons2.default);
              }
            }]);
            return BubbleTheme2;
          }(_base2.default);
          BubbleTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
            modules: {
              toolbar: {
                handlers: {
                  link: function link(value) {
                    if (!value) {
                      this.quill.format("link", false);
                    } else {
                      this.quill.theme.tooltip.edit();
                    }
                  }
                }
              }
            }
          });
          var BubbleTooltip = function(_BaseTooltip) {
            _inherits2(BubbleTooltip2, _BaseTooltip);
            function BubbleTooltip2(quill2, bounds) {
              _classCallCheck2(this, BubbleTooltip2);
              var _this2 = _possibleConstructorReturn2(this, (BubbleTooltip2.__proto__ || Object.getPrototypeOf(BubbleTooltip2)).call(this, quill2, bounds));
              _this2.quill.on(_emitter2.default.events.EDITOR_CHANGE, function(type2, range2, oldRange, source) {
                if (type2 !== _emitter2.default.events.SELECTION_CHANGE) return;
                if (range2 != null && range2.length > 0 && source === _emitter2.default.sources.USER) {
                  _this2.show();
                  _this2.root.style.left = "0px";
                  _this2.root.style.width = "";
                  _this2.root.style.width = _this2.root.offsetWidth + "px";
                  var lines = _this2.quill.getLines(range2.index, range2.length);
                  if (lines.length === 1) {
                    _this2.position(_this2.quill.getBounds(range2));
                  } else {
                    var lastLine = lines[lines.length - 1];
                    var index2 = _this2.quill.getIndex(lastLine);
                    var length = Math.min(lastLine.length() - 1, range2.index + range2.length - index2);
                    var _bounds = _this2.quill.getBounds(new _selection.Range(index2, length));
                    _this2.position(_bounds);
                  }
                } else if (document.activeElement !== _this2.textbox && _this2.quill.hasFocus()) {
                  _this2.hide();
                }
              });
              return _this2;
            }
            _createClass2(BubbleTooltip2, [{
              key: "listen",
              value: function listen() {
                var _this3 = this;
                _get2(BubbleTooltip2.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip2.prototype), "listen", this).call(this);
                this.root.querySelector(".ql-close").addEventListener("click", function() {
                  _this3.root.classList.remove("ql-editing");
                });
                this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE, function() {
                  setTimeout(function() {
                    if (_this3.root.classList.contains("ql-hidden")) return;
                    var range2 = _this3.quill.getSelection();
                    if (range2 != null) {
                      _this3.position(_this3.quill.getBounds(range2));
                    }
                  }, 1);
                });
              }
            }, {
              key: "cancel",
              value: function cancel() {
                this.show();
              }
            }, {
              key: "position",
              value: function position(reference) {
                var shift = _get2(BubbleTooltip2.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip2.prototype), "position", this).call(this, reference);
                var arrow = this.root.querySelector(".ql-tooltip-arrow");
                arrow.style.marginLeft = "";
                if (shift === 0) return shift;
                arrow.style.marginLeft = -1 * shift - arrow.offsetWidth / 2 + "px";
              }
            }]);
            return BubbleTooltip2;
          }(_base.BaseTooltip);
          BubbleTooltip.TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join("");
          exports3.BubbleTooltip = BubbleTooltip;
          exports3.default = BubbleTheme;
        },
        /* 109 */
        /***/
        function(module3, exports3, __webpack_require__) {
          module3.exports = __webpack_require__(63);
        }
        /******/
      ])["default"]
    );
  });
})(quill);
var quillExports = quill.exports;
const Quill = /* @__PURE__ */ getDefaultExportFromCjs(quillExports);
var __extends = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t2[p] = s2[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __spreadArrays = commonjsGlobal && commonjsGlobal.__spreadArrays || function() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s2 += arguments[i2].length;
  for (var r2 = Array(s2), k = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k++)
      r2[k] = a2[j];
  return r2;
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
var react_1 = __importDefault(reactExports);
var react_dom_1 = __importDefault(reactDomExports);
var isEqual_1 = __importDefault(isEqual_1$1);
var quill_1 = __importDefault(quillExports);
var ReactQuill = (
  /** @class */
  function(_super) {
    __extends(ReactQuill2, _super);
    function ReactQuill2(props) {
      var _this = _super.call(this, props) || this;
      _this.dirtyProps = [
        "modules",
        "formats",
        "bounds",
        "theme",
        "children"
      ];
      _this.cleanProps = [
        "id",
        "className",
        "style",
        "placeholder",
        "tabIndex",
        "onChange",
        "onChangeSelection",
        "onFocus",
        "onBlur",
        "onKeyPress",
        "onKeyDown",
        "onKeyUp"
      ];
      _this.state = {
        generation: 0
      };
      _this.selection = null;
      _this.onEditorChange = function(eventName, rangeOrDelta, oldRangeOrDelta, source) {
        var _a, _b, _c, _d;
        if (eventName === "text-change") {
          (_b = (_a = _this).onEditorChangeText) === null || _b === void 0 ? void 0 : _b.call(_a, _this.editor.root.innerHTML, rangeOrDelta, source, _this.unprivilegedEditor);
        } else if (eventName === "selection-change") {
          (_d = (_c = _this).onEditorChangeSelection) === null || _d === void 0 ? void 0 : _d.call(_c, rangeOrDelta, source, _this.unprivilegedEditor);
        }
      };
      var value = _this.isControlled() ? props.value : props.defaultValue;
      _this.value = value !== null && value !== void 0 ? value : "";
      return _this;
    }
    ReactQuill2.prototype.validateProps = function(props) {
      var _a;
      if (react_1.default.Children.count(props.children) > 1)
        throw new Error("The Quill editing area can only be composed of a single React element.");
      if (react_1.default.Children.count(props.children)) {
        var child = react_1.default.Children.only(props.children);
        if (((_a = child) === null || _a === void 0 ? void 0 : _a.type) === "textarea")
          throw new Error("Quill does not support editing on a <textarea>. Use a <div> instead.");
      }
      if (this.lastDeltaChangeSet && props.value === this.lastDeltaChangeSet)
        throw new Error("You are passing the `delta` object from the `onChange` event back as `value`. You most probably want `editor.getContents()` instead. See: https://github.com/zenoamaro/react-quill#using-deltas");
    };
    ReactQuill2.prototype.shouldComponentUpdate = function(nextProps, nextState) {
      var _this = this;
      var _a;
      this.validateProps(nextProps);
      if (!this.editor || this.state.generation !== nextState.generation) {
        return true;
      }
      if ("value" in nextProps) {
        var prevContents = this.getEditorContents();
        var nextContents = (_a = nextProps.value, _a !== null && _a !== void 0 ? _a : "");
        if (!this.isEqualValue(nextContents, prevContents)) {
          this.setEditorContents(this.editor, nextContents);
        }
      }
      if (nextProps.readOnly !== this.props.readOnly) {
        this.setEditorReadOnly(this.editor, nextProps.readOnly);
      }
      return __spreadArrays(this.cleanProps, this.dirtyProps).some(function(prop) {
        return !isEqual_1.default(nextProps[prop], _this.props[prop]);
      });
    };
    ReactQuill2.prototype.shouldComponentRegenerate = function(nextProps) {
      var _this = this;
      return this.dirtyProps.some(function(prop) {
        return !isEqual_1.default(nextProps[prop], _this.props[prop]);
      });
    };
    ReactQuill2.prototype.componentDidMount = function() {
      this.instantiateEditor();
      this.setEditorContents(this.editor, this.getEditorContents());
    };
    ReactQuill2.prototype.componentWillUnmount = function() {
      this.destroyEditor();
    };
    ReactQuill2.prototype.componentDidUpdate = function(prevProps, prevState) {
      var _this = this;
      if (this.editor && this.shouldComponentRegenerate(prevProps)) {
        var delta2 = this.editor.getContents();
        var selection = this.editor.getSelection();
        this.regenerationSnapshot = { delta: delta2, selection };
        this.setState({ generation: this.state.generation + 1 });
        this.destroyEditor();
      }
      if (this.state.generation !== prevState.generation) {
        var _a = this.regenerationSnapshot, delta2 = _a.delta, selection_1 = _a.selection;
        delete this.regenerationSnapshot;
        this.instantiateEditor();
        var editor_1 = this.editor;
        editor_1.setContents(delta2);
        postpone(function() {
          return _this.setEditorSelection(editor_1, selection_1);
        });
      }
    };
    ReactQuill2.prototype.instantiateEditor = function() {
      if (this.editor) {
        this.hookEditor(this.editor);
      } else {
        this.editor = this.createEditor(this.getEditingArea(), this.getEditorConfig());
      }
    };
    ReactQuill2.prototype.destroyEditor = function() {
      if (!this.editor)
        return;
      this.unhookEditor(this.editor);
    };
    ReactQuill2.prototype.isControlled = function() {
      return "value" in this.props;
    };
    ReactQuill2.prototype.getEditorConfig = function() {
      return {
        bounds: this.props.bounds,
        formats: this.props.formats,
        modules: this.props.modules,
        placeholder: this.props.placeholder,
        readOnly: this.props.readOnly,
        scrollingContainer: this.props.scrollingContainer,
        tabIndex: this.props.tabIndex,
        theme: this.props.theme
      };
    };
    ReactQuill2.prototype.getEditor = function() {
      if (!this.editor)
        throw new Error("Accessing non-instantiated editor");
      return this.editor;
    };
    ReactQuill2.prototype.createEditor = function(element, config2) {
      var editor = new quill_1.default(element, config2);
      if (config2.tabIndex != null) {
        this.setEditorTabIndex(editor, config2.tabIndex);
      }
      this.hookEditor(editor);
      return editor;
    };
    ReactQuill2.prototype.hookEditor = function(editor) {
      this.unprivilegedEditor = this.makeUnprivilegedEditor(editor);
      editor.on("editor-change", this.onEditorChange);
    };
    ReactQuill2.prototype.unhookEditor = function(editor) {
      editor.off("editor-change", this.onEditorChange);
    };
    ReactQuill2.prototype.getEditorContents = function() {
      return this.value;
    };
    ReactQuill2.prototype.getEditorSelection = function() {
      return this.selection;
    };
    ReactQuill2.prototype.isDelta = function(value) {
      return value && value.ops;
    };
    ReactQuill2.prototype.isEqualValue = function(value, nextValue) {
      if (this.isDelta(value) && this.isDelta(nextValue)) {
        return isEqual_1.default(value.ops, nextValue.ops);
      } else {
        return isEqual_1.default(value, nextValue);
      }
    };
    ReactQuill2.prototype.setEditorContents = function(editor, value) {
      var _this = this;
      this.value = value;
      var sel = this.getEditorSelection();
      if (typeof value === "string") {
        editor.setContents(editor.clipboard.convert(value));
      } else {
        editor.setContents(value);
      }
      postpone(function() {
        return _this.setEditorSelection(editor, sel);
      });
    };
    ReactQuill2.prototype.setEditorSelection = function(editor, range2) {
      this.selection = range2;
      if (range2) {
        var length_1 = editor.getLength();
        range2.index = Math.max(0, Math.min(range2.index, length_1 - 1));
        range2.length = Math.max(0, Math.min(range2.length, length_1 - 1 - range2.index));
        editor.setSelection(range2);
      }
    };
    ReactQuill2.prototype.setEditorTabIndex = function(editor, tabIndex) {
      var _a, _b;
      if ((_b = (_a = editor) === null || _a === void 0 ? void 0 : _a.scroll) === null || _b === void 0 ? void 0 : _b.domNode) {
        editor.scroll.domNode.tabIndex = tabIndex;
      }
    };
    ReactQuill2.prototype.setEditorReadOnly = function(editor, value) {
      if (value) {
        editor.disable();
      } else {
        editor.enable();
      }
    };
    ReactQuill2.prototype.makeUnprivilegedEditor = function(editor) {
      var e2 = editor;
      return {
        getHTML: function() {
          return e2.root.innerHTML;
        },
        getLength: e2.getLength.bind(e2),
        getText: e2.getText.bind(e2),
        getContents: e2.getContents.bind(e2),
        getSelection: e2.getSelection.bind(e2),
        getBounds: e2.getBounds.bind(e2)
      };
    };
    ReactQuill2.prototype.getEditingArea = function() {
      if (!this.editingArea) {
        throw new Error("Instantiating on missing editing area");
      }
      var element = react_dom_1.default.findDOMNode(this.editingArea);
      if (!element) {
        throw new Error("Cannot find element for editing area");
      }
      if (element.nodeType === 3) {
        throw new Error("Editing area cannot be a text node");
      }
      return element;
    };
    ReactQuill2.prototype.renderEditingArea = function() {
      var _this = this;
      var _a = this.props, children = _a.children, preserveWhitespace = _a.preserveWhitespace;
      var generation = this.state.generation;
      var properties = {
        key: generation,
        ref: function(instance2) {
          _this.editingArea = instance2;
        }
      };
      if (react_1.default.Children.count(children)) {
        return react_1.default.cloneElement(react_1.default.Children.only(children), properties);
      }
      return preserveWhitespace ? react_1.default.createElement("pre", __assign({}, properties)) : react_1.default.createElement("div", __assign({}, properties));
    };
    ReactQuill2.prototype.render = function() {
      var _a;
      return react_1.default.createElement("div", { id: this.props.id, style: this.props.style, key: this.state.generation, className: "quill " + (_a = this.props.className, _a !== null && _a !== void 0 ? _a : ""), onKeyPress: this.props.onKeyPress, onKeyDown: this.props.onKeyDown, onKeyUp: this.props.onKeyUp }, this.renderEditingArea());
    };
    ReactQuill2.prototype.onEditorChangeText = function(value, delta2, source, editor) {
      var _a, _b;
      if (!this.editor)
        return;
      var nextContents = this.isDelta(this.value) ? editor.getContents() : editor.getHTML();
      if (nextContents !== this.getEditorContents()) {
        this.lastDeltaChangeSet = delta2;
        this.value = nextContents;
        (_b = (_a = this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value, delta2, source, editor);
      }
    };
    ReactQuill2.prototype.onEditorChangeSelection = function(nextSelection, source, editor) {
      var _a, _b, _c, _d, _e, _f;
      if (!this.editor)
        return;
      var currentSelection = this.getEditorSelection();
      var hasGainedFocus = !currentSelection && nextSelection;
      var hasLostFocus = currentSelection && !nextSelection;
      if (isEqual_1.default(nextSelection, currentSelection))
        return;
      this.selection = nextSelection;
      (_b = (_a = this.props).onChangeSelection) === null || _b === void 0 ? void 0 : _b.call(_a, nextSelection, source, editor);
      if (hasGainedFocus) {
        (_d = (_c = this.props).onFocus) === null || _d === void 0 ? void 0 : _d.call(_c, nextSelection, source, editor);
      } else if (hasLostFocus) {
        (_f = (_e = this.props).onBlur) === null || _f === void 0 ? void 0 : _f.call(_e, currentSelection, source, editor);
      }
    };
    ReactQuill2.prototype.focus = function() {
      if (!this.editor)
        return;
      this.editor.focus();
    };
    ReactQuill2.prototype.blur = function() {
      if (!this.editor)
        return;
      this.selection = null;
      this.editor.blur();
    };
    ReactQuill2.displayName = "React Quill";
    ReactQuill2.Quill = quill_1.default;
    ReactQuill2.defaultProps = {
      theme: "snow",
      modules: {},
      readOnly: false
    };
    return ReactQuill2;
  }(react_1.default.Component)
);
function postpone(fn) {
  Promise.resolve().then(fn);
}
var lib$2 = ReactQuill;
const ReactQuill$1 = /* @__PURE__ */ getDefaultExportFromCjs(lib$2);
function ownKeys$F(object, enumerableOnly) {
  var keys4 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread2$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$F(Object(source), true).forEach(function(key) {
      _defineProperty$3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$F(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$2(obj);
}
function _classCallCheck$a(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
  }
}
function _createClass$8(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty$3(obj, key, value) {
  key = _toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends$g() {
  _extends$g = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$g.apply(this, arguments);
}
function _inherits$a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct$s() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn$a(self2, call2) {
  if (call2 && (typeof call2 === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$a(this, result);
  };
}
function _superPropBase$1(object, property2) {
  while (!Object.prototype.hasOwnProperty.call(object, property2)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }
  return object;
}
function _get$1() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$1 = Reflect.get.bind();
  } else {
    _get$1 = function _get2(target, property2, receiver) {
      var base = _superPropBase$1(target, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$1.apply(this, arguments);
}
function _unsupportedIterableToArray$g(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$g(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$g(o, minLen);
}
function _arrayLikeToArray$g(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function _createForOfIteratorHelper$f(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$g(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function() {
      };
      return {
        s: F,
        n: function() {
          if (i2 >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i2++]
          };
        },
        e: function(e2) {
          throw e2;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = it.call(o);
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e2) {
      didErr = true;
      err = e2;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _toPrimitive$1(input2, hint) {
  if (typeof input2 !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function _toPropertyKey$1(arg) {
  var key = _toPrimitive$1(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var Keys = {
  TAB: 9,
  ENTER: 13,
  ESCAPE: 27,
  UP: 38,
  DOWN: 40
};
function attachDataValues(element, data, dataAttributes) {
  var mention = element;
  Object.keys(data).forEach(function(key) {
    if (dataAttributes.indexOf(key) > -1) {
      mention.dataset[key] = data[key];
    } else {
      delete mention.dataset[key];
    }
  });
  return mention;
}
function setInnerContent(element, value) {
  if (value === null) return;
  if (_typeof$2(value) === "object") element.appendChild(value);
  else element.innerText = value;
}
function getMentionCharIndex(text, mentionDenotationChars, isolateChar, allowInlineMentionChar) {
  return mentionDenotationChars.reduce(function(prev, mentionChar) {
    var mentionCharIndex;
    if (isolateChar && allowInlineMentionChar) {
      var regex2 = new RegExp("^".concat(mentionChar, "|\\s").concat(mentionChar), "g");
      var lastMatch = (text.match(regex2) || []).pop();
      if (!lastMatch) {
        return {
          mentionChar: prev.mentionChar,
          mentionCharIndex: prev.mentionCharIndex
        };
      }
      mentionCharIndex = lastMatch !== mentionChar ? text.lastIndexOf(lastMatch) + lastMatch.length - mentionChar.length : 0;
    } else {
      mentionCharIndex = text.lastIndexOf(mentionChar);
    }
    if (mentionCharIndex > prev.mentionCharIndex) {
      return {
        mentionChar,
        mentionCharIndex
      };
    }
    return {
      mentionChar: prev.mentionChar,
      mentionCharIndex: prev.mentionCharIndex
    };
  }, {
    mentionChar: null,
    mentionCharIndex: -1
  });
}
function hasValidChars(text, allowedChars) {
  return allowedChars.test(text);
}
function hasValidMentionCharIndex(mentionCharIndex, text, isolateChar, textPrefix) {
  if (mentionCharIndex === -1) {
    return false;
  }
  if (!isolateChar) {
    return true;
  }
  var mentionPrefix = mentionCharIndex ? text[mentionCharIndex - 1] : textPrefix;
  return !mentionPrefix || !!mentionPrefix.match(/\s/);
}
var Embed = Quill["import"]("blots/embed");
var MentionBlot = /* @__PURE__ */ function(_Embed) {
  _inherits$a(MentionBlot2, _Embed);
  var _super = _createSuper(MentionBlot2);
  function MentionBlot2(scroll, node) {
    var _this;
    _classCallCheck$a(this, MentionBlot2);
    _this = _super.call(this, scroll, node);
    _defineProperty$3(_assertThisInitialized(_this), "hoverHandler", void 0);
    _defineProperty$3(_assertThisInitialized(_this), "hoverHandler", void 0);
    _this.clickHandler = null;
    _this.hoverHandler = null;
    _this.mounted = false;
    return _this;
  }
  _createClass$8(MentionBlot2, [{
    key: "attach",
    value: function attach() {
      _get$1(_getPrototypeOf(MentionBlot2.prototype), "attach", this).call(this);
      if (!this.mounted) {
        this.mounted = true;
        this.clickHandler = this.getClickHandler();
        this.hoverHandler = this.getHoverHandler();
        this.domNode.addEventListener("click", this.clickHandler, false);
        this.domNode.addEventListener("mouseenter", this.hoverHandler, false);
      }
    }
  }, {
    key: "detach",
    value: function detach() {
      _get$1(_getPrototypeOf(MentionBlot2.prototype), "detach", this).call(this);
      this.mounted = false;
      if (this.clickHandler) {
        this.domNode.removeEventListener("click", this.clickHandler);
        this.clickHandler = null;
      }
    }
  }, {
    key: "getClickHandler",
    value: function getClickHandler() {
      var _this2 = this;
      return function(e2) {
        var event = _this2.buildEvent("mention-clicked", e2);
        window.dispatchEvent(event);
        e2.preventDefault();
      };
    }
  }, {
    key: "getHoverHandler",
    value: function getHoverHandler() {
      var _this3 = this;
      return function(e2) {
        var event = _this3.buildEvent("mention-hovered", e2);
        window.dispatchEvent(event);
        e2.preventDefault();
      };
    }
  }, {
    key: "buildEvent",
    value: function buildEvent(name2, e2) {
      var event = new Event(name2, {
        bubbles: true,
        cancelable: true
      });
      event.value = _extends$g({}, this.domNode.dataset);
      event.event = e2;
      return event;
    }
  }], [{
    key: "create",
    value: function create(data) {
      var node = _get$1(_getPrototypeOf(MentionBlot2), "create", this).call(this);
      var denotationChar = document.createElement("span");
      denotationChar.className = "ql-mention-denotation-char";
      denotationChar.innerText = data.denotationChar;
      node.appendChild(denotationChar);
      if (typeof this.render === "function") {
        node.appendChild(this.render(data));
      } else {
        node.innerText += data.value;
      }
      return MentionBlot2.setDataValues(node, data);
    }
  }, {
    key: "setDataValues",
    value: function setDataValues(element, data) {
      var domNode = element;
      Object.keys(data).forEach(function(key) {
        domNode.dataset[key] = data[key];
      });
      return domNode;
    }
  }, {
    key: "value",
    value: function value(domNode) {
      return domNode.dataset;
    }
  }]);
  return MentionBlot2;
}(Embed);
MentionBlot.blotName = "mention";
MentionBlot.tagName = "span";
MentionBlot.className = "mention";
Quill.register("blots/mention", MentionBlot);
var Mention = /* @__PURE__ */ function() {
  function Mention2(quill2, options) {
    var _this = this;
    _classCallCheck$a(this, Mention2);
    this.isOpen = false;
    this.itemIndex = 0;
    this.mentionCharPos = null;
    this.cursorPos = null;
    this.values = [];
    this.suspendMouseEnter = false;
    this.existingSourceExecutionToken = null;
    this.quill = quill2;
    this.options = {
      source: null,
      renderItem: function renderItem(_ref) {
        var value = _ref.value;
        return "".concat(value);
      },
      renderLoading: function renderLoading() {
        return null;
      },
      onSelect: function onSelect(item, insertItem) {
        insertItem(item);
      },
      mentionDenotationChars: ["@"],
      showDenotationChar: true,
      allowedChars: /^[a-zA-Z0-9_]*$/,
      minChars: 0,
      maxChars: 31,
      offsetTop: 2,
      offsetLeft: 0,
      isolateCharacter: false,
      allowInlineMentionChar: false,
      fixMentionsToQuill: false,
      positioningStrategy: "normal",
      defaultMenuOrientation: "bottom",
      blotName: "mention",
      dataAttributes: ["id", "value", "denotationChar", "link", "target", "disabled"],
      linkTarget: "_blank",
      onOpen: function onOpen() {
        return true;
      },
      onBeforeClose: function onBeforeClose() {
        return true;
      },
      onClose: function onClose() {
        return true;
      },
      // Style options
      listItemClass: "ql-mention-list-item",
      mentionContainerClass: "ql-mention-list-container",
      mentionListClass: "ql-mention-list",
      spaceAfterInsert: true,
      selectKeys: [Keys.ENTER]
    };
    _extends$g(this.options, options, {
      dataAttributes: Array.isArray(options.dataAttributes) ? this.options.dataAttributes.concat(options.dataAttributes) : this.options.dataAttributes
    });
    for (var o in this.options) {
      if (typeof this.options[o] === "function") {
        this.options[o] = this.options[o].bind(this);
      }
    }
    this.mentionContainer = document.createElement("div");
    this.mentionContainer.className = this.options.mentionContainerClass ? this.options.mentionContainerClass : "";
    this.mentionContainer.style.cssText = "display: none; position: absolute;";
    this.mentionContainer.onmousemove = this.onContainerMouseMove.bind(this);
    if (this.options.fixMentionsToQuill) {
      this.mentionContainer.style.width = "auto";
    }
    this.mentionList = document.createElement("ul");
    this.mentionList.id = "quill-mention-list";
    quill2.root.setAttribute("aria-owns", "quill-mention-list");
    this.mentionList.className = this.options.mentionListClass ? this.options.mentionListClass : "";
    this.mentionContainer.appendChild(this.mentionList);
    quill2.on("text-change", this.onTextChange.bind(this));
    quill2.on("selection-change", this.onSelectionChange.bind(this));
    quill2.container.addEventListener("paste", function() {
      setTimeout(function() {
        var range2 = quill2.getSelection();
        _this.onSelectionChange(range2);
      });
    });
    quill2.keyboard.addBinding({
      key: Keys.TAB
    }, this.selectHandler.bind(this));
    quill2.keyboard.bindings[Keys.TAB].unshift(quill2.keyboard.bindings[Keys.TAB].pop());
    var _iterator = _createForOfIteratorHelper$f(this.options.selectKeys), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var selectKey = _step.value;
        quill2.keyboard.addBinding({
          key: selectKey
        }, this.selectHandler.bind(this));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    quill2.keyboard.bindings[Keys.ENTER].unshift(quill2.keyboard.bindings[Keys.ENTER].pop());
    quill2.keyboard.addBinding({
      key: Keys.ESCAPE
    }, this.escapeHandler.bind(this));
    quill2.keyboard.addBinding({
      key: Keys.UP
    }, this.upHandler.bind(this));
    quill2.keyboard.addBinding({
      key: Keys.DOWN
    }, this.downHandler.bind(this));
  }
  _createClass$8(Mention2, [{
    key: "selectHandler",
    value: function selectHandler() {
      if (this.isOpen && !this.existingSourceExecutionToken) {
        this.selectItem();
        return false;
      }
      return true;
    }
  }, {
    key: "escapeHandler",
    value: function escapeHandler() {
      if (this.isOpen) {
        if (this.existingSourceExecutionToken) {
          this.existingSourceExecutionToken.abandoned = true;
        }
        this.hideMentionList();
        return false;
      }
      return true;
    }
  }, {
    key: "upHandler",
    value: function upHandler() {
      if (this.isOpen && !this.existingSourceExecutionToken) {
        this.prevItem();
        return false;
      }
      return true;
    }
  }, {
    key: "downHandler",
    value: function downHandler() {
      if (this.isOpen && !this.existingSourceExecutionToken) {
        this.nextItem();
        return false;
      }
      return true;
    }
  }, {
    key: "showMentionList",
    value: function showMentionList() {
      if (this.options.positioningStrategy === "fixed") {
        document.body.appendChild(this.mentionContainer);
      } else {
        this.quill.container.appendChild(this.mentionContainer);
      }
      this.mentionContainer.style.visibility = "hidden";
      this.mentionContainer.style.display = "";
      this.mentionContainer.scrollTop = 0;
      this.setMentionContainerPosition();
      this.setIsOpen(true);
    }
  }, {
    key: "hideMentionList",
    value: function hideMentionList() {
      this.options.onBeforeClose();
      this.mentionContainer.style.display = "none";
      this.mentionContainer.remove();
      this.setIsOpen(false);
      this.quill.root.removeAttribute("aria-activedescendant");
    }
  }, {
    key: "highlightItem",
    value: function highlightItem() {
      var scrollItemInView = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      for (var i2 = 0; i2 < this.mentionList.childNodes.length; i2 += 1) {
        this.mentionList.childNodes[i2].classList.remove("selected");
      }
      if (this.itemIndex === -1 || this.mentionList.childNodes[this.itemIndex].dataset.disabled === "true") {
        return;
      }
      this.mentionList.childNodes[this.itemIndex].classList.add("selected");
      this.quill.root.setAttribute("aria-activedescendant", this.mentionList.childNodes[this.itemIndex].id);
      if (scrollItemInView) {
        this.mentionList.childNodes[this.itemIndex].scrollIntoView({
          behaviour: "smooth",
          block: "nearest"
        });
      }
    }
  }, {
    key: "onContainerMouseMove",
    value: function onContainerMouseMove() {
      this.suspendMouseEnter = false;
    }
  }, {
    key: "selectItem",
    value: function selectItem() {
      var _this2 = this;
      if (this.itemIndex === -1) {
        return;
      }
      var data = this.mentionList.childNodes[this.itemIndex].dataset;
      if (data.disabled) {
        return;
      }
      this.options.onSelect(data, function(asyncData) {
        var programmaticInsert = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var overriddenOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return _this2.insertItem(asyncData, programmaticInsert, overriddenOptions);
      });
      this.hideMentionList();
    }
  }, {
    key: "insertItem",
    value: function insertItem(data, programmaticInsert) {
      var overriddenOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var render3 = data;
      if (render3 === null) {
        return;
      }
      var options = _objectSpread2$1(_objectSpread2$1({}, this.options), overriddenOptions);
      if (!options.showDenotationChar) {
        render3.denotationChar = "";
      }
      var insertAtPos;
      if (!programmaticInsert) {
        insertAtPos = this.mentionCharPos;
        this.quill.deleteText(this.mentionCharPos, this.cursorPos - this.mentionCharPos, Quill.sources.USER);
      } else {
        insertAtPos = this.cursorPos;
      }
      var delta2 = this.quill.insertEmbed(insertAtPos, options.blotName, render3, Quill.sources.USER);
      if (options.spaceAfterInsert) {
        this.quill.insertText(insertAtPos + 1, " ", Quill.sources.USER);
        this.quill.setSelection(insertAtPos + 2, Quill.sources.USER);
      } else {
        this.quill.setSelection(insertAtPos + 1, Quill.sources.USER);
      }
      this.hideMentionList();
      return delta2;
    }
  }, {
    key: "onItemMouseEnter",
    value: function onItemMouseEnter(e2) {
      if (this.suspendMouseEnter) {
        return;
      }
      var index2 = Number(e2.target.dataset.index);
      if (!Number.isNaN(index2) && index2 !== this.itemIndex) {
        this.itemIndex = index2;
        this.highlightItem(false);
      }
    }
  }, {
    key: "onDisabledItemMouseEnter",
    value: function onDisabledItemMouseEnter(e2) {
      if (this.suspendMouseEnter) {
        return;
      }
      this.itemIndex = -1;
      this.highlightItem(false);
    }
  }, {
    key: "onItemClick",
    value: function onItemClick(e2) {
      if (e2.button !== 0) {
        return;
      }
      e2.preventDefault();
      e2.stopImmediatePropagation();
      this.itemIndex = e2.currentTarget.dataset.index;
      this.highlightItem();
      this.selectItem();
    }
  }, {
    key: "onItemMouseDown",
    value: function onItemMouseDown(e2) {
      e2.preventDefault();
      e2.stopImmediatePropagation();
    }
  }, {
    key: "renderLoading",
    value: function renderLoading() {
      var renderedLoading = this.options.renderLoading();
      if (!renderedLoading) {
        return;
      }
      if (this.mentionContainer.getElementsByClassName("ql-mention-loading").length > 0) {
        this.showMentionList();
        return;
      }
      this.mentionList.innerHTML = "";
      var loadingDiv = document.createElement("div");
      loadingDiv.className = "ql-mention-loading";
      setInnerContent(loadingDiv, this.options.renderLoading());
      this.mentionContainer.append(loadingDiv);
      this.showMentionList();
    }
  }, {
    key: "removeLoading",
    value: function removeLoading() {
      var loadingDiv = this.mentionContainer.getElementsByClassName("ql-mention-loading");
      if (loadingDiv.length > 0) {
        loadingDiv[0].remove();
      }
    }
  }, {
    key: "renderList",
    value: function renderList(mentionChar, data, searchTerm) {
      if (data && data.length > 0) {
        this.removeLoading();
        this.values = data;
        this.mentionList.innerText = "";
        var initialSelection = -1;
        for (var i2 = 0; i2 < data.length; i2 += 1) {
          var li = document.createElement("li");
          li.id = "quill-mention-item-" + i2;
          li.className = this.options.listItemClass ? this.options.listItemClass : "";
          if (data[i2].disabled) {
            li.className += " disabled";
            li.setAttribute("aria-hidden", "true");
          } else if (initialSelection === -1) {
            initialSelection = i2;
          }
          li.dataset.index = i2;
          var renderedItem = this.options.renderItem(data[i2], searchTerm);
          setInnerContent(li, renderedItem);
          if (!data[i2].disabled) {
            li.onmouseenter = this.onItemMouseEnter.bind(this);
            li.onmouseup = this.onItemClick.bind(this);
            li.onmousedown = this.onItemMouseDown.bind(this);
          } else {
            li.onmouseenter = this.onDisabledItemMouseEnter.bind(this);
          }
          li.dataset.denotationChar = mentionChar;
          this.mentionList.appendChild(attachDataValues(li, data[i2], this.options.dataAttributes));
        }
        this.itemIndex = initialSelection;
        this.highlightItem();
        this.showMentionList();
      } else {
        this.hideMentionList();
      }
    }
  }, {
    key: "nextItem",
    value: function nextItem() {
      var increment = 0;
      var newIndex;
      do {
        increment++;
        newIndex = (this.itemIndex + increment) % this.values.length;
        var disabled = this.mentionList.childNodes[newIndex].dataset.disabled === "true";
        if (increment === this.values.length + 1) {
          newIndex = -1;
          break;
        }
      } while (disabled);
      this.itemIndex = newIndex;
      this.suspendMouseEnter = true;
      this.highlightItem();
    }
  }, {
    key: "prevItem",
    value: function prevItem() {
      var decrement = 0;
      var newIndex;
      do {
        decrement++;
        newIndex = (this.itemIndex + this.values.length - decrement) % this.values.length;
        var disabled = this.mentionList.childNodes[newIndex].dataset.disabled === "true";
        if (decrement === this.values.length + 1) {
          newIndex = -1;
          break;
        }
      } while (disabled);
      this.itemIndex = newIndex;
      this.suspendMouseEnter = true;
      this.highlightItem();
    }
  }, {
    key: "containerBottomIsNotVisible",
    value: function containerBottomIsNotVisible(topPos, containerPos) {
      var mentionContainerBottom = topPos + this.mentionContainer.offsetHeight + containerPos.top;
      return mentionContainerBottom > window.pageYOffset + window.innerHeight;
    }
  }, {
    key: "containerRightIsNotVisible",
    value: function containerRightIsNotVisible(leftPos, containerPos) {
      if (this.options.fixMentionsToQuill) {
        return false;
      }
      var rightPos = leftPos + this.mentionContainer.offsetWidth + containerPos.left;
      var browserWidth = window.pageXOffset + document.documentElement.clientWidth;
      return rightPos > browserWidth;
    }
  }, {
    key: "setIsOpen",
    value: function setIsOpen(isOpen) {
      if (this.isOpen !== isOpen) {
        if (isOpen) {
          this.options.onOpen();
        } else {
          this.options.onClose();
        }
        this.isOpen = isOpen;
      }
    }
  }, {
    key: "setMentionContainerPosition",
    value: function setMentionContainerPosition() {
      if (this.options.positioningStrategy === "fixed") {
        this.setMentionContainerPosition_Fixed();
      } else {
        this.setMentionContainerPosition_Normal();
      }
    }
  }, {
    key: "setMentionContainerPosition_Normal",
    value: function setMentionContainerPosition_Normal() {
      var _this3 = this;
      var containerPos = this.quill.container.getBoundingClientRect();
      var mentionCharPos = this.quill.getBounds(this.mentionCharPos);
      var containerHeight = this.mentionContainer.offsetHeight;
      var topPos = this.options.offsetTop;
      var leftPos = this.options.offsetLeft;
      if (this.options.fixMentionsToQuill) {
        var rightPos = 0;
        this.mentionContainer.style.right = "".concat(rightPos, "px");
      } else {
        leftPos += mentionCharPos.left;
      }
      if (this.containerRightIsNotVisible(leftPos, containerPos)) {
        var containerWidth = this.mentionContainer.offsetWidth + this.options.offsetLeft;
        var quillWidth = containerPos.width;
        leftPos = quillWidth - containerWidth;
      }
      if (this.options.defaultMenuOrientation === "top") {
        if (this.options.fixMentionsToQuill) {
          topPos = -1 * (containerHeight + this.options.offsetTop);
        } else {
          topPos = mentionCharPos.top - (containerHeight + this.options.offsetTop);
        }
        if (topPos + containerPos.top <= 0) {
          var overMentionCharPos = this.options.offsetTop;
          if (this.options.fixMentionsToQuill) {
            overMentionCharPos += containerPos.height;
          } else {
            overMentionCharPos += mentionCharPos.bottom;
          }
          topPos = overMentionCharPos;
        }
      } else {
        if (this.options.fixMentionsToQuill) {
          topPos += containerPos.height;
        } else {
          topPos += mentionCharPos.bottom;
        }
        if (this.containerBottomIsNotVisible(topPos, containerPos)) {
          var _overMentionCharPos = this.options.offsetTop * -1;
          if (!this.options.fixMentionsToQuill) {
            _overMentionCharPos += mentionCharPos.top;
          }
          topPos = _overMentionCharPos - containerHeight;
        }
      }
      if (topPos >= 0) {
        this.options.mentionContainerClass.split(" ").forEach(function(className) {
          _this3.mentionContainer.classList.add("".concat(className, "-bottom"));
          _this3.mentionContainer.classList.remove("".concat(className, "-top"));
        });
      } else {
        this.options.mentionContainerClass.split(" ").forEach(function(className) {
          _this3.mentionContainer.classList.add("".concat(className, "-top"));
          _this3.mentionContainer.classList.remove("".concat(className, "-bottom"));
        });
      }
      this.mentionContainer.style.top = "".concat(topPos, "px");
      this.mentionContainer.style.left = "".concat(leftPos, "px");
      this.mentionContainer.style.visibility = "visible";
    }
  }, {
    key: "setMentionContainerPosition_Fixed",
    value: function setMentionContainerPosition_Fixed() {
      var _this4 = this;
      this.mentionContainer.style.position = "fixed";
      this.mentionContainer.style.height = null;
      var containerPos = this.quill.container.getBoundingClientRect();
      var mentionCharPos = this.quill.getBounds(this.mentionCharPos);
      var mentionCharPosAbsolute = {
        left: containerPos.left + mentionCharPos.left,
        top: containerPos.top + mentionCharPos.top,
        width: 0,
        height: mentionCharPos.height
      };
      var relativeToPos = this.options.fixMentionsToQuill ? containerPos : mentionCharPosAbsolute;
      var topPos = this.options.offsetTop;
      var leftPos = this.options.offsetLeft;
      if (this.options.fixMentionsToQuill) {
        var rightPos = relativeToPos.right;
        this.mentionContainer.style.right = "".concat(rightPos, "px");
      } else {
        leftPos += relativeToPos.left;
        if (leftPos + this.mentionContainer.offsetWidth > document.documentElement.clientWidth) {
          leftPos -= leftPos + this.mentionContainer.offsetWidth - document.documentElement.clientWidth;
        }
      }
      var availableSpaceTop = relativeToPos.top;
      var availableSpaceBottom = document.documentElement.clientHeight - (relativeToPos.top + relativeToPos.height);
      var fitsBottom = this.mentionContainer.offsetHeight <= availableSpaceBottom;
      var fitsTop = this.mentionContainer.offsetHeight <= availableSpaceTop;
      var placement;
      if (this.options.defaultMenuOrientation === "top" && fitsTop) {
        placement = "top";
      } else if (this.options.defaultMenuOrientation === "bottom" && fitsBottom) {
        placement = "bottom";
      } else {
        placement = availableSpaceBottom > availableSpaceTop ? "bottom" : "top";
      }
      if (placement === "bottom") {
        topPos = relativeToPos.top + relativeToPos.height;
        if (!fitsBottom) {
          this.mentionContainer.style.height = availableSpaceBottom - 3 + "px";
        }
        this.options.mentionContainerClass.split(" ").forEach(function(className) {
          _this4.mentionContainer.classList.add("".concat(className, "-bottom"));
          _this4.mentionContainer.classList.remove("".concat(className, "-top"));
        });
      } else {
        topPos = relativeToPos.top - this.mentionContainer.offsetHeight;
        if (!fitsTop) {
          this.mentionContainer.style.height = availableSpaceTop - 3 + "px";
          topPos = 3;
        }
        this.options.mentionContainerClass.split(" ").forEach(function(className) {
          _this4.mentionContainer.classList.add("".concat(className, "-top"));
          _this4.mentionContainer.classList.remove("".concat(className, "-bottom"));
        });
      }
      this.mentionContainer.style.top = "".concat(topPos, "px");
      this.mentionContainer.style.left = "".concat(leftPos, "px");
      this.mentionContainer.style.visibility = "visible";
    }
  }, {
    key: "getTextBeforeCursor",
    value: function getTextBeforeCursor() {
      var startPos = Math.max(0, this.cursorPos - this.options.maxChars);
      var textBeforeCursorPos = this.quill.getText(startPos, this.cursorPos - startPos);
      return textBeforeCursorPos;
    }
  }, {
    key: "onSomethingChange",
    value: function onSomethingChange() {
      var _this5 = this;
      var range2 = this.quill.getSelection();
      if (range2 == null) return;
      this.cursorPos = range2.index;
      var textBeforeCursor = this.getTextBeforeCursor();
      var textOffset = Math.max(0, this.cursorPos - this.options.maxChars);
      var textPrefix = textOffset ? this.quill.getText(textOffset - 1, textOffset) : "";
      var _getMentionCharIndex = getMentionCharIndex(textBeforeCursor, this.options.mentionDenotationChars, this.options.isolateCharacter, this.options.allowInlineMentionChar), mentionChar = _getMentionCharIndex.mentionChar, mentionCharIndex = _getMentionCharIndex.mentionCharIndex;
      if (hasValidMentionCharIndex(mentionCharIndex, textBeforeCursor, this.options.isolateCharacter, textPrefix)) {
        var mentionCharPos = this.cursorPos - (textBeforeCursor.length - mentionCharIndex);
        this.mentionCharPos = mentionCharPos;
        var textAfter = textBeforeCursor.substring(mentionCharIndex + mentionChar.length);
        if (textAfter.length >= this.options.minChars && hasValidChars(textAfter, this.getAllowedCharsRegex(mentionChar))) {
          if (this.existingSourceExecutionToken) {
            this.existingSourceExecutionToken.abandoned = true;
          }
          this.renderLoading();
          var sourceRequestToken = {
            abandoned: false
          };
          this.existingSourceExecutionToken = sourceRequestToken;
          this.options.source(textAfter, function(data, searchTerm) {
            if (sourceRequestToken.abandoned) {
              return;
            }
            _this5.existingSourceExecutionToken = null;
            _this5.renderList(mentionChar, data, searchTerm);
          }, mentionChar);
        } else {
          if (this.existingSourceExecutionToken) {
            this.existingSourceExecutionToken.abandoned = true;
          }
          this.hideMentionList();
        }
      } else {
        if (this.existingSourceExecutionToken) {
          this.existingSourceExecutionToken.abandoned = true;
        }
        this.hideMentionList();
      }
    }
  }, {
    key: "getAllowedCharsRegex",
    value: function getAllowedCharsRegex(denotationChar) {
      if (this.options.allowedChars instanceof RegExp) {
        return this.options.allowedChars;
      } else {
        return this.options.allowedChars(denotationChar);
      }
    }
  }, {
    key: "onTextChange",
    value: function onTextChange(delta2, oldDelta, source) {
      if (source === "user") {
        this.onSomethingChange();
      }
    }
  }, {
    key: "onSelectionChange",
    value: function onSelectionChange(range2) {
      if (range2 && range2.length === 0) {
        this.onSomethingChange();
      } else {
        this.hideMentionList();
      }
    }
  }, {
    key: "openMenu",
    value: function openMenu(denotationChar) {
      var selection = this.quill.getSelection(true);
      this.quill.insertText(selection.index, denotationChar);
      this.quill.blur();
      this.quill.focus();
    }
  }]);
  return Mention2;
}();
Quill.register("modules/mention", Mention);
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;
function diff_main(text1, text2, cursor_pos) {
  if (text1 == text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }
  if (cursor_pos < 0 || text1.length < cursor_pos) {
    cursor_pos = null;
  }
  var commonlength = diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);
  commonlength = diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);
  var diffs = diff_compute_(text1, text2);
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  diff_cleanupMerge(diffs);
  if (cursor_pos != null) {
    diffs = fix_cursor(diffs, cursor_pos);
  }
  diffs = fix_emoji(diffs);
  return diffs;
}
function diff_compute_(text1, text2) {
  var diffs;
  if (!text1) {
    return [[DIFF_INSERT, text2]];
  }
  if (!text2) {
    return [[DIFF_DELETE, text1]];
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i2 = longtext.indexOf(shorttext);
  if (i2 != -1) {
    diffs = [
      [DIFF_INSERT, longtext.substring(0, i2)],
      [DIFF_EQUAL, shorttext],
      [DIFF_INSERT, longtext.substring(i2 + shorttext.length)]
    ];
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }
  if (shorttext.length == 1) {
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }
  var hm = diff_halfMatch_(text1, text2);
  if (hm) {
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    var diffs_a = diff_main(text1_a, text2_a);
    var diffs_b = diff_main(text1_b, text2_b);
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }
  return diff_bisect_(text1, text2);
}
function diff_bisect_(text1, text2) {
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta2 = text1_length - text2_length;
  var front = delta2 % 2 != 0;
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        k1end += 2;
      } else if (y1 > text2_length) {
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta2 - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        k2end += 2;
      } else if (y2 > text2_length) {
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta2 - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          x2 = text1_length - x2;
          if (x1 >= x2) {
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }
  }
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
}
function diff_bisectSplit_(text1, text2, x, y) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);
  var diffs = diff_main(text1a, text2a);
  var diffsb = diff_main(text1b, text2b);
  return diffs.concat(diffsb);
}
function diff_commonPrefix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
function diff_commonSuffix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
function diff_halfMatch_(text1, text2) {
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;
  }
  function diff_halfMatchI_(longtext2, shorttext2, i2) {
    var seed = longtext2.substring(i2, i2 + Math.floor(longtext2.length / 4));
    var j = -1;
    var best_common = "";
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext2.indexOf(seed, j + 1)) != -1) {
      var prefixLength = diff_commonPrefix(
        longtext2.substring(i2),
        shorttext2.substring(j)
      );
      var suffixLength = diff_commonSuffix(
        longtext2.substring(0, i2),
        shorttext2.substring(0, j)
      );
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
        best_longtext_a = longtext2.substring(0, i2 - suffixLength);
        best_longtext_b = longtext2.substring(i2 + prefixLength);
        best_shorttext_a = shorttext2.substring(0, j - suffixLength);
        best_shorttext_b = shorttext2.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext2.length) {
      return [
        best_longtext_a,
        best_longtext_b,
        best_shorttext_a,
        best_shorttext_b,
        best_common
      ];
    } else {
      return null;
    }
  }
  var hm1 = diff_halfMatchI_(
    longtext,
    shorttext,
    Math.ceil(longtext.length / 4)
  );
  var hm2 = diff_halfMatchI_(
    longtext,
    shorttext,
    Math.ceil(longtext.length / 2)
  );
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
}
function diff_cleanupMerge(diffs) {
  diffs.push([DIFF_EQUAL, ""]);
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = "";
  var text_insert = "";
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            commonlength = diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [
                  DIFF_EQUAL,
                  text_insert.substring(0, commonlength)
                ]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            commonlength = diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length - commonlength);
              text_delete = text_delete.substring(0, text_delete.length - commonlength);
            }
          }
          if (count_delete === 0) {
            diffs.splice(
              pointer - count_insert,
              count_delete + count_insert,
              [DIFF_INSERT, text_insert]
            );
          } else if (count_insert === 0) {
            diffs.splice(
              pointer - count_delete,
              count_delete + count_insert,
              [DIFF_DELETE, text_delete]
            );
          } else {
            diffs.splice(
              pointer - count_delete - count_insert,
              count_delete + count_insert,
              [DIFF_DELETE, text_delete],
              [DIFF_INSERT, text_insert]
            );
          }
          pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === "") {
    diffs.pop();
  }
  var changes = false;
  pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  if (changes) {
    diff_cleanupMerge(diffs);
  }
}
var diff$2 = diff_main;
diff$2.INSERT = DIFF_INSERT;
diff$2.DELETE = DIFF_DELETE;
diff$2.EQUAL = DIFF_EQUAL;
var diff_1 = diff$2;
function cursor_normalize_diff(diffs, cursor_pos) {
  if (cursor_pos === 0) {
    return [DIFF_EQUAL, diffs];
  }
  for (var current_pos = 0, i2 = 0; i2 < diffs.length; i2++) {
    var d = diffs[i2];
    if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {
      var next_pos = current_pos + d[1].length;
      if (cursor_pos === next_pos) {
        return [i2 + 1, diffs];
      } else if (cursor_pos < next_pos) {
        diffs = diffs.slice();
        var split_pos = cursor_pos - current_pos;
        var d_left = [d[0], d[1].slice(0, split_pos)];
        var d_right = [d[0], d[1].slice(split_pos)];
        diffs.splice(i2, 1, d_left, d_right);
        return [i2 + 1, diffs];
      } else {
        current_pos = next_pos;
      }
    }
  }
  throw new Error("cursor_pos is out of bounds!");
}
function fix_cursor(diffs, cursor_pos) {
  var norm = cursor_normalize_diff(diffs, cursor_pos);
  var ndiffs = norm[1];
  var cursor_pointer = norm[0];
  var d = ndiffs[cursor_pointer];
  var d_next = ndiffs[cursor_pointer + 1];
  if (d == null) {
    return diffs;
  } else if (d[0] !== DIFF_EQUAL) {
    return diffs;
  } else {
    if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
      ndiffs.splice(cursor_pointer, 2, d_next, d);
      return merge_tuples(ndiffs, cursor_pointer, 2);
    } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
      ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
      var suffix = d_next[1].slice(d[1].length);
      if (suffix.length > 0) {
        ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
      }
      return merge_tuples(ndiffs, cursor_pointer, 3);
    } else {
      return diffs;
    }
  }
}
function fix_emoji(diffs) {
  var compact = false;
  var starts_with_pair_end = function(str) {
    return str.charCodeAt(0) >= 56320 && str.charCodeAt(0) <= 57343;
  };
  var ends_with_pair_start = function(str) {
    return str.charCodeAt(str.length - 1) >= 55296 && str.charCodeAt(str.length - 1) <= 56319;
  };
  for (var i2 = 2; i2 < diffs.length; i2 += 1) {
    if (diffs[i2 - 2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i2 - 2][1]) && diffs[i2 - 1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i2 - 1][1]) && diffs[i2][0] === DIFF_INSERT && starts_with_pair_end(diffs[i2][1])) {
      compact = true;
      diffs[i2 - 1][1] = diffs[i2 - 2][1].slice(-1) + diffs[i2 - 1][1];
      diffs[i2][1] = diffs[i2 - 2][1].slice(-1) + diffs[i2][1];
      diffs[i2 - 2][1] = diffs[i2 - 2][1].slice(0, -1);
    }
  }
  if (!compact) {
    return diffs;
  }
  var fixed_diffs = [];
  for (var i2 = 0; i2 < diffs.length; i2 += 1) {
    if (diffs[i2][1].length > 0) {
      fixed_diffs.push(diffs[i2]);
    }
  }
  return fixed_diffs;
}
function merge_tuples(diffs, start, length) {
  for (var i2 = start + length - 1; i2 >= 0 && i2 >= start - 1; i2--) {
    if (i2 + 1 < diffs.length) {
      var left_d = diffs[i2];
      var right_d = diffs[i2 + 1];
      if (left_d[0] === right_d[1]) {
        diffs.splice(i2, 2, [left_d[0], left_d[1] + right_d[1]]);
      }
    }
  }
  return diffs;
}
var toStr$4 = Object.prototype.toString;
var isArguments$6 = function isArguments(value) {
  var str = toStr$4.call(value);
  var isArgs2 = str === "[object Arguments]";
  if (!isArgs2) {
    isArgs2 = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$4.call(value.callee) === "[object Function]";
  }
  return isArgs2;
};
var implementation$8;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation$8;
  hasRequiredImplementation = 1;
  var keysShim2;
  if (!Object.keys) {
    var has5 = Object.prototype.hasOwnProperty;
    var toStr2 = Object.prototype.toString;
    var isArgs2 = isArguments$6;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
    var hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    var dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    var equalsConstructorPrototype = function(o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    var hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k in window) {
        try {
          if (!excludedKeys["$" + k] && has5.call(window, k) && window[k] !== null && typeof window[k] === "object") {
            try {
              equalsConstructorPrototype(window[k]);
            } catch (e2) {
              return true;
            }
          }
        } catch (e2) {
          return true;
        }
      }
      return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o);
      }
      try {
        return equalsConstructorPrototype(o);
      } catch (e2) {
        return false;
      }
    };
    keysShim2 = function keys4(object) {
      var isObject8 = object !== null && typeof object === "object";
      var isFunction2 = toStr2.call(object) === "[object Function]";
      var isArguments5 = isArgs2(object);
      var isString2 = isObject8 && toStr2.call(object) === "[object String]";
      var theKeys = [];
      if (!isObject8 && !isFunction2 && !isArguments5) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction2;
      if (isString2 && object.length > 0 && !has5.call(object, 0)) {
        for (var i2 = 0; i2 < object.length; ++i2) {
          theKeys.push(String(i2));
        }
      }
      if (isArguments5 && object.length > 0) {
        for (var j = 0; j < object.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name2 in object) {
          if (!(skipProto && name2 === "prototype") && has5.call(object, name2)) {
            theKeys.push(String(name2));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
        for (var k = 0; k < dontEnums.length; ++k) {
          if (!(skipConstructor && dontEnums[k] === "constructor") && has5.call(object, dontEnums[k])) {
            theKeys.push(dontEnums[k]);
          }
        }
      }
      return theKeys;
    };
  }
  implementation$8 = keysShim2;
  return implementation$8;
}
var slice = Array.prototype.slice;
var isArgs = isArguments$6;
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : requireImplementation();
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys4(object) {
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }
        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
var objectKeys$1 = keysShim;
var shams$1 = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var hasSymbols$3 = shams$1;
var shams = function hasToStringTagShams() {
  return hasSymbols$3() && !!Symbol.toStringTag;
};
var esErrors = Error;
var _eval = EvalError;
var range$2 = RangeError;
var ref = ReferenceError;
var syntax = SyntaxError;
var type$1 = TypeError;
var uri = URIError;
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams$1;
var hasSymbols$2 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var test = {
  __proto__: null,
  foo: {}
};
var $Object$1 = Object;
var hasProto$1 = function hasProto() {
  return { __proto__: test }.foo === test.foo && !(test instanceof $Object$1);
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var toStr$3 = Object.prototype.toString;
var max$2 = Math.max;
var funcType = "[object Function]";
var concatty = function concatty2(a2, b) {
  var arr = [];
  for (var i2 = 0; i2 < a2.length; i2 += 1) {
    arr[i2] = a2[i2];
  }
  for (var j = 0; j < b.length; j += 1) {
    arr[j + a2.length] = b[j];
  }
  return arr;
};
var slicy = function slicy2(arrLike, offset2) {
  var arr = [];
  for (var i2 = offset2, j = 0; i2 < arrLike.length; i2 += 1, j += 1) {
    arr[j] = arrLike[i2];
  }
  return arr;
};
var joiny = function(arr, joiner) {
  var str = "";
  for (var i2 = 0; i2 < arr.length; i2 += 1) {
    str += arr[i2];
    if (i2 + 1 < arr.length) {
      str += joiner;
    }
  }
  return str;
};
var implementation$7 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$3.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slicy(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
        this,
        concatty(args, arguments)
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    }
    return target.apply(
      that,
      concatty(args, arguments)
    );
  };
  var boundLength = max$2(0, target.length - args.length);
  var boundArgs = [];
  for (var i2 = 0; i2 < boundLength; i2++) {
    boundArgs[i2] = "$" + i2;
  }
  bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation$6 = implementation$7;
var functionBind = Function.prototype.bind || implementation$6;
var call$1 = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind$1 = functionBind;
var hasown = bind$1.call(call$1, $hasOwn);
var undefined$1;
var $Error = esErrors;
var $EvalError = _eval;
var $RangeError = range$2;
var $ReferenceError = ref;
var $SyntaxError$1 = syntax;
var $TypeError$4 = type$1;
var $URIError = uri;
var $Function = Function;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e2) {
  }
};
var $gOPD$2 = Object.getOwnPropertyDescriptor;
if ($gOPD$2) {
  try {
    $gOPD$2({}, "");
  } catch (e2) {
    $gOPD$2 = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$4();
};
var ThrowTypeError = $gOPD$2 ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD$2(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$1 = hasSymbols$2();
var hasProto2 = hasProto$1();
var getProto$1 = Object.getPrototypeOf || (hasProto2 ? function(x) {
  return x.__proto__;
} : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$1 && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$1 && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$1 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$1 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$1 && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$4,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
if (getProto$1) {
  try {
    null.error;
  } catch (e2) {
    var errorProto = getProto$1(getProto$1(e2));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name2) {
  var value;
  if (name2 === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name2 === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name2 === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name2 === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name2 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto$1) {
      value = getProto$1(gen.prototype);
    }
  }
  INTRINSICS[name2] = value;
  return value;
};
var LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind2 = functionBind;
var hasOwn$1 = hasown;
var $concat = bind2.call(Function.call, Array.prototype.concat);
var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
var $replace = bind2.call(Function.call, String.prototype.replace);
var $strSlice = bind2.call(Function.call, String.prototype.slice);
var $exec$1 = bind2.call(Function.call, RegExp.prototype.exec);
var rePropName$2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar$2 = /\\(\\)?/g;
var stringToPath$3 = function stringToPath(string) {
  var first3 = $strSlice(string, 0, 1);
  var last4 = $strSlice(string, -1);
  if (first3 === "%" && last4 !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  } else if (last4 === "%" && first3 !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string, rePropName$2, function(match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar$2, "$1") : number || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
  var intrinsicName = name2;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$4("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError$1("intrinsic " + name2 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name2, allowMissing) {
  if (typeof name2 !== "string" || name2.length === 0) {
    throw new $TypeError$4("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$4('"allowMissing" argument must be a boolean');
  }
  if ($exec$1(/^%?[^%]*%?$/, name2) === null) {
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath$3(name2);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
    var part = parts[i2];
    var first3 = $strSlice(part, 0, 1);
    var last4 = $strSlice(part, -1);
    if ((first3 === '"' || first3 === "'" || first3 === "`" || (last4 === '"' || last4 === "'" || last4 === "`")) && first3 !== last4) {
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$4("base intrinsic for " + name2 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$2 && i2 + 1 >= parts.length) {
        var desc = $gOPD$2(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$1(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$3 = { exports: {} };
var GetIntrinsic$3 = getIntrinsic;
var $defineProperty$2 = GetIntrinsic$3("%Object.defineProperty%", true) || false;
if ($defineProperty$2) {
  try {
    $defineProperty$2({}, "a", { value: 1 });
  } catch (e2) {
    $defineProperty$2 = false;
  }
}
var esDefineProperty = $defineProperty$2;
var GetIntrinsic$2 = getIntrinsic;
var $gOPD$1 = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD$1) {
  try {
    $gOPD$1([], "length");
  } catch (e2) {
    $gOPD$1 = null;
  }
}
var gopd$1 = $gOPD$1;
var $defineProperty$1 = esDefineProperty;
var $SyntaxError = syntax;
var $TypeError$3 = type$1;
var gopd = gopd$1;
var defineDataProperty$1 = function defineDataProperty(obj, property2, value) {
  if (!obj || typeof obj !== "object" && typeof obj !== "function") {
    throw new $TypeError$3("`obj` must be an object or a function`");
  }
  if (typeof property2 !== "string" && typeof property2 !== "symbol") {
    throw new $TypeError$3("`property` must be a string or a symbol`");
  }
  if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
    throw new $TypeError$3("`nonEnumerable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
    throw new $TypeError$3("`nonWritable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
    throw new $TypeError$3("`nonConfigurable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
    throw new $TypeError$3("`loose`, if provided, must be a boolean");
  }
  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  var nonWritable = arguments.length > 4 ? arguments[4] : null;
  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  var loose = arguments.length > 6 ? arguments[6] : false;
  var desc = !!gopd && gopd(obj, property2);
  if ($defineProperty$1) {
    $defineProperty$1(obj, property2, {
      configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
      enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
      value,
      writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
    obj[property2] = value;
  } else {
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }
};
var $defineProperty = esDefineProperty;
var hasPropertyDescriptors = function hasPropertyDescriptors2() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  if (!$defineProperty) {
    return null;
  }
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch (e2) {
    return true;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors;
var GetIntrinsic$1 = getIntrinsic;
var define$4 = defineDataProperty$1;
var hasDescriptors$1 = hasPropertyDescriptors_1();
var gOPD$4 = gopd$1;
var $TypeError$2 = type$1;
var $floor = GetIntrinsic$1("%Math.floor%");
var setFunctionLength = function setFunctionLength2(fn, length) {
  if (typeof fn !== "function") {
    throw new $TypeError$2("`fn` is not a function");
  }
  if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
    throw new $TypeError$2("`length` must be a positive 32-bit integer");
  }
  var loose = arguments.length > 2 && !!arguments[2];
  var functionLengthIsConfigurable = true;
  var functionLengthIsWritable = true;
  if ("length" in fn && gOPD$4) {
    var desc = gOPD$4(fn, "length");
    if (desc && !desc.configurable) {
      functionLengthIsConfigurable = false;
    }
    if (desc && !desc.writable) {
      functionLengthIsWritable = false;
    }
  }
  if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
    if (hasDescriptors$1) {
      define$4(
        /** @type {Parameters<define>[0]} */
        fn,
        "length",
        length,
        true,
        true
      );
    } else {
      define$4(
        /** @type {Parameters<define>[0]} */
        fn,
        "length",
        length
      );
    }
  }
  return fn;
};
(function(module2) {
  var bind3 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var setFunctionLength$1 = setFunctionLength;
  var $TypeError2 = type$1;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $defineProperty2 = esDefineProperty;
  var $max = GetIntrinsic3("%Math.max%");
  module2.exports = function callBind2(originalFunction) {
    if (typeof originalFunction !== "function") {
      throw new $TypeError2("a function is required");
    }
    var func = $reflectApply(bind3, $call, arguments);
    return setFunctionLength$1(
      func,
      1 + $max(0, originalFunction.length - (arguments.length - 1)),
      true
    );
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty2) {
    $defineProperty2(module2.exports, "apply", { value: applyBind });
  } else {
    module2.exports.apply = applyBind;
  }
})(callBind$3);
var callBindExports = callBind$3.exports;
var GetIntrinsic2 = getIntrinsic;
var callBind$2 = callBindExports;
var $indexOf = callBind$2(GetIntrinsic2("String.prototype.indexOf"));
var callBound$2 = function callBoundIntrinsic(name2, allowMissing) {
  var intrinsic = GetIntrinsic2(name2, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
    return callBind$2(intrinsic);
  }
  return intrinsic;
};
var hasToStringTag$2 = shams();
var callBound$1 = callBound$2;
var $toString$1 = callBound$1("Object.prototype.toString");
var isStandardArguments = function isArguments2(value) {
  if (hasToStringTag$2 && value && typeof value === "object" && Symbol.toStringTag in value) {
    return false;
  }
  return $toString$1(value) === "[object Arguments]";
};
var isLegacyArguments = function isArguments3(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString$1(value) !== "[object Array]" && $toString$1(value.callee) === "[object Function]";
};
var supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$5 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
var keys$6 = objectKeys$1;
var hasSymbols2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr$2 = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty2 = defineDataProperty$1;
var isFunction$3 = function(fn) {
  return typeof fn === "function" && toStr$2.call(fn) === "[object Function]";
};
var supportsDescriptors$2 = hasPropertyDescriptors_1();
var defineProperty$6 = function(object, name2, value, predicate) {
  if (name2 in object) {
    if (predicate === true) {
      if (object[name2] === value) {
        return;
      }
    } else if (!isFunction$3(predicate) || !predicate()) {
      return;
    }
  }
  if (supportsDescriptors$2) {
    defineDataProperty2(object, name2, value, true);
  } else {
    defineDataProperty2(object, name2, value);
  }
};
var defineProperties = function(object, map3) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys$6(map3);
  if (hasSymbols2) {
    props = concat.call(props, Object.getOwnPropertySymbols(map3));
  }
  for (var i2 = 0; i2 < props.length; i2 += 1) {
    defineProperty$6(object, props[i2], map3[props[i2]], predicates[props[i2]]);
  }
};
defineProperties.supportsDescriptors = !!supportsDescriptors$2;
var defineProperties_1 = defineProperties;
var numberIsNaN = function(value) {
  return value !== value;
};
var implementation$5 = function is(a2, b) {
  if (a2 === 0 && b === 0) {
    return 1 / a2 === 1 / b;
  }
  if (a2 === b) {
    return true;
  }
  if (numberIsNaN(a2) && numberIsNaN(b)) {
    return true;
  }
  return false;
};
var implementation$4 = implementation$5;
var polyfill$2 = function getPolyfill() {
  return typeof Object.is === "function" ? Object.is : implementation$4;
};
var getPolyfill$3 = polyfill$2;
var define$3 = defineProperties_1;
var shim$3 = function shimObjectIs() {
  var polyfill2 = getPolyfill$3();
  define$3(Object, { is: polyfill2 }, {
    is: function testObjectIs() {
      return Object.is !== polyfill2;
    }
  });
  return polyfill2;
};
var define$2 = defineProperties_1;
var callBind$1 = callBindExports;
var implementation$3 = implementation$5;
var getPolyfill$2 = polyfill$2;
var shim$2 = shim$3;
var polyfill$1 = callBind$1(getPolyfill$2(), Object);
define$2(polyfill$1, {
  getPolyfill: getPolyfill$2,
  implementation: implementation$3,
  shim: shim$2
});
var objectIs = polyfill$1;
var callBound = callBound$2;
var hasToStringTag$1 = shams();
var has$1;
var $exec;
var isRegexMarker;
var badStringifier;
if (hasToStringTag$1) {
  has$1 = callBound("Object.prototype.hasOwnProperty");
  $exec = callBound("RegExp.prototype.exec");
  isRegexMarker = {};
  var throwRegexMarker = function() {
    throw isRegexMarker;
  };
  badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  if (typeof Symbol.toPrimitive === "symbol") {
    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  }
}
var $toString = callBound("Object.prototype.toString");
var gOPD$3 = Object.getOwnPropertyDescriptor;
var regexClass = "[object RegExp]";
var isRegex$1 = hasToStringTag$1 ? function isRegex(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  var descriptor = gOPD$3(value, "lastIndex");
  var hasLastIndexDataProperty = descriptor && has$1(descriptor, "value");
  if (!hasLastIndexDataProperty) {
    return false;
  }
  try {
    $exec(value, badStringifier);
  } catch (e2) {
    return e2 === isRegexMarker;
  }
} : function isRegex2(value) {
  if (!value || typeof value !== "object" && typeof value !== "function") {
    return false;
  }
  return $toString(value) === regexClass;
};
var functionsHaveNames = function functionsHaveNames2() {
  return typeof (function f() {
  }).name === "string";
};
var gOPD$2 = Object.getOwnPropertyDescriptor;
if (gOPD$2) {
  try {
    gOPD$2([], "length");
  } catch (e2) {
    gOPD$2 = null;
  }
}
functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
  if (!functionsHaveNames() || !gOPD$2) {
    return false;
  }
  var desc = gOPD$2(function() {
  }, "name");
  return !!desc && !!desc.configurable;
};
var $bind = Function.prototype.bind;
functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
  return functionsHaveNames() && typeof $bind === "function" && (function f() {
  }).bind().name !== "";
};
var functionsHaveNames_1 = functionsHaveNames;
var define$1 = defineDataProperty$1;
var hasDescriptors = hasPropertyDescriptors_1();
var functionsHaveConfigurableNames2 = functionsHaveNames_1.functionsHaveConfigurableNames();
var $TypeError$1 = type$1;
var setFunctionName$1 = function setFunctionName(fn, name2) {
  if (typeof fn !== "function") {
    throw new $TypeError$1("`fn` is not a function");
  }
  var loose = arguments.length > 2 && !!arguments[2];
  if (!loose || functionsHaveConfigurableNames2) {
    if (hasDescriptors) {
      define$1(
        /** @type {Parameters<define>[0]} */
        fn,
        "name",
        name2,
        true,
        true
      );
    } else {
      define$1(
        /** @type {Parameters<define>[0]} */
        fn,
        "name",
        name2
      );
    }
  }
  return fn;
};
var setFunctionName2 = setFunctionName$1;
var $TypeError = type$1;
var $Object = Object;
var implementation$2 = setFunctionName2(function flags() {
  if (this == null || this !== $Object(this)) {
    throw new $TypeError("RegExp.prototype.flags getter called on non-object");
  }
  var result = "";
  if (this.hasIndices) {
    result += "d";
  }
  if (this.global) {
    result += "g";
  }
  if (this.ignoreCase) {
    result += "i";
  }
  if (this.multiline) {
    result += "m";
  }
  if (this.dotAll) {
    result += "s";
  }
  if (this.unicode) {
    result += "u";
  }
  if (this.unicodeSets) {
    result += "v";
  }
  if (this.sticky) {
    result += "y";
  }
  return result;
}, "get flags", true);
var implementation$1 = implementation$2;
var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
var $gOPD = Object.getOwnPropertyDescriptor;
var polyfill = function getPolyfill2() {
  if (supportsDescriptors$1 && /a/mig.flags === "gim") {
    var descriptor = $gOPD(RegExp.prototype, "flags");
    if (descriptor && typeof descriptor.get === "function" && "dotAll" in RegExp.prototype && "hasIndices" in RegExp.prototype) {
      var calls = "";
      var o = {};
      Object.defineProperty(o, "hasIndices", {
        get: function() {
          calls += "d";
        }
      });
      Object.defineProperty(o, "sticky", {
        get: function() {
          calls += "y";
        }
      });
      descriptor.get.call(o);
      if (calls === "dy") {
        return descriptor.get;
      }
    }
  }
  return implementation$1;
};
var supportsDescriptors = defineProperties_1.supportsDescriptors;
var getPolyfill$1 = polyfill;
var gOPD$1 = Object.getOwnPropertyDescriptor;
var defineProperty$5 = Object.defineProperty;
var TypeErr = TypeError;
var getProto = Object.getPrototypeOf;
var regex = /a/;
var shim$1 = function shimFlags() {
  if (!supportsDescriptors || !getProto) {
    throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  }
  var polyfill2 = getPolyfill$1();
  var proto2 = getProto(regex);
  var descriptor = gOPD$1(proto2, "flags");
  if (!descriptor || descriptor.get !== polyfill2) {
    defineProperty$5(proto2, "flags", {
      configurable: true,
      enumerable: false,
      get: polyfill2
    });
  }
  return polyfill2;
};
var define = defineProperties_1;
var callBind = callBindExports;
var implementation = implementation$2;
var getPolyfill3 = polyfill;
var shim = shim$1;
var flagsBound = callBind(getPolyfill3());
define(flagsBound, {
  getPolyfill: getPolyfill3,
  implementation,
  shim
});
var regexp_prototype_flags = flagsBound;
var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
  try {
    getDay.call(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var toStr$1 = Object.prototype.toString;
var dateClass = "[object Date]";
var hasToStringTag = shams();
var isDateObject = function isDateObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  return hasToStringTag ? tryDateObject(value) : toStr$1.call(value) === dateClass;
};
var objectKeys = objectKeys$1;
var isArguments$4 = isArguments$5;
var is$1 = objectIs;
var isRegex3 = isRegex$1;
var flags2 = regexp_prototype_flags;
var isDate$1 = isDateObject;
var getTime = Date.prototype.getTime;
function deepEqual$2(actual, expected, options) {
  var opts = options || {};
  if (opts.strict ? is$1(actual, expected) : actual === expected) {
    return true;
  }
  if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
    return opts.strict ? is$1(actual, expected) : actual == expected;
  }
  return objEquiv(actual, expected, opts);
}
function isUndefinedOrNull(value) {
  return value === null || value === void 0;
}
function isBuffer$3(x) {
  if (!x || typeof x !== "object" || typeof x.length !== "number") {
    return false;
  }
  if (typeof x.copy !== "function" || typeof x.slice !== "function") {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== "number") {
    return false;
  }
  return true;
}
function objEquiv(a2, b, opts) {
  var i2, key;
  if (typeof a2 !== typeof b) {
    return false;
  }
  if (isUndefinedOrNull(a2) || isUndefinedOrNull(b)) {
    return false;
  }
  if (a2.prototype !== b.prototype) {
    return false;
  }
  if (isArguments$4(a2) !== isArguments$4(b)) {
    return false;
  }
  var aIsRegex = isRegex3(a2);
  var bIsRegex = isRegex3(b);
  if (aIsRegex !== bIsRegex) {
    return false;
  }
  if (aIsRegex || bIsRegex) {
    return a2.source === b.source && flags2(a2) === flags2(b);
  }
  if (isDate$1(a2) && isDate$1(b)) {
    return getTime.call(a2) === getTime.call(b);
  }
  var aIsBuffer = isBuffer$3(a2);
  var bIsBuffer = isBuffer$3(b);
  if (aIsBuffer !== bIsBuffer) {
    return false;
  }
  if (aIsBuffer || bIsBuffer) {
    if (a2.length !== b.length) {
      return false;
    }
    for (i2 = 0; i2 < a2.length; i2++) {
      if (a2[i2] !== b[i2]) {
        return false;
      }
    }
    return true;
  }
  if (typeof a2 !== typeof b) {
    return false;
  }
  try {
    var ka = objectKeys(a2);
    var kb = objectKeys(b);
  } catch (e2) {
    return false;
  }
  if (ka.length !== kb.length) {
    return false;
  }
  ka.sort();
  kb.sort();
  for (i2 = ka.length - 1; i2 >= 0; i2--) {
    if (ka[i2] != kb[i2]) {
      return false;
    }
  }
  for (i2 = ka.length - 1; i2 >= 0; i2--) {
    key = ka[i2];
    if (!deepEqual$2(a2[key], b[key], opts)) {
      return false;
    }
  }
  return true;
}
var deepEqual_1 = deepEqual$2;
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty$4 = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;
var isArray$c = function isArray(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr.call(arr) === "[object Array]";
};
var isPlainObject$5 = function isPlainObject(obj) {
  if (!obj || toStr.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key;
  for (key in obj) {
  }
  return typeof key === "undefined" || hasOwn.call(obj, key);
};
var setProperty = function setProperty2(target, options) {
  if (defineProperty$4 && options.name === "__proto__") {
    defineProperty$4(target, options.name, {
      enumerable: true,
      configurable: true,
      value: options.newValue,
      writable: true
    });
  } else {
    target[options.name] = options.newValue;
  }
};
var getProperty = function getProperty2(obj, name2) {
  if (name2 === "__proto__") {
    if (!hasOwn.call(obj, name2)) {
      return void 0;
    } else if (gOPD) {
      return gOPD(obj, name2).value;
    }
  }
  return obj[name2];
};
var extend$3 = function extend() {
  var options, name2, src, copy2, copyIsArray, clone3;
  var target = arguments[0];
  var i2 = 1;
  var length = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i2 = 2;
  }
  if (target == null || typeof target !== "object" && typeof target !== "function") {
    target = {};
  }
  for (; i2 < length; ++i2) {
    options = arguments[i2];
    if (options != null) {
      for (name2 in options) {
        src = getProperty(target, name2);
        copy2 = getProperty(options, name2);
        if (target !== copy2) {
          if (deep && copy2 && (isPlainObject$5(copy2) || (copyIsArray = isArray$c(copy2)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone3 = src && isArray$c(src) ? src : [];
            } else {
              clone3 = src && isPlainObject$5(src) ? src : {};
            }
            setProperty(target, { name: name2, newValue: extend(deep, clone3, copy2) });
          } else if (typeof copy2 !== "undefined") {
            setProperty(target, { name: name2, newValue: copy2 });
          }
        }
      }
    }
  }
  return target;
};
var equal$1 = deepEqual_1;
var extend$2 = extend$3;
var lib$1 = {
  attributes: {
    compose: function(a2, b, keepNull) {
      if (typeof a2 !== "object") a2 = {};
      if (typeof b !== "object") b = {};
      var attributes = extend$2(true, {}, b);
      if (!keepNull) {
        attributes = Object.keys(attributes).reduce(function(copy2, key2) {
          if (attributes[key2] != null) {
            copy2[key2] = attributes[key2];
          }
          return copy2;
        }, {});
      }
      for (var key in a2) {
        if (a2[key] !== void 0 && b[key] === void 0) {
          attributes[key] = a2[key];
        }
      }
      return Object.keys(attributes).length > 0 ? attributes : void 0;
    },
    diff: function(a2, b) {
      if (typeof a2 !== "object") a2 = {};
      if (typeof b !== "object") b = {};
      var attributes = Object.keys(a2).concat(Object.keys(b)).reduce(function(attributes2, key) {
        if (!equal$1(a2[key], b[key])) {
          attributes2[key] = b[key] === void 0 ? null : b[key];
        }
        return attributes2;
      }, {});
      return Object.keys(attributes).length > 0 ? attributes : void 0;
    },
    transform: function(a2, b, priority) {
      if (typeof a2 !== "object") return b;
      if (typeof b !== "object") return void 0;
      if (!priority) return b;
      var attributes = Object.keys(b).reduce(function(attributes2, key) {
        if (a2[key] === void 0) attributes2[key] = b[key];
        return attributes2;
      }, {});
      return Object.keys(attributes).length > 0 ? attributes : void 0;
    }
  },
  iterator: function(ops) {
    return new Iterator$1(ops);
  },
  length: function(op2) {
    if (typeof op2["delete"] === "number") {
      return op2["delete"];
    } else if (typeof op2.retain === "number") {
      return op2.retain;
    } else {
      return typeof op2.insert === "string" ? op2.insert.length : 1;
    }
  }
};
function Iterator$1(ops) {
  this.ops = ops;
  this.index = 0;
  this.offset = 0;
}
Iterator$1.prototype.hasNext = function() {
  return this.peekLength() < Infinity;
};
Iterator$1.prototype.next = function(length) {
  if (!length) length = Infinity;
  var nextOp = this.ops[this.index];
  if (nextOp) {
    var offset2 = this.offset;
    var opLength = lib$1.length(nextOp);
    if (length >= opLength - offset2) {
      length = opLength - offset2;
      this.index += 1;
      this.offset = 0;
    } else {
      this.offset += length;
    }
    if (typeof nextOp["delete"] === "number") {
      return { "delete": length };
    } else {
      var retOp = {};
      if (nextOp.attributes) {
        retOp.attributes = nextOp.attributes;
      }
      if (typeof nextOp.retain === "number") {
        retOp.retain = length;
      } else if (typeof nextOp.insert === "string") {
        retOp.insert = nextOp.insert.substr(offset2, length);
      } else {
        retOp.insert = nextOp.insert;
      }
      return retOp;
    }
  } else {
    return { retain: Infinity };
  }
};
Iterator$1.prototype.peek = function() {
  return this.ops[this.index];
};
Iterator$1.prototype.peekLength = function() {
  if (this.ops[this.index]) {
    return lib$1.length(this.ops[this.index]) - this.offset;
  } else {
    return Infinity;
  }
};
Iterator$1.prototype.peekType = function() {
  if (this.ops[this.index]) {
    if (typeof this.ops[this.index]["delete"] === "number") {
      return "delete";
    } else if (typeof this.ops[this.index].retain === "number") {
      return "retain";
    } else {
      return "insert";
    }
  }
  return "retain";
};
Iterator$1.prototype.rest = function() {
  if (!this.hasNext()) {
    return [];
  } else if (this.offset === 0) {
    return this.ops.slice(this.index);
  } else {
    var offset2 = this.offset;
    var index2 = this.index;
    var next = this.next();
    var rest2 = this.ops.slice(this.index);
    this.offset = offset2;
    this.index = index2;
    return [next].concat(rest2);
  }
};
var op$1 = lib$1;
var diff$1 = diff_1;
var equal = deepEqual_1;
var extend$1 = extend$3;
var op = op$1;
var NULL_CHARACTER = String.fromCharCode(0);
var Delta = function(ops) {
  if (Array.isArray(ops)) {
    this.ops = ops;
  } else if (ops != null && Array.isArray(ops.ops)) {
    this.ops = ops.ops;
  } else {
    this.ops = [];
  }
};
Delta.prototype.insert = function(text, attributes) {
  var newOp = {};
  if (text.length === 0) return this;
  newOp.insert = text;
  if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
    newOp.attributes = attributes;
  }
  return this.push(newOp);
};
Delta.prototype["delete"] = function(length) {
  if (length <= 0) return this;
  return this.push({ "delete": length });
};
Delta.prototype.retain = function(length, attributes) {
  if (length <= 0) return this;
  var newOp = { retain: length };
  if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
    newOp.attributes = attributes;
  }
  return this.push(newOp);
};
Delta.prototype.push = function(newOp) {
  var index2 = this.ops.length;
  var lastOp = this.ops[index2 - 1];
  newOp = extend$1(true, {}, newOp);
  if (typeof lastOp === "object") {
    if (typeof newOp["delete"] === "number" && typeof lastOp["delete"] === "number") {
      this.ops[index2 - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
      return this;
    }
    if (typeof lastOp["delete"] === "number" && newOp.insert != null) {
      index2 -= 1;
      lastOp = this.ops[index2 - 1];
      if (typeof lastOp !== "object") {
        this.ops.unshift(newOp);
        return this;
      }
    }
    if (equal(newOp.attributes, lastOp.attributes)) {
      if (typeof newOp.insert === "string" && typeof lastOp.insert === "string") {
        this.ops[index2 - 1] = { insert: lastOp.insert + newOp.insert };
        if (typeof newOp.attributes === "object") this.ops[index2 - 1].attributes = newOp.attributes;
        return this;
      } else if (typeof newOp.retain === "number" && typeof lastOp.retain === "number") {
        this.ops[index2 - 1] = { retain: lastOp.retain + newOp.retain };
        if (typeof newOp.attributes === "object") this.ops[index2 - 1].attributes = newOp.attributes;
        return this;
      }
    }
  }
  if (index2 === this.ops.length) {
    this.ops.push(newOp);
  } else {
    this.ops.splice(index2, 0, newOp);
  }
  return this;
};
Delta.prototype.chop = function() {
  var lastOp = this.ops[this.ops.length - 1];
  if (lastOp && lastOp.retain && !lastOp.attributes) {
    this.ops.pop();
  }
  return this;
};
Delta.prototype.filter = function(predicate) {
  return this.ops.filter(predicate);
};
Delta.prototype.forEach = function(predicate) {
  this.ops.forEach(predicate);
};
Delta.prototype.map = function(predicate) {
  return this.ops.map(predicate);
};
Delta.prototype.partition = function(predicate) {
  var passed = [], failed = [];
  this.forEach(function(op2) {
    var target = predicate(op2) ? passed : failed;
    target.push(op2);
  });
  return [passed, failed];
};
Delta.prototype.reduce = function(predicate, initial) {
  return this.ops.reduce(predicate, initial);
};
Delta.prototype.changeLength = function() {
  return this.reduce(function(length, elem) {
    if (elem.insert) {
      return length + op.length(elem);
    } else if (elem.delete) {
      return length - elem.delete;
    }
    return length;
  }, 0);
};
Delta.prototype.length = function() {
  return this.reduce(function(length, elem) {
    return length + op.length(elem);
  }, 0);
};
Delta.prototype.slice = function(start, end) {
  start = start || 0;
  if (typeof end !== "number") end = Infinity;
  var ops = [];
  var iter = op.iterator(this.ops);
  var index2 = 0;
  while (index2 < end && iter.hasNext()) {
    var nextOp;
    if (index2 < start) {
      nextOp = iter.next(start - index2);
    } else {
      nextOp = iter.next(end - index2);
      ops.push(nextOp);
    }
    index2 += op.length(nextOp);
  }
  return new Delta(ops);
};
Delta.prototype.compose = function(other) {
  var thisIter = op.iterator(this.ops);
  var otherIter = op.iterator(other.ops);
  var ops = [];
  var firstOther = otherIter.peek();
  if (firstOther != null && typeof firstOther.retain === "number" && firstOther.attributes == null) {
    var firstLeft = firstOther.retain;
    while (thisIter.peekType() === "insert" && thisIter.peekLength() <= firstLeft) {
      firstLeft -= thisIter.peekLength();
      ops.push(thisIter.next());
    }
    if (firstOther.retain - firstLeft > 0) {
      otherIter.next(firstOther.retain - firstLeft);
    }
  }
  var delta2 = new Delta(ops);
  while (thisIter.hasNext() || otherIter.hasNext()) {
    if (otherIter.peekType() === "insert") {
      delta2.push(otherIter.next());
    } else if (thisIter.peekType() === "delete") {
      delta2.push(thisIter.next());
    } else {
      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
      var thisOp = thisIter.next(length);
      var otherOp = otherIter.next(length);
      if (typeof otherOp.retain === "number") {
        var newOp = {};
        if (typeof thisOp.retain === "number") {
          newOp.retain = length;
        } else {
          newOp.insert = thisOp.insert;
        }
        var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === "number");
        if (attributes) newOp.attributes = attributes;
        delta2.push(newOp);
        if (!otherIter.hasNext() && equal(delta2.ops[delta2.ops.length - 1], newOp)) {
          var rest2 = new Delta(thisIter.rest());
          return delta2.concat(rest2).chop();
        }
      } else if (typeof otherOp["delete"] === "number" && typeof thisOp.retain === "number") {
        delta2.push(otherOp);
      }
    }
  }
  return delta2.chop();
};
Delta.prototype.concat = function(other) {
  var delta2 = new Delta(this.ops.slice());
  if (other.ops.length > 0) {
    delta2.push(other.ops[0]);
    delta2.ops = delta2.ops.concat(other.ops.slice(1));
  }
  return delta2;
};
Delta.prototype.diff = function(other, index2) {
  if (this.ops === other.ops) {
    return new Delta();
  }
  var strings = [this, other].map(function(delta3) {
    return delta3.map(function(op2) {
      if (op2.insert != null) {
        return typeof op2.insert === "string" ? op2.insert : NULL_CHARACTER;
      }
      var prep = delta3 === other ? "on" : "with";
      throw new Error("diff() called " + prep + " non-document");
    }).join("");
  });
  var delta2 = new Delta();
  var diffResult = diff$1(strings[0], strings[1], index2);
  var thisIter = op.iterator(this.ops);
  var otherIter = op.iterator(other.ops);
  diffResult.forEach(function(component) {
    var length = component[1].length;
    while (length > 0) {
      var opLength = 0;
      switch (component[0]) {
        case diff$1.INSERT:
          opLength = Math.min(otherIter.peekLength(), length);
          delta2.push(otherIter.next(opLength));
          break;
        case diff$1.DELETE:
          opLength = Math.min(length, thisIter.peekLength());
          thisIter.next(opLength);
          delta2["delete"](opLength);
          break;
        case diff$1.EQUAL:
          opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
          var thisOp = thisIter.next(opLength);
          var otherOp = otherIter.next(opLength);
          if (equal(thisOp.insert, otherOp.insert)) {
            delta2.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));
          } else {
            delta2.push(otherOp)["delete"](opLength);
          }
          break;
      }
      length -= opLength;
    }
  });
  return delta2.chop();
};
Delta.prototype.eachLine = function(predicate, newline) {
  newline = newline || "\n";
  var iter = op.iterator(this.ops);
  var line = new Delta();
  var i2 = 0;
  while (iter.hasNext()) {
    if (iter.peekType() !== "insert") return;
    var thisOp = iter.peek();
    var start = op.length(thisOp) - iter.peekLength();
    var index2 = typeof thisOp.insert === "string" ? thisOp.insert.indexOf(newline, start) - start : -1;
    if (index2 < 0) {
      line.push(iter.next());
    } else if (index2 > 0) {
      line.push(iter.next(index2));
    } else {
      if (predicate(line, iter.next(1).attributes || {}, i2) === false) {
        return;
      }
      i2 += 1;
      line = new Delta();
    }
  }
  if (line.length() > 0) {
    predicate(line, {}, i2);
  }
};
Delta.prototype.transform = function(other, priority) {
  priority = !!priority;
  if (typeof other === "number") {
    return this.transformPosition(other, priority);
  }
  var thisIter = op.iterator(this.ops);
  var otherIter = op.iterator(other.ops);
  var delta2 = new Delta();
  while (thisIter.hasNext() || otherIter.hasNext()) {
    if (thisIter.peekType() === "insert" && (priority || otherIter.peekType() !== "insert")) {
      delta2.retain(op.length(thisIter.next()));
    } else if (otherIter.peekType() === "insert") {
      delta2.push(otherIter.next());
    } else {
      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
      var thisOp = thisIter.next(length);
      var otherOp = otherIter.next(length);
      if (thisOp["delete"]) {
        continue;
      } else if (otherOp["delete"]) {
        delta2.push(otherOp);
      } else {
        delta2.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
      }
    }
  }
  return delta2.chop();
};
Delta.prototype.transformPosition = function(index2, priority) {
  priority = !!priority;
  var thisIter = op.iterator(this.ops);
  var offset2 = 0;
  while (thisIter.hasNext() && offset2 <= index2) {
    var length = thisIter.peekLength();
    var nextType = thisIter.peekType();
    thisIter.next();
    if (nextType === "delete") {
      index2 -= Math.min(length, index2 - offset2);
      continue;
    } else if (nextType === "insert" && (offset2 < index2 || !priority)) {
      index2 += length;
    }
    offset2 += length;
  }
  return index2;
};
var delta = Delta;
const Delta$1 = /* @__PURE__ */ getDefaultExportFromCjs(delta);
const Clipboard = lib$2.Quill.import("modules/clipboard");
class SurveyFormClipboard extends Clipboard {
  onPaste(e2) {
    e2.preventDefault();
    const range2 = this.quill.getSelection();
    const text = e2.clipboardData.getData("text/plain");
    text.split("\r\n").filter(function(item) {
      return item;
    });
    const delta2 = new Delta$1().retain(range2.index).delete(range2.length).insert(text);
    const index2 = text.length + range2.index;
    const length = 0;
    this.quill.updateContents(delta2, "silent");
    this.quill.setSelection(index2, length, "silent");
  }
}
const accessibleDependencies = (componentIndices, code) => {
  let dependencies2 = [];
  if (!componentIndices) {
    return dependencies2;
  }
  let componentIndex = componentIndices.find(
    (element) => element.code === code
  );
  if (!componentIndex) {
    return dependencies2;
  }
  if (componentIndex.parent) {
    let componentParents = parents$1(componentIndices, componentIndex);
    componentParents.forEach((element) => {
      dependencies2 = dependencies2.concat(
        accessibleSiblings$1(componentIndices, element)
      );
    });
  }
  if (isGroup(componentIndex.code) || isQuestion(componentIndex.code)) {
    dependencies2 = dependencies2.concat(
      accessibleSiblings$1(componentIndices, componentIndex)
    );
  }
  return dependencies2;
};
const parents$1 = (componentIndices, componentIndex) => {
  let result = [];
  let parent2 = componentIndices.find(
    (element) => element.code === componentIndex.parent
  );
  if (parent2 && parent2.parent) {
    result.push(parent2);
    result = result.concat(parents$1(componentIndices, parent2));
  }
  return result;
};
const accessibleSiblings$1 = (componentIndices, componentIndex) => {
  let result = [];
  if (!isGroup(componentIndex.code) && !isQuestion(componentIndex.code)) {
    return result;
  }
  let accessibleSiblings2 = componentIndices.filter((elem) => {
    return elem.parent === componentIndex.parent && elem.maxIndex < componentIndex.minIndex && (!componentIndex.prioritisedSiblings || componentIndex.prioritisedSiblings.indexOf(elem.code) === -1);
  });
  accessibleSiblings2.forEach((sibling) => {
    result = result.concat(sibling.code);
    result = result.concat(childrenDependencies$1(componentIndices, sibling));
  });
  return result;
};
const childrenDependencies$1 = (componentIndices, componentIndex) => {
  let result = [];
  if (!isGroup(componentIndex.code)) {
    return result;
  }
  if (componentIndex.children) {
    componentIndex.children.forEach((childCode) => {
      let child = componentIndices.find(
        (element) => element.code === childCode
      );
      result = result.concat(child.code);
      result = result.concat(childrenDependencies$1(componentIndices, child));
    });
  }
  return result;
};
const buildReferences = (componentIndices, code, state, mainLang) => {
  let dependencies2 = accessibleDependencies(componentIndices, code);
  let returnResult = [];
  dependencies2.forEach((el) => {
    if (isQuestion(el)) {
      const reference = buildReference(el, state[el], state, mainLang);
      if (reference.length) {
        returnResult = returnResult.concat(reference);
      }
    }
  });
  return returnResult;
};
const buildReference = (code, component, state, mainLang) => {
  var _a, _b;
  const label2 = code + ". " + stripTags((_b = (_a = component.content) == null ? void 0 : _a.label) == null ? void 0 : _b[mainLang]);
  let instruction = "";
  let type2 = component.type;
  switch (component.type) {
    case "scq_icon_array":
    case "scq_array":
      return component.children.filter((el) => el.type == "row").map((element) => {
        var _a2, _b2;
        return {
          value: label2 + " - " + code + ". " + stripTags(
            (_b2 = (_a2 = state[element.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[mainLang]
          ),
          id: code + element.code,
          type: "SCQ Array Row",
          instruction: code + element.code + ".masked_value"
        };
      });
    case "text":
      type2 = "Short Text";
      instruction = "".concat(code, ".value");
      break;
    case "nps":
      type2 = "NPS";
      instruction = "".concat(code, ".value");
      break;
    case "email":
      type2 = "Email";
      instruction = "".concat(code, ".value");
      break;
    case "paragraph":
      instruction = "".concat(code, ".value");
      type2 = "Long Text";
      break;
    case "number":
      type2 = "Number";
      instruction = "".concat(code, ".value");
      break;
    case "date":
      type2 = "Date";
      instruction = "".concat(code, ".masked_value");
      break;
    case "time":
      type2 = "time";
      instruction = "".concat(code, ".masked_value");
      break;
    case "date_time":
      type2 = "Date Time";
      instruction = "".concat(code, ".masked_value");
      break;
    case "scq":
      type2 = "SCQ";
      instruction = "".concat(code, ".masked_value");
      break;
    case "icon_scq":
      type2 = "Icon SCQ";
      instruction = "".concat(code, ".masked_value");
      break;
    case "image_scq":
      type2 = "Image SCQ";
      instruction = "".concat(code, ".masked_value");
      break;
    case "mcq":
      type2 = "MCQ";
      instruction = "".concat(code, ".masked_value");
      break;
    case "image_mcq":
      type2 = "Image MCQ";
      instruction = "".concat(code, ".masked_value");
      break;
    case "icon_mcq":
      type2 = "Icon MCQ";
      instruction = "".concat(code, ".masked_value");
      break;
    default:
      return [];
  }
  return [{ id: code, instruction, value: label2, type: type2 }];
};
lib$2.Quill.register("modules/mentions", Mention);
lib$2.Quill.register("modules/clipboard", SurveyFormClipboard, true);
function DraftEditor({ value, onBlurListener, extended, isRtl, lang: lang2, code }) {
  console.debug("DraftEditor for: " + code);
  const oneLine = (value2, oneLine2) => {
    return !oneLine2 ? value2 : "<p>" + value2.replace(/<br>/gi, "").replace(/<p>/gi, "").replace(/<\/p>/, "") + "</p>";
  };
  const editor = React.createRef();
  const [state, setState] = reactExports.useState(oneLine(value, !extended));
  const [lastFocus, setLastFocus] = reactExports.useState(0);
  async function references(searchTerm) {
    const designState = manageStore.getState().designState;
    const values2 = buildReferences(
      designState.componentIndex,
      code,
      designState,
      designState.langInfo.mainLang
    );
    if (searchTerm.length === 0) {
      return values2;
    } else {
      const matches = [];
      for (var i2 = 0; i2 < values2.length; i2++) {
        if (values2[i2].value.toLowerCase().indexOf(searchTerm.toLowerCase()) >= 0) {
          matches.push(values2[i2]);
        }
      }
      return matches;
    }
  }
  reactExports.useEffect(() => {
    const quill2 = editor.current.getEditor();
    quill2.setSelection(quill2.getLength(), 0);
  }, [editor.current]);
  const modules = reactExports.useMemo(() => {
    return {
      mention: {
        dataAttributes: ["instruction", "type"],
        isolateCharacter: true,
        allowedChars: /[^\p{L}\p{N}]*$/,
        mentionDenotationChars: ["@"],
        showDenotationChar: false,
        onSelect: function(item, insertItem) {
          insertItem({ ...item, value: "{{".concat(item.id, ":").concat(item.type, "}}") });
        },
        source: async function(searchTerm, renderList) {
          const values2 = await references(searchTerm);
          renderList(values2);
        }
      },
      toolbar: {
        container: extended ? [
          ["bold", "italic", "underline", "strike", "link"],
          [
            { list: "ordered" },
            { list: "bullet" },
            { indent: "-1" },
            { indent: "+1" }
          ],
          [{ color: [] }, { background: [] }],
          ["clean"]
        ] : [
          ["bold", "italic", "underline", "strike", "link"],
          [{ color: [] }, { background: [] }],
          ["clean"]
        ],
        clipboard: {
          // Add the clipboard module with paste and matchVisual options
          matchVisual: false
          // Disable matching visual formatting during paste
        }
        // handlers: {
        //   // handlers object will be merged with default handlers object
        //   link: function (value) {
        //     if (value) {
        //       var href = prompt("Enter the URL");
        //       this.quill.format("link", href);
        //     } else {
        //       this.quill.format("link", false);
        //     }
        //   },
        // },
      }
    };
  }, []);
  const formats = [
    "bold",
    "italic",
    "underline",
    "strike",
    "direction",
    "list",
    "bullet",
    "indent",
    "color",
    "background",
    "mention",
    "link"
  ];
  let timeoutID = null;
  const onFocus = () => {
    setLastFocus(Date.now());
    timeoutID && clearTimeout(timeoutID);
  };
  const onBlur = () => {
    timeoutID = setTimeout(() => {
      onBlurListener(state, lang2);
    }, 500);
  };
  const onChange = (value2) => {
    onFocus();
    setState(oneLine(value2, !extended));
  };
  const onContainerClick = (e2) => {
    if (e2.target.tagName === "A" && e2.target.className == "ql-preview") {
      e2.preventDefault();
      window.open(e2.target.href, "_blank");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      onClick: onContainerClick,
      className: "quill-wrapper",
      onFocus,
      onBlur,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ReactQuill$1,
        {
          className: isRtl ? "rtl" : "ltr",
          theme: "snow",
          bounds: ".quill-wrapper",
          ref: editor,
          modules,
          formats,
          value: state,
          onChange
        }
      )
    }
  );
}
const DraftEditor$1 = React.memo(DraftEditor);
function ContentEditor$1({ placeholder: placeholder2, extended, contentKey, code, editable }) {
  const dispatch = useDispatch();
  const content = useSelector((state) => {
    var _a;
    return (_a = state.designState[code].content) == null ? void 0 : _a[contentKey];
  });
  const langInfo = useSelector((state) => {
    return state.designState.langInfo;
  });
  useSelector((state) => {
    var _a;
    return code[0] == "G" ? ((_a = state.designState[code].groupType) == null ? void 0 : _a.toLowerCase()) || "group" : state.designState[code].type;
  });
  const lang2 = langInfo.lang;
  const mainLang = langInfo.mainLang;
  const onMainLang = langInfo.onMainLang;
  const value = (content == null ? void 0 : content[lang2]) || "";
  const finalPlaceholder = onMainLang ? placeholder2 : isNotEmptyHtml(content == null ? void 0 : content[mainLang]) ? content == null ? void 0 : content[mainLang] : placeholder2;
  const [isActive, setActive] = reactExports.useState(false);
  const OnEditorBlurred = reactExports.useCallback(
    (text, editorLang) => {
      setActive(false);
      if (lang2 != editorLang) {
        return;
      } else if (text != value) {
        dispatch(changeContent({ code, key: contentKey, lang: lang2, value: text }));
      }
    },
    [value]
  );
  const onContainerClicked = (event) => {
    event.preventDefault();
    setActive(true);
  };
  const isRtl = rtlLanguage.includes(lang2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      className: styles$G.fullWidth,
      onClick: (e2) => {
        if (editable) {
          onContainerClicked(e2);
        }
      },
      children: isActive ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        DraftEditor$1,
        {
          lang: lang2,
          isRtl,
          code,
          extended,
          onBlurListener: OnEditorBlurred,
          value
        }
      ) : isNotEmptyHtml(value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "".concat(isRtl ? "rtl" : "ltr", " ql-editor ").concat(styles$G.noPadding),
          dangerouslySetInnerHTML: { __html: value }
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "".concat(isRtl ? "rtl" : "ltr", " ql-editor ").concat(styles$G.placeholder),
          dangerouslySetInnerHTML: { __html: finalPlaceholder }
        }
      )
    }
  );
}
const ContentEditor$2 = React.memo(ContentEditor$1);
const actionControl = "_actionControl_1xa5v_1";
const statusIcon = "_statusIcon_1xa5v_8";
const questionContainer = "_questionContainer_1xa5v_12";
const actionIcon = "_actionIcon_1xa5v_16";
const settingIcon$2 = "_settingIcon_1xa5v_17";
const deleteIcon = "_deleteIcon_1xa5v_25";
const styles$F = {
  actionControl,
  statusIcon,
  questionContainer,
  actionIcon,
  settingIcon: settingIcon$2,
  deleteIcon
};
var Verified = {};
var _interopRequireDefault$t = interopRequireDefaultExports;
Object.defineProperty(Verified, "__esModule", {
  value: true
});
var default_1$l = Verified.default = void 0;
var _createSvgIcon$l = _interopRequireDefault$t(requireCreateSvgIcon());
var _jsxRuntime$l = jsxRuntimeExports;
default_1$l = Verified.default = (0, _createSvgIcon$l.default)(/* @__PURE__ */ (0, _jsxRuntime$l.jsx)("path", {
  d: "m23 12-2.44-2.79.34-3.69-3.61-.82-1.89-3.2L12 2.96 8.6 1.5 6.71 4.69 3.1 5.5l.34 3.7L1 12l2.44 2.79-.34 3.7 3.61.82L8.6 22.5l3.4-1.47 3.4 1.46 1.89-3.19 3.61-.82-.34-3.69zm-12.91 4.72-3.8-3.81 1.48-1.48 2.32 2.33 5.85-5.87 1.48 1.48z"
}), "Verified");
var Shuffle = {};
var _interopRequireDefault$s = interopRequireDefaultExports;
Object.defineProperty(Shuffle, "__esModule", {
  value: true
});
var default_1$k = Shuffle.default = void 0;
var _createSvgIcon$k = _interopRequireDefault$s(requireCreateSvgIcon());
var _jsxRuntime$k = jsxRuntimeExports;
default_1$k = Shuffle.default = (0, _createSvgIcon$k.default)(/* @__PURE__ */ (0, _jsxRuntime$k.jsx)("path", {
  d: "M10.59 9.17 5.41 4 4 5.41l5.17 5.17zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4zm.33 9.41-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04z"
}), "Shuffle");
var LowPriority = {};
var _interopRequireDefault$r = interopRequireDefaultExports;
Object.defineProperty(LowPriority, "__esModule", {
  value: true
});
var default_1$j = LowPriority.default = void 0;
var _createSvgIcon$j = _interopRequireDefault$r(requireCreateSvgIcon());
var _jsxRuntime$j = jsxRuntimeExports;
default_1$j = LowPriority.default = (0, _createSvgIcon$j.default)(/* @__PURE__ */ (0, _jsxRuntime$j.jsx)("path", {
  d: "M14 5h8v2h-8zm0 5.5h8v2h-8zm0 5.5h8v2h-8zM2 11.5C2 15.08 4.92 18 8.5 18H9v2l3-3-3-3v2h-.5C6.02 16 4 13.98 4 11.5S6.02 7 8.5 7H12V5H8.5C4.92 5 2 7.92 2 11.5"
}), "LowPriority");
var MoveDown = {};
var _interopRequireDefault$q = interopRequireDefaultExports;
Object.defineProperty(MoveDown, "__esModule", {
  value: true
});
var default_1$i = MoveDown.default = void 0;
var _createSvgIcon$i = _interopRequireDefault$q(requireCreateSvgIcon());
var _jsxRuntime$i = jsxRuntimeExports;
default_1$i = MoveDown.default = (0, _createSvgIcon$i.default)(/* @__PURE__ */ (0, _jsxRuntime$i.jsx)("path", {
  d: "M3 11c0 2.45 1.76 4.47 4.08 4.91l-1.49-1.49L7 13l4 4.01L7 21l-1.41-1.41 1.58-1.58v-.06C3.7 17.54 1 14.58 1 11c0-3.87 3.13-7 7-7h3v2H8c-2.76 0-5 2.24-5 5m19 0V4h-9v7zm-2-2h-5V6h5zm-7 4h9v7h-9z"
}), "MoveDown");
function ActionToolbar({
  code,
  isGroup: isGroup2,
  parentCode,
  disableDelete,
  onDelete,
  onClone,
  t: t2
}) {
  const dispatch = useDispatch();
  const theme = useTheme$1();
  const type2 = useSelector((state) => {
    var _a;
    return isGroup2 ? ((_a = state.designState[code].groupType) == null ? void 0 : _a.toLowerCase()) || "group" : state.designState[code].type;
  });
  const [open, setOpen] = reactExports.useState(false);
  const handleClose = () => setOpen(false);
  const hasRelevance = useSelector((state) => {
    var _a, _b;
    let instruction = (_b = (_a = state.designState[code]) == null ? void 0 : _a.instructionList) == null ? void 0 : _b.find(
      (el) => el.code == "conditional_relevance"
    );
    return typeof instruction !== "undefined" && !instruction.errors;
  });
  const hasValidation = useSelector((state) => {
    var _a, _b, _c;
    return !isGroup2 && ((_c = (_b = (_a = state.designState[code]) == null ? void 0 : _a.instructionList) == null ? void 0 : _b.filter(
      (el) => el.code.startsWith("validation_") && !el.errors
    )) == null ? void 0 : _c.length) > 0;
  });
  const setSetup = () => {
    dispatch(setup({ code, rules: setupOptions(type2) }));
  };
  const expandRelevance = () => {
    dispatch(
      setup({
        code,
        rules: setupOptions(type2),
        highlighted: "relevance",
        expanded: ["relevance"]
      })
    );
  };
  const expandValidation = () => {
    dispatch(
      setup({
        code,
        rules: setupOptions(type2),
        highlighted: "validation",
        expanded: ["validation"]
      })
    );
  };
  const expandSkipLogic = () => {
    dispatch(
      setup({
        code,
        rules: setupOptions(type2),
        highlighted: "skip_logic",
        expanded: ["skip_logic"]
      })
    );
  };
  const expandParentRandom = () => {
    if (isGroup2) {
      dispatch(setup({ ...surveySetup, highlighted: "random" }));
    } else {
      dispatch(
        setup({
          code: parentCode,
          rules: setupOptions("group"),
          highlighted: "random",
          expanded: ["random"]
        })
      );
    }
  };
  const textColor = theme.textStyles.question.color;
  const hasSkip = useSelector((state) => {
    var _a, _b, _c;
    let skipInstructions = (_b = (_a = state.designState[code]) == null ? void 0 : _a.instructionList) == null ? void 0 : _b.filter(
      (el) => el.code.startsWith("skip_to")
    );
    return ((_c = skipInstructions == null ? void 0 : skipInstructions.filter((el) => !el.errors)) == null ? void 0 : _c.length) >= 1;
  });
  const isRandomized = useSelector((state) => {
    var _a;
    let indexObj = (_a = state.designState.componentIndex) == null ? void 0 : _a.find(
      (el) => el.code == code
    );
    return indexObj && indexObj.minIndex != indexObj.maxIndex;
  });
  const isPrioritised = useSelector((state) => {
    var _a, _b;
    let indexObj = (_a = state.designState.componentIndex) == null ? void 0 : _a.find(
      (el) => el.code == code
    );
    return ((_b = indexObj == null ? void 0 : indexObj.prioritisedSiblings) == null ? void 0 : _b.length) > 0;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: styles$F.actionControl,
      onClick: (e2) => {
        if (e2.target !== e2.currentTarget) {
          e2.preventDefault();
          e2.stopPropagation();
        }
      },
      children: [
        hasRelevance && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomTooltip, { title: "Has show/Hide Condition", showIcon: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            className: styles$F.statusIcon,
            onClick: () => expandRelevance(),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$p, { style: { color: textColor } })
          }
        ) }),
        hasValidation && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomTooltip, { title: "Has Validation", showIcon: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            className: styles$F.statusIcon,
            onClick: () => expandValidation(),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$l, { style: { color: textColor } })
          }
        ) }),
        isRandomized && /* @__PURE__ */ jsxRuntimeExports.jsx(
          CustomTooltip,
          {
            title: "Is part of a valid Random Group (within parent)",
            showIcon: false,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                className: styles$F.statusIcon,
                onClick: () => expandParentRandom(),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$k, { style: { color: textColor } })
              }
            )
          }
        ),
        isPrioritised && /* @__PURE__ */ jsxRuntimeExports.jsx(
          CustomTooltip,
          {
            title: "Is part of a valid Priority Group (within parent)",
            showIcon: false,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                className: styles$F.statusIcon,
                onClick: () => expandParentRandom(),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$j, { style: { color: textColor } })
              }
            )
          }
        ),
        hasSkip && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomTooltip, { title: "Has active Skip Logic", showIcon: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            className: styles$F.statusIcon,
            onClick: () => expandSkipLogic(),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$i, { style: { color: textColor } })
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => setSetup(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(SurveyIcon, { name: "settings", size: ".75em", color: "".concat(textColor) }) }),
        !isGroup2 && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => onClone(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(SurveyIcon, { name: "duplicate", size: ".75em", color: "".concat(textColor) }) }),
        !disableDelete && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => setOpen(true), disabled: disableDelete, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SurveyIcon, { name: "delete", size: ".75em", color: textColor }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          DeleteModal,
          {
            open,
            description: t2("delete_question"),
            handleClose,
            handleDelete: onDelete
          }
        )
      ]
    }
  );
}
const ActionToolbar$1 = React.memo(ActionToolbar);
const questionItem$8 = "_questionItem_wb37f_1";
const styles$E = {
  questionItem: questionItem$8
};
function TextQuestionDesign({ code }) {
  var _a, _b, _c, _d;
  const theme = useTheme();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$E.questionItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TextField,
    {
      disabled: true,
      variant: "standard",
      required: ((_b = (_a = state.validation) == null ? void 0 : _a.validation_required) == null ? void 0 : _b.isActive) ? true : false,
      label: state.showHint && (((_d = (_c = state.content) == null ? void 0 : _c.hint) == null ? void 0 : _d[lang2]) || ""),
      value: "",
      InputProps: {
        sx: {
          fontFamily: theme.textStyles.text.font,
          color: theme.textStyles.text.color,
          fontSize: theme.textStyles.text.size,
          "&.Mui-disabled": {
            color: theme.textStyles.text.color,
            borderBottom: "1px solid"
          }
        }
      }
    }
  ) });
}
const TextQuestionDesign$1 = React.memo(TextQuestionDesign);
const questionItem$7 = "_questionItem_1sx0f_1";
const styles$D = {
  questionItem: questionItem$7
};
function EmailQuestionDesign({ code }) {
  var _a, _b, _c, _d;
  const theme = useTheme();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$D.questionItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TextField,
    {
      disabled: true,
      variant: "standard",
      required: ((_b = (_a = state.validation) == null ? void 0 : _a.validation_required) == null ? void 0 : _b.isActive) ? true : false,
      label: state.showHint && (((_d = (_c = state.content) == null ? void 0 : _c.hint) == null ? void 0 : _d[lang2]) || ""),
      InputProps: {
        sx: {
          fontFamily: theme.textStyles.text.font,
          color: theme.textStyles.text.color,
          fontSize: theme.textStyles.text.size
        }
      },
      value: ""
    }
  ) });
}
const EmailQuestionDesign$1 = React.memo(EmailQuestionDesign);
const questionItem$6 = "_questionItem_169qj_1";
const styles$C = {
  questionItem: questionItem$6
};
function NumberQuestionDesign({ code }) {
  var _a, _b, _c, _d;
  const theme = useTheme();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$C.questionItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TextField,
    {
      disabled: true,
      variant: "standard",
      required: ((_b = (_a = state.validation) == null ? void 0 : _a.validation_required) == null ? void 0 : _b.isActive) ? true : false,
      label: state.showHint && (((_d = (_c = state.content) == null ? void 0 : _c.hint) == null ? void 0 : _d[lang2]) || ""),
      value: "",
      InputProps: {
        sx: {
          fontFamily: theme.textStyles.text.font,
          color: theme.textStyles.text.color,
          fontSize: theme.textStyles.text.size
        }
      }
    }
  ) });
}
const NumberQuestionDesign$1 = React.memo(NumberQuestionDesign);
const questionItem$5 = "_questionItem_13fbu_1";
const paragraph = "_paragraph_13fbu_15";
const wordCount = "_wordCount_13fbu_19";
const styles$B = {
  questionItem: questionItem$5,
  paragraph,
  wordCount
};
function ParagraphQuestionDesign({ code, t: t2 }) {
  var _a, _b, _c, _d;
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$B.questionItem, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextareaAutosize,
      {
        disabled: true,
        className: styles$B.paragraph,
        required: ((_b = (_a = state.validation) == null ? void 0 : _a.validation_required) == null ? void 0 : _b.isActive) ? true : false,
        placeholder: state.showHint && (((_d = (_c = state.content) == null ? void 0 : _c.hint) == null ? void 0 : _d[lang2]) || ""),
        minRows: state.minRows || 2,
        value: ""
      }
    ),
    state.showWordCount ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$B.wordCount, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("word_count", { lng: lang2, count: 0 }) }) }) : ""
  ] });
}
const ParagraphQuestionDesign$1 = React.memo(ParagraphQuestionDesign);
const questionItem$4 = "_questionItem_1sx0f_1";
const styles$A = {
  questionItem: questionItem$4
};
function FileUploadQuestionDesign({ code }) {
  var _a, _b;
  const theme = useTheme();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$A.questionItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TextField,
    {
      variant: "standard",
      required: ((_b = (_a = state.validation) == null ? void 0 : _a.validation_required) == null ? void 0 : _b.isActive) ? true : false,
      label: state.showHint && state.content.hint ? state.content.hint[lang2] : "",
      InputProps: {
        sx: {
          fontFamily: theme.textStyles.text.font,
          color: theme.textStyles.text.color,
          fontSize: theme.textStyles.text.size
        }
      },
      value: "",
      type: "file",
      disabled: true
    }
  ) });
}
const FileUploadQuestionDesign$1 = React.memo(FileUploadQuestionDesign);
const questionItem$3 = "_questionItem_1sx0f_1";
const styles$z = {
  questionItem: questionItem$3
};
function DateTimeQuestionDesign({ code }) {
  var _a, _b, _c;
  const theme = useTheme();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$z.questionItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TextField,
    {
      disabled: true,
      variant: "standard",
      required: ((_b = (_a = state.validation) == null ? void 0 : _a.validation_required) == null ? void 0 : _b.isActive) ? true : false,
      label: state.showHint && ((_c = state.content) == null ? void 0 : _c.hint) ? state.content.hint[lang2] : "",
      value: "",
      InputProps: {
        sx: {
          fontFamily: theme.textStyles.text,
          color: theme.textStyles.text.color,
          fontSize: theme.textStyles.text.size
        }
      },
      placeholder: state.dateFormat
    }
  ) });
}
const DateTimeQuestionDesign$1 = React.memo(DateTimeQuestionDesign);
const questionItem$2 = "_questionItem_wb37f_1";
const styles$y = {
  questionItem: questionItem$2
};
function TimeQuestionDesign({ code }) {
  var _a, _b, _c;
  const theme = useTheme();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$y.questionItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TextField,
    {
      disabled: true,
      variant: "standard",
      required: ((_b = (_a = state.validation) == null ? void 0 : _a.validation_required) == null ? void 0 : _b.isActive) ? true : false,
      label: state.showHint && ((_c = state.content) == null ? void 0 : _c.hint) ? state.content.hint[lang2] : "",
      value: "",
      type: "time",
      InputProps: {
        sx: {
          fontFamily: theme.textStyles.text.font,
          color: theme.textStyles.text.color,
          fontSize: theme.textStyles.text.size
        }
      }
    }
  ) });
}
const TimeQuestionDesign$1 = React.memo(TimeQuestionDesign);
var DragIndicator = {};
var _interopRequireDefault$p = interopRequireDefaultExports;
Object.defineProperty(DragIndicator, "__esModule", {
  value: true
});
var default_1$h = DragIndicator.default = void 0;
var _createSvgIcon$h = _interopRequireDefault$p(requireCreateSvgIcon());
var _jsxRuntime$h = jsxRuntimeExports;
default_1$h = DragIndicator.default = (0, _createSvgIcon$h.default)(/* @__PURE__ */ (0, _jsxRuntime$h.jsx)("path", {
  d: "M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2m-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
}), "DragIndicator");
function SCQArray(props) {
  const theme = useTheme();
  const t2 = props.t;
  const langInfo = useSelector((state) => {
    return state.designState.langInfo;
  });
  langInfo.lang === langInfo.mainLang;
  const children = useSelector(
    (state) => state.designState[props.code].children
  );
  useSelector((state) => {
    var _a;
    return ((_a = state.designState.setup) == null ? void 0 : _a.code) == props.code;
  });
  const rows = React.useMemo(
    () => (children == null ? void 0 : children.filter((el) => el.type == "row")) || [],
    [children]
  );
  const columns = React.useMemo(
    () => (children == null ? void 0 : children.filter((el) => el.type == "column")) || [],
    [children]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    inDesign(props.designMode) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$L.addColumn, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        sx: {
          fontFamily: theme.textStyles.text.font,
          fontSize: theme.textStyles.text.size,
          color: theme.textStyles.question.color
        },
        size: "small",
        onClick: (e2) => props.addNewAnswer(props.code, props.type, "column"),
        children: t2("add_column")
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
        inDesign(props.designMode) && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableCell,
          {
            sx: {
              padding: "0"
            }
          },
          "move"
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, {}, "content"),
        columns.map((item, index2) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            SCQArrayHeaderDesign$1,
            {
              parentQualifiedCode: props.qualifiedCode,
              langInfo,
              designMode: props.designMode,
              t: props.t,
              item,
              index: index2
            },
            item.qualifiedCode
          );
        }),
        inDesign(props.designMode) && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableCell,
          {
            sx: {
              padding: "0"
            }
          },
          "remove"
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: rows.map((item, index2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          SCQArrayRowDesign$1,
          {
            parentQualifiedCode: props.qualifiedCode,
            langInfo,
            t: props.t,
            designMode: props.designMode,
            item,
            colCount: columns.length,
            index: index2
          },
          item.qualifiedCode
        );
      }) })
    ] }) }),
    props.onMainLang && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$L.addRow, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        sx: {
          fontFamily: theme.textStyles.text.font,
          fontSize: theme.textStyles.text.size,
          color: theme.textStyles.question.color
        },
        size: "small",
        onClick: (e2) => props.addNewAnswer(props.code, props.type, "row"),
        children: t2("add_row")
      }
    ) })
  ] });
}
const SCQArray$1 = React.memo(SCQArray);
function SCQArrayRowDesign$1({
  item,
  index: index2,
  colCount,
  designMode,
  t: t2,
  langInfo,
  parentQualifiedCode
}) {
  const dispatch = useDispatch();
  const theme = useTheme();
  const ref2 = reactExports.useRef();
  const onMainLang = langInfo.lang === langInfo.mainLang;
  const content = useSelector((state) => {
    var _a, _b;
    return (_b = (_a = state.designState[item.qualifiedCode].content) == null ? void 0 : _a["label"]) == null ? void 0 : _b[langInfo.lang];
  });
  const mainContent = useSelector((state) => {
    var _a, _b;
    return (_b = (_a = state.designState[item.qualifiedCode].content) == null ? void 0 : _a["label"]) == null ? void 0 : _b[langInfo.mainLang];
  });
  const itemType = "col-".concat(parentQualifiedCode);
  const [isDragging2, drag, preview] = useDrag(
    {
      type: itemType,
      item: {
        qualifiedCode: item.qualifiedCode,
        index: index2
      },
      collect: (monitor) => monitor.isDragging()
    },
    [index2]
  );
  const [{ handlerId }, drop] = useDrop({
    accept: itemType,
    collect(monitor) {
      return {
        handlerId: monitor.getHandlerId()
      };
    },
    hover(item2, monitor) {
      var _a;
      if (!ref2.current || !monitor.isOver({ shallow: true }) || !item2) {
        return;
      }
      const dragIndex = item2.index;
      const hoverIndex = index2;
      if (dragIndex === hoverIndex) {
        return;
      }
      const hoverBoundingRect = (_a = ref2.current) == null ? void 0 : _a.getBoundingClientRect();
      const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
      const clientOffset = monitor.getClientOffset();
      const hoverClientY = clientOffset.y - hoverBoundingRect.top;
      if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {
        return;
      }
      if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {
        return;
      }
      dispatch(
        onDrag({
          type: "reorder_answers_by_type",
          id: item2.qualifiedCode,
          fromIndex: item2.index,
          toIndex: hoverIndex
        })
      );
      item2.index = hoverIndex;
    }
  });
  drop(preview(ref2));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TableRow,
    {
      style: {
        opacity: isDragging2 ? "0.2" : "1"
      },
      ref: ref2,
      "data-handler-id": handlerId,
      children: [
        inDesign(designMode) && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableCell,
          {
            ref: drag,
            sx: {
              padding: "0",
              color: theme.textStyles.text.color
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$h, {})
          },
          "move"
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableCell,
          {
            sx: {
              fontFamily: theme.textStyles.text.font,
              color: theme.textStyles.text.color,
              fontSize: theme.textStyles.text.size,
              padding: "4px"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                variant: "standard",
                value: content || "",
                onChange: (e2) => {
                  dispatch(
                    changeContent({
                      code: item.qualifiedCode,
                      key: "label",
                      lang: langInfo.lang,
                      value: e2.target.value
                    })
                  );
                },
                placeholder: onMainLang ? t2("content_editor_placeholder_option") : mainContent || t2("content_editor_placeholder_option"),
                InputProps: {
                  disableUnderline: true,
                  sx: {
                    fontFamily: theme.textStyles.text.font,
                    color: theme.textStyles.text.color,
                    fontSize: theme.textStyles.text.size
                  }
                }
              }
            )
          }
        ),
        [...Array(colCount)].map((_option, index22) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            TableCell,
            {
              scope: "row",
              align: "center",
              sx: {
                padding: "4px"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Radio,
                {
                  sx: {
                    "&.Mui-disabled": {
                      color: theme.textStyles.text.color
                    }
                  },
                  disabled: true
                }
              )
            },
            index22
          );
        }),
        inDesign(designMode) && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableCell,
          {
            onClick: (e2) => dispatch(removeAnswer(item.qualifiedCode)),
            sx: {
              padding: "0",
              color: theme.textStyles.text.color
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, {})
          },
          "remove"
        )
      ]
    },
    item.code
  );
}
function SCQArrayHeaderDesign$1({
  item,
  index: index2,
  designMode,
  t: t2,
  langInfo,
  parentQualifiedCode
}) {
  const dispatch = useDispatch();
  const theme = useTheme();
  const ref2 = reactExports.useRef();
  const onMainLang = langInfo.lang === langInfo.mainLang;
  const isRtl = rtlLanguage.includes(langInfo.lang);
  const isLtr = !isRtl;
  const content = useSelector((state) => {
    var _a, _b;
    return (_b = (_a = state.designState[item.qualifiedCode].content) == null ? void 0 : _a["label"]) == null ? void 0 : _b[langInfo.lang];
  });
  const mainContent = useSelector((state) => {
    var _a, _b;
    return (_b = (_a = state.designState[item.qualifiedCode].content) == null ? void 0 : _a["label"]) == null ? void 0 : _b[langInfo.mainLang];
  });
  const itemType = "row-".concat(parentQualifiedCode);
  const [isDragging2, drag, preview] = useDrag(
    {
      type: itemType,
      item: {
        qualifiedCode: item.qualifiedCode,
        index: index2
      },
      collect: (monitor) => monitor.isDragging()
    },
    [index2]
  );
  const [{ handlerId }, drop] = useDrop({
    accept: itemType,
    collect(monitor) {
      return {
        handlerId: monitor.getHandlerId()
      };
    },
    hover(item2, monitor) {
      var _a;
      if (!ref2.current || !monitor.isOver({ shallow: true }) || !item2) {
        return;
      }
      const dragIndex = item2.index;
      const hoverIndex = index2;
      if (dragIndex === hoverIndex) {
        return;
      }
      const hoverBoundingRect = (_a = ref2.current) == null ? void 0 : _a.getBoundingClientRect();
      const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;
      const clientOffset = monitor.getClientOffset();
      const hoverClientX = clientOffset.x - hoverBoundingRect.left;
      if (isLtr && dragIndex < hoverIndex && hoverClientX < hoverMiddleX) {
        return;
      }
      if (isLtr && dragIndex > hoverIndex && hoverClientX > hoverMiddleX) {
        return;
      }
      if (isRtl && dragIndex < hoverIndex && hoverClientX > hoverMiddleX) {
        return;
      }
      if (isRtl && dragIndex > hoverIndex && hoverClientX < hoverMiddleX) {
        return;
      }
      dispatch(
        onDrag({
          type: "reorder_answers_by_type",
          id: item2.qualifiedCode,
          fromIndex: item2.index,
          toIndex: hoverIndex
        })
      );
      item2.index = hoverIndex;
    }
  });
  drop(preview(ref2));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TableCell,
    {
      ref: ref2,
      "data-handler-id": handlerId,
      align: "center",
      sx: {
        opacity: isDragging2 ? "0.2" : "1",
        fontFamily: theme.textStyles.text.font,
        color: theme.textStyles.text.color,
        fontSize: theme.textStyles.text.size,
        padding: "4px"
      },
      children: [
        inDesign(designMode) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "inline-flex" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              ref: drag,
              sx: {
                padding: "0"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$h, {})
            },
            "move"
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              sx: {
                padding: "0"
              },
              onClick: (e2) => dispatch(removeAnswer(item.qualifiedCode)),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, {})
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            variant: "standard",
            value: content || "",
            onChange: (e2) => {
              dispatch(
                changeContent({
                  code: item.qualifiedCode,
                  key: "label",
                  lang: langInfo.lang,
                  value: e2.target.value
                })
              );
            },
            placeholder: onMainLang ? t2("content_editor_placeholder_option") : mainContent || t2("content_editor_placeholder_option"),
            inputProps: { style: { textAlign: "center" } },
            InputProps: {
              disableUnderline: true,
              sx: {
                fontFamily: theme.textStyles.text.font,
                color: theme.textStyles.text.color,
                fontSize: theme.textStyles.text.size
              }
            }
          }
        )
      ]
    },
    item.qualifiedCode
  );
}
var Videocam = {};
var _interopRequireDefault$o = interopRequireDefaultExports;
Object.defineProperty(Videocam, "__esModule", {
  value: true
});
var default_1$g = Videocam.default = void 0;
var _createSvgIcon$g = _interopRequireDefault$o(requireCreateSvgIcon());
var _jsxRuntime$g = jsxRuntimeExports;
default_1$g = Videocam.default = (0, _createSvgIcon$g.default)(/* @__PURE__ */ (0, _jsxRuntime$g.jsx)("path", {
  d: "M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11z"
}), "Videocam");
const placeholder$1 = "_placeholder_4iqf5_1";
const buttonContainer$1 = "_buttonContainer_4iqf5_9";
const styles$x = {
  placeholder: placeholder$1,
  buttonContainer: buttonContainer$1
};
function VideoDisplayDesign({ code, t: t2, onMainLang }) {
  var _a, _b;
  const designService = useService("design");
  const dispatch = useDispatch();
  const [isUploading, setUploading] = reactExports.useState(false);
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const handleVideoUpload = (e2) => {
    e2.preventDefault();
    setUploading(true);
    let file = e2.target.files[0];
    designService.uploadResource(file).then((response) => {
      setUploading(false);
      dispatch(changeResources({ code, key: "videoUrl", value: response.name }));
    }).catch((err) => {
      console.error(err);
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !isUploading && ((_a = state.resources) == null ? void 0 : _a.videoUrl) && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          position: "relative",
          marginTop: "16px",
          // 16:9 aspect ratio
          paddingTop: state.audio_only ? "10%" : "56%"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ReactPlayer,
          {
            url: buildResourceUrl(state.resources.videoUrl),
            loop: state.loop || false,
            light: true,
            controls: true,
            config: {
              forceAudio: state.audio_only || false
            },
            style: {
              backgroundColor: "black",
              position: "absolute",
              top: "0",
              left: "0"
            },
            volume: 1,
            width: "100%",
            height: "100%"
          }
        )
      }
    ),
    isUploading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$x.buttonContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingDots, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("uploading_video") })
    ] }) : onMainLang ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$x.buttonContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button,
      {
        component: "label",
        variant: "outlined",
        startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$g, {}),
        children: [
          ((_b = state.resources) == null ? void 0 : _b.videoUrl) ? t2("replace_video") : t2("upload_video"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              hidden: true,
              id: code,
              accept: "video/*",
              type: "file",
              onChange: handleVideoUpload
            }
          )
        ]
      }
    ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {})
  ] });
}
const signatureCanvas = "_signatureCanvas_1uxb1_1";
const styles$w = {
  signatureCanvas
};
function SignatureDesign() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      className: styles$w.signatureCanvas,
      sx: { backgroundColor: "background.default" },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: "/signature.png",
          style: {
            backgroundColor: "rgba(255,255,255,255)",
            width: "80%",
            maxWidth: "500px",
            height: "200px"
          }
        }
      )
    }
  );
}
const SignatureDesign$1 = React.memo(SignatureDesign);
var Photo = {};
var _interopRequireDefault$n = interopRequireDefaultExports;
Object.defineProperty(Photo, "__esModule", {
  value: true
});
var default_1$f = Photo.default = void 0;
var _createSvgIcon$f = _interopRequireDefault$n(requireCreateSvgIcon());
var _jsxRuntime$f = jsxRuntimeExports;
default_1$f = Photo.default = (0, _createSvgIcon$f.default)(/* @__PURE__ */ (0, _jsxRuntime$f.jsx)("path", {
  d: "M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2M8.5 13.5l2.5 3.01L14.5 12l4.5 6H5z"
}), "Photo");
const placeholder = "_placeholder_xjf3c_1";
const buttonContainer = "_buttonContainer_xjf3c_9";
const imageContainer$2 = "_imageContainer_xjf3c_14";
const styles$v = {
  placeholder,
  buttonContainer,
  imageContainer: imageContainer$2
};
function ImageDisplayDesign({ code, t: t2, onMainLang }) {
  var _a, _b;
  const designService = useService("design");
  const dispatch = useDispatch();
  const [isUploading, setUploading] = reactExports.useState(false);
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const handleUpload = (e2) => {
    e2.preventDefault();
    setUploading(true);
    let file = e2.target.files[0];
    designService.uploadResource(file).then((response) => {
      setUploading(false);
      dispatch(changeResources({ code, key: "imageUrl", value: response.name }));
    }).catch((err) => {
      console.error(err);
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !isUploading && ((_a = state.resources) == null ? void 0 : _a.imageUrl) && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        style: {
          width: "100%"
        },
        src: buildResourceUrl(state.resources.imageUrl)
      }
    ),
    isUploading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$v.buttonContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingDots, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("uploading_image") })
    ] }) : onMainLang ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$v.buttonContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: "outlined", component: "label", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$f, { className: "mr-10" }),
      ((_b = state.resources) == null ? void 0 : _b.imageUrl) ? t2("replace_image") : t2("upload_image"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          hidden: true,
          accept: "image/*",
          type: "file",
          onChange: handleUpload
        }
      )
    ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {})
  ] });
}
const ImageDisplayDesign$1 = React.memo(ImageDisplayDesign);
const choicesContainer$1 = "_choicesContainer_k0bnu_1";
const choice = "_choice_k0bnu_1";
const choiceLabels = "_choiceLabels_k0bnu_19";
const styles$u = {
  choicesContainer: choicesContainer$1,
  choice,
  choiceLabels
};
function NPSDesign({ code }) {
  var _a, _b, _c, _d;
  useTheme();
  let columns = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$u.choiceLabels, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: (_b = (_a = state.content) == null ? void 0 : _a.lower_bound_hint) == null ? void 0 : _b[lang2] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: (_d = (_c = state.content) == null ? void 0 : _c.higher_bound_hint) == null ? void 0 : _d[lang2] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: styles$u.choicesContainer, children: columns.map((option) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: styles$u.choice, children: option }, option);
    }) })
  ] });
}
const NPSDesign$1 = React.memo(NPSDesign);
const container$2 = "_container_cyg3h_1";
const styles$t = {
  container: container$2
};
function PhotoCaptureDesign({ code }) {
  var _a, _b;
  useTheme$1();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$t.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: "/camera.png",
        style: {
          maxHeight: "200px"
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    state.showHint && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ((_b = (_a = state.content) == null ? void 0 : _a.hint) == null ? void 0 : _b[lang2]) || "" })
  ] });
}
const PhotoCaptureDesign$1 = React.memo(PhotoCaptureDesign);
const container$1 = "_container_cyg3h_1";
const styles$s = {
  container: container$1
};
function VideoCaptureDesign({ code }) {
  var _a, _b;
  useTheme$1();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$s.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: "/video.png",
        style: {
          maxHeight: "200px"
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    state.showHint && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ((_b = (_a = state.content) == null ? void 0 : _a.hint) == null ? void 0 : _b[lang2]) || "" })
  ] });
}
const VideoCaptureDesign$1 = React.memo(VideoCaptureDesign);
const container = "_container_cyg3h_1";
const styles$r = {
  container
};
function BarcodeDesign({ code }) {
  var _a, _b;
  useTheme$1();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$r.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: "/barcode.png",
        style: {
          maxHeight: "200px"
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    state.showHint && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ((_b = (_a = state.content) == null ? void 0 : _a.hint) == null ? void 0 : _b[lang2]) || "" })
  ] });
}
const BarcodeDesign$1 = React.memo(BarcodeDesign);
const answerAdd = "_answerAdd_5tmqk_1";
const questionItem$1 = "_questionItem_5tmqk_9";
const choicesContainer = "_choicesContainer_5tmqk_15";
const styles$q = {
  answerAdd,
  questionItem: questionItem$1,
  choicesContainer
};
const answerItem = "_answerItem_shykq_1";
const answerIcon = "_answerIcon_shykq_10";
const answerIconOther = "_answerIconOther_shykq_18";
const answerNumberOrder = "_answerNumberOrder_shykq_27";
const answerControl = "_answerControl_shykq_32";
const answerControlRtl = "_answerControlRtl_shykq_37";
const answerControlOther = "_answerControlOther_shykq_42";
const answerControlOtherRtl = "_answerControlOtherRtl_shykq_47";
const answerOtherControl = "_answerOtherControl_shykq_52";
const styles$p = {
  answerItem,
  answerIcon,
  answerIconOther,
  answerNumberOrder,
  answerControl,
  answerControlRtl,
  answerControlOther,
  answerControlOtherRtl,
  answerOtherControl
};
var Build = {};
var _interopRequireDefault$m = interopRequireDefaultExports;
Object.defineProperty(Build, "__esModule", {
  value: true
});
var default_1$e = Build.default = void 0;
var _createSvgIcon$e = _interopRequireDefault$m(requireCreateSvgIcon());
var _jsxRuntime$e = jsxRuntimeExports;
default_1$e = Build.default = (0, _createSvgIcon$e.default)(/* @__PURE__ */ (0, _jsxRuntime$e.jsx)("path", {
  d: "m22.7 19-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4"
}), "Build");
function ChoiceItemDesign(props) {
  const dispatch = useDispatch();
  const theme = useTheme();
  const ref2 = reactExports.useRef(null);
  const langInfo = useSelector((state) => {
    return state.designState.langInfo;
  });
  const answer = useSelector((state) => {
    return state.designState[props.qualifiedCode];
  });
  const onMainLang = langInfo.lang === langInfo.mainLang;
  const lang2 = langInfo.lang;
  const isRtl = rtlLanguage.includes(lang2);
  const isInSetup = useSelector((state) => {
    var _a;
    return answer.type === "other" && ((_a = state.designState.setup) == null ? void 0 : _a.code) == props.qualifiedCode + "Atext";
  });
  const content = useSelector((state) => {
    var _a, _b;
    return (_b = (_a = state.designState[props.qualifiedCode].content) == null ? void 0 : _a["label"]) == null ? void 0 : _b[lang2];
  });
  const mainContent = useSelector((state) => {
    var _a, _b;
    return (_b = (_a = state.designState[props.qualifiedCode].content) == null ? void 0 : _a["label"]) == null ? void 0 : _b[langInfo.mainLang];
  });
  const getStyles = (isDragging22) => {
    const styles2 = {
      transition: "all 500ms"
    };
    if (isDragging22) {
      styles2.opacity = 0.5;
    }
    return styles2;
  };
  const [isDragging2, drag, preview] = useDrag(
    {
      type: props.droppableId,
      item: {
        index: props.index,
        draggableId: props.qualifiedCode,
        type: props.droppableId,
        code: props.code,
        itemType: props.type,
        droppableId: props.droppableId
      },
      collect: (monitor) => monitor.isDragging()
    },
    [props]
  );
  const [{ handlerId }, drop] = useDrop({
    accept: props.droppableId,
    collect(monitor) {
      return {
        handlerId: monitor.getHandlerId()
      };
    },
    hover(item, monitor) {
      var _a;
      if (!ref2.current || !monitor.isOver({ shallow: true }) || !item) {
        return;
      }
      const dragIndex = item.index;
      const hoverIndex = props.index;
      if (dragIndex === hoverIndex) {
        return;
      }
      const hoverBoundingRect = (_a = ref2.current) == null ? void 0 : _a.getBoundingClientRect();
      const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
      const clientOffset = monitor.getClientOffset();
      const hoverClientY = clientOffset.y - hoverBoundingRect.top;
      if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {
        return;
      }
      if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {
        return;
      }
      dispatch(
        onDrag({
          type: "reorder_answers",
          id: item.draggableId,
          fromIndex: item.index,
          toIndex: props.index
        })
      );
      item.index = hoverIndex;
    }
  });
  drop(preview(ref2));
  getContrastColor(theme.palette.background.paper);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: ref2, style: getStyles(isDragging2), "data-handler-id": handlerId, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: { backgroundColor: isInSetup ? "beige" : "inherit" },
      className: styles$p.answerItem,
      children: [
        inDesign(props.designMode) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: drag, className: styles$p.answerIcon, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          default_1$h,
          {
            ref: drag,
            sx: {
              fontSize: 18
            }
          }
        ) }),
        props.label ? /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: props.label }) : "",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            variant: "standard",
            disabled: !contentEditable(props.designMode),
            className: answer.type === "other" && isRtl ? styles$p.answerControlOtherRtl : answer.type === "other" ? styles$p.answerControlOther : isRtl ? styles$p.answerControlRtl : styles$p.answerControl,
            value: content || "",
            onChange: (e2) => dispatch(
              changeContent({
                code: props.qualifiedCode,
                key: "label",
                lang: lang2,
                value: e2.target.value
              })
            ),
            placeholder: onMainLang ? props.t("content_editor_placeholder_option") : mainContent || props.t("content_editor_placeholder_option"),
            InputProps: {
              sx: {
                fontFamily: theme.textStyles.text.font,
                color: theme.textStyles.text.color,
                fontSize: theme.textStyles.text.size
              }
            }
          }
        ),
        answer.type === "other" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          default_1$e,
          {
            sx: { fontSize: 18 },
            className: styles$p.answerIconOther,
            onClick: () => {
              dispatch(
                setup({
                  code: props.qualifiedCode + "Atext",
                  rules: setupOptions("other_text")
                })
              );
            }
          },
          "setup"
        ),
        inDesign(props.designMode) && /* @__PURE__ */ jsxRuntimeExports.jsx(
          default_1$o,
          {
            sx: { fontSize: 18 },
            className: styles$p.answerIcon,
            onClick: (e2) => dispatch(removeAnswer(props.qualifiedCode))
          },
          "close"
        )
      ]
    }
  ) });
}
function ChoiceQuestion(props) {
  const theme = useTheme();
  const t2 = props.t;
  const children = useSelector((state) => {
    return state.designState[props.code].children;
  });
  const questionType = useSelector((state) => {
    return state.designState[props.code].type;
  });
  const isOther = (questionType == "mcq" || questionType == "scq") && (!children || !children.some((el) => el.code === "Aother"));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$q.questionItem, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$q.choicesContainer, children: children && children.length > 0 && children.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      ChoiceItemDesign,
      {
        designMode: props.designMode,
        code: item.code,
        t: props.t,
        label: item.code,
        qualifiedCode: item.qualifiedCode,
        index: index2,
        type: props.type,
        droppableId: "option-".concat(props.code)
      },
      item.code
    )) }),
    inDesign(props.designMode) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$q.answerAdd, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          size: "small",
          style: {
            fontFamily: theme.textStyles.text.font,
            fontSize: theme.textStyles.text.size,
            color: theme.textStyles.question.color
          },
          onClick: () => props.addNewAnswer(props.code, questionType),
          children: t2("add_option")
        }
      ),
      isOther && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            style: {
              color: theme.textStyles.question.color
            },
            children: t2("or")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            style: {
              fontFamily: theme.textStyles.text.font,
              fontSize: theme.textStyles.text.size,
              color: theme.textStyles.question.color
            },
            size: "small",
            className: styles$q.answerIcon,
            onClick: () => props.addNewAnswer(props.code, questionType, "other"),
            children: t2("add_other")
          }
        )
      ] })
    ] })
  ] });
}
const ChoiceQuestion$1 = React.memo(ChoiceQuestion);
const addAnswerIcon$2 = "_addAnswerIcon_4rcog_1";
const questionItem = "_questionItem_4rcog_5";
const addAnswerButton$2 = "_addAnswerButton_4rcog_10";
const styles$o = {
  addAnswerIcon: addAnswerIcon$2,
  questionItem,
  addAnswerButton: addAnswerButton$2
};
const imageIconButton$1 = "_imageIconButton_chgwf_1";
const imageContainer$1 = "_imageContainer_chgwf_8";
const addAnswerIcon$1 = "_addAnswerIcon_chgwf_16";
const loadingContainer$1 = "_loadingContainer_chgwf_20";
const addAnswerButton$1 = "_addAnswerButton_chgwf_26";
const buttonContainers$1 = "_buttonContainers_chgwf_34";
const styles$n = {
  imageIconButton: imageIconButton$1,
  imageContainer: imageContainer$1,
  addAnswerIcon: addAnswerIcon$1,
  loadingContainer: loadingContainer$1,
  addAnswerButton: addAnswerButton$1,
  buttonContainers: buttonContainers$1
};
var DeleteOutline = {};
var _interopRequireDefault$l = interopRequireDefaultExports;
Object.defineProperty(DeleteOutline, "__esModule", {
  value: true
});
var default_1$d = DeleteOutline.default = void 0;
var _createSvgIcon$d = _interopRequireDefault$l(requireCreateSvgIcon());
var _jsxRuntime$d = jsxRuntimeExports;
default_1$d = DeleteOutline.default = (0, _createSvgIcon$d.default)(/* @__PURE__ */ (0, _jsxRuntime$d.jsx)("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM8 9h8v10H8zm7.5-5-1-1h-5l-1 1H5v2h14V4z"
}), "DeleteOutline");
var Add = {};
var _interopRequireDefault$k = interopRequireDefaultExports;
Object.defineProperty(Add, "__esModule", {
  value: true
});
var default_1$c = Add.default = void 0;
var _createSvgIcon$c = _interopRequireDefault$k(requireCreateSvgIcon());
var _jsxRuntime$c = jsxRuntimeExports;
default_1$c = Add.default = (0, _createSvgIcon$c.default)(/* @__PURE__ */ (0, _jsxRuntime$c.jsx)("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
}), "Add");
function ImageChoiceItemDesign({
  parentCode,
  index: index2,
  qualifiedCode,
  type: type2,
  columnNumber,
  imageAspectRatio,
  designMode,
  hideText,
  t: t2,
  addAnswer
}) {
  var _a;
  const designService = useService("design");
  const dispatch = useDispatch();
  const theme = useTheme();
  const ref2 = reactExports.useRef();
  const [isUploading, setUploading] = reactExports.useState(false);
  const langInfo = useSelector((state) => {
    return state.designState.langInfo;
  });
  const answer = useSelector((state) => {
    return type2 == "add" ? void 0 : state.designState[qualifiedCode];
  });
  const onMainLang = langInfo.lang === langInfo.mainLang;
  const lang2 = langInfo.lang;
  const isRtl = rtlLanguage.includes(lang2);
  const content = useSelector((state) => {
    var _a2, _b;
    return type2 == "add" ? void 0 : (_b = (_a2 = state.designState[qualifiedCode].content) == null ? void 0 : _a2["label"]) == null ? void 0 : _b[lang2];
  });
  const mainContent = useSelector((state) => {
    var _a2, _b;
    return type2 == "add" ? void 0 : (_b = (_a2 = state.designState[qualifiedCode].content) == null ? void 0 : _a2["label"]) == null ? void 0 : _b[langInfo.mainLang];
  });
  const onDelete = () => {
    if (window.confirm("Are you sure?")) {
      dispatch(removeAnswer(qualifiedCode));
    }
  };
  const backgroundImage = ((_a = answer == null ? void 0 : answer.resources) == null ? void 0 : _a.image) ? "url('".concat(buildResourceUrl(answer.resources.image), "')") : "0";
  function handleImageChange(e2) {
    e2.preventDefault();
    let file = e2.target.files[0];
    setUploading(true);
    designService.uploadResource(file).then((response) => {
      setUploading(false);
      dispatch(
        changeResources({
          code: qualifiedCode,
          key: "image",
          value: response.name
        })
      );
    }).catch((err) => {
      setUploading(false);
      console.error(err);
    });
  }
  const dragType = parentCode + "image-drag";
  const getRowByIndex = (index22) => {
    return Math.round(index22 / columnNumber);
  };
  const getColByIndex = (index22) => {
    return index22 % columnNumber;
  };
  const colIndex = getColByIndex(index2);
  const rowIndex = getRowByIndex(index2);
  const [isDragging2, drag, preview] = useDrag(
    {
      type: dragType,
      item: {
        index: index2,
        colIndex,
        rowIndex,
        draggableId: qualifiedCode,
        parentCode,
        type: dragType,
        itemType: dragType
      },
      collect: (monitor) => monitor.isDragging()
    },
    [index2]
  );
  const [{ handlerId }, drop] = useDrop({
    accept: dragType,
    collect(monitor) {
      return {
        handlerId: monitor.getHandlerId()
      };
    },
    hover(item, monitor) {
      var _a2;
      if (!ref2.current || !monitor.isOver({ shallow: true }) || !item) {
        return;
      }
      const dragIndex = item.index;
      const hoverIndex = index2;
      const dragRowIndex = item.rowIndex;
      const hoverRowIndex = rowIndex;
      const dragColIndex = item.colIndex;
      const hoverColIndex = colIndex;
      if (dragIndex === hoverIndex) {
        return;
      }
      const hoverBoundingRect = (_a2 = ref2.current) == null ? void 0 : _a2.getBoundingClientRect();
      const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
      const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;
      const clientOffset = monitor.getClientOffset();
      const hoverClientY = clientOffset.y - hoverBoundingRect.top;
      const hoverClientX = clientOffset.x - hoverBoundingRect.left;
      if (dragRowIndex < hoverRowIndex && hoverClientY < hoverMiddleY && dragColIndex < hoverColIndex && hoverClientX < hoverMiddleX) {
        return;
      }
      if (dragRowIndex > hoverRowIndex && hoverClientY > hoverMiddleY && dragColIndex > hoverColIndex && hoverClientX > hoverMiddleX) {
        return;
      }
      {
        dispatch(
          onDrag({
            type: "reorder_answers",
            id: item.draggableId,
            fromIndex: dragIndex,
            toIndex: hoverIndex
          })
        );
        item.index = hoverIndex;
        item.rowIndex = hoverRowIndex;
        item.colIndex = hoverColIndex;
      }
    }
  });
  drop(preview(ref2));
  return type2 == "add" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { height: "100%", item: true, xs: 12 / columnNumber, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      className: styles$n.addAnswerButton,
      style: {
        minHeight: "100px",
        height: "100%",
        width: "100%",
        backgroundColor: theme.palette.background.default,
        borderRadius: "4px"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          sx: {
            color: theme.textStyles.text.color
          },
          className: styles$n.addAnswerIcon,
          onClick: () => {
            addAnswer();
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$c, {})
        }
      )
    }
  ) }, "add") : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Grid$1,
    {
      style: {
        opacity: isDragging2 ? "0.2" : "1"
      },
      item: true,
      xs: 12 / columnNumber,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: styles$n.imageContainer,
            style: {
              paddingTop: 100 / imageAspectRatio + "%",
              backgroundColor: theme.palette.background.default,
              backgroundImage
            },
            ref: ref2,
            "data-handler-id": handlerId,
            children: [
              inDesign(designMode) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$n.buttonContainers, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IconButton,
                  {
                    sx: {
                      color: theme.textStyles.text.color
                    },
                    className: styles$n.imageIconButton,
                    onClick: () => {
                      onDelete();
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$d, {})
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  IconButton,
                  {
                    sx: {
                      color: theme.textStyles.text.color
                    },
                    component: "label",
                    className: styles$n.imageIconButton,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$f, {}),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "input",
                        {
                          hidden: true,
                          id: qualifiedCode,
                          accept: "image/*",
                          multiple: true,
                          type: "file",
                          onChange: handleImageChange
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IconButton,
                  {
                    sx: {
                      color: theme.textStyles.text.color
                    },
                    ref: drag,
                    className: styles$n.imageIconButton,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$h, {})
                  }
                )
              ] }),
              isUploading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$n.loadingContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingDots, {}) })
            ]
          }
        ),
        !hideText && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            dir: isRtl ? "rtl" : "ltr",
            variant: "standard",
            value: content || "",
            disabled: !contentEditable(designMode),
            onChange: (e2) => dispatch(
              changeContent({
                code: qualifiedCode,
                key: "label",
                lang: lang2,
                value: e2.target.value
              })
            ),
            placeholder: onMainLang ? t2("content_editor_placeholder_option") : mainContent || t2("content_editor_placeholder_option"),
            inputProps: { style: { textAlign: "center" } },
            InputProps: {
              sx: {
                fontFamily: theme.textStyles.text.font,
                color: theme.textStyles.text.color,
                fontSize: theme.textStyles.text.size
              }
            }
          }
        )
      ]
    },
    qualifiedCode
  ) });
}
const imageIconButton = "_imageIconButton_lgrld_1";
const imageContainer = "_imageContainer_lgrld_8";
const addAnswerIcon = "_addAnswerIcon_lgrld_12";
const loadingContainer = "_loadingContainer_lgrld_16";
const addAnswerButton = "_addAnswerButton_lgrld_23";
const svgContainer = "_svgContainer_lgrld_31";
const buttonContainers = "_buttonContainers_lgrld_36";
const styles$m = {
  imageIconButton,
  imageContainer,
  addAnswerIcon,
  loadingContainer,
  addAnswerButton,
  svgContainer,
  buttonContainers
};
class IconService {
  search(searchTerm, cancelToken) {
    return new Promise((resolve, reject) => {
      axios.get(
        "https://api.iconify.design/search?query=".concat(searchTerm, "&limit=250"),
        { cancelToken: cancelToken.token }
      ).then((data) => {
        resolve(data.data.icons);
      }).catch((err) => {
        if (axios.isCancel(err)) {
          console.debug("Request canceled:", err.message);
        } else {
          reject(err);
        }
      });
    });
  }
}
const IconService$1 = new IconService();
const resultImage = "_resultImage_2y7qe_1";
const styles$l = {
  resultImage
};
function IconSelector({ currentIcon, onIconSelected }) {
  const { t: t2 } = useTranslation("design");
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [cancelToken, setCancelToken] = reactExports.useState(null);
  const [searchResults, setSearchResults] = reactExports.useState([]);
  reactExports.useEffect(() => {
    if (cancelToken) {
      cancelToken.cancel("Operation canceled by the user.");
    }
    if (searchTerm) {
      const source = axios.CancelToken.source();
      setCancelToken(source);
      IconService$1.search(searchTerm, source).then((result) => {
        setSearchResults(result);
      }).catch((e2) => {
        console.error(e2);
      });
    } else {
      setSearchResults([]);
    }
  }, [searchTerm]);
  const handleInputChange = (event) => {
    setSearchTerm(event.target.value);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      fullScreen: true,
      sx: { margin: "200px", backgroundColor: "white" },
      open: true,
      onClose: () => onIconSelected(false),
      "aria-labelledby": "alert-dialog-title-logic-builder",
      "aria-describedby": "alert-dialog-description",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { id: "alert-dialog-title-logic-builder", children: t2("select Icon") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              placeholder: "Search for icons",
              value: searchTerm,
              onChange: handleInputChange
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "search-results", children: searchResults.map((icon, index2) => {
            const parts = icon.split(":");
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              SVGDisplay,
              {
                onClick: onIconSelected,
                source: "https://api.iconify.design/".concat(parts[0], "/").concat(parts[1], ".svg")
              },
              index2
            );
          }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => {
        }, autoFocus: true, children: "Select" }) })
      ]
    }
  );
}
function SVGDisplay({ source, onClick }) {
  const [svgSource, setSvgSource] = reactExports.useState("");
  reactExports.useEffect(() => {
    axios.get(source).then((response) => {
      if (isSVGValid(response.data)) {
        setSvgSource(response.data);
      }
    });
  }, [source]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      onClick: () => {
        onClick(svgSource);
      },
      className: styles$l.resultImage,
      dangerouslySetInnerHTML: { __html: svgSource }
    }
  );
}
function isSVGValid(svgContent) {
  if (typeof svgContent !== "string") {
    return false;
  }
  return /^<svg[\s\S]*<\/svg>$/.test(svgContent);
}
function IconChoiceItemDesign({
  parentCode,
  index: index2,
  qualifiedCode,
  type: type2,
  columnNumber,
  designMode,
  imageHeight,
  hideText,
  t: t2,
  addAnswer
}) {
  var _a, _b, _c, _d, _e;
  const designService = useService("design");
  const dispatch = useDispatch();
  const ref2 = reactExports.useRef(null);
  const theme = useTheme();
  const [iconSelectoOpen, setIconSelectorOpen] = reactExports.useState(false);
  const langInfo = useSelector((state) => {
    return state.designState.langInfo;
  });
  const answer = useSelector((state) => {
    return type2 == "add" ? void 0 : state.designState[qualifiedCode];
  });
  const onMainLang = langInfo.lang === langInfo.mainLang;
  const lang2 = langInfo.lang;
  const svgIconName = (_a = answer == null ? void 0 : answer.resources) == null ? void 0 : _a.icon;
  const content = type2 == "add" ? void 0 : (_c = (_b = answer.content) == null ? void 0 : _b["label"]) == null ? void 0 : _c[lang2];
  type2 == "add" ? void 0 : answer.icon;
  const isRtl = rtlLanguage.includes(lang2);
  const mainContent = type2 == "add" ? void 0 : (_e = (_d = answer.content) == null ? void 0 : _d["label"]) == null ? void 0 : _e[langInfo.mainLang];
  const onDelete = () => {
    if (window.confirm("Are you sure?")) {
      dispatch(removeAnswer(qualifiedCode));
    }
  };
  const dragType = parentCode + "icon-drag";
  const getRowByIndex = (index22) => {
    return Math.round(index22 / columnNumber);
  };
  const getColByIndex = (index22) => {
    return index22 % columnNumber;
  };
  const uploadAsResource = (svgContent) => {
    const svgBlob = new Blob([svgContent], { type: "image/svg+xml" });
    const svgFile = new File([svgBlob], "file.svg", { type: "image/svg+xml" });
    designService.uploadResource(svgFile).then((response) => {
      dispatch(
        changeResources({
          code: qualifiedCode,
          key: "icon",
          value: response.name
        })
      );
    }).catch((error2) => {
      console.error(error2.message);
    });
  };
  const colIndex = getColByIndex(index2);
  const rowIndex = getRowByIndex(index2);
  const [isDragging2, drag, preview] = useDrag(
    {
      type: dragType,
      item: {
        index: index2,
        colIndex,
        rowIndex,
        draggableId: qualifiedCode,
        parentCode,
        type: dragType,
        itemType: dragType
      },
      collect: (monitor) => monitor.isDragging()
    },
    [index2]
  );
  const [{ handlerId }, drop] = useDrop({
    accept: dragType,
    collect(monitor) {
      return {
        handlerId: monitor.getHandlerId()
      };
    },
    hover(item, monitor) {
      var _a2;
      if (!ref2.current || !monitor.isOver({ shallow: true }) || !item) {
        return;
      }
      const dragIndex = item.index;
      const hoverIndex = index2;
      const dragRowIndex = item.rowIndex;
      const hoverRowIndex = rowIndex;
      const dragColIndex = item.colIndex;
      const hoverColIndex = colIndex;
      if (dragIndex === hoverIndex) {
        return;
      }
      const hoverBoundingRect = (_a2 = ref2.current) == null ? void 0 : _a2.getBoundingClientRect();
      const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
      const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;
      const clientOffset = monitor.getClientOffset();
      const hoverClientY = clientOffset.y - hoverBoundingRect.top;
      const hoverClientX = clientOffset.x - hoverBoundingRect.left;
      if (dragRowIndex < hoverRowIndex && hoverClientY < hoverMiddleY && dragColIndex < hoverColIndex && hoverClientX < hoverMiddleX) {
        return;
      }
      if (dragRowIndex > hoverRowIndex && hoverClientY > hoverMiddleY && dragColIndex > hoverColIndex && hoverClientX > hoverMiddleX) {
        return;
      }
      {
        dispatch(
          onDrag({
            type: "reorder_answers",
            id: item.draggableId,
            fromIndex: dragIndex,
            toIndex: hoverIndex
          })
        );
        item.index = hoverIndex;
        item.rowIndex = hoverRowIndex;
        item.colIndex = hoverColIndex;
      }
    }
  });
  drop(preview(ref2));
  return type2 == "add" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, xs: 12 / columnNumber, height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      className: styles$m.addAnswerButton,
      style: {
        minHeight: "100px",
        borderRadius: "4px",
        backgroundColor: theme.palette.background.default,
        height: "100%",
        width: "100%"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          sx: {
            color: theme.textStyles.text.color
          },
          className: styles$m.addAnswerIcon,
          onClick: () => {
            addAnswer();
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$c, {})
        }
      )
    }
  ) }, "add") : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        style: {
          opacity: isDragging2 ? "0.2" : "1"
        },
        item: true,
        xs: 12 / columnNumber,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: ref2, "data-handler-id": handlerId, children: [
          inDesign(designMode) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$m.buttonContainers, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                sx: { color: theme.textStyles.text.color },
                className: styles$m.imageIconButton,
                onClick: () => {
                  onDelete();
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$d, {})
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                sx: { color: theme.textStyles.text.color },
                component: "label",
                className: styles$m.imageIconButton,
                onClick: () => setIconSelectorOpen(true),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$f, {})
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                sx: { color: theme.textStyles.text.color },
                ref: drag,
                className: styles$m.imageIconButton,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$h, {})
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                width: "100%",
                display: "flex",
                justifyContent: "center"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                DynamicSvg,
                {
                  imageHeight: imageHeight + "px",
                  svgUrl: svgIconName ? buildResourceUrl(svgIconName) : void 0
                }
              )
            }
          ),
          !hideText && /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              dir: isRtl ? "rtl" : "ltr",
              variant: "standard",
              disabled: !contentEditable(designMode),
              value: content || "",
              onChange: (e2) => dispatch(
                changeContent({
                  code: qualifiedCode,
                  key: "label",
                  lang: lang2,
                  value: e2.target.value
                })
              ),
              placeholder: onMainLang ? t2("content_editor_placeholder_option") : mainContent || t2("content_editor_placeholder_option"),
              inputProps: { style: { textAlign: "center" } },
              InputProps: {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  color: theme.textStyles.text.color,
                  fontSize: theme.textStyles.text.size
                }
              }
            }
          )
        ] })
      },
      qualifiedCode
    ),
    iconSelectoOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconSelector,
      {
        currentIcon: "",
        onIconSelected: (icon2) => {
          uploadAsResource(icon2);
          setIconSelectorOpen(false);
        }
      }
    )
  ] });
}
function ImageChoiceQuestion(props) {
  const state = useSelector((state2) => {
    return state2.designState[props.code];
  });
  const children = state.children || [];
  const imageAspectRatio = useSelector((state2) => {
    return state2.designState[props.code].imageAspectRatio || 1;
  });
  const questionType = state.type;
  const childrenWithAdd = inDesign(props.designMode) ? [...children, { type: "add", code: "add" }] : children;
  const columnNumber = state.columns || 2;
  const hideText = state.hideText || false;
  const spacing = state.spacing || 8;
  const imageHeight = state.iconSize ? +state.iconSize : 64;
  const itemWidth = "calc(".concat(100 / columnNumber, "% - ").concat(spacing, "px)");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$o.questionItem, children: imageHeight && /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      id: "items-" + props.code,
      sx: {
        display: "flex",
        flexWrap: "wrap",
        gap: "".concat(spacing, "px")
      },
      children: childrenWithAdd.map(
        (item, index2) => props.icon ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              flex: "0 1 ".concat(itemWidth),
              maxWidth: itemWidth
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconChoiceItemDesign,
              {
                parentCode: props.code,
                index: index2,
                columnNumber,
                designMode: props.designMode,
                hideText,
                imageHeight,
                t: props.t,
                addAnswer: () => props.addNewAnswer(props.code, questionType),
                type: item.type,
                qualifiedCode: item.qualifiedCode
              },
              item.code
            )
          },
          item.code
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              flex: "0 1 ".concat(itemWidth),
              maxWidth: itemWidth
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ImageChoiceItemDesign,
              {
                parentCode: props.code,
                index: index2,
                imageAspectRatio,
                columnNumber,
                hideText,
                designMode: props.designMode,
                imageHeight,
                t: props.t,
                addAnswer: () => props.addNewAnswer(props.code, questionType),
                type: item.type,
                qualifiedCode: item.qualifiedCode
              },
              item.code
            )
          },
          item.code
        )
      )
    }
  ) });
}
const ImageChoiceQuestion$1 = React.memo(ImageChoiceQuestion);
var AddBox = {};
var _interopRequireDefault$j = interopRequireDefaultExports;
Object.defineProperty(AddBox, "__esModule", {
  value: true
});
var default_1$b = AddBox.default = void 0;
var _createSvgIcon$b = _interopRequireDefault$j(requireCreateSvgIcon());
var _jsxRuntime$b = jsxRuntimeExports;
default_1$b = AddBox.default = (0, _createSvgIcon$b.default)(/* @__PURE__ */ (0, _jsxRuntime$b.jsx)("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4z"
}), "AddBox");
function SCQIconArrayDesign(props) {
  const theme = useTheme();
  const t2 = props.t;
  const langInfo = useSelector((state) => {
    return state.designState.langInfo;
  });
  const inDesgin = props.designMode == DESIGN_SURVEY_MODE.DESIGN;
  const children = useSelector((state) => {
    return state.designState[props.code].children;
  });
  const rows = (children == null ? void 0 : children.filter((el) => el.type == "row")) || [];
  const columns = (children == null ? void 0 : children.filter((el) => el.type == "column")) || [];
  const icons = useSelector(
    (state) => columns.map((col) => {
      var _a;
      return (_a = state.designState[col.qualifiedCode].resources) == null ? void 0 : _a.icon;
    })
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    inDesgin && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$L.addColumn, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        sx: {
          fontFamily: theme.textStyles.text.font,
          fontSize: theme.textStyles.text.size,
          color: theme.textStyles.question.color
        },
        size: "small",
        onClick: (e2) => props.addNewAnswer(props.code, props.type, "column"),
        children: t2("add_column")
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
        inDesgin && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableCell,
          {
            sx: {
              padding: "0"
            }
          },
          "move"
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, {}, "content"),
        columns.map((item, index2) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            SCQArrayHeaderDesign,
            {
              parentQualifiedCode: props.qualifiedCode,
              langInfo,
              t: props.t,
              item,
              inDesgin,
              icons,
              styles: styles$L,
              index: index2
            },
            item.qualifiedCode
          );
        }),
        inDesgin && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableCell,
          {
            sx: {
              padding: "0"
            }
          },
          "remove"
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: rows.map((item, index2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          SCQArrayRowDesign,
          {
            parentQualifiedCode: props.qualifiedCode,
            langInfo,
            t: props.t,
            item,
            inDesgin,
            columns,
            icons,
            index: index2
          },
          item.qualifiedCode
        );
      }) })
    ] }) }),
    props.inDesgin && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$L.addRow, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        sx: {
          fontFamily: theme.textStyles.text.font,
          fontSize: theme.textStyles.text.size,
          color: theme.textStyles.question.color
        },
        size: "small",
        onClick: (e2) => props.addNewAnswer(props.code, props.type, "row"),
        children: t2("add_row")
      }
    ) })
  ] });
}
const SCQIconArrayDesign$1 = React.memo(SCQIconArrayDesign);
function SCQArrayRowDesign({
  item,
  index: index2,
  columns,
  icons,
  inDesgin,
  t: t2,
  langInfo,
  parentQualifiedCode
}) {
  const dispatch = useDispatch();
  const theme = useTheme();
  const ref2 = reactExports.useRef();
  const onMainLang = langInfo.lang === langInfo.mainLang;
  const content = useSelector((state) => {
    var _a, _b;
    return (_b = (_a = state.designState[item.qualifiedCode].content) == null ? void 0 : _a["label"]) == null ? void 0 : _b[langInfo.lang];
  });
  const mainContent = useSelector((state) => {
    var _a, _b;
    return (_b = (_a = state.designState[item.qualifiedCode].content) == null ? void 0 : _a["label"]) == null ? void 0 : _b[langInfo.mainLang];
  });
  const itemType = "col-".concat(parentQualifiedCode);
  const [isDragging2, drag, preview] = useDrag(
    {
      type: itemType,
      item: {
        qualifiedCode: item.qualifiedCode,
        index: index2
      },
      collect: (monitor) => monitor.isDragging()
    },
    [index2]
  );
  const [{ handlerId }, drop] = useDrop({
    accept: itemType,
    collect(monitor) {
      return {
        handlerId: monitor.getHandlerId()
      };
    },
    hover(item2, monitor) {
      var _a;
      if (!ref2.current || !monitor.isOver({ shallow: true }) || !item2) {
        return;
      }
      const dragIndex = item2.index;
      const hoverIndex = index2;
      if (dragIndex === hoverIndex) {
        return;
      }
      const hoverBoundingRect = (_a = ref2.current) == null ? void 0 : _a.getBoundingClientRect();
      const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
      const clientOffset = monitor.getClientOffset();
      const hoverClientY = clientOffset.y - hoverBoundingRect.top;
      if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {
        return;
      }
      if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {
        return;
      }
      dispatch(
        onDrag({
          type: "reorder_answers_by_type",
          id: item2.qualifiedCode,
          fromIndex: item2.index,
          toIndex: hoverIndex
        })
      );
      item2.index = hoverIndex;
    }
  });
  drop(preview(ref2));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TableRow,
    {
      style: {
        opacity: isDragging2 ? "0.2" : "1"
      },
      ref: ref2,
      "data-handler-id": handlerId,
      children: [
        inDesgin && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableCell,
          {
            ref: drag,
            sx: {
              padding: "0",
              color: theme.textStyles.text.color
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$h, {})
          },
          "move"
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableCell,
          {
            sx: {
              fontFamily: theme.textStyles.text.font,
              color: theme.textStyles.text.color,
              fontSize: theme.textStyles.text.size,
              padding: "4px"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                variant: "standard",
                value: content || "",
                onChange: (e2) => {
                  dispatch(
                    changeContent({
                      code: item.qualifiedCode,
                      key: "label",
                      lang: langInfo.lang,
                      value: e2.target.value
                    })
                  );
                },
                placeholder: onMainLang ? t2("content_editor_placeholder_option") : mainContent || t2("content_editor_placeholder_option"),
                InputProps: {
                  disableUnderline: true,
                  sx: {
                    fontFamily: theme.textStyles.text.font,
                    color: theme.textStyles.text.color,
                    fontSize: theme.textStyles.text.size
                  }
                }
              }
            )
          }
        ),
        columns.map((option, index22) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            TableCell,
            {
              scope: "row",
              align: "center",
              sx: {
                padding: "4px"
              },
              children: icons[index22] && /* @__PURE__ */ jsxRuntimeExports.jsx(
                DynamicSvg,
                {
                  opacity: 0.2,
                  iconColor: theme.textStyles.text.color,
                  onIconClick: () => {
                  },
                  imageHeight: "64px",
                  svgUrl: icons[index22] ? buildResourceUrl(icons[index22]) : void 0
                }
              )
            },
            index22
          );
        }),
        inDesgin && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableCell,
          {
            onClick: (e2) => dispatch(removeAnswer(item.qualifiedCode)),
            sx: {
              padding: "0",
              color: theme.textStyles.text.color
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, {})
          },
          "remove"
        )
      ]
    },
    item.code
  );
}
function SCQArrayHeaderDesign({
  item,
  index: index2,
  icons,
  inDesgin,
  t: t2,
  langInfo,
  parentQualifiedCode,
  styles: styles2
}) {
  const designService = useService("design");
  const icon = icons[index2];
  const [iconSelectoOpen, setIconSelectorOpen] = reactExports.useState(false);
  const dispatch = useDispatch();
  const theme = useTheme();
  const ref2 = reactExports.useRef();
  const isRtl = rtlLanguage.includes(langInfo.lang);
  const isLtr = !isRtl;
  const itemType = "row-".concat(parentQualifiedCode);
  const [isDragging2, drag, preview] = useDrag(
    {
      type: itemType,
      item: {
        qualifiedCode: item.qualifiedCode,
        index: index2
      },
      collect: (monitor) => monitor.isDragging()
    },
    [index2]
  );
  const [{ handlerId }, drop] = useDrop({
    accept: itemType,
    collect(monitor) {
      return {
        handlerId: monitor.getHandlerId()
      };
    },
    hover(item2, monitor) {
      var _a;
      if (!ref2.current || !monitor.isOver({ shallow: true }) || !item2) {
        return;
      }
      const dragIndex = item2.index;
      const hoverIndex = index2;
      if (dragIndex === hoverIndex) {
        return;
      }
      const hoverBoundingRect = (_a = ref2.current) == null ? void 0 : _a.getBoundingClientRect();
      const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;
      const clientOffset = monitor.getClientOffset();
      const hoverClientX = clientOffset.x - hoverBoundingRect.left;
      if (isLtr && dragIndex < hoverIndex && hoverClientX < hoverMiddleX) {
        return;
      }
      if (isLtr && dragIndex > hoverIndex && hoverClientX > hoverMiddleX) {
        return;
      }
      if (isRtl && dragIndex < hoverIndex && hoverClientX > hoverMiddleX) {
        return;
      }
      if (isRtl && dragIndex > hoverIndex && hoverClientX < hoverMiddleX) {
        return;
      }
      dispatch(
        onDrag({
          type: "reorder_answers_by_type",
          id: item2.qualifiedCode,
          fromIndex: item2.index,
          toIndex: hoverIndex
        })
      );
      item2.index = hoverIndex;
    }
  });
  const uploadAsResource = (svgContent) => {
    const svgBlob = new Blob([svgContent], { type: "image/svg+xml" });
    const svgFile = new File([svgBlob], "file.svg", { type: "image/svg+xml" });
    designService.uploadResource(svgFile).then((response) => {
      dispatch(
        changeResources({
          code: item.qualifiedCode,
          key: "icon",
          value: response.name
        })
      );
    }).catch((error2) => {
      console.error(error2.message);
    });
  };
  drop(preview(ref2));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      TableCell,
      {
        ref: ref2,
        "data-handler-id": handlerId,
        align: "center",
        sx: {
          opacity: isDragging2 ? "0.2" : "1",
          fontFamily: theme.textStyles.text.font,
          color: theme.textStyles.text.color,
          fontSize: theme.textStyles.text.size,
          padding: "4px"
        },
        children: [
          inDesgin && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "inline-flex" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                ref: drag,
                sx: {
                  padding: "0"
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$h, {})
              },
              "move"
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                sx: {
                  padding: "0",
                  color: theme.textStyles.text.color
                },
                onClick: (e2) => dispatch(removeAnswer(item.qualifiedCode)),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, {})
              }
            )
          ] }),
          icon ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            DynamicSvg,
            {
              onIconClick: () => setIconSelectorOpen(true),
              imageHeight: "64px",
              svgUrl: icon ? buildResourceUrl(icon) : void 0
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => setIconSelectorOpen(true), children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$b, { sx: { width: "64px", height: "64px" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Click to add icon" })
            ] })
          ] })
        ]
      },
      item.qualifiedCode
    ),
    iconSelectoOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconSelector,
      {
        currentIcon: "",
        onIconSelected: (icon2) => {
          uploadAsResource(icon2);
          setIconSelectorOpen(false);
        }
      }
    )
  ] });
}
function QuestionDesignBody({ code, type: type2, t: t2, onMainLang, addAnswer, designMode }) {
  switch (type2) {
    case "video_display":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        VideoDisplayDesign,
        {
          code,
          t: t2,
          onMainLang
        },
        code
      );
    case "image_display":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ImageDisplayDesign$1,
        {
          code,
          t: t2,
          onMainLang
        },
        code
      );
    case "signature":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SignatureDesign$1, {});
    case "photo_capture":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PhotoCaptureDesign$1, { code });
    case "video_capture":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(VideoCaptureDesign$1, { code });
    case "date_time":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DateTimeQuestionDesign$1, { code }, code);
    case "date":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DateTimeQuestionDesign$1, { code }, code);
    case "time":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TimeQuestionDesign$1, { code }, code);
    case "scq":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ChoiceQuestion$1,
        {
          t: t2,
          designMode,
          onMainLang,
          addNewAnswer: addAnswer,
          code,
          type: "radio"
        },
        code
      );
    case "image_mcq":
    case "image_scq":
    case "image_ranking":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ImageChoiceQuestion$1,
        {
          t: t2,
          onMainLang,
          designMode,
          addNewAnswer: addAnswer,
          code
        },
        code
      );
    case "icon_scq":
    case "icon_mcq":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ImageChoiceQuestion$1,
        {
          icon: true,
          t: t2,
          onMainLang,
          designMode,
          addNewAnswer: addAnswer,
          code
        },
        code
      );
    case "scq_icon_array":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SCQIconArrayDesign$1,
        {
          onMainLang,
          type: type2,
          designMode,
          addNewAnswer: addAnswer,
          code,
          t: t2
        },
        code
      );
    case "scq_array":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SCQArray$1,
        {
          onMainLang,
          type: type2,
          designMode,
          addNewAnswer: addAnswer,
          code,
          t: t2
        },
        code
      );
    case "file_upload":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(FileUploadQuestionDesign$1, { code }, code);
    case "mcq":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ChoiceQuestion$1,
        {
          designMode,
          addNewAnswer: addAnswer,
          code,
          onMainLang,
          t: t2,
          type: "checkbox"
        },
        code
      );
    case "ranking":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ChoiceQuestion$1,
        {
          designMode,
          onMainLang,
          addNewAnswer: addAnswer,
          code,
          t: t2,
          type: "ranking"
        },
        code
      );
    case "nps":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(NPSDesign$1, { code }, code);
    case "number":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(NumberQuestionDesign$1, { code }, code);
    case "text":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TextQuestionDesign$1, { code }, code);
    case "paragraph":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ParagraphQuestionDesign$1, { t: t2, code }, code);
    case "barcode":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(BarcodeDesign$1, { t: t2, code }, code);
    case "email":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(EmailQuestionDesign$1, { code }, code);
    default:
      return "";
  }
}
const QuestionDesignBody$1 = React.memo(QuestionDesignBody);
function QuestionDesign({
  code,
  type: type2,
  isLast,
  parentCode,
  index: index2,
  t: t2,
  designMode,
  onMainLang,
  parentIndex
}) {
  console.debug(code + ": " + index2);
  const [hovered, setHovered] = reactExports.useState(false);
  const containerRef = reactExports.useRef();
  const dispatch = useDispatch();
  const theme = useTheme();
  const isInSetup = useSelector((state) => {
    var _a;
    return ((_a = state.designState.setup) == null ? void 0 : _a.code) == code;
  });
  const question = useSelector((state) => {
    return state.designState[code];
  });
  const children = question.children;
  const collapsed = useSelector((state) => {
    var _a;
    return ((_a = state.designState["globalSetup"]) == null ? void 0 : _a.reorder_setup) === "collapse_questions";
  });
  useSelector(
    (state) => !hasMajorSetup(state.designState.setup)
  );
  const onDelete = reactExports.useCallback(() => dispatch(deleteQuestion(code)), []);
  const onClone = reactExports.useCallback(() => dispatch(cloneQuestion(code)), []);
  const [isDragging2, drag, preview] = useDrag({
    type: "questions",
    item: {
      index: index2,
      draggableId: code,
      droppableId: parentCode,
      parentIndex,
      isLast,
      type: "questions",
      itemType: type2
    },
    collect: (monitor) => {
      var _a;
      return ((_a = monitor.getItem()) == null ? void 0 : _a.draggableId) === code;
    }
  });
  const [collectedProps, drop] = useDrop({
    accept: "questions",
    hover(item, monitor) {
      var _a;
      if (!containerRef.current || !monitor.isOver({ shallow: true }) || !item || !item.droppableId.startsWith("G")) {
        return;
      }
      const dragIndex = item.index;
      const hoverIndex = index2;
      if (dragIndex === hoverIndex || (item == null ? void 0 : item.droppableId) !== parentCode) {
        return;
      }
      const hoverBoundingRect = (_a = containerRef.current) == null ? void 0 : _a.getBoundingClientRect();
      const clientOffset = monitor.getClientOffset();
      if (dragIndex < hoverIndex && clientOffset.y < hoverBoundingRect.top + 20) {
        return;
      }
      if (dragIndex > hoverIndex && clientOffset.y > hoverBoundingRect.bottom - 20) {
        return;
      }
      dispatch(
        onDrag({
          type: "reorder_questions",
          source: item.droppableId,
          destination: parentCode,
          id: item.draggableId,
          fromIndex: dragIndex,
          toIndex: hoverIndex + 1
        })
      );
      item.index = hoverIndex;
      item.isLast = isLast;
    }
  });
  drop(preview(containerRef));
  const addAnswer = React.useCallback(
    (questionCode, questionType, type22) => {
      const answers = children || [];
      let nextAnswerIndex = 1;
      let code2 = "";
      let qualifiedCode = "";
      let label2 = "";
      const valueInstruction = {
        code: "value",
        isActive: false,
        returnType: {
          name: questionType == "ranking" || questionType == "nps" || questionType == "image_ranking" ? "Int" : questionType == "scq_array" || questionType == "scq_icon_array" ? "String" : "Boolean"
        },
        text: ""
      };
      switch (type22) {
        case "column":
          nextAnswerIndex = nextId(
            answers.filter((el) => el.type === "column")
          );
          label2 = "Col" + nextAnswerIndex;
          code2 = "Ac" + nextAnswerIndex;
          qualifiedCode = questionCode + code2;
          dispatch(
            addNewAnswer({ label: label2, answer: { code: code2, qualifiedCode, type: type22 } })
          );
          break;
        case "row":
          nextAnswerIndex = nextId(answers.filter((el) => el.type === "row"));
          code2 = "A" + nextAnswerIndex;
          label2 = "Row" + nextAnswerIndex;
          qualifiedCode = questionCode + code2;
          dispatch(
            addNewAnswer({
              label: label2,
              instructionList: [valueInstruction],
              answer: { code: code2, qualifiedCode, type: type22 }
            })
          );
          break;
        case "other":
          code2 = "Aother";
          label2 = "Other";
          qualifiedCode = questionCode + code2;
          const instructionListForText = [
            {
              code: "value",
              isActive: false,
              returnType: {
                name: "String"
              },
              text: ""
            },
            {
              code: "conditional_relevance",
              isActive: true,
              returnType: {
                name: "Boolean"
              },
              text: questionType === "scq" ? "".concat(questionCode, ".value === 'Aother'") : "".concat(questionCode, "Aother.value === true")
            }
          ];
          dispatch(
            addNewAnswer({
              label: label2,
              answer: { code: code2, qualifiedCode, type: type22 },
              instructionList: questionType == "mcq" ? [valueInstruction] : []
            })
          );
          dispatch(
            addNewAnswer({
              instructionList: instructionListForText,
              answer: {
                code: "Atext",
                qualifiedCode: qualifiedCode + "Atext",
                type: "other_text"
              }
            })
          );
          break;
        default:
          nextAnswerIndex = nextId(answers);
          code2 = "A" + nextAnswerIndex;
          label2 = "Option" + nextAnswerIndex;
          qualifiedCode = questionCode + code2;
          dispatch(
            addNewAnswer({
              label: label2,
              answer: { code: code2, qualifiedCode },
              instructionList: questionType == "mcq" || questionType == "image_mcq" || questionType == "icon_mcq" || questionType == "ranking" || questionType == "image_ranking" ? [valueInstruction] : []
            })
          );
          break;
      }
    },
    [children]
  );
  const contrastColor = getContrastColor(theme.palette.background.paper);
  const textColor = theme.textStyles.question.color;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      ref: containerRef,
      onMouseEnter: () => {
        setHovered(true);
      },
      onMouseLeave: () => {
        setHovered(false);
      },
      style: isInSetup ? {
        border: "0.5px solid ".concat(textColor),
        backgroundColor: contrastColor,
        color: textColor
      } : {
        opacity: isDragging2 ? "0.2" : "1",
        border: isDragging2 ? "dotted 1px " + contrastColor : "0"
      },
      className: "question ".concat(styles$H.groupQuestion),
      "data-code": code,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$H.contentContainer, children: [
          collapsed && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$H.moveBox, ref: drag, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$m, { style: { color: textColor } }) }),
          designMode == DESIGN_SURVEY_MODE.DESIGN && (isInSetup || hovered) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$H.actionToolbarVisible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            ActionToolbar$1,
            {
              t: t2,
              isGroup: false,
              isInSetup,
              code,
              parentCode,
              onClone,
              onDelete,
              disableDelete: false
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$H.titleContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: styles$H.iconBox, children: questionIconByType("".concat(type2), void 0, textColor) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: styles$H.titleQuestion,
              style: {
                fontFamily: theme.textStyles.question.font,
                color: theme.textStyles.question.color,
                fontSize: theme.textStyles.question.size
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                ContentEditor$2,
                {
                  code,
                  editable: designMode == DESIGN_SURVEY_MODE.DESIGN || designMode == DESIGN_SURVEY_MODE.LANGUAGES,
                  extended: false,
                  placeholder: t2("content_editor_placeholder_title"),
                  contentKey: "label"
                }
              )
            }
          )
        ] }),
        question.showDescription && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: styles$H.textDescriptionContent, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ContentEditor$2,
          {
            code,
            editable: designMode == DESIGN_SURVEY_MODE.DESIGN || designMode == DESIGN_SURVEY_MODE.LANGUAGES,
            extended: true,
            placeholder: t2("content_editor_placeholder_description"),
            contentKey: "description"
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collapse, { in: collapsed !== true, timeout: "auto", unmountOnExit: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          QuestionDesignBody$1,
          {
            code,
            type: type2,
            t: t2,
            addAnswer,
            designMode,
            onMainLang,
            addNewAnswer: addAnswer
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorDisplay$1, { code })
      ]
    }
  );
}
const QuestionDesign$1 = React.memo(QuestionDesign);
const textHeader = "_textHeader_17ofz_1";
const textDescription = "_textDescription_17ofz_5";
const groupCard = "_groupCard_17ofz_11";
const type = "_type_17ofz_18";
const groupType = "_groupType_17ofz_25";
const questionsOuterContainer = "_questionsOuterContainer_17ofz_33";
const questionsInnerContainer = "_questionsInnerContainer_17ofz_37";
const groupDesignError = "_groupDesignError_17ofz_43";
const groupHeader = "_groupHeader_17ofz_48";
const inputGroupTitle = "_inputGroupTitle_17ofz_52";
const inputGroupDescription = "_inputGroupDescription_17ofz_57";
const moveBox = "_moveBox_17ofz_62";
const topLevel = "_topLevel_17ofz_71";
const groupText = "_groupText_17ofz_83";
const actionToolbarVisible = "_actionToolbarVisible_17ofz_101";
const fadeInMoveRight = "_fadeInMoveRight_17ofz_1";
const contentContainer = "_contentContainer_17ofz_105";
const headerContent = "_headerContent_17ofz_116";
const styles$k = {
  textHeader,
  textDescription,
  groupCard,
  type,
  groupType,
  questionsOuterContainer,
  questionsInnerContainer,
  groupDesignError,
  groupHeader,
  inputGroupTitle,
  inputGroupDescription,
  moveBox,
  topLevel,
  groupText,
  actionToolbarVisible,
  fadeInMoveRight,
  contentContainer,
  headerContent
};
const groupDropArea = "_groupDropArea_1m6hh_1";
const groupDragging = "_groupDragging_1m6hh_24";
const questionDropArea = "_questionDropArea_1m6hh_45";
const groupDropAreaWrapper = "_groupDropAreaWrapper_1m6hh_72";
const hide = "_hide_1m6hh_79";
const hidden = "_hidden_1m6hh_83";
const isDragging = "_isDragging_1m6hh_92";
const groupHidden = "_groupHidden_1m6hh_104";
const groupEmptyHint = "_groupEmptyHint_1m6hh_111";
const groupEmptyHintHover = "_groupEmptyHintHover_1m6hh_130";
const dropText = "_dropText_1m6hh_134";
const styles$j = {
  groupDropArea,
  groupDragging,
  questionDropArea,
  groupDropAreaWrapper,
  hide,
  hidden,
  isDragging,
  groupHidden,
  groupEmptyHint,
  groupEmptyHintHover,
  dropText
};
var observerMap = /* @__PURE__ */ new Map();
var RootIds = /* @__PURE__ */ new WeakMap();
var rootId = 0;
var unsupportedValue = void 0;
function getRootId(root2) {
  if (!root2) return "0";
  if (RootIds.has(root2)) return RootIds.get(root2);
  rootId += 1;
  RootIds.set(root2, rootId.toString());
  return RootIds.get(root2);
}
function optionsToId(options) {
  return Object.keys(options).sort().filter(
    (key) => options[key] !== void 0
  ).map((key) => {
    return "".concat(key, "_").concat(key === "root" ? getRootId(options.root) : options[key]);
  }).toString();
}
function createObserver(options) {
  const id2 = optionsToId(options);
  let instance2 = observerMap.get(id2);
  if (!instance2) {
    const elements = /* @__PURE__ */ new Map();
    let thresholds2;
    const observer = new IntersectionObserver((entries3) => {
      entries3.forEach((entry) => {
        var _a;
        const inView = entry.isIntersecting && thresholds2.some((threshold) => entry.intersectionRatio >= threshold);
        if (options.trackVisibility && typeof entry.isVisible === "undefined") {
          entry.isVisible = inView;
        }
        (_a = elements.get(entry.target)) == null ? void 0 : _a.forEach((callback) => {
          callback(inView, entry);
        });
      });
    }, options);
    thresholds2 = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
    instance2 = {
      id: id2,
      observer,
      elements
    };
    observerMap.set(id2, instance2);
  }
  return instance2;
}
function observe(element, callback, options = {}, fallbackInView = unsupportedValue) {
  if (typeof window.IntersectionObserver === "undefined" && fallbackInView !== void 0) {
    const bounds = element.getBoundingClientRect();
    callback(fallbackInView, {
      isIntersecting: fallbackInView,
      target: element,
      intersectionRatio: typeof options.threshold === "number" ? options.threshold : 0,
      time: 0,
      boundingClientRect: bounds,
      intersectionRect: bounds,
      rootBounds: bounds
    });
    return () => {
    };
  }
  const { id: id2, observer, elements } = createObserver(options);
  const callbacks = elements.get(element) || [];
  if (!elements.has(element)) {
    elements.set(element, callbacks);
  }
  callbacks.push(callback);
  observer.observe(element);
  return function unobserve() {
    callbacks.splice(callbacks.indexOf(callback), 1);
    if (callbacks.length === 0) {
      elements.delete(element);
      observer.unobserve(element);
    }
    if (elements.size === 0) {
      observer.disconnect();
      observerMap.delete(id2);
    }
  };
}
function useInView({
  threshold,
  delay,
  trackVisibility,
  rootMargin,
  root: root2,
  triggerOnce,
  skip: skip3,
  initialInView,
  fallbackInView,
  onChange
} = {}) {
  var _a;
  const [ref2, setRef2] = reactExports.useState(null);
  const callback = reactExports.useRef();
  const [state, setState] = reactExports.useState({
    inView: !!initialInView,
    entry: void 0
  });
  callback.current = onChange;
  reactExports.useEffect(
    () => {
      if (skip3 || !ref2) return;
      let unobserve;
      unobserve = observe(
        ref2,
        (inView, entry) => {
          setState({
            inView,
            entry
          });
          if (callback.current) callback.current(inView, entry);
          if (entry.isIntersecting && triggerOnce && unobserve) {
            unobserve();
            unobserve = void 0;
          }
        },
        {
          root: root2,
          rootMargin,
          threshold,
          // @ts-ignore
          trackVisibility,
          // @ts-ignore
          delay
        },
        fallbackInView
      );
      return () => {
        if (unobserve) {
          unobserve();
        }
      };
    },
    // We break the rule here, because we aren't including the actual `threshold` variable
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      // If the threshold is an array, convert it to a string, so it won't change between renders.
      Array.isArray(threshold) ? threshold.toString() : threshold,
      ref2,
      root2,
      rootMargin,
      triggerOnce,
      skip3,
      trackVisibility,
      fallbackInView,
      delay
    ]
  );
  const entryTarget = (_a = state.entry) == null ? void 0 : _a.target;
  const previousEntryTarget = reactExports.useRef();
  if (!ref2 && entryTarget && !triggerOnce && !skip3 && previousEntryTarget.current !== entryTarget) {
    previousEntryTarget.current = entryTarget;
    setState({
      inView: !!initialInView,
      entry: void 0
    });
  }
  const result = [setRef2, state.inView, state.entry];
  result.ref = result[0];
  result.inView = result[1];
  result.entry = result[2];
  return result;
}
function GroupDropArea({ index: index2, groupsCount, t: t2, emptySurvey }) {
  const dispatch = useDispatch();
  const [{ isOver, item }, drop] = useDrop(
    () => ({
      accept: "groups",
      drop: (item2) => {
        dispatch(
          onDrag({
            type: "new_group",
            groupType: item2.draggableId,
            toIndex: index2
          })
        );
      },
      collect: (monitor) => ({
        isOver: monitor.isOver(),
        item: monitor.getItem()
      })
    }),
    [index2]
  );
  const isDraggingGroup = item != null && item.draggableId == "group";
  const canDrop = item && item.droppableId == "new-groups" && canDropWelcomeGroup(item, index2) && canDropEndGroup(item, index2, groupsCount) && canSortGroup(item, index2);
  const theme = useTheme$1();
  const contrastColor = getContrastColor(theme.palette.background.paper);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      ref: drop,
      style: {
        backgroundColor: isDraggingGroup && contrastColor,
        color: theme.palette.text.primary
      },
      className: "" + (emptySurvey ? styles$j.groupEmptyHint + (isOver ? " " + styles$j.groupEmptyHintHover : "") : isOver && canDrop ? styles$j.groupDropArea : isDraggingGroup ? styles$j.groupDragging : styles$j.groupHidden),
      children: [
        isDraggingGroup && !emptySurvey && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.dropText, children: t2("empty_survey_hint") }) }),
        emptySurvey && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("empty_survey_hint") })
      ]
    }
  );
}
function QuestionDropArea({
  index: index2,
  isLast = false,
  parentCode,
  parentType,
  parentIndex,
  emptyGroup = false,
  t: t2
}) {
  const theme = useTheme$1();
  const dispatch = useDispatch();
  const reorderRefreshCode = useSelector((state) => {
    return state.designState["reorder_refresh_code"];
  });
  const [{ isOver, isDragging: isDragging2 }, drop] = useDrop(
    () => ({
      accept: ["new-questions", "questions"],
      hover(item) {
        if (item.type !== "questions" || item.droppableId === parentCode) {
          return;
        }
        if (parentType === "end" && !isDisplay(item.itemType)) {
          return;
        }
        dispatch(
          onDrag({
            type: "reparent_question",
            source: item.droppableId,
            destination: parentCode,
            id: item.draggableId
          })
        );
        item.index = index2;
        item.parentIndex = parentIndex;
        item.isLast = isLast;
        item.droppableId = parentCode;
      },
      drop: (item) => {
        if (item.type !== "new-questions") {
          return;
        }
        dispatch(
          onDrag({
            type: "new_question",
            questionType: item.draggableId,
            destination: parentCode,
            toIndex: index2
          })
        );
      },
      collect: (monitor) => {
        var _a, _b, _c, _d, _e;
        return {
          isOver: ((_a = monitor.getItem()) == null ? void 0 : _a.type) == "new-questions" && monitor.isOver() && (parentType !== "end" || isDisplay((_b = monitor.getItem()) == null ? void 0 : _b.itemType)),
          isDragging: parentType === "end" && !isDisplay((_c = monitor.getItem()) == null ? void 0 : _c.itemType) ? false : ((_d = monitor.getItem()) == null ? void 0 : _d.droppableId) === "new-questions" || ((_e = monitor.getItem()) == null ? void 0 : _e.type) === "questions" && monitor.getItem().droppableId !== parentCode && (index2 == 0 && monitor.getItem().isLast && monitor.getItem().parentIndex + 1 === parentIndex || isLast && monitor.getItem().index == 0 && monitor.getItem().parentIndex - 1 === parentIndex)
        };
      }
    }),
    [reorderRefreshCode, index2]
  );
  const { ref: ref2, inView, entry } = useInView({
    /* Optional options */
    threshold: 0,
    trackVisibility: isDragging2,
    delay: isDragging2 ? 100 : 0
  });
  const textContrast = theme.palette.text.primary;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: ref2, children: [
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        ref: drop,
        style: {
          marginTop: !isDragging2 && !isOver ? "0rem" : "inherit",
          marginBottom: !isDragging2 && !isOver ? "0rem" : "inherit"
        },
        className: "question-drop-area " + (emptyGroup ? isOver ? styles$j.questionDropArea : isDragging2 && inView ? styles$j.isDragging : styles$j.groupEmptyHint : isOver ? styles$j.questionDropArea : isDragging2 && inView ? styles$j.isDragging : styles$j.hidden) + " ",
        children: [
          isDragging2 && !emptyGroup && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { display: "flex", justifyContent: "center", alignItems: "center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(HelpOutline, { sx: { marginRight: "8px", color: textContrast } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: styles$j.dropText,
                style: {
                  color: textContrast
                },
                children: t2("empty_group_hint")
              }
            )
          ] }),
          emptyGroup && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { display: "flex", justifyContent: "center", alignItems: "center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(HelpOutline, { sx: { marginRight: "8px", color: textContrast } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: styles$j.dropText,
                style: {
                  color: textContrast
                },
                children: t2("empty_group_hint")
              }
            )
          ] })
        ]
      }
    )
  ] });
}
const canSortGroup = (item, index2) => {
  if ((item == null ? void 0 : item.index) === index2 || index2 - 1 === (item == null ? void 0 : item.index)) {
    if ((item == null ? void 0 : item.droppableId) !== "new-groups") {
      return false;
    }
  }
  return true;
};
const canDropWelcomeGroup = (item, index2) => {
  if ((item == null ? void 0 : item.draggableId) !== "welcome") {
    return true;
  }
  return index2 === 0;
};
const canDropEndGroup = (item, index2, groupsCount) => {
  if ((item == null ? void 0 : item.draggableId) !== "end") {
    return true;
  }
  return index2 === groupsCount;
};
function GroupHeader({ t: t2, code, children, designMode }) {
  console.debug("Group Header: " + code);
  const dispatch = useDispatch();
  const langInfo = useSelector((state) => {
    return state.designState.langInfo;
  });
  const onMainLang = langInfo.onMainLang;
  const group3 = useSelector((state) => {
    return state.designState[code];
  });
  const theme = useTheme();
  const inDesgin = designMode == DESIGN_SURVEY_MODE.DESIGN;
  const onDelete = reactExports.useCallback(() => dispatch(deleteGroup(code)), [code]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: styles$k.headerContent, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$k.groupHeader, "data-code": code, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: styles$k.contentContainer, children: inDesgin && onMainLang && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$k.actionToolbarVisible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ActionToolbar$1,
      {
        code,
        t: t2,
        isGroup: true,
        onDelete,
        disableDelete: children && children.length > 0
      }
    ) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: styles$k.textHeader,
        style: {
          fontFamily: theme.textStyles.group.font,
          color: theme.textStyles.group.color,
          fontSize: theme.textStyles.group.size
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ContentEditor$2,
          {
            editable: designMode == DESIGN_SURVEY_MODE.DESIGN || designMode == DESIGN_SURVEY_MODE.LANGUAGES,
            code,
            extended: false,
            contentKey: "label",
            placeholder: t2("content_editor_placeholder_title")
          }
        )
      }
    ),
    group3.showDescription && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: styles$k.textDescription, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ContentEditor$2,
      {
        editable: designMode == DESIGN_SURVEY_MODE.DESIGN || designMode == DESIGN_SURVEY_MODE.LANGUAGES,
        code,
        extended: true,
        contentKey: "description",
        placeholder: t2("content_editor_placeholder_description")
      }
    ) }),
    onMainLang && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorDisplay$1, { type: "group", code })
  ] }) });
}
const GroupHeader$1 = React.memo(GroupHeader);
function GroupDesign({ t: t2, code, index: index2, designMode }) {
  const dispatch = useDispatch();
  const group3 = useSelector((state) => {
    return state.designState[code];
  });
  const inDesign2 = designMode == DESIGN_SURVEY_MODE.DESIGN;
  const collapsed = useSelector((state) => {
    var _a;
    return ((_a = state.designState["globalSetup"]) == null ? void 0 : _a.reorder_setup) === "collapse_groups";
  });
  const langInfo = useSelector((state) => {
    return state.designState.langInfo;
  });
  const isInSetup = useSelector((state) => {
    var _a;
    return ((_a = state.designState.setup) == null ? void 0 : _a.code) == code;
  });
  const theme = useTheme$1();
  const containerRef = reactExports.useRef();
  const [isDragging2, drag, preview] = useDrag({
    type: "groups",
    item: () => {
      return {
        index: index2,
        draggableId: code,
        droppableId: "groups",
        type: "groups"
      };
    },
    collect: (monitor) => {
      var _a;
      return ((_a = monitor.getItem()) == null ? void 0 : _a.draggableId) === code;
    }
  });
  const [collectedProps, drop] = useDrop({
    accept: "groups",
    hover(item, monitor) {
      var _a;
      if (!containerRef.current || type2 == "welcome" || type2 == "end" || !monitor.isOver({ shallow: true }) || !item || item.droppableId != "groups") {
        return;
      }
      const dragIndex = item.index;
      const hoverIndex = index2;
      if (dragIndex === hoverIndex) {
        return;
      }
      const hoverBoundingRect = (_a = containerRef.current) == null ? void 0 : _a.getBoundingClientRect();
      const clientOffset = monitor.getClientOffset();
      if (dragIndex < hoverIndex && clientOffset.y < hoverBoundingRect.top + 50) {
        return;
      }
      if (dragIndex > hoverIndex && clientOffset.y > hoverBoundingRect.bottom - 50) {
        return;
      }
      dispatch(
        onDrag({
          type: "reorder_groups",
          id: item.draggableId,
          fromIndex: dragIndex,
          toIndex: hoverIndex
        })
      );
      item.index = hoverIndex;
    }
  });
  langInfo.onMainLang;
  const type2 = group3 == null ? void 0 : group3.groupType.toLowerCase();
  const children = group3 == null ? void 0 : group3.children;
  const getStyles = (isDragging22) => {
    const styles2 = {
      transition: "all 500ms"
    };
    if (isDragging22) {
      styles2.opacity = 0.2;
    }
    return styles2;
  };
  drop(preview(containerRef));
  const contrastColor = getContrastColor(theme.palette.background.paper);
  const textColor = theme.textStyles.question.color;
  if (!group3) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: isInSetup ? {
        border: "0.5px solid ".concat(textColor),
        color: textColor,
        backgroundColor: contrastColor
      } : {
        backgroundColor: "background.paper"
      },
      className: styles$k.topLevel,
      ref: containerRef,
      style: getStyles(isDragging2),
      children: [
        collapsed == true && type2 !== "welcome" && type2 !== "end" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$k.moveBox, ref: drag, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$m, { style: { color: textColor } }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(GroupHeader$1, { t: t2, code, index: index2, designMode, children }),
        collapsed !== true && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          children && children.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            QuestionDropArea,
            {
              index: 0,
              parentCode: code,
              parentType: type2,
              parentIndex: index2,
              t: t2
            }
          ),
          children == null ? void 0 : children.map((quest, childIndex) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                QuestionDesign$1,
                {
                  t: t2,
                  parentCode: code,
                  parentIndex: index2,
                  index: childIndex,
                  isLast: children.length == childIndex + 1,
                  type: quest.type,
                  code: quest.code,
                  designMode,
                  onMainLang: inDesign2
                },
                quest.code
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                QuestionDropArea,
                {
                  isLast: children.length == childIndex + 1,
                  index: childIndex + 1,
                  parentIndex: index2,
                  parentCode: code,
                  parentType: type2,
                  t: t2
                }
              )
            ] }, quest.code);
          }),
          (!children || !children.length) && inDesign2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            QuestionDropArea,
            {
              t: t2,
              index: 0,
              parentCode: code,
              parentType: type2,
              emptyGroup: true
            }
          )
        ] })
      ]
    }
  );
}
const GroupDesign$1 = React.memo(GroupDesign);
const PUBLISH = 0;
const SUBSCRIBE = 1;
const RESET = 2;
const VALUE = 4;
function compose(a2, b) {
  return (arg) => a2(b(arg));
}
function thrush(arg, proc) {
  return proc(arg);
}
function curry2to1(proc, arg1) {
  return (arg2) => proc(arg1, arg2);
}
function curry1to0(proc, arg) {
  return () => proc(arg);
}
function tap(arg, proc) {
  proc(arg);
  return arg;
}
function tup(...args) {
  return args;
}
function call(proc) {
  proc();
}
function always(value) {
  return () => value;
}
function joinProc(...procs) {
  return () => {
    procs.map(call);
  };
}
function isDefined(arg) {
  return arg !== void 0;
}
function noop$1() {
}
function subscribe(emitter, subscription) {
  return emitter(SUBSCRIBE, subscription);
}
function publish(publisher, value) {
  publisher(PUBLISH, value);
}
function reset(emitter) {
  emitter(RESET);
}
function getValue$1(depot) {
  return depot(VALUE);
}
function connect(emitter, publisher) {
  return subscribe(emitter, curry2to1(publisher, PUBLISH));
}
function handleNext(emitter, subscription) {
  const unsub = emitter(SUBSCRIBE, (value) => {
    unsub();
    subscription(value);
  });
  return unsub;
}
function stream() {
  const subscriptions = [];
  return (action2, arg) => {
    switch (action2) {
      case RESET:
        subscriptions.splice(0, subscriptions.length);
        return;
      case SUBSCRIBE:
        subscriptions.push(arg);
        return () => {
          const indexOf3 = subscriptions.indexOf(arg);
          if (indexOf3 > -1) {
            subscriptions.splice(indexOf3, 1);
          }
        };
      case PUBLISH:
        subscriptions.slice().forEach((subscription) => {
          subscription(arg);
        });
        return;
      default:
        throw new Error("unrecognized action ".concat(action2));
    }
  };
}
function statefulStream(initial) {
  let value = initial;
  const innerSubject = stream();
  return (action2, arg) => {
    switch (action2) {
      case SUBSCRIBE:
        const subscription = arg;
        subscription(value);
        break;
      case PUBLISH:
        value = arg;
        break;
      case VALUE:
        return value;
    }
    return innerSubject(action2, arg);
  };
}
function eventHandler(emitter) {
  let unsub;
  let currentSubscription;
  const cleanup = () => unsub && unsub();
  return function(action2, subscription) {
    switch (action2) {
      case SUBSCRIBE:
        if (subscription) {
          if (currentSubscription === subscription) {
            return;
          }
          cleanup();
          currentSubscription = subscription;
          unsub = subscribe(emitter, subscription);
          return unsub;
        } else {
          cleanup();
          return noop$1;
        }
      case RESET:
        cleanup();
        currentSubscription = null;
        return;
      default:
        throw new Error("unrecognized action ".concat(action2));
    }
  };
}
function streamFromEmitter(emitter) {
  return tap(stream(), (stream2) => connect(emitter, stream2));
}
function statefulStreamFromEmitter(emitter, initial) {
  return tap(statefulStream(initial), (stream2) => connect(emitter, stream2));
}
function combineOperators(...operators2) {
  return (subscriber) => {
    return operators2.reduceRight(thrush, subscriber);
  };
}
function pipe(source, ...operators2) {
  const project = combineOperators(...operators2);
  return (action2, subscription) => {
    switch (action2) {
      case SUBSCRIBE:
        return subscribe(source, project(subscription));
      case RESET:
        reset(source);
        return;
    }
  };
}
function defaultComparator$1(previous, next) {
  return previous === next;
}
function distinctUntilChanged(comparator = defaultComparator$1) {
  let current;
  return (done) => (next) => {
    if (!comparator(current, next)) {
      current = next;
      done(next);
    }
  };
}
function filter(predicate) {
  return (done) => (value) => {
    predicate(value) && done(value);
  };
}
function map$3(project) {
  return (done) => compose(done, project);
}
function mapTo(value) {
  return (done) => () => done(value);
}
function scan(scanner, initial) {
  return (done) => (value) => done(initial = scanner(initial, value));
}
function skip(times) {
  return (done) => (value) => {
    times > 0 ? times-- : done(value);
  };
}
function throttleTime(interval) {
  let currentValue = null;
  let timeout;
  return (done) => (value) => {
    currentValue = value;
    if (timeout) {
      return;
    }
    timeout = setTimeout(() => {
      timeout = void 0;
      done(currentValue);
    }, interval);
  };
}
function debounceTime(interval) {
  let currentValue;
  let timeout;
  return (done) => (value) => {
    currentValue = value;
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      done(currentValue);
    }, interval);
  };
}
function withLatestFrom(...sources) {
  const values2 = new Array(sources.length);
  let called = 0;
  let pendingCall = null;
  const allCalled = Math.pow(2, sources.length) - 1;
  sources.forEach((source, index2) => {
    const bit = Math.pow(2, index2);
    subscribe(source, (value) => {
      const prevCalled = called;
      called = called | bit;
      values2[index2] = value;
      if (prevCalled !== allCalled && called === allCalled && pendingCall) {
        pendingCall();
        pendingCall = null;
      }
    });
  });
  return (done) => (value) => {
    const call2 = () => done([value].concat(values2));
    if (called === allCalled) {
      call2();
    } else {
      pendingCall = call2;
    }
  };
}
function merge$4(...sources) {
  return function(action2, subscription) {
    switch (action2) {
      case SUBSCRIBE:
        return joinProc(...sources.map((source) => subscribe(source, subscription)));
      case RESET:
        return;
      default:
        throw new Error("unrecognized action ".concat(action2));
    }
  };
}
function duc(source, comparator = defaultComparator$1) {
  return pipe(source, distinctUntilChanged(comparator));
}
function combineLatest(...emitters) {
  const innerSubject = stream();
  const values2 = new Array(emitters.length);
  let called = 0;
  const allCalled = Math.pow(2, emitters.length) - 1;
  emitters.forEach((source, index2) => {
    const bit = Math.pow(2, index2);
    subscribe(source, (value) => {
      values2[index2] = value;
      called = called | bit;
      if (called === allCalled) {
        publish(innerSubject, values2);
      }
    });
  });
  return function(action2, subscription) {
    switch (action2) {
      case SUBSCRIBE:
        if (called === allCalled) {
          subscription(values2);
        }
        return subscribe(innerSubject, subscription);
      case RESET:
        return reset(innerSubject);
      default:
        throw new Error("unrecognized action ".concat(action2));
    }
  };
}
function system(constructor, dependencies2 = [], { singleton } = { singleton: true }) {
  return {
    id: id(),
    constructor,
    dependencies: dependencies2,
    singleton
  };
}
const id = () => Symbol();
function init(systemSpec) {
  const singletons = /* @__PURE__ */ new Map();
  const _init = ({ id: id2, constructor, dependencies: dependencies2, singleton }) => {
    if (singleton && singletons.has(id2)) {
      return singletons.get(id2);
    }
    const system2 = constructor(dependencies2.map((e2) => _init(e2)));
    if (singleton) {
      singletons.set(id2, system2);
    }
    return system2;
  };
  return _init(systemSpec);
}
function omit$3(keys4, obj) {
  const result = {};
  const index2 = {};
  let idx = 0;
  const len = keys4.length;
  while (idx < len) {
    index2[keys4[idx]] = 1;
    idx += 1;
  }
  for (const prop in obj) {
    if (!index2.hasOwnProperty(prop)) {
      result[prop] = obj[prop];
    }
  }
  return result;
}
const useIsomorphicLayoutEffect$1 = typeof document !== "undefined" ? React.useLayoutEffect : React.useEffect;
function systemToComponent(systemSpec, map22, Root) {
  const requiredPropNames = Object.keys(map22.required || {});
  const optionalPropNames = Object.keys(map22.optional || {});
  const methodNames = Object.keys(map22.methods || {});
  const eventNames = Object.keys(map22.events || {});
  const Context = React.createContext({});
  function applyPropsToSystem(system2, props) {
    if (system2["propsReady"]) {
      publish(system2["propsReady"], false);
    }
    for (const requiredPropName of requiredPropNames) {
      const stream2 = system2[map22.required[requiredPropName]];
      publish(stream2, props[requiredPropName]);
    }
    for (const optionalPropName of optionalPropNames) {
      if (optionalPropName in props) {
        const stream2 = system2[map22.optional[optionalPropName]];
        publish(stream2, props[optionalPropName]);
      }
    }
    if (system2["propsReady"]) {
      publish(system2["propsReady"], true);
    }
  }
  function buildMethods(system2) {
    return methodNames.reduce((acc, methodName) => {
      acc[methodName] = (value) => {
        const stream2 = system2[map22.methods[methodName]];
        publish(stream2, value);
      };
      return acc;
    }, {});
  }
  function buildEventHandlers(system2) {
    return eventNames.reduce((handlers, eventName) => {
      handlers[eventName] = eventHandler(system2[map22.events[eventName]]);
      return handlers;
    }, {});
  }
  const Component = React.forwardRef((propsWithChildren, ref2) => {
    const { children, ...props } = propsWithChildren;
    const [system2] = React.useState(() => {
      return tap(init(systemSpec), (system22) => applyPropsToSystem(system22, props));
    });
    const [handlers] = React.useState(curry1to0(buildEventHandlers, system2));
    useIsomorphicLayoutEffect$1(() => {
      for (const eventName of eventNames) {
        if (eventName in props) {
          subscribe(handlers[eventName], props[eventName]);
        }
      }
      return () => {
        Object.values(handlers).map(reset);
      };
    }, [props, handlers, system2]);
    useIsomorphicLayoutEffect$1(() => {
      applyPropsToSystem(system2, props);
    });
    React.useImperativeHandle(ref2, always(buildMethods(system2)));
    const RootComponent = Root;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value: system2, children: Root ? /* @__PURE__ */ jsxRuntimeExports.jsx(RootComponent, { ...omit$3([...requiredPropNames, ...optionalPropNames, ...eventNames], props), children }) : children });
  });
  const usePublisher2 = (key) => {
    return React.useCallback(curry2to1(publish, React.useContext(Context)[key]), [key]);
  };
  const useEmitterValue18 = (key) => {
    const system2 = React.useContext(Context);
    const source = system2[key];
    const cb = React.useCallback(
      (c2) => {
        return subscribe(source, c2);
      },
      [source]
    );
    return React.useSyncExternalStore(
      cb,
      () => getValue$1(source),
      () => getValue$1(source)
    );
  };
  const useEmitterValueLegacy = (key) => {
    const system2 = React.useContext(Context);
    const source = system2[key];
    const [value, setValue4] = React.useState(curry1to0(getValue$1, source));
    useIsomorphicLayoutEffect$1(
      () => subscribe(source, (next) => {
        if (next !== value) {
          setValue4(always(next));
        }
      }),
      [source, value]
    );
    return value;
  };
  const useEmitterValue2 = React.version.startsWith("18") ? useEmitterValue18 : useEmitterValueLegacy;
  const useEmitter2 = (key, callback) => {
    const context2 = React.useContext(Context);
    const source = context2[key];
    useIsomorphicLayoutEffect$1(() => subscribe(source, callback), [callback, source]);
  };
  return {
    Component,
    usePublisher: usePublisher2,
    useEmitterValue: useEmitterValue2,
    useEmitter: useEmitter2
  };
}
const useIsomorphicLayoutEffect = typeof document !== "undefined" ? React.useLayoutEffect : React.useEffect;
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  return LogLevel2;
})(LogLevel || {});
const CONSOLE_METHOD_MAP = {
  [
    0
    /* DEBUG */
  ]: "debug",
  [
    1
    /* INFO */
  ]: "log",
  [
    2
    /* WARN */
  ]: "warn",
  [
    3
    /* ERROR */
  ]: "error"
};
const getGlobalThis = () => typeof globalThis === "undefined" ? window : globalThis;
const loggerSystem = system(
  () => {
    const logLevel = statefulStream(
      3
      /* ERROR */
    );
    const log = statefulStream((label2, message, level = 1) => {
      var _a;
      const currentLevel = (_a = getGlobalThis()["VIRTUOSO_LOG_LEVEL"]) != null ? _a : getValue$1(logLevel);
      if (level >= currentLevel) {
        console[CONSOLE_METHOD_MAP[level]](
          "%creact-virtuoso: %c%s %o",
          "color: #0253b3; font-weight: bold",
          "color: initial",
          label2,
          message
        );
      }
    });
    return {
      log,
      logLevel
    };
  },
  [],
  { singleton: true }
);
function useSizeWithElRef(callback, enabled, skipAnimationFrame) {
  const ref2 = React.useRef(null);
  let callbackRef = (_el) => {
  };
  if (typeof ResizeObserver !== "undefined") {
    const observer = React.useMemo(() => {
      return new ResizeObserver((entries3) => {
        const code = () => {
          const element = entries3[0].target;
          if (element.offsetParent !== null) {
            callback(element);
          }
        };
        skipAnimationFrame ? code() : requestAnimationFrame(code);
      });
    }, [callback]);
    callbackRef = (elRef) => {
      if (elRef && enabled) {
        observer.observe(elRef);
        ref2.current = elRef;
      } else {
        if (ref2.current) {
          observer.unobserve(ref2.current);
        }
        ref2.current = null;
      }
    };
  }
  return { ref: ref2, callbackRef };
}
function useSize(callback, enabled, skipAnimationFrame) {
  return useSizeWithElRef(callback, enabled, skipAnimationFrame).callbackRef;
}
function useChangedListContentsSizes(callback, itemSize, enabled, scrollContainerStateCallback, log, gap, customScrollParent, horizontalDirection, skipAnimationFrame) {
  const memoedCallback = React.useCallback(
    (el) => {
      const ranges = getChangedChildSizes(el.children, itemSize, horizontalDirection ? "offsetWidth" : "offsetHeight", log);
      let scrollableElement = el.parentElement;
      while (!scrollableElement.dataset["virtuosoScroller"]) {
        scrollableElement = scrollableElement.parentElement;
      }
      const windowScrolling = scrollableElement.lastElementChild.dataset["viewportType"] === "window";
      const scrollTop = customScrollParent ? horizontalDirection ? customScrollParent.scrollLeft : customScrollParent.scrollTop : windowScrolling ? horizontalDirection ? window.pageXOffset || document.documentElement.scrollLeft : window.pageYOffset || document.documentElement.scrollTop : horizontalDirection ? scrollableElement.scrollLeft : scrollableElement.scrollTop;
      const scrollHeight = customScrollParent ? horizontalDirection ? customScrollParent.scrollWidth : customScrollParent.scrollHeight : windowScrolling ? horizontalDirection ? document.documentElement.scrollWidth : document.documentElement.scrollHeight : horizontalDirection ? scrollableElement.scrollWidth : scrollableElement.scrollHeight;
      const viewportHeight = customScrollParent ? horizontalDirection ? customScrollParent.offsetWidth : customScrollParent.offsetHeight : windowScrolling ? horizontalDirection ? window.innerWidth : window.innerHeight : horizontalDirection ? scrollableElement.offsetWidth : scrollableElement.offsetHeight;
      scrollContainerStateCallback({
        scrollTop: Math.max(scrollTop, 0),
        scrollHeight,
        viewportHeight
      });
      gap == null ? void 0 : gap(
        horizontalDirection ? resolveGapValue$1("column-gap", getComputedStyle(el).columnGap, log) : resolveGapValue$1("row-gap", getComputedStyle(el).rowGap, log)
      );
      if (ranges !== null) {
        callback(ranges);
      }
    },
    [callback, itemSize, log, gap, customScrollParent, scrollContainerStateCallback]
  );
  return useSizeWithElRef(memoedCallback, enabled, skipAnimationFrame);
}
function getChangedChildSizes(children, itemSize, field, log) {
  const length = children.length;
  if (length === 0) {
    return null;
  }
  const results = [];
  for (let i2 = 0; i2 < length; i2++) {
    const child = children.item(i2);
    if (!child || child.dataset.index === void 0) {
      continue;
    }
    const index2 = parseInt(child.dataset.index);
    const knownSize = parseFloat(child.dataset.knownSize);
    const size = itemSize(child, field);
    if (size === 0) {
      log("Zero-sized element, this should not happen", { child }, LogLevel.ERROR);
    }
    if (size === knownSize) {
      continue;
    }
    const lastResult = results[results.length - 1];
    if (results.length === 0 || lastResult.size !== size || lastResult.endIndex !== index2 - 1) {
      results.push({ startIndex: index2, endIndex: index2, size });
    } else {
      results[results.length - 1].endIndex++;
    }
  }
  return results;
}
function resolveGapValue$1(property2, value, log) {
  if (value !== "normal" && !(value == null ? void 0 : value.endsWith("px"))) {
    log("".concat(property2, " was not resolved to pixel value correctly"), value, LogLevel.WARN);
  }
  if (value === "normal") {
    return 0;
  }
  return parseInt(value != null ? value : "0", 10);
}
function correctItemSize(el, dimension) {
  return Math.round(el.getBoundingClientRect()[dimension]);
}
function approximatelyEqual(num1, num2) {
  return Math.abs(num1 - num2) < 1.01;
}
function useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, scrollerElement, scrollerRefCallback = noop$1, customScrollParent, horizontalDirection) {
  const scrollerRef = React.useRef(null);
  const scrollTopTarget = React.useRef(null);
  const timeoutRef = React.useRef(null);
  const handler = React.useCallback(
    (ev) => {
      const el = ev.target;
      const windowScroll = el === window || el === document;
      const scrollTop = horizontalDirection ? windowScroll ? window.pageXOffset || document.documentElement.scrollLeft : el.scrollLeft : windowScroll ? window.pageYOffset || document.documentElement.scrollTop : el.scrollTop;
      const scrollHeight = horizontalDirection ? windowScroll ? document.documentElement.scrollWidth : el.scrollWidth : windowScroll ? document.documentElement.scrollHeight : el.scrollHeight;
      const viewportHeight = horizontalDirection ? windowScroll ? window.innerWidth : el.offsetWidth : windowScroll ? window.innerHeight : el.offsetHeight;
      const call2 = () => {
        scrollContainerStateCallback({
          scrollTop: Math.max(scrollTop, 0),
          scrollHeight,
          viewportHeight
        });
      };
      if (ev.suppressFlushSync) {
        call2();
      } else {
        ReactDOM.flushSync(call2);
      }
      if (scrollTopTarget.current !== null) {
        if (scrollTop === scrollTopTarget.current || scrollTop <= 0 || scrollTop === scrollHeight - viewportHeight) {
          scrollTopTarget.current = null;
          smoothScrollTargetReached(true);
          if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
            timeoutRef.current = null;
          }
        }
      }
    },
    [scrollContainerStateCallback, smoothScrollTargetReached]
  );
  React.useEffect(() => {
    const localRef = customScrollParent ? customScrollParent : scrollerRef.current;
    scrollerRefCallback(customScrollParent ? customScrollParent : scrollerRef.current);
    handler({ target: localRef, suppressFlushSync: true });
    localRef.addEventListener("scroll", handler, { passive: true });
    return () => {
      scrollerRefCallback(null);
      localRef.removeEventListener("scroll", handler);
    };
  }, [scrollerRef, handler, scrollerElement, scrollerRefCallback, customScrollParent]);
  function scrollToCallback(location) {
    const scrollerElement2 = scrollerRef.current;
    if (!scrollerElement2 || (horizontalDirection ? "offsetWidth" in scrollerElement2 && scrollerElement2.offsetWidth === 0 : "offsetHeight" in scrollerElement2 && scrollerElement2.offsetHeight === 0)) {
      return;
    }
    const isSmooth = location.behavior === "smooth";
    let offsetHeight;
    let scrollHeight;
    let scrollTop;
    if (scrollerElement2 === window) {
      scrollHeight = Math.max(
        correctItemSize(document.documentElement, horizontalDirection ? "width" : "height"),
        horizontalDirection ? document.documentElement.scrollWidth : document.documentElement.scrollHeight
      );
      offsetHeight = horizontalDirection ? window.innerWidth : window.innerHeight;
      scrollTop = horizontalDirection ? document.documentElement.scrollLeft : document.documentElement.scrollTop;
    } else {
      scrollHeight = scrollerElement2[horizontalDirection ? "scrollWidth" : "scrollHeight"];
      offsetHeight = correctItemSize(scrollerElement2, horizontalDirection ? "width" : "height");
      scrollTop = scrollerElement2[horizontalDirection ? "scrollLeft" : "scrollTop"];
    }
    const maxScrollTop = scrollHeight - offsetHeight;
    location.top = Math.ceil(Math.max(Math.min(maxScrollTop, location.top), 0));
    if (approximatelyEqual(offsetHeight, scrollHeight) || location.top === scrollTop) {
      scrollContainerStateCallback({ scrollTop, scrollHeight, viewportHeight: offsetHeight });
      if (isSmooth) {
        smoothScrollTargetReached(true);
      }
      return;
    }
    if (isSmooth) {
      scrollTopTarget.current = location.top;
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      timeoutRef.current = setTimeout(() => {
        timeoutRef.current = null;
        scrollTopTarget.current = null;
        smoothScrollTargetReached(true);
      }, 1e3);
    } else {
      scrollTopTarget.current = null;
    }
    if (horizontalDirection) {
      location = { left: location.top, behavior: location.behavior };
    }
    scrollerElement2.scrollTo(location);
  }
  function scrollByCallback(location) {
    if (horizontalDirection) {
      location = { left: location.top, behavior: location.behavior };
    }
    scrollerRef.current.scrollBy(location);
  }
  return { scrollerRef, scrollByCallback, scrollToCallback };
}
const domIOSystem = system(
  () => {
    const scrollContainerState = stream();
    const scrollTop = stream();
    const deviation = statefulStream(0);
    const smoothScrollTargetReached = stream();
    const statefulScrollTop = statefulStream(0);
    const viewportHeight = stream();
    const scrollHeight = stream();
    const headerHeight = statefulStream(0);
    const fixedHeaderHeight = statefulStream(0);
    const fixedFooterHeight = statefulStream(0);
    const footerHeight = statefulStream(0);
    const scrollTo = stream();
    const scrollBy = stream();
    const scrollingInProgress = statefulStream(false);
    const horizontalDirection = statefulStream(false);
    const skipAnimationFrameInResizeObserver = statefulStream(false);
    connect(
      pipe(
        scrollContainerState,
        map$3(({ scrollTop: scrollTop2 }) => scrollTop2)
      ),
      scrollTop
    );
    connect(
      pipe(
        scrollContainerState,
        map$3(({ scrollHeight: scrollHeight2 }) => scrollHeight2)
      ),
      scrollHeight
    );
    connect(scrollTop, statefulScrollTop);
    return {
      // input
      scrollContainerState,
      scrollTop,
      viewportHeight,
      headerHeight,
      fixedHeaderHeight,
      fixedFooterHeight,
      footerHeight,
      scrollHeight,
      smoothScrollTargetReached,
      horizontalDirection,
      skipAnimationFrameInResizeObserver,
      // signals
      scrollTo,
      scrollBy,
      // state
      statefulScrollTop,
      deviation,
      scrollingInProgress
    };
  },
  [],
  { singleton: true }
);
const NIL_NODE = { lvl: 0 };
function newAANode(k, v, lvl, l = NIL_NODE, r2 = NIL_NODE) {
  return { k, v, lvl, l, r: r2 };
}
function empty(node) {
  return node === NIL_NODE;
}
function newTree() {
  return NIL_NODE;
}
function remove$1(node, key) {
  if (empty(node)) return NIL_NODE;
  const { k, l, r: r2 } = node;
  if (key === k) {
    if (empty(l)) {
      return r2;
    } else if (empty(r2)) {
      return l;
    } else {
      const [lastKey, lastValue] = last$3(l);
      return adjust(clone$6(node, { k: lastKey, v: lastValue, l: deleteLast(l) }));
    }
  } else if (key < k) {
    return adjust(clone$6(node, { l: remove$1(l, key) }));
  } else {
    return adjust(clone$6(node, { r: remove$1(r2, key) }));
  }
}
function find(node, key) {
  if (empty(node)) {
    return;
  }
  if (key === node.k) {
    return node.v;
  } else if (key < node.k) {
    return find(node.l, key);
  } else {
    return find(node.r, key);
  }
}
function findMaxKeyValue(node, value, field = "k") {
  if (empty(node)) {
    return [-Infinity, void 0];
  }
  if (Number(node[field]) === value) {
    return [node.k, node.v];
  }
  if (Number(node[field]) < value) {
    const r2 = findMaxKeyValue(node.r, value, field);
    if (r2[0] === -Infinity) {
      return [node.k, node.v];
    } else {
      return r2;
    }
  }
  return findMaxKeyValue(node.l, value, field);
}
function insert(node, k, v) {
  if (empty(node)) {
    return newAANode(k, v, 1);
  }
  if (k === node.k) {
    return clone$6(node, { k, v });
  } else if (k < node.k) {
    return rebalance(clone$6(node, { l: insert(node.l, k, v) }));
  } else {
    return rebalance(clone$6(node, { r: insert(node.r, k, v) }));
  }
}
function walkWithin(node, start, end) {
  if (empty(node)) {
    return [];
  }
  const { k, v, l, r: r2 } = node;
  let result = [];
  if (k > start) {
    result = result.concat(walkWithin(l, start, end));
  }
  if (k >= start && k <= end) {
    result.push({ k, v });
  }
  if (k <= end) {
    result = result.concat(walkWithin(r2, start, end));
  }
  return result;
}
function walk(node) {
  if (empty(node)) {
    return [];
  }
  return [...walk(node.l), { k: node.k, v: node.v }, ...walk(node.r)];
}
function last$3(node) {
  return empty(node.r) ? [node.k, node.v] : last$3(node.r);
}
function deleteLast(node) {
  return empty(node.r) ? node.l : adjust(clone$6(node, { r: deleteLast(node.r) }));
}
function clone$6(node, args) {
  return newAANode(
    args.k !== void 0 ? args.k : node.k,
    args.v !== void 0 ? args.v : node.v,
    args.lvl !== void 0 ? args.lvl : node.lvl,
    args.l !== void 0 ? args.l : node.l,
    args.r !== void 0 ? args.r : node.r
  );
}
function isSingle(node) {
  return empty(node) || node.lvl > node.r.lvl;
}
function rebalance(node) {
  return split(skew(node));
}
function adjust(node) {
  const { l, r: r2, lvl } = node;
  if (r2.lvl >= lvl - 1 && l.lvl >= lvl - 1) {
    return node;
  } else if (lvl > r2.lvl + 1) {
    if (isSingle(l)) {
      return skew(clone$6(node, { lvl: lvl - 1 }));
    } else {
      if (!empty(l) && !empty(l.r)) {
        return clone$6(l.r, {
          l: clone$6(l, { r: l.r.l }),
          r: clone$6(node, {
            l: l.r.r,
            lvl: lvl - 1
          }),
          lvl
        });
      } else {
        throw new Error("Unexpected empty nodes");
      }
    }
  } else {
    if (isSingle(node)) {
      return split(clone$6(node, { lvl: lvl - 1 }));
    } else {
      if (!empty(r2) && !empty(r2.l)) {
        const rl = r2.l;
        const rlvl = isSingle(rl) ? r2.lvl - 1 : r2.lvl;
        return clone$6(rl, {
          l: clone$6(node, {
            r: rl.l,
            lvl: lvl - 1
          }),
          r: split(clone$6(r2, { l: rl.r, lvl: rlvl })),
          lvl: rl.lvl + 1
        });
      } else {
        throw new Error("Unexpected empty nodes");
      }
    }
  }
}
function rangesWithin(node, startIndex, endIndex) {
  if (empty(node)) {
    return [];
  }
  const adjustedStart = findMaxKeyValue(node, startIndex)[0];
  return toRanges(walkWithin(node, adjustedStart, endIndex));
}
function arrayToRanges(items, parser) {
  const length = items.length;
  if (length === 0) {
    return [];
  }
  let { index: start, value } = parser(items[0]);
  const result = [];
  for (let i2 = 1; i2 < length; i2++) {
    const { index: nextIndex, value: nextValue } = parser(items[i2]);
    result.push({ start, end: nextIndex - 1, value });
    start = nextIndex;
    value = nextValue;
  }
  result.push({ start, end: Infinity, value });
  return result;
}
function toRanges(nodes) {
  return arrayToRanges(nodes, ({ k: index2, v: value }) => ({ index: index2, value }));
}
function split(node) {
  const { r: r2, lvl } = node;
  return !empty(r2) && !empty(r2.r) && r2.lvl === lvl && r2.r.lvl === lvl ? clone$6(r2, { l: clone$6(node, { r: r2.l }), lvl: lvl + 1 }) : node;
}
function skew(node) {
  const { l } = node;
  return !empty(l) && l.lvl === node.lvl ? clone$6(l, { r: clone$6(node, { l: l.r }) }) : node;
}
function findIndexOfClosestSmallerOrEqual(items, value, comparator, start = 0) {
  let end = items.length - 1;
  while (start <= end) {
    const index2 = Math.floor((start + end) / 2);
    const item = items[index2];
    const match = comparator(item, value);
    if (match === 0) {
      return index2;
    }
    if (match === -1) {
      if (end - start < 2) {
        return index2 - 1;
      }
      end = index2 - 1;
    } else {
      if (end === start) {
        return index2;
      }
      start = index2 + 1;
    }
  }
  throw new Error("Failed binary finding record in array - ".concat(items.join(","), ", searched for ").concat(value));
}
function findClosestSmallerOrEqual(items, value, comparator) {
  return items[findIndexOfClosestSmallerOrEqual(items, value, comparator)];
}
function findRange(items, startValue, endValue, comparator) {
  const startIndex = findIndexOfClosestSmallerOrEqual(items, startValue, comparator);
  const endIndex = findIndexOfClosestSmallerOrEqual(items, endValue, comparator, startIndex);
  return items.slice(startIndex, endIndex + 1);
}
const recalcSystem = system(
  () => {
    const recalcInProgress = statefulStream(false);
    return { recalcInProgress };
  },
  [],
  { singleton: true }
);
function rangeIncludes(refRange) {
  const { size, startIndex, endIndex } = refRange;
  return (range2) => {
    return range2.start === startIndex && (range2.end === endIndex || range2.end === Infinity) && range2.value === size;
  };
}
function affectedGroupCount(offset2, groupIndices) {
  let recognizedOffsetItems = 0;
  let groupIndex = 0;
  while (recognizedOffsetItems < offset2) {
    recognizedOffsetItems += groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;
    groupIndex++;
  }
  const offsetIsExact = recognizedOffsetItems === offset2;
  return groupIndex - (offsetIsExact ? 0 : 1);
}
function insertRanges(sizeTree, ranges) {
  let syncStart = empty(sizeTree) ? 0 : Infinity;
  for (const range2 of ranges) {
    const { size, startIndex, endIndex } = range2;
    syncStart = Math.min(syncStart, startIndex);
    if (empty(sizeTree)) {
      sizeTree = insert(sizeTree, 0, size);
      continue;
    }
    const overlappingRanges = rangesWithin(sizeTree, startIndex - 1, endIndex + 1);
    if (overlappingRanges.some(rangeIncludes(range2))) {
      continue;
    }
    let firstPassDone = false;
    let shouldInsert = false;
    for (const { start: rangeStart, end: rangeEnd, value: rangeValue } of overlappingRanges) {
      if (!firstPassDone) {
        shouldInsert = rangeValue !== size;
        firstPassDone = true;
      } else {
        if (endIndex >= rangeStart || size === rangeValue) {
          sizeTree = remove$1(sizeTree, rangeStart);
        }
      }
      if (rangeEnd > endIndex && endIndex >= rangeStart) {
        if (rangeValue !== size) {
          sizeTree = insert(sizeTree, endIndex + 1, rangeValue);
        }
      }
    }
    if (shouldInsert) {
      sizeTree = insert(sizeTree, startIndex, size);
    }
  }
  return [sizeTree, syncStart];
}
function initialSizeState() {
  return {
    offsetTree: [],
    sizeTree: newTree(),
    groupOffsetTree: newTree(),
    lastIndex: 0,
    lastOffset: 0,
    lastSize: 0,
    groupIndices: []
  };
}
function indexComparator({ index: itemIndex }, index2) {
  return index2 === itemIndex ? 0 : index2 < itemIndex ? -1 : 1;
}
function offsetComparator({ offset: itemOffset }, offset2) {
  return offset2 === itemOffset ? 0 : offset2 < itemOffset ? -1 : 1;
}
function offsetPointParser(point) {
  return { index: point.index, value: point };
}
function rangesWithinOffsets(tree2, startOffset, endOffset, minStartIndex = 0) {
  if (minStartIndex > 0) {
    startOffset = Math.max(startOffset, findClosestSmallerOrEqual(tree2, minStartIndex, indexComparator).offset);
  }
  return arrayToRanges(findRange(tree2, startOffset, endOffset, offsetComparator), offsetPointParser);
}
function createOffsetTree(prevOffsetTree, syncStart, sizeTree, gap) {
  let offsetTree = prevOffsetTree;
  let prevIndex = 0;
  let prevSize = 0;
  let prevOffset = 0;
  let startIndex = 0;
  if (syncStart !== 0) {
    startIndex = findIndexOfClosestSmallerOrEqual(offsetTree, syncStart - 1, indexComparator);
    const offsetInfo = offsetTree[startIndex];
    prevOffset = offsetInfo.offset;
    const kv = findMaxKeyValue(sizeTree, syncStart - 1);
    prevIndex = kv[0];
    prevSize = kv[1];
    if (offsetTree.length && offsetTree[startIndex].size === findMaxKeyValue(sizeTree, syncStart)[1]) {
      startIndex -= 1;
    }
    offsetTree = offsetTree.slice(0, startIndex + 1);
  } else {
    offsetTree = [];
  }
  for (const { start: startIndex2, value } of rangesWithin(sizeTree, syncStart, Infinity)) {
    const indexOffset = startIndex2 - prevIndex;
    const aOffset = indexOffset * prevSize + prevOffset + indexOffset * gap;
    offsetTree.push({
      offset: aOffset,
      size: value,
      index: startIndex2
    });
    prevIndex = startIndex2;
    prevOffset = aOffset;
    prevSize = value;
  }
  return {
    offsetTree,
    lastIndex: prevIndex,
    lastOffset: prevOffset,
    lastSize: prevSize
  };
}
function sizeStateReducer(state, [ranges, groupIndices, log, gap]) {
  if (ranges.length > 0) {
    log("received item sizes", ranges, LogLevel.DEBUG);
  }
  const sizeTree = state.sizeTree;
  let newSizeTree = sizeTree;
  let syncStart = 0;
  if (groupIndices.length > 0 && empty(sizeTree) && ranges.length === 2) {
    const groupSize = ranges[0].size;
    const itemSize = ranges[1].size;
    newSizeTree = groupIndices.reduce((tree2, groupIndex) => {
      return insert(insert(tree2, groupIndex, groupSize), groupIndex + 1, itemSize);
    }, newSizeTree);
  } else {
    [newSizeTree, syncStart] = insertRanges(newSizeTree, ranges);
  }
  if (newSizeTree === sizeTree) {
    return state;
  }
  const { offsetTree: newOffsetTree, lastIndex, lastSize, lastOffset } = createOffsetTree(state.offsetTree, syncStart, newSizeTree, gap);
  return {
    sizeTree: newSizeTree,
    offsetTree: newOffsetTree,
    lastIndex,
    lastOffset,
    lastSize,
    groupOffsetTree: groupIndices.reduce((tree2, index2) => {
      return insert(tree2, index2, offsetOf(index2, newOffsetTree, gap));
    }, newTree()),
    groupIndices
  };
}
function offsetOf(index2, tree2, gap) {
  if (tree2.length === 0) {
    return 0;
  }
  const { offset: offset2, index: startIndex, size } = findClosestSmallerOrEqual(tree2, index2, indexComparator);
  const itemCount = index2 - startIndex;
  const top = size * itemCount + (itemCount - 1) * gap + offset2;
  return top > 0 ? top + gap : top;
}
function isGroupLocation(location) {
  return typeof location.groupIndex !== "undefined";
}
function originalIndexFromLocation(location, sizes, lastIndex) {
  if (isGroupLocation(location)) {
    return sizes.groupIndices[location.groupIndex] + 1;
  } else {
    const numericIndex = location.index === "LAST" ? lastIndex : location.index;
    let result = originalIndexFromItemIndex(numericIndex, sizes);
    result = Math.max(0, result, Math.min(lastIndex, result));
    return result;
  }
}
function originalIndexFromItemIndex(itemIndex, sizes) {
  if (!hasGroups(sizes)) {
    return itemIndex;
  }
  let groupOffset = 0;
  while (sizes.groupIndices[groupOffset] <= itemIndex + groupOffset) {
    groupOffset++;
  }
  return itemIndex + groupOffset;
}
function hasGroups(sizes) {
  return !empty(sizes.groupOffsetTree);
}
function sizeTreeToRanges(sizeTree) {
  return walk(sizeTree).map(({ k: startIndex, v: size }, index2, sizeArray) => {
    const nextSize = sizeArray[index2 + 1];
    const endIndex = nextSize ? nextSize.k - 1 : Infinity;
    return { startIndex, endIndex, size };
  });
}
const SIZE_MAP = {
  offsetHeight: "height",
  offsetWidth: "width"
};
const sizeSystem = system(
  ([{ log }, { recalcInProgress }]) => {
    const sizeRanges = stream();
    const totalCount = stream();
    const statefulTotalCount = statefulStreamFromEmitter(totalCount, 0);
    const unshiftWith = stream();
    const shiftWith = stream();
    const firstItemIndex = statefulStream(0);
    const groupIndices = statefulStream([]);
    const fixedItemSize = statefulStream(void 0);
    const defaultItemSize = statefulStream(void 0);
    const itemSize = statefulStream((el, field) => correctItemSize(el, SIZE_MAP[field]));
    const data = statefulStream(void 0);
    const gap = statefulStream(0);
    const initial = initialSizeState();
    const sizes = statefulStreamFromEmitter(
      pipe(sizeRanges, withLatestFrom(groupIndices, log, gap), scan(sizeStateReducer, initial), distinctUntilChanged()),
      initial
    );
    const prevGroupIndices = statefulStreamFromEmitter(
      pipe(
        groupIndices,
        distinctUntilChanged(),
        scan((prev, curr) => ({ prev: prev.current, current: curr }), {
          prev: [],
          current: []
        }),
        map$3(({ prev }) => prev)
      ),
      []
    );
    connect(
      pipe(
        groupIndices,
        filter((indexes) => indexes.length > 0),
        withLatestFrom(sizes, gap),
        map$3(([groupIndices2, sizes2, gap2]) => {
          const groupOffsetTree = groupIndices2.reduce((tree2, index2, idx) => {
            return insert(tree2, index2, offsetOf(index2, sizes2.offsetTree, gap2) || idx);
          }, newTree());
          return {
            ...sizes2,
            groupIndices: groupIndices2,
            groupOffsetTree
          };
        })
      ),
      sizes
    );
    connect(
      pipe(
        totalCount,
        withLatestFrom(sizes),
        filter(([totalCount2, { lastIndex }]) => {
          return totalCount2 < lastIndex;
        }),
        map$3(([totalCount2, { lastIndex, lastSize }]) => {
          return [
            {
              startIndex: totalCount2,
              endIndex: lastIndex,
              size: lastSize
            }
          ];
        })
      ),
      sizeRanges
    );
    connect(fixedItemSize, defaultItemSize);
    const trackItemSizes = statefulStreamFromEmitter(
      pipe(
        fixedItemSize,
        map$3((size) => size === void 0)
      ),
      true
    );
    connect(
      pipe(
        defaultItemSize,
        filter((value) => {
          return value !== void 0 && empty(getValue$1(sizes).sizeTree);
        }),
        map$3((size) => [{ startIndex: 0, endIndex: 0, size }])
      ),
      sizeRanges
    );
    const listRefresh = streamFromEmitter(
      pipe(
        sizeRanges,
        withLatestFrom(sizes),
        scan(
          ({ sizes: oldSizes }, [_, newSizes]) => {
            return {
              changed: newSizes !== oldSizes,
              sizes: newSizes
            };
          },
          { changed: false, sizes: initial }
        ),
        map$3((value) => value.changed)
      )
    );
    subscribe(
      pipe(
        firstItemIndex,
        scan(
          (prev, next) => {
            return { diff: prev.prev - next, prev: next };
          },
          { diff: 0, prev: 0 }
        ),
        map$3((val) => val.diff)
      ),
      (offset2) => {
        const { groupIndices: groupIndices2 } = getValue$1(sizes);
        if (offset2 > 0) {
          publish(recalcInProgress, true);
          publish(unshiftWith, offset2 + affectedGroupCount(offset2, groupIndices2));
        } else if (offset2 < 0) {
          const prevGroupIndicesValue = getValue$1(prevGroupIndices);
          if (prevGroupIndicesValue.length > 0) {
            offset2 -= affectedGroupCount(-offset2, prevGroupIndicesValue);
          }
          publish(shiftWith, offset2);
        }
      }
    );
    subscribe(pipe(firstItemIndex, withLatestFrom(log)), ([index2, log2]) => {
      if (index2 < 0) {
        log2(
          "`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value",
          { firstItemIndex },
          LogLevel.ERROR
        );
      }
    });
    const beforeUnshiftWith = streamFromEmitter(unshiftWith);
    connect(
      pipe(
        unshiftWith,
        withLatestFrom(sizes),
        map$3(([unshiftWith2, sizes2]) => {
          const groupedMode = sizes2.groupIndices.length > 0;
          const initialRanges = [];
          const defaultSize = sizes2.lastSize;
          if (groupedMode) {
            const firstGroupSize = find(sizes2.sizeTree, 0);
            let prependedGroupItemsCount = 0;
            let groupIndex = 0;
            while (prependedGroupItemsCount < unshiftWith2) {
              const theGroupIndex = sizes2.groupIndices[groupIndex];
              const groupItemCount = sizes2.groupIndices.length === groupIndex + 1 ? Infinity : sizes2.groupIndices[groupIndex + 1] - theGroupIndex - 1;
              initialRanges.push({
                startIndex: theGroupIndex,
                endIndex: theGroupIndex,
                size: firstGroupSize
              });
              initialRanges.push({
                startIndex: theGroupIndex + 1,
                endIndex: theGroupIndex + 1 + groupItemCount - 1,
                size: defaultSize
              });
              groupIndex++;
              prependedGroupItemsCount += groupItemCount + 1;
            }
            const sizeTreeKV = walk(sizes2.sizeTree);
            const firstGroupIsExpanded = prependedGroupItemsCount !== unshiftWith2;
            if (firstGroupIsExpanded) {
              sizeTreeKV.shift();
            }
            return sizeTreeKV.reduce(
              (acc, { k: index2, v: size }) => {
                let ranges = acc.ranges;
                if (acc.prevSize !== 0) {
                  ranges = [
                    ...acc.ranges,
                    {
                      startIndex: acc.prevIndex,
                      endIndex: index2 + unshiftWith2 - 1,
                      size: acc.prevSize
                    }
                  ];
                }
                return {
                  ranges,
                  prevIndex: index2 + unshiftWith2,
                  prevSize: size
                };
              },
              {
                ranges: initialRanges,
                prevIndex: unshiftWith2,
                prevSize: 0
              }
            ).ranges;
          }
          return walk(sizes2.sizeTree).reduce(
            (acc, { k: index2, v: size }) => {
              return {
                ranges: [...acc.ranges, { startIndex: acc.prevIndex, endIndex: index2 + unshiftWith2 - 1, size: acc.prevSize }],
                prevIndex: index2 + unshiftWith2,
                prevSize: size
              };
            },
            {
              ranges: [],
              prevIndex: 0,
              prevSize: defaultSize
            }
          ).ranges;
        })
      ),
      sizeRanges
    );
    const shiftWithOffset = streamFromEmitter(
      pipe(
        shiftWith,
        withLatestFrom(sizes, gap),
        map$3(([shiftWith2, { offsetTree }, gap2]) => {
          const newFirstItemIndex = -shiftWith2;
          return offsetOf(newFirstItemIndex, offsetTree, gap2);
        })
      )
    );
    connect(
      pipe(
        shiftWith,
        withLatestFrom(sizes, gap),
        map$3(([shiftWith2, sizes2, gap2]) => {
          const groupedMode = sizes2.groupIndices.length > 0;
          if (groupedMode) {
            if (empty(sizes2.sizeTree)) {
              return sizes2;
            }
            let newSizeTree = newTree();
            const prevGroupIndicesValue = getValue$1(prevGroupIndices);
            let removedItemsCount = 0;
            let groupIndex = 0;
            let groupOffset = 0;
            while (removedItemsCount < -shiftWith2) {
              groupOffset = prevGroupIndicesValue[groupIndex];
              const groupItemCount = prevGroupIndicesValue[groupIndex + 1] - groupOffset - 1;
              groupIndex++;
              removedItemsCount += groupItemCount + 1;
            }
            newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k, v }) => {
              return insert(acc, Math.max(0, k + shiftWith2), v);
            }, newSizeTree);
            const aGroupIsShrunk = removedItemsCount !== -shiftWith2;
            if (aGroupIsShrunk) {
              const firstGroupSize = find(sizes2.sizeTree, groupOffset);
              newSizeTree = insert(newSizeTree, 0, firstGroupSize);
              const nextItemSize = findMaxKeyValue(sizes2.sizeTree, -shiftWith2 + 1)[1];
              newSizeTree = insert(newSizeTree, 1, nextItemSize);
            }
            return {
              ...sizes2,
              sizeTree: newSizeTree,
              ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)
            };
          } else {
            const newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k, v }) => {
              return insert(acc, Math.max(0, k + shiftWith2), v);
            }, newTree());
            return {
              ...sizes2,
              sizeTree: newSizeTree,
              ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)
            };
          }
        })
      ),
      sizes
    );
    return {
      // input
      data,
      totalCount,
      sizeRanges,
      groupIndices,
      defaultItemSize,
      fixedItemSize,
      unshiftWith,
      shiftWith,
      shiftWithOffset,
      beforeUnshiftWith,
      firstItemIndex,
      gap,
      // output
      sizes,
      listRefresh,
      statefulTotalCount,
      trackItemSizes,
      itemSize
    };
  },
  tup(loggerSystem, recalcSystem),
  { singleton: true }
);
const SUPPORTS_SCROLL_TO_OPTIONS = typeof document !== "undefined" && "scrollBehavior" in document.documentElement.style;
function normalizeIndexLocation(location) {
  const result = typeof location === "number" ? { index: location } : location;
  if (!result.align) {
    result.align = "start";
  }
  if (!result.behavior || !SUPPORTS_SCROLL_TO_OPTIONS) {
    result.behavior = "auto";
  }
  if (!result.offset) {
    result.offset = 0;
  }
  return result;
}
const scrollToIndexSystem = system(
  ([
    { sizes, totalCount, listRefresh, gap },
    {
      scrollingInProgress,
      viewportHeight,
      scrollTo,
      smoothScrollTargetReached,
      headerHeight,
      footerHeight,
      fixedHeaderHeight,
      fixedFooterHeight
    },
    { log }
  ]) => {
    const scrollToIndex = stream();
    const scrollTargetReached = stream();
    const topListHeight = statefulStream(0);
    let unsubscribeNextListRefresh = null;
    let cleartTimeoutRef = null;
    let unsubscribeListRefresh = null;
    function cleanup() {
      if (unsubscribeNextListRefresh) {
        unsubscribeNextListRefresh();
        unsubscribeNextListRefresh = null;
      }
      if (unsubscribeListRefresh) {
        unsubscribeListRefresh();
        unsubscribeListRefresh = null;
      }
      if (cleartTimeoutRef) {
        clearTimeout(cleartTimeoutRef);
        cleartTimeoutRef = null;
      }
      publish(scrollingInProgress, false);
    }
    connect(
      pipe(
        scrollToIndex,
        withLatestFrom(sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight, log),
        withLatestFrom(gap, fixedHeaderHeight, fixedFooterHeight),
        map$3(
          ([
            [location, sizes2, viewportHeight2, totalCount2, topListHeight2, headerHeight2, footerHeight2, log2],
            gap2,
            fixedHeaderHeight2,
            fixedFooterHeight2
          ]) => {
            const normalLocation = normalizeIndexLocation(location);
            const { align, behavior, offset: offset2 } = normalLocation;
            const lastIndex = totalCount2 - 1;
            const index2 = originalIndexFromLocation(normalLocation, sizes2, lastIndex);
            let top = offsetOf(index2, sizes2.offsetTree, gap2) + headerHeight2;
            if (align === "end") {
              top += fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index2)[1] - viewportHeight2 + fixedFooterHeight2;
              if (index2 === lastIndex) {
                top += footerHeight2;
              }
            } else if (align === "center") {
              top += (fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index2)[1] - viewportHeight2 + fixedFooterHeight2) / 2;
            } else {
              top -= topListHeight2;
            }
            if (offset2) {
              top += offset2;
            }
            const retry = (listChanged) => {
              cleanup();
              if (listChanged) {
                log2("retrying to scroll to", { location }, LogLevel.DEBUG);
                publish(scrollToIndex, location);
              } else {
                publish(scrollTargetReached, true);
                log2("list did not change, scroll successful", {}, LogLevel.DEBUG);
              }
            };
            cleanup();
            if (behavior === "smooth") {
              let listChanged = false;
              unsubscribeListRefresh = subscribe(listRefresh, (changed) => {
                listChanged = listChanged || changed;
              });
              unsubscribeNextListRefresh = handleNext(smoothScrollTargetReached, () => {
                retry(listChanged);
              });
            } else {
              unsubscribeNextListRefresh = handleNext(pipe(listRefresh, watchChangesFor(150)), retry);
            }
            cleartTimeoutRef = setTimeout(() => {
              cleanup();
            }, 1200);
            publish(scrollingInProgress, true);
            log2("scrolling from index to", { index: index2, top, behavior }, LogLevel.DEBUG);
            return { top, behavior };
          }
        )
      ),
      scrollTo
    );
    return {
      scrollToIndex,
      scrollTargetReached,
      topListHeight
    };
  },
  tup(sizeSystem, domIOSystem, loggerSystem),
  { singleton: true }
);
function watchChangesFor(limit) {
  return (done) => {
    const timeoutRef = setTimeout(() => {
      done(false);
    }, limit);
    return (value) => {
      if (value) {
        done(true);
        clearTimeout(timeoutRef);
      }
    };
  };
}
const UP = "up";
const DOWN = "down";
const NONE$1 = "none";
const INITIAL_BOTTOM_STATE = {
  atBottom: false,
  notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
  state: {
    offsetBottom: 0,
    scrollTop: 0,
    viewportHeight: 0,
    scrollHeight: 0
  }
};
const DEFAULT_AT_TOP_THRESHOLD = 0;
const stateFlagsSystem = system(([{ scrollContainerState, scrollTop, viewportHeight, headerHeight, footerHeight, scrollBy }]) => {
  const isAtBottom = statefulStream(false);
  const isAtTop = statefulStream(true);
  const atBottomStateChange = stream();
  const atTopStateChange = stream();
  const atBottomThreshold = statefulStream(4);
  const atTopThreshold = statefulStream(DEFAULT_AT_TOP_THRESHOLD);
  const isScrolling = statefulStreamFromEmitter(
    pipe(
      merge$4(pipe(duc(scrollTop), skip(1), mapTo(true)), pipe(duc(scrollTop), skip(1), mapTo(false), debounceTime(100))),
      distinctUntilChanged()
    ),
    false
  );
  const isScrollingBy = statefulStreamFromEmitter(
    pipe(merge$4(pipe(scrollBy, mapTo(true)), pipe(scrollBy, mapTo(false), debounceTime(200))), distinctUntilChanged()),
    false
  );
  connect(
    pipe(
      combineLatest(duc(scrollTop), duc(atTopThreshold)),
      map$3(([top, atTopThreshold2]) => top <= atTopThreshold2),
      distinctUntilChanged()
    ),
    isAtTop
  );
  connect(pipe(isAtTop, throttleTime(50)), atTopStateChange);
  const atBottomState = streamFromEmitter(
    pipe(
      combineLatest(scrollContainerState, duc(viewportHeight), duc(headerHeight), duc(footerHeight), duc(atBottomThreshold)),
      scan((current, [{ scrollTop: scrollTop2, scrollHeight }, viewportHeight2, _headerHeight, _footerHeight, atBottomThreshold2]) => {
        const isAtBottom2 = scrollTop2 + viewportHeight2 - scrollHeight > -atBottomThreshold2;
        const state = {
          viewportHeight: viewportHeight2,
          scrollTop: scrollTop2,
          scrollHeight
        };
        if (isAtBottom2) {
          let atBottomBecause;
          let scrollTopDelta;
          if (scrollTop2 > current.state.scrollTop) {
            atBottomBecause = "SCROLLED_DOWN";
            scrollTopDelta = current.state.scrollTop - scrollTop2;
          } else {
            atBottomBecause = "SIZE_DECREASED";
            scrollTopDelta = current.state.scrollTop - scrollTop2 || current.scrollTopDelta;
          }
          return {
            atBottom: true,
            state,
            atBottomBecause,
            scrollTopDelta
          };
        }
        let notAtBottomBecause;
        if (state.scrollHeight > current.state.scrollHeight) {
          notAtBottomBecause = "SIZE_INCREASED";
        } else if (viewportHeight2 < current.state.viewportHeight) {
          notAtBottomBecause = "VIEWPORT_HEIGHT_DECREASING";
        } else if (scrollTop2 < current.state.scrollTop) {
          notAtBottomBecause = "SCROLLING_UPWARDS";
        } else {
          notAtBottomBecause = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM";
        }
        return {
          atBottom: false,
          notAtBottomBecause,
          state
        };
      }, INITIAL_BOTTOM_STATE),
      distinctUntilChanged((prev, next) => {
        return prev && prev.atBottom === next.atBottom;
      })
    )
  );
  const lastJumpDueToItemResize = statefulStreamFromEmitter(
    pipe(
      scrollContainerState,
      scan(
        (current, { scrollTop: scrollTop2, scrollHeight, viewportHeight: viewportHeight2 }) => {
          if (!approximatelyEqual(current.scrollHeight, scrollHeight)) {
            const atBottom = scrollHeight - (scrollTop2 + viewportHeight2) < 1;
            if (current.scrollTop !== scrollTop2 && atBottom) {
              return {
                scrollHeight,
                scrollTop: scrollTop2,
                jump: current.scrollTop - scrollTop2,
                changed: true
              };
            } else {
              return {
                scrollHeight,
                scrollTop: scrollTop2,
                jump: 0,
                changed: true
              };
            }
          } else {
            return {
              scrollTop: scrollTop2,
              scrollHeight,
              jump: 0,
              changed: false
            };
          }
        },
        { scrollHeight: 0, jump: 0, scrollTop: 0, changed: false }
      ),
      filter((value) => value.changed),
      map$3((value) => value.jump)
    ),
    0
  );
  connect(
    pipe(
      atBottomState,
      map$3((state) => state.atBottom)
    ),
    isAtBottom
  );
  connect(pipe(isAtBottom, throttleTime(50)), atBottomStateChange);
  const scrollDirection = statefulStream(DOWN);
  connect(
    pipe(
      scrollContainerState,
      map$3(({ scrollTop: scrollTop2 }) => scrollTop2),
      distinctUntilChanged(),
      scan(
        (acc, scrollTop2) => {
          if (getValue$1(isScrollingBy)) {
            return { direction: acc.direction, prevScrollTop: scrollTop2 };
          }
          return { direction: scrollTop2 < acc.prevScrollTop ? UP : DOWN, prevScrollTop: scrollTop2 };
        },
        { direction: DOWN, prevScrollTop: 0 }
      ),
      map$3((value) => value.direction)
    ),
    scrollDirection
  );
  connect(pipe(scrollContainerState, throttleTime(50), mapTo(NONE$1)), scrollDirection);
  const scrollVelocity = statefulStream(0);
  connect(
    pipe(
      isScrolling,
      filter((value) => !value),
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      mapTo(0)
    ),
    scrollVelocity
  );
  connect(
    pipe(
      scrollTop,
      throttleTime(100),
      withLatestFrom(isScrolling),
      filter(([_, isScrolling2]) => !!isScrolling2),
      scan(([_, prev], [next]) => [prev, next], [0, 0]),
      map$3(([prev, next]) => next - prev)
    ),
    scrollVelocity
  );
  return {
    isScrolling,
    isAtTop,
    isAtBottom,
    atBottomState,
    atTopStateChange,
    atBottomStateChange,
    scrollDirection,
    atBottomThreshold,
    atTopThreshold,
    scrollVelocity,
    lastJumpDueToItemResize
  };
}, tup(domIOSystem));
const propsReadySystem = system(
  ([{ log }]) => {
    const propsReady = statefulStream(false);
    const didMount = streamFromEmitter(
      pipe(
        propsReady,
        filter((ready) => ready),
        distinctUntilChanged()
      )
    );
    subscribe(propsReady, (value) => {
      value && getValue$1(log)("props updated", {}, LogLevel.DEBUG);
    });
    return { propsReady, didMount };
  },
  tup(loggerSystem),
  { singleton: true }
);
function skipFrames(frameCount, callback) {
  if (frameCount == 0) {
    callback();
  } else {
    requestAnimationFrame(() => skipFrames(frameCount - 1, callback));
  }
}
function getInitialTopMostItemIndexNumber(location, totalCount) {
  const lastIndex = totalCount - 1;
  const index2 = typeof location === "number" ? location : location.index === "LAST" ? lastIndex : location.index;
  return index2;
}
const initialTopMostItemIndexSystem = system(
  ([{ sizes, listRefresh, defaultItemSize }, { scrollTop }, { scrollToIndex, scrollTargetReached }, { didMount }]) => {
    const scrolledToInitialItem = statefulStream(true);
    const initialTopMostItemIndex = statefulStream(0);
    const initialItemFinalLocationReached = statefulStream(true);
    connect(
      pipe(
        didMount,
        withLatestFrom(initialTopMostItemIndex),
        filter(([_, location]) => !!location),
        mapTo(false)
      ),
      scrolledToInitialItem
    );
    connect(
      pipe(
        didMount,
        withLatestFrom(initialTopMostItemIndex),
        filter(([_, location]) => !!location),
        mapTo(false)
      ),
      initialItemFinalLocationReached
    );
    subscribe(
      pipe(
        combineLatest(listRefresh, didMount),
        withLatestFrom(scrolledToInitialItem, sizes, defaultItemSize, initialItemFinalLocationReached),
        filter(([[, didMount2], scrolledToInitialItem2, { sizeTree }, defaultItemSize2, scrollScheduled]) => {
          return didMount2 && (!empty(sizeTree) || isDefined(defaultItemSize2)) && !scrolledToInitialItem2 && !scrollScheduled;
        }),
        withLatestFrom(initialTopMostItemIndex)
      ),
      ([, initialTopMostItemIndex2]) => {
        handleNext(scrollTargetReached, () => {
          publish(initialItemFinalLocationReached, true);
        });
        skipFrames(4, () => {
          handleNext(scrollTop, () => {
            publish(scrolledToInitialItem, true);
          });
          publish(scrollToIndex, initialTopMostItemIndex2);
        });
      }
    );
    return {
      scrolledToInitialItem,
      initialTopMostItemIndex,
      initialItemFinalLocationReached
    };
  },
  tup(sizeSystem, domIOSystem, scrollToIndexSystem, propsReadySystem),
  { singleton: true }
);
function normalizeFollowOutput(follow) {
  if (!follow) {
    return false;
  }
  return follow === "smooth" ? "smooth" : "auto";
}
const behaviorFromFollowOutput = (follow, isAtBottom) => {
  if (typeof follow === "function") {
    return normalizeFollowOutput(follow(isAtBottom));
  }
  return isAtBottom && normalizeFollowOutput(follow);
};
const followOutputSystem = system(
  ([
    { totalCount, listRefresh },
    { isAtBottom, atBottomState },
    { scrollToIndex },
    { scrolledToInitialItem },
    { propsReady, didMount },
    { log },
    { scrollingInProgress }
  ]) => {
    const followOutput = statefulStream(false);
    const autoscrollToBottom = stream();
    let pendingScrollHandle = null;
    function scrollToBottom(followOutputBehavior) {
      publish(scrollToIndex, {
        index: "LAST",
        align: "end",
        behavior: followOutputBehavior
      });
    }
    subscribe(
      pipe(
        combineLatest(pipe(duc(totalCount), skip(1)), didMount),
        withLatestFrom(duc(followOutput), isAtBottom, scrolledToInitialItem, scrollingInProgress),
        map$3(([[totalCount2, didMount2], followOutput2, isAtBottom2, scrolledToInitialItem2, scrollingInProgress2]) => {
          let shouldFollow = didMount2 && scrolledToInitialItem2;
          let followOutputBehavior = "auto";
          if (shouldFollow) {
            followOutputBehavior = behaviorFromFollowOutput(followOutput2, isAtBottom2 || scrollingInProgress2);
            shouldFollow = shouldFollow && !!followOutputBehavior;
          }
          return { totalCount: totalCount2, shouldFollow, followOutputBehavior };
        }),
        filter(({ shouldFollow }) => shouldFollow)
      ),
      ({ totalCount: totalCount2, followOutputBehavior }) => {
        if (pendingScrollHandle) {
          pendingScrollHandle();
          pendingScrollHandle = null;
        }
        pendingScrollHandle = handleNext(listRefresh, () => {
          getValue$1(log)("following output to ", { totalCount: totalCount2 }, LogLevel.DEBUG);
          scrollToBottom(followOutputBehavior);
          pendingScrollHandle = null;
        });
      }
    );
    function trapNextSizeIncrease(followOutput2) {
      const cancel = handleNext(atBottomState, (state) => {
        if (followOutput2 && !state.atBottom && state.notAtBottomBecause === "SIZE_INCREASED" && !pendingScrollHandle) {
          getValue$1(log)("scrolling to bottom due to increased size", {}, LogLevel.DEBUG);
          scrollToBottom("auto");
        }
      });
      setTimeout(cancel, 100);
    }
    subscribe(
      pipe(
        combineLatest(duc(followOutput), totalCount, propsReady),
        filter(([follow, , ready]) => follow && ready),
        scan(
          ({ value }, [, next]) => {
            return { refreshed: value === next, value: next };
          },
          { refreshed: false, value: 0 }
        ),
        filter(({ refreshed }) => refreshed),
        withLatestFrom(followOutput, totalCount)
      ),
      ([, followOutput2]) => {
        if (getValue$1(scrolledToInitialItem)) {
          trapNextSizeIncrease(followOutput2 !== false);
        }
      }
    );
    subscribe(autoscrollToBottom, () => {
      trapNextSizeIncrease(getValue$1(followOutput) !== false);
    });
    subscribe(combineLatest(duc(followOutput), atBottomState), ([followOutput2, state]) => {
      if (followOutput2 && !state.atBottom && state.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING") {
        scrollToBottom("auto");
      }
    });
    return { followOutput, autoscrollToBottom };
  },
  tup(sizeSystem, stateFlagsSystem, scrollToIndexSystem, initialTopMostItemIndexSystem, propsReadySystem, loggerSystem, domIOSystem)
);
function groupCountsToIndicesAndCount(counts) {
  return counts.reduce(
    (acc, groupCount) => {
      acc.groupIndices.push(acc.totalCount);
      acc.totalCount += groupCount + 1;
      return acc;
    },
    {
      totalCount: 0,
      groupIndices: []
    }
  );
}
const groupedListSystem = system(([{ totalCount, groupIndices, sizes }, { scrollTop, headerHeight }]) => {
  const groupCounts = stream();
  const topItemsIndexes = stream();
  const groupIndicesAndCount = streamFromEmitter(pipe(groupCounts, map$3(groupCountsToIndicesAndCount)));
  connect(
    pipe(
      groupIndicesAndCount,
      map$3((value) => value.totalCount)
    ),
    totalCount
  );
  connect(
    pipe(
      groupIndicesAndCount,
      map$3((value) => value.groupIndices)
    ),
    groupIndices
  );
  connect(
    pipe(
      combineLatest(scrollTop, sizes, headerHeight),
      filter(([_, sizes2]) => hasGroups(sizes2)),
      map$3(([scrollTop2, state, headerHeight2]) => findMaxKeyValue(state.groupOffsetTree, Math.max(scrollTop2 - headerHeight2, 0), "v")[0]),
      distinctUntilChanged(),
      map$3((index2) => [index2])
    ),
    topItemsIndexes
  );
  return { groupCounts, topItemsIndexes };
}, tup(sizeSystem, domIOSystem));
function tupleComparator(prev, current) {
  return !!(prev && prev[0] === current[0] && prev[1] === current[1]);
}
function rangeComparator(prev, next) {
  return !!(prev && prev.startIndex === next.startIndex && prev.endIndex === next.endIndex);
}
const TOP = "top";
const BOTTOM = "bottom";
const NONE = "none";
function getOverscan(overscan, end, direction) {
  if (typeof overscan === "number") {
    return direction === UP && end === TOP || direction === DOWN && end === BOTTOM ? overscan : 0;
  } else {
    if (direction === UP) {
      return end === TOP ? overscan.main : overscan.reverse;
    } else {
      return end === BOTTOM ? overscan.main : overscan.reverse;
    }
  }
}
function getViewportIncrease(value, end) {
  return typeof value === "number" ? value : value[end] || 0;
}
const sizeRangeSystem = system(
  ([{ scrollTop, viewportHeight, deviation, headerHeight, fixedHeaderHeight }]) => {
    const listBoundary = stream();
    const topListHeight = statefulStream(0);
    const increaseViewportBy = statefulStream(0);
    const overscan = statefulStream(0);
    const visibleRange = statefulStreamFromEmitter(
      pipe(
        combineLatest(
          duc(scrollTop),
          duc(viewportHeight),
          duc(headerHeight),
          duc(listBoundary, tupleComparator),
          duc(overscan),
          duc(topListHeight),
          duc(fixedHeaderHeight),
          duc(deviation),
          duc(increaseViewportBy)
        ),
        map$3(
          ([
            scrollTop2,
            viewportHeight2,
            headerHeight2,
            [listTop, listBottom],
            overscan2,
            topListHeight2,
            fixedHeaderHeight2,
            deviation2,
            increaseViewportBy2
          ]) => {
            const top = scrollTop2 - deviation2;
            const stickyHeaderHeight = topListHeight2 + fixedHeaderHeight2;
            const headerVisible = Math.max(headerHeight2 - top, 0);
            let direction = NONE;
            const topViewportAddition = getViewportIncrease(increaseViewportBy2, TOP);
            const bottomViewportAddition = getViewportIncrease(increaseViewportBy2, BOTTOM);
            listTop -= deviation2;
            listTop += headerHeight2 + fixedHeaderHeight2;
            listBottom += headerHeight2 + fixedHeaderHeight2;
            listBottom -= deviation2;
            if (listTop > scrollTop2 + stickyHeaderHeight - topViewportAddition) {
              direction = UP;
            }
            if (listBottom < scrollTop2 - headerVisible + viewportHeight2 + bottomViewportAddition) {
              direction = DOWN;
            }
            if (direction !== NONE) {
              return [
                Math.max(top - headerHeight2 - getOverscan(overscan2, TOP, direction) - topViewportAddition, 0),
                top - headerVisible - fixedHeaderHeight2 + viewportHeight2 + getOverscan(overscan2, BOTTOM, direction) + bottomViewportAddition
              ];
            }
            return null;
          }
        ),
        filter((value) => value != null),
        distinctUntilChanged(tupleComparator)
      ),
      [0, 0]
    );
    return {
      // input
      listBoundary,
      overscan,
      topListHeight,
      increaseViewportBy,
      // output
      visibleRange
    };
  },
  tup(domIOSystem),
  { singleton: true }
);
function probeItemSet(index2, sizes, data) {
  if (hasGroups(sizes)) {
    const itemIndex = originalIndexFromItemIndex(index2, sizes);
    const groupIndex = findMaxKeyValue(sizes.groupOffsetTree, itemIndex)[0];
    return [
      { index: groupIndex, size: 0, offset: 0 },
      { index: itemIndex, size: 0, offset: 0, data: data && data[0] }
    ];
  }
  return [{ index: index2, size: 0, offset: 0, data: data && data[0] }];
}
const EMPTY_LIST_STATE = {
  items: [],
  topItems: [],
  offsetTop: 0,
  offsetBottom: 0,
  top: 0,
  bottom: 0,
  topListHeight: 0,
  totalCount: 0,
  firstItemIndex: 0
};
function transposeItems(items, sizes, firstItemIndex) {
  if (items.length === 0) {
    return [];
  }
  if (!hasGroups(sizes)) {
    return items.map((item) => ({ ...item, index: item.index + firstItemIndex, originalIndex: item.index }));
  }
  const startIndex = items[0].index;
  const endIndex = items[items.length - 1].index;
  const transposedItems = [];
  const groupRanges = rangesWithin(sizes.groupOffsetTree, startIndex, endIndex);
  let currentRange = void 0;
  let currentGroupIndex = 0;
  for (const item of items) {
    if (!currentRange || currentRange.end < item.index) {
      currentRange = groupRanges.shift();
      currentGroupIndex = sizes.groupIndices.indexOf(currentRange.start);
    }
    let transposedItem;
    if (item.index === currentRange.start) {
      transposedItem = {
        type: "group",
        index: currentGroupIndex
      };
    } else {
      transposedItem = {
        index: item.index - (currentGroupIndex + 1) + firstItemIndex,
        groupIndex: currentGroupIndex
      };
    }
    transposedItems.push({
      ...transposedItem,
      size: item.size,
      offset: item.offset,
      originalIndex: item.index,
      data: item.data
    });
  }
  return transposedItems;
}
function buildListState(items, topItems, totalCount, gap, sizes, firstItemIndex) {
  const { lastSize, lastOffset, lastIndex } = sizes;
  let offsetTop = 0;
  let bottom = 0;
  if (items.length > 0) {
    offsetTop = items[0].offset;
    const lastItem = items[items.length - 1];
    bottom = lastItem.offset + lastItem.size;
  }
  const itemCount = totalCount - lastIndex;
  const total = lastOffset + itemCount * lastSize + (itemCount - 1) * gap;
  const top = offsetTop;
  const offsetBottom = total - bottom;
  return {
    items: transposeItems(items, sizes, firstItemIndex),
    topItems: transposeItems(topItems, sizes, firstItemIndex),
    topListHeight: topItems.reduce((height, item) => item.size + height, 0),
    offsetTop,
    offsetBottom,
    top,
    bottom,
    totalCount,
    firstItemIndex
  };
}
function buildListStateFromItemCount(itemCount, initialTopMostItemIndex, sizes, firstItemIndex, gap, data) {
  let includedGroupsCount = 0;
  if (sizes.groupIndices.length > 0) {
    for (const index2 of sizes.groupIndices) {
      if (index2 - includedGroupsCount >= itemCount) {
        break;
      }
      includedGroupsCount++;
    }
  }
  const adjustedCount = itemCount + includedGroupsCount;
  const initialTopMostItemIndexNumber = getInitialTopMostItemIndexNumber(initialTopMostItemIndex, adjustedCount);
  const items = Array.from({ length: adjustedCount }).map((_, index2) => ({
    index: index2 + initialTopMostItemIndexNumber,
    size: 0,
    offset: 0,
    data: data[index2 + initialTopMostItemIndexNumber]
  }));
  return buildListState(items, [], adjustedCount, gap, sizes, firstItemIndex);
}
const listStateSystem = system(
  ([
    { sizes, totalCount, data, firstItemIndex, gap },
    groupedListSystem2,
    { visibleRange, listBoundary, topListHeight: rangeTopListHeight },
    { scrolledToInitialItem, initialTopMostItemIndex },
    { topListHeight },
    stateFlags,
    { didMount },
    { recalcInProgress }
  ]) => {
    const topItemsIndexes = statefulStream([]);
    const initialItemCount = statefulStream(0);
    const itemsRendered = stream();
    connect(groupedListSystem2.topItemsIndexes, topItemsIndexes);
    const listState = statefulStreamFromEmitter(
      pipe(
        combineLatest(
          didMount,
          recalcInProgress,
          duc(visibleRange, tupleComparator),
          duc(totalCount),
          duc(sizes),
          duc(initialTopMostItemIndex),
          scrolledToInitialItem,
          duc(topItemsIndexes),
          duc(firstItemIndex),
          duc(gap),
          data
        ),
        filter(([mount, recalcInProgress2, , totalCount2, , , , , , , data2]) => {
          const dataChangeInProgress = data2 && data2.length !== totalCount2;
          return mount && !recalcInProgress2 && !dataChangeInProgress;
        }),
        map$3(
          ([
            ,
            ,
            [startOffset, endOffset],
            totalCount2,
            sizes2,
            initialTopMostItemIndex2,
            scrolledToInitialItem2,
            topItemsIndexes2,
            firstItemIndex2,
            gap2,
            data2
          ]) => {
            const sizesValue = sizes2;
            const { sizeTree, offsetTree } = sizesValue;
            const initialItemCountValue = getValue$1(initialItemCount);
            if (totalCount2 === 0) {
              return { ...EMPTY_LIST_STATE, totalCount: totalCount2 };
            }
            if (startOffset === 0 && endOffset === 0) {
              if (initialItemCountValue === 0) {
                return { ...EMPTY_LIST_STATE, totalCount: totalCount2 };
              } else {
                return buildListStateFromItemCount(initialItemCountValue, initialTopMostItemIndex2, sizes2, firstItemIndex2, gap2, data2 || []);
              }
            }
            if (empty(sizeTree)) {
              if (initialItemCountValue > 0) {
                return null;
              }
              const state = buildListState(
                probeItemSet(getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2), sizesValue, data2),
                [],
                totalCount2,
                gap2,
                sizesValue,
                firstItemIndex2
              );
              return state;
            }
            const topItems = [];
            if (topItemsIndexes2.length > 0) {
              const startIndex = topItemsIndexes2[0];
              const endIndex = topItemsIndexes2[topItemsIndexes2.length - 1];
              let offset2 = 0;
              for (const range2 of rangesWithin(sizeTree, startIndex, endIndex)) {
                const size = range2.value;
                const rangeStartIndex = Math.max(range2.start, startIndex);
                const rangeEndIndex = Math.min(range2.end, endIndex);
                for (let i2 = rangeStartIndex; i2 <= rangeEndIndex; i2++) {
                  topItems.push({ index: i2, size, offset: offset2, data: data2 && data2[i2] });
                  offset2 += size;
                }
              }
            }
            if (!scrolledToInitialItem2) {
              return buildListState([], topItems, totalCount2, gap2, sizesValue, firstItemIndex2);
            }
            const minStartIndex = topItemsIndexes2.length > 0 ? topItemsIndexes2[topItemsIndexes2.length - 1] + 1 : 0;
            const offsetPointRanges = rangesWithinOffsets(offsetTree, startOffset, endOffset, minStartIndex);
            if (offsetPointRanges.length === 0) {
              return null;
            }
            const maxIndex = totalCount2 - 1;
            const items = tap([], (result) => {
              for (const range2 of offsetPointRanges) {
                const point = range2.value;
                let offset2 = point.offset;
                let rangeStartIndex = range2.start;
                const size = point.size;
                if (point.offset < startOffset) {
                  rangeStartIndex += Math.floor((startOffset - point.offset + gap2) / (size + gap2));
                  const itemCount = rangeStartIndex - range2.start;
                  offset2 += itemCount * size + itemCount * gap2;
                }
                if (rangeStartIndex < minStartIndex) {
                  offset2 += (minStartIndex - rangeStartIndex) * size;
                  rangeStartIndex = minStartIndex;
                }
                const endIndex = Math.min(range2.end, maxIndex);
                for (let i2 = rangeStartIndex; i2 <= endIndex; i2++) {
                  if (offset2 >= endOffset) {
                    break;
                  }
                  result.push({ index: i2, size, offset: offset2, data: data2 && data2[i2] });
                  offset2 += size + gap2;
                }
              }
            });
            return buildListState(items, topItems, totalCount2, gap2, sizesValue, firstItemIndex2);
          }
        ),
        //@ts-expect-error filter needs to be fixed
        filter((value) => value !== null),
        distinctUntilChanged()
      ),
      EMPTY_LIST_STATE
    );
    connect(
      pipe(
        data,
        filter(isDefined),
        map$3((data2) => data2 == null ? void 0 : data2.length)
      ),
      totalCount
    );
    connect(
      pipe(
        listState,
        map$3((value) => value.topListHeight)
      ),
      topListHeight
    );
    connect(topListHeight, rangeTopListHeight);
    connect(
      pipe(
        listState,
        map$3((state) => [state.top, state.bottom])
      ),
      listBoundary
    );
    connect(
      pipe(
        listState,
        map$3((state) => state.items)
      ),
      itemsRendered
    );
    const endReached = streamFromEmitter(
      pipe(
        listState,
        filter(({ items }) => items.length > 0),
        withLatestFrom(totalCount, data),
        filter(([{ items }, totalCount2]) => items[items.length - 1].originalIndex === totalCount2 - 1),
        map$3(([, totalCount2, data2]) => [totalCount2 - 1, data2]),
        distinctUntilChanged(tupleComparator),
        map$3(([count2]) => count2)
      )
    );
    const startReached = streamFromEmitter(
      pipe(
        listState,
        throttleTime(200),
        filter(({ items, topItems }) => {
          return items.length > 0 && items[0].originalIndex === topItems.length;
        }),
        map$3(({ items }) => items[0].index),
        distinctUntilChanged()
      )
    );
    const rangeChanged = streamFromEmitter(
      pipe(
        listState,
        filter(({ items }) => items.length > 0),
        map$3(({ items }) => {
          let startIndex = 0;
          let endIndex = items.length - 1;
          while (items[startIndex].type === "group" && startIndex < endIndex) {
            startIndex++;
          }
          while (items[endIndex].type === "group" && endIndex > startIndex) {
            endIndex--;
          }
          return {
            startIndex: items[startIndex].index,
            endIndex: items[endIndex].index
          };
        }),
        distinctUntilChanged(rangeComparator)
      )
    );
    return { listState, topItemsIndexes, endReached, startReached, rangeChanged, itemsRendered, initialItemCount, ...stateFlags };
  },
  tup(
    sizeSystem,
    groupedListSystem,
    sizeRangeSystem,
    initialTopMostItemIndexSystem,
    scrollToIndexSystem,
    stateFlagsSystem,
    propsReadySystem,
    recalcSystem
  ),
  { singleton: true }
);
const initialItemCountSystem = system(
  ([{ sizes, firstItemIndex, data, gap }, { initialTopMostItemIndex }, { initialItemCount, listState }, { didMount }]) => {
    connect(
      pipe(
        didMount,
        withLatestFrom(initialItemCount),
        filter(([, count2]) => count2 !== 0),
        withLatestFrom(initialTopMostItemIndex, sizes, firstItemIndex, gap, data),
        map$3(([[, count2], initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap2, data2 = []]) => {
          return buildListStateFromItemCount(count2, initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap2, data2);
        })
      ),
      listState
    );
    return {};
  },
  tup(sizeSystem, initialTopMostItemIndexSystem, listStateSystem, propsReadySystem),
  { singleton: true }
);
const scrollSeekSystem = system(
  ([{ scrollVelocity }]) => {
    const isSeeking = statefulStream(false);
    const rangeChanged = stream();
    const scrollSeekConfiguration = statefulStream(false);
    connect(
      pipe(
        scrollVelocity,
        withLatestFrom(scrollSeekConfiguration, isSeeking, rangeChanged),
        filter(([_, config2]) => !!config2),
        map$3(([speed, config2, isSeeking2, range2]) => {
          const { exit, enter } = config2;
          if (isSeeking2) {
            if (exit(speed, range2)) {
              return false;
            }
          } else {
            if (enter(speed, range2)) {
              return true;
            }
          }
          return isSeeking2;
        }),
        distinctUntilChanged()
      ),
      isSeeking
    );
    subscribe(
      pipe(combineLatest(isSeeking, scrollVelocity, rangeChanged), withLatestFrom(scrollSeekConfiguration)),
      ([[isSeeking2, velocity, range2], config2]) => isSeeking2 && config2 && config2.change && config2.change(velocity, range2)
    );
    return { isSeeking, scrollSeekConfiguration, scrollVelocity, scrollSeekRangeChanged: rangeChanged };
  },
  tup(stateFlagsSystem),
  { singleton: true }
);
const topItemCountSystem = system(([{ topItemsIndexes }]) => {
  const topItemCount = statefulStream(0);
  connect(
    pipe(
      topItemCount,
      filter((length) => length > 0),
      map$3((length) => Array.from({ length }).map((_, index2) => index2))
    ),
    topItemsIndexes
  );
  return { topItemCount };
}, tup(listStateSystem));
const totalListHeightSystem = system(
  ([{ footerHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight }, { listState }]) => {
    const totalListHeightChanged = stream();
    const totalListHeight = statefulStreamFromEmitter(
      pipe(
        combineLatest(footerHeight, fixedFooterHeight, headerHeight, fixedHeaderHeight, listState),
        map$3(([footerHeight2, fixedFooterHeight2, headerHeight2, fixedHeaderHeight2, listState2]) => {
          return footerHeight2 + fixedFooterHeight2 + headerHeight2 + fixedHeaderHeight2 + listState2.offsetBottom + listState2.bottom;
        })
      ),
      0
    );
    connect(duc(totalListHeight), totalListHeightChanged);
    return { totalListHeight, totalListHeightChanged };
  },
  tup(domIOSystem, listStateSystem),
  { singleton: true }
);
function simpleMemoize(func) {
  let called = false;
  let result;
  return () => {
    if (!called) {
      called = true;
      result = func();
    }
    return result;
  };
}
const isMobileSafari = simpleMemoize(() => {
  return /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);
});
const upwardScrollFixSystem = system(
  ([
    { scrollBy, scrollTop, deviation, scrollingInProgress },
    { isScrolling, isAtBottom, scrollDirection, lastJumpDueToItemResize },
    { listState },
    { beforeUnshiftWith, shiftWithOffset, sizes, gap },
    { log },
    { recalcInProgress }
  ]) => {
    const deviationOffset = streamFromEmitter(
      pipe(
        listState,
        withLatestFrom(lastJumpDueToItemResize),
        scan(
          ([, prevItems, prevTotalCount, prevTotalHeight], [{ items, totalCount, bottom, offsetBottom }, lastJumpDueToItemResize2]) => {
            const totalHeight = bottom + offsetBottom;
            let newDev = 0;
            if (prevTotalCount === totalCount) {
              if (prevItems.length > 0 && items.length > 0) {
                const atStart = items[0].originalIndex === 0 && prevItems[0].originalIndex === 0;
                if (!atStart) {
                  newDev = totalHeight - prevTotalHeight;
                  if (newDev !== 0) {
                    newDev += lastJumpDueToItemResize2;
                  }
                }
              }
            }
            return [newDev, items, totalCount, totalHeight];
          },
          [0, [], 0, 0]
        ),
        filter(([amount]) => amount !== 0),
        withLatestFrom(scrollTop, scrollDirection, scrollingInProgress, isAtBottom, log, recalcInProgress),
        filter(([, scrollTop2, scrollDirection2, scrollingInProgress2, , , recalcInProgress2]) => {
          return !recalcInProgress2 && !scrollingInProgress2 && scrollTop2 !== 0 && scrollDirection2 === UP;
        }),
        map$3(([[amount], , , , , log2]) => {
          log2("Upward scrolling compensation", { amount }, LogLevel.DEBUG);
          return amount;
        })
      )
    );
    function scrollByWith(offset2) {
      if (offset2 > 0) {
        publish(scrollBy, { top: -offset2, behavior: "auto" });
        publish(deviation, 0);
      } else {
        publish(deviation, 0);
        publish(scrollBy, { top: -offset2, behavior: "auto" });
      }
    }
    subscribe(pipe(deviationOffset, withLatestFrom(deviation, isScrolling)), ([offset2, deviationAmount, isScrolling2]) => {
      if (isScrolling2 && isMobileSafari()) {
        publish(deviation, deviationAmount - offset2);
      } else {
        scrollByWith(-offset2);
      }
    });
    subscribe(
      pipe(
        combineLatest(statefulStreamFromEmitter(isScrolling, false), deviation, recalcInProgress),
        filter(([is3, deviation2, recalc]) => !is3 && !recalc && deviation2 !== 0),
        map$3(([_, deviation2]) => deviation2),
        throttleTime(1)
      ),
      scrollByWith
    );
    connect(
      pipe(
        shiftWithOffset,
        map$3((offset2) => {
          return { top: -offset2 };
        })
      ),
      scrollBy
    );
    subscribe(
      pipe(
        beforeUnshiftWith,
        withLatestFrom(sizes, gap),
        map$3(([offset2, { lastSize: defaultItemSize, groupIndices, sizeTree }, gap2]) => {
          function getItemOffset(itemCount) {
            return itemCount * (defaultItemSize + gap2);
          }
          if (groupIndices.length === 0) {
            return getItemOffset(offset2);
          } else {
            let amount = 0;
            const defaultGroupSize = find(sizeTree, 0);
            let recognizedOffsetItems = 0;
            let groupIndex = 0;
            while (recognizedOffsetItems < offset2) {
              recognizedOffsetItems++;
              amount += defaultGroupSize;
              let groupItemCount = groupIndices.length === groupIndex + 1 ? Infinity : groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;
              if (recognizedOffsetItems + groupItemCount > offset2) {
                amount -= defaultGroupSize;
                groupItemCount = offset2 - recognizedOffsetItems + 1;
              }
              recognizedOffsetItems += groupItemCount;
              amount += getItemOffset(groupItemCount);
              groupIndex++;
            }
            return amount;
          }
        })
      ),
      (offset2) => {
        publish(deviation, offset2);
        requestAnimationFrame(() => {
          publish(scrollBy, { top: offset2 });
          requestAnimationFrame(() => {
            publish(deviation, 0);
            publish(recalcInProgress, false);
          });
        });
      }
    );
    return { deviation };
  },
  tup(domIOSystem, stateFlagsSystem, listStateSystem, sizeSystem, loggerSystem, recalcSystem)
);
const initialScrollTopSystem = system(
  ([{ didMount }, { scrollTo }, { listState }]) => {
    const initialScrollTop = statefulStream(0);
    subscribe(
      pipe(
        didMount,
        withLatestFrom(initialScrollTop),
        filter(([, offset2]) => offset2 !== 0),
        map$3(([, offset2]) => ({ top: offset2 }))
      ),
      (location) => {
        handleNext(
          pipe(
            listState,
            skip(1),
            filter((state) => state.items.length > 1)
          ),
          () => {
            requestAnimationFrame(() => {
              publish(scrollTo, location);
            });
          }
        );
      }
    );
    return {
      initialScrollTop
    };
  },
  tup(propsReadySystem, domIOSystem, listStateSystem),
  { singleton: true }
);
const alignToBottomSystem = system(
  ([{ viewportHeight }, { totalListHeight }]) => {
    const alignToBottom = statefulStream(false);
    const paddingTopAddition = statefulStreamFromEmitter(
      pipe(
        combineLatest(alignToBottom, viewportHeight, totalListHeight),
        filter(([enabled]) => enabled),
        map$3(([, viewportHeight2, totalListHeight2]) => {
          return Math.max(0, viewportHeight2 - totalListHeight2);
        }),
        throttleTime(0),
        distinctUntilChanged()
      ),
      0
    );
    return { alignToBottom, paddingTopAddition };
  },
  tup(domIOSystem, totalListHeightSystem),
  { singleton: true }
);
const windowScrollerSystem = system(([{ scrollTo, scrollContainerState }]) => {
  const windowScrollContainerState = stream();
  const windowViewportRect = stream();
  const windowScrollTo = stream();
  const useWindowScroll = statefulStream(false);
  const customScrollParent = statefulStream(void 0);
  connect(
    pipe(
      combineLatest(windowScrollContainerState, windowViewportRect),
      map$3(([{ viewportHeight, scrollTop: windowScrollTop, scrollHeight }, { offsetTop }]) => {
        return {
          scrollTop: Math.max(0, windowScrollTop - offsetTop),
          scrollHeight,
          viewportHeight
        };
      })
    ),
    scrollContainerState
  );
  connect(
    pipe(
      scrollTo,
      withLatestFrom(windowViewportRect),
      map$3(([scrollTo2, { offsetTop }]) => {
        return {
          ...scrollTo2,
          top: scrollTo2.top + offsetTop
        };
      })
    ),
    windowScrollTo
  );
  return {
    // config
    useWindowScroll,
    customScrollParent,
    // input
    windowScrollContainerState,
    windowViewportRect,
    // signals
    windowScrollTo
  };
}, tup(domIOSystem));
const defaultCalculateViewLocation = ({
  itemTop: itemTop2,
  itemBottom,
  viewportTop,
  viewportBottom,
  locationParams: { behavior, align, ...rest2 }
}) => {
  if (itemTop2 < viewportTop) {
    return { ...rest2, behavior, align: align != null ? align : "start" };
  }
  if (itemBottom > viewportBottom) {
    return { ...rest2, behavior, align: align != null ? align : "end" };
  }
  return null;
};
const scrollIntoViewSystem = system(
  ([
    { sizes, totalCount, gap },
    { scrollTop, viewportHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollingInProgress },
    { scrollToIndex }
  ]) => {
    const scrollIntoView = stream();
    connect(
      pipe(
        scrollIntoView,
        withLatestFrom(sizes, viewportHeight, totalCount, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollTop),
        withLatestFrom(gap),
        map$3(([[viewLocation, sizes2, viewportHeight2, totalCount2, headerHeight2, fixedHeaderHeight2, fixedFooterHeight2, scrollTop2], gap2]) => {
          const { done, behavior, align, calculateViewLocation = defaultCalculateViewLocation, ...rest2 } = viewLocation;
          const actualIndex = originalIndexFromLocation(viewLocation, sizes2, totalCount2 - 1);
          const itemTop2 = offsetOf(actualIndex, sizes2.offsetTree, gap2) + headerHeight2 + fixedHeaderHeight2;
          const itemBottom = itemTop2 + findMaxKeyValue(sizes2.sizeTree, actualIndex)[1];
          const viewportTop = scrollTop2 + fixedHeaderHeight2;
          const viewportBottom = scrollTop2 + viewportHeight2 - fixedFooterHeight2;
          const location = calculateViewLocation({
            itemTop: itemTop2,
            itemBottom,
            viewportTop,
            viewportBottom,
            locationParams: { behavior, align, ...rest2 }
          });
          if (location) {
            done && handleNext(
              pipe(
                scrollingInProgress,
                filter((value) => value === false),
                // skips the initial publish of false, and the cleanup call.
                // but if scrollingInProgress is true, we skip the initial publish.
                skip(getValue$1(scrollingInProgress) ? 1 : 2)
              ),
              done
            );
          } else {
            done && done();
          }
          return location;
        }),
        filter((value) => value !== null)
      ),
      scrollToIndex
    );
    return {
      scrollIntoView
    };
  },
  tup(sizeSystem, domIOSystem, scrollToIndexSystem, listStateSystem, loggerSystem),
  { singleton: true }
);
const stateLoadSystem = system(
  ([
    { sizes, sizeRanges },
    { scrollTop, headerHeight },
    { initialTopMostItemIndex },
    { didMount },
    { useWindowScroll, windowScrollContainerState, windowViewportRect }
  ]) => {
    const getState = stream();
    const restoreStateFrom = statefulStream(void 0);
    const statefulWindowScrollContainerState = statefulStream(null);
    const statefulWindowViewportRect = statefulStream(null);
    connect(windowScrollContainerState, statefulWindowScrollContainerState);
    connect(windowViewportRect, statefulWindowViewportRect);
    subscribe(
      pipe(
        getState,
        withLatestFrom(sizes, scrollTop, useWindowScroll, statefulWindowScrollContainerState, statefulWindowViewportRect, headerHeight)
      ),
      ([callback, sizes2, scrollTop2, useWindowScroll2, windowScrollContainerState2, windowViewportRect2, headerHeight2]) => {
        const ranges = sizeTreeToRanges(sizes2.sizeTree);
        if (useWindowScroll2 && windowScrollContainerState2 !== null && windowViewportRect2 !== null) {
          scrollTop2 = windowScrollContainerState2.scrollTop - windowViewportRect2.offsetTop;
        }
        scrollTop2 -= headerHeight2;
        callback({ ranges, scrollTop: scrollTop2 });
      }
    );
    connect(pipe(restoreStateFrom, filter(isDefined), map$3(locationFromSnapshot)), initialTopMostItemIndex);
    connect(
      pipe(
        didMount,
        withLatestFrom(restoreStateFrom),
        filter(([, state]) => state !== void 0),
        distinctUntilChanged(),
        map$3(([, snapshot]) => {
          return snapshot.ranges;
        })
      ),
      sizeRanges
    );
    return {
      getState,
      restoreStateFrom
    };
  },
  tup(sizeSystem, domIOSystem, initialTopMostItemIndexSystem, propsReadySystem, windowScrollerSystem)
);
function locationFromSnapshot(snapshot) {
  return { offset: snapshot.scrollTop, index: 0, align: "start" };
}
const featureGroup1System = system(
  ([
    sizeRange,
    initialItemCount,
    propsReady,
    scrollSeek,
    totalListHeight,
    initialScrollTopSystem2,
    alignToBottom,
    windowScroller,
    scrollIntoView,
    logger2
  ]) => {
    return {
      ...sizeRange,
      ...initialItemCount,
      ...propsReady,
      ...scrollSeek,
      ...totalListHeight,
      ...initialScrollTopSystem2,
      ...alignToBottom,
      ...windowScroller,
      ...scrollIntoView,
      ...logger2
    };
  },
  tup(
    sizeRangeSystem,
    initialItemCountSystem,
    propsReadySystem,
    scrollSeekSystem,
    totalListHeightSystem,
    initialScrollTopSystem,
    alignToBottomSystem,
    windowScrollerSystem,
    scrollIntoViewSystem,
    loggerSystem
  )
);
const listSystem = system(
  ([
    {
      totalCount,
      sizeRanges,
      fixedItemSize,
      defaultItemSize,
      trackItemSizes,
      itemSize,
      data,
      firstItemIndex,
      groupIndices,
      statefulTotalCount,
      gap,
      sizes
    },
    { initialTopMostItemIndex, scrolledToInitialItem, initialItemFinalLocationReached },
    domIO,
    stateLoad,
    followOutput,
    { listState, topItemsIndexes, ...flags3 },
    { scrollToIndex },
    _,
    { topItemCount },
    { groupCounts },
    featureGroup1
  ]) => {
    connect(flags3.rangeChanged, featureGroup1.scrollSeekRangeChanged);
    connect(
      pipe(
        featureGroup1.windowViewportRect,
        map$3((value) => value.visibleHeight)
      ),
      domIO.viewportHeight
    );
    return {
      // input
      totalCount,
      data,
      firstItemIndex,
      sizeRanges,
      initialTopMostItemIndex,
      scrolledToInitialItem,
      initialItemFinalLocationReached,
      topItemsIndexes,
      topItemCount,
      groupCounts,
      fixedItemHeight: fixedItemSize,
      defaultItemHeight: defaultItemSize,
      gap,
      ...followOutput,
      // output
      statefulTotalCount,
      listState,
      scrollToIndex,
      trackItemSizes,
      itemSize,
      groupIndices,
      // exported from stateFlagsSystem
      ...flags3,
      // the bag of IO from featureGroup1System
      ...featureGroup1,
      ...domIO,
      sizes,
      ...stateLoad
    };
  },
  tup(
    sizeSystem,
    initialTopMostItemIndexSystem,
    domIOSystem,
    stateLoadSystem,
    followOutputSystem,
    listStateSystem,
    scrollToIndexSystem,
    upwardScrollFixSystem,
    topItemCountSystem,
    groupedListSystem,
    featureGroup1System
  )
);
const WEBKIT_STICKY = "-webkit-sticky";
const STICKY = "sticky";
const positionStickyCssValue = simpleMemoize(() => {
  if (typeof document === "undefined") {
    return STICKY;
  }
  const node = document.createElement("div");
  node.style.position = WEBKIT_STICKY;
  return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY;
});
function useWindowViewportRectRef(callback, customScrollParent, skipAnimationFrame) {
  const viewportInfo = React.useRef(null);
  const calculateInfo = React.useCallback(
    (element) => {
      if (element === null || !element.offsetParent) {
        return;
      }
      const rect = element.getBoundingClientRect();
      const visibleWidth = rect.width;
      let visibleHeight, offsetTop;
      if (customScrollParent) {
        const customScrollParentRect = customScrollParent.getBoundingClientRect();
        const deltaTop = rect.top - customScrollParentRect.top;
        visibleHeight = customScrollParentRect.height - Math.max(0, deltaTop);
        offsetTop = deltaTop + customScrollParent.scrollTop;
      } else {
        visibleHeight = window.innerHeight - Math.max(0, rect.top);
        offsetTop = rect.top + window.pageYOffset;
      }
      viewportInfo.current = {
        offsetTop,
        visibleHeight,
        visibleWidth
      };
      callback(viewportInfo.current);
    },
    [callback, customScrollParent]
  );
  const { callbackRef, ref: ref2 } = useSizeWithElRef(calculateInfo, true, skipAnimationFrame);
  const scrollAndResizeEventHandler = React.useCallback(() => {
    calculateInfo(ref2.current);
  }, [calculateInfo, ref2]);
  React.useEffect(() => {
    if (customScrollParent) {
      customScrollParent.addEventListener("scroll", scrollAndResizeEventHandler);
      const observer = new ResizeObserver(() => {
        requestAnimationFrame(scrollAndResizeEventHandler);
      });
      observer.observe(customScrollParent);
      return () => {
        customScrollParent.removeEventListener("scroll", scrollAndResizeEventHandler);
        observer.unobserve(customScrollParent);
      };
    } else {
      window.addEventListener("scroll", scrollAndResizeEventHandler);
      window.addEventListener("resize", scrollAndResizeEventHandler);
      return () => {
        window.removeEventListener("scroll", scrollAndResizeEventHandler);
        window.removeEventListener("resize", scrollAndResizeEventHandler);
      };
    }
  }, [scrollAndResizeEventHandler, customScrollParent]);
  return callbackRef;
}
const VirtuosoMockContext = React.createContext(void 0);
const VirtuosoGridMockContext = React.createContext(void 0);
function identity$6(value) {
  return value;
}
const listComponentPropsSystem = /* @__PURE__ */ system(() => {
  const itemContent = statefulStream((index2) => "Item ".concat(index2));
  const context2 = statefulStream(null);
  const groupContent = statefulStream((index2) => "Group ".concat(index2));
  const components = statefulStream({});
  const computeItemKey = statefulStream(identity$6);
  const HeaderFooterTag = statefulStream("div");
  const scrollerRef = statefulStream(noop$1);
  const distinctProp = (propName, defaultValue = null) => {
    return statefulStreamFromEmitter(
      pipe(
        components,
        map$3((components2) => components2[propName]),
        distinctUntilChanged()
      ),
      defaultValue
    );
  };
  return {
    context: context2,
    itemContent,
    groupContent,
    components,
    computeItemKey,
    HeaderFooterTag,
    scrollerRef,
    FooterComponent: distinctProp("Footer"),
    HeaderComponent: distinctProp("Header"),
    TopItemListComponent: distinctProp("TopItemList"),
    ListComponent: distinctProp("List", "div"),
    ItemComponent: distinctProp("Item", "div"),
    GroupComponent: distinctProp("Group", "div"),
    ScrollerComponent: distinctProp("Scroller", "div"),
    EmptyPlaceholder: distinctProp("EmptyPlaceholder"),
    ScrollSeekPlaceholder: distinctProp("ScrollSeekPlaceholder")
  };
});
const combinedSystem$2 = /* @__PURE__ */ system(([listSystem2, propsSystem]) => {
  return { ...listSystem2, ...propsSystem };
}, tup(listSystem, listComponentPropsSystem));
const DefaultScrollSeekPlaceholder$1 = ({ height }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height } });
const GROUP_STYLE = { position: positionStickyCssValue(), zIndex: 1, overflowAnchor: "none" };
const ITEM_STYLE$1 = { overflowAnchor: "none" };
const HORIZONTAL_ITEM_STYLE = { ...ITEM_STYLE$1, display: "inline-block", height: "100%" };
const Items$1 = /* @__PURE__ */ React.memo(function VirtuosoItems({ showTopList = false }) {
  const listState = useEmitterValue$2("listState");
  const sizeRanges = usePublisher$2("sizeRanges");
  const useWindowScroll = useEmitterValue$2("useWindowScroll");
  const customScrollParent = useEmitterValue$2("customScrollParent");
  const windowScrollContainerStateCallback = usePublisher$2("windowScrollContainerState");
  const _scrollContainerStateCallback = usePublisher$2("scrollContainerState");
  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;
  const itemContent = useEmitterValue$2("itemContent");
  const context2 = useEmitterValue$2("context");
  const groupContent = useEmitterValue$2("groupContent");
  const trackItemSizes = useEmitterValue$2("trackItemSizes");
  const itemSize = useEmitterValue$2("itemSize");
  const log = useEmitterValue$2("log");
  const listGap = usePublisher$2("gap");
  const horizontalDirection = useEmitterValue$2("horizontalDirection");
  const { callbackRef } = useChangedListContentsSizes(
    sizeRanges,
    itemSize,
    trackItemSizes,
    showTopList ? noop$1 : scrollContainerStateCallback,
    log,
    listGap,
    customScrollParent,
    horizontalDirection,
    useEmitterValue$2("skipAnimationFrameInResizeObserver")
  );
  const [deviation, setDeviation] = React.useState(0);
  useEmitter$2("deviation", (value) => {
    if (deviation !== value) {
      setDeviation(value);
    }
  });
  const EmptyPlaceholder = useEmitterValue$2("EmptyPlaceholder");
  const ScrollSeekPlaceholder = useEmitterValue$2("ScrollSeekPlaceholder") || DefaultScrollSeekPlaceholder$1;
  const ListComponent = useEmitterValue$2("ListComponent");
  const ItemComponent = useEmitterValue$2("ItemComponent");
  const GroupComponent = useEmitterValue$2("GroupComponent");
  const computeItemKey = useEmitterValue$2("computeItemKey");
  const isSeeking = useEmitterValue$2("isSeeking");
  const hasGroups2 = useEmitterValue$2("groupIndices").length > 0;
  const alignToBottom = useEmitterValue$2("alignToBottom");
  const initialItemFinalLocationReached = useEmitterValue$2("initialItemFinalLocationReached");
  const containerStyle = showTopList ? {} : {
    boxSizing: "border-box",
    ...horizontalDirection ? {
      whiteSpace: "nowrap",
      display: "inline-block",
      height: "100%",
      paddingLeft: listState.offsetTop,
      paddingRight: listState.offsetBottom,
      marginLeft: deviation !== 0 ? deviation : alignToBottom ? "auto" : 0
    } : {
      marginTop: deviation !== 0 ? deviation : alignToBottom ? "auto" : 0,
      paddingTop: listState.offsetTop,
      paddingBottom: listState.offsetBottom
    },
    ...initialItemFinalLocationReached ? {} : { visibility: "hidden" }
  };
  if (!showTopList && listState.totalCount === 0 && EmptyPlaceholder) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyPlaceholder, { ...contextPropIfNotDomElement(EmptyPlaceholder, context2) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ListComponent,
    {
      ...contextPropIfNotDomElement(ListComponent, context2),
      ref: callbackRef,
      style: containerStyle,
      "data-testid": showTopList ? "virtuoso-top-item-list" : "virtuoso-item-list",
      children: (showTopList ? listState.topItems : listState.items).map((item) => {
        const index2 = item.originalIndex;
        const key = computeItemKey(index2 + listState.firstItemIndex, item.data, context2);
        if (isSeeking) {
          return /* @__PURE__ */ reactExports.createElement(
            ScrollSeekPlaceholder,
            {
              ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context2),
              key,
              index: item.index,
              height: item.size,
              type: item.type || "item",
              ...item.type === "group" ? {} : { groupIndex: item.groupIndex }
            }
          );
        }
        if (item.type === "group") {
          return /* @__PURE__ */ reactExports.createElement(
            GroupComponent,
            {
              ...contextPropIfNotDomElement(GroupComponent, context2),
              key,
              "data-index": index2,
              "data-known-size": item.size,
              "data-item-index": item.index,
              style: GROUP_STYLE
            },
            groupContent(item.index, context2)
          );
        } else {
          return /* @__PURE__ */ reactExports.createElement(
            ItemComponent,
            {
              ...contextPropIfNotDomElement(ItemComponent, context2),
              ...itemPropIfNotDomElement(ItemComponent, item.data),
              key,
              "data-index": index2,
              "data-known-size": item.size,
              "data-item-index": item.index,
              "data-item-group-index": item.groupIndex,
              style: horizontalDirection ? HORIZONTAL_ITEM_STYLE : ITEM_STYLE$1
            },
            hasGroups2 ? itemContent(item.index, item.groupIndex, item.data, context2) : itemContent(item.index, item.data, context2)
          );
        }
      })
    }
  );
});
const scrollerStyle = {
  height: "100%",
  outline: "none",
  overflowY: "auto",
  position: "relative",
  WebkitOverflowScrolling: "touch"
};
const horizontalScrollerStyle = {
  outline: "none",
  overflowX: "auto",
  position: "relative"
};
const viewportStyle = (alignToBottom) => ({
  width: "100%",
  height: "100%",
  position: "absolute",
  top: 0,
  ...alignToBottom ? { display: "flex", flexDirection: "column" } : {}
});
const topItemListStyle = {
  width: "100%",
  position: positionStickyCssValue(),
  top: 0,
  zIndex: 1
};
function contextPropIfNotDomElement(element, context2) {
  if (typeof element === "string") {
    return void 0;
  }
  return { context: context2 };
}
function itemPropIfNotDomElement(element, item) {
  return { item: typeof element === "string" ? void 0 : item };
}
const Header$1 = /* @__PURE__ */ React.memo(function VirtuosoHeader() {
  const Header2 = useEmitterValue$2("HeaderComponent");
  const headerHeight = usePublisher$2("headerHeight");
  const HeaderFooterTag = useEmitterValue$2("HeaderFooterTag");
  const ref2 = useSize(
    React.useMemo(() => (el) => headerHeight(correctItemSize(el, "height")), [headerHeight]),
    true,
    useEmitterValue$2("skipAnimationFrameInResizeObserver")
  );
  const context2 = useEmitterValue$2("context");
  return Header2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(HeaderFooterTag, { ref: ref2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Header2, { ...contextPropIfNotDomElement(Header2, context2) }) }) : null;
});
const Footer$1 = /* @__PURE__ */ React.memo(function VirtuosoFooter() {
  const Footer2 = useEmitterValue$2("FooterComponent");
  const footerHeight = usePublisher$2("footerHeight");
  const HeaderFooterTag = useEmitterValue$2("HeaderFooterTag");
  const ref2 = useSize(
    React.useMemo(() => (el) => footerHeight(correctItemSize(el, "height")), [footerHeight]),
    true,
    useEmitterValue$2("skipAnimationFrameInResizeObserver")
  );
  const context2 = useEmitterValue$2("context");
  return Footer2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(HeaderFooterTag, { ref: ref2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Footer2, { ...contextPropIfNotDomElement(Footer2, context2) }) }) : null;
});
function buildScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {
  const Scroller2 = React.memo(function VirtuosoScroller({ style, children, ...props }) {
    const scrollContainerStateCallback = usePublisher2("scrollContainerState");
    const ScrollerComponent = useEmitterValue2("ScrollerComponent");
    const smoothScrollTargetReached = usePublisher2("smoothScrollTargetReached");
    const scrollerRefCallback = useEmitterValue2("scrollerRef");
    const context2 = useEmitterValue2("context");
    const horizontalDirection = useEmitterValue2("horizontalDirection") || false;
    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(
      scrollContainerStateCallback,
      smoothScrollTargetReached,
      ScrollerComponent,
      scrollerRefCallback,
      void 0,
      horizontalDirection
    );
    useEmitter2("scrollTo", scrollToCallback);
    useEmitter2("scrollBy", scrollByCallback);
    const defaultStyle = horizontalDirection ? horizontalScrollerStyle : scrollerStyle;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollerComponent,
      {
        ref: scrollerRef,
        style: { ...defaultStyle, ...style },
        "data-testid": "virtuoso-scroller",
        "data-virtuoso-scroller": true,
        tabIndex: 0,
        ...props,
        ...contextPropIfNotDomElement(ScrollerComponent, context2),
        children
      }
    );
  });
  return Scroller2;
}
function buildWindowScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {
  const Scroller2 = React.memo(function VirtuosoWindowScroller({ style, children, ...props }) {
    const scrollContainerStateCallback = usePublisher2("windowScrollContainerState");
    const ScrollerComponent = useEmitterValue2("ScrollerComponent");
    const smoothScrollTargetReached = usePublisher2("smoothScrollTargetReached");
    const totalListHeight = useEmitterValue2("totalListHeight");
    const deviation = useEmitterValue2("deviation");
    const customScrollParent = useEmitterValue2("customScrollParent");
    const context2 = useEmitterValue2("context");
    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(
      scrollContainerStateCallback,
      smoothScrollTargetReached,
      ScrollerComponent,
      noop$1,
      customScrollParent
    );
    useIsomorphicLayoutEffect(() => {
      scrollerRef.current = customScrollParent ? customScrollParent : window;
      return () => {
        scrollerRef.current = null;
      };
    }, [scrollerRef, customScrollParent]);
    useEmitter2("windowScrollTo", scrollToCallback);
    useEmitter2("scrollBy", scrollByCallback);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollerComponent,
      {
        style: { position: "relative", ...style, ...totalListHeight !== 0 ? { height: totalListHeight + deviation } : {} },
        "data-virtuoso-scroller": true,
        ...props,
        ...contextPropIfNotDomElement(ScrollerComponent, context2),
        children
      }
    );
  });
  return Scroller2;
}
const Viewport$2 = ({ children }) => {
  const ctx2 = React.useContext(VirtuosoMockContext);
  const viewportHeight = usePublisher$2("viewportHeight");
  const fixedItemHeight = usePublisher$2("fixedItemHeight");
  const alignToBottom = useEmitterValue$2("alignToBottom");
  const horizontalDirection = useEmitterValue$2("horizontalDirection");
  const viewportSizeCallbackMemo = React.useMemo(
    () => compose(viewportHeight, (el) => correctItemSize(el, horizontalDirection ? "width" : "height")),
    [viewportHeight, horizontalDirection]
  );
  const viewportRef = useSize(viewportSizeCallbackMemo, true, useEmitterValue$2("skipAnimationFrameInResizeObserver"));
  React.useEffect(() => {
    if (ctx2) {
      viewportHeight(ctx2.viewportHeight);
      fixedItemHeight(ctx2.itemHeight);
    }
  }, [ctx2, viewportHeight, fixedItemHeight]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: viewportStyle(alignToBottom), ref: viewportRef, "data-viewport-type": "element", children });
};
const WindowViewport$2 = ({ children }) => {
  const ctx2 = React.useContext(VirtuosoMockContext);
  const windowViewportRect = usePublisher$2("windowViewportRect");
  const fixedItemHeight = usePublisher$2("fixedItemHeight");
  const customScrollParent = useEmitterValue$2("customScrollParent");
  const viewportRef = useWindowViewportRectRef(
    windowViewportRect,
    customScrollParent,
    useEmitterValue$2("skipAnimationFrameInResizeObserver")
  );
  const alignToBottom = useEmitterValue$2("alignToBottom");
  React.useEffect(() => {
    if (ctx2) {
      fixedItemHeight(ctx2.itemHeight);
      windowViewportRect({ offsetTop: 0, visibleHeight: ctx2.viewportHeight, visibleWidth: 100 });
    }
  }, [ctx2, windowViewportRect, fixedItemHeight]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: viewportRef, style: viewportStyle(alignToBottom), "data-viewport-type": "window", children });
};
const TopItemListContainer = ({ children }) => {
  const TopItemList = useEmitterValue$2("TopItemListComponent") || "div";
  const headerHeight = useEmitterValue$2("headerHeight");
  const style = { ...topItemListStyle, marginTop: "".concat(headerHeight, "px") };
  const context2 = useEmitterValue$2("context");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TopItemList, { style, ...contextPropIfNotDomElement(TopItemList, context2), children });
};
const ListRoot = /* @__PURE__ */ React.memo(function VirtuosoRoot(props) {
  const useWindowScroll = useEmitterValue$2("useWindowScroll");
  const showTopList = useEmitterValue$2("topItemsIndexes").length > 0;
  const customScrollParent = useEmitterValue$2("customScrollParent");
  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$2 : Scroller$2;
  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$2 : Viewport$2;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TheScroller, { ...props, children: [
    showTopList && /* @__PURE__ */ jsxRuntimeExports.jsx(TopItemListContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Items$1, { showTopList: true }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TheViewport, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header$1, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Items$1, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Footer$1, {})
    ] })
  ] });
});
const {
  Component: List$1,
  usePublisher: usePublisher$2,
  useEmitterValue: useEmitterValue$2,
  useEmitter: useEmitter$2
} = /* @__PURE__ */ systemToComponent(
  combinedSystem$2,
  {
    required: {},
    optional: {
      restoreStateFrom: "restoreStateFrom",
      context: "context",
      followOutput: "followOutput",
      itemContent: "itemContent",
      groupContent: "groupContent",
      overscan: "overscan",
      increaseViewportBy: "increaseViewportBy",
      totalCount: "totalCount",
      groupCounts: "groupCounts",
      topItemCount: "topItemCount",
      firstItemIndex: "firstItemIndex",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      components: "components",
      atBottomThreshold: "atBottomThreshold",
      atTopThreshold: "atTopThreshold",
      computeItemKey: "computeItemKey",
      defaultItemHeight: "defaultItemHeight",
      fixedItemHeight: "fixedItemHeight",
      itemSize: "itemSize",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      headerFooterTag: "HeaderFooterTag",
      data: "data",
      initialItemCount: "initialItemCount",
      initialScrollTop: "initialScrollTop",
      alignToBottom: "alignToBottom",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel",
      horizontalDirection: "horizontalDirection",
      skipAnimationFrameInResizeObserver: "skipAnimationFrameInResizeObserver"
    },
    methods: {
      scrollToIndex: "scrollToIndex",
      scrollIntoView: "scrollIntoView",
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      autoscrollToBottom: "autoscrollToBottom",
      getState: "getState"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      totalListHeightChanged: "totalListHeightChanged",
      itemsRendered: "itemsRendered",
      groupIndices: "groupIndices"
    }
  },
  ListRoot
);
const Scroller$2 = /* @__PURE__ */ buildScroller({ usePublisher: usePublisher$2, useEmitterValue: useEmitterValue$2, useEmitter: useEmitter$2 });
const WindowScroller$2 = /* @__PURE__ */ buildWindowScroller({ usePublisher: usePublisher$2, useEmitterValue: useEmitterValue$2, useEmitter: useEmitter$2 });
const Virtuoso = List$1;
const INITIAL_GRID_STATE = {
  items: [],
  offsetBottom: 0,
  offsetTop: 0,
  top: 0,
  bottom: 0,
  itemHeight: 0,
  itemWidth: 0
};
const PROBE_GRID_STATE = {
  items: [{ index: 0 }],
  offsetBottom: 0,
  offsetTop: 0,
  top: 0,
  bottom: 0,
  itemHeight: 0,
  itemWidth: 0
};
const { round: round$1, ceil, floor, min: min$1, max: max$1 } = Math;
function buildProbeGridState(items) {
  return {
    ...PROBE_GRID_STATE,
    items
  };
}
function buildItems(startIndex, endIndex, data) {
  return Array.from({ length: endIndex - startIndex + 1 }).map((_, i2) => {
    const dataItem = data === null ? null : data[i2 + startIndex];
    return { index: i2 + startIndex, data: dataItem };
  });
}
function gapComparator(prev, next) {
  return prev && prev.column === next.column && prev.row === next.row;
}
function dimensionComparator(prev, next) {
  return prev && prev.width === next.width && prev.height === next.height;
}
const gridSystem = /* @__PURE__ */ system(
  ([
    { overscan, visibleRange, listBoundary, increaseViewportBy },
    { scrollTop, viewportHeight, scrollBy, scrollTo, smoothScrollTargetReached, scrollContainerState, footerHeight, headerHeight },
    stateFlags,
    scrollSeek,
    { propsReady, didMount },
    { windowViewportRect, useWindowScroll, customScrollParent, windowScrollContainerState, windowScrollTo },
    log
  ]) => {
    const totalCount = statefulStream(0);
    const initialItemCount = statefulStream(0);
    const gridState = statefulStream(INITIAL_GRID_STATE);
    const viewportDimensions = statefulStream({ height: 0, width: 0 });
    const itemDimensions = statefulStream({ height: 0, width: 0 });
    const scrollToIndex = stream();
    const scrollHeight = stream();
    const deviation = statefulStream(0);
    const data = statefulStream(null);
    const gap = statefulStream({ row: 0, column: 0 });
    const stateChanged = stream();
    const restoreStateFrom = stream();
    const stateRestoreInProgress = statefulStream(false);
    const initialTopMostItemIndex = statefulStream(0);
    const scrolledToInitialItem = statefulStream(true);
    const scrollScheduled = statefulStream(false);
    const horizontalDirection = statefulStream(false);
    subscribe(
      pipe(
        didMount,
        withLatestFrom(initialTopMostItemIndex),
        filter(([_, location]) => !!location)
      ),
      () => {
        publish(scrolledToInitialItem, false);
      }
    );
    subscribe(
      pipe(
        combineLatest(didMount, scrolledToInitialItem, itemDimensions, viewportDimensions, initialTopMostItemIndex, scrollScheduled),
        filter(([didMount2, scrolledToInitialItem2, itemDimensions2, viewportDimensions2, , scrollScheduled2]) => {
          return didMount2 && !scrolledToInitialItem2 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0 && !scrollScheduled2;
        })
      ),
      ([, , , , initialTopMostItemIndex2]) => {
        publish(scrollScheduled, true);
        skipFrames(1, () => {
          publish(scrollToIndex, initialTopMostItemIndex2);
        });
        handleNext(pipe(scrollTop), () => {
          publish(listBoundary, [0, 0]);
          publish(scrolledToInitialItem, true);
        });
      }
    );
    connect(
      pipe(
        restoreStateFrom,
        filter((value) => value !== void 0 && value !== null && value.scrollTop > 0),
        mapTo(0)
      ),
      initialItemCount
    );
    subscribe(
      pipe(
        didMount,
        withLatestFrom(restoreStateFrom),
        filter(([, snapshot]) => snapshot !== void 0 && snapshot !== null)
      ),
      ([, snapshot]) => {
        if (!snapshot) {
          return;
        }
        publish(viewportDimensions, snapshot.viewport), publish(itemDimensions, snapshot == null ? void 0 : snapshot.item);
        publish(gap, snapshot.gap);
        if (snapshot.scrollTop > 0) {
          publish(stateRestoreInProgress, true);
          handleNext(pipe(scrollTop, skip(1)), (_value) => {
            publish(stateRestoreInProgress, false);
          });
          publish(scrollTo, { top: snapshot.scrollTop });
        }
      }
    );
    connect(
      pipe(
        viewportDimensions,
        map$3(({ height }) => height)
      ),
      viewportHeight
    );
    connect(
      pipe(
        combineLatest(
          duc(viewportDimensions, dimensionComparator),
          duc(itemDimensions, dimensionComparator),
          duc(gap, (prev, next) => prev && prev.column === next.column && prev.row === next.row),
          duc(scrollTop)
        ),
        map$3(([viewport, item, gap2, scrollTop2]) => ({
          viewport,
          item,
          gap: gap2,
          scrollTop: scrollTop2
        }))
      ),
      stateChanged
    );
    connect(
      pipe(
        combineLatest(
          duc(totalCount),
          visibleRange,
          duc(gap, gapComparator),
          duc(itemDimensions, dimensionComparator),
          duc(viewportDimensions, dimensionComparator),
          duc(data),
          duc(initialItemCount),
          duc(stateRestoreInProgress),
          duc(scrolledToInitialItem),
          duc(initialTopMostItemIndex)
        ),
        filter(([, , , , , , , stateRestoreInProgress2]) => {
          return !stateRestoreInProgress2;
        }),
        map$3(
          ([
            totalCount2,
            [startOffset, endOffset],
            gap2,
            item,
            viewport,
            data2,
            initialItemCount2,
            ,
            scrolledToInitialItem2,
            initialTopMostItemIndex2
          ]) => {
            const { row: rowGap, column: columnGap } = gap2;
            const { height: itemHeight, width: itemWidth } = item;
            const { width: viewportWidth } = viewport;
            if (initialItemCount2 === 0 && (totalCount2 === 0 || viewportWidth === 0)) {
              return INITIAL_GRID_STATE;
            }
            if (itemWidth === 0) {
              const startIndex2 = getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2);
              const endIndex2 = Math.max(startIndex2 + initialItemCount2 - 1, 0);
              return buildProbeGridState(buildItems(startIndex2, endIndex2, data2));
            }
            const perRow = itemsPerRow(viewportWidth, itemWidth, columnGap);
            let startIndex;
            let endIndex;
            if (!scrolledToInitialItem2) {
              startIndex = 0;
              endIndex = -1;
            } else if (startOffset === 0 && endOffset === 0 && initialItemCount2 > 0) {
              startIndex = 0;
              endIndex = initialItemCount2 - 1;
            } else {
              startIndex = perRow * floor((startOffset + rowGap) / (itemHeight + rowGap));
              endIndex = perRow * ceil((endOffset + rowGap) / (itemHeight + rowGap)) - 1;
              endIndex = min$1(totalCount2 - 1, max$1(endIndex, perRow - 1));
              startIndex = min$1(endIndex, max$1(0, startIndex));
            }
            const items = buildItems(startIndex, endIndex, data2);
            const { top, bottom } = gridLayout(viewport, gap2, item, items);
            const rowCount = ceil(totalCount2 / perRow);
            const totalHeight = rowCount * itemHeight + (rowCount - 1) * rowGap;
            const offsetBottom = totalHeight - bottom;
            return { items, offsetTop: top, offsetBottom, top, bottom, itemHeight, itemWidth };
          }
        )
      ),
      gridState
    );
    connect(
      pipe(
        data,
        filter((data2) => data2 !== null),
        map$3((data2) => data2.length)
      ),
      totalCount
    );
    connect(
      pipe(
        combineLatest(viewportDimensions, itemDimensions, gridState, gap),
        filter(([viewportDimensions2, itemDimensions2, { items }]) => {
          return items.length > 0 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0;
        }),
        map$3(([viewportDimensions2, itemDimensions2, { items }, gap2]) => {
          const { top, bottom } = gridLayout(viewportDimensions2, gap2, itemDimensions2, items);
          return [top, bottom];
        }),
        distinctUntilChanged(tupleComparator)
      ),
      listBoundary
    );
    const hasScrolled = statefulStream(false);
    connect(
      pipe(
        scrollTop,
        withLatestFrom(hasScrolled),
        map$3(([scrollTop2, hasScrolled2]) => {
          return hasScrolled2 || scrollTop2 !== 0;
        })
      ),
      hasScrolled
    );
    const endReached = streamFromEmitter(
      pipe(
        duc(gridState),
        filter(({ items }) => items.length > 0),
        withLatestFrom(totalCount, hasScrolled),
        filter(([{ items }, totalCount2, hasScrolled2]) => hasScrolled2 && items[items.length - 1].index === totalCount2 - 1),
        map$3(([, totalCount2]) => totalCount2 - 1),
        distinctUntilChanged()
      )
    );
    const startReached = streamFromEmitter(
      pipe(
        duc(gridState),
        filter(({ items }) => {
          return items.length > 0 && items[0].index === 0;
        }),
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        mapTo(0),
        distinctUntilChanged()
      )
    );
    const rangeChanged = streamFromEmitter(
      pipe(
        duc(gridState),
        withLatestFrom(stateRestoreInProgress),
        filter(([{ items }, stateRestoreInProgress2]) => items.length > 0 && !stateRestoreInProgress2),
        map$3(([{ items }]) => {
          return {
            startIndex: items[0].index,
            endIndex: items[items.length - 1].index
          };
        }),
        distinctUntilChanged(rangeComparator),
        throttleTime(0)
      )
    );
    connect(rangeChanged, scrollSeek.scrollSeekRangeChanged);
    connect(
      pipe(
        scrollToIndex,
        withLatestFrom(viewportDimensions, itemDimensions, totalCount, gap),
        map$3(([location, viewportDimensions2, itemDimensions2, totalCount2, gap2]) => {
          const normalLocation = normalizeIndexLocation(location);
          const { align, behavior, offset: offset2 } = normalLocation;
          let index2 = normalLocation.index;
          if (index2 === "LAST") {
            index2 = totalCount2 - 1;
          }
          index2 = max$1(0, index2, min$1(totalCount2 - 1, index2));
          let top = itemTop(viewportDimensions2, gap2, itemDimensions2, index2);
          if (align === "end") {
            top = round$1(top - viewportDimensions2.height + itemDimensions2.height);
          } else if (align === "center") {
            top = round$1(top - viewportDimensions2.height / 2 + itemDimensions2.height / 2);
          }
          if (offset2) {
            top += offset2;
          }
          return { top, behavior };
        })
      ),
      scrollTo
    );
    const totalListHeight = statefulStreamFromEmitter(
      pipe(
        gridState,
        map$3((gridState2) => {
          return gridState2.offsetBottom + gridState2.bottom;
        })
      ),
      0
    );
    connect(
      pipe(
        windowViewportRect,
        map$3((viewportInfo) => ({ width: viewportInfo.visibleWidth, height: viewportInfo.visibleHeight }))
      ),
      viewportDimensions
    );
    return {
      // input
      data,
      totalCount,
      viewportDimensions,
      itemDimensions,
      scrollTop,
      scrollHeight,
      overscan,
      increaseViewportBy,
      scrollBy,
      scrollTo,
      scrollToIndex,
      smoothScrollTargetReached,
      windowViewportRect,
      windowScrollTo,
      useWindowScroll,
      customScrollParent,
      windowScrollContainerState,
      deviation,
      scrollContainerState,
      footerHeight,
      headerHeight,
      initialItemCount,
      gap,
      restoreStateFrom,
      ...scrollSeek,
      initialTopMostItemIndex,
      horizontalDirection,
      // output
      gridState,
      totalListHeight,
      ...stateFlags,
      startReached,
      endReached,
      rangeChanged,
      stateChanged,
      propsReady,
      stateRestoreInProgress,
      ...log
    };
  },
  tup(sizeRangeSystem, domIOSystem, stateFlagsSystem, scrollSeekSystem, propsReadySystem, windowScrollerSystem, loggerSystem)
);
function gridLayout(viewport, gap, item, items) {
  const { height: itemHeight } = item;
  if (itemHeight === void 0 || items.length === 0) {
    return { top: 0, bottom: 0 };
  }
  const top = itemTop(viewport, gap, item, items[0].index);
  const bottom = itemTop(viewport, gap, item, items[items.length - 1].index) + itemHeight;
  return { top, bottom };
}
function itemTop(viewport, gap, item, index2) {
  const perRow = itemsPerRow(viewport.width, item.width, gap.column);
  const rowCount = floor(index2 / perRow);
  const top = rowCount * item.height + max$1(0, rowCount - 1) * gap.row;
  return top > 0 ? top + gap.row : top;
}
function itemsPerRow(viewportWidth, itemWidth, gap) {
  return max$1(1, floor((viewportWidth + gap) / (floor(itemWidth) + gap)));
}
const gridComponentPropsSystem = /* @__PURE__ */ system(() => {
  const itemContent = statefulStream((index2) => "Item ".concat(index2));
  const components = statefulStream({});
  const context2 = statefulStream(null);
  const itemClassName = statefulStream("virtuoso-grid-item");
  const listClassName = statefulStream("virtuoso-grid-list");
  const computeItemKey = statefulStream(identity$6);
  const headerFooterTag = statefulStream("div");
  const scrollerRef = statefulStream(noop$1);
  const distinctProp = (propName, defaultValue = null) => {
    return statefulStreamFromEmitter(
      pipe(
        components,
        map$3((components2) => components2[propName]),
        distinctUntilChanged()
      ),
      defaultValue
    );
  };
  const readyStateChanged = statefulStream(false);
  const reportReadyState = statefulStream(false);
  connect(duc(reportReadyState), readyStateChanged);
  return {
    readyStateChanged,
    reportReadyState,
    context: context2,
    itemContent,
    components,
    computeItemKey,
    itemClassName,
    listClassName,
    headerFooterTag,
    scrollerRef,
    FooterComponent: distinctProp("Footer"),
    HeaderComponent: distinctProp("Header"),
    ListComponent: distinctProp("List", "div"),
    ItemComponent: distinctProp("Item", "div"),
    ScrollerComponent: distinctProp("Scroller", "div"),
    ScrollSeekPlaceholder: distinctProp("ScrollSeekPlaceholder", "div")
  };
});
const combinedSystem$1 = /* @__PURE__ */ system(([gridSystem2, gridComponentPropsSystem2]) => {
  return { ...gridSystem2, ...gridComponentPropsSystem2 };
}, tup(gridSystem, gridComponentPropsSystem));
const GridItems = /* @__PURE__ */ React.memo(function GridItems2() {
  const gridState = useEmitterValue$1("gridState");
  const listClassName = useEmitterValue$1("listClassName");
  const itemClassName = useEmitterValue$1("itemClassName");
  const itemContent = useEmitterValue$1("itemContent");
  const computeItemKey = useEmitterValue$1("computeItemKey");
  const isSeeking = useEmitterValue$1("isSeeking");
  const scrollHeightCallback = usePublisher$1("scrollHeight");
  const ItemComponent = useEmitterValue$1("ItemComponent");
  const ListComponent = useEmitterValue$1("ListComponent");
  const ScrollSeekPlaceholder = useEmitterValue$1("ScrollSeekPlaceholder");
  const context2 = useEmitterValue$1("context");
  const itemDimensions = usePublisher$1("itemDimensions");
  const gridGap = usePublisher$1("gap");
  const log = useEmitterValue$1("log");
  const stateRestoreInProgress = useEmitterValue$1("stateRestoreInProgress");
  const reportReadyState = usePublisher$1("reportReadyState");
  const listRef = useSize(
    React.useMemo(
      () => (el) => {
        const scrollHeight = el.parentElement.parentElement.scrollHeight;
        scrollHeightCallback(scrollHeight);
        const firstItem = el.firstChild;
        if (firstItem) {
          const { width, height } = firstItem.getBoundingClientRect();
          itemDimensions({ width, height });
        }
        gridGap({
          row: resolveGapValue("row-gap", getComputedStyle(el).rowGap, log),
          column: resolveGapValue("column-gap", getComputedStyle(el).columnGap, log)
        });
      },
      [scrollHeightCallback, itemDimensions, gridGap, log]
    ),
    true,
    false
  );
  useIsomorphicLayoutEffect(() => {
    if (gridState.itemHeight > 0 && gridState.itemWidth > 0) {
      reportReadyState(true);
    }
  }, [gridState]);
  if (stateRestoreInProgress) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ListComponent,
    {
      ref: listRef,
      className: listClassName,
      ...contextPropIfNotDomElement(ListComponent, context2),
      style: { paddingTop: gridState.offsetTop, paddingBottom: gridState.offsetBottom },
      "data-testid": "virtuoso-item-list",
      children: gridState.items.map((item) => {
        const key = computeItemKey(item.index, item.data, context2);
        return isSeeking ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          ScrollSeekPlaceholder,
          {
            ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context2),
            index: item.index,
            height: gridState.itemHeight,
            width: gridState.itemWidth
          },
          key
        ) : /* @__PURE__ */ reactExports.createElement(
          ItemComponent,
          {
            ...contextPropIfNotDomElement(ItemComponent, context2),
            className: itemClassName,
            "data-index": item.index,
            key
          },
          itemContent(item.index, item.data, context2)
        );
      })
    }
  );
});
const Header = React.memo(function VirtuosoHeader2() {
  const Header2 = useEmitterValue$1("HeaderComponent");
  const headerHeight = usePublisher$1("headerHeight");
  const HeaderFooterTag = useEmitterValue$1("headerFooterTag");
  const ref2 = useSize(
    React.useMemo(() => (el) => headerHeight(correctItemSize(el, "height")), [headerHeight]),
    true,
    false
  );
  const context2 = useEmitterValue$1("context");
  return Header2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(HeaderFooterTag, { ref: ref2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Header2, { ...contextPropIfNotDomElement(Header2, context2) }) }) : null;
});
const Footer = React.memo(function VirtuosoGridFooter() {
  const Footer2 = useEmitterValue$1("FooterComponent");
  const footerHeight = usePublisher$1("footerHeight");
  const HeaderFooterTag = useEmitterValue$1("headerFooterTag");
  const ref2 = useSize(
    React.useMemo(() => (el) => footerHeight(correctItemSize(el, "height")), [footerHeight]),
    true,
    false
  );
  const context2 = useEmitterValue$1("context");
  return Footer2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(HeaderFooterTag, { ref: ref2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Footer2, { ...contextPropIfNotDomElement(Footer2, context2) }) }) : null;
});
const Viewport$1 = ({ children }) => {
  const ctx2 = React.useContext(VirtuosoGridMockContext);
  const itemDimensions = usePublisher$1("itemDimensions");
  const viewportDimensions = usePublisher$1("viewportDimensions");
  const viewportRef = useSize(
    React.useMemo(
      () => (el) => {
        viewportDimensions(el.getBoundingClientRect());
      },
      [viewportDimensions]
    ),
    true,
    false
  );
  React.useEffect(() => {
    if (ctx2) {
      viewportDimensions({ height: ctx2.viewportHeight, width: ctx2.viewportWidth });
      itemDimensions({ height: ctx2.itemHeight, width: ctx2.itemWidth });
    }
  }, [ctx2, viewportDimensions, itemDimensions]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: viewportStyle(false), ref: viewportRef, children });
};
const WindowViewport$1 = ({ children }) => {
  const ctx2 = React.useContext(VirtuosoGridMockContext);
  const windowViewportRect = usePublisher$1("windowViewportRect");
  const itemDimensions = usePublisher$1("itemDimensions");
  const customScrollParent = useEmitterValue$1("customScrollParent");
  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent, false);
  React.useEffect(() => {
    if (ctx2) {
      itemDimensions({ height: ctx2.itemHeight, width: ctx2.itemWidth });
      windowViewportRect({ offsetTop: 0, visibleHeight: ctx2.viewportHeight, visibleWidth: ctx2.viewportWidth });
    }
  }, [ctx2, windowViewportRect, itemDimensions]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: viewportRef, style: viewportStyle(false), children });
};
const GridRoot = /* @__PURE__ */ React.memo(function GridRoot2({ ...props }) {
  const useWindowScroll = useEmitterValue$1("useWindowScroll");
  const customScrollParent = useEmitterValue$1("customScrollParent");
  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$1 : Scroller$1;
  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$1 : Viewport$1;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TheScroller, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TheViewport, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(GridItems, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, {})
  ] }) });
});
const {
  Component: Grid,
  usePublisher: usePublisher$1,
  useEmitterValue: useEmitterValue$1,
  useEmitter: useEmitter$1
} = /* @__PURE__ */ systemToComponent(
  combinedSystem$1,
  {
    optional: {
      context: "context",
      totalCount: "totalCount",
      overscan: "overscan",
      itemContent: "itemContent",
      components: "components",
      computeItemKey: "computeItemKey",
      data: "data",
      initialItemCount: "initialItemCount",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      headerFooterTag: "headerFooterTag",
      listClassName: "listClassName",
      itemClassName: "itemClassName",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel",
      restoreStateFrom: "restoreStateFrom",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      increaseViewportBy: "increaseViewportBy"
    },
    methods: {
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      scrollToIndex: "scrollToIndex"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      stateChanged: "stateChanged",
      readyStateChanged: "readyStateChanged"
    }
  },
  GridRoot
);
const Scroller$1 = /* @__PURE__ */ buildScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });
const WindowScroller$1 = /* @__PURE__ */ buildWindowScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });
function resolveGapValue(property2, value, log) {
  if (value !== "normal" && !(value == null ? void 0 : value.endsWith("px"))) {
    log("".concat(property2, " was not resolved to pixel value correctly"), value, LogLevel.WARN);
  }
  if (value === "normal") {
    return 0;
  }
  return parseInt(value != null ? value : "0", 10);
}
function useDragNearViewportEdge(virtuosoWrapperRef) {
  const [isNearTop, setIsNearTop] = reactExports.useState(false);
  const [isNearBottom, setIsNearBottom] = reactExports.useState(false);
  const threshold = 50;
  const updateViewportEdgeProximity = (currentOffset2, panelWidth) => {
    if (!currentOffset2 || !virtuosoWrapperRef.current) return;
    const wrapperBounds = virtuosoWrapperRef.current.getBoundingClientRect();
    const adjustedLeft = wrapperBounds.left + panelWidth;
    const adjustedRight = wrapperBounds.right + panelWidth;
    const isInVirtuoso = currentOffset2.x >= adjustedLeft && currentOffset2.x <= adjustedRight && currentOffset2.y >= wrapperBounds.top && currentOffset2.y <= wrapperBounds.bottom;
    if (!isInVirtuoso) {
      setIsNearTop(false);
      setIsNearBottom(false);
      return;
    }
    const distanceFromTop = currentOffset2.y - wrapperBounds.top;
    const distanceFromBottom = wrapperBounds.bottom - currentOffset2.y;
    setIsNearTop(distanceFromTop <= threshold);
    setIsNearBottom(distanceFromBottom <= threshold);
  };
  const { isDragging: isDragging2, currentOffset } = useDragLayer((monitor) => ({
    isDragging: monitor.isDragging(),
    currentOffset: monitor.getClientOffset()
  }));
  reactExports.useEffect(() => {
    const screenWidth = window.innerWidth;
    let panelWidth;
    if (screenWidth >= 1200) {
      panelWidth = 450;
    } else if (screenWidth >= 768) {
      panelWidth = 400;
    } else {
      panelWidth = 400;
    }
    if (isDragging2) {
      updateViewportEdgeProximity(currentOffset, panelWidth);
    } else {
      setIsNearTop(false);
      setIsNearBottom(false);
    }
  }, [isDragging2, currentOffset]);
  return { isNearTop, isNearBottom };
}
function ContentPanel({ designMode }, ref2) {
  const { t: t2 } = useTranslation(["design", "run"]);
  const theme = useTheme();
  const inDesgin = designMode == DESIGN_SURVEY_MODE.DESIGN;
  const groups = useSelector((state) => {
    var _a;
    return ((_a = state.designState["Survey"]) == null ? void 0 : _a.children) || [];
  });
  const headerImage = useSelector((state) => {
    var _a, _b;
    return (_b = (_a = state.designState["Survey"]) == null ? void 0 : _a.resources) == null ? void 0 : _b.headerImage;
  });
  useSelector(
    (state) => {
      var _a, _b;
      return (_b = (_a = state.designState["Survey"]) == null ? void 0 : _a.resources) == null ? void 0 : _b.backgroundImage;
    }
  );
  const groupsEmpty = !groups.length;
  const welcomeGroupExists = reactExports.useMemo(() => {
    let returnResult = false;
    groups == null ? void 0 : groups.forEach((group3) => {
      var _a;
      if ((group3 == null ? void 0 : group3.type) === "welcome" || ((_a = group3.groupType) == null ? void 0 : _a.toLowerCase()) === "welcome") {
        returnResult = true;
      }
    });
    return returnResult;
  }, [groups]);
  const items = reactExports.useMemo(() => {
    var _a;
    const list2 = [];
    if (headerImage) {
      list2.push({ name: ELEMENTS.IMAGE });
    }
    if (!welcomeGroupExists) {
      list2.push({ name: ELEMENTS.DROP_AREA, index: 0 });
    }
    for (let i2 = 0; i2 < groups.length; i2++) {
      list2.push({ name: ELEMENTS.GROUP, group: groups[i2], index: i2 });
      if (groups[i2].type !== "end" && ((_a = groups[i2].groupType) == null ? void 0 : _a.toLowerCase()) !== "end") {
        list2.push({ name: ELEMENTS.DROP_AREA, group: groups[i2], index: i2 + 1 });
      }
    }
    list2.push({ name: ELEMENTS.FOOTER });
    return list2;
  }, [groups, t2, headerImage]);
  const virtuosoRef = reactExports.useRef(null);
  const virtuosoWrapperRef = reactExports.useRef(null);
  const { isNearBottom, isNearTop } = useDragNearViewportEdge(virtuosoWrapperRef);
  reactExports.useEffect(() => {
    let animationFrameId;
    const performScroll = () => {
      if (virtuosoRef.current) {
        if (isNearBottom) {
          virtuosoRef.current.scrollBy({ top: 6, behavior: "auto" });
        } else if (isNearTop) {
          virtuosoRef.current.scrollBy({ top: -6, behavior: "auto" });
        }
        animationFrameId = requestAnimationFrame(performScroll);
      }
    };
    if (isNearTop || isNearBottom) {
      animationFrameId = requestAnimationFrame(performScroll);
    }
    return () => {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
    };
  }, [isNearTop, isNearBottom]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      ref: ref2,
      className: "content-panel ".concat(styles$J.contentPanel),
      style: {
        backgroundColor: theme.palette.background.default,
        fontFamily: theme.textStyles.text.font,
        color: theme.textStyles.text.color,
        fontSize: theme.textStyles.text.size
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ref: virtuosoWrapperRef, width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Virtuoso,
        {
          ref: virtuosoRef,
          data: items,
          className: styles$J.virtuosoStyle,
          itemContent: (index2, item) => {
            switch (item.name) {
              case ELEMENTS.IMAGE:
                return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$J.cardMediaContent, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    CardMedia,
                    {
                      className: styles$J.cardImage,
                      component: "img",
                      image: buildResourceUrl(headerImage),
                      height: "140"
                    }
                  ),
                  inDesgin && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorDisplay$1, { code: "Survey" })
                ] });
              case ELEMENTS.DROP_AREA:
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  GroupDropArea,
                  {
                    emptySurvey: groupsEmpty,
                    t: t2,
                    index: item.index,
                    groupsCount: groups.length
                  }
                );
              case ELEMENTS.GROUP:
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  GroupDesign$1,
                  {
                    t: t2,
                    designMode,
                    code: item.group.code,
                    index: item.index
                  }
                );
              case ELEMENTS.FOOTER:
                return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$J.footer });
            }
          }
        }
      ) })
    }
  );
}
const ContentPanel$1 = React.forwardRef(ContentPanel);
const ELEMENTS = {
  IMAGE: "IMAGE",
  GROUP: "GROUP",
  DROP_AREA: "DROP_AREA",
  FOOTER: "FOOTER"
};
function FieldSize({
  label: label2,
  rule: rule3,
  t: t2,
  defaultValue,
  code,
  lowerBound,
  upperBound
}) {
  const dispatch = useDispatch();
  const stateValue = useSelector((state) => {
    return state.designState[code][rule3] || defaultValue;
  });
  const [value, setValue4] = reactExports.useState(stateValue);
  const onValueChange = (event) => {
    setValue4(event.target.value);
    if (value >= lowerBound && value <= upperBound) {
      dispatch(
        changeAttribute({
          code,
          key: rule3,
          value: Math.max(lowerBound, Math.min(upperBound, event.target.value))
        })
      );
    }
  };
  const isError = value != stateValue;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { children: [
      label2,
      ":"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextField,
      {
        label: label2,
        error: isError,
        variant: "outlined",
        type: "number",
        helperText: isError ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Trans,
          {
            t: t2,
            values: {
              lower_bound: lowerBound,
              upper_bound: upperBound,
              setup_value: stateValue,
              label: label2
            },
            i18nKey: "value_beyond_bounds"
          }
        ) : null,
        size: "small",
        style: { maxWidth: "200px" },
        value,
        onChange: (event) => onValueChange(event)
      }
    )
  ] });
}
const FieldSize$1 = React.memo(FieldSize);
const showHint = "_showHint_9iocv_1";
const inputValue$1 = "_inputValue_9iocv_9";
const styles$i = {
  showHint,
  inputValue: inputValue$1
};
function ShowHint({ code, t: t2 }) {
  const dispatch = useDispatch();
  const showHint2 = useSelector((state) => {
    return state.designState[code].showHint || false;
  });
  const setCheckedHint = (value) => {
    dispatch(changeAttribute({ code, key: "showHint", value }));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$i.showHint, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: t2("show_question_hint") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Switch,
        {
          checked: showHint2,
          onChange: (event) => setCheckedHint(event.target.checked)
        }
      )
    ] }),
    showHint2 && /* @__PURE__ */ jsxRuntimeExports.jsx(ContentEditor, { code, objectName: "hint" })
  ] });
}
function ContentEditor({ code, objectName, title: title2 }) {
  const dispatch = useDispatch();
  const setContentValue = (lang2, value) => {
    dispatch(changeContent({ code, key: objectName, lang: lang2, value }));
  };
  const languagesList = useSelector((state) => {
    return state.designState.langInfo.languagesList;
  });
  const hintObj = useSelector((state) => {
    var _a;
    return (_a = state.designState[code].content) == null ? void 0 : _a[objectName];
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    title2 && /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: title2 }),
    languagesList.map((lang2) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$i.inputValue, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          label: lang2.name,
          variant: "standard",
          type: "text",
          value: (hintObj == null ? void 0 : hintObj[lang2.code]) || "",
          onChange: (event) => setContentValue(lang2.code, event.target.value)
        }
      ) }, lang2.code);
    })
  ] });
}
const boxContainer$1 = "_boxContainer_182us_1";
const mt10$1 = "_mt10_182us_10";
const uppercase$1 = "_uppercase_182us_14";
const title$5 = "_title_182us_18";
const styles$h = {
  boxContainer: boxContainer$1,
  mt10: mt10$1,
  uppercase: uppercase$1,
  title: title$5
};
const boxContainer = "_boxContainer_1vhs4_1";
const mt10 = "_mt10_1vhs4_9";
const uppercase = "_uppercase_1vhs4_13";
const title$4 = "_title_1vhs4_18";
const titleContent = "_titleContent_1vhs4_28";
const standardError = "_standardError_1vhs4_33";
const errorWrapper = "_errorWrapper_1vhs4_44";
const errorLabelWrapper = "_errorLabelWrapper_1vhs4_48";
const errorItem = "_errorItem_1vhs4_52";
const errorItemContainer = "_errorItemContainer_1vhs4_58";
const styles$g = {
  boxContainer,
  mt10,
  uppercase,
  title: title$4,
  titleContent,
  standardError,
  errorWrapper,
  errorLabelWrapper,
  errorItem,
  errorItemContainer
};
function ValidationSetupMessage({ validationRule, code, rule: rule3, t: t2 }) {
  const dispatch = useDispatch();
  const isCustomErrorActive = validationRule.isCustomErrorActive || false;
  const languagesList = useSelector((state) => {
    return state.designState.langInfo.languagesList;
  });
  let content = validationRule.content || {};
  const checkedCustomError = (checked) => {
    dispatch(
      changeValidationValue({
        code,
        rule: rule3,
        key: "isCustomErrorActive",
        value: checked
      })
    );
  };
  const onContentUpdate = (key, value) => {
    const newContent = { ...content, [key]: value };
    dispatch(
      changeValidationValue({
        code,
        rule: rule3,
        key: "content",
        value: newContent
      })
    );
  };
  const label2 = { inputProps: { "aria-label": "Switch validation" } };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: t2("standard_error") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$g.errorWrapper, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$g.errorLabelWrapper, children: languagesList.map((l) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "".concat(styles$g.errorItem, " ").concat(styles$g.uppercase),
          children: [
            l.code,
            ":"
          ]
        },
        l.code
      )) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: languagesList.map((l) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$g.errorItem, children: t2(rule3, { ns: "run", lng: l.code, ...validationRule }) }, l.code)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$g.title, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: styles$g.mt10, children: t2("custom_error") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Switch,
        {
          ...label2,
          checked: isCustomErrorActive,
          onChange: (event) => checkedCustomError(event.target.checked)
        }
      )
    ] }),
    isCustomErrorActive ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$g.errorWrapper, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$g.errorLabelWrapper, children: languagesList.map((l) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "".concat(styles$g.errorItem, " ").concat(styles$g.uppercase),
          children: [
            l.code,
            ":"
          ]
        },
        l.code
      )) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$g.errorItemContainer, children: languagesList.map((l) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$g.errorItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          size: "small",
          variant: "standard",
          value: content[l.code] || "",
          onChange: (event) => onContentUpdate(l.code, event.target.value)
        }
      ) }, l.code)) })
    ] }) : ""
  ] });
}
const valueValidationItems = "_valueValidationItems_1hupk_1";
const valueValidationItemsContainer = "_valueValidationItemsContainer_1hupk_6";
const error = "_error_1hupk_11";
const styles$f = {
  valueValidationItems,
  valueValidationItemsContainer,
  error
};
function FileType({ value, onValueChanged }) {
  const { t: t2 } = useTranslation("design");
  const onFileTypeChanged = (e2) => {
    let finalValue = [...value];
    if (!e2.target.checked) {
      finalValue = value.filter((el) => el != e2.target.name);
    } else {
      finalValue.push(e2.target.name);
    }
    onValueChanged(finalValue);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { id: "file-type-label", children: t2("file_type") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormControlLabel,
      {
        control: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            checked: value.indexOf("presentation") > -1,
            onChange: onFileTypeChanged,
            name: "presentation"
          }
        ),
        label: t2("file_types.presentation")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormControlLabel,
      {
        control: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            checked: value.indexOf("document") > -1,
            onChange: onFileTypeChanged,
            name: "document"
          }
        ),
        label: t2("file_types.document")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormControlLabel,
      {
        control: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            checked: value.indexOf("spreadsheet") > -1,
            onChange: onFileTypeChanged,
            name: "spreadsheet"
          }
        ),
        label: t2("file_types.spreadsheet")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormControlLabel,
      {
        control: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            checked: value.indexOf("pdf") > -1,
            onChange: onFileTypeChanged,
            name: "pdf"
          }
        ),
        label: t2("file_types.pdf")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormControlLabel,
      {
        control: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            checked: value.indexOf("image") > -1,
            onChange: onFileTypeChanged,
            name: "image"
          }
        ),
        label: t2("file_types.image")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormControlLabel,
      {
        control: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            checked: value.indexOf("video") > -1,
            onChange: onFileTypeChanged,
            name: "video"
          }
        ),
        label: t2("file_types.video")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormControlLabel,
      {
        control: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            checked: value.indexOf("audio") > -1,
            onChange: onFileTypeChanged,
            name: "audio"
          }
        ),
        label: t2("file_types.audio")
      }
    )
  ] });
}
const FileType$1 = React.memo(FileType);
function ValidationSetupValue({ code, validation: validation2, rule: rule3, t: t2 }) {
  const childCount = useSelector((state) => {
    var _a;
    return ((_a = state.designState[code].children) == null ? void 0 : _a.length) || 0;
  });
  const bounds = React.useMemo(() => {
    switch (rule3) {
      case "validation_min_char_length":
        return [1, Number.MAX_VALUE];
      case "validation_max_file_size":
        return [1, Number.MAX_VALUE];
      case "validation_max_char_length":
        return [1, Number.MAX_VALUE];
      case "validation_max_word_count":
        return [1, Number.MAX_VALUE];
      case "validation_min_word_count":
        return [1, Number.MAX_VALUE];
      case "validation_min_ranking_count":
      case "validation_min_option_count":
      case "validation_max_ranking_count":
      case "validation_max_option_count":
      case "validation_ranking_count":
      case "validation_option_count":
        return [1, childCount];
      default:
        return void 0;
    }
  }, [childCount]);
  const dispatch = useDispatch();
  const onChange = (key, value) => {
    dispatch(changeValidationValue({ rule: rule3, code, key, value }));
  };
  const onValuesUpdate = (key, value) => {
    onChange(
      key,
      typeof bounds === "undefined" ? value : Math.max(bounds[0], Math.min(bounds[1], value))
    );
  };
  let keys4 = validationAttributes(validation2);
  const hasSubtitle = rule3 != "validation_required" && rule3 != "validation_one_response_per_col" && rule3 != "validation_pattern_email" && rule3 != "validation_file_types";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$f.valueValidationItemsContainer, children: [
    keys4 && hasSubtitle && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t2(rule3 + "_subtitle") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$f.valueValidationItems, children: rule3 == "validation_file_types" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      FileType$1,
      {
        value: validation2.fileTypes,
        onValueChanged: (value) => onValuesUpdate("fileTypes", value)
      }
    ) : keys4.map((i2) => {
      const isInError = typeof bounds !== "undefined" && (validation2[i2] < bounds[0] || validation2[i2] > bounds[1]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          error: isInError,
          value: validation2[i2],
          variant: "outlined",
          size: "small",
          type: typeof validation2[i2] === "number" ? "number" : "text",
          onChange: (event) => onValuesUpdate(
            i2,
            typeof validation2[i2] === "number" ? parseInt(event.target.value) : event.target.value
          ),
          style: { maxWidth: "150px", marginLeft: "8px" }
        },
        i2
      );
    }) })
  ] });
}
const validationAttributes = (validation2) => {
  return Object.keys(validation2).filter(
    (el) => ![
      "content",
      "isActive",
      "isCustomErrorActive",
      "bounds",
      "fileTypes"
    ].includes(el)
  );
};
function ValidationSetupItem({ rule: rule3, t: t2, code }) {
  console.debug("ValidationSetupItem: " + code);
  const dispatch = useDispatch();
  const validationRule = useSelector((state) => {
    var _a, _b;
    return (_b = (_a = state.designState[code]) == null ? void 0 : _a.validation) == null ? void 0 : _b[rule3];
  });
  const label2 = { inputProps: { "aria-label": "Switch validation" } };
  const isActive = (validationRule == null ? void 0 : validationRule.isActive) || false;
  const checkedValidationItem = (checked) => {
    dispatch(
      changeValidationValue({
        code,
        rule: rule3,
        key: "isActive",
        value: checked
      })
    );
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$h.title, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: t2(rule3 + "_title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Switch,
        {
          ...label2,
          checked: isActive,
          onChange: (event) => checkedValidationItem(event.target.checked)
        }
      )
    ] }),
    isActive && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$h.boxContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ValidationSetupValue,
        {
          code,
          validation: validationRule,
          rule: rule3,
          t: t2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ValidationSetupMessage,
        {
          code,
          validationRule,
          rule: rule3,
          t: t2
        }
      )
    ] })
  ] });
}
const ValidationSetupItem$1 = React.memo(ValidationSetupItem);
const toggleValue = "_toggleValue_1d9zg_1";
const inputValue = "_inputValue_1d9zg_8";
const styles$e = {
  toggleValue,
  inputValue
};
function ToggleValue({ label: label2, code, rule: rule3 }) {
  const dispatch = useDispatch();
  const value = useSelector((state) => {
    return state.designState[code][rule3] || false;
  });
  const onChange = (value2) => {
    dispatch(changeAttribute({ code, key: rule3, value: value2 }));
  };
  const swithLabel = { inputProps: { "aria-label": "Switch demo" } };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$e.toggleValue, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: label2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Switch,
      {
        ...swithLabel,
        checked: value,
        onChange: (event) => {
          onChange(event.target.checked);
        }
      }
    )
  ] });
}
const selectValue$1 = "_selectValue_9m4tq_1";
const styles$d = {
  selectValue: selectValue$1
};
function SelectValue({ label: label2, rule: rule3, defaultValue, code, values: values2, labels }) {
  const dispatch = useDispatch();
  const value = useSelector((state) => {
    var _a;
    return ((_a = state.designState[code]) == null ? void 0 : _a[rule3]) || defaultValue;
  });
  const onChange = (value2) => {
    dispatch(changeAttribute({ code, key: rule3, value: value2 }));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$d.selectDate, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: label2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { variant: "standard", fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Select,
      {
        id: "select-value",
        value,
        label: "Select Value",
        onChange: (e2) => {
          onChange(e2.target.value);
        },
        children: values2.map((element, index2) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: element, children: labels ? labels[index2] : element }, element);
        })
      }
    ) })
  ] });
}
const selectDate = "_selectDate_1qp3e_1";
const selectDateField = "_selectDateField_1qp3e_8";
const styles$c = {
  selectDate,
  selectDateField
};
function SelectDate({ label: label2, rule: rule3, code }) {
  const dispatch = useDispatch();
  const value = useSelector((state) => {
    return state.designState[code][rule3] || "";
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$c.selectDate, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: label2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextField,
      {
        className: styles$c.selectDateField,
        variant: "standard",
        value,
        type: "date",
        onChange: (event) => {
          dispatch(
            changeAttribute({ code, key: rule3, value: event.target.value })
          );
        }
      }
    )
  ] });
}
function _arrayLikeToArray$f(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function _arrayWithHoles(r2) {
  if (Array.isArray(r2)) return r2;
}
function _defineProperty$2(e2, r2, t2) {
  return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r2] = t2, e2;
}
function _extends$f() {
  return _extends$f = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$f.apply(null, arguments);
}
function _iterableToArrayLimit(r2, l) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u, a2 = [], f = true, o = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l) ;
      else for (; !(f = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l); f = true) ;
    } catch (r3) {
      o = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n2;
      }
    }
    return a2;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys$E(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$E(Object(t2), true).forEach(function(r3) {
      _defineProperty$2(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$E(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _slicedToArray(r2, e2) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray$f(r2, e2) || _nonIterableRest();
}
function _toPrimitive(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _toPropertyKey(t2) {
  var i2 = _toPrimitive(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _unsupportedIterableToArray$f(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$f(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$f(r2, a2) : void 0;
  }
}
var ConfirmContext = /* @__PURE__ */ reactExports.createContext({
  confirmBase: function confirmBase() {
    throw new Error("Missing ConfirmProvider");
  },
  closeOnParentUnmount: function closeOnParentUnmount() {
  }
});
var ConfirmationDialog = function ConfirmationDialog2(_ref) {
  var open = _ref.open, options = _ref.options, onCancel = _ref.onCancel, onConfirm = _ref.onConfirm, onClose = _ref.onClose;
  var title2 = options.title, description2 = options.description, content = options.content, confirmationText = options.confirmationText, cancellationText = options.cancellationText, dialogProps = options.dialogProps, dialogActionsProps = options.dialogActionsProps, confirmationButtonProps = options.confirmationButtonProps, cancellationButtonProps = options.cancellationButtonProps, titleProps = options.titleProps, contentProps = options.contentProps, allowClose = options.allowClose, confirmationKeyword = options.confirmationKeyword, confirmationKeywordTextFieldProps = options.confirmationKeywordTextFieldProps, hideCancelButton = options.hideCancelButton, buttonOrder = options.buttonOrder, acknowledgement = options.acknowledgement, acknowledgementFormControlLabelProps = options.acknowledgementFormControlLabelProps, acknowledgementCheckboxProps = options.acknowledgementCheckboxProps;
  var _React$useState = React.useState(""), _React$useState2 = _slicedToArray(_React$useState, 2), confirmationKeywordValue = _React$useState2[0], setConfirmationKeywordValue = _React$useState2[1];
  var _React$useState3 = React.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), isAcknowledged = _React$useState4[0], setIsAcknowledged = _React$useState4[1];
  var confirmationButtonDisabled = Boolean(confirmationKeyword && confirmationKeywordValue !== confirmationKeyword || acknowledgement && !isAcknowledged);
  var acknowledgeCheckbox = /* @__PURE__ */ React.createElement(React.Fragment, null, acknowledgement && /* @__PURE__ */ React.createElement(FormControlLabel, _extends$f({}, acknowledgementFormControlLabelProps, {
    control: /* @__PURE__ */ React.createElement(Checkbox, _extends$f({}, acknowledgementCheckboxProps, {
      value: isAcknowledged,
      onChange: function onChange(_, value) {
        return setIsAcknowledged(value);
      }
    })),
    label: acknowledgement
  })));
  var confirmationContent = /* @__PURE__ */ React.createElement(React.Fragment, null, confirmationKeyword && /* @__PURE__ */ React.createElement(TextField, _extends$f({
    onChange: function onChange(e2) {
      return setConfirmationKeywordValue(e2.target.value);
    },
    value: confirmationKeywordValue,
    fullWidth: true
  }, confirmationKeywordTextFieldProps)));
  var dialogActions = buttonOrder.map(function(buttonType) {
    if (buttonType === "cancel") {
      return !hideCancelButton && /* @__PURE__ */ React.createElement(Button, _extends$f({
        key: "cancel"
      }, cancellationButtonProps, {
        onClick: onCancel
      }), cancellationText);
    }
    if (buttonType === "confirm") {
      return /* @__PURE__ */ React.createElement(Button, _extends$f({
        key: "confirm",
        color: "primary",
        disabled: confirmationButtonDisabled
      }, confirmationButtonProps, {
        onClick: onConfirm
      }), confirmationText);
    }
    throw new Error('Supported button types are only "confirm" and "cancel", got: '.concat(buttonType));
  });
  return /* @__PURE__ */ React.createElement(Dialog, _extends$f({
    fullWidth: true
  }, dialogProps, {
    open,
    onClose: allowClose ? onClose : null
  }), title2 && /* @__PURE__ */ React.createElement(DialogTitle, titleProps, title2), content ? /* @__PURE__ */ React.createElement(DialogContent, contentProps, content, confirmationContent, acknowledgeCheckbox) : description2 ? /* @__PURE__ */ React.createElement(DialogContent, contentProps, /* @__PURE__ */ React.createElement(DialogContentText, null, description2), confirmationContent, acknowledgeCheckbox) : (confirmationKeyword || acknowledgeCheckbox) && /* @__PURE__ */ React.createElement(DialogContent, contentProps, confirmationContent, acknowledgeCheckbox), /* @__PURE__ */ React.createElement(DialogActions, dialogActionsProps, dialogActions));
};
var DEFAULT_OPTIONS = {
  title: "Are you sure?",
  description: "",
  content: null,
  confirmationText: "Ok",
  cancellationText: "Cancel",
  dialogProps: {},
  dialogActionsProps: {},
  confirmationButtonProps: {},
  cancellationButtonProps: {},
  titleProps: {},
  contentProps: {},
  allowClose: true,
  confirmationKeywordTextFieldProps: {},
  hideCancelButton: false,
  buttonOrder: ["cancel", "confirm"],
  acknowledgement: false,
  acknowledgementFormControlLabelProps: {},
  acknowledgementCheckboxProps: {}
};
var buildOptions = function buildOptions2(defaultOptions, options) {
  var dialogProps = _objectSpread2(_objectSpread2({}, defaultOptions.dialogProps || DEFAULT_OPTIONS.dialogProps), options.dialogProps || {});
  var dialogActionsProps = _objectSpread2(_objectSpread2({}, defaultOptions.dialogActionsProps || DEFAULT_OPTIONS.dialogActionsProps), options.dialogActionsProps || {});
  var confirmationButtonProps = _objectSpread2(_objectSpread2({}, defaultOptions.confirmationButtonProps || DEFAULT_OPTIONS.confirmationButtonProps), options.confirmationButtonProps || {});
  var cancellationButtonProps = _objectSpread2(_objectSpread2({}, defaultOptions.cancellationButtonProps || DEFAULT_OPTIONS.cancellationButtonProps), options.cancellationButtonProps || {});
  var titleProps = _objectSpread2(_objectSpread2({}, defaultOptions.titleProps || DEFAULT_OPTIONS.titleProps), options.titleProps || {});
  var contentProps = _objectSpread2(_objectSpread2({}, defaultOptions.contentProps || DEFAULT_OPTIONS.contentProps), options.contentProps || {});
  var confirmationKeywordTextFieldProps = _objectSpread2(_objectSpread2({}, defaultOptions.confirmationKeywordTextFieldProps || DEFAULT_OPTIONS.confirmationKeywordTextFieldProps), options.confirmationKeywordTextFieldProps || {});
  var acknowledgementFormControlLabelProps = _objectSpread2(_objectSpread2({}, defaultOptions.acknowledgementFormControlLabelProps || DEFAULT_OPTIONS.acknowledgementFormControlLabelProps), options.acknowledgementFormControlLabelProps || {});
  var acknowledgementCheckboxProps = _objectSpread2(_objectSpread2({}, defaultOptions.acknowledgementCheckboxProps || DEFAULT_OPTIONS.acknowledgementCheckboxProps), options.acknowledgementCheckboxProps || {});
  return _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_OPTIONS), defaultOptions), options), {}, {
    dialogProps,
    dialogActionsProps,
    confirmationButtonProps,
    cancellationButtonProps,
    titleProps,
    contentProps,
    confirmationKeywordTextFieldProps,
    acknowledgementFormControlLabelProps,
    acknowledgementCheckboxProps
  });
};
var ConfirmProvider = function ConfirmProvider2(_ref) {
  var children = _ref.children, _ref$defaultOptions = _ref.defaultOptions, defaultOptions = _ref$defaultOptions === void 0 ? {} : _ref$defaultOptions;
  var _useState = reactExports.useState(null), _useState2 = _slicedToArray(_useState, 2), state = _useState2[0], setState = _useState2[1];
  var _useState3 = reactExports.useState({}), _useState4 = _slicedToArray(_useState3, 2), options = _useState4[0], setOptions = _useState4[1];
  var _useState5 = reactExports.useState(0), _useState6 = _slicedToArray(_useState5, 2), key = _useState6[0], setKey = _useState6[1];
  var confirmBase2 = reactExports.useCallback(function(parentId) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return new Promise(function(resolve, reject) {
      setKey(function(key2) {
        return key2 + 1;
      });
      setOptions(options2);
      setState({
        resolve,
        reject,
        parentId
      });
    });
  }, []);
  var closeOnParentUnmount2 = reactExports.useCallback(function(parentId) {
    setState(function(state2) {
      if (state2 && state2.parentId === parentId) {
        return null;
      } else {
        return state2;
      }
    });
  }, []);
  var handleClose = reactExports.useCallback(function() {
    setState(null);
  }, []);
  var handleCancel = reactExports.useCallback(function() {
    setState(function(state2) {
      state2 && state2.reject();
      return null;
    });
  }, []);
  var handleConfirm = reactExports.useCallback(function() {
    setState(function(state2) {
      state2 && state2.resolve();
      return null;
    });
  }, []);
  reactExports.useCallback(function(options2) {
    return confirmBase2("global", options2);
  });
  return /* @__PURE__ */ React.createElement(reactExports.Fragment, null, /* @__PURE__ */ React.createElement(ConfirmContext.Provider, {
    value: {
      confirmBase: confirmBase2,
      closeOnParentUnmount: closeOnParentUnmount2
    }
  }, children), /* @__PURE__ */ React.createElement(ConfirmationDialog, {
    key,
    open: state !== null,
    options: buildOptions(defaultOptions, options !== null && options !== void 0 ? options : {}),
    onClose: handleClose,
    onCancel: handleCancel,
    onConfirm: handleConfirm
  }));
};
var idCounter$1 = 0;
var useConfirmId = function useConfirmId2() {
  var id2 = reactExports.useMemo(function() {
    return idCounter$1++;
  }, []);
  return "confirm-".concat(id2);
};
var useConfirm = function useConfirm2() {
  var parentId = useConfirmId();
  var _useContext = reactExports.useContext(ConfirmContext), confirmBase2 = _useContext.confirmBase, closeOnParentUnmount2 = _useContext.closeOnParentUnmount;
  var confirm2 = reactExports.useCallback(function(options) {
    return confirmBase2(parentId, options);
  }, [parentId]);
  reactExports.useEffect(function() {
    return function() {
      closeOnParentUnmount2(parentId);
    };
  }, [parentId]);
  return confirm2;
};
//! moment.js
//! version : 2.30.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray$b(input2) {
  return input2 instanceof Array || Object.prototype.toString.call(input2) === "[object Array]";
}
function isObject$h(input2) {
  return input2 != null && Object.prototype.toString.call(input2) === "[object Object]";
}
function hasOwnProp(a2, b) {
  return Object.prototype.hasOwnProperty.call(a2, b);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k;
    for (k in obj) {
      if (hasOwnProp(obj, k)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined$1(input2) {
  return input2 === void 0;
}
function isNumber(input2) {
  return typeof input2 === "number" || Object.prototype.toString.call(input2) === "[object Number]";
}
function isDate(input2) {
  return input2 instanceof Date || Object.prototype.toString.call(input2) === "[object Date]";
}
function map$2(arr, fn) {
  var res = [], i2, arrLen = arr.length;
  for (i2 = 0; i2 < arrLen; ++i2) {
    res.push(fn(arr[i2], i2));
  }
  return res;
}
function extend2(a2, b) {
  for (var i2 in b) {
    if (hasOwnProp(b, i2)) {
      a2[i2] = b[i2];
    }
  }
  if (hasOwnProp(b, "toString")) {
    a2.toString = b.toString;
  }
  if (hasOwnProp(b, "valueOf")) {
    a2.valueOf = b.valueOf;
  }
  return a2;
}
function createUTC(input2, format2, locale2, strict) {
  return createLocalOrUTC(input2, format2, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m) {
  if (m._pf == null) {
    m._pf = defaultParsingFlags();
  }
  return m._pf;
}
var some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function(fun) {
    var t2 = Object(this), len = t2.length >>> 0, i2;
    for (i2 = 0; i2 < len; i2++) {
      if (i2 in t2 && fun.call(this, t2[i2], i2, t2)) {
        return true;
      }
    }
    return false;
  };
}
function isValid(m) {
  var flags3 = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
  if (isNowValid) {
    flags3 = getParsingFlags(m);
    parsedParts = some.call(flags3.parsedDateParts, function(i2) {
      return i2 != null;
    });
    isNowValid = flags3.overflow < 0 && !flags3.empty && !flags3.invalidEra && !flags3.invalidMonth && !flags3.invalidWeekday && !flags3.weekdayMismatch && !flags3.nullInput && !flags3.invalidFormat && !flags3.userInvalidated && (!flags3.meridiem || flags3.meridiem && parsedParts);
    if (m._strict) {
      isNowValid = isNowValid && flags3.charsLeftOver === 0 && flags3.unusedTokens.length === 0 && flags3.bigHour === void 0;
    }
  }
  if (Object.isFrozen == null || !Object.isFrozen(m)) {
    m._isValid = isNowValid;
  } else {
    return isNowValid;
  }
  return m._isValid;
}
function createInvalid(flags3) {
  var m = createUTC(NaN);
  if (flags3 != null) {
    extend2(getParsingFlags(m), flags3);
  } else {
    getParsingFlags(m).userInvalidated = true;
  }
  return m;
}
var momentProperties = hooks.momentProperties = [], updateInProgress = false;
function copyConfig(to2, from2) {
  var i2, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined$1(from2._isAMomentObject)) {
    to2._isAMomentObject = from2._isAMomentObject;
  }
  if (!isUndefined$1(from2._i)) {
    to2._i = from2._i;
  }
  if (!isUndefined$1(from2._f)) {
    to2._f = from2._f;
  }
  if (!isUndefined$1(from2._l)) {
    to2._l = from2._l;
  }
  if (!isUndefined$1(from2._strict)) {
    to2._strict = from2._strict;
  }
  if (!isUndefined$1(from2._tzm)) {
    to2._tzm = from2._tzm;
  }
  if (!isUndefined$1(from2._isUTC)) {
    to2._isUTC = from2._isUTC;
  }
  if (!isUndefined$1(from2._offset)) {
    to2._offset = from2._offset;
  }
  if (!isUndefined$1(from2._pf)) {
    to2._pf = getParsingFlags(from2);
  }
  if (!isUndefined$1(from2._locale)) {
    to2._locale = from2._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i2 = 0; i2 < momentPropertiesLen; i2++) {
      prop = momentProperties[i2];
      val = from2[prop];
      if (!isUndefined$1(val)) {
        to2[prop] = val;
      }
    }
  }
  return to2;
}
function Moment(config2) {
  copyConfig(this, config2);
  this._d = new Date(config2._d != null ? config2._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = /* @__PURE__ */ new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend2(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i2, key, argLen = arguments.length;
      for (i2 = 0; i2 < argLen; i2++) {
        arg = "";
        if (typeof arguments[i2] === "object") {
          arg += "\n[" + i2 + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i2];
        }
        args.push(arg);
      }
      warn(
        msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
      );
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
var deprecations = {};
function deprecateSimple(name2, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name2, msg);
  }
  if (!deprecations[name2]) {
    warn(msg);
    deprecations[name2] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction$2(input2) {
  return typeof Function !== "undefined" && input2 instanceof Function || Object.prototype.toString.call(input2) === "[object Function]";
}
function set$1(config2) {
  var prop, i2;
  for (i2 in config2) {
    if (hasOwnProp(config2, i2)) {
      prop = config2[i2];
      if (isFunction$2(prop)) {
        this[i2] = prop;
      } else {
        this["_" + i2] = prop;
      }
    }
  }
  this._config = config2;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend2({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject$h(parentConfig[prop]) && isObject$h(childConfig[prop])) {
        res[prop] = {};
        extend2(res[prop], parentConfig[prop]);
        extend2(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject$h(parentConfig[prop])) {
      res[prop] = extend2({}, res[prop]);
    }
  }
  return res;
}
function Locale(config2) {
  if (config2 != null) {
    this.set(config2);
  }
}
var keys$5;
if (Object.keys) {
  keys$5 = Object.keys;
} else {
  keys$5 = function(obj) {
    var i2, res = [];
    for (i2 in obj) {
      if (hasOwnProp(obj, i2)) {
        res.push(i2);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now3) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction$2(output) ? output.call(mom, now3) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
function addFormatToken(token2, padded, ordinal2, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(
        func.apply(this, arguments),
        token2
      );
    };
  }
}
function removeFormattingTokens(input2) {
  if (input2.match(/\[[\s\S]/)) {
    return input2.replace(/^\[|\]$/g, "");
  }
  return input2.replace(/\\/g, "");
}
function makeFormatFunction(format2) {
  var array = format2.match(formattingTokens), i2, length;
  for (i2 = 0, length = array.length; i2 < length; i2++) {
    if (formatTokenFunctions[array[i2]]) {
      array[i2] = formatTokenFunctions[array[i2]];
    } else {
      array[i2] = removeFormattingTokens(array[i2]);
    }
  }
  return function(mom) {
    var output = "", i3;
    for (i3 = 0; i3 < length; i3++) {
      output += isFunction$2(array[i3]) ? array[i3].call(mom, format2) : array[i3];
    }
    return output;
  };
}
function formatMoment(m, format2) {
  if (!m.isValid()) {
    return m.localeData().invalidDate();
  }
  format2 = expandFormat(format2, m.localeData());
  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
  return formatFunctions[format2](m);
}
function expandFormat(format2, locale2) {
  var i2 = 5;
  function replaceLongDateFormatTokens(input2) {
    return locale2.longDateFormat(input2) || input2;
  }
  localFormattingTokens.lastIndex = 0;
  while (i2 >= 0 && localFormattingTokens.test(format2)) {
    format2 = format2.replace(
      localFormattingTokens,
      replaceLongDateFormatTokens
    );
    localFormattingTokens.lastIndex = 0;
    i2 -= 1;
  }
  return format2;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format2 || !formatUpper) {
    return format2;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number, withoutSuffix, string, isFuture) {
  var output = this._relativeTime[string];
  return isFunction$2(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff2, output) {
  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction$2(format2) ? format2(output) : format2.replace(/%s/i, output);
}
var aliases = {
  D: "date",
  dates: "date",
  date: "date",
  d: "day",
  days: "day",
  day: "day",
  e: "weekday",
  weekdays: "weekday",
  weekday: "weekday",
  E: "isoWeekday",
  isoweekdays: "isoWeekday",
  isoweekday: "isoWeekday",
  DDD: "dayOfYear",
  dayofyears: "dayOfYear",
  dayofyear: "dayOfYear",
  h: "hour",
  hours: "hour",
  hour: "hour",
  ms: "millisecond",
  milliseconds: "millisecond",
  millisecond: "millisecond",
  m: "minute",
  minutes: "minute",
  minute: "minute",
  M: "month",
  months: "month",
  month: "month",
  Q: "quarter",
  quarters: "quarter",
  quarter: "quarter",
  s: "second",
  seconds: "second",
  second: "second",
  gg: "weekYear",
  weekyears: "weekYear",
  weekyear: "weekYear",
  GG: "isoWeekYear",
  isoweekyears: "isoWeekYear",
  isoweekyear: "isoWeekYear",
  w: "week",
  weeks: "week",
  week: "week",
  W: "isoWeek",
  isoweeks: "isoWeek",
  isoweek: "isoWeek",
  y: "year",
  years: "year",
  year: "year"
};
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
var priorities = {
  date: 9,
  day: 11,
  weekday: 11,
  isoWeekday: 11,
  dayOfYear: 4,
  hour: 13,
  millisecond: 16,
  minute: 14,
  month: 8,
  quarter: 7,
  second: 15,
  weekYear: 1,
  isoWeekYear: 1,
  week: 5,
  isoWeek: 5,
  year: 1
};
function getPrioritizedUnits(unitsObj) {
  var units = [], u;
  for (u in unitsObj) {
    if (hasOwnProp(unitsObj, u)) {
      units.push({ unit: u, priority: priorities[u] });
    }
  }
  units.sort(function(a2, b) {
    return a2.priority - b.priority;
  });
  return units;
}
var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
regexes = {};
function addRegexToken(token2, regex2, strictRegex) {
  regexes[token2] = isFunction$2(regex2) ? regex2 : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex2;
  };
}
function getParseRegexForToken(token2, config2) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config2._strict, config2._locale);
}
function unescapeFormat(s2) {
  return regexEscape$1(
    s2.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }
    )
  );
}
function regexEscape$1(s2) {
  return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
var tokens = {};
function addParseToken(token2, callback) {
  var i2, func = callback, tokenLen;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber(callback)) {
    func = function(input2, array) {
      array[callback] = toInt(input2);
    };
  }
  tokenLen = token2.length;
  for (i2 = 0; i2 < tokenLen; i2++) {
    tokens[token2[i2]] = func;
  }
}
function addWeekParseToken(token2, callback) {
  addParseToken(token2, function(input2, array, config2, token3) {
    config2._w = config2._w || {};
    callback(input2, config2._w, config2, token3);
  });
}
function addTimeToArrayFromToken(token2, input2, config2) {
  if (input2 != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input2, config2._a, config2, token2);
  }
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
addFormatToken("Y", 0, 0, function() {
  var y = this.year();
  return y <= 9999 ? zeroFill(y, 4) : "+" + y;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input2, array) {
  array[YEAR] = input2.length === 2 ? hooks.parseTwoDigitYear(input2) : toInt(input2);
});
addParseToken("YY", function(input2, array) {
  array[YEAR] = hooks.parseTwoDigitYear(input2);
});
addParseToken("Y", function(input2, array) {
  array[YEAR] = parseInt(input2, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input2) {
  return toInt(input2) + (toInt(input2) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get$6(this, unit);
    }
  };
}
function get$6(mom, unit) {
  if (!mom.isValid()) {
    return NaN;
  }
  var d = mom._d, isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
    case "Seconds":
      return isUTC ? d.getUTCSeconds() : d.getSeconds();
    case "Minutes":
      return isUTC ? d.getUTCMinutes() : d.getMinutes();
    case "Hours":
      return isUTC ? d.getUTCHours() : d.getHours();
    case "Date":
      return isUTC ? d.getUTCDate() : d.getDate();
    case "Day":
      return isUTC ? d.getUTCDay() : d.getDay();
    case "Month":
      return isUTC ? d.getUTCMonth() : d.getMonth();
    case "FullYear":
      return isUTC ? d.getUTCFullYear() : d.getFullYear();
    default:
      return NaN;
  }
}
function set$1$1(mom, unit, value) {
  var d, isUTC, year, month, date;
  if (!mom.isValid() || isNaN(value)) {
    return;
  }
  d = mom._d;
  isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
    case "Seconds":
      return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
    case "Minutes":
      return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
    case "Hours":
      return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
    case "Date":
      return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
    case "FullYear":
      break;
    default:
      return;
  }
  year = value;
  month = mom.month();
  date = mom.date();
  date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
  void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction$2(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
    for (i2 = 0; i2 < prioritizedLen; i2++) {
      this[prioritized[i2].unit](units[prioritized[i2].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction$2(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
function mod(n2, x) {
  return (n2 % x + x) % x;
}
var indexOf;
if (Array.prototype.indexOf) {
  indexOf = Array.prototype.indexOf;
} else {
  indexOf = function(o) {
    var i2;
    for (i2 = 0; i2 < this.length; ++i2) {
      if (this[i2] === o) {
        return i2;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format2) {
  return this.localeData().monthsShort(this, format2);
});
addFormatToken("MMMM", 0, 0, function(format2) {
  return this.localeData().months(this, format2);
});
addRegexToken("M", match1to2, match1to2NoLeadingZero);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function(isStrict, locale2) {
  return locale2.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale2) {
  return locale2.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input2, array) {
  array[MONTH] = toInt(input2) - 1;
});
addParseToken(["MMM", "MMMM"], function(input2, array, config2, token2) {
  var month = config2._locale.monthsParse(input2, token2, config2._strict);
  if (month != null) {
    array[MONTH] = month;
  } else {
    getParsingFlags(config2).invalidMonth = input2;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
function localeMonths(m, format2) {
  if (!m) {
    return isArray$b(this._months) ? this._months : this._months["standalone"];
  }
  return isArray$b(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
}
function localeMonthsShort(m, format2) {
  if (!m) {
    return isArray$b(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray$b(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
}
function handleStrictParse(monthName, format2, strict) {
  var i2, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i2 = 0; i2 < 12; ++i2) {
      mom = createUTC([2e3, i2]);
      this._shortMonthsParse[i2] = this.monthsShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format2, strict) {
  var i2, mom, regex2;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format2, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i2 = 0; i2 < 12; i2++) {
    mom = createUTC([2e3, i2]);
    if (strict && !this._longMonthsParse[i2]) {
      this._longMonthsParse[i2] = new RegExp(
        "^" + this.months(mom, "").replace(".", "") + "$",
        "i"
      );
      this._shortMonthsParse[i2] = new RegExp(
        "^" + this.monthsShort(mom, "").replace(".", "") + "$",
        "i"
      );
    }
    if (!strict && !this._monthsParse[i2]) {
      regex2 = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i2] = new RegExp(regex2.replace(".", ""), "i");
    }
    if (strict && format2 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
      return i2;
    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
      return i2;
    } else if (!strict && this._monthsParse[i2].test(monthName)) {
      return i2;
    }
  }
}
function setMonth(mom, value) {
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber(value)) {
        return mom;
      }
    }
  }
  var month = value, date = mom.date();
  date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
  void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get$6(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a2, b) {
    return b.length - a2.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, shortP, longP;
  for (i2 = 0; i2 < 12; i2++) {
    mom = createUTC([2e3, i2]);
    shortP = regexEscape$1(this.monthsShort(mom, ""));
    longP = regexEscape$1(this.months(mom, ""));
    shortPieces.push(shortP);
    longPieces.push(longP);
    mixedPieces.push(longP);
    mixedPieces.push(shortP);
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._monthsShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
}
function createDate(y, m, d, h, M, s2, ms) {
  var date;
  if (y < 100 && y >= 0) {
    date = new Date(y + 400, m, d, h, M, s2, ms);
    if (isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }
  } else {
    date = new Date(y, m, d, h, M, s2, ms);
  }
  return date;
}
function createUTCDate(y) {
  var date, args;
  if (y < 100 && y >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y + 400;
    date = new Date(Date.UTC.apply(null, args));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }
  } else {
    date = new Date(Date.UTC.apply(null, arguments));
  }
  return date;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addRegexToken("w", match1to2, match1to2NoLeadingZero);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2, match1to2NoLeadingZero);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(
  ["w", "ww", "W", "WW"],
  function(input2, week, config2, token2) {
    week[token2.substr(0, 1)] = toInt(input2);
  }
);
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input2) {
  var week = this.localeData().week(this);
  return input2 == null ? week : this.add((input2 - week) * 7, "d");
}
function getSetISOWeek(input2) {
  var week = weekOfYear(this, 1, 4).week;
  return input2 == null ? week : this.add((input2 - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format2) {
  return this.localeData().weekdaysMin(this, format2);
});
addFormatToken("ddd", 0, 0, function(format2) {
  return this.localeData().weekdaysShort(this, format2);
});
addFormatToken("dddd", 0, 0, function(format2) {
  return this.localeData().weekdays(this, format2);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale2) {
  return locale2.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale2) {
  return locale2.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale2) {
  return locale2.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input2, week, config2, token2) {
  var weekday = config2._locale.weekdaysParse(input2, token2, config2._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config2).invalidWeekday = input2;
  }
});
addWeekParseToken(["d", "e", "E"], function(input2, week, config2, token2) {
  week[token2] = toInt(input2);
});
function parseWeekday(input2, locale2) {
  if (typeof input2 !== "string") {
    return input2;
  }
  if (!isNaN(input2)) {
    return parseInt(input2, 10);
  }
  input2 = locale2.weekdaysParse(input2);
  if (typeof input2 === "number") {
    return input2;
  }
  return null;
}
function parseIsoWeekday(input2, locale2) {
  if (typeof input2 === "string") {
    return locale2.weekdaysParse(input2) % 7 || 7;
  }
  return isNaN(input2) ? null : input2;
}
function shiftWeekdays(ws, n2) {
  return ws.slice(n2, 7).concat(ws.slice(0, n2));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m, format2) {
  var weekdays = isArray$b(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
  return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
}
function localeWeekdaysShort(m) {
  return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m) {
  return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format2, strict) {
  var i2, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i2 = 0; i2 < 7; ++i2) {
      mom = createUTC([2e3, 1]).day(i2);
      this._minWeekdaysParse[i2] = this.weekdaysMin(
        mom,
        ""
      ).toLocaleLowerCase();
      this._shortWeekdaysParse[i2] = this.weekdaysShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format2, strict) {
  var i2, mom, regex2;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format2, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i2 = 0; i2 < 7; i2++) {
    mom = createUTC([2e3, 1]).day(i2);
    if (strict && !this._fullWeekdaysParse[i2]) {
      this._fullWeekdaysParse[i2] = new RegExp(
        "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._shortWeekdaysParse[i2] = new RegExp(
        "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._minWeekdaysParse[i2] = new RegExp(
        "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
    }
    if (!this._weekdaysParse[i2]) {
      regex2 = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i2] = new RegExp(regex2.replace(".", ""), "i");
    }
    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
      return i2;
    }
  }
}
function getSetDayOfWeek(input2) {
  if (!this.isValid()) {
    return input2 != null ? this : NaN;
  }
  var day = get$6(this, "Day");
  if (input2 != null) {
    input2 = parseWeekday(input2, this.localeData());
    return this.add(input2 - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input2) {
  if (!this.isValid()) {
    return input2 != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input2 == null ? weekday : this.add(input2 - weekday, "d");
}
function getSetISODayOfWeek(input2) {
  if (!this.isValid()) {
    return input2 != null ? this : NaN;
  }
  if (input2 != null) {
    var weekday = parseIsoWeekday(input2, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a2, b) {
    return b.length - a2.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
  for (i2 = 0; i2 < 7; i2++) {
    mom = createUTC([2e3, 1]).day(i2);
    minp = regexEscape$1(this.weekdaysMin(mom, ""));
    shortp = regexEscape$1(this.weekdaysShort(mom, ""));
    longp = regexEscape$1(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._weekdaysShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
  this._weekdaysMinStrictRegex = new RegExp(
    "^(" + minPieces.join("|") + ")",
    "i"
  );
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      lowercase
    );
  });
}
meridiem("a", true);
meridiem("A", false);
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2, match1to2HasZero);
addRegexToken("h", match1to2, match1to2NoLeadingZero);
addRegexToken("k", match1to2, match1to2NoLeadingZero);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input2, array, config2) {
  var kInput = toInt(input2);
  array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input2, array, config2) {
  config2._isPm = config2._locale.isPM(input2);
  config2._meridiem = input2;
});
addParseToken(["h", "hh"], function(input2, array, config2) {
  array[HOUR] = toInt(input2);
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmm", function(input2, array, config2) {
  var pos = input2.length - 2;
  array[HOUR] = toInt(input2.substr(0, pos));
  array[MINUTE] = toInt(input2.substr(pos));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmmss", function(input2, array, config2) {
  var pos1 = input2.length - 4, pos2 = input2.length - 2;
  array[HOUR] = toInt(input2.substr(0, pos1));
  array[MINUTE] = toInt(input2.substr(pos1, 2));
  array[SECOND] = toInt(input2.substr(pos2));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("Hmm", function(input2, array, config2) {
  var pos = input2.length - 2;
  array[HOUR] = toInt(input2.substr(0, pos));
  array[MINUTE] = toInt(input2.substr(pos));
});
addParseToken("Hmmss", function(input2, array, config2) {
  var pos1 = input2.length - 4, pos2 = input2.length - 2;
  array[HOUR] = toInt(input2.substr(0, pos1));
  array[MINUTE] = toInt(input2.substr(pos1, 2));
  array[SECOND] = toInt(input2.substr(pos2));
});
function localeIsPM(input2) {
  return (input2 + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {}, localeFamilies = {}, globalLocale;
function commonPrefix(arr1, arr2) {
  var i2, minl = Math.min(arr1.length, arr2.length);
  for (i2 = 0; i2 < minl; i2 += 1) {
    if (arr1[i2] !== arr2[i2]) {
      return i2;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names2) {
  var i2 = 0, j, next, locale2, split2;
  while (i2 < names2.length) {
    split2 = normalizeLocale(names2[i2]).split("-");
    j = split2.length;
    next = normalizeLocale(names2[i2 + 1]);
    next = next ? next.split("-") : null;
    while (j > 0) {
      locale2 = loadLocale(split2.slice(0, j).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j && commonPrefix(split2, next) >= j - 1) {
        break;
      }
      j--;
    }
    i2++;
  }
  return globalLocale;
}
function isLocaleNameSane(name2) {
  return !!(name2 && name2.match("^[^/\\\\]*$"));
}
function loadLocale(name2) {
  var oldLocale = null, aliasedRequire;
  if (locales[name2] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name2)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = require;
      aliasedRequire("./locale/" + name2);
      getSetGlobalLocale(oldLocale);
    } catch (e2) {
      locales[name2] = null;
    }
  }
  return locales[name2];
}
function getSetGlobalLocale(key, values2) {
  var data;
  if (key) {
    if (isUndefined$1(values2)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values2);
    }
    if (data) {
      globalLocale = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(
          "Locale " + key + " not found. Did you forget to load it?"
        );
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name2, config2) {
  if (config2 !== null) {
    var locale2, parentConfig = baseConfig;
    config2.abbr = name2;
    if (locales[name2] != null) {
      deprecateSimple(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales[name2]._config;
    } else if (config2.parentLocale != null) {
      if (locales[config2.parentLocale] != null) {
        parentConfig = locales[config2.parentLocale]._config;
      } else {
        locale2 = loadLocale(config2.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config2.parentLocale]) {
            localeFamilies[config2.parentLocale] = [];
          }
          localeFamilies[config2.parentLocale].push({
            name: name2,
            config: config2
          });
          return null;
        }
      }
    }
    locales[name2] = new Locale(mergeConfigs(parentConfig, config2));
    if (localeFamilies[name2]) {
      localeFamilies[name2].forEach(function(x) {
        defineLocale(x.name, x.config);
      });
    }
    getSetGlobalLocale(name2);
    return locales[name2];
  } else {
    delete locales[name2];
    return null;
  }
}
function updateLocale(name2, config2) {
  if (config2 != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name2] != null && locales[name2].parentLocale != null) {
      locales[name2].set(mergeConfigs(locales[name2]._config, config2));
    } else {
      tmpLocale = loadLocale(name2);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config2 = mergeConfigs(parentConfig, config2);
      if (tmpLocale == null) {
        config2.abbr = name2;
      }
      locale2 = new Locale(config2);
      locale2.parentLocale = locales[name2];
      locales[name2] = locale2;
    }
    getSetGlobalLocale(name2);
  } else {
    if (locales[name2] != null) {
      if (locales[name2].parentLocale != null) {
        locales[name2] = locales[name2].parentLocale;
        if (name2 === getSetGlobalLocale()) {
          getSetGlobalLocale(name2);
        }
      } else if (locales[name2] != null) {
        delete locales[name2];
      }
    }
  }
  return locales[name2];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray$b(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys$5(locales);
}
function checkOverflow(m) {
  var overflow, a2 = m._a;
  if (a2 && getParsingFlags(m).overflow === -2) {
    overflow = a2[MONTH] < 0 || a2[MONTH] > 11 ? MONTH : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH]) ? DATE : a2[HOUR] < 0 || a2[HOUR] > 24 || a2[HOUR] === 24 && (a2[MINUTE] !== 0 || a2[SECOND] !== 0 || a2[MILLISECOND] !== 0) ? HOUR : a2[MINUTE] < 0 || a2[MINUTE] > 59 ? MINUTE : a2[SECOND] < 0 || a2[SECOND] > 59 ? SECOND : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m).overflow = overflow;
  }
  return m;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
], isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config2) {
  var i2, l, string = config2._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match) {
    getParsingFlags(config2).iso = true;
    for (i2 = 0, l = isoDatesLen; i2 < l; i2++) {
      if (isoDates[i2][1].exec(match[1])) {
        dateFormat = isoDates[i2][0];
        allowTime = isoDates[i2][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config2._isValid = false;
      return;
    }
    if (match[3]) {
      for (i2 = 0, l = isoTimesLen; i2 < l; i2++) {
        if (isoTimes[i2][1].exec(match[3])) {
          timeFormat = (match[2] || " ") + isoTimes[i2][0];
          break;
        }
      }
      if (timeFormat == null) {
        config2._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config2._isValid = false;
      return;
    }
    if (match[4]) {
      if (tzRegex.exec(match[4])) {
        tzFormat = "Z";
      } else {
        config2._isValid = false;
        return;
      }
    }
    config2._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config2);
  } else {
    config2._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config2) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
      parsedInput[0],
      parsedInput[1],
      parsedInput[2]
    ).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config2).weekdayMismatch = true;
      config2._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
    return h * 60 + m;
  }
}
function configFromRFC2822(config2) {
  var match = rfc2822.exec(preprocessRFC2822(config2._i)), parsedArray;
  if (match) {
    parsedArray = extractFromRFC2822Strings(
      match[4],
      match[3],
      match[2],
      match[5],
      match[6],
      match[7]
    );
    if (!checkWeekday(match[1], parsedArray, config2)) {
      return;
    }
    config2._a = parsedArray;
    config2._tzm = calculateOffset(match[8], match[9], match[10]);
    config2._d = createUTCDate.apply(null, config2._a);
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
    getParsingFlags(config2).rfc2822 = true;
  } else {
    config2._isValid = false;
  }
}
function configFromString(config2) {
  var matched = aspNetJsonRegex.exec(config2._i);
  if (matched !== null) {
    config2._d = /* @__PURE__ */ new Date(+matched[1]);
    return;
  }
  configFromISO(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  configFromRFC2822(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  if (config2._strict) {
    config2._isValid = false;
  } else {
    hooks.createFromInputFallback(config2);
  }
}
hooks.createFromInputFallback = deprecate(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(config2) {
    config2._d = /* @__PURE__ */ new Date(config2._i + (config2._useUTC ? " UTC" : ""));
  }
);
function defaults(a2, b, c2) {
  if (a2 != null) {
    return a2;
  }
  if (b != null) {
    return b;
  }
  return c2;
}
function currentDateArray(config2) {
  var nowValue = new Date(hooks.now());
  if (config2._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config2) {
  var i2, date, input2 = [], currentDate, expectedWeekday, yearToUse;
  if (config2._d) {
    return;
  }
  currentDate = currentDateArray(config2);
  if (config2._w && config2._a[DATE] == null && config2._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config2);
  }
  if (config2._dayOfYear != null) {
    yearToUse = defaults(config2._a[YEAR], currentDate[YEAR]);
    if (config2._dayOfYear > daysInYear(yearToUse) || config2._dayOfYear === 0) {
      getParsingFlags(config2)._overflowDayOfYear = true;
    }
    date = createUTCDate(yearToUse, 0, config2._dayOfYear);
    config2._a[MONTH] = date.getUTCMonth();
    config2._a[DATE] = date.getUTCDate();
  }
  for (i2 = 0; i2 < 3 && config2._a[i2] == null; ++i2) {
    config2._a[i2] = input2[i2] = currentDate[i2];
  }
  for (; i2 < 7; i2++) {
    config2._a[i2] = input2[i2] = config2._a[i2] == null ? i2 === 2 ? 1 : 0 : config2._a[i2];
  }
  if (config2._a[HOUR] === 24 && config2._a[MINUTE] === 0 && config2._a[SECOND] === 0 && config2._a[MILLISECOND] === 0) {
    config2._nextDay = true;
    config2._a[HOUR] = 0;
  }
  config2._d = (config2._useUTC ? createUTCDate : createDate).apply(
    null,
    input2
  );
  expectedWeekday = config2._useUTC ? config2._d.getUTCDay() : config2._d.getDay();
  if (config2._tzm != null) {
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
  }
  if (config2._nextDay) {
    config2._a[HOUR] = 24;
  }
  if (config2._w && typeof config2._w.d !== "undefined" && config2._w.d !== expectedWeekday) {
    getParsingFlags(config2).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config2) {
  var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w = config2._w;
  if (w.GG != null || w.W != null || w.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults(
      w.GG,
      config2._a[YEAR],
      weekOfYear(createLocal(), 1, 4).year
    );
    week = defaults(w.W, 1);
    weekday = defaults(w.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config2._locale._week.dow;
    doy = config2._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults(w.gg, config2._a[YEAR], curWeek.year);
    week = defaults(w.w, curWeek.week);
    if (w.d != null) {
      weekday = w.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w.e != null) {
      weekday = w.e + dow;
      if (w.e < 0 || w.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config2)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config2)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config2._a[YEAR] = temp.year;
    config2._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config2) {
  if (config2._f === hooks.ISO_8601) {
    configFromISO(config2);
    return;
  }
  if (config2._f === hooks.RFC_2822) {
    configFromRFC2822(config2);
    return;
  }
  config2._a = [];
  getParsingFlags(config2).empty = true;
  var string = "" + config2._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config2._f, config2._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i2 = 0; i2 < tokenLen; i2++) {
    token2 = tokens2[i2];
    parsedInput = (string.match(getParseRegexForToken(token2, config2)) || [])[0];
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config2).unusedInput.push(skipped);
      }
      string = string.slice(
        string.indexOf(parsedInput) + parsedInput.length
      );
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config2).empty = false;
      } else {
        getParsingFlags(config2).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config2);
    } else if (config2._strict && !parsedInput) {
      getParsingFlags(config2).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config2).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags(config2).unusedInput.push(string);
  }
  if (config2._a[HOUR] <= 12 && getParsingFlags(config2).bigHour === true && config2._a[HOUR] > 0) {
    getParsingFlags(config2).bigHour = void 0;
  }
  getParsingFlags(config2).parsedDateParts = config2._a.slice(0);
  getParsingFlags(config2).meridiem = config2._meridiem;
  config2._a[HOUR] = meridiemFixWrap(
    config2._locale,
    config2._a[HOUR],
    config2._meridiem
  );
  era = getParsingFlags(config2).era;
  if (era !== null) {
    config2._a[YEAR] = config2._locale.erasConvertYear(era, config2._a[YEAR]);
  }
  configFromArray(config2);
  checkOverflow(config2);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config2) {
  var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config2._f.length;
  if (configfLen === 0) {
    getParsingFlags(config2).invalidFormat = true;
    config2._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (i2 = 0; i2 < configfLen; i2++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config2);
    if (config2._useUTC != null) {
      tempConfig._useUTC = config2._useUTC;
    }
    tempConfig._f = config2._f[i2];
    configFromStringAndFormat(tempConfig);
    if (isValid(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend2(config2, bestMoment || tempConfig);
}
function configFromObject(config2) {
  if (config2._d) {
    return;
  }
  var i2 = normalizeObjectUnits(config2._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
  config2._a = map$2(
    [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
    function(obj) {
      return obj && parseInt(obj, 10);
    }
  );
  configFromArray(config2);
}
function createFromConfig(config2) {
  var res = new Moment(checkOverflow(prepareConfig(config2)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config2) {
  var input2 = config2._i, format2 = config2._f;
  config2._locale = config2._locale || getLocale(config2._l);
  if (input2 === null || format2 === void 0 && input2 === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input2 === "string") {
    config2._i = input2 = config2._locale.preparse(input2);
  }
  if (isMoment(input2)) {
    return new Moment(checkOverflow(input2));
  } else if (isDate(input2)) {
    config2._d = input2;
  } else if (isArray$b(format2)) {
    configFromStringAndArray(config2);
  } else if (format2) {
    configFromStringAndFormat(config2);
  } else {
    configFromInput(config2);
  }
  if (!isValid(config2)) {
    config2._d = null;
  }
  return config2;
}
function configFromInput(config2) {
  var input2 = config2._i;
  if (isUndefined$1(input2)) {
    config2._d = new Date(hooks.now());
  } else if (isDate(input2)) {
    config2._d = new Date(input2.valueOf());
  } else if (typeof input2 === "string") {
    configFromString(config2);
  } else if (isArray$b(input2)) {
    config2._a = map$2(input2.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config2);
  } else if (isObject$h(input2)) {
    configFromObject(config2);
  } else if (isNumber(input2)) {
    config2._d = new Date(input2);
  } else {
    hooks.createFromInputFallback(config2);
  }
}
function createLocalOrUTC(input2, format2, locale2, strict, isUTC) {
  var c2 = {};
  if (format2 === true || format2 === false) {
    strict = format2;
    format2 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject$h(input2) && isObjectEmpty(input2) || isArray$b(input2) && input2.length === 0) {
    input2 = void 0;
  }
  c2._isAMomentObject = true;
  c2._useUTC = c2._isUTC = isUTC;
  c2._l = locale2;
  c2._i = input2;
  c2._f = format2;
  c2._strict = strict;
  return createFromConfig(c2);
}
function createLocal(input2, format2, locale2, strict) {
  return createLocalOrUTC(input2, format2, locale2, strict, false);
}
var prototypeMin = deprecate(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  }
), prototypeMax = deprecate(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
function pickBy$2(fn, moments) {
  var res, i2;
  if (moments.length === 1 && isArray$b(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i2 = 1; i2 < moments.length; ++i2) {
    if (!moments[i2].isValid() || moments[i2][fn](res)) {
      res = moments[i2];
    }
  }
  return res;
}
function min() {
  var args = [].slice.call(arguments, 0);
  return pickBy$2("isBefore", args);
}
function max() {
  var args = [].slice.call(arguments, 0);
  return pickBy$2("isAfter", args);
}
var now$3 = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m) {
  var key, unitHasDecimal = false, i2, orderLen = ordering.length;
  for (key in m) {
    if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
      return false;
    }
  }
  for (i2 = 0; i2 < orderLen; ++i2) {
    if (m[ordering[i2]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m[ordering[i2]]) !== toInt(m[ordering[i2]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
  minutes2 * 6e4 + // 1000 * 60
  hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
  for (i2 = 0; i2 < len; i2++) {
    if (toInt(array1[i2]) !== toInt(array2[i2])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset2 = this.utcOffset(), sign2 = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
offset("Z", ":");
offset("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input2, array, config2) {
  config2._useUTC = true;
  config2._tzm = offsetFromString(matchShortOffset, input2);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher, string) {
  var matches = (string || "").match(matcher), chunk, parts, minutes2;
  if (matches === null) {
    return null;
  }
  chunk = matches[matches.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input2, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input2) || isDate(input2) ? input2.valueOf() : createLocal(input2).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input2).local();
  }
}
function getDateOffset(m) {
  return -Math.round(m._d.getTimezoneOffset());
}
hooks.updateOffset = function() {
};
function getSetOffset(input2, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input2 != null ? this : NaN;
  }
  if (input2 != null) {
    if (typeof input2 === "string") {
      input2 = offsetFromString(matchShortOffset, input2);
      if (input2 === null) {
        return this;
      }
    } else if (Math.abs(input2) < 16 && !keepMinutes) {
      input2 = input2 * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input2;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input2) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(
          this,
          createDuration(input2 - offset2, "m"),
          1,
          false
        );
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input2, keepLocalTime) {
  if (input2 != null) {
    if (typeof input2 !== "string") {
      input2 = -input2;
    }
    this.utcOffset(input2, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input2) {
  if (!this.isValid()) {
    return false;
  }
  input2 = input2 ? createLocal(input2).utcOffset() : 0;
  return (this.utcOffset() - input2) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined$1(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c2 = {}, other;
  copyConfig(c2, this);
  c2 = prepareConfig(c2);
  if (c2._a) {
    other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
    this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input2, key) {
  var duration = input2, match = null, sign2, ret, diffRes;
  if (isDuration(input2)) {
    duration = {
      ms: input2._milliseconds,
      d: input2._days,
      M: input2._months
    };
  } else if (isNumber(input2) || !isNaN(+input2)) {
    duration = {};
    if (key) {
      duration[key] = +input2;
    } else {
      duration.milliseconds = +input2;
    }
  } else if (match = aspNetRegex.exec(input2)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match[DATE]) * sign2,
      h: toInt(match[HOUR]) * sign2,
      m: toInt(match[MINUTE]) * sign2,
      s: toInt(match[SECOND]) * sign2,
      ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
      // the millisecond decimal point is included in the match
    };
  } else if (match = isoRegex.exec(input2)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match[2], sign2),
      M: parseIso(match[3], sign2),
      w: parseIso(match[4], sign2),
      d: parseIso(match[5], sign2),
      h: parseIso(match[6], sign2),
      m: parseIso(match[7], sign2),
      s: parseIso(match[8], sign2)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(
      createLocal(duration.from),
      createLocal(duration.to)
    );
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input2) && hasOwnProp(input2, "_locale")) {
    ret._locale = input2._locale;
  }
  if (isDuration(input2) && hasOwnProp(input2, "_isValid")) {
    ret._isValid = input2._isValid;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name2) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(
        name2,
        "moment()." + name2 + "(period, number) is deprecated. Please use moment()." + name2 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      );
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth(mom, get$6(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1$1(mom, "Date", get$6(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
function isString$2(input2) {
  return typeof input2 === "string" || input2 instanceof String;
}
function isMomentInput(input2) {
  return isMoment(input2) || isDate(input2) || isString$2(input2) || isNumber(input2) || isNumberOrStringArray(input2) || isMomentInputObject(input2) || input2 === null || input2 === void 0;
}
function isMomentInputObject(input2) {
  var objectTest = isObject$h(input2) && !isObjectEmpty(input2), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i2, property2, propertyLen = properties.length;
  for (i2 = 0; i2 < propertyLen; i2 += 1) {
    property2 = properties[i2];
    propertyTest = propertyTest || hasOwnProp(input2, property2);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input2) {
  var arrayTest = isArray$b(input2), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input2.filter(function(item) {
      return !isNumber(item) && isString$2(input2);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input2) {
  var objectTest = isObject$h(input2) && !isObjectEmpty(input2), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i2, property2;
  for (i2 = 0; i2 < properties.length; i2 += 1) {
    property2 = properties[i2];
    propertyTest = propertyTest || hasOwnProp(input2, property2);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now3) {
  var diff2 = myMoment.diff(now3, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time = void 0;
    }
  }
  var now3 = time || createLocal(), sod = cloneWithOffset(now3, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction$2(formats[format2]) ? formats[format2].call(this, now3) : formats[format2]);
  return this.format(
    output || this.localeData().calendar(format2, this, createLocal(now3))
  );
}
function clone$5() {
  return new Moment(this);
}
function isAfter(input2, units) {
  var localInput = isMoment(input2) ? input2 : createLocal(input2);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input2, units) {
  var localInput = isMoment(input2) ? input2 : createLocal(input2);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from2, to2, units, inclusivity) {
  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input2, units) {
  var localInput = isMoment(input2) ? input2 : createLocal(input2), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input2, units) {
  return this.isSame(input2, units) || this.isAfter(input2, units);
}
function isSameOrBefore(input2, units) {
  return this.isSame(input2, units) || this.isBefore(input2, units);
}
function diff(input2, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input2, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a2, b) {
  if (a2.date() < b.date()) {
    return -monthDiff(b, a2);
  }
  var wholeMonthDiff = (b.year() - a2.year()) * 12 + (b.month() - a2.month()), anchor = a2.clone().add(wholeMonthDiff, "months"), anchor2, adjust2;
  if (b - anchor < 0) {
    anchor2 = a2.clone().add(wholeMonthDiff - 1, "months");
    adjust2 = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a2.clone().add(wholeMonthDiff + 1, "months");
    adjust2 = (b - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust2) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString$5() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
  if (m.year() < 0 || m.year() > 9999) {
    return formatMoment(
      m,
      utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  if (isFunction$2(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
    }
  }
  return formatMoment(
    m,
    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(key) {
    if (key === void 0) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  }
);
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return new Date(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return new Date(y, m, d).valueOf();
  }
}
function utcStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y, m, d);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      );
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      ) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf$1() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray() {
  var m = this;
  return [
    m.year(),
    m.month(),
    m.date(),
    m.hour(),
    m.minute(),
    m.second(),
    m.millisecond()
  ];
}
function toObject$1() {
  var m = this;
  return {
    years: m.year(),
    months: m.month(),
    date: m.date(),
    hours: m.hours(),
    minutes: m.minutes(),
    seconds: m.seconds(),
    milliseconds: m.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid(this);
}
function parsingFlags() {
  return extend2({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(input2, array, config2, token2) {
    var era = config2._locale.erasParse(input2, token2, config2._strict);
    if (era) {
      getParsingFlags(config2).era = era;
    } else {
      getParsingFlags(config2).invalidEra = input2;
    }
  }
);
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input2, array, config2, token2) {
  var match;
  if (config2._locale._eraYearOrdinalRegex) {
    match = input2.match(config2._locale._eraYearOrdinalRegex);
  }
  if (config2._locale.eraYearOrdinalParse) {
    array[YEAR] = config2._locale.eraYearOrdinalParse(input2, match);
  } else {
    array[YEAR] = parseInt(input2, 10);
  }
});
function localeEras(m, format2) {
  var i2, l, date, eras = this._eras || getLocale("en")._eras;
  for (i2 = 0, l = eras.length; i2 < l; ++i2) {
    switch (typeof eras[i2].since) {
      case "string":
        date = hooks(eras[i2].since).startOf("day");
        eras[i2].since = date.valueOf();
        break;
    }
    switch (typeof eras[i2].until) {
      case "undefined":
        eras[i2].until = Infinity;
        break;
      case "string":
        date = hooks(eras[i2].until).startOf("day").valueOf();
        eras[i2].until = date.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format2, strict) {
  var i2, l, eras = this.eras(), name2, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i2 = 0, l = eras.length; i2 < l; ++i2) {
    name2 = eras[i2].name.toUpperCase();
    abbr = eras[i2].abbr.toUpperCase();
    narrow = eras[i2].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i2];
          }
          break;
        case "NNNN":
          if (name2 === eraName) {
            return eras[i2];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i2];
          }
          break;
      }
    } else if ([name2, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i2];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i2, l, val, eras = this.localeData().eras();
  for (i2 = 0, l = eras.length; i2 < l; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].name;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i2, l, val, eras = this.localeData().eras();
  for (i2 = 0, l = eras.length; i2 < l; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].narrow;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i2, l, val, eras = this.localeData().eras();
  for (i2 = 0, l = eras.length; i2 < l; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].abbr;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i2, l, dir, val, eras = this.localeData().eras();
  for (i2 = 0, l = eras.length; i2 < l; ++i2) {
    dir = eras[i2].since <= eras[i2].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
      return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
  for (i2 = 0, l = eras.length; i2 < l; ++i2) {
    erasName = regexEscape$1(eras[i2].name);
    erasAbbr = regexEscape$1(eras[i2].abbr);
    erasNarrow = regexEscape$1(eras[i2].narrow);
    namePieces.push(erasName);
    abbrPieces.push(erasAbbr);
    narrowPieces.push(erasNarrow);
    mixedPieces.push(erasName);
    mixedPieces.push(erasAbbr);
    mixedPieces.push(erasNarrow);
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp(
    "^(" + narrowPieces.join("|") + ")",
    "i"
  );
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(input2, week, config2, token2) {
    week[token2.substr(0, 2)] = toInt(input2);
  }
);
addWeekParseToken(["gg", "GG"], function(input2, week, config2, token2) {
  week[token2] = hooks.parseTwoDigitYear(input2);
});
function getSetWeekYear(input2) {
  return getSetWeekYearHelper.call(
    this,
    input2,
    this.week(),
    this.weekday() + this.localeData()._week.dow,
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear(input2) {
  return getSetWeekYearHelper.call(
    this,
    input2,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input2, week, weekday, dow, doy) {
  var weeksTarget;
  if (input2 == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input2, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input2, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addRegexToken("Q", match1);
addParseToken("Q", function(input2, array) {
  array[MONTH] = (toInt(input2) - 1) * 3;
});
function getSetQuarter(input2) {
  return input2 == null ? Math.ceil((this.month() + 1) / 3) : this.month((input2 - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addRegexToken("D", match1to2, match1to2NoLeadingZero);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input2, array) {
  array[DATE] = toInt(input2.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input2, array, config2) {
  config2._dayOfYear = toInt(input2);
});
function getSetDayOfYear(input2) {
  var dayOfYear = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return input2 == null ? dayOfYear : this.add(input2 - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addRegexToken("m", match1to2, match1to2HasZero);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addRegexToken("s", match1to2, match1to2HasZero);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token, getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input2, array) {
  array[MILLISECOND] = toInt(("0." + input2) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add;
proto.calendar = calendar$1;
proto.clone = clone$5;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray;
proto.toObject = toObject$1;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON;
proto.toString = toString$5;
proto.unix = unix;
proto.valueOf = valueOf$1;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate(
  "dates accessor is deprecated. Use date instead.",
  getSetDayOfMonth
);
proto.months = deprecate(
  "months accessor is deprecated. Use month instead",
  getSetMonth
);
proto.years = deprecate(
  "years accessor is deprecated. Use year instead",
  getSetYear
);
proto.zone = deprecate(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  getSetZone
);
proto.isDSTShifted = deprecate(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  isDaylightSavingTimeShifted
);
function createUnix(input2) {
  return createLocal(input2 * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string) {
  return string;
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set$1;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1$1(format2, index2, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index2);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index2, field) {
  if (isNumber(format2)) {
    index2 = format2;
    format2 = void 0;
  }
  format2 = format2 || "";
  if (index2 != null) {
    return get$1$1(format2, index2, field, "month");
  }
  var i2, out = [];
  for (i2 = 0; i2 < 12; i2++) {
    out[i2] = get$1$1(format2, i2, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index2, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format2)) {
      index2 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index2 = format2;
    localeSorted = false;
    if (isNumber(format2)) {
      index2 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
  if (index2 != null) {
    return get$1$1(format2, (index2 + shift) % 7, field, "day");
  }
  for (i2 = 0; i2 < 7; i2++) {
    out[i2] = get$1$1(format2, (i2 + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index2) {
  return listMonthsImpl(format2, index2, "months");
}
function listMonthsShort(format2, index2) {
  return listMonthsImpl(format2, index2, "monthsShort");
}
function listWeekdays(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number) {
    var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
    return number + output;
  }
});
hooks.lang = deprecate(
  "moment.lang is deprecated. Use moment.locale instead.",
  getSetGlobalLocale
);
hooks.langData = deprecate(
  "moment.langData is deprecated. Use moment.localeData instead.",
  getLocale
);
var mathAbs = Math.abs;
function abs() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}
function addSubtract$1(duration, input2, value, direction) {
  var other = createDuration(input2, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1(input2, value) {
  return addSubtract$1(this, input2, value, 1);
}
function subtract$1(input2, value) {
  return addSubtract$1(this, input2, value, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data.days = days2;
  data.months = months2;
  data.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1$1 = asMilliseconds;
function clone$1$1() {
  return createDuration(this);
}
function get$2$1(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name2) {
  return function() {
    return this.isValid() ? this._data[name2] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round = Math.round, thresholds = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a2 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a2 = a2 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a2 = a2 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a2[2] = withoutSuffix;
  a2[3] = +posNegDuration > 0;
  a2[4] = locale2;
  return substituteTimeAgo.apply(null, a2);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1 = Math.abs;
function sign(x) {
  return (x > 0) - (x < 0) || +x;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1$1;
proto$2.get = get$2$1;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  toISOString$1
);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input2, array, config2) {
  config2._d = new Date(parseFloat(input2) * 1e3);
});
addParseToken("x", function(input2, array, config2) {
  config2._d = new Date(toInt(input2));
});
//! moment.js
hooks.version = "2.30.1";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min;
hooks.max = max;
hooks.now = now$3;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
const defaultFormats = {
  normalDateWithWeekday: "ddd, MMM D",
  normalDate: "D MMMM",
  shortDate: "MMM D",
  monthAndDate: "MMMM D",
  dayOfMonth: "D",
  year: "YYYY",
  month: "MMMM",
  monthShort: "MMM",
  monthAndYear: "MMMM YYYY",
  weekday: "dddd",
  weekdayShort: "ddd",
  minutes: "mm",
  hours12h: "hh",
  hours24h: "HH",
  seconds: "ss",
  fullTime: "LT",
  fullTime12h: "hh:mm A",
  fullTime24h: "HH:mm",
  fullDate: "ll",
  fullDateWithWeekday: "dddd, LL",
  fullDateTime: "lll",
  fullDateTime12h: "ll hh:mm A",
  fullDateTime24h: "ll HH:mm",
  keyboardDate: "L",
  keyboardDateTime: "L LT",
  keyboardDateTime12h: "L hh:mm A",
  keyboardDateTime24h: "L HH:mm"
};
class MomentUtils {
  constructor({ locale: locale2, formats, instance: instance2 } = {}) {
    this.lib = "moment";
    this.is12HourCycleInCurrentLocale = () => {
      return /A|a/.test(this.moment.localeData(this.getCurrentLocaleCode()).longDateFormat("LT"));
    };
    this.getFormatHelperText = (format2) => {
      var _a, _b;
      const localFormattingTokens2 = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})|./g;
      return (_b = (_a = format2.match(localFormattingTokens2)) === null || _a === void 0 ? void 0 : _a.map((token2) => {
        const firstCharacter = token2[0];
        if (firstCharacter === "L" || firstCharacter === ";") {
          return this.moment.localeData(this.getCurrentLocaleCode()).longDateFormat(token2);
        }
        return token2;
      }).join("").replace(/a/gi, "(a|p)m").toLocaleLowerCase()) !== null && _b !== void 0 ? _b : format2;
    };
    this.getCurrentLocaleCode = () => {
      return this.locale || this.moment.locale();
    };
    this.parseISO = (isoString) => {
      return this.moment(isoString, true);
    };
    this.toISO = (value) => {
      return value.toISOString();
    };
    this.parse = (value, format2) => {
      if (value === "") {
        return null;
      }
      if (this.locale) {
        return this.moment(value, format2, this.locale, true);
      }
      return this.moment(value, format2, true);
    };
    this.date = (value) => {
      if (value === null) {
        return null;
      }
      const moment2 = this.moment(value);
      if (this.locale) {
        moment2.locale(this.locale);
      }
      return moment2;
    };
    this.toJsDate = (value) => {
      return value.toDate();
    };
    this.isValid = (value) => {
      return this.moment(value).isValid();
    };
    this.isNull = (date) => {
      return date === null;
    };
    this.getDiff = (date, comparing, unit) => {
      if (!this.moment(comparing).isValid()) {
        return 0;
      }
      return date.diff(comparing, unit);
    };
    this.isAfter = (date, value) => {
      return date.isAfter(value);
    };
    this.isBefore = (date, value) => {
      return date.isBefore(value);
    };
    this.isAfterDay = (date, value) => {
      return date.isAfter(value, "day");
    };
    this.isBeforeDay = (date, value) => {
      return date.isBefore(value, "day");
    };
    this.isBeforeMonth = (date, value) => {
      return date.isBefore(value, "month");
    };
    this.isAfterMonth = (date, value) => {
      return date.isAfter(value, "month");
    };
    this.isBeforeYear = (date, value) => {
      return date.isBefore(value, "year");
    };
    this.isAfterYear = (date, value) => {
      return date.isAfter(value, "year");
    };
    this.startOfDay = (date) => {
      return date.clone().startOf("day");
    };
    this.endOfDay = (date) => {
      return date.clone().endOf("day");
    };
    this.format = (date, formatKey) => {
      return this.formatByString(date, this.formats[formatKey]);
    };
    this.formatByString = (date, formatString) => {
      const clonedDate = date.clone();
      if (this.locale) {
        clonedDate.locale(this.locale);
      }
      return clonedDate.format(formatString);
    };
    this.formatNumber = (numberToFormat) => {
      return numberToFormat;
    };
    this.getHours = (date) => {
      return date.get("hours");
    };
    this.addSeconds = (date, count2) => {
      return count2 < 0 ? date.clone().subtract(Math.abs(count2), "seconds") : date.clone().add(count2, "seconds");
    };
    this.addMinutes = (date, count2) => {
      return count2 < 0 ? date.clone().subtract(Math.abs(count2), "minutes") : date.clone().add(count2, "minutes");
    };
    this.addHours = (date, count2) => {
      return count2 < 0 ? date.clone().subtract(Math.abs(count2), "hours") : date.clone().add(count2, "hours");
    };
    this.addDays = (date, count2) => {
      return count2 < 0 ? date.clone().subtract(Math.abs(count2), "days") : date.clone().add(count2, "days");
    };
    this.addWeeks = (date, count2) => {
      return count2 < 0 ? date.clone().subtract(Math.abs(count2), "weeks") : date.clone().add(count2, "weeks");
    };
    this.addMonths = (date, count2) => {
      return count2 < 0 ? date.clone().subtract(Math.abs(count2), "months") : date.clone().add(count2, "months");
    };
    this.addYears = (date, count2) => {
      return count2 < 0 ? date.clone().subtract(Math.abs(count2), "years") : date.clone().add(count2, "years");
    };
    this.setHours = (date, count2) => {
      return date.clone().hours(count2);
    };
    this.getMinutes = (date) => {
      return date.get("minutes");
    };
    this.setMinutes = (date, count2) => {
      return date.clone().minutes(count2);
    };
    this.getSeconds = (date) => {
      return date.get("seconds");
    };
    this.setSeconds = (date, count2) => {
      return date.clone().seconds(count2);
    };
    this.getMonth = (date) => {
      return date.get("month");
    };
    this.getDaysInMonth = (date) => {
      return date.daysInMonth();
    };
    this.isSameDay = (date, comparing) => {
      return date.isSame(comparing, "day");
    };
    this.isSameMonth = (date, comparing) => {
      return date.isSame(comparing, "month");
    };
    this.isSameYear = (date, comparing) => {
      return date.isSame(comparing, "year");
    };
    this.isSameHour = (date, comparing) => {
      return date.isSame(comparing, "hour");
    };
    this.setMonth = (date, count2) => {
      return date.clone().month(count2);
    };
    this.getMeridiemText = (ampm) => {
      if (this.is12HourCycleInCurrentLocale()) {
        return this.moment.localeData(this.getCurrentLocaleCode()).meridiem(ampm === "am" ? 0 : 13, 0, false);
      }
      return ampm === "am" ? "AM" : "PM";
    };
    this.startOfYear = (date) => {
      return date.clone().startOf("year");
    };
    this.endOfYear = (date) => {
      return date.clone().endOf("year");
    };
    this.startOfMonth = (date) => {
      return date.clone().startOf("month");
    };
    this.endOfMonth = (date) => {
      return date.clone().endOf("month");
    };
    this.startOfWeek = (date) => {
      return date.clone().startOf("week");
    };
    this.endOfWeek = (date) => {
      return date.clone().endOf("week");
    };
    this.getNextMonth = (date) => {
      return date.clone().add(1, "month");
    };
    this.getPreviousMonth = (date) => {
      return date.clone().subtract(1, "month");
    };
    this.getMonthArray = (date) => {
      const firstMonth = date.clone().startOf("year");
      const monthArray = [firstMonth];
      while (monthArray.length < 12) {
        const prevMonth = monthArray[monthArray.length - 1];
        monthArray.push(this.getNextMonth(prevMonth));
      }
      return monthArray;
    };
    this.getYear = (date) => {
      return date.get("year");
    };
    this.setYear = (date, year) => {
      return date.clone().set("year", year);
    };
    this.getDate = (date) => {
      return date.get("date");
    };
    this.setDate = (date, year) => {
      return date.clone().set("date", year);
    };
    this.mergeDateAndTime = (date, time) => {
      return date.hour(time.hour()).minute(time.minute()).second(time.second());
    };
    this.getWeekdays = () => {
      return this.moment.weekdaysShort(true);
    };
    this.isEqual = (value, comparing) => {
      if (value === null && comparing === null) {
        return true;
      }
      return this.moment(value).isSame(comparing);
    };
    this.getWeekArray = (date) => {
      const start = date.clone().startOf("month").startOf("week");
      const end = date.clone().endOf("month").endOf("week");
      let count2 = 0;
      let current = start;
      const nestedWeeks = [];
      while (current.isBefore(end)) {
        const weekNumber = Math.floor(count2 / 7);
        nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
        nestedWeeks[weekNumber].push(current);
        current = current.clone().add(1, "day");
        count2 += 1;
      }
      return nestedWeeks;
    };
    this.getYearRange = (start, end) => {
      const startDate = this.moment(start).startOf("year");
      const endDate = this.moment(end).endOf("year");
      const years2 = [];
      let current = startDate;
      while (current.isBefore(endDate)) {
        years2.push(current);
        current = current.clone().add(1, "year");
      }
      return years2;
    };
    this.isWithinRange = (date, [start, end]) => {
      return date.isBetween(start, end, null, "[]");
    };
    this.moment = instance2 || hooks;
    this.locale = locale2;
    this.formats = Object.assign({}, defaultFormats, formats);
  }
}
const name = "@mui/x-date-pickers";
const version$1 = "5.0.20";
const description = "The community edition of the date picker components (MUI X).";
const author = "MUI Team";
const main = "./node/index.js";
const license = "MIT";
const bugs = {
  url: "https://github.com/mui/mui-x/issues"
};
const homepage = "https://mui.com/x/react-date-pickers/getting-started/";
const funding = {
  type: "opencollective",
  url: "https://opencollective.com/mui"
};
const sideEffects = false;
const publishConfig = {
  access: "public"
};
const keywords = [
  "react",
  "react-component",
  "mui",
  "material-ui",
  "material design",
  "datepicker",
  "timepicker",
  "datetimepicker"
];
const repository = {
  type: "git",
  url: "https://github.com/mui/mui-x.git",
  directory: "packages/x-date-pickers"
};
const dependencies = {
  "@babel/runtime": "^7.18.9",
  "@date-io/core": "^2.15.0",
  "@date-io/date-fns": "^2.15.0",
  "@date-io/dayjs": "^2.15.0",
  "@date-io/luxon": "^2.15.0",
  "@date-io/moment": "^2.15.0",
  "@mui/utils": "^5.10.3",
  "@types/react-transition-group": "^4.4.5",
  clsx: "^1.2.1",
  "prop-types": "^15.7.2",
  "react-transition-group": "^4.4.5",
  rifm: "^0.12.1"
};
const peerDependencies = {
  "@emotion/react": "^11.9.0",
  "@emotion/styled": "^11.8.1",
  "@mui/material": "^5.4.1",
  "@mui/system": "^5.4.1",
  "date-fns": "^2.25.0",
  dayjs: "^1.10.7",
  luxon: "^1.28.0 || ^2.0.0 || ^3.0.0",
  moment: "^2.29.1",
  react: "^17.0.2 || ^18.0.0",
  "react-dom": "^17.0.2 || ^18.0.0"
};
const peerDependenciesMeta = {
  "date-fns": {
    optional: true
  },
  dayjs: {
    optional: true
  },
  "@emotion/react": {
    optional: true
  },
  "@emotion/styled": {
    optional: true
  },
  luxon: {
    optional: true
  },
  moment: {
    optional: true
  }
};
const setupFiles = [
  "<rootDir>/src/setupTests.js"
];
const engines = {
  node: ">=12.0.0"
};
const module$1 = "./index.js";
const types$5 = "./index.d.ts";
const xdpPackage = {
  name,
  version: version$1,
  description,
  author,
  main,
  license,
  bugs,
  homepage,
  funding,
  sideEffects,
  publishConfig,
  keywords,
  repository,
  dependencies,
  peerDependencies,
  peerDependenciesMeta,
  setupFiles,
  engines,
  "private": false,
  module: module$1,
  types: types$5
};
const MuiTextWidget = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var readonly = props.readonly, placeholder2 = props.placeholder, customProps = props.customProps, maxLength = props.maxLength;
  props.errorMessage;
  var onChange = reactExports.useCallback(function(e2) {
    var val = e2.target.value;
    if (val === "") val = void 0;
    setValue4(val);
  }, [setValue4]);
  var textValue = value || "";
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(TextField, _extends$h({
    variant: "standard",
    value: textValue,
    placeholder: !readonly ? placeholder2 : "",
    InputProps: {
      readOnly: readonly
    },
    inputProps: {
      maxLength
    },
    disabled: readonly,
    onChange,
    size: "small"
  }, customProps)));
};
const MuiTextAreaWidget = function(props) {
  var value = props.value, setValue4 = props.setValue, config2 = props.config, readonly = props.readonly, placeholder2 = props.placeholder, customProps = props.customProps, maxLength = props.maxLength, maxRows = props.maxRows, fullWidth2 = props.fullWidth;
  var defaultMaxRows = config2.settings.defaultMaxRows;
  var onChange = function onChange2(e2) {
    var val = e2.target.value;
    if (val === "") val = void 0;
    setValue4(val);
  };
  var textValue = value || "";
  return /* @__PURE__ */ React.createElement(FormControl, {
    fullWidth: fullWidth2
  }, /* @__PURE__ */ React.createElement(TextField, _extends$h({
    variant: "standard",
    fullWidth: fullWidth2,
    maxRows: maxRows || defaultMaxRows,
    multiline: true,
    value: textValue,
    placeholder: !readonly ? placeholder2 : "",
    InputProps: {
      readOnly: readonly
    },
    inputProps: {
      maxLength
    },
    disabled: readonly,
    onChange,
    size: "small"
  }, customProps)));
};
function _arrayWithoutHoles(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray$h(r2);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(r2) {
  return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray$h(r2) || _nonIterableSpread();
}
var DELETE = "delete";
var SHIFT = 5;
var SIZE = 1 << SHIFT;
var MASK = SIZE - 1;
var NOT_SET = {};
function MakeRef() {
  return { value: false };
}
function SetRef(ref2) {
  if (ref2) {
    ref2.value = true;
  }
}
function OwnerID() {
}
function ensureSize(iter) {
  if (iter.size === void 0) {
    iter.size = iter.__iterate(returnTrue);
  }
  return iter.size;
}
function wrapIndex(iter, index2) {
  if (typeof index2 !== "number") {
    var uint32Index = index2 >>> 0;
    if ("" + uint32Index !== index2 || uint32Index === 4294967295) {
      return NaN;
    }
    index2 = uint32Index;
  }
  return index2 < 0 ? ensureSize(iter) + index2 : index2;
}
function returnTrue() {
  return true;
}
function wholeSlice(begin, end, size) {
  return (begin === 0 && !isNeg(begin) || size !== void 0 && begin <= -size) && (end === void 0 || size !== void 0 && end >= size);
}
function resolveBegin(begin, size) {
  return resolveIndex(begin, size, 0);
}
function resolveEnd(end, size) {
  return resolveIndex(end, size, size);
}
function resolveIndex(index2, size, defaultIndex) {
  return index2 === void 0 ? defaultIndex : isNeg(index2) ? size === Infinity ? size : Math.max(0, size + index2) | 0 : size === void 0 || size === index2 ? index2 : Math.min(size, index2) | 0;
}
function isNeg(value) {
  return value < 0 || value === 0 && 1 / value === -Infinity;
}
var IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isCollection(maybeCollection) {
  return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
}
var IS_KEYED_SYMBOL = "@@__IMMUTABLE_KEYED__@@";
function isKeyed(maybeKeyed) {
  return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
}
var IS_INDEXED_SYMBOL = "@@__IMMUTABLE_INDEXED__@@";
function isIndexed(maybeIndexed) {
  return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
}
function isAssociative(maybeAssociative) {
  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}
var Collection = function Collection2(value) {
  return isCollection(value) ? value : Seq(value);
};
var KeyedCollection = /* @__PURE__ */ function(Collection3) {
  function KeyedCollection2(value) {
    return isKeyed(value) ? value : KeyedSeq(value);
  }
  if (Collection3) KeyedCollection2.__proto__ = Collection3;
  KeyedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  KeyedCollection2.prototype.constructor = KeyedCollection2;
  return KeyedCollection2;
}(Collection);
var IndexedCollection = /* @__PURE__ */ function(Collection3) {
  function IndexedCollection2(value) {
    return isIndexed(value) ? value : IndexedSeq(value);
  }
  if (Collection3) IndexedCollection2.__proto__ = Collection3;
  IndexedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  IndexedCollection2.prototype.constructor = IndexedCollection2;
  return IndexedCollection2;
}(Collection);
var SetCollection = /* @__PURE__ */ function(Collection3) {
  function SetCollection2(value) {
    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
  }
  if (Collection3) SetCollection2.__proto__ = Collection3;
  SetCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  SetCollection2.prototype.constructor = SetCollection2;
  return SetCollection2;
}(Collection);
Collection.Keyed = KeyedCollection;
Collection.Indexed = IndexedCollection;
Collection.Set = SetCollection;
var IS_SEQ_SYMBOL = "@@__IMMUTABLE_SEQ__@@";
function isSeq(maybeSeq) {
  return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
}
var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
function isRecord(maybeRecord) {
  return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
}
function isImmutable$2(maybeImmutable) {
  return isCollection(maybeImmutable) || isRecord(maybeImmutable);
}
var IS_ORDERED_SYMBOL = "@@__IMMUTABLE_ORDERED__@@";
function isOrdered(maybeOrdered) {
  return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
}
var ITERATE_KEYS = 0;
var ITERATE_VALUES = 1;
var ITERATE_ENTRIES = 2;
var REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = "@@iterator";
var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
var Iterator = function Iterator2(next) {
  this.next = next;
};
Iterator.prototype.toString = function toString() {
  return "[Iterator]";
};
Iterator.KEYS = ITERATE_KEYS;
Iterator.VALUES = ITERATE_VALUES;
Iterator.ENTRIES = ITERATE_ENTRIES;
Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
  return this.toString();
};
Iterator.prototype[ITERATOR_SYMBOL] = function() {
  return this;
};
function iteratorValue(type2, k, v, iteratorResult) {
  var value = type2 === 0 ? k : type2 === 1 ? v : [k, v];
  iteratorResult ? iteratorResult.value = value : iteratorResult = {
    value,
    done: false
  };
  return iteratorResult;
}
function iteratorDone() {
  return { value: void 0, done: true };
}
function hasIterator(maybeIterable) {
  if (Array.isArray(maybeIterable)) {
    return true;
  }
  return !!getIteratorFn(maybeIterable);
}
function isIterator(maybeIterator) {
  return maybeIterator && typeof maybeIterator.next === "function";
}
function getIterator(iterable) {
  var iteratorFn = getIteratorFn(iterable);
  return iteratorFn && iteratorFn.call(iterable);
}
function getIteratorFn(iterable) {
  var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === "function") {
    return iteratorFn;
  }
}
function isEntriesIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.entries;
}
function isKeysIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.keys;
}
var hasOwnProperty$g = Object.prototype.hasOwnProperty;
function isArrayLike$6(value) {
  if (Array.isArray(value) || typeof value === "string") {
    return true;
  }
  return value && typeof value === "object" && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ? (
    // Only {length: 0} is considered Array-like.
    Object.keys(value).length === 1
  ) : (
    // An object is only Array-like if it has a property where the last value
    // in the array-like may be found (which could be undefined).
    value.hasOwnProperty(value.length - 1)
  ));
}
var Seq = /* @__PURE__ */ function(Collection3) {
  function Seq2(value) {
    return value === void 0 || value === null ? emptySequence() : isImmutable$2(value) ? value.toSeq() : seqFromValue(value);
  }
  if (Collection3) Seq2.__proto__ = Collection3;
  Seq2.prototype = Object.create(Collection3 && Collection3.prototype);
  Seq2.prototype.constructor = Seq2;
  Seq2.prototype.toSeq = function toSeq3() {
    return this;
  };
  Seq2.prototype.toString = function toString6() {
    return this.__toString("Seq {", "}");
  };
  Seq2.prototype.cacheResult = function cacheResult() {
    if (!this._cache && this.__iterateUncached) {
      this._cache = this.entrySeq().toArray();
      this.size = this._cache.length;
    }
    return this;
  };
  Seq2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var cache = this._cache;
    if (cache) {
      var size = cache.length;
      var i2 = 0;
      while (i2 !== size) {
        var entry = cache[reverse3 ? size - ++i2 : i2++];
        if (fn(entry[1], entry[0], this) === false) {
          break;
        }
      }
      return i2;
    }
    return this.__iterateUncached(fn, reverse3);
  };
  Seq2.prototype.__iterator = function __iterator2(type2, reverse3) {
    var cache = this._cache;
    if (cache) {
      var size = cache.length;
      var i2 = 0;
      return new Iterator(function() {
        if (i2 === size) {
          return iteratorDone();
        }
        var entry = cache[reverse3 ? size - ++i2 : i2++];
        return iteratorValue(type2, entry[0], entry[1]);
      });
    }
    return this.__iteratorUncached(type2, reverse3);
  };
  return Seq2;
}(Collection);
var KeyedSeq = /* @__PURE__ */ function(Seq2) {
  function KeyedSeq2(value) {
    return value === void 0 || value === null ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
  }
  if (Seq2) KeyedSeq2.__proto__ = Seq2;
  KeyedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  KeyedSeq2.prototype.constructor = KeyedSeq2;
  KeyedSeq2.prototype.toKeyedSeq = function toKeyedSeq3() {
    return this;
  };
  return KeyedSeq2;
}(Seq);
var IndexedSeq = /* @__PURE__ */ function(Seq2) {
  function IndexedSeq2(value) {
    return value === void 0 || value === null ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
  }
  if (Seq2) IndexedSeq2.__proto__ = Seq2;
  IndexedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  IndexedSeq2.prototype.constructor = IndexedSeq2;
  IndexedSeq2.of = function of() {
    return IndexedSeq2(arguments);
  };
  IndexedSeq2.prototype.toIndexedSeq = function toIndexedSeq2() {
    return this;
  };
  IndexedSeq2.prototype.toString = function toString6() {
    return this.__toString("Seq [", "]");
  };
  return IndexedSeq2;
}(Seq);
var SetSeq = /* @__PURE__ */ function(Seq2) {
  function SetSeq2(value) {
    return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
  }
  if (Seq2) SetSeq2.__proto__ = Seq2;
  SetSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  SetSeq2.prototype.constructor = SetSeq2;
  SetSeq2.of = function of() {
    return SetSeq2(arguments);
  };
  SetSeq2.prototype.toSetSeq = function toSetSeq2() {
    return this;
  };
  return SetSeq2;
}(Seq);
Seq.isSeq = isSeq;
Seq.Keyed = KeyedSeq;
Seq.Set = SetSeq;
Seq.Indexed = IndexedSeq;
Seq.prototype[IS_SEQ_SYMBOL] = true;
var ArraySeq = /* @__PURE__ */ function(IndexedSeq2) {
  function ArraySeq2(array) {
    this._array = array;
    this.size = array.length;
  }
  if (IndexedSeq2) ArraySeq2.__proto__ = IndexedSeq2;
  ArraySeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  ArraySeq2.prototype.constructor = ArraySeq2;
  ArraySeq2.prototype.get = function get12(index2, notSetValue) {
    return this.has(index2) ? this._array[wrapIndex(this, index2)] : notSetValue;
  };
  ArraySeq2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var array = this._array;
    var size = array.length;
    var i2 = 0;
    while (i2 !== size) {
      var ii = reverse3 ? size - ++i2 : i2++;
      if (fn(array[ii], ii, this) === false) {
        break;
      }
    }
    return i2;
  };
  ArraySeq2.prototype.__iterator = function __iterator2(type2, reverse3) {
    var array = this._array;
    var size = array.length;
    var i2 = 0;
    return new Iterator(function() {
      if (i2 === size) {
        return iteratorDone();
      }
      var ii = reverse3 ? size - ++i2 : i2++;
      return iteratorValue(type2, ii, array[ii]);
    });
  };
  return ArraySeq2;
}(IndexedSeq);
var ObjectSeq = /* @__PURE__ */ function(KeyedSeq2) {
  function ObjectSeq2(object) {
    var keys4 = Object.keys(object).concat(
      Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : []
    );
    this._object = object;
    this._keys = keys4;
    this.size = keys4.length;
  }
  if (KeyedSeq2) ObjectSeq2.__proto__ = KeyedSeq2;
  ObjectSeq2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  ObjectSeq2.prototype.constructor = ObjectSeq2;
  ObjectSeq2.prototype.get = function get12(key, notSetValue) {
    if (notSetValue !== void 0 && !this.has(key)) {
      return notSetValue;
    }
    return this._object[key];
  };
  ObjectSeq2.prototype.has = function has5(key) {
    return hasOwnProperty$g.call(this._object, key);
  };
  ObjectSeq2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var object = this._object;
    var keys4 = this._keys;
    var size = keys4.length;
    var i2 = 0;
    while (i2 !== size) {
      var key = keys4[reverse3 ? size - ++i2 : i2++];
      if (fn(object[key], key, this) === false) {
        break;
      }
    }
    return i2;
  };
  ObjectSeq2.prototype.__iterator = function __iterator2(type2, reverse3) {
    var object = this._object;
    var keys4 = this._keys;
    var size = keys4.length;
    var i2 = 0;
    return new Iterator(function() {
      if (i2 === size) {
        return iteratorDone();
      }
      var key = keys4[reverse3 ? size - ++i2 : i2++];
      return iteratorValue(type2, key, object[key]);
    });
  };
  return ObjectSeq2;
}(KeyedSeq);
ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;
var CollectionSeq = /* @__PURE__ */ function(IndexedSeq2) {
  function CollectionSeq2(collection) {
    this._collection = collection;
    this.size = collection.length || collection.size;
  }
  if (IndexedSeq2) CollectionSeq2.__proto__ = IndexedSeq2;
  CollectionSeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  CollectionSeq2.prototype.constructor = CollectionSeq2;
  CollectionSeq2.prototype.__iterateUncached = function __iterateUncached(fn, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    var iterations = 0;
    if (isIterator(iterator)) {
      var step;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
    }
    return iterations;
  };
  CollectionSeq2.prototype.__iteratorUncached = function __iteratorUncached(type2, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterator(type2, reverse3);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    if (!isIterator(iterator)) {
      return new Iterator(iteratorDone);
    }
    var iterations = 0;
    return new Iterator(function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type2, iterations++, step.value);
    });
  };
  return CollectionSeq2;
}(IndexedSeq);
var EMPTY_SEQ;
function emptySequence() {
  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}
function keyedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq.fromEntrySeq();
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    "Expected Array or collection object of [k, v] entries, or keyed object: " + value
  );
}
function indexedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq;
  }
  throw new TypeError(
    "Expected Array or collection object of values: " + value
  );
}
function seqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return isEntriesIterable(value) ? seq.fromEntrySeq() : isKeysIterable(value) ? seq.toSetSeq() : seq;
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    "Expected Array or collection object of values, or keyed object: " + value
  );
}
function maybeIndexedSeqFromValue(value) {
  return isArrayLike$6(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : void 0;
}
var IS_MAP_SYMBOL = "@@__IMMUTABLE_MAP__@@";
function isMap$2(maybeMap) {
  return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
}
function isOrderedMap(maybeOrderedMap) {
  return isMap$2(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}
function isValueObject(maybeValue) {
  return Boolean(
    maybeValue && typeof maybeValue.equals === "function" && typeof maybeValue.hashCode === "function"
  );
}
function is2(valueA, valueB) {
  if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
    return true;
  }
  if (!valueA || !valueB) {
    return false;
  }
  if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
    valueA = valueA.valueOf();
    valueB = valueB.valueOf();
    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
  }
  return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
}
var imul = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul2(a2, b) {
  a2 |= 0;
  b |= 0;
  var c2 = a2 & 65535;
  var d = b & 65535;
  return c2 * d + ((a2 >>> 16) * d + c2 * (b >>> 16) << 16 >>> 0) | 0;
};
function smi(i32) {
  return i32 >>> 1 & 1073741824 | i32 & 3221225471;
}
var defaultValueOf = Object.prototype.valueOf;
function hash(o) {
  if (o == null) {
    return hashNullish(o);
  }
  if (typeof o.hashCode === "function") {
    return smi(o.hashCode(o));
  }
  var v = valueOf(o);
  if (v == null) {
    return hashNullish(v);
  }
  switch (typeof v) {
    case "boolean":
      return v ? 1108378657 : 1108378656;
    case "number":
      return hashNumber(v);
    case "string":
      return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);
    case "object":
    case "function":
      return hashJSObj(v);
    case "symbol":
      return hashSymbol(v);
    default:
      if (typeof v.toString === "function") {
        return hashString(v.toString());
      }
      throw new Error("Value type " + typeof v + " cannot be hashed.");
  }
}
function hashNullish(nullish) {
  return nullish === null ? 1108378658 : (
    /* undefined */
    1108378659
  );
}
function hashNumber(n2) {
  if (n2 !== n2 || n2 === Infinity) {
    return 0;
  }
  var hash2 = n2 | 0;
  if (hash2 !== n2) {
    hash2 ^= n2 * 4294967295;
  }
  while (n2 > 4294967295) {
    n2 /= 4294967295;
    hash2 ^= n2;
  }
  return smi(hash2);
}
function cachedHashString(string) {
  var hashed = stringHashCache[string];
  if (hashed === void 0) {
    hashed = hashString(string);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string] = hashed;
  }
  return hashed;
}
function hashString(string) {
  var hashed = 0;
  for (var ii = 0; ii < string.length; ii++) {
    hashed = 31 * hashed + string.charCodeAt(ii) | 0;
  }
  return smi(hashed);
}
function hashSymbol(sym) {
  var hashed = symbolMap[sym];
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  symbolMap[sym] = hashed;
  return hashed;
}
function hashJSObj(obj) {
  var hashed;
  if (usingWeakMap) {
    hashed = weakMap.get(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = obj[UID_HASH_KEY];
  if (hashed !== void 0) {
    return hashed;
  }
  if (!canDefineProperty) {
    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
    if (hashed !== void 0) {
      return hashed;
    }
    hashed = getIENodeHash(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = nextHash();
  if (usingWeakMap) {
    weakMap.set(obj, hashed);
  } else if (isExtensible !== void 0 && isExtensible(obj) === false) {
    throw new Error("Non-extensible objects are not allowed as keys.");
  } else if (canDefineProperty) {
    Object.defineProperty(obj, UID_HASH_KEY, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: hashed
    });
  } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
    obj.propertyIsEnumerable = function() {
      return this.constructor.prototype.propertyIsEnumerable.apply(
        this,
        arguments
      );
    };
    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
  } else if (obj.nodeType !== void 0) {
    obj[UID_HASH_KEY] = hashed;
  } else {
    throw new Error("Unable to set a non-enumerable property on object.");
  }
  return hashed;
}
var isExtensible = Object.isExtensible;
var canDefineProperty = function() {
  try {
    Object.defineProperty({}, "@", {});
    return true;
  } catch (e2) {
    return false;
  }
}();
function getIENodeHash(node) {
  if (node && node.nodeType > 0) {
    switch (node.nodeType) {
      case 1:
        return node.uniqueID;
      case 9:
        return node.documentElement && node.documentElement.uniqueID;
    }
  }
}
function valueOf(obj) {
  return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? obj.valueOf(obj) : obj;
}
function nextHash() {
  var nextHash2 = ++_objHashUID;
  if (_objHashUID & 1073741824) {
    _objHashUID = 0;
  }
  return nextHash2;
}
var usingWeakMap = typeof WeakMap === "function";
var weakMap;
if (usingWeakMap) {
  weakMap = /* @__PURE__ */ new WeakMap();
}
var symbolMap = /* @__PURE__ */ Object.create(null);
var _objHashUID = 0;
var UID_HASH_KEY = "__immutablehash__";
if (typeof Symbol === "function") {
  UID_HASH_KEY = Symbol(UID_HASH_KEY);
}
var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var stringHashCache = {};
var ToKeyedSequence = /* @__PURE__ */ function(KeyedSeq2) {
  function ToKeyedSequence2(indexed, useKeys) {
    this._iter = indexed;
    this._useKeys = useKeys;
    this.size = indexed.size;
  }
  if (KeyedSeq2) ToKeyedSequence2.__proto__ = KeyedSeq2;
  ToKeyedSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  ToKeyedSequence2.prototype.constructor = ToKeyedSequence2;
  ToKeyedSequence2.prototype.get = function get12(key, notSetValue) {
    return this._iter.get(key, notSetValue);
  };
  ToKeyedSequence2.prototype.has = function has5(key) {
    return this._iter.has(key);
  };
  ToKeyedSequence2.prototype.valueSeq = function valueSeq2() {
    return this._iter.valueSeq();
  };
  ToKeyedSequence2.prototype.reverse = function reverse3() {
    var this$1$1 = this;
    var reversedSequence = reverseFactory(this, true);
    if (!this._useKeys) {
      reversedSequence.valueSeq = function() {
        return this$1$1._iter.toSeq().reverse();
      };
    }
    return reversedSequence;
  };
  ToKeyedSequence2.prototype.map = function map3(mapper, context2) {
    var this$1$1 = this;
    var mappedSequence = mapFactory(this, mapper, context2);
    if (!this._useKeys) {
      mappedSequence.valueSeq = function() {
        return this$1$1._iter.toSeq().map(mapper, context2);
      };
    }
    return mappedSequence;
  };
  ToKeyedSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(v, k) {
      return fn(v, k, this$1$1);
    }, reverse3);
  };
  ToKeyedSequence2.prototype.__iterator = function __iterator2(type2, reverse3) {
    return this._iter.__iterator(type2, reverse3);
  };
  return ToKeyedSequence2;
}(KeyedSeq);
ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;
var ToIndexedSequence = /* @__PURE__ */ function(IndexedSeq2) {
  function ToIndexedSequence2(iter) {
    this._iter = iter;
    this.size = iter.size;
  }
  if (IndexedSeq2) ToIndexedSequence2.__proto__ = IndexedSeq2;
  ToIndexedSequence2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  ToIndexedSequence2.prototype.constructor = ToIndexedSequence2;
  ToIndexedSequence2.prototype.includes = function includes3(value) {
    return this._iter.includes(value);
  };
  ToIndexedSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    var i2 = 0;
    reverse3 && ensureSize(this);
    return this._iter.__iterate(
      function(v) {
        return fn(v, reverse3 ? this$1$1.size - ++i2 : i2++, this$1$1);
      },
      reverse3
    );
  };
  ToIndexedSequence2.prototype.__iterator = function __iterator2(type2, reverse3) {
    var this$1$1 = this;
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
    var i2 = 0;
    reverse3 && ensureSize(this);
    return new Iterator(function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(
        type2,
        reverse3 ? this$1$1.size - ++i2 : i2++,
        step.value,
        step
      );
    });
  };
  return ToIndexedSequence2;
}(IndexedSeq);
var ToSetSequence = /* @__PURE__ */ function(SetSeq2) {
  function ToSetSequence2(iter) {
    this._iter = iter;
    this.size = iter.size;
  }
  if (SetSeq2) ToSetSequence2.__proto__ = SetSeq2;
  ToSetSequence2.prototype = Object.create(SetSeq2 && SetSeq2.prototype);
  ToSetSequence2.prototype.constructor = ToSetSequence2;
  ToSetSequence2.prototype.has = function has5(key) {
    return this._iter.includes(key);
  };
  ToSetSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(v) {
      return fn(v, v, this$1$1);
    }, reverse3);
  };
  ToSetSequence2.prototype.__iterator = function __iterator2(type2, reverse3) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type2, step.value, step.value, step);
    });
  };
  return ToSetSequence2;
}(SetSeq);
var FromEntriesSequence = /* @__PURE__ */ function(KeyedSeq2) {
  function FromEntriesSequence2(entries3) {
    this._iter = entries3;
    this.size = entries3.size;
  }
  if (KeyedSeq2) FromEntriesSequence2.__proto__ = KeyedSeq2;
  FromEntriesSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  FromEntriesSequence2.prototype.constructor = FromEntriesSequence2;
  FromEntriesSequence2.prototype.entrySeq = function entrySeq2() {
    return this._iter.toSeq();
  };
  FromEntriesSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(entry) {
      if (entry) {
        validateEntry(entry);
        var indexedCollection = isCollection(entry);
        return fn(
          indexedCollection ? entry.get(1) : entry[1],
          indexedCollection ? entry.get(0) : entry[0],
          this$1$1
        );
      }
    }, reverse3);
  };
  FromEntriesSequence2.prototype.__iterator = function __iterator2(type2, reverse3) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
    return new Iterator(function() {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        if (entry) {
          validateEntry(entry);
          var indexedCollection = isCollection(entry);
          return iteratorValue(
            type2,
            indexedCollection ? entry.get(0) : entry[0],
            indexedCollection ? entry.get(1) : entry[1],
            step
          );
        }
      }
    });
  };
  return FromEntriesSequence2;
}(KeyedSeq);
ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
function flipFactory(collection) {
  var flipSequence = makeSequence(collection);
  flipSequence._iter = collection;
  flipSequence.size = collection.size;
  flipSequence.flip = function() {
    return collection;
  };
  flipSequence.reverse = function() {
    var reversedSequence = collection.reverse.apply(this);
    reversedSequence.flip = function() {
      return collection.reverse();
    };
    return reversedSequence;
  };
  flipSequence.has = function(key) {
    return collection.includes(key);
  };
  flipSequence.includes = function(key) {
    return collection.has(key);
  };
  flipSequence.cacheResult = cacheResultThrough;
  flipSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(function(v, k) {
      return fn(k, v, this$1$1) !== false;
    }, reverse3);
  };
  flipSequence.__iteratorUncached = function(type2, reverse3) {
    if (type2 === ITERATE_ENTRIES) {
      var iterator = collection.__iterator(type2, reverse3);
      return new Iterator(function() {
        var step = iterator.next();
        if (!step.done) {
          var k = step.value[0];
          step.value[0] = step.value[1];
          step.value[1] = k;
        }
        return step;
      });
    }
    return collection.__iterator(
      type2 === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
      reverse3
    );
  };
  return flipSequence;
}
function mapFactory(collection, mapper, context2) {
  var mappedSequence = makeSequence(collection);
  mappedSequence.size = collection.size;
  mappedSequence.has = function(key) {
    return collection.has(key);
  };
  mappedSequence.get = function(key, notSetValue) {
    var v = collection.get(key, NOT_SET);
    return v === NOT_SET ? notSetValue : mapper.call(context2, v, key, collection);
  };
  mappedSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(
      function(v, k, c2) {
        return fn(mapper.call(context2, v, k, c2), k, this$1$1) !== false;
      },
      reverse3
    );
  };
  mappedSequence.__iteratorUncached = function(type2, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var key = entry[0];
      return iteratorValue(
        type2,
        key,
        mapper.call(context2, entry[1], key, collection),
        step
      );
    });
  };
  return mappedSequence;
}
function reverseFactory(collection, useKeys) {
  var this$1$1 = this;
  var reversedSequence = makeSequence(collection);
  reversedSequence._iter = collection;
  reversedSequence.size = collection.size;
  reversedSequence.reverse = function() {
    return collection;
  };
  if (collection.flip) {
    reversedSequence.flip = function() {
      var flipSequence = flipFactory(collection);
      flipSequence.reverse = function() {
        return collection.flip();
      };
      return flipSequence;
    };
  }
  reversedSequence.get = function(key, notSetValue) {
    return collection.get(useKeys ? key : -1 - key, notSetValue);
  };
  reversedSequence.has = function(key) {
    return collection.has(useKeys ? key : -1 - key);
  };
  reversedSequence.includes = function(value) {
    return collection.includes(value);
  };
  reversedSequence.cacheResult = cacheResultThrough;
  reversedSequence.__iterate = function(fn, reverse3) {
    var this$1$12 = this;
    var i2 = 0;
    reverse3 && ensureSize(collection);
    return collection.__iterate(
      function(v, k) {
        return fn(v, useKeys ? k : reverse3 ? this$1$12.size - ++i2 : i2++, this$1$12);
      },
      !reverse3
    );
  };
  reversedSequence.__iterator = function(type2, reverse3) {
    var i2 = 0;
    reverse3 && ensureSize(collection);
    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      return iteratorValue(
        type2,
        useKeys ? entry[0] : reverse3 ? this$1$1.size - ++i2 : i2++,
        entry[1],
        step
      );
    });
  };
  return reversedSequence;
}
function filterFactory(collection, predicate, context2, useKeys) {
  var filterSequence = makeSequence(collection);
  if (useKeys) {
    filterSequence.has = function(key) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && !!predicate.call(context2, v, key, collection);
    };
    filterSequence.get = function(key, notSetValue) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && predicate.call(context2, v, key, collection) ? v : notSetValue;
    };
  }
  filterSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(function(v, k, c2) {
      if (predicate.call(context2, v, k, c2)) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1);
      }
    }, reverse3);
    return iterations;
  };
  filterSequence.__iteratorUncached = function(type2, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterations = 0;
    return new Iterator(function() {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        var value = entry[1];
        if (predicate.call(context2, value, key, collection)) {
          return iteratorValue(type2, useKeys ? key : iterations++, value, step);
        }
      }
    });
  };
  return filterSequence;
}
function countByFactory(collection, grouper, context2) {
  var groups = Map$2().asMutable();
  collection.__iterate(function(v, k) {
    groups.update(grouper.call(context2, v, k, collection), 0, function(a2) {
      return a2 + 1;
    });
  });
  return groups.asImmutable();
}
function groupByFactory(collection, grouper, context2) {
  var isKeyedIter = isKeyed(collection);
  var groups = (isOrdered(collection) ? OrderedMap() : Map$2()).asMutable();
  collection.__iterate(function(v, k) {
    groups.update(
      grouper.call(context2, v, k, collection),
      function(a2) {
        return a2 = a2 || [], a2.push(isKeyedIter ? [k, v] : v), a2;
      }
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function(arr) {
    return reify(collection, coerce(arr));
  }).asImmutable();
}
function partitionFactory(collection, predicate, context2) {
  var isKeyedIter = isKeyed(collection);
  var groups = [[], []];
  collection.__iterate(function(v, k) {
    groups[predicate.call(context2, v, k, collection) ? 1 : 0].push(
      isKeyedIter ? [k, v] : v
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function(arr) {
    return reify(collection, coerce(arr));
  });
}
function sliceFactory(collection, begin, end, useKeys) {
  var originalSize = collection.size;
  if (wholeSlice(begin, end, originalSize)) {
    return collection;
  }
  if (typeof originalSize === "undefined" && (begin < 0 || end < 0)) {
    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
  }
  var resolvedBegin = resolveBegin(begin, originalSize);
  var resolvedEnd = resolveEnd(end, originalSize);
  var resolvedSize = resolvedEnd - resolvedBegin;
  var sliceSize;
  if (resolvedSize === resolvedSize) {
    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
  }
  var sliceSeq = makeSequence(collection);
  sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || void 0;
  if (!useKeys && isSeq(collection) && sliceSize >= 0) {
    sliceSeq.get = function(index2, notSetValue) {
      index2 = wrapIndex(this, index2);
      return index2 >= 0 && index2 < sliceSize ? collection.get(index2 + resolvedBegin, notSetValue) : notSetValue;
    };
  }
  sliceSeq.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (sliceSize === 0) {
      return 0;
    }
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var skipped = 0;
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v, k) {
      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1) !== false && iterations !== sliceSize;
      }
    });
    return iterations;
  };
  sliceSeq.__iteratorUncached = function(type2, reverse3) {
    if (sliceSize !== 0 && reverse3) {
      return this.cacheResult().__iterator(type2, reverse3);
    }
    if (sliceSize === 0) {
      return new Iterator(iteratorDone);
    }
    var iterator = collection.__iterator(type2, reverse3);
    var skipped = 0;
    var iterations = 0;
    return new Iterator(function() {
      while (skipped++ < resolvedBegin) {
        iterator.next();
      }
      if (++iterations > sliceSize) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (useKeys || type2 === ITERATE_VALUES || step.done) {
        return step;
      }
      if (type2 === ITERATE_KEYS) {
        return iteratorValue(type2, iterations - 1, void 0, step);
      }
      return iteratorValue(type2, iterations - 1, step.value[1], step);
    });
  };
  return sliceSeq;
}
function takeWhileFactory(collection, predicate, context2) {
  var takeSequence = makeSequence(collection);
  takeSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var iterations = 0;
    collection.__iterate(
      function(v, k, c2) {
        return predicate.call(context2, v, k, c2) && ++iterations && fn(v, k, this$1$1);
      }
    );
    return iterations;
  };
  takeSequence.__iteratorUncached = function(type2, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type2, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterating = true;
    return new Iterator(function() {
      if (!iterating) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var k = entry[0];
      var v = entry[1];
      if (!predicate.call(context2, v, k, this$1$1)) {
        iterating = false;
        return iteratorDone();
      }
      return type2 === ITERATE_ENTRIES ? step : iteratorValue(type2, k, v, step);
    });
  };
  return takeSequence;
}
function skipWhileFactory(collection, predicate, context2, useKeys) {
  var skipSequence = makeSequence(collection);
  skipSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v, k, c2) {
      if (!(isSkipping && (isSkipping = predicate.call(context2, v, k, c2)))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1);
      }
    });
    return iterations;
  };
  skipSequence.__iteratorUncached = function(type2, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type2, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var skipping = true;
    var iterations = 0;
    return new Iterator(function() {
      var step;
      var k;
      var v;
      do {
        step = iterator.next();
        if (step.done) {
          if (useKeys || type2 === ITERATE_VALUES) {
            return step;
          }
          if (type2 === ITERATE_KEYS) {
            return iteratorValue(type2, iterations++, void 0, step);
          }
          return iteratorValue(type2, iterations++, step.value[1], step);
        }
        var entry = step.value;
        k = entry[0];
        v = entry[1];
        skipping && (skipping = predicate.call(context2, v, k, this$1$1));
      } while (skipping);
      return type2 === ITERATE_ENTRIES ? step : iteratorValue(type2, k, v, step);
    });
  };
  return skipSequence;
}
function concatFactory(collection, values2) {
  var isKeyedCollection = isKeyed(collection);
  var iters = [collection].concat(values2).map(function(v) {
    if (!isCollection(v)) {
      v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
    } else if (isKeyedCollection) {
      v = KeyedCollection(v);
    }
    return v;
  }).filter(function(v) {
    return v.size !== 0;
  });
  if (iters.length === 0) {
    return collection;
  }
  if (iters.length === 1) {
    var singleton = iters[0];
    if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
      return singleton;
    }
  }
  var concatSeq = new ArraySeq(iters);
  if (isKeyedCollection) {
    concatSeq = concatSeq.toKeyedSeq();
  } else if (!isIndexed(collection)) {
    concatSeq = concatSeq.toSetSeq();
  }
  concatSeq = concatSeq.flatten(true);
  concatSeq.size = iters.reduce(function(sum, seq) {
    if (sum !== void 0) {
      var size = seq.size;
      if (size !== void 0) {
        return sum + size;
      }
    }
  }, 0);
  return concatSeq;
}
function flattenFactory(collection, depth, useKeys) {
  var flatSequence = makeSequence(collection);
  flatSequence.__iterateUncached = function(fn, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var iterations = 0;
    var stopped = false;
    function flatDeep(iter, currentDepth) {
      iter.__iterate(function(v, k) {
        if ((!depth || currentDepth < depth) && isCollection(v)) {
          flatDeep(v, currentDepth + 1);
        } else {
          iterations++;
          if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
            stopped = true;
          }
        }
        return !stopped;
      }, reverse3);
    }
    flatDeep(collection, 0);
    return iterations;
  };
  flatSequence.__iteratorUncached = function(type2, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterator(type2, reverse3);
    }
    var iterator = collection.__iterator(type2, reverse3);
    var stack = [];
    var iterations = 0;
    return new Iterator(function() {
      while (iterator) {
        var step = iterator.next();
        if (step.done !== false) {
          iterator = stack.pop();
          continue;
        }
        var v = step.value;
        if (type2 === ITERATE_ENTRIES) {
          v = v[1];
        }
        if ((!depth || stack.length < depth) && isCollection(v)) {
          stack.push(iterator);
          iterator = v.__iterator(type2, reverse3);
        } else {
          return useKeys ? step : iteratorValue(type2, iterations++, v, step);
        }
      }
      return iteratorDone();
    });
  };
  return flatSequence;
}
function flatMapFactory(collection, mapper, context2) {
  var coerce = collectionClass(collection);
  return collection.toSeq().map(function(v, k) {
    return coerce(mapper.call(context2, v, k, collection));
  }).flatten(true);
}
function interposeFactory(collection, separator) {
  var interposedSequence = makeSequence(collection);
  interposedSequence.size = collection.size && collection.size * 2 - 1;
  interposedSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(
      function(v) {
        return (!iterations || fn(separator, iterations++, this$1$1) !== false) && fn(v, iterations++, this$1$1) !== false;
      },
      reverse3
    );
    return iterations;
  };
  interposedSequence.__iteratorUncached = function(type2, reverse3) {
    var iterator = collection.__iterator(ITERATE_VALUES, reverse3);
    var iterations = 0;
    var step;
    return new Iterator(function() {
      if (!step || iterations % 2) {
        step = iterator.next();
        if (step.done) {
          return step;
        }
      }
      return iterations % 2 ? iteratorValue(type2, iterations++, separator) : iteratorValue(type2, iterations++, step.value, step);
    });
  };
  return interposedSequence;
}
function sortFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  var isKeyedCollection = isKeyed(collection);
  var index2 = 0;
  var entries3 = collection.toSeq().map(function(v, k) {
    return [k, v, index2++, mapper ? mapper(v, k, collection) : v];
  }).valueSeq().toArray();
  entries3.sort(function(a2, b) {
    return comparator(a2[3], b[3]) || a2[2] - b[2];
  }).forEach(
    isKeyedCollection ? function(v, i2) {
      entries3[i2].length = 2;
    } : function(v, i2) {
      entries3[i2] = v[1];
    }
  );
  return isKeyedCollection ? KeyedSeq(entries3) : isIndexed(collection) ? IndexedSeq(entries3) : SetSeq(entries3);
}
function maxFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  if (mapper) {
    var entry = collection.toSeq().map(function(v, k) {
      return [v, mapper(v, k, collection)];
    }).reduce(function(a2, b) {
      return maxCompare(comparator, a2[1], b[1]) ? b : a2;
    });
    return entry && entry[0];
  }
  return collection.reduce(function(a2, b) {
    return maxCompare(comparator, a2, b) ? b : a2;
  });
}
function maxCompare(comparator, a2, b) {
  var comp = comparator(b, a2);
  return comp === 0 && b !== a2 && (b === void 0 || b === null || b !== b) || comp > 0;
}
function zipWithFactory(keyIter, zipper, iters, zipAll2) {
  var zipSequence = makeSequence(keyIter);
  var sizes = new ArraySeq(iters).map(function(i2) {
    return i2.size;
  });
  zipSequence.size = zipAll2 ? sizes.max() : sizes.min();
  zipSequence.__iterate = function(fn, reverse3) {
    var iterator = this.__iterator(ITERATE_VALUES, reverse3);
    var step;
    var iterations = 0;
    while (!(step = iterator.next()).done) {
      if (fn(step.value, iterations++, this) === false) {
        break;
      }
    }
    return iterations;
  };
  zipSequence.__iteratorUncached = function(type2, reverse3) {
    var iterators = iters.map(
      function(i2) {
        return i2 = Collection(i2), getIterator(reverse3 ? i2.reverse() : i2);
      }
    );
    var iterations = 0;
    var isDone = false;
    return new Iterator(function() {
      var steps;
      if (!isDone) {
        steps = iterators.map(function(i2) {
          return i2.next();
        });
        isDone = zipAll2 ? steps.every(function(s2) {
          return s2.done;
        }) : steps.some(function(s2) {
          return s2.done;
        });
      }
      if (isDone) {
        return iteratorDone();
      }
      return iteratorValue(
        type2,
        iterations++,
        zipper.apply(
          null,
          steps.map(function(s2) {
            return s2.value;
          })
        )
      );
    });
  };
  return zipSequence;
}
function reify(iter, seq) {
  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
}
function validateEntry(entry) {
  if (entry !== Object(entry)) {
    throw new TypeError("Expected [K, V] tuple: " + entry);
  }
}
function collectionClass(collection) {
  return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
}
function makeSequence(collection) {
  return Object.create(
    (isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype
  );
}
function cacheResultThrough() {
  if (this._iter.cacheResult) {
    this._iter.cacheResult();
    this.size = this._iter.size;
    return this;
  }
  return Seq.prototype.cacheResult.call(this);
}
function defaultComparator(a2, b) {
  if (a2 === void 0 && b === void 0) {
    return 0;
  }
  if (a2 === void 0) {
    return 1;
  }
  if (b === void 0) {
    return -1;
  }
  return a2 > b ? 1 : a2 < b ? -1 : 0;
}
function arrCopy(arr, offset2) {
  offset2 = offset2 || 0;
  var len = Math.max(0, arr.length - offset2);
  var newArr = new Array(len);
  for (var ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset2];
  }
  return newArr;
}
function invariant(condition, error2) {
  if (!condition) {
    throw new Error(error2);
  }
}
function assertNotInfinite(size) {
  invariant(
    size !== Infinity,
    "Cannot perform this action with an infinite size."
  );
}
function coerceKeyPath(keyPath) {
  if (isArrayLike$6(keyPath) && typeof keyPath !== "string") {
    return keyPath;
  }
  if (isOrdered(keyPath)) {
    return keyPath.toArray();
  }
  throw new TypeError(
    "Invalid keyPath: expected Ordered Collection or Array: " + keyPath
  );
}
var toString$4 = Object.prototype.toString;
function isPlainObject$4(value) {
  if (!value || typeof value !== "object" || toString$4.call(value) !== "[object Object]") {
    return false;
  }
  var proto2 = Object.getPrototypeOf(value);
  if (proto2 === null) {
    return true;
  }
  var parentProto = proto2;
  var nextProto = Object.getPrototypeOf(proto2);
  while (nextProto !== null) {
    parentProto = nextProto;
    nextProto = Object.getPrototypeOf(parentProto);
  }
  return parentProto === proto2;
}
function isDataStructure(value) {
  return typeof value === "object" && (isImmutable$2(value) || Array.isArray(value) || isPlainObject$4(value));
}
function quoteString(value) {
  try {
    return typeof value === "string" ? JSON.stringify(value) : String(value);
  } catch (_ignoreError) {
    return JSON.stringify(value);
  }
}
function has(collection, key) {
  return isImmutable$2(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty$g.call(collection, key);
}
function get$5(collection, key, notSetValue) {
  return isImmutable$2(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === "function" ? collection.get(key) : collection[key];
}
function shallowCopy$1(from2) {
  if (Array.isArray(from2)) {
    return arrCopy(from2);
  }
  var to2 = {};
  for (var key in from2) {
    if (hasOwnProperty$g.call(from2, key)) {
      to2[key] = from2[key];
    }
  }
  return to2;
}
function remove(collection, key) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot update non-data-structure value: " + collection
    );
  }
  if (isImmutable$2(collection)) {
    if (!collection.remove) {
      throw new TypeError(
        "Cannot update immutable value without .remove() method: " + collection
      );
    }
    return collection.remove(key);
  }
  if (!hasOwnProperty$g.call(collection, key)) {
    return collection;
  }
  var collectionCopy = shallowCopy$1(collection);
  if (Array.isArray(collectionCopy)) {
    collectionCopy.splice(key, 1);
  } else {
    delete collectionCopy[key];
  }
  return collectionCopy;
}
function set(collection, key, value) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot update non-data-structure value: " + collection
    );
  }
  if (isImmutable$2(collection)) {
    if (!collection.set) {
      throw new TypeError(
        "Cannot update immutable value without .set() method: " + collection
      );
    }
    return collection.set(key, value);
  }
  if (hasOwnProperty$g.call(collection, key) && value === collection[key]) {
    return collection;
  }
  var collectionCopy = shallowCopy$1(collection);
  collectionCopy[key] = value;
  return collectionCopy;
}
function updateIn$1(collection, keyPath, notSetValue, updater) {
  if (!updater) {
    updater = notSetValue;
    notSetValue = void 0;
  }
  var updatedValue = updateInDeeply(
    isImmutable$2(collection),
    collection,
    coerceKeyPath(keyPath),
    0,
    notSetValue,
    updater
  );
  return updatedValue === NOT_SET ? notSetValue : updatedValue;
}
function updateInDeeply(inImmutable, existing, keyPath, i2, notSetValue, updater) {
  var wasNotSet = existing === NOT_SET;
  if (i2 === keyPath.length) {
    var existingValue = wasNotSet ? notSetValue : existing;
    var newValue = updater(existingValue);
    return newValue === existingValue ? existing : newValue;
  }
  if (!wasNotSet && !isDataStructure(existing)) {
    throw new TypeError(
      "Cannot update within non-data-structure value in path [" + keyPath.slice(0, i2).map(quoteString) + "]: " + existing
    );
  }
  var key = keyPath[i2];
  var nextExisting = wasNotSet ? NOT_SET : get$5(existing, key, NOT_SET);
  var nextUpdated = updateInDeeply(
    nextExisting === NOT_SET ? inImmutable : isImmutable$2(nextExisting),
    nextExisting,
    keyPath,
    i2 + 1,
    notSetValue,
    updater
  );
  return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key) : set(
    wasNotSet ? inImmutable ? emptyMap() : {} : existing,
    key,
    nextUpdated
  );
}
function setIn$1(collection, keyPath, value) {
  return updateIn$1(collection, keyPath, NOT_SET, function() {
    return value;
  });
}
function setIn(keyPath, v) {
  return setIn$1(this, keyPath, v);
}
function removeIn(collection, keyPath) {
  return updateIn$1(collection, keyPath, function() {
    return NOT_SET;
  });
}
function deleteIn(keyPath) {
  return removeIn(this, keyPath);
}
function update$1(collection, key, notSetValue, updater) {
  return updateIn$1(collection, [key], notSetValue, updater);
}
function update(key, notSetValue, updater) {
  return arguments.length === 1 ? key(this) : update$1(this, key, notSetValue, updater);
}
function updateIn(keyPath, notSetValue, updater) {
  return updateIn$1(this, keyPath, notSetValue, updater);
}
function merge$1$1() {
  var iters = [], len = arguments.length;
  while (len--) iters[len] = arguments[len];
  return mergeIntoKeyedWith(this, iters);
}
function mergeWith$1$1(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  if (typeof merger !== "function") {
    throw new TypeError("Invalid merger function: " + merger);
  }
  return mergeIntoKeyedWith(this, iters, merger);
}
function mergeIntoKeyedWith(collection, collections, merger) {
  var iters = [];
  for (var ii = 0; ii < collections.length; ii++) {
    var collection$1 = KeyedCollection(collections[ii]);
    if (collection$1.size !== 0) {
      iters.push(collection$1);
    }
  }
  if (iters.length === 0) {
    return collection;
  }
  if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {
    return collection.constructor(iters[0]);
  }
  return collection.withMutations(function(collection2) {
    var mergeIntoCollection = merger ? function(value, key) {
      update$1(
        collection2,
        key,
        NOT_SET,
        function(oldVal) {
          return oldVal === NOT_SET ? value : merger(oldVal, value, key);
        }
      );
    } : function(value, key) {
      collection2.set(key, value);
    };
    for (var ii2 = 0; ii2 < iters.length; ii2++) {
      iters[ii2].forEach(mergeIntoCollection);
    }
  });
}
function merge$3(collection) {
  var sources = [], len = arguments.length - 1;
  while (len-- > 0) sources[len] = arguments[len + 1];
  return mergeWithSources(collection, sources);
}
function mergeWith$2(merger, collection) {
  var sources = [], len = arguments.length - 2;
  while (len-- > 0) sources[len] = arguments[len + 2];
  return mergeWithSources(collection, sources, merger);
}
function mergeDeep$1(collection) {
  var sources = [], len = arguments.length - 1;
  while (len-- > 0) sources[len] = arguments[len + 1];
  return mergeDeepWithSources(collection, sources);
}
function mergeDeepWith$1(merger, collection) {
  var sources = [], len = arguments.length - 2;
  while (len-- > 0) sources[len] = arguments[len + 2];
  return mergeDeepWithSources(collection, sources, merger);
}
function mergeDeepWithSources(collection, sources, merger) {
  return mergeWithSources(collection, sources, deepMergerWith(merger));
}
function mergeWithSources(collection, sources, merger) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot merge into non-data-structure value: " + collection
    );
  }
  if (isImmutable$2(collection)) {
    return typeof merger === "function" && collection.mergeWith ? collection.mergeWith.apply(collection, [merger].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);
  }
  var isArray3 = Array.isArray(collection);
  var merged = collection;
  var Collection3 = isArray3 ? IndexedCollection : KeyedCollection;
  var mergeItem = isArray3 ? function(value) {
    if (merged === collection) {
      merged = shallowCopy$1(merged);
    }
    merged.push(value);
  } : function(value, key) {
    var hasVal = hasOwnProperty$g.call(merged, key);
    var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;
    if (!hasVal || nextVal !== merged[key]) {
      if (merged === collection) {
        merged = shallowCopy$1(merged);
      }
      merged[key] = nextVal;
    }
  };
  for (var i2 = 0; i2 < sources.length; i2++) {
    Collection3(sources[i2]).forEach(mergeItem);
  }
  return merged;
}
function deepMergerWith(merger) {
  function deepMerger(oldValue, newValue, key) {
    return isDataStructure(oldValue) && isDataStructure(newValue) && areMergeable(oldValue, newValue) ? mergeWithSources(oldValue, [newValue], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;
  }
  return deepMerger;
}
function areMergeable(oldDataStructure, newDataStructure) {
  var oldSeq = Seq(oldDataStructure);
  var newSeq = Seq(newDataStructure);
  return isIndexed(oldSeq) === isIndexed(newSeq) && isKeyed(oldSeq) === isKeyed(newSeq);
}
function mergeDeep() {
  var iters = [], len = arguments.length;
  while (len--) iters[len] = arguments[len];
  return mergeDeepWithSources(this, iters);
}
function mergeDeepWith(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  return mergeDeepWithSources(this, iters, merger);
}
function mergeIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  return updateIn$1(this, keyPath, emptyMap(), function(m) {
    return mergeWithSources(m, iters);
  });
}
function mergeDeepIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  return updateIn$1(
    this,
    keyPath,
    emptyMap(),
    function(m) {
      return mergeDeepWithSources(m, iters);
    }
  );
}
function withMutations(fn) {
  var mutable = this.asMutable();
  fn(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}
function asMutable() {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}
function asImmutable() {
  return this.__ensureOwner();
}
function wasAltered() {
  return this.__altered;
}
var Map$2 = /* @__PURE__ */ function(KeyedCollection2) {
  function Map2(value) {
    return value === void 0 || value === null ? emptyMap() : isMap$2(value) && !isOrdered(value) ? value : emptyMap().withMutations(function(map3) {
      var iter = KeyedCollection2(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v, k) {
        return map3.set(k, v);
      });
    });
  }
  if (KeyedCollection2) Map2.__proto__ = KeyedCollection2;
  Map2.prototype = Object.create(KeyedCollection2 && KeyedCollection2.prototype);
  Map2.prototype.constructor = Map2;
  Map2.of = function of() {
    var keyValues = [], len = arguments.length;
    while (len--) keyValues[len] = arguments[len];
    return emptyMap().withMutations(function(map3) {
      for (var i2 = 0; i2 < keyValues.length; i2 += 2) {
        if (i2 + 1 >= keyValues.length) {
          throw new Error("Missing value for key: " + keyValues[i2]);
        }
        map3.set(keyValues[i2], keyValues[i2 + 1]);
      }
    });
  };
  Map2.prototype.toString = function toString6() {
    return this.__toString("Map {", "}");
  };
  Map2.prototype.get = function get12(k, notSetValue) {
    return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
  };
  Map2.prototype.set = function set3(k, v) {
    return updateMap(this, k, v);
  };
  Map2.prototype.remove = function remove3(k) {
    return updateMap(this, k, NOT_SET);
  };
  Map2.prototype.deleteAll = function deleteAll(keys4) {
    var collection = Collection(keys4);
    if (collection.size === 0) {
      return this;
    }
    return this.withMutations(function(map3) {
      collection.forEach(function(key) {
        return map3.remove(key);
      });
    });
  };
  Map2.prototype.clear = function clear2() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._root = null;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyMap();
  };
  Map2.prototype.sort = function sort2(comparator) {
    return OrderedMap(sortFactory(this, comparator));
  };
  Map2.prototype.sortBy = function sortBy2(mapper, comparator) {
    return OrderedMap(sortFactory(this, comparator, mapper));
  };
  Map2.prototype.map = function map3(mapper, context2) {
    var this$1$1 = this;
    return this.withMutations(function(map4) {
      map4.forEach(function(value, key) {
        map4.set(key, mapper.call(context2, value, key, this$1$1));
      });
    });
  };
  Map2.prototype.__iterator = function __iterator2(type2, reverse3) {
    return new MapIterator(this, type2, reverse3);
  };
  Map2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    this._root && this._root.iterate(function(entry) {
      iterations++;
      return fn(entry[1], entry[0], this$1$1);
    }, reverse3);
    return iterations;
  };
  Map2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeMap(this.size, this._root, ownerID, this.__hash);
  };
  return Map2;
}(KeyedCollection);
Map$2.isMap = isMap$2;
var MapPrototype = Map$2.prototype;
MapPrototype[IS_MAP_SYMBOL] = true;
MapPrototype[DELETE] = MapPrototype.remove;
MapPrototype.removeAll = MapPrototype.deleteAll;
MapPrototype.setIn = setIn;
MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
MapPrototype.update = update;
MapPrototype.updateIn = updateIn;
MapPrototype.merge = MapPrototype.concat = merge$1$1;
MapPrototype.mergeWith = mergeWith$1$1;
MapPrototype.mergeDeep = mergeDeep;
MapPrototype.mergeDeepWith = mergeDeepWith;
MapPrototype.mergeIn = mergeIn;
MapPrototype.mergeDeepIn = mergeDeepIn;
MapPrototype.withMutations = withMutations;
MapPrototype.wasAltered = wasAltered;
MapPrototype.asImmutable = asImmutable;
MapPrototype["@@transducer/init"] = MapPrototype.asMutable = asMutable;
MapPrototype["@@transducer/step"] = function(result, arr) {
  return result.set(arr[0], arr[1]);
};
MapPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
var ArrayMapNode = function ArrayMapNode2(ownerID, entries3) {
  this.ownerID = ownerID;
  this.entries = entries3;
};
ArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
  var entries3 = this.entries;
  for (var ii = 0, len = entries3.length; ii < len; ii++) {
    if (is2(key, entries3[ii][0])) {
      return entries3[ii][1];
    }
  }
  return notSetValue;
};
ArrayMapNode.prototype.update = function update2(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var entries3 = this.entries;
  var idx = 0;
  var len = entries3.length;
  for (; idx < len; idx++) {
    if (is2(key, entries3[idx][0])) {
      break;
    }
  }
  var exists = idx < len;
  if (exists ? entries3[idx][1] === value : removed) {
    return this;
  }
  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);
  if (removed && entries3.length === 1) {
    return;
  }
  if (!exists && !removed && entries3.length >= MAX_ARRAY_MAP_SIZE) {
    return createNodes(ownerID, entries3, key, value);
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries3 : arrCopy(entries3);
  if (exists) {
    if (removed) {
      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }
  if (isEditable) {
    this.entries = newEntries;
    return this;
  }
  return new ArrayMapNode(ownerID, newEntries);
};
var BitmapIndexedNode = function BitmapIndexedNode2(ownerID, bitmap, nodes) {
  this.ownerID = ownerID;
  this.bitmap = bitmap;
  this.nodes = nodes;
};
BitmapIndexedNode.prototype.get = function get2(shift, keyHash, key, notSetValue) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
  var bitmap = this.bitmap;
  return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(
    shift + SHIFT,
    keyHash,
    key,
    notSetValue
  );
};
BitmapIndexedNode.prototype.update = function update3(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var bit = 1 << keyHashFrag;
  var bitmap = this.bitmap;
  var exists = (bitmap & bit) !== 0;
  if (!exists && value === NOT_SET) {
    return this;
  }
  var idx = popCount(bitmap & bit - 1);
  var nodes = this.nodes;
  var node = exists ? nodes[idx] : void 0;
  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
  if (newNode === node) {
    return this;
  }
  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
  }
  if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
    return nodes[idx ^ 1];
  }
  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
    return newNode;
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
  var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
  if (isEditable) {
    this.bitmap = newBitmap;
    this.nodes = newNodes;
    return this;
  }
  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
};
var HashArrayMapNode = function HashArrayMapNode2(ownerID, count2, nodes) {
  this.ownerID = ownerID;
  this.count = count2;
  this.nodes = nodes;
};
HashArrayMapNode.prototype.get = function get3(shift, keyHash, key, notSetValue) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var node = this.nodes[idx];
  return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
};
HashArrayMapNode.prototype.update = function update4(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var removed = value === NOT_SET;
  var nodes = this.nodes;
  var node = nodes[idx];
  if (removed && !node) {
    return this;
  }
  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
  if (newNode === node) {
    return this;
  }
  var newCount = this.count;
  if (!node) {
    newCount++;
  } else if (!newNode) {
    newCount--;
    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
      return packNodes(ownerID, nodes, newCount, idx);
    }
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newNodes = setAt(nodes, idx, newNode, isEditable);
  if (isEditable) {
    this.count = newCount;
    this.nodes = newNodes;
    return this;
  }
  return new HashArrayMapNode(ownerID, newCount, newNodes);
};
var HashCollisionNode = function HashCollisionNode2(ownerID, keyHash, entries3) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entries = entries3;
};
HashCollisionNode.prototype.get = function get4(shift, keyHash, key, notSetValue) {
  var entries3 = this.entries;
  for (var ii = 0, len = entries3.length; ii < len; ii++) {
    if (is2(key, entries3[ii][0])) {
      return entries3[ii][1];
    }
  }
  return notSetValue;
};
HashCollisionNode.prototype.update = function update5(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var removed = value === NOT_SET;
  if (keyHash !== this.keyHash) {
    if (removed) {
      return this;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
  }
  var entries3 = this.entries;
  var idx = 0;
  var len = entries3.length;
  for (; idx < len; idx++) {
    if (is2(key, entries3[idx][0])) {
      break;
    }
  }
  var exists = idx < len;
  if (exists ? entries3[idx][1] === value : removed) {
    return this;
  }
  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);
  if (removed && len === 2) {
    return new ValueNode(ownerID, this.keyHash, entries3[idx ^ 1]);
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries3 : arrCopy(entries3);
  if (exists) {
    if (removed) {
      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }
  if (isEditable) {
    this.entries = newEntries;
    return this;
  }
  return new HashCollisionNode(ownerID, this.keyHash, newEntries);
};
var ValueNode = function ValueNode2(ownerID, keyHash, entry) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entry = entry;
};
ValueNode.prototype.get = function get5(shift, keyHash, key, notSetValue) {
  return is2(key, this.entry[0]) ? this.entry[1] : notSetValue;
};
ValueNode.prototype.update = function update6(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var keyMatch = is2(key, this.entry[0]);
  if (keyMatch ? value === this.entry[1] : removed) {
    return this;
  }
  SetRef(didAlter);
  if (removed) {
    SetRef(didChangeSize);
    return;
  }
  if (keyMatch) {
    if (ownerID && ownerID === this.ownerID) {
      this.entry[1] = value;
      return this;
    }
    return new ValueNode(ownerID, this.keyHash, [key, value]);
  }
  SetRef(didChangeSize);
  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
};
ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn, reverse3) {
  var entries3 = this.entries;
  for (var ii = 0, maxIndex = entries3.length - 1; ii <= maxIndex; ii++) {
    if (fn(entries3[reverse3 ? maxIndex - ii : ii]) === false) {
      return false;
    }
  }
};
BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn, reverse3) {
  var nodes = this.nodes;
  for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
    var node = nodes[reverse3 ? maxIndex - ii : ii];
    if (node && node.iterate(fn, reverse3) === false) {
      return false;
    }
  }
};
ValueNode.prototype.iterate = function(fn, reverse3) {
  return fn(this.entry);
};
var MapIterator = /* @__PURE__ */ function(Iterator3) {
  function MapIterator2(map3, type2, reverse3) {
    this._type = type2;
    this._reverse = reverse3;
    this._stack = map3._root && mapIteratorFrame(map3._root);
  }
  if (Iterator3) MapIterator2.__proto__ = Iterator3;
  MapIterator2.prototype = Object.create(Iterator3 && Iterator3.prototype);
  MapIterator2.prototype.constructor = MapIterator2;
  MapIterator2.prototype.next = function next() {
    var type2 = this._type;
    var stack = this._stack;
    while (stack) {
      var node = stack.node;
      var index2 = stack.index++;
      var maxIndex = void 0;
      if (node.entry) {
        if (index2 === 0) {
          return mapIteratorValue(type2, node.entry);
        }
      } else if (node.entries) {
        maxIndex = node.entries.length - 1;
        if (index2 <= maxIndex) {
          return mapIteratorValue(
            type2,
            node.entries[this._reverse ? maxIndex - index2 : index2]
          );
        }
      } else {
        maxIndex = node.nodes.length - 1;
        if (index2 <= maxIndex) {
          var subNode = node.nodes[this._reverse ? maxIndex - index2 : index2];
          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type2, subNode.entry);
            }
            stack = this._stack = mapIteratorFrame(subNode, stack);
          }
          continue;
        }
      }
      stack = this._stack = this._stack.__prev;
    }
    return iteratorDone();
  };
  return MapIterator2;
}(Iterator);
function mapIteratorValue(type2, entry) {
  return iteratorValue(type2, entry[0], entry[1]);
}
function mapIteratorFrame(node, prev) {
  return {
    node,
    index: 0,
    __prev: prev
  };
}
function makeMap(size, root2, ownerID, hash2) {
  var map3 = Object.create(MapPrototype);
  map3.size = size;
  map3._root = root2;
  map3.__ownerID = ownerID;
  map3.__hash = hash2;
  map3.__altered = false;
  return map3;
}
var EMPTY_MAP;
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map3, k, v) {
  var newRoot;
  var newSize;
  if (!map3._root) {
    if (v === NOT_SET) {
      return map3;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map3.__ownerID, [[k, v]]);
  } else {
    var didChangeSize = MakeRef();
    var didAlter = MakeRef();
    newRoot = updateNode(
      map3._root,
      map3.__ownerID,
      0,
      void 0,
      k,
      v,
      didChangeSize,
      didAlter
    );
    if (!didAlter.value) {
      return map3;
    }
    newSize = map3.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
  }
  if (map3.__ownerID) {
    map3.size = newSize;
    map3._root = newRoot;
    map3.__hash = void 0;
    map3.__altered = true;
    return map3;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value]);
  }
  return node.update(
    ownerID,
    shift,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
}
function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
  }
  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var newNode;
  var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}
function createNodes(ownerID, entries3, key, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  var node = new ValueNode(ownerID, hash(key), [key, value]);
  for (var ii = 0; ii < entries3.length; ii++) {
    var entry = entries3[ii];
    node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
  }
  return node;
}
function packNodes(ownerID, nodes, count2, excluding) {
  var bitmap = 0;
  var packedII = 0;
  var packedNodes = new Array(count2);
  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
    var node = nodes[ii];
    if (node !== void 0 && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
  var count2 = 0;
  var expandedNodes = new Array(SIZE);
  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count2++] : void 0;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count2 + 1, expandedNodes);
}
function popCount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function setAt(array, idx, val, canEdit) {
  var newArray = canEdit ? array : arrCopy(array);
  newArray[idx] = val;
  return newArray;
}
function spliceIn(array, idx, val, canEdit) {
  var newLen = array.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array[idx] = val;
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array[ii + after];
    }
  }
  return newArray;
}
function spliceOut(array, idx, canEdit) {
  var newLen = array.length - 1;
  if (canEdit && idx === newLen) {
    array.pop();
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array[ii + after];
  }
  return newArray;
}
var MAX_ARRAY_MAP_SIZE = SIZE / 4;
var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
var IS_LIST_SYMBOL = "@@__IMMUTABLE_LIST__@@";
function isList(maybeList) {
  return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
}
var List = /* @__PURE__ */ function(IndexedCollection2) {
  function List2(value) {
    var empty2 = emptyList();
    if (value === void 0 || value === null) {
      return empty2;
    }
    if (isList(value)) {
      return value;
    }
    var iter = IndexedCollection2(value);
    var size = iter.size;
    if (size === 0) {
      return empty2;
    }
    assertNotInfinite(size);
    if (size > 0 && size < SIZE) {
      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
    }
    return empty2.withMutations(function(list2) {
      list2.setSize(size);
      iter.forEach(function(v, i2) {
        return list2.set(i2, v);
      });
    });
  }
  if (IndexedCollection2) List2.__proto__ = IndexedCollection2;
  List2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
  List2.prototype.constructor = List2;
  List2.of = function of() {
    return this(arguments);
  };
  List2.prototype.toString = function toString6() {
    return this.__toString("List [", "]");
  };
  List2.prototype.get = function get12(index2, notSetValue) {
    index2 = wrapIndex(this, index2);
    if (index2 >= 0 && index2 < this.size) {
      index2 += this._origin;
      var node = listNodeFor(this, index2);
      return node && node.array[index2 & MASK];
    }
    return notSetValue;
  };
  List2.prototype.set = function set3(index2, value) {
    return updateList(this, index2, value);
  };
  List2.prototype.remove = function remove3(index2) {
    return !this.has(index2) ? this : index2 === 0 ? this.shift() : index2 === this.size - 1 ? this.pop() : this.splice(index2, 1);
  };
  List2.prototype.insert = function insert2(index2, value) {
    return this.splice(index2, 0, value);
  };
  List2.prototype.clear = function clear2() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = this._origin = this._capacity = 0;
      this._level = SHIFT;
      this._root = this._tail = this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyList();
  };
  List2.prototype.push = function push() {
    var values2 = arguments;
    var oldSize = this.size;
    return this.withMutations(function(list2) {
      setListBounds(list2, 0, oldSize + values2.length);
      for (var ii = 0; ii < values2.length; ii++) {
        list2.set(oldSize + ii, values2[ii]);
      }
    });
  };
  List2.prototype.pop = function pop() {
    return setListBounds(this, 0, -1);
  };
  List2.prototype.unshift = function unshift() {
    var values2 = arguments;
    return this.withMutations(function(list2) {
      setListBounds(list2, -values2.length);
      for (var ii = 0; ii < values2.length; ii++) {
        list2.set(ii, values2[ii]);
      }
    });
  };
  List2.prototype.shift = function shift() {
    return setListBounds(this, 1);
  };
  List2.prototype.concat = function concat3() {
    var arguments$1 = arguments;
    var seqs = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      var argument = arguments$1[i2];
      var seq = IndexedCollection2(
        typeof argument !== "string" && hasIterator(argument) ? argument : [argument]
      );
      if (seq.size !== 0) {
        seqs.push(seq);
      }
    }
    if (seqs.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
      return this.constructor(seqs[0]);
    }
    return this.withMutations(function(list2) {
      seqs.forEach(function(seq2) {
        return seq2.forEach(function(value) {
          return list2.push(value);
        });
      });
    });
  };
  List2.prototype.setSize = function setSize(size) {
    return setListBounds(this, 0, size);
  };
  List2.prototype.map = function map3(mapper, context2) {
    var this$1$1 = this;
    return this.withMutations(function(list2) {
      for (var i2 = 0; i2 < this$1$1.size; i2++) {
        list2.set(i2, mapper.call(context2, list2.get(i2), i2, this$1$1));
      }
    });
  };
  List2.prototype.slice = function slice4(begin, end) {
    var size = this.size;
    if (wholeSlice(begin, end, size)) {
      return this;
    }
    return setListBounds(
      this,
      resolveBegin(begin, size),
      resolveEnd(end, size)
    );
  };
  List2.prototype.__iterator = function __iterator2(type2, reverse3) {
    var index2 = reverse3 ? this.size : 0;
    var values2 = iterateList(this, reverse3);
    return new Iterator(function() {
      var value = values2();
      return value === DONE ? iteratorDone() : iteratorValue(type2, reverse3 ? --index2 : index2++, value);
    });
  };
  List2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var index2 = reverse3 ? this.size : 0;
    var values2 = iterateList(this, reverse3);
    var value;
    while ((value = values2()) !== DONE) {
      if (fn(value, reverse3 ? --index2 : index2++, this) === false) {
        break;
      }
    }
    return index2;
  };
  List2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyList();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeList(
      this._origin,
      this._capacity,
      this._level,
      this._root,
      this._tail,
      ownerID,
      this.__hash
    );
  };
  return List2;
}(IndexedCollection);
List.isList = isList;
var ListPrototype = List.prototype;
ListPrototype[IS_LIST_SYMBOL] = true;
ListPrototype[DELETE] = ListPrototype.remove;
ListPrototype.merge = ListPrototype.concat;
ListPrototype.setIn = setIn;
ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
ListPrototype.update = update;
ListPrototype.updateIn = updateIn;
ListPrototype.mergeIn = mergeIn;
ListPrototype.mergeDeepIn = mergeDeepIn;
ListPrototype.withMutations = withMutations;
ListPrototype.wasAltered = wasAltered;
ListPrototype.asImmutable = asImmutable;
ListPrototype["@@transducer/init"] = ListPrototype.asMutable = asMutable;
ListPrototype["@@transducer/step"] = function(result, arr) {
  return result.push(arr);
};
ListPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
var VNode = function VNode2(array, ownerID) {
  this.array = array;
  this.ownerID = ownerID;
};
VNode.prototype.removeBefore = function removeBefore(ownerID, level, index2) {
  if (index2 === level ? 1 << level : this.array.length === 0) {
    return this;
  }
  var originIndex = index2 >>> level & MASK;
  if (originIndex >= this.array.length) {
    return new VNode([], ownerID);
  }
  var removingFirst = originIndex === 0;
  var newChild;
  if (level > 0) {
    var oldChild = this.array[originIndex];
    newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index2);
    if (newChild === oldChild && removingFirst) {
      return this;
    }
  }
  if (removingFirst && !newChild) {
    return this;
  }
  var editable = editableVNode(this, ownerID);
  if (!removingFirst) {
    for (var ii = 0; ii < originIndex; ii++) {
      editable.array[ii] = void 0;
    }
  }
  if (newChild) {
    editable.array[originIndex] = newChild;
  }
  return editable;
};
VNode.prototype.removeAfter = function removeAfter(ownerID, level, index2) {
  if (index2 === (level ? 1 << level : 0) || this.array.length === 0) {
    return this;
  }
  var sizeIndex = index2 - 1 >>> level & MASK;
  if (sizeIndex >= this.array.length) {
    return this;
  }
  var newChild;
  if (level > 0) {
    var oldChild = this.array[sizeIndex];
    newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index2);
    if (newChild === oldChild && sizeIndex === this.array.length - 1) {
      return this;
    }
  }
  var editable = editableVNode(this, ownerID);
  editable.array.splice(sizeIndex + 1);
  if (newChild) {
    editable.array[sizeIndex] = newChild;
  }
  return editable;
};
var DONE = {};
function iterateList(list2, reverse3) {
  var left = list2._origin;
  var right = list2._capacity;
  var tailPos = getTailOffset(right);
  var tail = list2._tail;
  return iterateNodeOrLeaf(list2._root, list2._level, 0);
  function iterateNodeOrLeaf(node, level, offset2) {
    return level === 0 ? iterateLeaf(node, offset2) : iterateNode(node, level, offset2);
  }
  function iterateLeaf(node, offset2) {
    var array = offset2 === tailPos ? tail && tail.array : node && node.array;
    var from2 = offset2 > left ? 0 : left - offset2;
    var to2 = right - offset2;
    if (to2 > SIZE) {
      to2 = SIZE;
    }
    return function() {
      if (from2 === to2) {
        return DONE;
      }
      var idx = reverse3 ? --to2 : from2++;
      return array && array[idx];
    };
  }
  function iterateNode(node, level, offset2) {
    var values2;
    var array = node && node.array;
    var from2 = offset2 > left ? 0 : left - offset2 >> level;
    var to2 = (right - offset2 >> level) + 1;
    if (to2 > SIZE) {
      to2 = SIZE;
    }
    return function() {
      while (true) {
        if (values2) {
          var value = values2();
          if (value !== DONE) {
            return value;
          }
          values2 = null;
        }
        if (from2 === to2) {
          return DONE;
        }
        var idx = reverse3 ? --to2 : from2++;
        values2 = iterateNodeOrLeaf(
          array && array[idx],
          level - SHIFT,
          offset2 + (idx << level)
        );
      }
    };
  }
}
function makeList(origin, capacity, level, root2, tail, ownerID, hash2) {
  var list2 = Object.create(ListPrototype);
  list2.size = capacity - origin;
  list2._origin = origin;
  list2._capacity = capacity;
  list2._level = level;
  list2._root = root2;
  list2._tail = tail;
  list2.__ownerID = ownerID;
  list2.__hash = hash2;
  list2.__altered = false;
  return list2;
}
var EMPTY_LIST;
function emptyList() {
  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
}
function updateList(list2, index2, value) {
  index2 = wrapIndex(list2, index2);
  if (index2 !== index2) {
    return list2;
  }
  if (index2 >= list2.size || index2 < 0) {
    return list2.withMutations(function(list3) {
      index2 < 0 ? setListBounds(list3, index2).set(0, value) : setListBounds(list3, 0, index2 + 1).set(index2, value);
    });
  }
  index2 += list2._origin;
  var newTail = list2._tail;
  var newRoot = list2._root;
  var didAlter = MakeRef();
  if (index2 >= getTailOffset(list2._capacity)) {
    newTail = updateVNode(newTail, list2.__ownerID, 0, index2, value, didAlter);
  } else {
    newRoot = updateVNode(
      newRoot,
      list2.__ownerID,
      list2._level,
      index2,
      value,
      didAlter
    );
  }
  if (!didAlter.value) {
    return list2;
  }
  if (list2.__ownerID) {
    list2._root = newRoot;
    list2._tail = newTail;
    list2.__hash = void 0;
    list2.__altered = true;
    return list2;
  }
  return makeList(list2._origin, list2._capacity, list2._level, newRoot, newTail);
}
function updateVNode(node, ownerID, level, index2, value, didAlter) {
  var idx = index2 >>> level & MASK;
  var nodeHas = node && idx < node.array.length;
  if (!nodeHas && value === void 0) {
    return node;
  }
  var newNode;
  if (level > 0) {
    var lowerNode = node && node.array[idx];
    var newLowerNode = updateVNode(
      lowerNode,
      ownerID,
      level - SHIFT,
      index2,
      value,
      didAlter
    );
    if (newLowerNode === lowerNode) {
      return node;
    }
    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    return newNode;
  }
  if (nodeHas && node.array[idx] === value) {
    return node;
  }
  if (didAlter) {
    SetRef(didAlter);
  }
  newNode = editableVNode(node, ownerID);
  if (value === void 0 && idx === newNode.array.length - 1) {
    newNode.array.pop();
  } else {
    newNode.array[idx] = value;
  }
  return newNode;
}
function editableVNode(node, ownerID) {
  if (ownerID && node && ownerID === node.ownerID) {
    return node;
  }
  return new VNode(node ? node.array.slice() : [], ownerID);
}
function listNodeFor(list2, rawIndex) {
  if (rawIndex >= getTailOffset(list2._capacity)) {
    return list2._tail;
  }
  if (rawIndex < 1 << list2._level + SHIFT) {
    var node = list2._root;
    var level = list2._level;
    while (node && level > 0) {
      node = node.array[rawIndex >>> level & MASK];
      level -= SHIFT;
    }
    return node;
  }
}
function setListBounds(list2, begin, end) {
  if (begin !== void 0) {
    begin |= 0;
  }
  if (end !== void 0) {
    end |= 0;
  }
  var owner = list2.__ownerID || new OwnerID();
  var oldOrigin = list2._origin;
  var oldCapacity = list2._capacity;
  var newOrigin = oldOrigin + begin;
  var newCapacity = end === void 0 ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
    return list2;
  }
  if (newOrigin >= newCapacity) {
    return list2.clear();
  }
  var newLevel = list2._level;
  var newRoot = list2._root;
  var offsetShift = 0;
  while (newOrigin + offsetShift < 0) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [void 0, newRoot] : [],
      owner
    );
    newLevel += SHIFT;
    offsetShift += 1 << newLevel;
  }
  if (offsetShift) {
    newOrigin += offsetShift;
    oldOrigin += offsetShift;
    newCapacity += offsetShift;
    oldCapacity += offsetShift;
  }
  var oldTailOffset = getTailOffset(oldCapacity);
  var newTailOffset = getTailOffset(newCapacity);
  while (newTailOffset >= 1 << newLevel + SHIFT) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [newRoot] : [],
      owner
    );
    newLevel += SHIFT;
  }
  var oldTail = list2._tail;
  var newTail = newTailOffset < oldTailOffset ? listNodeFor(list2, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
  if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
    newRoot = editableVNode(newRoot, owner);
    var node = newRoot;
    for (var level = newLevel; level > SHIFT; level -= SHIFT) {
      var idx = oldTailOffset >>> level & MASK;
      node = node.array[idx] = editableVNode(node.array[idx], owner);
    }
    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
  }
  if (newCapacity < oldCapacity) {
    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
  }
  if (newOrigin >= newTailOffset) {
    newOrigin -= newTailOffset;
    newCapacity -= newTailOffset;
    newLevel = SHIFT;
    newRoot = null;
    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
    offsetShift = 0;
    while (newRoot) {
      var beginIndex = newOrigin >>> newLevel & MASK;
      if (beginIndex !== newTailOffset >>> newLevel & MASK) {
        break;
      }
      if (beginIndex) {
        offsetShift += (1 << newLevel) * beginIndex;
      }
      newLevel -= SHIFT;
      newRoot = newRoot.array[beginIndex];
    }
    if (newRoot && newOrigin > oldOrigin) {
      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
    }
    if (newRoot && newTailOffset < oldTailOffset) {
      newRoot = newRoot.removeAfter(
        owner,
        newLevel,
        newTailOffset - offsetShift
      );
    }
    if (offsetShift) {
      newOrigin -= offsetShift;
      newCapacity -= offsetShift;
    }
  }
  if (list2.__ownerID) {
    list2.size = newCapacity - newOrigin;
    list2._origin = newOrigin;
    list2._capacity = newCapacity;
    list2._level = newLevel;
    list2._root = newRoot;
    list2._tail = newTail;
    list2.__hash = void 0;
    list2.__altered = true;
    return list2;
  }
  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}
function getTailOffset(size) {
  return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
}
var OrderedMap = /* @__PURE__ */ function(Map2) {
  function OrderedMap2(value) {
    return value === void 0 || value === null ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map3) {
      var iter = KeyedCollection(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v, k) {
        return map3.set(k, v);
      });
    });
  }
  if (Map2) OrderedMap2.__proto__ = Map2;
  OrderedMap2.prototype = Object.create(Map2 && Map2.prototype);
  OrderedMap2.prototype.constructor = OrderedMap2;
  OrderedMap2.of = function of() {
    return this(arguments);
  };
  OrderedMap2.prototype.toString = function toString6() {
    return this.__toString("OrderedMap {", "}");
  };
  OrderedMap2.prototype.get = function get12(k, notSetValue) {
    var index2 = this._map.get(k);
    return index2 !== void 0 ? this._list.get(index2)[1] : notSetValue;
  };
  OrderedMap2.prototype.clear = function clear2() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._map.clear();
      this._list.clear();
      this.__altered = true;
      return this;
    }
    return emptyOrderedMap();
  };
  OrderedMap2.prototype.set = function set3(k, v) {
    return updateOrderedMap(this, k, v);
  };
  OrderedMap2.prototype.remove = function remove3(k) {
    return updateOrderedMap(this, k, NOT_SET);
  };
  OrderedMap2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    return this._list.__iterate(
      function(entry) {
        return entry && fn(entry[1], entry[0], this$1$1);
      },
      reverse3
    );
  };
  OrderedMap2.prototype.__iterator = function __iterator2(type2, reverse3) {
    return this._list.fromEntrySeq().__iterator(type2, reverse3);
  };
  OrderedMap2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    var newList = this._list.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return emptyOrderedMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      this._map = newMap;
      this._list = newList;
      return this;
    }
    return makeOrderedMap(newMap, newList, ownerID, this.__hash);
  };
  return OrderedMap2;
}(Map$2);
OrderedMap.isOrderedMap = isOrderedMap;
OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
function makeOrderedMap(map3, list2, ownerID, hash2) {
  var omap = Object.create(OrderedMap.prototype);
  omap.size = map3 ? map3.size : 0;
  omap._map = map3;
  omap._list = list2;
  omap.__ownerID = ownerID;
  omap.__hash = hash2;
  omap.__altered = false;
  return omap;
}
var EMPTY_ORDERED_MAP;
function emptyOrderedMap() {
  return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
}
function updateOrderedMap(omap, k, v) {
  var map3 = omap._map;
  var list2 = omap._list;
  var i2 = map3.get(k);
  var has5 = i2 !== void 0;
  var newMap;
  var newList;
  if (v === NOT_SET) {
    if (!has5) {
      return omap;
    }
    if (list2.size >= SIZE && list2.size >= map3.size * 2) {
      newList = list2.filter(function(entry, idx) {
        return entry !== void 0 && i2 !== idx;
      });
      newMap = newList.toKeyedSeq().map(function(entry) {
        return entry[0];
      }).flip().toMap();
      if (omap.__ownerID) {
        newMap.__ownerID = newList.__ownerID = omap.__ownerID;
      }
    } else {
      newMap = map3.remove(k);
      newList = i2 === list2.size - 1 ? list2.pop() : list2.set(i2, void 0);
    }
  } else if (has5) {
    if (v === list2.get(i2)[1]) {
      return omap;
    }
    newMap = map3;
    newList = list2.set(i2, [k, v]);
  } else {
    newMap = map3.set(k, list2.size);
    newList = list2.set(list2.size, [k, v]);
  }
  if (omap.__ownerID) {
    omap.size = newMap.size;
    omap._map = newMap;
    omap._list = newList;
    omap.__hash = void 0;
    omap.__altered = true;
    return omap;
  }
  return makeOrderedMap(newMap, newList);
}
var IS_STACK_SYMBOL = "@@__IMMUTABLE_STACK__@@";
function isStack(maybeStack) {
  return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
}
var Stack$4 = /* @__PURE__ */ function(IndexedCollection2) {
  function Stack2(value) {
    return value === void 0 || value === null ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
  }
  if (IndexedCollection2) Stack2.__proto__ = IndexedCollection2;
  Stack2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
  Stack2.prototype.constructor = Stack2;
  Stack2.of = function of() {
    return this(arguments);
  };
  Stack2.prototype.toString = function toString6() {
    return this.__toString("Stack [", "]");
  };
  Stack2.prototype.get = function get12(index2, notSetValue) {
    var head = this._head;
    index2 = wrapIndex(this, index2);
    while (head && index2--) {
      head = head.next;
    }
    return head ? head.value : notSetValue;
  };
  Stack2.prototype.peek = function peek() {
    return this._head && this._head.value;
  };
  Stack2.prototype.push = function push() {
    var arguments$1 = arguments;
    if (arguments.length === 0) {
      return this;
    }
    var newSize = this.size + arguments.length;
    var head = this._head;
    for (var ii = arguments.length - 1; ii >= 0; ii--) {
      head = {
        value: arguments$1[ii],
        next: head
      };
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };
  Stack2.prototype.pushAll = function pushAll(iter) {
    iter = IndexedCollection2(iter);
    if (iter.size === 0) {
      return this;
    }
    if (this.size === 0 && isStack(iter)) {
      return iter;
    }
    assertNotInfinite(iter.size);
    var newSize = this.size;
    var head = this._head;
    iter.__iterate(
      function(value) {
        newSize++;
        head = {
          value,
          next: head
        };
      },
      /* reverse */
      true
    );
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };
  Stack2.prototype.pop = function pop() {
    return this.slice(1);
  };
  Stack2.prototype.clear = function clear2() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._head = void 0;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyStack();
  };
  Stack2.prototype.slice = function slice4(begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    var resolvedBegin = resolveBegin(begin, this.size);
    var resolvedEnd = resolveEnd(end, this.size);
    if (resolvedEnd !== this.size) {
      return IndexedCollection2.prototype.slice.call(this, begin, end);
    }
    var newSize = this.size - resolvedBegin;
    var head = this._head;
    while (resolvedBegin--) {
      head = head.next;
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };
  Stack2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyStack();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeStack(this.size, this._head, ownerID, this.__hash);
  };
  Stack2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return new ArraySeq(this.toArray()).__iterate(
        function(v, k) {
          return fn(v, k, this$1$1);
        },
        reverse3
      );
    }
    var iterations = 0;
    var node = this._head;
    while (node) {
      if (fn(node.value, iterations++, this) === false) {
        break;
      }
      node = node.next;
    }
    return iterations;
  };
  Stack2.prototype.__iterator = function __iterator2(type2, reverse3) {
    if (reverse3) {
      return new ArraySeq(this.toArray()).__iterator(type2, reverse3);
    }
    var iterations = 0;
    var node = this._head;
    return new Iterator(function() {
      if (node) {
        var value = node.value;
        node = node.next;
        return iteratorValue(type2, iterations++, value);
      }
      return iteratorDone();
    });
  };
  return Stack2;
}(IndexedCollection);
Stack$4.isStack = isStack;
var StackPrototype = Stack$4.prototype;
StackPrototype[IS_STACK_SYMBOL] = true;
StackPrototype.shift = StackPrototype.pop;
StackPrototype.unshift = StackPrototype.push;
StackPrototype.unshiftAll = StackPrototype.pushAll;
StackPrototype.withMutations = withMutations;
StackPrototype.wasAltered = wasAltered;
StackPrototype.asImmutable = asImmutable;
StackPrototype["@@transducer/init"] = StackPrototype.asMutable = asMutable;
StackPrototype["@@transducer/step"] = function(result, arr) {
  return result.unshift(arr);
};
StackPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
function makeStack(size, head, ownerID, hash2) {
  var map3 = Object.create(StackPrototype);
  map3.size = size;
  map3._head = head;
  map3.__ownerID = ownerID;
  map3.__hash = hash2;
  map3.__altered = false;
  return map3;
}
var EMPTY_STACK;
function emptyStack() {
  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}
var IS_SET_SYMBOL = "@@__IMMUTABLE_SET__@@";
function isSet$2(maybeSet) {
  return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
}
function isOrderedSet(maybeOrderedSet) {
  return isSet$2(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}
function deepEqual$1(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (!isCollection(b) || a2.size !== void 0 && b.size !== void 0 && a2.size !== b.size || a2.__hash !== void 0 && b.__hash !== void 0 && a2.__hash !== b.__hash || isKeyed(a2) !== isKeyed(b) || isIndexed(a2) !== isIndexed(b) || isOrdered(a2) !== isOrdered(b)) {
    return false;
  }
  if (a2.size === 0 && b.size === 0) {
    return true;
  }
  var notAssociative = !isAssociative(a2);
  if (isOrdered(a2)) {
    var entries3 = a2.entries();
    return b.every(function(v, k) {
      var entry = entries3.next().value;
      return entry && is2(entry[1], v) && (notAssociative || is2(entry[0], k));
    }) && entries3.next().done;
  }
  var flipped = false;
  if (a2.size === void 0) {
    if (b.size === void 0) {
      if (typeof a2.cacheResult === "function") {
        a2.cacheResult();
      }
    } else {
      flipped = true;
      var _ = a2;
      a2 = b;
      b = _;
    }
  }
  var allEqual = true;
  var bSize = b.__iterate(function(v, k) {
    if (notAssociative ? !a2.has(v) : flipped ? !is2(v, a2.get(k, NOT_SET)) : !is2(a2.get(k, NOT_SET), v)) {
      allEqual = false;
      return false;
    }
  });
  return allEqual && a2.size === bSize;
}
function mixin(ctor, methods) {
  var keyCopier = function(key) {
    ctor.prototype[key] = methods[key];
  };
  Object.keys(methods).forEach(keyCopier);
  Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
  return ctor;
}
function toJS(value) {
  if (!value || typeof value !== "object") {
    return value;
  }
  if (!isCollection(value)) {
    if (!isDataStructure(value)) {
      return value;
    }
    value = Seq(value);
  }
  if (isKeyed(value)) {
    var result$1 = {};
    value.__iterate(function(v, k) {
      result$1[k] = toJS(v);
    });
    return result$1;
  }
  var result = [];
  value.__iterate(function(v) {
    result.push(toJS(v));
  });
  return result;
}
var Set$2 = /* @__PURE__ */ function(SetCollection2) {
  function Set2(value) {
    return value === void 0 || value === null ? emptySet() : isSet$2(value) && !isOrdered(value) ? value : emptySet().withMutations(function(set3) {
      var iter = SetCollection2(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v) {
        return set3.add(v);
      });
    });
  }
  if (SetCollection2) Set2.__proto__ = SetCollection2;
  Set2.prototype = Object.create(SetCollection2 && SetCollection2.prototype);
  Set2.prototype.constructor = Set2;
  Set2.of = function of() {
    return this(arguments);
  };
  Set2.fromKeys = function fromKeys(value) {
    return this(KeyedCollection(value).keySeq());
  };
  Set2.intersect = function intersect(sets2) {
    sets2 = Collection(sets2).toArray();
    return sets2.length ? SetPrototype.intersect.apply(Set2(sets2.pop()), sets2) : emptySet();
  };
  Set2.union = function union(sets2) {
    sets2 = Collection(sets2).toArray();
    return sets2.length ? SetPrototype.union.apply(Set2(sets2.pop()), sets2) : emptySet();
  };
  Set2.prototype.toString = function toString6() {
    return this.__toString("Set {", "}");
  };
  Set2.prototype.has = function has5(value) {
    return this._map.has(value);
  };
  Set2.prototype.add = function add2(value) {
    return updateSet(this, this._map.set(value, value));
  };
  Set2.prototype.remove = function remove3(value) {
    return updateSet(this, this._map.remove(value));
  };
  Set2.prototype.clear = function clear2() {
    return updateSet(this, this._map.clear());
  };
  Set2.prototype.map = function map3(mapper, context2) {
    var this$1$1 = this;
    var didChanges = false;
    var newMap = updateSet(
      this,
      this._map.mapEntries(function(ref2) {
        var v = ref2[1];
        var mapped = mapper.call(context2, v, v, this$1$1);
        if (mapped !== v) {
          didChanges = true;
        }
        return [mapped, mapped];
      }, context2)
    );
    return didChanges ? newMap : this;
  };
  Set2.prototype.union = function union() {
    var iters = [], len = arguments.length;
    while (len--) iters[len] = arguments[len];
    iters = iters.filter(function(x) {
      return x.size !== 0;
    });
    if (iters.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && iters.length === 1) {
      return this.constructor(iters[0]);
    }
    return this.withMutations(function(set3) {
      for (var ii = 0; ii < iters.length; ii++) {
        if (typeof iters[ii] === "string") {
          set3.add(iters[ii]);
        } else {
          SetCollection2(iters[ii]).forEach(function(value) {
            return set3.add(value);
          });
        }
      }
    });
  };
  Set2.prototype.intersect = function intersect() {
    var iters = [], len = arguments.length;
    while (len--) iters[len] = arguments[len];
    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function(iter) {
      return SetCollection2(iter);
    });
    var toRemove = [];
    this.forEach(function(value) {
      if (!iters.every(function(iter) {
        return iter.includes(value);
      })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function(set3) {
      toRemove.forEach(function(value) {
        set3.remove(value);
      });
    });
  };
  Set2.prototype.subtract = function subtract2() {
    var iters = [], len = arguments.length;
    while (len--) iters[len] = arguments[len];
    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function(iter) {
      return SetCollection2(iter);
    });
    var toRemove = [];
    this.forEach(function(value) {
      if (iters.some(function(iter) {
        return iter.includes(value);
      })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function(set3) {
      toRemove.forEach(function(value) {
        set3.remove(value);
      });
    });
  };
  Set2.prototype.sort = function sort2(comparator) {
    return OrderedSet(sortFactory(this, comparator));
  };
  Set2.prototype.sortBy = function sortBy2(mapper, comparator) {
    return OrderedSet(sortFactory(this, comparator, mapper));
  };
  Set2.prototype.wasAltered = function wasAltered3() {
    return this._map.wasAltered();
  };
  Set2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    return this._map.__iterate(function(k) {
      return fn(k, k, this$1$1);
    }, reverse3);
  };
  Set2.prototype.__iterator = function __iterator2(type2, reverse3) {
    return this._map.__iterator(type2, reverse3);
  };
  Set2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return this.__empty();
      }
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }
    return this.__make(newMap, ownerID);
  };
  return Set2;
}(SetCollection);
Set$2.isSet = isSet$2;
var SetPrototype = Set$2.prototype;
SetPrototype[IS_SET_SYMBOL] = true;
SetPrototype[DELETE] = SetPrototype.remove;
SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
SetPrototype.withMutations = withMutations;
SetPrototype.asImmutable = asImmutable;
SetPrototype["@@transducer/init"] = SetPrototype.asMutable = asMutable;
SetPrototype["@@transducer/step"] = function(result, arr) {
  return result.add(arr);
};
SetPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
SetPrototype.__empty = emptySet;
SetPrototype.__make = makeSet;
function updateSet(set3, newMap) {
  if (set3.__ownerID) {
    set3.size = newMap.size;
    set3._map = newMap;
    return set3;
  }
  return newMap === set3._map ? set3 : newMap.size === 0 ? set3.__empty() : set3.__make(newMap);
}
function makeSet(map3, ownerID) {
  var set3 = Object.create(SetPrototype);
  set3.size = map3 ? map3.size : 0;
  set3._map = map3;
  set3.__ownerID = ownerID;
  return set3;
}
var EMPTY_SET;
function emptySet() {
  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}
var Range = /* @__PURE__ */ function(IndexedSeq2) {
  function Range2(start, end, step) {
    if (!(this instanceof Range2)) {
      return new Range2(start, end, step);
    }
    invariant(step !== 0, "Cannot step a Range by 0");
    start = start || 0;
    if (end === void 0) {
      end = Infinity;
    }
    step = step === void 0 ? 1 : Math.abs(step);
    if (end < start) {
      step = -step;
    }
    this._start = start;
    this._end = end;
    this._step = step;
    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
    if (this.size === 0) {
      if (EMPTY_RANGE) {
        return EMPTY_RANGE;
      }
      EMPTY_RANGE = this;
    }
  }
  if (IndexedSeq2) Range2.__proto__ = IndexedSeq2;
  Range2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  Range2.prototype.constructor = Range2;
  Range2.prototype.toString = function toString6() {
    if (this.size === 0) {
      return "Range []";
    }
    return "Range [ " + this._start + "..." + this._end + (this._step !== 1 ? " by " + this._step : "") + " ]";
  };
  Range2.prototype.get = function get12(index2, notSetValue) {
    return this.has(index2) ? this._start + wrapIndex(this, index2) * this._step : notSetValue;
  };
  Range2.prototype.includes = function includes3(searchValue) {
    var possibleIndex = (searchValue - this._start) / this._step;
    return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
  };
  Range2.prototype.slice = function slice4(begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    begin = resolveBegin(begin, this.size);
    end = resolveEnd(end, this.size);
    if (end <= begin) {
      return new Range2(0, 0);
    }
    return new Range2(
      this.get(begin, this._end),
      this.get(end, this._end),
      this._step
    );
  };
  Range2.prototype.indexOf = function indexOf3(searchValue) {
    var offsetValue = searchValue - this._start;
    if (offsetValue % this._step === 0) {
      var index2 = offsetValue / this._step;
      if (index2 >= 0 && index2 < this.size) {
        return index2;
      }
    }
    return -1;
  };
  Range2.prototype.lastIndexOf = function lastIndexOf2(searchValue) {
    return this.indexOf(searchValue);
  };
  Range2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var size = this.size;
    var step = this._step;
    var value = reverse3 ? this._start + (size - 1) * step : this._start;
    var i2 = 0;
    while (i2 !== size) {
      if (fn(value, reverse3 ? size - ++i2 : i2++, this) === false) {
        break;
      }
      value += reverse3 ? -step : step;
    }
    return i2;
  };
  Range2.prototype.__iterator = function __iterator2(type2, reverse3) {
    var size = this.size;
    var step = this._step;
    var value = reverse3 ? this._start + (size - 1) * step : this._start;
    var i2 = 0;
    return new Iterator(function() {
      if (i2 === size) {
        return iteratorDone();
      }
      var v = value;
      value += reverse3 ? -step : step;
      return iteratorValue(type2, reverse3 ? size - ++i2 : i2++, v);
    });
  };
  Range2.prototype.equals = function equals3(other) {
    return other instanceof Range2 ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual$1(this, other);
  };
  return Range2;
}(IndexedSeq);
var EMPTY_RANGE;
function getIn$1(collection, searchKeyPath, notSetValue) {
  var keyPath = coerceKeyPath(searchKeyPath);
  var i2 = 0;
  while (i2 !== keyPath.length) {
    collection = get$5(collection, keyPath[i2++], NOT_SET);
    if (collection === NOT_SET) {
      return notSetValue;
    }
  }
  return collection;
}
function getIn(searchKeyPath, notSetValue) {
  return getIn$1(this, searchKeyPath, notSetValue);
}
function hasIn$1$1(collection, keyPath) {
  return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;
}
function hasIn$4(searchKeyPath) {
  return hasIn$1$1(this, searchKeyPath);
}
function toObject() {
  assertNotInfinite(this.size);
  var object = {};
  this.__iterate(function(v, k) {
    object[k] = v;
  });
  return object;
}
Collection.isIterable = isCollection;
Collection.isKeyed = isKeyed;
Collection.isIndexed = isIndexed;
Collection.isAssociative = isAssociative;
Collection.isOrdered = isOrdered;
Collection.Iterator = Iterator;
mixin(Collection, {
  // ### Conversion to other types
  toArray: function toArray2() {
    assertNotInfinite(this.size);
    var array = new Array(this.size || 0);
    var useTuples = isKeyed(this);
    var i2 = 0;
    this.__iterate(function(v, k) {
      array[i2++] = useTuples ? [k, v] : v;
    });
    return array;
  },
  toIndexedSeq: function toIndexedSeq() {
    return new ToIndexedSequence(this);
  },
  toJS: function toJS$1() {
    return toJS(this);
  },
  toKeyedSeq: function toKeyedSeq() {
    return new ToKeyedSequence(this, true);
  },
  toMap: function toMap() {
    return Map$2(this.toKeyedSeq());
  },
  toObject,
  toOrderedMap: function toOrderedMap() {
    return OrderedMap(this.toKeyedSeq());
  },
  toOrderedSet: function toOrderedSet() {
    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
  },
  toSet: function toSet() {
    return Set$2(isKeyed(this) ? this.valueSeq() : this);
  },
  toSetSeq: function toSetSeq() {
    return new ToSetSequence(this);
  },
  toSeq: function toSeq() {
    return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
  },
  toStack: function toStack() {
    return Stack$4(isKeyed(this) ? this.valueSeq() : this);
  },
  toList: function toList() {
    return List(isKeyed(this) ? this.valueSeq() : this);
  },
  // ### Common JavaScript methods and properties
  toString: function toString2() {
    return "[Collection]";
  },
  __toString: function __toString(head, tail) {
    if (this.size === 0) {
      return head + tail;
    }
    return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
  },
  // ### ES6 Collection methods (ES6 Array and Map)
  concat: function concat2() {
    var values2 = [], len = arguments.length;
    while (len--) values2[len] = arguments[len];
    return reify(this, concatFactory(this, values2));
  },
  includes: function includes(searchValue) {
    return this.some(function(value) {
      return is2(value, searchValue);
    });
  },
  entries: function entries() {
    return this.__iterator(ITERATE_ENTRIES);
  },
  every: function every(predicate, context2) {
    assertNotInfinite(this.size);
    var returnValue = true;
    this.__iterate(function(v, k, c2) {
      if (!predicate.call(context2, v, k, c2)) {
        returnValue = false;
        return false;
      }
    });
    return returnValue;
  },
  filter: function filter2(predicate, context2) {
    return reify(this, filterFactory(this, predicate, context2, true));
  },
  partition: function partition(predicate, context2) {
    return partitionFactory(this, predicate, context2);
  },
  find: function find2(predicate, context2, notSetValue) {
    var entry = this.findEntry(predicate, context2);
    return entry ? entry[1] : notSetValue;
  },
  forEach: function forEach(sideEffect, context2) {
    assertNotInfinite(this.size);
    return this.__iterate(context2 ? sideEffect.bind(context2) : sideEffect);
  },
  join: function join(separator) {
    assertNotInfinite(this.size);
    separator = separator !== void 0 ? "" + separator : ",";
    var joined = "";
    var isFirst = true;
    this.__iterate(function(v) {
      isFirst ? isFirst = false : joined += separator;
      joined += v !== null && v !== void 0 ? v.toString() : "";
    });
    return joined;
  },
  keys: function keys2() {
    return this.__iterator(ITERATE_KEYS);
  },
  map: function map(mapper, context2) {
    return reify(this, mapFactory(this, mapper, context2));
  },
  reduce: function reduce$1(reducer, initialReduction, context2) {
    return reduce(
      this,
      reducer,
      initialReduction,
      context2,
      arguments.length < 2,
      false
    );
  },
  reduceRight: function reduceRight(reducer, initialReduction, context2) {
    return reduce(
      this,
      reducer,
      initialReduction,
      context2,
      arguments.length < 2,
      true
    );
  },
  reverse: function reverse() {
    return reify(this, reverseFactory(this, true));
  },
  slice: function slice2(begin, end) {
    return reify(this, sliceFactory(this, begin, end, true));
  },
  some: function some2(predicate, context2) {
    assertNotInfinite(this.size);
    var returnValue = false;
    this.__iterate(function(v, k, c2) {
      if (predicate.call(context2, v, k, c2)) {
        returnValue = true;
        return false;
      }
    });
    return returnValue;
  },
  sort: function sort(comparator) {
    return reify(this, sortFactory(this, comparator));
  },
  values: function values() {
    return this.__iterator(ITERATE_VALUES);
  },
  // ### More sequential methods
  butLast: function butLast() {
    return this.slice(0, -1);
  },
  isEmpty: function isEmpty() {
    return this.size !== void 0 ? this.size === 0 : !this.some(function() {
      return true;
    });
  },
  count: function count(predicate, context2) {
    return ensureSize(
      predicate ? this.toSeq().filter(predicate, context2) : this
    );
  },
  countBy: function countBy(grouper, context2) {
    return countByFactory(this, grouper, context2);
  },
  equals: function equals(other) {
    return deepEqual$1(this, other);
  },
  entrySeq: function entrySeq() {
    var collection = this;
    if (collection._cache) {
      return new ArraySeq(collection._cache);
    }
    var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
    entriesSequence.fromEntrySeq = function() {
      return collection.toSeq();
    };
    return entriesSequence;
  },
  filterNot: function filterNot(predicate, context2) {
    return this.filter(not(predicate), context2);
  },
  findEntry: function findEntry(predicate, context2, notSetValue) {
    var found = notSetValue;
    this.__iterate(function(v, k, c2) {
      if (predicate.call(context2, v, k, c2)) {
        found = [k, v];
        return false;
      }
    });
    return found;
  },
  findKey: function findKey(predicate, context2) {
    var entry = this.findEntry(predicate, context2);
    return entry && entry[0];
  },
  findLast: function findLast(predicate, context2, notSetValue) {
    return this.toKeyedSeq().reverse().find(predicate, context2, notSetValue);
  },
  findLastEntry: function findLastEntry(predicate, context2, notSetValue) {
    return this.toKeyedSeq().reverse().findEntry(predicate, context2, notSetValue);
  },
  findLastKey: function findLastKey(predicate, context2) {
    return this.toKeyedSeq().reverse().findKey(predicate, context2);
  },
  first: function first(notSetValue) {
    return this.find(returnTrue, null, notSetValue);
  },
  flatMap: function flatMap(mapper, context2) {
    return reify(this, flatMapFactory(this, mapper, context2));
  },
  flatten: function flatten(depth) {
    return reify(this, flattenFactory(this, depth, true));
  },
  fromEntrySeq: function fromEntrySeq() {
    return new FromEntriesSequence(this);
  },
  get: function get6(searchKey, notSetValue) {
    return this.find(function(_, key) {
      return is2(key, searchKey);
    }, void 0, notSetValue);
  },
  getIn,
  groupBy: function groupBy(grouper, context2) {
    return groupByFactory(this, grouper, context2);
  },
  has: function has2(searchKey) {
    return this.get(searchKey, NOT_SET) !== NOT_SET;
  },
  hasIn: hasIn$4,
  isSubset: function isSubset(iter) {
    iter = typeof iter.includes === "function" ? iter : Collection(iter);
    return this.every(function(value) {
      return iter.includes(value);
    });
  },
  isSuperset: function isSuperset(iter) {
    iter = typeof iter.isSubset === "function" ? iter : Collection(iter);
    return iter.isSubset(this);
  },
  keyOf: function keyOf(searchValue) {
    return this.findKey(function(value) {
      return is2(value, searchValue);
    });
  },
  keySeq: function keySeq() {
    return this.toSeq().map(keyMapper).toIndexedSeq();
  },
  last: function last(notSetValue) {
    return this.toSeq().reverse().first(notSetValue);
  },
  lastKeyOf: function lastKeyOf(searchValue) {
    return this.toKeyedSeq().reverse().keyOf(searchValue);
  },
  max: function max2(comparator) {
    return maxFactory(this, comparator);
  },
  maxBy: function maxBy(mapper, comparator) {
    return maxFactory(this, comparator, mapper);
  },
  min: function min2(comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator
    );
  },
  minBy: function minBy(mapper, comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator,
      mapper
    );
  },
  rest: function rest() {
    return this.slice(1);
  },
  skip: function skip2(amount) {
    return amount === 0 ? this : this.slice(Math.max(0, amount));
  },
  skipLast: function skipLast(amount) {
    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
  },
  skipWhile: function skipWhile(predicate, context2) {
    return reify(this, skipWhileFactory(this, predicate, context2, true));
  },
  skipUntil: function skipUntil(predicate, context2) {
    return this.skipWhile(not(predicate), context2);
  },
  sortBy: function sortBy(mapper, comparator) {
    return reify(this, sortFactory(this, comparator, mapper));
  },
  take: function take(amount) {
    return this.slice(0, Math.max(0, amount));
  },
  takeLast: function takeLast(amount) {
    return this.slice(-Math.max(0, amount));
  },
  takeWhile: function takeWhile(predicate, context2) {
    return reify(this, takeWhileFactory(this, predicate, context2));
  },
  takeUntil: function takeUntil(predicate, context2) {
    return this.takeWhile(not(predicate), context2);
  },
  update: function update7(fn) {
    return fn(this);
  },
  valueSeq: function valueSeq() {
    return this.toIndexedSeq();
  },
  // ### Hashable Object
  hashCode: function hashCode() {
    return this.__hash || (this.__hash = hashCollection(this));
  }
  // ### Internal
  // abstract __iterate(fn, reverse)
  // abstract __iterator(type, reverse)
});
var CollectionPrototype = Collection.prototype;
CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
CollectionPrototype.toJSON = CollectionPrototype.toArray;
CollectionPrototype.__toStringMapper = quoteString;
CollectionPrototype.inspect = CollectionPrototype.toSource = function() {
  return this.toString();
};
CollectionPrototype.chain = CollectionPrototype.flatMap;
CollectionPrototype.contains = CollectionPrototype.includes;
mixin(KeyedCollection, {
  // ### More sequential methods
  flip: function flip() {
    return reify(this, flipFactory(this));
  },
  mapEntries: function mapEntries(mapper, context2) {
    var this$1$1 = this;
    var iterations = 0;
    return reify(
      this,
      this.toSeq().map(function(v, k) {
        return mapper.call(context2, [k, v], iterations++, this$1$1);
      }).fromEntrySeq()
    );
  },
  mapKeys: function mapKeys(mapper, context2) {
    var this$1$1 = this;
    return reify(
      this,
      this.toSeq().flip().map(function(k, v) {
        return mapper.call(context2, k, v, this$1$1);
      }).flip()
    );
  }
});
var KeyedCollectionPrototype = KeyedCollection.prototype;
KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
KeyedCollectionPrototype.toJSON = toObject;
KeyedCollectionPrototype.__toStringMapper = function(v, k) {
  return quoteString(k) + ": " + quoteString(v);
};
mixin(IndexedCollection, {
  // ### Conversion to other types
  toKeyedSeq: function toKeyedSeq2() {
    return new ToKeyedSequence(this, false);
  },
  // ### ES6 Collection methods (ES6 Array and Map)
  filter: function filter3(predicate, context2) {
    return reify(this, filterFactory(this, predicate, context2, false));
  },
  findIndex: function findIndex2(predicate, context2) {
    var entry = this.findEntry(predicate, context2);
    return entry ? entry[0] : -1;
  },
  indexOf: function indexOf2(searchValue) {
    var key = this.keyOf(searchValue);
    return key === void 0 ? -1 : key;
  },
  lastIndexOf: function lastIndexOf(searchValue) {
    var key = this.lastKeyOf(searchValue);
    return key === void 0 ? -1 : key;
  },
  reverse: function reverse2() {
    return reify(this, reverseFactory(this, false));
  },
  slice: function slice3(begin, end) {
    return reify(this, sliceFactory(this, begin, end, false));
  },
  splice: function splice(index2, removeNum) {
    var numArgs = arguments.length;
    removeNum = Math.max(removeNum || 0, 0);
    if (numArgs === 0 || numArgs === 2 && !removeNum) {
      return this;
    }
    index2 = resolveBegin(index2, index2 < 0 ? this.count() : this.size);
    var spliced = this.slice(0, index2);
    return reify(
      this,
      numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index2 + removeNum))
    );
  },
  // ### More collection methods
  findLastIndex: function findLastIndex(predicate, context2) {
    var entry = this.findLastEntry(predicate, context2);
    return entry ? entry[0] : -1;
  },
  first: function first2(notSetValue) {
    return this.get(0, notSetValue);
  },
  flatten: function flatten2(depth) {
    return reify(this, flattenFactory(this, depth, false));
  },
  get: function get7(index2, notSetValue) {
    index2 = wrapIndex(this, index2);
    return index2 < 0 || this.size === Infinity || this.size !== void 0 && index2 > this.size ? notSetValue : this.find(function(_, key) {
      return key === index2;
    }, void 0, notSetValue);
  },
  has: function has3(index2) {
    index2 = wrapIndex(this, index2);
    return index2 >= 0 && (this.size !== void 0 ? this.size === Infinity || index2 < this.size : this.indexOf(index2) !== -1);
  },
  interpose: function interpose(separator) {
    return reify(this, interposeFactory(this, separator));
  },
  interleave: function interleave() {
    var collections = [this].concat(arrCopy(arguments));
    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
    var interleaved = zipped.flatten(true);
    if (zipped.size) {
      interleaved.size = zipped.size * collections.length;
    }
    return reify(this, interleaved);
  },
  keySeq: function keySeq2() {
    return Range(0, this.size);
  },
  last: function last2(notSetValue) {
    return this.get(-1, notSetValue);
  },
  skipWhile: function skipWhile2(predicate, context2) {
    return reify(this, skipWhileFactory(this, predicate, context2, false));
  },
  zip: function zip() {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections));
  },
  zipAll: function zipAll() {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections, true));
  },
  zipWith: function zipWith(zipper) {
    var collections = arrCopy(arguments);
    collections[0] = this;
    return reify(this, zipWithFactory(this, zipper, collections));
  }
});
var IndexedCollectionPrototype = IndexedCollection.prototype;
IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
mixin(SetCollection, {
  // ### ES6 Collection methods (ES6 Array and Map)
  get: function get8(value, notSetValue) {
    return this.has(value) ? value : notSetValue;
  },
  includes: function includes2(value) {
    return this.has(value);
  },
  // ### More sequential methods
  keySeq: function keySeq3() {
    return this.valueSeq();
  }
});
var SetCollectionPrototype = SetCollection.prototype;
SetCollectionPrototype.has = CollectionPrototype.includes;
SetCollectionPrototype.contains = SetCollectionPrototype.includes;
SetCollectionPrototype.keys = SetCollectionPrototype.values;
mixin(KeyedSeq, KeyedCollectionPrototype);
mixin(IndexedSeq, IndexedCollectionPrototype);
mixin(SetSeq, SetCollectionPrototype);
function reduce(collection, reducer, reduction, context2, useFirst, reverse3) {
  assertNotInfinite(collection.size);
  collection.__iterate(function(v, k, c2) {
    if (useFirst) {
      useFirst = false;
      reduction = v;
    } else {
      reduction = reducer.call(context2, reduction, v, k, c2);
    }
  }, reverse3);
  return reduction;
}
function keyMapper(v, k) {
  return k;
}
function entryMapper(v, k) {
  return [k, v];
}
function not(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
function neg(predicate) {
  return function() {
    return -predicate.apply(this, arguments);
  };
}
function defaultZipper() {
  return arrCopy(arguments);
}
function defaultNegComparator(a2, b) {
  return a2 < b ? 1 : a2 > b ? -1 : 0;
}
function hashCollection(collection) {
  if (collection.size === Infinity) {
    return 0;
  }
  var ordered = isOrdered(collection);
  var keyed = isKeyed(collection);
  var h = ordered ? 1 : 0;
  var size = collection.__iterate(
    keyed ? ordered ? function(v, k) {
      h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
    } : function(v, k) {
      h = h + hashMerge(hash(v), hash(k)) | 0;
    } : ordered ? function(v) {
      h = 31 * h + hash(v) | 0;
    } : function(v) {
      h = h + hash(v) | 0;
    }
  );
  return murmurHashOfSize(size, h);
}
function murmurHashOfSize(size, h) {
  h = imul(h, 3432918353);
  h = imul(h << 15 | h >>> -15, 461845907);
  h = imul(h << 13 | h >>> -13, 5);
  h = (h + 3864292196 | 0) ^ size;
  h = imul(h ^ h >>> 16, 2246822507);
  h = imul(h ^ h >>> 13, 3266489909);
  h = smi(h ^ h >>> 16);
  return h;
}
function hashMerge(a2, b) {
  return a2 ^ b + 2654435769 + (a2 << 6) + (a2 >> 2) | 0;
}
var OrderedSet = /* @__PURE__ */ function(Set2) {
  function OrderedSet2(value) {
    return value === void 0 || value === null ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set3) {
      var iter = SetCollection(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v) {
        return set3.add(v);
      });
    });
  }
  if (Set2) OrderedSet2.__proto__ = Set2;
  OrderedSet2.prototype = Object.create(Set2 && Set2.prototype);
  OrderedSet2.prototype.constructor = OrderedSet2;
  OrderedSet2.of = function of() {
    return this(arguments);
  };
  OrderedSet2.fromKeys = function fromKeys(value) {
    return this(KeyedCollection(value).keySeq());
  };
  OrderedSet2.prototype.toString = function toString6() {
    return this.__toString("OrderedSet {", "}");
  };
  return OrderedSet2;
}(Set$2);
OrderedSet.isOrderedSet = isOrderedSet;
var OrderedSetPrototype = OrderedSet.prototype;
OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
OrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;
OrderedSetPrototype.__empty = emptyOrderedSet;
OrderedSetPrototype.__make = makeOrderedSet;
function makeOrderedSet(map3, ownerID) {
  var set3 = Object.create(OrderedSetPrototype);
  set3.size = map3 ? map3.size : 0;
  set3._map = map3;
  set3.__ownerID = ownerID;
  return set3;
}
var EMPTY_ORDERED_SET;
function emptyOrderedSet() {
  return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
}
var PairSorting = {
  LeftThenRight: -1,
  RightThenLeft: 1
};
function throwOnInvalidDefaultValues(defaultValues) {
  if (isRecord(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead."
    );
  }
  if (isImmutable$2(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead."
    );
  }
  if (defaultValues === null || typeof defaultValues !== "object") {
    throw new Error(
      "Can not call `Record` with a non-object as default values. Use a plain javascript object instead."
    );
  }
}
var Record = function Record2(defaultValues, name2) {
  var hasInitialized;
  throwOnInvalidDefaultValues(defaultValues);
  var RecordType = function Record3(values2) {
    var this$1$1 = this;
    if (values2 instanceof RecordType) {
      return values2;
    }
    if (!(this instanceof RecordType)) {
      return new RecordType(values2);
    }
    if (!hasInitialized) {
      hasInitialized = true;
      var keys4 = Object.keys(defaultValues);
      var indices = RecordTypePrototype._indices = {};
      RecordTypePrototype._name = name2;
      RecordTypePrototype._keys = keys4;
      RecordTypePrototype._defaultValues = defaultValues;
      for (var i2 = 0; i2 < keys4.length; i2++) {
        var propName = keys4[i2];
        indices[propName] = i2;
        if (RecordTypePrototype[propName]) {
          typeof console === "object" && console.warn && console.warn(
            "Cannot define " + recordName(this) + ' with property "' + propName + '" since that property name is part of the Record API.'
          );
        } else {
          setProp(RecordTypePrototype, propName);
        }
      }
    }
    this.__ownerID = void 0;
    this._values = List().withMutations(function(l) {
      l.setSize(this$1$1._keys.length);
      KeyedCollection(values2).forEach(function(v, k) {
        l.set(this$1$1._indices[k], v === this$1$1._defaultValues[k] ? void 0 : v);
      });
    });
    return this;
  };
  var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
  RecordTypePrototype.constructor = RecordType;
  if (name2) {
    RecordType.displayName = name2;
  }
  return RecordType;
};
Record.prototype.toString = function toString3() {
  var str = recordName(this) + " { ";
  var keys4 = this._keys;
  var k;
  for (var i2 = 0, l = keys4.length; i2 !== l; i2++) {
    k = keys4[i2];
    str += (i2 ? ", " : "") + k + ": " + quoteString(this.get(k));
  }
  return str + " }";
};
Record.prototype.equals = function equals2(other) {
  return this === other || isRecord(other) && recordSeq(this).equals(recordSeq(other));
};
Record.prototype.hashCode = function hashCode2() {
  return recordSeq(this).hashCode();
};
Record.prototype.has = function has4(k) {
  return this._indices.hasOwnProperty(k);
};
Record.prototype.get = function get9(k, notSetValue) {
  if (!this.has(k)) {
    return notSetValue;
  }
  var index2 = this._indices[k];
  var value = this._values.get(index2);
  return value === void 0 ? this._defaultValues[k] : value;
};
Record.prototype.set = function set2(k, v) {
  if (this.has(k)) {
    var newValues = this._values.set(
      this._indices[k],
      v === this._defaultValues[k] ? void 0 : v
    );
    if (newValues !== this._values && !this.__ownerID) {
      return makeRecord(this, newValues);
    }
  }
  return this;
};
Record.prototype.remove = function remove2(k) {
  return this.set(k);
};
Record.prototype.clear = function clear() {
  var newValues = this._values.clear().setSize(this._keys.length);
  return this.__ownerID ? this : makeRecord(this, newValues);
};
Record.prototype.wasAltered = function wasAltered2() {
  return this._values.wasAltered();
};
Record.prototype.toSeq = function toSeq2() {
  return recordSeq(this);
};
Record.prototype.toJS = function toJS$12() {
  return toJS(this);
};
Record.prototype.entries = function entries2() {
  return this.__iterator(ITERATE_ENTRIES);
};
Record.prototype.__iterator = function __iterator(type2, reverse3) {
  return recordSeq(this).__iterator(type2, reverse3);
};
Record.prototype.__iterate = function __iterate(fn, reverse3) {
  return recordSeq(this).__iterate(fn, reverse3);
};
Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
  if (ownerID === this.__ownerID) {
    return this;
  }
  var newValues = this._values.__ensureOwner(ownerID);
  if (!ownerID) {
    this.__ownerID = ownerID;
    this._values = newValues;
    return this;
  }
  return makeRecord(this, newValues, ownerID);
};
Record.isRecord = isRecord;
Record.getDescriptiveName = recordName;
var RecordPrototype = Record.prototype;
RecordPrototype[IS_RECORD_SYMBOL] = true;
RecordPrototype[DELETE] = RecordPrototype.remove;
RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
RecordPrototype.getIn = getIn;
RecordPrototype.hasIn = CollectionPrototype.hasIn;
RecordPrototype.merge = merge$1$1;
RecordPrototype.mergeWith = mergeWith$1$1;
RecordPrototype.mergeIn = mergeIn;
RecordPrototype.mergeDeep = mergeDeep;
RecordPrototype.mergeDeepWith = mergeDeepWith;
RecordPrototype.mergeDeepIn = mergeDeepIn;
RecordPrototype.setIn = setIn;
RecordPrototype.update = update;
RecordPrototype.updateIn = updateIn;
RecordPrototype.withMutations = withMutations;
RecordPrototype.asMutable = asMutable;
RecordPrototype.asImmutable = asImmutable;
RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;
RecordPrototype.inspect = RecordPrototype.toSource = function() {
  return this.toString();
};
function makeRecord(likeRecord, values2, ownerID) {
  var record = Object.create(Object.getPrototypeOf(likeRecord));
  record._values = values2;
  record.__ownerID = ownerID;
  return record;
}
function recordName(record) {
  return record.constructor.displayName || record.constructor.name || "Record";
}
function recordSeq(record) {
  return keyedSeqFromValue(record._keys.map(function(k) {
    return [k, record.get(k)];
  }));
}
function setProp(prototype, name2) {
  try {
    Object.defineProperty(prototype, name2, {
      get: function() {
        return this.get(name2);
      },
      set: function(value) {
        invariant(this.__ownerID, "Cannot set on an immutable record.");
        this.set(name2, value);
      }
    });
  } catch (error2) {
  }
}
var Repeat = /* @__PURE__ */ function(IndexedSeq2) {
  function Repeat2(value, times) {
    if (!(this instanceof Repeat2)) {
      return new Repeat2(value, times);
    }
    this._value = value;
    this.size = times === void 0 ? Infinity : Math.max(0, times);
    if (this.size === 0) {
      if (EMPTY_REPEAT) {
        return EMPTY_REPEAT;
      }
      EMPTY_REPEAT = this;
    }
  }
  if (IndexedSeq2) Repeat2.__proto__ = IndexedSeq2;
  Repeat2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  Repeat2.prototype.constructor = Repeat2;
  Repeat2.prototype.toString = function toString6() {
    if (this.size === 0) {
      return "Repeat []";
    }
    return "Repeat [ " + this._value + " " + this.size + " times ]";
  };
  Repeat2.prototype.get = function get12(index2, notSetValue) {
    return this.has(index2) ? this._value : notSetValue;
  };
  Repeat2.prototype.includes = function includes3(searchValue) {
    return is2(this._value, searchValue);
  };
  Repeat2.prototype.slice = function slice4(begin, end) {
    var size = this.size;
    return wholeSlice(begin, end, size) ? this : new Repeat2(
      this._value,
      resolveEnd(end, size) - resolveBegin(begin, size)
    );
  };
  Repeat2.prototype.reverse = function reverse3() {
    return this;
  };
  Repeat2.prototype.indexOf = function indexOf3(searchValue) {
    if (is2(this._value, searchValue)) {
      return 0;
    }
    return -1;
  };
  Repeat2.prototype.lastIndexOf = function lastIndexOf2(searchValue) {
    if (is2(this._value, searchValue)) {
      return this.size;
    }
    return -1;
  };
  Repeat2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var size = this.size;
    var i2 = 0;
    while (i2 !== size) {
      if (fn(this._value, reverse3 ? size - ++i2 : i2++, this) === false) {
        break;
      }
    }
    return i2;
  };
  Repeat2.prototype.__iterator = function __iterator2(type2, reverse3) {
    var this$1$1 = this;
    var size = this.size;
    var i2 = 0;
    return new Iterator(
      function() {
        return i2 === size ? iteratorDone() : iteratorValue(type2, reverse3 ? size - ++i2 : i2++, this$1$1._value);
      }
    );
  };
  Repeat2.prototype.equals = function equals3(other) {
    return other instanceof Repeat2 ? is2(this._value, other._value) : deepEqual$1(this, other);
  };
  return Repeat2;
}(IndexedSeq);
var EMPTY_REPEAT;
function fromJS(value, converter) {
  return fromJSWith(
    [],
    converter || defaultConverter,
    value,
    "",
    converter && converter.length > 2 ? [] : void 0,
    { "": value }
  );
}
function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
  if (typeof value !== "string" && !isImmutable$2(value) && (isArrayLike$6(value) || hasIterator(value) || isPlainObject$4(value))) {
    if (~stack.indexOf(value)) {
      throw new TypeError("Cannot convert circular structure to Immutable");
    }
    stack.push(value);
    keyPath && key !== "" && keyPath.push(key);
    var converted = converter.call(
      parentValue,
      key,
      Seq(value).map(
        function(v, k) {
          return fromJSWith(stack, converter, v, k, keyPath, value);
        }
      ),
      keyPath && keyPath.slice()
    );
    stack.pop();
    keyPath && keyPath.pop();
    return converted;
  }
  return value;
}
function defaultConverter(k, v) {
  return isIndexed(v) ? v.toList() : isKeyed(v) ? v.toMap() : v.toSet();
}
var version = "4.3.7";
var Immutable = {
  version,
  Collection,
  // Note: Iterable is deprecated
  Iterable: Collection,
  Seq,
  Map: Map$2,
  OrderedMap,
  List,
  Stack: Stack$4,
  Set: Set$2,
  OrderedSet,
  PairSorting,
  Record,
  Range,
  Repeat,
  is: is2,
  fromJS,
  hash,
  isImmutable: isImmutable$2,
  isCollection,
  isKeyed,
  isIndexed,
  isAssociative,
  isOrdered,
  isValueObject,
  isPlainObject: isPlainObject$4,
  isSeq,
  isList,
  isMap: isMap$2,
  isOrderedMap,
  isStack,
  isSet: isSet$2,
  isOrderedSet,
  isRecord,
  get: get$5,
  getIn: getIn$1,
  has,
  hasIn: hasIn$1$1,
  merge: merge$3,
  mergeDeep: mergeDeep$1,
  mergeWith: mergeWith$2,
  mergeDeepWith: mergeDeepWith$1,
  remove,
  removeIn,
  set,
  setIn: setIn$1,
  update: update$1,
  updateIn: updateIn$1
};
var query_builder_seed = 0;
const uuid = function() {
  var timePart = ((/* @__PURE__ */ new Date()).getTime().toString(16) + "FF").substr(0, 11);
  var s2 = "ssssssss-xxxx-4xxx-yxxx-x".replace(/[xys]/g, function(c2) {
    var r2 = c2 === "s" ? Math.floor(Math.random() * 16) : query_builder_seed++ & 15;
    var v = c2 === "x" ? r2 : r2 & 3 | 8;
    return v.toString(16);
  });
  return s2 + timePart;
};
var define_process_env_default$1 = {};
function ownKeys$D(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r22) {
      return Object.getOwnPropertyDescriptor(e2, r22).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$D(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$D(Object(t2), true).forEach(function(r22) {
      _defineProperty$4(e2, r22, t2[r22]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$D(Object(t2)).forEach(function(r22) {
      Object.defineProperty(e2, r22, Object.getOwnPropertyDescriptor(t2, r22));
    });
  }
  return e2;
}
var widgetDefKeysToOmit = ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue", "spelImportFuncs", "spelImportValue"];
var opDefKeysToOmit = ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"];
var isObject$g = function isObject2(v) {
  return _typeof$3(v) === "object" && v !== null && Object.prototype.toString.call(v) === "[object Object]";
};
var shallowCopy = function shallowCopy2(v) {
  if (_typeof$3(v) === "object" && v !== null) {
    if (Array.isArray(v)) {
      return _toConsumableArray(v);
    } else if (isObject$g(v)) {
      return _objectSpread$D({}, v);
    }
  }
  return v;
};
var omit$2 = function omit2(obj, keys4) {
  return Object.fromEntries(Object.entries(obj).filter(function(_ref) {
    var _ref2 = _slicedToArray$1(_ref, 1), k = _ref2[0];
    return !keys4.includes(k);
  }));
};
var getOpCardinality$1 = function getOpCardinality2(opDef) {
  var _opDef$cardinality;
  return (_opDef$cardinality = opDef === null || opDef === void 0 ? void 0 : opDef.cardinality) !== null && _opDef$cardinality !== void 0 ? _opDef$cardinality : 1;
};
var deepEqual = function deepEqual2(v1, v2) {
  if (v1 === v2) {
    return true;
  } else if (Map$2.isMap(v1)) {
    return v1.equals(v2);
  } else {
    return JSON.stringify(v1) == JSON.stringify(v2);
  }
};
var shallowEqual$4 = function shallowEqual2(a2, b) {
  var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (a2 === b) {
    return true;
  } else if (Array.isArray(a2)) return shallowEqualArrays$1(a2, b, deep);
  else if (Map$2.isMap(a2)) return a2.equals(b);
  else if (_typeof$3(a2) == "object") return shallowEqualObjects$1(a2, b, deep);
  else return a2 === b;
};
function shallowEqualArrays$1(arrA, arrB) {
  var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (arrA === arrB) {
    return true;
  }
  if (!arrA || !arrB) {
    return false;
  }
  var len = arrA.length;
  if (arrB.length !== len) {
    return false;
  }
  for (var i2 = 0; i2 < len; i2++) {
    var isEqual2 = deep ? shallowEqual$4(arrA[i2], arrB[i2], deep) : arrA[i2] === arrB[i2];
    if (!isEqual2) {
      return false;
    }
  }
  return true;
}
function shallowEqualObjects$1(objA, objB) {
  var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (objA === objB) {
    return true;
  }
  if (!objA || !objB) {
    return false;
  }
  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var len = aKeys.length;
  if (bKeys.length !== len) {
    return false;
  }
  for (var i2 = 0; i2 < len; i2++) {
    var key = aKeys[i2];
    var isEqual2 = deep ? shallowEqual$4(objA[key], objB[key], deep) : objA[key] === objB[key];
    if (!isEqual2) {
      return false;
    }
  }
  return true;
}
var isImmutable$1 = function isImmutable2(v) {
  return _typeof$3(v) === "object" && v !== null && typeof v.toJS === "function";
};
var isImmutableList = function isImmutableList2(v) {
  return isImmutable$1(v) && Immutable.isList(v);
};
function toImmutableList(v) {
  return isImmutableList(v) ? v : new Immutable.List(v);
}
function applyToJS(v) {
  return isImmutable$1(v) ? v.toJS() : v;
}
var escapeRegExp = function escapeRegExp2(string) {
  return string.replace(/[.*+?^${}()|[\]\\/]/g, "\\$&");
};
var mergeCustomizerNoArrays = function mergeCustomizerNoArrays2(objValue, srcValue, _key, _object, _source, _stack) {
  if (Array.isArray(objValue)) {
    return srcValue;
  }
};
var cleanJSX = function cleanJSX2(jsx) {
  var jsxKeys = ["$$typeof", "_owner", "_store", "ref", "key"];
  var getName = function getName2(val) {
    if (typeof val === "string") {
      return val;
    } else if (typeof val === "function") {
      return val.name;
    }
    return val;
  };
  if (jsx instanceof Array) {
    return jsx.map(function(el, _i) {
      return cleanJSX2(el);
    });
  } else if (_typeof$3(jsx) === "object" && jsx !== null) {
    if (isDirtyJSX(jsx)) {
      var _cleaned$props;
      var cleaned = omit$2(jsx, jsxKeys);
      if (cleaned.type) {
        cleaned.type = getName(cleaned.type);
      }
      if (cleaned !== null && cleaned !== void 0 && (_cleaned$props = cleaned.props) !== null && _cleaned$props !== void 0 && _cleaned$props.children) {
        cleaned.props.children = cleanJSX2(cleaned.props.children);
      }
      return cleaned;
    }
  }
  return jsx;
};
var isDirtyJSX = function isDirtyJSX2(jsx) {
  return _typeof$3(jsx) === "object" && jsx !== null && !Array.isArray(jsx) && Object.keys(jsx).includes("type") && Object.keys(jsx).includes("props") && Object.keys(jsx).includes("key") && Object.keys(jsx).includes("ref") && Object.keys(jsx).includes("$$typeof");
};
var isJSX = function isJSX2(jsx) {
  return _typeof$3(jsx) === "object" && jsx !== null && !Array.isArray(jsx) && typeof jsx["type"] === "string" && Object.keys(jsx).includes("props");
};
var isJsonLogic = function isJsonLogic2(logic2) {
  var isJL = _typeof$3(logic2) === "object" && logic2 !== null && !Array.isArray(logic2) && Object.keys(logic2).length === 1;
  return isJL;
};
function sleep$1(delay) {
  return new Promise(function(resolve) {
    setTimeout(resolve, delay);
  });
}
function mergeArraysSmart(arr1, arr2) {
  if (!arr1) arr1 = [];
  if (!arr2) arr2 = [];
  return arr2.map(function(op2) {
    return [op2, arr1.indexOf(op2)];
  }).map(function(_ref3, i2, orig) {
    var _ref4 = _slicedToArray$1(_ref3, 2), op2 = _ref4[0], ind = _ref4[1];
    if (ind == -1) {
      var next = orig.slice(i2 + 1);
      var prev = orig.slice(0, i2);
      var after = prev.reverse().find(function(_ref5) {
        var _ref6 = _slicedToArray$1(_ref5, 2);
        _ref6[0];
        var ci = _ref6[1];
        return ci != -1;
      });
      var before = next.find(function(_ref7) {
        var _ref8 = _slicedToArray$1(_ref7, 2);
        _ref8[0];
        var ci = _ref8[1];
        return ci != -1;
      });
      if (before) return [op2, "before", before[0]];
      else if (after) return [op2, "after", after[0]];
      else return [op2, "append", null];
    } else {
      return null;
    }
  }).filter(function(x) {
    return x !== null;
  }).reduce(function(acc, _ref9) {
    var _ref10 = _slicedToArray$1(_ref9, 3), newOp = _ref10[0], rel = _ref10[1], relOp = _ref10[2];
    var ind = acc.indexOf(relOp);
    if (acc.indexOf(newOp) == -1) {
      if (ind > -1) {
        acc.splice(ind + (rel == "after" ? 1 : 0), 0, newOp);
      } else {
        acc.splice(rel == "append" ? Infinity : 0, 0, newOp);
      }
    }
    return acc;
  }, arr1.slice());
}
var deepFreeze = function deepFreeze2(obj) {
  if (_typeof$3(obj) === "object" && obj !== null && !isDirtyJSX(obj)) {
    Object.keys(obj).forEach(function(prop) {
      if (prop !== "__cache") {
        deepFreeze2(obj[prop]);
      }
    });
    Object.freeze(obj);
  }
};
var isJsonCompatible = function isJsonCompatible2(tpl, obj) {
  var bag = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
  if (isObject$g(tpl)) {
    if (tpl["var"]) {
      bag[tpl["var"]] = obj;
      return true;
    }
    if (!isObject$g(obj)) return false;
    for (var k in tpl) {
      var tv = tpl[k];
      var ov = obj[k];
      if (!isJsonCompatible2(tv, ov, bag, [].concat(_toConsumableArray(path), [k]))) return false;
    }
    return true;
  } else if (Array.isArray(tpl)) {
    if (!Array.isArray(obj)) return false;
    for (var i2 = 0; i2 < tpl.length; i2++) {
      var _tv = tpl[i2];
      var _ov = obj[i2];
      if (!isJsonCompatible2(_tv, _ov, bag, [].concat(_toConsumableArray(path), [i2]))) return false;
    }
    return true;
  } else {
    return tpl === obj;
  }
};
var isDev$1 = function isDev2() {
  return typeof process !== "undefined" && define_process_env_default$1 && false;
};
var getLogger$1 = function getLogger2() {
  var devMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  var verbose = devMode != void 0 ? devMode : isDev$1();
  return verbose ? console : {
    error: function error2() {
    },
    log: function log() {
    },
    warn: function warn2() {
    },
    debug: function debug() {
    },
    info: function info() {
    }
  };
};
var getFirstDefined = function getFirstDefined2() {
  var arr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var ret;
  for (var i2 = 0; i2 < arr.length; i2++) {
    var v = arr[i2];
    if (v !== void 0) {
      ret = v;
      break;
    }
  }
  return ret;
};
var logger$1 = getLogger$1();
const stuff = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  applyToJS,
  cleanJSX,
  deepEqual,
  deepFreeze,
  escapeRegExp,
  getFirstDefined,
  getLogger: getLogger$1,
  getOpCardinality: getOpCardinality$1,
  isDirtyJSX,
  isImmutable: isImmutable$1,
  isImmutableList,
  isJSX,
  isJsonCompatible,
  isJsonLogic,
  isObject: isObject$g,
  logger: logger$1,
  mergeArraysSmart,
  mergeCustomizerNoArrays,
  omit: omit$2,
  opDefKeysToOmit,
  shallowCopy,
  shallowEqual: shallowEqual$4,
  sleep: sleep$1,
  toImmutableList,
  uuid,
  widgetDefKeysToOmit
}, Symbol.toStringTag, { value: "Module" }));
var regeneratorRuntime$1 = { exports: {} };
var _typeof$1 = { exports: {} };
(function(module2) {
  function _typeof2(o) {
    "@babel/helpers - typeof";
    return module2.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof2(o);
  }
  module2.exports = _typeof2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(_typeof$1);
var _typeofExports = _typeof$1.exports;
(function(module2) {
  var _typeof2 = _typeofExports["default"];
  function _regeneratorRuntime2() {
    module2.exports = _regeneratorRuntime2 = function _regeneratorRuntime3() {
      return e2;
    }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    var t2, e2 = {}, r2 = Object.prototype, n2 = r2.hasOwnProperty, o = Object.defineProperty || function(t3, e3, r3) {
      t3[e3] = r3.value;
    }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", c2 = i2.asyncIterator || "@@asyncIterator", u = i2.toStringTag || "@@toStringTag";
    function define2(t3, e3, r3) {
      return Object.defineProperty(t3, e3, {
        value: r3,
        enumerable: true,
        configurable: true,
        writable: true
      }), t3[e3];
    }
    try {
      define2({}, "");
    } catch (t3) {
      define2 = function define3(t4, e3, r3) {
        return t4[e3] = r3;
      };
    }
    function wrap(t3, e3, r3, n3) {
      var i3 = e3 && e3.prototype instanceof Generator ? e3 : Generator, a3 = Object.create(i3.prototype), c3 = new Context(n3 || []);
      return o(a3, "_invoke", {
        value: makeInvokeMethod(t3, r3, c3)
      }), a3;
    }
    function tryCatch(t3, e3, r3) {
      try {
        return {
          type: "normal",
          arg: t3.call(e3, r3)
        };
      } catch (t4) {
        return {
          type: "throw",
          arg: t4
        };
      }
    }
    e2.wrap = wrap;
    var h = "suspendedStart", l = "suspendedYield", f = "executing", s2 = "completed", y = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var p = {};
    define2(p, a2, function() {
      return this;
    });
    var d = Object.getPrototypeOf, v = d && d(d(values2([])));
    v && v !== r2 && n2.call(v, a2) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t3) {
      ["next", "throw", "return"].forEach(function(e3) {
        define2(t3, e3, function(t4) {
          return this._invoke(e3, t4);
        });
      });
    }
    function AsyncIterator(t3, e3) {
      function invoke(r4, o2, i3, a3) {
        var c3 = tryCatch(t3[r4], t3, o2);
        if ("throw" !== c3.type) {
          var u2 = c3.arg, h2 = u2.value;
          return h2 && "object" == _typeof2(h2) && n2.call(h2, "__await") ? e3.resolve(h2.__await).then(function(t4) {
            invoke("next", t4, i3, a3);
          }, function(t4) {
            invoke("throw", t4, i3, a3);
          }) : e3.resolve(h2).then(function(t4) {
            u2.value = t4, i3(u2);
          }, function(t4) {
            return invoke("throw", t4, i3, a3);
          });
        }
        a3(c3.arg);
      }
      var r3;
      o(this, "_invoke", {
        value: function value(t4, n3) {
          function callInvokeWithMethodAndArg() {
            return new e3(function(e4, r4) {
              invoke(t4, n3, e4, r4);
            });
          }
          return r3 = r3 ? r3.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e3, r3, n3) {
      var o2 = h;
      return function(i3, a3) {
        if (o2 === f) throw Error("Generator is already running");
        if (o2 === s2) {
          if ("throw" === i3) throw a3;
          return {
            value: t2,
            done: true
          };
        }
        for (n3.method = i3, n3.arg = a3; ; ) {
          var c3 = n3.delegate;
          if (c3) {
            var u2 = maybeInvokeDelegate(c3, n3);
            if (u2) {
              if (u2 === y) continue;
              return u2;
            }
          }
          if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
          else if ("throw" === n3.method) {
            if (o2 === h) throw o2 = s2, n3.arg;
            n3.dispatchException(n3.arg);
          } else "return" === n3.method && n3.abrupt("return", n3.arg);
          o2 = f;
          var p2 = tryCatch(e3, r3, n3);
          if ("normal" === p2.type) {
            if (o2 = n3.done ? s2 : l, p2.arg === y) continue;
            return {
              value: p2.arg,
              done: n3.done
            };
          }
          "throw" === p2.type && (o2 = s2, n3.method = "throw", n3.arg = p2.arg);
        }
      };
    }
    function maybeInvokeDelegate(e3, r3) {
      var n3 = r3.method, o2 = e3.iterator[n3];
      if (o2 === t2) return r3.delegate = null, "throw" === n3 && e3.iterator["return"] && (r3.method = "return", r3.arg = t2, maybeInvokeDelegate(e3, r3), "throw" === r3.method) || "return" !== n3 && (r3.method = "throw", r3.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), y;
      var i3 = tryCatch(o2, e3.iterator, r3.arg);
      if ("throw" === i3.type) return r3.method = "throw", r3.arg = i3.arg, r3.delegate = null, y;
      var a3 = i3.arg;
      return a3 ? a3.done ? (r3[e3.resultName] = a3.value, r3.next = e3.nextLoc, "return" !== r3.method && (r3.method = "next", r3.arg = t2), r3.delegate = null, y) : a3 : (r3.method = "throw", r3.arg = new TypeError("iterator result is not an object"), r3.delegate = null, y);
    }
    function pushTryEntry(t3) {
      var e3 = {
        tryLoc: t3[0]
      };
      1 in t3 && (e3.catchLoc = t3[1]), 2 in t3 && (e3.finallyLoc = t3[2], e3.afterLoc = t3[3]), this.tryEntries.push(e3);
    }
    function resetTryEntry(t3) {
      var e3 = t3.completion || {};
      e3.type = "normal", delete e3.arg, t3.completion = e3;
    }
    function Context(t3) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t3.forEach(pushTryEntry, this), this.reset(true);
    }
    function values2(e3) {
      if (e3 || "" === e3) {
        var r3 = e3[a2];
        if (r3) return r3.call(e3);
        if ("function" == typeof e3.next) return e3;
        if (!isNaN(e3.length)) {
          var o2 = -1, i3 = function next() {
            for (; ++o2 < e3.length; ) if (n2.call(e3, o2)) return next.value = e3[o2], next.done = false, next;
            return next.value = t2, next.done = true, next;
          };
          return i3.next = i3;
        }
      }
      throw new TypeError(_typeof2(e3) + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: true
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: true
    }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e2.isGeneratorFunction = function(t3) {
      var e3 = "function" == typeof t3 && t3.constructor;
      return !!e3 && (e3 === GeneratorFunction || "GeneratorFunction" === (e3.displayName || e3.name));
    }, e2.mark = function(t3) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t3, GeneratorFunctionPrototype) : (t3.__proto__ = GeneratorFunctionPrototype, define2(t3, u, "GeneratorFunction")), t3.prototype = Object.create(g), t3;
    }, e2.awrap = function(t3) {
      return {
        __await: t3
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c2, function() {
      return this;
    }), e2.AsyncIterator = AsyncIterator, e2.async = function(t3, r3, n3, o2, i3) {
      void 0 === i3 && (i3 = Promise);
      var a3 = new AsyncIterator(wrap(t3, r3, n3, o2), i3);
      return e2.isGeneratorFunction(r3) ? a3 : a3.next().then(function(t4) {
        return t4.done ? t4.value : a3.next();
      });
    }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a2, function() {
      return this;
    }), define2(g, "toString", function() {
      return "[object Generator]";
    }), e2.keys = function(t3) {
      var e3 = Object(t3), r3 = [];
      for (var n3 in e3) r3.push(n3);
      return r3.reverse(), function next() {
        for (; r3.length; ) {
          var t4 = r3.pop();
          if (t4 in e3) return next.value = t4, next.done = false, next;
        }
        return next.done = true, next;
      };
    }, e2.values = values2, Context.prototype = {
      constructor: Context,
      reset: function reset2(e3) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t2, this.done = false, this.delegate = null, this.method = "next", this.arg = t2, this.tryEntries.forEach(resetTryEntry), !e3) for (var r3 in this) "t" === r3.charAt(0) && n2.call(this, r3) && !isNaN(+r3.slice(1)) && (this[r3] = t2);
      },
      stop: function stop() {
        this.done = true;
        var t3 = this.tryEntries[0].completion;
        if ("throw" === t3.type) throw t3.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(e3) {
        if (this.done) throw e3;
        var r3 = this;
        function handle(n3, o3) {
          return a3.type = "throw", a3.arg = e3, r3.next = n3, o3 && (r3.method = "next", r3.arg = t2), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i3 = this.tryEntries[o2], a3 = i3.completion;
          if ("root" === i3.tryLoc) return handle("end");
          if (i3.tryLoc <= this.prev) {
            var c3 = n2.call(i3, "catchLoc"), u2 = n2.call(i3, "finallyLoc");
            if (c3 && u2) {
              if (this.prev < i3.catchLoc) return handle(i3.catchLoc, true);
              if (this.prev < i3.finallyLoc) return handle(i3.finallyLoc);
            } else if (c3) {
              if (this.prev < i3.catchLoc) return handle(i3.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i3.finallyLoc) return handle(i3.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(t3, e3) {
        for (var r3 = this.tryEntries.length - 1; r3 >= 0; --r3) {
          var o2 = this.tryEntries[r3];
          if (o2.tryLoc <= this.prev && n2.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i3 = o2;
            break;
          }
        }
        i3 && ("break" === t3 || "continue" === t3) && i3.tryLoc <= e3 && e3 <= i3.finallyLoc && (i3 = null);
        var a3 = i3 ? i3.completion : {};
        return a3.type = t3, a3.arg = e3, i3 ? (this.method = "next", this.next = i3.finallyLoc, y) : this.complete(a3);
      },
      complete: function complete(t3, e3) {
        if ("throw" === t3.type) throw t3.arg;
        return "break" === t3.type || "continue" === t3.type ? this.next = t3.arg : "return" === t3.type ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : "normal" === t3.type && e3 && (this.next = e3), y;
      },
      finish: function finish(t3) {
        for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
          var r3 = this.tryEntries[e3];
          if (r3.finallyLoc === t3) return this.complete(r3.completion, r3.afterLoc), resetTryEntry(r3), y;
        }
      },
      "catch": function _catch(t3) {
        for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
          var r3 = this.tryEntries[e3];
          if (r3.tryLoc === t3) {
            var n3 = r3.completion;
            if ("throw" === n3.type) {
              var o2 = n3.arg;
              resetTryEntry(r3);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(e3, r3, n3) {
        return this.delegate = {
          iterator: values2(e3),
          resultName: r3,
          nextLoc: n3
        }, "next" === this.method && (this.arg = t2), y;
      }
    }, e2;
  }
  module2.exports = _regeneratorRuntime2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(regeneratorRuntime$1);
var regeneratorRuntimeExports = regeneratorRuntime$1.exports;
var runtime = regeneratorRuntimeExports();
var regenerator = runtime;
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
const _regeneratorRuntime = /* @__PURE__ */ getDefaultExportFromCjs(regenerator);
var baseGetTag$3 = _baseGetTag, isObjectLike$6 = isObjectLike_1;
var symbolTag$4 = "[object Symbol]";
function isSymbol$5(value) {
  return typeof value == "symbol" || isObjectLike$6(value) && baseGetTag$3(value) == symbolTag$4;
}
var isSymbol_1 = isSymbol$5;
var isArray$a = isArray_1, isSymbol$4 = isSymbol_1;
var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp$1 = /^\w*$/;
function isKey$4(value, object) {
  if (isArray$a(value)) {
    return false;
  }
  var type2 = typeof value;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol$4(value)) {
    return true;
  }
  return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$4;
var MapCache$1 = _MapCache;
var FUNC_ERROR_TEXT$4 = "Expected a function";
function memoize$2(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$4);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$2.Cache || MapCache$1)();
  return memoized;
}
memoize$2.Cache = MapCache$1;
var memoize_1 = memoize$2;
var memoize$1 = memoize_1;
var MAX_MEMOIZE_SIZE$1 = 500;
function memoizeCapped$2(func) {
  var result = memoize$1(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE$1) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$2;
var memoizeCapped$1 = _memoizeCapped;
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar$1 = /\\(\\)?/g;
var stringToPath$2 = memoizeCapped$1(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName$1, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar$1, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$2;
function arrayMap$5(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var _arrayMap = arrayMap$5;
var Symbol$4 = _Symbol, arrayMap$4 = _arrayMap, isArray$9 = isArray_1, isSymbol$3 = isSymbol_1;
var INFINITY$4 = 1 / 0;
var symbolProto$3 = Symbol$4 ? Symbol$4.prototype : void 0, symbolToString$1 = symbolProto$3 ? symbolProto$3.toString : void 0;
function baseToString$3(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$9(value)) {
    return arrayMap$4(value, baseToString$3) + "";
  }
  if (isSymbol$3(value)) {
    return symbolToString$1 ? symbolToString$1.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$4 ? "-0" : result;
}
var _baseToString = baseToString$3;
var baseToString$2 = _baseToString;
function toString$3(value) {
  return value == null ? "" : baseToString$2(value);
}
var toString_1 = toString$3;
var isArray$8 = isArray_1, isKey$3 = _isKey, stringToPath$1 = _stringToPath, toString$2 = toString_1;
function castPath$7(value, object) {
  if (isArray$8(value)) {
    return value;
  }
  return isKey$3(value, object) ? [value] : stringToPath$1(toString$2(value));
}
var _castPath = castPath$7;
var isSymbol$2 = isSymbol_1;
var INFINITY$3 = 1 / 0;
function toKey$7(value) {
  if (typeof value == "string" || isSymbol$2(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
}
var _toKey = toKey$7;
var castPath$6 = _castPath, toKey$6 = _toKey;
function baseGet$5(object, path) {
  path = castPath$6(path, object);
  var index2 = 0, length = path.length;
  while (object != null && index2 < length) {
    object = object[toKey$6(path[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
var _baseGet = baseGet$5;
var getNative$1 = _getNative;
var defineProperty$3 = function() {
  try {
    var func = getNative$1(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var _defineProperty$1 = defineProperty$3;
var defineProperty$2 = _defineProperty$1;
function baseAssignValue$5(object, key, value) {
  if (key == "__proto__" && defineProperty$2) {
    defineProperty$2(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$5;
var baseAssignValue$4 = _baseAssignValue, eq$3 = eq_1;
var objectProto$i = Object.prototype;
var hasOwnProperty$f = objectProto$i.hasOwnProperty;
function assignValue$4(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$f.call(object, key) && eq$3(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$4(object, key, value);
  }
}
var _assignValue = assignValue$4;
var assignValue$3 = _assignValue, castPath$5 = _castPath, isIndex$3 = _isIndex, isObject$f = isObject_1, toKey$5 = _toKey;
function baseSet$1(object, path, value, customizer) {
  if (!isObject$f(object)) {
    return object;
  }
  path = castPath$5(path, object);
  var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index2 < length) {
    var key = toKey$5(path[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$f(objValue) ? objValue : isIndex$3(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue$3(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet$1;
var baseGet$4 = _baseGet, baseSet = _baseSet, castPath$4 = _castPath;
function basePickBy$2(object, paths, predicate) {
  var index2 = -1, length = paths.length, result = {};
  while (++index2 < length) {
    var path = paths[index2], value = baseGet$4(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath$4(path, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$2;
function baseHasIn$2(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$2;
var castPath$3 = _castPath, isArguments$3 = isArguments_1, isArray$7 = isArray_1, isIndex$2 = _isIndex, isLength$1 = isLength_1, toKey$4 = _toKey;
function hasPath$2(object, path, hasFunc) {
  path = castPath$3(path, object);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key = toKey$4(path[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength$1(length) && isIndex$2(key, length) && (isArray$7(object) || isArguments$3(object));
}
var _hasPath = hasPath$2;
var baseHasIn$1 = _baseHasIn, hasPath$1 = _hasPath;
function hasIn$3(object, path) {
  return object != null && hasPath$1(object, path, baseHasIn$1);
}
var hasIn_1 = hasIn$3;
var basePickBy$1 = _basePickBy, hasIn$2 = hasIn_1;
function basePick$1(object, paths) {
  return basePickBy$1(object, paths, function(value, path) {
    return hasIn$2(object, path);
  });
}
var _basePick = basePick$1;
var Symbol$3 = _Symbol, isArguments$2 = isArguments_1, isArray$6 = isArray_1;
var spreadableSymbol = Symbol$3 ? Symbol$3.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$6(value) || isArguments$2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush$2 = _arrayPush, isFlattenable = _isFlattenable;
function baseFlatten$1(array, depth, predicate, isStrict, result) {
  var index2 = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush$2(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$1;
var baseFlatten = _baseFlatten;
function flatten$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}
var flatten_1 = flatten$1;
function apply$2(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$2;
var apply$1 = _apply;
var nativeMax$4 = Math.max;
function overRest$3(func, start, transform2) {
  start = nativeMax$4(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax$4(args.length - start, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform2(array);
    return apply$1(func, this, otherArgs);
  };
}
var _overRest = overRest$3;
function constant$2(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$2;
function identity$5(value) {
  return value;
}
var identity_1 = identity$5;
var constant$1 = constant_1, defineProperty$1 = _defineProperty$1, identity$4 = identity_1;
var baseSetToString$2 = !defineProperty$1 ? identity$4 : function(func, string) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant$1(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$2;
var HOT_COUNT$1 = 800, HOT_SPAN$1 = 16;
var nativeNow$1 = Date.now;
function shortOut$2(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow$1(), remaining = HOT_SPAN$1 - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT$1) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$2;
var baseSetToString$1 = _baseSetToString, shortOut$1 = _shortOut;
var setToString$3 = shortOut$1(baseSetToString$1);
var _setToString = setToString$3;
var flatten3 = flatten_1, overRest$2 = _overRest, setToString$2 = _setToString;
function flatRest$2(func) {
  return setToString$2(overRest$2(func, void 0, flatten3), func + "");
}
var _flatRest = flatRest$2;
var basePick = _basePick, flatRest$1 = _flatRest;
var pick = flatRest$1(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});
var pick_1 = pick;
const pick$1 = /* @__PURE__ */ getDefaultExportFromCjs(pick_1);
function last$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_1 = last$1;
const last$2 = /* @__PURE__ */ getDefaultExportFromCjs(last_1);
function arrayEach$2(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$2;
var assignValue$2 = _assignValue, baseAssignValue$3 = _baseAssignValue;
function copyObject$7(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue$3(object, key, newValue);
    } else {
      assignValue$2(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$7;
var copyObject$6 = _copyObject, keys$4 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$6(source, keys$4(source), object);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$2(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$2;
var isObject$e = isObject_1, isPrototype$2 = _isPrototype, nativeKeysIn$1 = _nativeKeysIn;
var objectProto$h = Object.prototype;
var hasOwnProperty$e = objectProto$h.hasOwnProperty;
function baseKeysIn$2(object) {
  if (!isObject$e(object)) {
    return nativeKeysIn$1(object);
  }
  var isProto = isPrototype$2(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$e.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$2;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeysIn$1 = _baseKeysIn, isArrayLike$5 = isArrayLike_1;
function keysIn$6(object) {
  return isArrayLike$5(object) ? arrayLikeKeys$1(object, true) : baseKeysIn$1(object);
}
var keysIn_1 = keysIn$6;
var copyObject$5 = _copyObject, keysIn$5 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$5(source, keysIn$5(source), object);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
(function(module2, exports2) {
  var root2 = _root;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var Buffer2 = moduleExports2 ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module2.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var _cloneBufferExports = _cloneBuffer.exports;
function copyArray$3(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
var _copyArray = copyArray$3;
var copyObject$4 = _copyObject, getSymbols$2 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$4(source, getSymbols$2(source), object);
}
var _copySymbols = copySymbols$1;
var overArg$1 = _overArg;
var getPrototype$4 = overArg$1(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$4;
var arrayPush$1 = _arrayPush, getPrototype$3 = _getPrototype, getSymbols$1 = _getSymbols, stubArray$1 = stubArray_1;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  var result = [];
  while (object) {
    arrayPush$1(result, getSymbols$1(object));
    object = getPrototype$3(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$3 = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject$3(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$4 = keysIn_1;
function getAllKeysIn$3(object) {
  return baseGetAllKeys$1(object, keysIn$4, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$3;
var objectProto$g = Object.prototype;
var hasOwnProperty$d = objectProto$g.hasOwnProperty;
function initCloneArray$1(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$d.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var Uint8Array$2 = _Uint8Array;
function cloneArrayBuffer$4(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$4;
var cloneArrayBuffer$3 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$3(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$2 = _Symbol;
var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneTypedArray$3(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$3;
var cloneArrayBuffer$1 = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray$2 = _cloneTypedArray;
var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$4 = "[object String]", symbolTag$3 = "[object Symbol]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$3:
      return cloneArrayBuffer$1(object);
    case boolTag$3:
    case dateTag$3:
      return new Ctor(+object);
    case dataViewTag$4:
      return cloneDataView(object, isDeep);
    case float32Tag$2:
    case float64Tag$2:
    case int8Tag$2:
    case int16Tag$2:
    case int32Tag$2:
    case uint8Tag$2:
    case uint8ClampedTag$2:
    case uint16Tag$2:
    case uint32Tag$2:
      return cloneTypedArray$2(object, isDeep);
    case mapTag$5:
      return new Ctor();
    case numberTag$3:
    case stringTag$4:
      return new Ctor(object);
    case regexpTag$3:
      return cloneRegExp(object);
    case setTag$5:
      return new Ctor();
    case symbolTag$3:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$d = isObject_1;
var objectCreate$1 = Object.create;
var baseCreate$2 = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto2) {
    if (!isObject$d(proto2)) {
      return {};
    }
    if (objectCreate$1) {
      return objectCreate$1(proto2);
    }
    object.prototype = proto2;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$2;
var baseCreate$1 = _baseCreate, getPrototype$2 = _getPrototype, isPrototype$1 = _isPrototype;
function initCloneObject$3(object) {
  return typeof object.constructor == "function" && !isPrototype$1(object) ? baseCreate$1(getPrototype$2(object)) : {};
}
var _initCloneObject = initCloneObject$3;
var getTag$3 = _getTag, isObjectLike$5 = isObjectLike_1;
var mapTag$4 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$5(value) && getTag$3(value) == mapTag$4;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$2 = _baseUnary, nodeUtil$2 = _nodeUtilExports;
var nodeIsMap = nodeUtil$2 && nodeUtil$2.isMap;
var isMap$1 = nodeIsMap ? baseUnary$2(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$2 = _getTag, isObjectLike$4 = isObjectLike_1;
var setTag$4 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$4(value) && getTag$2(value) == setTag$4;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtilExports;
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet$1 = nodeIsSet ? baseUnary$1(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack$3 = _Stack, arrayEach$1 = _arrayEach, assignValue$1 = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer$2 = _cloneBufferExports, copyArray$2 = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys$1 = _getAllKeys, getAllKeysIn$2 = _getAllKeysIn, getTag$1 = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject$2 = _initCloneObject, isArray$5 = isArray_1, isBuffer$2 = isBufferExports, isMap = isMap_1, isObject$c = isObject_1, isSet = isSet_1, keys$3 = keys_1, keysIn$3 = keysIn_1;
var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag$3 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", objectTag$5 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$3 = "[object String]", symbolTag$2 = "[object Symbol]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag$1] = cloneableTags[float64Tag$1] = cloneableTags[int8Tag$1] = cloneableTags[int16Tag$1] = cloneableTags[int32Tag$1] = cloneableTags[mapTag$3] = cloneableTags[numberTag$2] = cloneableTags[objectTag$5] = cloneableTags[regexpTag$2] = cloneableTags[setTag$3] = cloneableTags[stringTag$3] = cloneableTags[symbolTag$2] = cloneableTags[uint8Tag$1] = cloneableTags[uint8ClampedTag$1] = cloneableTags[uint16Tag$1] = cloneableTags[uint32Tag$1] = true;
cloneableTags[errorTag$2] = cloneableTags[funcTag$2] = cloneableTags[weakMapTag$2] = false;
function baseClone$2(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$c(value)) {
    return value;
  }
  var isArr = isArray$5(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray$2(value, result);
    }
  } else {
    var tag = getTag$1(value), isFunc = tag == funcTag$2 || tag == genTag$1;
    if (isBuffer$2(value)) {
      return cloneBuffer$2(value, isDeep);
    }
    if (tag == objectTag$5 || tag == argsTag$3 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject$2(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack$3());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn$2 : getAllKeys$1 : isFlat ? keysIn$3 : keys$3;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach$1(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue$1(result, key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$2;
function baseSlice$1(array, start, end) {
  var index2 = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array[index2 + start];
  }
  return result;
}
var _baseSlice = baseSlice$1;
var baseGet$3 = _baseGet, baseSlice = _baseSlice;
function parent$2(object, path) {
  return path.length < 2 ? object : baseGet$3(object, baseSlice(path, 0, -1));
}
var _parent = parent$2;
var castPath$2 = _castPath, last3 = last_1, parent$1 = _parent, toKey$3 = _toKey;
function baseUnset$1(object, path) {
  path = castPath$2(path, object);
  object = parent$1(object, path);
  return object == null || delete object[toKey$3(last3(path))];
}
var _baseUnset = baseUnset$1;
var baseGetTag$2 = _baseGetTag, getPrototype$1 = _getPrototype, isObjectLike$3 = isObjectLike_1;
var objectTag$4 = "[object Object]";
var funcProto$3 = Function.prototype, objectProto$f = Object.prototype;
var funcToString$3 = funcProto$3.toString;
var hasOwnProperty$c = objectProto$f.hasOwnProperty;
var objectCtorString$1 = funcToString$3.call(Object);
function isPlainObject$3(value) {
  if (!isObjectLike$3(value) || baseGetTag$2(value) != objectTag$4) {
    return false;
  }
  var proto2 = getPrototype$1(value);
  if (proto2 === null) {
    return true;
  }
  var Ctor = hasOwnProperty$c.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$3.call(Ctor) == objectCtorString$1;
}
var isPlainObject_1 = isPlainObject$3;
var isPlainObject$2 = isPlainObject_1;
function customOmitClone$1(value) {
  return isPlainObject$2(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone$1;
var arrayMap$3 = _arrayMap, baseClone$1 = _baseClone, baseUnset = _baseUnset, castPath$1 = _castPath, copyObject$2 = _copyObject, customOmitClone = _customOmitClone, flatRest = _flatRest, getAllKeysIn$1 = _getAllKeysIn;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap$3(paths, function(path) {
    path = castPath$1(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject$2(object, getAllKeysIn$1(object), result);
  if (isDeep) {
    result = baseClone$1(result, CLONE_DEEP_FLAG$1 | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG$1, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});
var omit_1 = omit;
const omit$1 = /* @__PURE__ */ getDefaultExportFromCjs(omit_1);
function _createForOfIteratorHelper$e(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$e(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null) it["return"]();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$e(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$e(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$e(o, minLen);
}
function _arrayLikeToArray$e(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function ownKeys$C(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$C(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$C(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$C(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var isObject$b = function isObject(v) {
  return _typeof$3(v) == "object" && v !== null && !Array.isArray(v);
};
var toListValue = function toListValue2(v, title2) {
  if (v == null || v == "") {
    return void 0;
  } else if (isObject$b(v)) {
    return _objectSpread$C(_objectSpread$C({}, v), {}, {
      title: v.title || v.value
      // fallback to value
    });
  } else {
    return {
      value: v,
      title: title2 !== void 0 ? title2 : "" + v
    };
  }
};
var makeCustomListValue$1 = function makeCustomListValue(v) {
  var lv = toListValue(v);
  if (isObject$b(lv)) {
    return _objectSpread$C(_objectSpread$C({}, toListValue(v)), {}, {
      isCustom: true
    });
  } else {
    return lv;
  }
};
var listValuesToArray$1 = function listValuesToArray(listValuesObj) {
  if (Array.isArray(listValuesObj)) return listValuesObj.map(function(v2) {
    return toListValue(v2);
  });
  if (!isObject$b(listValuesObj)) return listValuesObj;
  var listValuesArr = [];
  for (var v in listValuesObj) {
    var title2 = listValuesObj[v];
    listValuesArr.push(toListValue(v, title2));
  }
  return listValuesArr;
};
var getItemInListValues = function getItemInListValues2(listValues2, value) {
  if (Array.isArray(listValues2)) {
    var values2 = listValues2.map(function(v) {
      return toListValue(v);
    });
    return values2.find(function(v) {
      return "" + v.value === "" + value;
    });
  } else {
    return listValues2[value] !== void 0 ? toListValue(value, listValues2[value]) : void 0;
  }
};
var getTitleInListValues$1 = function getTitleInListValues(listValues2, value) {
  if (listValues2 == void 0) return value;
  var it = getItemInListValues(listValues2, value);
  return it !== void 0 ? it.title : value;
};
var getValueInListValues = function getValueInListValues2(listValues2, value) {
  if (listValues2 == void 0) return value;
  var it = getItemInListValues(listValues2, value);
  return it !== void 0 ? it.value : value;
};
var mapListValues$5 = function mapListValues(listValues2, mapFn) {
  var ret = [];
  if (Array.isArray(listValues2)) {
    var _iterator = _createForOfIteratorHelper$e(listValues2), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var v = _step.value;
        var lv = mapFn(toListValue(v));
        if (lv != null) ret.push(lv);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    for (var value in listValues2) {
      var _lv = mapFn(toListValue(value, listValues2[value]));
      if (_lv != null) ret.push(_lv);
    }
  }
  return ret;
};
var searchListValue$1 = function searchListValue(search, listValues2) {
  return mapListValues$5(listValues2, function(lv) {
    return "".concat(lv.value).indexOf(search) != -1 || lv.title.indexOf(search) != -1 ? lv : null;
  }).filter(function(v) {
    return v !== null;
  }).shift();
};
var getListValue$1 = function getListValue(selectedValue, listValues2) {
  return mapListValues$5(listValues2, function(lv) {
    return "" + lv.value === "" + selectedValue ? lv : null;
  }).filter(function(v) {
    return v !== null;
  }).shift();
};
const listValues = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getItemInListValues,
  getListValue: getListValue$1,
  getTitleInListValues: getTitleInListValues$1,
  getValueInListValues,
  listValuesToArray: listValuesToArray$1,
  makeCustomListValue: makeCustomListValue$1,
  mapListValues: mapListValues$5,
  searchListValue: searchListValue$1,
  toListValue
}, Symbol.toStringTag, { value: "Module" }));
var expandTreePath = function expandTreePath2(path) {
  for (var _len = arguments.length, suffix = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    suffix[_key - 1] = arguments[_key];
  }
  return path.interpose("children1").withMutations(function(list2) {
    list2.skip(1);
    list2.push.apply(list2, suffix);
    return list2;
  });
};
var expandTreeSubpath = function expandTreeSubpath2(path) {
  for (var _len2 = arguments.length, suffix = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    suffix[_key2 - 1] = arguments[_key2];
  }
  return path.interpose("children1").withMutations(function(list2) {
    list2.push.apply(list2, suffix);
    return list2;
  });
};
var getItemByPath = function getItemByPath2(tree2, path) {
  var children = new Immutable.OrderedMap(_defineProperty$4({}, tree2.get("id"), tree2));
  var res = tree2;
  path.forEach(function(id2) {
    var _res;
    res = children.get(id2);
    children = (_res = res) === null || _res === void 0 ? void 0 : _res.get("children1");
  });
  return res;
};
var removeIsLockedInTree = function removeIsLockedInTree2(tree2) {
  var newTree2 = tree2;
  function _processNode(item, path) {
    var isParentLocked = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var itemPath = path.push(item.get("id"));
    var isLocked = item.getIn(["properties", "isLocked"]);
    if (isParentLocked && isLocked) {
      newTree2 = newTree2.deleteIn(expandTreePath(itemPath, "properties", "isLocked"));
    }
    var children = item.get("children1");
    if (children) {
      children.map(function(child, _childId) {
        _processNode(child, itemPath, isLocked || isParentLocked);
      });
    }
  }
  _processNode(tree2, new Immutable.List());
  return newTree2;
};
var fixPathsInTree = function fixPathsInTree2(tree2) {
  var newTree2 = tree2;
  function _processNode(item, path, lev, nodeId) {
    if (!item) return;
    var currPath = item.get("path");
    var currId = item.get("id");
    var itemId = currId || nodeId || uuid();
    var itemPath = path.push(itemId);
    if (!currPath || !currPath.equals(itemPath)) {
      newTree2 = newTree2.setIn(expandTreePath(itemPath, "path"), itemPath);
    }
    if (!currId) {
      newTree2 = newTree2.setIn(expandTreePath(itemPath, "id"), itemId);
    }
    var children = item.get("children1");
    if (children) {
      if (children.constructor.name === "Map") {
        newTree2 = newTree2.setIn(expandTreePath(itemPath, "children1"), new Immutable.OrderedMap(children));
      }
      children.map(function(child, childId) {
        _processNode(child, itemPath, lev + 1, childId);
      });
    }
  }
  _processNode(tree2, new Immutable.List(), 0);
  return newTree2;
};
var fixEmptyGroupsInTree = function fixEmptyGroupsInTree2(tree2) {
  var newTree2 = tree2;
  function _processNode(item, path, lev, nodeId) {
    if (!item) return false;
    var itemId = item.get("id") || nodeId;
    var itemPath = path.push(itemId);
    var children = item.get("children1");
    if (children) {
      var allChildrenGone = children.map(function(child, childId) {
        return _processNode(child, itemPath, lev + 1, childId);
      }).reduce(function(curr, v) {
        return curr && v;
      }, true);
      if ((children.size == 0 || allChildrenGone) && lev > 0) {
        newTree2 = newTree2.deleteIn(expandTreePath(itemPath));
        return true;
      }
    }
    return false;
  }
  _processNode(tree2, new Immutable.List(), 0);
  return newTree2;
};
var getFlatTree$1 = function getFlatTree(tree2) {
  var flat = [];
  var items = {};
  var cases = [];
  var visibleHeight = 0;
  var globalLeafCount = 0;
  var globalGroupCount = 0;
  var globalCountByType = {};
  function _flatizeTree(item2, path, insideCollapsed, insideLocked, insideRuleGroup, lev, caseId, childNo) {
    var isRoot = item2 === tree2;
    var type2 = item2.get("type");
    var collapsed = item2.get("collapsed");
    var id2 = item2.get("id");
    var children = item2.get("children1");
    var isLocked = item2.getIn(["properties", "isLocked"]);
    var childrenIds = children ? children.map(function(_child, childId) {
      return childId;
    }).valueSeq().toArray() : null;
    var isRuleGroup = type2 === "rule_group";
    var isRule = type2 === "rule";
    var isGroup2 = type2 === "group";
    var isCaseGroup = type2 === "case_group";
    var isAtomicRule = !insideRuleGroup && (!children || isRuleGroup);
    var hasChildren3 = (childrenIds === null || childrenIds === void 0 ? void 0 : childrenIds.length) > 0;
    var parentId = path.length ? path[path.length - 1] : null;
    var currentCaseId = isCaseGroup ? id2 : caseId;
    if (isCaseGroup) {
      cases.push(id2);
      globalLeafCount = 0;
      globalGroupCount = 0;
      globalCountByType = {};
    }
    var caseNo = currentCaseId ? cases.indexOf(currentCaseId) : null;
    var itemsBefore = flat.length;
    var top = visibleHeight;
    var position;
    if (!isRoot) {
      position = {};
      position.caseNo = caseNo;
      position.globalNoByType = isCaseGroup ? caseNo : globalCountByType[type2] || 0;
      position.indexPath = [].concat(_toConsumableArray(path.slice(1).map(function(id3) {
        return items[id3].childNo;
      })), [childNo]);
      if (isRule) {
        position.globalLeafNo = globalLeafCount;
      } else if (isGroup2) {
        position.globalGroupNo = globalGroupCount;
      }
    }
    flat.push(id2);
    items[id2] = {
      node: item2,
      index: itemsBefore,
      // index in `flat`
      id: id2,
      type: type2,
      parent: parentId,
      parentType: parentId ? items[parentId].type : null,
      children: childrenIds,
      childNo,
      caseId: currentCaseId,
      caseNo,
      path: path.concat(id2),
      lev,
      // depth level (0 for root node)
      isLeaf: !children,
      // is atomic rule OR rule inside rule_group
      isAtomicRule,
      // is atomic (rule or rule_group, but not rules inside rule_group)
      isLocked: isLocked || insideLocked,
      // vertical
      top: insideCollapsed ? null : top,
      // for case
      isDefaultCase: isCaseGroup ? !children : void 0,
      atomicRulesCountInCase: isCaseGroup ? 0 : void 0,
      // object with numbers indicating # of item in tree
      position,
      // unused
      collapsed,
      _top: itemsBefore,
      // @deprecated use isLeaf instead
      leaf: !children
      // will be added later:
      //  prev
      //  next
      //  depth  - for any group (children of rule_group are not counted, collapsed are not counted)
      //  height  - visible height
      //  bottom = (insideCollapsed ? null : top + height)
      //  _height = (itemsAfter - itemsBefore)  - real height (incl. collapsed)
    };
    var height = 0;
    var depth = 0;
    if (!insideCollapsed) {
      visibleHeight += 1;
      height += 1;
      if (hasChildren3 && !collapsed && !isRuleGroup) {
        depth += 1;
      }
      if (!isRoot && !isCaseGroup) {
        isGroup2 && globalGroupCount++;
        isRule && globalLeafCount++;
        globalCountByType[type2] = (globalCountByType[type2] || 0) + 1;
      }
    }
    if (caseId && isAtomicRule) {
      items[caseId].atomicRulesCountInCase++;
    }
    var maxChildDepth = 0;
    var sumHeight = 0;
    if (hasChildren3) {
      var childCount = 0;
      children.map(function(child, childId) {
        if (child) {
          _flatizeTree(child, path.concat(id2), insideCollapsed || collapsed, insideLocked || isLocked, insideRuleGroup || isRuleGroup, lev + 1, currentCaseId, childCount);
          var childItem = items[childId];
          maxChildDepth = Math.max(maxChildDepth, childItem.depth || 0);
          sumHeight += childItem.height;
          childCount++;
        }
      });
    }
    height += sumHeight;
    depth += maxChildDepth;
    var itemsAfter = flat.length;
    var _height = itemsAfter - itemsBefore;
    var bottom = insideCollapsed ? null : top + height;
    Object.assign(items[id2], {
      depth: children ? depth : void 0,
      _height,
      height,
      bottom
    });
  }
  _flatizeTree(tree2, [], false, false, false, 0, null, null);
  for (var i2 = 0; i2 < flat.length; i2++) {
    var prevId = i2 > 0 ? flat[i2 - 1] : null;
    var nextId2 = i2 < flat.length - 1 ? flat[i2 + 1] : null;
    var item = items[flat[i2]];
    item.prev = prevId;
    item.next = nextId2;
  }
  return {
    flat,
    items,
    cases
  };
};
var getTotalReordableNodesCountInTree$2 = function getTotalReordableNodesCountInTree(tree2) {
  if (!tree2) return -1;
  var cnt = 0;
  function _processNode(item, path, lev) {
    var id2, children, type2;
    if (typeof item.get === "function") {
      id2 = item.get("id");
      children = item.get("children1");
      type2 = item.get("type");
    } else {
      id2 = item.id;
      children = item.children1;
      type2 = item.type;
    }
    var isRuleGroup = type2 == "rule_group";
    cnt++;
    if (children && !isRuleGroup) {
      children.map(function(child, _childId) {
        if (child) {
          _processNode(child, path.concat(id2));
        }
      });
    }
  }
  _processNode(tree2, []);
  return cnt - 1;
};
var getTotalRulesCountInTree$2 = function getTotalRulesCountInTree(tree2) {
  if (!tree2) return -1;
  var cnt = 0;
  function _processNode(item, path, lev) {
    var id2, children, type2;
    if (typeof item.get === "function") {
      id2 = item.get("id");
      children = item.get("children1");
      type2 = item.get("type");
    } else {
      id2 = item.id;
      children = item.children1;
      type2 = item.type;
    }
    if (type2 == "rule" || type2 == "rule_group") {
      cnt++;
    } else if (children) {
      children.map(function(child, _childId) {
        if (child) {
          _processNode(child, path.concat(id2));
        }
      });
    }
  }
  _processNode(tree2, []);
  return cnt;
};
var getLightTree = function getLightTree2(tree2) {
  var deleteExcess = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var children1AsArray = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var newTree2 = tree2;
  function _processNode(item, itemId) {
    if (deleteExcess && item.path) {
      delete item.path;
    }
    if (deleteExcess && !children1AsArray && itemId) {
      delete item.id;
    }
    var properties = item.properties;
    if (properties) {
      if (properties.operatorOptions == null) {
        delete properties.operatorOptions;
      }
    }
    var children = item.children1;
    if (children) {
      for (var id2 in children) {
        if (children[id2]) {
          _processNode(children[id2], id2);
        }
      }
      if (children1AsArray) {
        item.children1 = Object.values(children);
      }
    }
  }
  _processNode(tree2, null);
  return newTree2;
};
var getSwitchValues = function getSwitchValues2(tree2) {
  var vals = [];
  var children = tree2.get("children1");
  if (children) {
    children.map(function(child) {
      var value = child.getIn(["properties", "value"]);
      var caseValue;
      if (value && value.size == 1) {
        caseValue = value.get(0);
        if (Array.isArray(caseValue) && caseValue.length == 0) {
          caseValue = null;
        }
      } else {
        caseValue = null;
      }
      vals = [].concat(_toConsumableArray(vals), [caseValue]);
    });
  }
  return vals;
};
var isEmptyTree = function isEmptyTree2(tree2) {
  return !tree2.get("children1") || tree2.get("children1").size == 0;
};
var hasChildren = function hasChildren2(tree2, path) {
  return tree2.getIn(expandTreePath(path, "children1")).size > 0;
};
var _fixImmutableValue$1 = function _fixImmutableValue(v) {
  if (v !== null && v !== void 0 && v.toJS) {
    var _v$toJS;
    var vJs = v === null || v === void 0 || (_v$toJS = v.toJS) === null || _v$toJS === void 0 ? void 0 : _v$toJS.call(v);
    if (vJs !== null && vJs !== void 0 && vJs.func) {
      return v.toOrderedMap();
    } else {
      return vJs;
    }
  } else {
    return v;
  }
};
const treeUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _fixImmutableValue: _fixImmutableValue$1,
  expandTreePath,
  expandTreeSubpath,
  fixEmptyGroupsInTree,
  fixPathsInTree,
  getFlatTree: getFlatTree$1,
  getItemByPath,
  getLightTree,
  getSwitchValues,
  getTotalReordableNodesCountInTree: getTotalReordableNodesCountInTree$2,
  getTotalRulesCountInTree: getTotalRulesCountInTree$2,
  hasChildren,
  immutableToJs: applyToJS,
  isEmptyTree,
  isImmutable: isImmutable$1,
  jsToImmutable,
  removeIsLockedInTree,
  toImmutableList
}, Symbol.toStringTag, { value: "Module" }));
var getTree = function getTree2(immutableTree) {
  var light = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var children1AsArray = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  if (!immutableTree) return void 0;
  var tree2 = immutableTree;
  tree2 = tree2.toJS();
  tree2 = getLightTree(tree2, light, children1AsArray);
  return tree2;
};
var loadTree = function loadTree2(serTree) {
  if (isImmutableTree(serTree)) {
    return serTree;
  } else if (isTree(serTree)) {
    return fixPathsInTree(jsToImmutable(serTree));
  } else if (typeof serTree == "string" && serTree.startsWith('["~#iM"')) {
    throw new Error("You are trying to load query in obsolete serialization format (Immutable string) which is not supported in versions starting from 2.1.17");
  } else if (typeof serTree === "string") {
    return fixPathsInTree(jsToImmutable(JSON.parse(serTree)));
  } else throw new Error("Can't load tree!");
};
var isImmutableTree = function isImmutableTree2(tree2) {
  return Map$2.isMap(tree2);
};
var isTree = function isTree2(tree2) {
  return _typeof$3(tree2) == "object" && (tree2.type == "group" || tree2.type == "switch_group");
};
function jsToImmutable(tree2) {
  var imm = fromJS(tree2, function(key, value, path) {
    var isFuncArg = path && path.length > 3 && path[path.length - 1] === "value" && path[path.length - 3] === "args";
    var isRuleValue = path && path.length > 3 && path[path.length - 1] === "value" && path[path.length - 2] === "properties";
    var outValue;
    if (key == "properties") {
      outValue = value.toOrderedMap();
      for (var i2 = 0; i2 < 2; i2++) {
        var _outValue$get, _outValue$get$get, _outValue$get2;
        if (((_outValue$get = outValue.get("value")) === null || _outValue$get === void 0 || (_outValue$get$get = (_outValue$get2 = _outValue$get).get) === null || _outValue$get$get === void 0 ? void 0 : _outValue$get$get.call(_outValue$get2, i2)) === null) {
          outValue = outValue.setIn(["value", i2], void 0);
        }
      }
    } else if (isFuncArg) {
      outValue = _fixImmutableValue$1(value);
    } else if ((path ? isRuleValue : key == "value") && Immutable.Iterable.isIndexed(value)) {
      outValue = value.map(_fixImmutableValue$1).toList();
    } else if (key == "asyncListValues") {
      outValue = value.toJS();
    } else if (key == "children1" && Immutable.Iterable.isIndexed(value)) {
      outValue = new Immutable.OrderedMap(value.map(function(child) {
        return [(child === null || child === void 0 ? void 0 : child.get("id")) || uuid(), child];
      }));
    } else {
      outValue = Immutable.Iterable.isIndexed(value) ? value.toList() : value.toOrderedMap();
    }
    return outValue;
  });
  return imm;
}
function ownKeys$B(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$B(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$B(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$B(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _createForOfIteratorHelper$d(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$d(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e2) {
        throw _e2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e3) {
    didErr = true;
    err = _e3;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null) it["return"]();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$d(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$d(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$d(o, minLen);
}
function _arrayLikeToArray$d(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
var arrayUniq = function arrayUniq2(arr) {
  return Array.from(new Set(arr));
};
var jlFieldMarker = "jlField";
var jlArgsMarker = "jlArgs";
var jlEqOps = ["==", "!="];
var jlRangeOps = ["<", "<=", ">", ">="];
var multiselectOps = ["multiselect_equals", "multiselect_not_equals", "multiselect_contains", "multiselect_not_contains"];
var createMeta = function createMeta2(parentMeta) {
  return {
    errors: [],
    settings: parentMeta === null || parentMeta === void 0 ? void 0 : parentMeta.settings
  };
};
var loadFromJsonLogic = function loadFromJsonLogic2(logicTree, config2) {
  return _loadFromJsonLogic(logicTree, config2, false);
};
var _loadFromJsonLogic = function _loadFromJsonLogic2(logicTree, config2) {
  var returnErrors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var meta = createMeta();
  meta.settings = {
    allowUnknownFields: false,
    returnErrors
  };
  var extendedConfig = extendConfig(config2, void 0, false);
  var conv = buildConv$1(extendedConfig);
  var jsTree = logicTree ? convertFromLogic(logicTree, conv, extendedConfig, ["rule", "group", "switch"], meta) : void 0;
  var immTree = jsTree ? loadTree(jsTree) : void 0;
  if (returnErrors) {
    return [immTree, meta.errors];
  } else {
    if (meta.errors.length) console.warn("Errors while importing from JsonLogic:", meta.errors);
    return immTree;
  }
};
var buildConv$1 = function buildConv(config2) {
  var operators2 = {};
  var combinationOperators = {};
  for (var opKey in config2.operators) {
    var opConfig = config2.operators[opKey];
    if (typeof opConfig.jsonLogic == "string") {
      var opk = opConfig.jsonLogic + "/" + getOpCardinality$1(opConfig);
      if (!operators2[opk]) operators2[opk] = [];
      operators2[opk].push(opKey);
    } else if (typeof opConfig.jsonLogic2 == "string") {
      var _opk = opConfig.jsonLogic2 + "/" + getOpCardinality$1(opConfig);
      if (!operators2[_opk]) operators2[_opk] = [];
      operators2[_opk].push(opKey);
      if (!combinationOperators[opKey]) combinationOperators[opKey] = {};
      combinationOperators[opKey] = {
        "template": opConfig.jsonLogic(jlFieldMarker, opKey, jlArgsMarker),
        "jsonLogic2": opConfig.jsonLogic2,
        "_jsonLogicIsExclamationOp": !!opConfig._jsonLogicIsExclamationOp
      };
    }
  }
  var conjunctions2 = {};
  for (var conjKey in config2.conjunctions) {
    var conjunctionDefinition = config2.conjunctions[conjKey];
    var ck = conjunctionDefinition.jsonLogicConj || conjKey.toLowerCase();
    conjunctions2[ck] = conjKey;
  }
  var funcs2 = {};
  var _iterator = _createForOfIteratorHelper$d(iterateFuncs(config2)), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _step$value = _slicedToArray$1(_step.value, 2), funcPath = _step$value[0], funcConfig = _step$value[1];
      var fk = void 0;
      if (funcConfig.jsonLogicIsMethod) {
        fk = "#" + funcConfig.jsonLogic;
      } else if (typeof funcConfig.jsonLogic == "string") {
        fk = funcConfig.jsonLogic;
      }
      if (fk) {
        if (!funcs2[fk]) funcs2[fk] = [];
        funcs2[fk].push(funcPath);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var _config$settings$json = config2.settings.jsonLogic, groupVarKey = _config$settings$json.groupVarKey, altVarKey = _config$settings$json.altVarKey;
  return {
    operators: operators2,
    conjunctions: conjunctions2,
    funcs: funcs2,
    varKeys: ["var", groupVarKey, altVarKey],
    combinationOperators
  };
};
var matchAgainstTemplates = function matchAgainstTemplates2(jsonlogic, conv, meta) {
  var operatorsToCheck = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var response;
  if (conv !== null && conv !== void 0 && conv.combinationOperators) {
    for (var _i = 0, _Object$entries = Object.entries(conv.combinationOperators); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray$1(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];
      if (operatorsToCheck == null || operatorsToCheck.includes(key)) {
        var tempResponse = isTemplateMatch(value.template, jsonlogic);
        if (tempResponse.match) {
          if (!response) response = tempResponse;
          else meta.errors.push("Operator matched against 2 templates: ".concat(response.newOp, " and ").concat(key));
          response["newOp"] = value.jsonLogic2;
        }
      }
    }
  }
  return response;
};
var isTemplateMatch = function isTemplateMatch2(template, jsonlogic) {
  var response = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    "match": true,
    "jlField": null,
    "jlArgs": []
  };
  if (template == void 0 || jsonlogic == void 0) {
    response.match = false;
    return response;
  }
  var tKeys = Object.keys(template);
  var jKeys = Object.keys(jsonlogic);
  if (tKeys.length !== jKeys.length) {
    response.match = false;
    return response;
  }
  for (var index2 = 0; index2 < tKeys.length; index2++) {
    var key = tKeys[index2];
    var value = template[key];
    if (key !== jKeys[index2]) {
      response.match = false;
      return response;
    } else if (value === jlFieldMarker && isJsonLogic(jsonlogic[key])) {
      response.jlField = jsonlogic[key];
    } else if (value === jlArgsMarker) {
      response.jlArgs.push(jsonlogic[key]);
    } else if (_typeof$3(value) === "object" && value !== null || Array.isArray(value)) {
      response = isTemplateMatch2(value, jsonlogic[key], response);
    } else if (value !== jsonlogic[key]) {
      response.match = false;
      return response;
    }
  }
  return response;
};
var convertFromLogic = function convertFromLogic2(logic2, conv, config2, expectedTypes, meta) {
  var not2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
  var fieldConfig = arguments.length > 6 ? arguments[6] : void 0;
  var widget = arguments.length > 7 ? arguments[7] : void 0;
  var parentField = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : null;
  var op2, vals;
  if (isJsonLogic(logic2)) {
    op2 = Object.keys(logic2)[0];
    vals = logic2[op2];
    if (!Array.isArray(vals)) vals = [vals];
  }
  var ret;
  var beforeErrorsCnt = meta.errors.length;
  var lockedOp = config2.settings.jsonLogic.lockedOp;
  var isEmptyOp = op2 == "!" && vals.length == 1 && vals[0] && isJsonLogic(vals[0]) && conv.varKeys.includes(Object.keys(vals[0])[0]);
  var match = matchAgainstTemplates(logic2, conv, meta);
  if (match) {
    vals = [];
    vals[0] = match.jlField;
    match.jlArgs.forEach(function(arg) {
      return vals.push(arg);
    });
    op2 = match.newOp;
  }
  var isNot = op2 == "!" && !isEmptyOp;
  var isLocked = lockedOp && op2 == lockedOp;
  var isSwitch = expectedTypes.includes("switch");
  var isRoot = isSwitch;
  if (isLocked) {
    ret = convertFromLogic2(vals[0], conv, config2, expectedTypes, meta, not2, fieldConfig, widget, parentField, true);
  } else if (isNot) {
    ret = convertFromLogic2(vals[0], conv, config2, expectedTypes, meta, !not2, fieldConfig, widget, parentField);
  } else if (expectedTypes.includes("val")) {
    ret = convertFieldRhs(op2, vals, conv, config2, not2, meta, parentField) || convertFuncRhs(op2, vals, conv, config2, not2, fieldConfig, meta, parentField) || convertValRhs(logic2, fieldConfig, widget, config2, meta);
  } else {
    if (expectedTypes.includes("switch")) {
      ret = convertIf(op2, vals, conv, config2, not2, meta, parentField);
    }
    if (ret == void 0 && expectedTypes.includes("group")) {
      ret = convertConj(op2, vals, conv, config2, not2, meta, parentField, false);
    }
    if (ret == void 0 && expectedTypes.includes("rule")) {
      ret = convertOp$1(op2, vals, conv, config2, not2, meta, parentField);
    }
    if (ret) {
      if (isRoot && !["group", "switch_group"].includes(ret.type)) {
        ret = wrapInDefaultConj$1(ret, config2);
      }
    }
  }
  var afterErrorsCnt = meta.errors.length;
  if (op2 != "!" && ret === void 0 && afterErrorsCnt == beforeErrorsCnt) {
    meta.errors.push("Can't parse logic ".concat(JSON.stringify(logic2)));
  }
  if (isLocked) {
    ret.properties.isLocked = true;
  }
  return ret;
};
var convertValRhs = function convertValRhs2(val, fieldConfig, widget, config2, meta) {
  var _fieldConfig$fieldSet;
  if (val === void 0) val = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.defaultValue;
  if (val === void 0) return void 0;
  widget = widget || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mainWidget);
  var widgetConfig = config2.widgets[widget];
  var fieldType = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type;
  if (fieldType && !widgetConfig) {
    meta.errors.push("No widget for type ".concat(fieldType));
    return void 0;
  }
  if (isJsonLogic(val)) {
    meta.errors.push("Unexpected logic in value: ".concat(JSON.stringify(val)));
    return void 0;
  }
  if (fieldType === "time" && typeof val === "number") {
    var h = Math.floor(val / 60 / 60) % 24, m = Math.floor(val / 60) % 60, s2 = val % 60;
    var valueFormat = widgetConfig.valueFormat;
    if (valueFormat) {
      var dateVal = new Date(val);
      dateVal.setMilliseconds(0);
      dateVal.setHours(h);
      dateVal.setMinutes(m);
      dateVal.setSeconds(s2);
      val = hooks(dateVal).format(valueFormat);
    } else {
      val = "".concat(h, ":").concat(m, ":").concat(s2);
    }
  }
  if (["date", "datetime"].includes(fieldType) && val && !(val instanceof Date)) {
    try {
      var _dateVal = new Date(val);
      if (_dateVal instanceof Date && _dateVal.toISOString() === val) {
        val = _dateVal;
      }
    } catch (e2) {
      meta.errors.push("Can't convert value ".concat(val, " as Date"));
      val = void 0;
    }
  }
  if (val instanceof Date && fieldConfig) {
    var _valueFormat = widgetConfig.valueFormat;
    if (_valueFormat) {
      val = hooks(val).format(_valueFormat);
    }
  }
  var asyncListValues;
  if (val && fieldConfig !== null && fieldConfig !== void 0 && (_fieldConfig$fieldSet = fieldConfig.fieldSettings) !== null && _fieldConfig$fieldSet !== void 0 && _fieldConfig$fieldSet.asyncFetch) {
    var vals = Array.isArray(val) ? val : [val];
    asyncListValues = vals;
  }
  if (widgetConfig !== null && widgetConfig !== void 0 && widgetConfig.jsonLogicImport) {
    try {
      val = widgetConfig.jsonLogicImport.call(config2.ctx, val);
    } catch (e2) {
      var _e$message;
      meta.errors.push("Can't import value ".concat(val, " using import func of widget ").concat(widget, ": ").concat((_e$message = e2 === null || e2 === void 0 ? void 0 : e2.message) !== null && _e$message !== void 0 ? _e$message : e2));
      val = void 0;
    }
  }
  return {
    valueSrc: "value",
    value: val,
    valueType: widgetConfig === null || widgetConfig === void 0 ? void 0 : widgetConfig.type,
    asyncListValues
  };
};
var convertFieldRhs = function convertFieldRhs2(op2, vals, conv, config2, not2, meta) {
  var parentField = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  if (conv.varKeys.includes(op2) && typeof vals[0] == "string") {
    var _meta$settings;
    var field = normalizeField(config2, vals[0], parentField);
    var fieldConfig = getFieldConfig$8(config2, field);
    if (!fieldConfig && !((_meta$settings = meta.settings) !== null && _meta$settings !== void 0 && _meta$settings.allowUnknownFields)) {
      meta.errors.push("No config for field ".concat(field));
      return void 0;
    }
    return {
      valueSrc: "field",
      value: field,
      valueType: fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type
    };
  }
  return void 0;
};
var convertLhs = function convertLhs2(isGroup0, jlField, args, conv, config2) {
  var not2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
  var fieldConfig = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  var meta = arguments.length > 7 ? arguments[7] : void 0;
  var parentField = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : null;
  var k = Object.keys(jlField)[0];
  var v = Object.values(jlField)[0];
  var _parse = function _parse2(k2, v2) {
    return convertFieldLhs(k2, v2, conv, config2, not2, meta, parentField) || convertFuncLhs(k2, v2, conv, config2, not2, fieldConfig, meta, parentField);
  };
  var beforeErrorsCnt = meta.errors.length;
  var field, fieldSrc, having, isGroup2;
  var parsed = _parse(k, v);
  if (parsed) {
    field = parsed.field;
    fieldSrc = parsed.fieldSrc;
  }
  if (isGroup0) {
    isGroup2 = true;
    having = args[0];
    args = [];
  }
  if (k == "reduce" && Array.isArray(v) && v.length == 3) {
    var _v = v, _v2 = _slicedToArray$1(_v, 3), filter4 = _v2[0], acc = _v2[1], init2 = _v2[2];
    if (isJsonLogic(filter4) && init2 == 0 && isJsonLogic(acc) && Array.isArray(acc["+"]) && acc["+"][0] == 1 && isJsonLogic(acc["+"][1]) && acc["+"][1]["var"] == "accumulator") {
      k = Object.keys(filter4)[0];
      v = Object.values(filter4)[0];
      if (k == "filter") {
        var _v3 = v, _v4 = _slicedToArray$1(_v3, 2), group3 = _v4[0], _filter = _v4[1];
        if (isJsonLogic(group3)) {
          k = Object.keys(group3)[0];
          v = Object.values(group3)[0];
          var parsedGroup = _parse(k, v);
          if (parsedGroup) {
            field = parsedGroup.field;
            fieldSrc = parsedGroup.fieldSrc;
            having = _filter;
            isGroup2 = true;
          }
        }
      } else {
        var _parsedGroup = _parse(k, v);
        if (_parsedGroup) {
          field = _parsedGroup.field;
          fieldSrc = _parsedGroup.fieldSrc;
          isGroup2 = true;
        }
      }
    }
  }
  var afterErrorsCnt = meta.errors.length;
  if (!field && afterErrorsCnt == beforeErrorsCnt) {
    meta.errors.push("Unknown LHS ".concat(JSON.stringify(jlField)));
  }
  if (!field) return;
  return {
    field,
    fieldSrc,
    having,
    isGroup: isGroup2,
    args
  };
};
var convertFieldLhs = function convertFieldLhs2(op2, vals, conv, config2, not2, meta) {
  var parentField = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  if (!Array.isArray(vals)) vals = [vals];
  var parsed = convertFieldRhs(op2, vals, conv, config2, not2, meta, parentField);
  if (parsed) {
    return {
      fieldSrc: "field",
      field: parsed.value
    };
  }
  return void 0;
};
var convertFuncLhs = function convertFuncLhs2(op2, vals, conv, config2, not2) {
  var fieldConfig = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
  var meta = arguments.length > 6 ? arguments[6] : void 0;
  var parentField = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null;
  var parsed = convertFuncRhs(op2, vals, conv, config2, not2, fieldConfig, meta, parentField);
  if (parsed) {
    return {
      fieldSrc: "func",
      field: parsed.value
    };
  }
  return void 0;
};
var convertFuncRhs = function convertFuncRhs2(op2, vals, conv, config2, not2) {
  var fieldConfig = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
  var meta = arguments.length > 6 ? arguments[6] : void 0;
  var parentField = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null;
  if (!op2) return void 0;
  var func, argsArr, funcKey;
  var jsonLogicIsMethod = op2 == "method";
  if (jsonLogicIsMethod) {
    var obj, opts;
    var _vals = _toArray(vals);
    obj = _vals[0];
    func = _vals[1];
    opts = _vals.slice(2);
    argsArr = [obj].concat(_toConsumableArray(opts));
  } else {
    func = op2;
    argsArr = vals;
  }
  var fk = (jsonLogicIsMethod ? "#" : "") + func;
  var returnType = (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.returnType);
  var funcKeys = (conv.funcs[fk] || []).filter(function(k) {
    return fieldConfig ? getFuncConfig$2(config2, k).returnType == returnType : true;
  });
  if (funcKeys.length) {
    funcKey = funcKeys[0];
  } else {
    var v = _defineProperty$4({}, op2, vals);
    var _iterator2 = _createForOfIteratorHelper$d(iterateFuncs(config2)), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var _step2$value = _slicedToArray$1(_step2.value, 2), f = _step2$value[0], fc = _step2$value[1];
        if (fc.jsonLogicImport && (returnType ? fc.returnType == returnType : true)) {
          var parsed = void 0;
          try {
            parsed = fc.jsonLogicImport(v);
          } catch (_e) {
          }
          if (parsed) {
            funcKey = f;
            argsArr = parsed;
          }
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  if (!funcKey) return void 0;
  if (funcKey) {
    var funcConfig = getFuncConfig$2(config2, funcKey);
    var argKeys = Object.keys(funcConfig.args || {});
    var argsObj = argsArr.reduce(function(acc, val, ind) {
      var argKey2 = argKeys[ind];
      var argConfig2 = funcConfig.args[argKey2];
      var argVal2;
      if (argConfig2) {
        argVal2 = convertFromLogic(val, conv, config2, ["val"], meta, false, argConfig2, null, parentField);
      }
      return argVal2 !== void 0 ? _objectSpread$B(_objectSpread$B({}, acc), {}, _defineProperty$4({}, argKey2, argVal2)) : acc;
    }, {});
    for (var argKey in funcConfig.args) {
      var argConfig = funcConfig.args[argKey];
      var argVal = argsObj[argKey];
      if (argVal === void 0) {
        argVal = argConfig === null || argConfig === void 0 ? void 0 : argConfig.defaultValue;
        if (argVal !== void 0) {
          var _argVal;
          argVal = {
            value: argVal,
            valueSrc: (_argVal = argVal) !== null && _argVal !== void 0 && _argVal.func ? "func" : "value",
            valueType: argConfig.type
          };
        }
        if (argVal === void 0) {
          if (argConfig !== null && argConfig !== void 0 && argConfig.isOptional) ;
          else {
            meta.errors.push("No value for arg ".concat(argKey, " of func ").concat(funcKey));
            return void 0;
          }
        } else {
          argsObj[argKey] = argVal;
        }
      }
    }
    return {
      valueSrc: "func",
      value: {
        func: funcKey,
        args: argsObj
      },
      valueType: funcConfig.returnType
    };
  }
  return void 0;
};
var convertConj = function convertConj2(op2, vals, conv, config2, not2, meta) {
  var parentField = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  var conjKey = conv.conjunctions[op2];
  var fieldSeparator = config2.settings.fieldSeparator;
  if (conjKey) {
    var type2 = "group";
    var children = vals.map(function(v) {
      return convertFromLogic(v, conv, config2, ["rule", "group"], meta, false, null, null, parentField);
    }).filter(function(r2) {
      return r2 !== void 0;
    }).reduce(function(acc, r2) {
      return _objectSpread$B(_objectSpread$B({}, acc), {}, _defineProperty$4({}, r2.id, r2));
    }, {});
    var complexFields = Object.values(children).map(function(v) {
      var _v$properties, _v$properties2;
      return (v === null || v === void 0 || (_v$properties = v.properties) === null || _v$properties === void 0 ? void 0 : _v$properties.fieldSrc) == "field" && (v === null || v === void 0 || (_v$properties2 = v.properties) === null || _v$properties2 === void 0 ? void 0 : _v$properties2.field);
    }).filter(function(f) {
      var _f$includes;
      return f === null || f === void 0 || (_f$includes = f.includes) === null || _f$includes === void 0 ? void 0 : _f$includes.call(f, fieldSeparator);
    });
    var complexFieldsGroupAncestors = Object.fromEntries(arrayUniq(complexFields).map(function(f) {
      var parts = f.split(fieldSeparator);
      var ancs = Object.fromEntries(parts.slice(0, -1).map(function(f2, i2, parts2) {
        return [].concat(_toConsumableArray(parts2.slice(0, i2)), [f2]);
      }).map(function(fp) {
        return [fp.join(fieldSeparator), getFieldConfig$8(config2, fp)];
      }).filter(function(_ref) {
        var _ref2 = _slicedToArray$1(_ref, 2);
        _ref2[0];
        var fc = _ref2[1];
        return (fc === null || fc === void 0 ? void 0 : fc.type) == "!group";
      }));
      return [f, Object.keys(ancs)];
    }));
    var properties = {
      conjunction: conjKey,
      not: not2
    };
    var id2 = uuid();
    var children1 = {};
    var groupToId = {};
    Object.entries(children).map(function(_ref3) {
      var _ref4 = _slicedToArray$1(_ref3, 2), k = _ref4[0], v = _ref4[1];
      if ((v === null || v === void 0 ? void 0 : v.type) == "group" || (v === null || v === void 0 ? void 0 : v.type) == "rule_group") {
        children1[k] = v;
      } else {
        var _v$properties3;
        var field = v === null || v === void 0 || (_v$properties3 = v.properties) === null || _v$properties3 === void 0 ? void 0 : _v$properties3.field;
        var groupAncestors = complexFieldsGroupAncestors[field] || [];
        var groupField = groupAncestors[groupAncestors.length - 1];
        if (!groupField) {
          if (v) {
            children1[k] = v;
          }
        } else {
          var ch = children1;
          var parentFieldParts = getFieldParts$3(parentField, config2);
          var groupPath = getFieldParts$3(groupField, config2);
          var isInParent = shallowEqual$4(parentFieldParts, groupPath.slice(0, parentFieldParts.length));
          if (!isInParent) parentFieldParts = [];
          var traverseGroupFields = groupField.split(fieldSeparator).slice(parentFieldParts.length).map(function(f, i2, parts) {
            return [].concat(_toConsumableArray(parentFieldParts), _toConsumableArray(parts.slice(0, i2)), [f]).join(fieldSeparator);
          }).map(function(f) {
            return {
              f,
              fc: getFieldConfig$8(config2, f) || {}
            };
          }).filter(function(_ref5) {
            var fc = _ref5.fc;
            return fc.type != "!struct";
          });
          traverseGroupFields.map(function(_ref6, i2) {
            var gf = _ref6.f, gfc = _ref6.fc;
            var groupId = groupToId[gf];
            if (!groupId) {
              groupId = uuid();
              groupToId[gf] = groupId;
              ch[groupId] = {
                type: "rule_group",
                id: groupId,
                children1: {},
                properties: {
                  conjunction: conjKey,
                  not: false,
                  field: gf,
                  fieldSrc: "field",
                  mode: gfc.mode
                }
              };
            }
            ch = ch[groupId].children1;
          });
          ch[k] = v;
        }
      }
    });
    return {
      type: type2,
      id: id2,
      children1,
      properties
    };
  }
  return void 0;
};
var wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup2(rule3, parentField, parentFieldConfig, config2) {
  var conj = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
  var not2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
  if (!rule3) return void 0;
  return {
    type: "rule_group",
    id: uuid(),
    children1: _defineProperty$4({}, rule3.id, rule3),
    properties: {
      conjunction: conj || defaultGroupConjunction$1(config2, parentFieldConfig),
      not: not2,
      field: parentField
    }
  };
};
var wrapInDefaultConj$1 = function wrapInDefaultConj(rule3, config2) {
  var not2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  return {
    type: "group",
    id: uuid(),
    children1: _defineProperty$4({}, rule3.id, rule3),
    properties: {
      conjunction: defaultConjunction(config2),
      not: not2
    }
  };
};
var parseRule = function parseRule2(op2, arity, vals, parentField, conv, config2, meta) {
  var submeta = createMeta(meta);
  var res = _parseRule(op2, arity, vals, parentField, conv, config2, submeta);
  if (!res) {
    meta.errors.push(submeta.errors.join("; ") || "Unknown op ".concat(op2, "/").concat(arity));
    return void 0;
  }
  return res;
};
var _parseRule = function _parseRule2(op2, arity, vals, parentField, conv, config2, meta) {
  var _meta$settings2;
  var isAllOrSomeInForMultiselect = multiselectOps.map(function(opName) {
    var _config$operators$opN;
    return (_config$operators$opN = config2.operators[opName]) === null || _config$operators$opN === void 0 ? void 0 : _config$operators$opN.jsonLogic2;
  }).includes(op2);
  var isGroup0 = config2.settings.groupOperators.includes(op2) && !isAllOrSomeInForMultiselect;
  var cardinality = isGroup0 ? 0 : arity - 1;
  if (isGroup0) cardinality = 0;
  else if (jlEqOps.includes(op2) && cardinality == 1 && vals[1] === null) {
    arity = 1;
    cardinality = 0;
    vals = [vals[0]];
  }
  var opk = op2 + "/" + cardinality;
  var opKeys = conv.operators[opk];
  if (!opKeys) return;
  var jlField, jlArgs = [];
  if (jlRangeOps.includes(op2) && arity == 3) {
    jlField = vals[1];
    jlArgs = [vals[0], vals[2]];
  } else {
    var _vals2 = vals;
    var _vals3 = _toArray(_vals2);
    jlField = _vals3[0];
    jlArgs = _vals3.slice(1);
  }
  if (!isJsonLogic(jlField)) {
    meta.errors.push("Incorrect operands for ".concat(op2, ": ").concat(JSON.stringify(vals)));
    return;
  }
  var lhs = convertLhs(isGroup0, jlField, jlArgs, conv, config2, null, null, meta, parentField);
  if (!lhs) return;
  var field = lhs.field, fieldSrc = lhs.fieldSrc, having = lhs.having;
  lhs.isGroup;
  var args = lhs.args;
  var fieldConfig = getFieldConfig$8(config2, field);
  if (!fieldConfig && !((_meta$settings2 = meta.settings) !== null && _meta$settings2 !== void 0 && _meta$settings2.allowUnknownFields)) {
    meta.errors.push("No config for LHS ".concat(field));
    return;
  }
  var opKey = opKeys[0];
  if (opKeys.length > 1 && fieldConfig && fieldConfig.operators) {
    opKeys = opKeys.filter(function(k) {
      return fieldConfig.operators.includes(k);
    });
    if (opKeys.length == 0) {
      meta.errors.push("No corresponding ops for LHS ".concat(field));
      return;
    }
    opKey = opKeys[0];
  }
  return {
    field,
    fieldSrc,
    fieldConfig,
    opKey,
    args,
    having
  };
};
var convertOp$1 = function convertOp(op2, vals, conv, config2, not2, meta) {
  var _opConfig;
  var parentField = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  var _isOneRuleInRuleGroup = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
  if (!op2) return void 0;
  var jlConjs = Object.values(config2.conjunctions).map(function(_ref7) {
    var jsonLogicConj = _ref7.jsonLogicConj;
    return jsonLogicConj;
  });
  var arity = vals.length;
  var parseRes = parseRule(op2, arity, vals, parentField, conv, config2, meta);
  if (!parseRes) return void 0;
  var field = parseRes.field, fieldSrc = parseRes.fieldSrc, fieldConfig = parseRes.fieldConfig, opKey = parseRes.opKey, args = parseRes.args, having = parseRes.having;
  var parentFieldConfig = getFieldConfig$8(config2, parentField);
  var opConfig = config2.operators[opKey];
  var reversedOpConfig = config2.operators[(_opConfig = opConfig) === null || _opConfig === void 0 ? void 0 : _opConfig.reversedOp];
  var opNeedsReverse = false;
  var opCanReverse = !!reversedOpConfig;
  var isRuleGroup = fieldConfig.type == "!group";
  var isInRuleGroup = (parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.type) == "!group";
  var canRev = opCanReverse && (!!config2.settings.reverseOperatorsForNot || opNeedsReverse || isRuleGroup && !having || !isRuleGroup && isInRuleGroup && !_isOneRuleInRuleGroup);
  var needRev = not2 && canRev || opNeedsReverse;
  var conj;
  var havingVals;
  var havingNot = false;
  var canRevHaving = !!config2.settings.reverseOperatorsForNot;
  if ((fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) == "!group" && having) {
    conj = Object.keys(having)[0];
    havingVals = having[conj];
    if (!Array.isArray(havingVals)) havingVals = [havingVals];
    var match = matchAgainstTemplates(having, conv, meta);
    while (conj == "!" && !match) {
      var isEmptyOp = conj == "!" && havingVals.length == 1 && havingVals[0] && isJsonLogic(havingVals[0]) && conv.varKeys.includes(Object.keys(havingVals[0])[0]);
      if (isEmptyOp) {
        break;
      }
      havingNot = !havingNot;
      having = having["!"];
      conj = Object.keys(having)[0];
      havingVals = having[conj];
      if (canRevHaving && jlConjs.includes(conj) && havingVals.length == 1) {
        having = having[conj][0];
        conj = Object.keys(having)[0];
        havingVals = having[conj];
      }
      var matchTemp = matchAgainstTemplates(having, conv, meta);
      match = matchTemp ? matchTemp : match;
    }
    if (!Array.isArray(havingVals)) {
      havingVals = [havingVals];
    }
    if (match) {
      havingVals = [];
      havingVals[0] = match.jlField;
      match.jlArgs.forEach(function(arg) {
        return havingVals.push(arg);
      });
      conj = match.newOp;
    }
  }
  if (needRev) {
    not2 = !not2;
    opKey = opConfig.reversedOp;
    opConfig = config2.operators[opKey];
  }
  var widget = getWidgetForFieldOp$3(config2, field, opKey, null);
  var convertedArgs = args.map(function(v) {
    return convertFromLogic(v, conv, config2, ["val"], meta, false, fieldConfig, widget, parentField);
  });
  if (convertedArgs.filter(function(v) {
    return v === void 0;
  }).length) {
    return void 0;
  }
  var res;
  fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type;
  if ((fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) == "!group" && having) {
    if (conv.conjunctions[conj] !== void 0) {
      res = convertConj(conj, havingVals, conv, config2, havingNot, meta, field, true);
    } else {
      res = convertOp(conj, havingVals, conv, config2, havingNot, meta, field, true);
      if (res) {
        var _res$properties;
        if (res.type === "rule_group" && ((_res$properties = res.properties) === null || _res$properties === void 0 ? void 0 : _res$properties.field) !== field) {
          res = wrapInDefaultConjRuleGroup(res, field, fieldConfig, config2);
        }
        Object.assign(res.properties, {
          conjunction: defaultGroupConjunction$1(config2, fieldConfig)
        });
      }
    }
    if (!res) return void 0;
    res.type = "rule_group";
    Object.assign(res.properties, {
      field,
      mode: fieldConfig.mode,
      operator: opKey
    });
    if (fieldConfig.mode == "array") {
      Object.assign(res.properties, {
        value: convertedArgs.map(function(v) {
          return v.value;
        }),
        valueSrc: convertedArgs.map(function(v) {
          return v.valueSrc;
        }),
        valueType: convertedArgs.map(function(v) {
          return v.valueType;
        })
      });
    }
    if (not2) {
      res = wrapInDefaultConj$1(res, config2, not2);
    }
  } else if ((fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) == "!group" && !having) {
    res = {
      type: "rule_group",
      id: uuid(),
      children1: {},
      properties: {
        conjunction: defaultGroupConjunction$1(config2, fieldConfig),
        // tip: `not: true` have no effect if there are no children! "NOT" is hidden in UI and is ignored during export
        // So it's better to reverse group op (see `canRev =`), or wrap in conj with NOT as a last resort
        not: false,
        mode: fieldConfig.mode,
        field,
        operator: opKey
      }
    };
    if (fieldConfig.mode === "array") {
      Object.assign(res.properties, {
        value: convertedArgs.map(function(v) {
          return v.value;
        }),
        valueSrc: convertedArgs.map(function(v) {
          return v.valueSrc;
        }),
        valueType: convertedArgs.map(function(v) {
          return v.valueType;
        })
      });
    }
    if (not2) {
      res = wrapInDefaultConj$1(res, config2, not2);
    }
  } else {
    var asyncListValuesArr = convertedArgs.map(function(v) {
      return v.asyncListValues;
    }).filter(function(v) {
      return v != void 0;
    });
    var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : void 0;
    res = {
      type: "rule",
      id: uuid(),
      properties: _objectSpread$B({
        field,
        fieldSrc,
        operator: opKey,
        value: convertedArgs.map(function(v) {
          return v.value;
        }),
        valueSrc: convertedArgs.map(function(v) {
          return v.valueSrc;
        }),
        valueType: convertedArgs.map(function(v) {
          return v.valueType;
        })
      }, asyncListValues ? {
        asyncListValues
      } : {})
    };
    if (not2 || _isOneRuleInRuleGroup) {
      res = wrapInDefaultConj$1(res, config2, not2);
    }
  }
  return res;
};
var convertIf = function convertIf2(op2, vals, conv, config2, not2, meta) {
  var parentField = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  if ((op2 === null || op2 === void 0 ? void 0 : op2.toLowerCase()) !== "if") return void 0;
  var flat = flatizeTernary$1(vals);
  var cases = flat.map(function(_ref8) {
    var _ref9 = _slicedToArray$1(_ref8, 2), cond = _ref9[0], val = _ref9[1];
    return [cond ? convertFromLogic(cond, conv, config2, ["rule", "group"], meta, false, null, null, parentField) : null, buildCaseValProperties$1(config2, meta, conv, val)];
  });
  var children1 = cases.map(function(_ref10) {
    var _ref11 = _slicedToArray$1(_ref10, 2), cond = _ref11[0], val = _ref11[1];
    return wrapInCase(cond, val, config2, meta);
  });
  var switchI = {
    type: "switch_group",
    id: uuid(),
    children1,
    properties: {}
  };
  return switchI;
};
var flatizeTernary$1 = function flatizeTernary(children) {
  var flat = [];
  function _processTernaryChildren(tern) {
    var _tern = _slicedToArray$1(tern, 3), cond = _tern[0], if_val = _tern[1], else_val = _tern[2];
    flat.push([cond, if_val]);
    var else_op = isJsonLogic(else_val) ? Object.keys(else_val)[0] : null;
    if ((else_op === null || else_op === void 0 ? void 0 : else_op.toLowerCase()) === "if") {
      _processTernaryChildren(else_val[else_op]);
    } else {
      flat.push([void 0, else_val]);
    }
  }
  _processTernaryChildren(children);
  return flat;
};
var wrapInCase = function wrapInCase2(cond, valProperties, config2, meta) {
  var caseI;
  if (cond) {
    caseI = _objectSpread$B({}, cond);
    if (caseI.type) {
      if (caseI.type != "group") {
        caseI = wrapInDefaultConj$1(caseI, config2);
      }
      caseI.type = "case_group";
    } else {
      meta.errors.push("Unexpected case: ".concat(JSON.stringify(caseI)));
      caseI = void 0;
    }
  } else {
    caseI = {
      id: uuid(),
      type: "case_group",
      properties: {}
    };
  }
  if (caseI) {
    caseI.properties = _objectSpread$B(_objectSpread$B({}, caseI.properties), valProperties);
  }
  return caseI;
};
var buildCaseValProperties$1 = function buildCaseValProperties(config2, meta, conv, val) {
  var caseValueFieldConfig = getFieldConfig$8(config2, "!case_value");
  if (!caseValueFieldConfig) {
    meta.errors.push("Missing caseValueField in settings");
    return void 0;
  }
  var widget = caseValueFieldConfig.mainWidget;
  var widgetDef = config2.widgets[widget];
  if (!widgetDef) {
    meta.errors.push("No widget ".concat(widget, " for case value"));
    return void 0;
  }
  var convVal = convertFromLogic(val, conv, config2, ["val", "case_val"], meta, false, caseValueFieldConfig, widget);
  if (convVal == void 0) {
    return void 0;
  }
  var value = convVal.value, valueSrc = convVal.valueSrc, valueType = convVal.valueType;
  var valProperties = {
    value: [value],
    valueSrc: [valueSrc !== null && valueSrc !== void 0 ? valueSrc : "value"],
    valueType: [valueType !== null && valueType !== void 0 ? valueType : widgetDef === null || widgetDef === void 0 ? void 0 : widgetDef.type],
    field: "!case_value"
  };
  return valProperties;
};
var spel2js = { exports: {} };
(function(module2, exports2) {
  (function webpackUniversalModuleDefinition(root2, factory26) {
    module2.exports = factory26();
  })(commonjsGlobal, function() {
    return (
      /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module3 = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.l = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports3, name2, getter) {
          if (!__webpack_require__.o(exports3, name2)) {
            Object.defineProperty(exports3, name2, {
              /******/
              configurable: false,
              /******/
              enumerable: true,
              /******/
              get: getter
              /******/
            });
          }
        };
        __webpack_require__.n = function(module3) {
          var getter = module3 && module3.__esModule ? (
            /******/
            function getDefault() {
              return module3["default"];
            }
          ) : (
            /******/
            function getModuleExports() {
              return module3;
            }
          );
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property2) {
          return Object.prototype.hasOwnProperty.call(object, property2);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 3);
      }([
        /* 0 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          function createSpelNode(nodeType, position) {
            var node = {}, type2 = nodeType || "Abstract", children = [], parent2 = null, activeContext;
            node._type = type2;
            node.getType = function() {
              return type2;
            };
            node.setType = function(nodeType2) {
              type2 = nodeType2;
            };
            node.getChildren = function() {
              return children;
            };
            node.addChild = function(childNode) {
              if (!childNode) {
                return;
              }
              if (!childNode.setParent) {
                throw {
                  name: "Error",
                  message: "Trying to add a child which is not a node: " + JSON.stringify(childNode)
                };
              }
              childNode.setParent(node);
              children.push(childNode);
            };
            node.getParent = function() {
              return parent2;
            };
            node.setParent = function(parentNode) {
              parent2 = parentNode;
            };
            node.getContext = function(state) {
              return activeContext || state.activeContext.peek();
            };
            node.setContext = function(nodeContext) {
              activeContext = nodeContext;
            };
            node.getStartPosition = function() {
              return position >> 16;
            };
            node.getEndPosition = function() {
              return position & 65535;
            };
            node.getValue = function() {
              throw {
                name: "MethodNotImplementedException",
                message: "SpelNode#getValue() must be overridden."
              };
            };
            node.toString = function() {
              var s2 = "Kind: " + node.getType();
              s2 += ", Children: [";
              for (var i2 = 0, l = node.getChildren().length; i2 < l; i2 += 1) {
                s2 += "{" + node.getChildren()[i2] + "}, ";
              }
              s2 += "]";
              return s2;
            };
            if (position === 0) {
              throw {
                name: "Error",
                message: "Position cannot be 0"
              };
            }
            for (var _len = arguments.length, operands = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              operands[_key - 2] = arguments[_key];
            }
            if (operands) {
              operands.forEach(function(operand) {
                node.addChild(operand);
              });
            }
            return node;
          }
          exports3.SpelNode = {
            create: createSpelNode
          };
        },
        /* 1 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Stack = Stack2;
          function Stack2(startingElements) {
            this.elements = startingElements || [];
          }
          Stack2.prototype.push = function(el) {
            this.elements.push(el);
            return el;
          };
          Stack2.prototype.pop = function() {
            return this.elements.pop();
          };
          Stack2.prototype.peek = function() {
            return this.elements[this.elements.length - 1];
          };
          Stack2.prototype.empty = function() {
            return this.elements.length > 0;
          };
          Stack2.prototype.search = function(el) {
            return this.elements.length - this.elements.indexOf(el);
          };
        },
        /* 2 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var types2 = {
            LITERAL_INT: 1,
            //tested
            LITERAL_LONG: 2,
            //tested
            LITERAL_HEXINT: 3,
            //tested
            LITERAL_HEXLONG: 4,
            //tested
            LITERAL_STRING: 5,
            //tested
            LITERAL_REAL: 6,
            //tested
            LITERAL_REAL_FLOAT: 7,
            //tested
            LPAREN: "(",
            //tested
            RPAREN: ")",
            //tested
            COMMA: ",",
            //tested
            IDENTIFIER: 0,
            //tested
            COLON: ":",
            //tested
            HASH: "#",
            //tested
            RSQUARE: "]",
            //tested
            LSQUARE: "[",
            //tested
            LCURLY: "{",
            //tested
            RCURLY: "}",
            //tested
            DOT: ".",
            //tested
            PLUS: "+",
            //tested
            STAR: "*",
            //tested
            MINUS: "-",
            //tested
            SELECT_FIRST: "^[",
            //tested
            SELECT_LAST: "$[",
            //tested
            QMARK: "?",
            //tested
            PROJECT: "![",
            //tested
            DIV: "/",
            //tested
            GE: ">=",
            //tested
            GT: ">",
            //tested
            LE: "<=",
            //tested
            LT: "<",
            //tested
            EQ: "==",
            //tested
            NE: "!=",
            //tested
            MOD: "%",
            //tested
            NOT: "!",
            //tested
            ASSIGN: "=",
            //tested
            INSTANCEOF: "instanceof",
            //test fails
            MATCHES: "matches",
            //test fails
            BETWEEN: "between",
            //test fails
            SELECT: "?[",
            //tested
            POWER: "^",
            //tested
            ELVIS: "?:",
            //tested
            SAFE_NAVI: "?.",
            //tested
            BEAN_REF: "@",
            //tested
            SYMBOLIC_OR: "||",
            //tested
            SYMBOLIC_AND: "&&",
            //tested
            INC: "++",
            //tested
            DEC: "--"
            //tested
          };
          function TokenKind(type2) {
            this.type = type2;
            this.tokenChars = types2[type2];
            this._hasPayload = typeof types2[type2] !== "string";
            if (typeof types2[type2] === "number") {
              this._ordinal = types2[type2];
            }
          }
          for (var t2 in types2) {
            if (types2.hasOwnProperty(t2)) {
              TokenKind[t2] = new TokenKind(t2);
            }
          }
          TokenKind.prototype.toString = function() {
            return this.type + (this.tokenChars.length !== 0 ? "(" + this.tokenChars + ")" : "");
          };
          TokenKind.prototype.getLength = function() {
            return this.tokenChars.length;
          };
          TokenKind.prototype.hasPayload = function() {
            return this._hasPayload;
          };
          TokenKind.prototype.valueOf = function(id2) {
            for (var t3 in types2) {
              if (types2.hasOwnProperty(t3) && types2[t3] === id2) {
                return TokenKind[t3];
              }
            }
          };
          TokenKind.prototype.ordinal = function() {
            return this._ordinal;
          };
          exports3.TokenKind = TokenKind;
        },
        /* 3 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.StandardContext = exports3.SpelExpressionEvaluator = void 0;
          var _SpelExpressionEvaluator = __webpack_require__(4);
          var _StandardContext = __webpack_require__(50);
          exports3.SpelExpressionEvaluator = _SpelExpressionEvaluator.SpelExpressionEvaluator;
          exports3.StandardContext = _StandardContext.StandardContext;
        },
        /* 4 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.SpelExpressionEvaluator = void 0;
          var _SpelExpressionParser = __webpack_require__(5);
          var _Stack2 = __webpack_require__(1);
          var spelExpressionEvaluator = {};
          function evalCompiled(compiledExpression, context2, locals) {
            var activeContext = new _Stack2.Stack(), state;
            if (!context2) {
              context2 = {};
            }
            activeContext.push(context2);
            state = {
              rootContext: context2,
              activeContext,
              locals
            };
            return compiledExpression.getValue(state);
          }
          spelExpressionEvaluator.compile = function(expression) {
            var compiledExpression = (0, _SpelExpressionParser.SpelExpressionParser)().parse(expression);
            return {
              eval: function _eval2(context2, locals) {
                return evalCompiled(compiledExpression, context2, locals);
              },
              _compiledExpression: compiledExpression
            };
          };
          spelExpressionEvaluator.eval = function(expression, context2, locals) {
            return spelExpressionEvaluator.compile(expression).eval(context2, locals);
          };
          exports3.SpelExpressionEvaluator = spelExpressionEvaluator;
        },
        /* 5 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.SpelExpressionParser = void 0;
          var _TokenKind = __webpack_require__(2);
          var _Tokenizer = __webpack_require__(6);
          var _BooleanLiteral = __webpack_require__(8);
          var _NumberLiteral = __webpack_require__(9);
          var _StringLiteral = __webpack_require__(10);
          var _NullLiteral = __webpack_require__(11);
          var _FunctionReference = __webpack_require__(12);
          var _MethodReference = __webpack_require__(13);
          var _PropertyReference = __webpack_require__(14);
          var _VariableReference = __webpack_require__(15);
          var _CompoundExpression = __webpack_require__(16);
          var _Indexer = __webpack_require__(17);
          var _Assign = __webpack_require__(18);
          var _OpEQ = __webpack_require__(19);
          var _OpNE = __webpack_require__(20);
          var _OpGE = __webpack_require__(21);
          var _OpGT = __webpack_require__(22);
          var _OpLE = __webpack_require__(23);
          var _OpLT = __webpack_require__(24);
          var _OpPlus = __webpack_require__(25);
          var _OpMinus = __webpack_require__(26);
          var _OpMultiply = __webpack_require__(27);
          var _OpDivide = __webpack_require__(28);
          var _OpModulus = __webpack_require__(29);
          var _OpPower = __webpack_require__(30);
          var _OpInc = __webpack_require__(31);
          var _OpDec = __webpack_require__(32);
          var _OpNot = __webpack_require__(33);
          var _OpAnd = __webpack_require__(34);
          var _OpOr = __webpack_require__(35);
          var _OpMatches = __webpack_require__(36);
          var _Ternary = __webpack_require__(37);
          var _Elvis = __webpack_require__(38);
          var _InlineList = __webpack_require__(39);
          var _InlineMap = __webpack_require__(40);
          var _Selection = __webpack_require__(41);
          var _Projection = __webpack_require__(42);
          var _OpInstanceof = __webpack_require__(43);
          var _OpBetween = __webpack_require__(44);
          var _TypeReference = __webpack_require__(45);
          var _BeanReference = __webpack_require__(46);
          var _Identifier = __webpack_require__(47);
          var _QualifiedIdentifier = __webpack_require__(48);
          var _ConstructorReference = __webpack_require__(49);
          exports3.SpelExpressionParser = function SpelExpressionParser() {
            var VALID_QUALIFIED_ID_PATTERN = new RegExp("[\\p{L}\\p{N}_$]+");
            var constructedNodes = [];
            var expressionString;
            var tokenStream;
            var tokenStreamLength;
            var tokenStreamPointer;
            function setConfiguration(config2) {
            }
            function parse(expression, context2) {
              try {
                expressionString = expression;
                tokenStream = _Tokenizer.Tokenizer.tokenize(expression);
                tokenStreamLength = tokenStream.length;
                tokenStreamPointer = 0;
                constructedNodes = [];
                var ast = eatExpression();
                if (moreTokens()) {
                  raiseInternalException(peekToken().startPos, "MORE_INPUT", nextToken().toString());
                }
                return ast;
              } catch (e2) {
                throw e2.message;
              }
            }
            function eatExpression() {
              var expr = eatLogicalOrExpression();
              if (moreTokens()) {
                var token2 = peekToken();
                if (token2.getKind() === _TokenKind.TokenKind.ASSIGN) {
                  if (expr === null) {
                    expr = _NullLiteral.NullLiteral.create(toPosBounds(token2.startPos - 1, token2.endPos - 1));
                  }
                  nextToken();
                  var assignedValue = eatLogicalOrExpression();
                  return _Assign.Assign.create(toPosToken(token2), expr, assignedValue);
                }
                if (token2.getKind() === _TokenKind.TokenKind.ELVIS) {
                  if (expr === null) {
                    expr = _NullLiteral.NullLiteral.create(toPosBounds(token2.startPos - 1, token2.endPos - 2));
                  }
                  nextToken();
                  var valueIfNull = eatExpression();
                  if (valueIfNull === null) {
                    valueIfNull = _NullLiteral.NullLiteral.create(toPosBounds(token2.startPos + 1, token2.endPos + 1));
                  }
                  return _Elvis.Elvis.create(toPosToken(token2), expr, valueIfNull);
                }
                if (token2.getKind() === _TokenKind.TokenKind.QMARK) {
                  if (expr === null) {
                    expr = _NullLiteral.NullLiteral.create(toPosBounds(token2.startPos - 1, token2.endPos - 1));
                  }
                  nextToken();
                  var ifTrueExprValue = eatExpression();
                  eatToken(_TokenKind.TokenKind.COLON);
                  var ifFalseExprValue = eatExpression();
                  return _Ternary.Ternary.create(toPosToken(token2), expr, ifTrueExprValue, ifFalseExprValue);
                }
              }
              return expr;
            }
            function eatLogicalOrExpression() {
              var expr = eatLogicalAndExpression();
              while (peekIdentifierToken("or") || peekTokenOne(_TokenKind.TokenKind.SYMBOLIC_OR)) {
                var token2 = nextToken();
                var rhExpr = eatLogicalAndExpression();
                checkOperands(token2, expr, rhExpr);
                expr = _OpOr.OpOr.create(toPosToken(token2), expr, rhExpr);
              }
              return expr;
            }
            function eatLogicalAndExpression() {
              var expr = eatRelationalExpression();
              while (peekIdentifierToken("and") || peekTokenOne(_TokenKind.TokenKind.SYMBOLIC_AND)) {
                var token2 = nextToken();
                var rhExpr = eatRelationalExpression();
                checkOperands(token2, expr, rhExpr);
                expr = _OpAnd.OpAnd.create(toPosToken(token2), expr, rhExpr);
              }
              return expr;
            }
            function eatRelationalExpression() {
              var expr = eatSumExpression();
              var relationalOperatorToken = maybeEatRelationalOperator();
              if (relationalOperatorToken !== null) {
                var token2 = nextToken();
                var rhExpr = eatSumExpression();
                checkOperands(token2, expr, rhExpr);
                var tk = relationalOperatorToken.kind;
                if (relationalOperatorToken.isNumericRelationalOperator()) {
                  var pos = toPosToken(token2);
                  if (tk === _TokenKind.TokenKind.GT) {
                    return _OpGT.OpGT.create(pos, expr, rhExpr);
                  }
                  if (tk === _TokenKind.TokenKind.LT) {
                    return _OpLT.OpLT.create(pos, expr, rhExpr);
                  }
                  if (tk === _TokenKind.TokenKind.LE) {
                    return _OpLE.OpLE.create(pos, expr, rhExpr);
                  }
                  if (tk === _TokenKind.TokenKind.GE) {
                    return _OpGE.OpGE.create(pos, expr, rhExpr);
                  }
                  if (tk === _TokenKind.TokenKind.EQ) {
                    return _OpEQ.OpEQ.create(pos, expr, rhExpr);
                  }
                  return _OpNE.OpNE.create(pos, expr, rhExpr);
                }
                if (tk === _TokenKind.TokenKind.INSTANCEOF) {
                  return _OpInstanceof.OpInstanceof.create(toPosToken(token2), expr, rhExpr);
                }
                if (tk === _TokenKind.TokenKind.MATCHES) {
                  return _OpMatches.OpMatches.create(toPosToken(token2), expr, rhExpr);
                }
                return _OpBetween.OpBetween.create(toPosToken(token2), expr, rhExpr);
              }
              return expr;
            }
            function eatSumExpression() {
              var expr = eatProductExpression();
              while (peekTokenAny(_TokenKind.TokenKind.PLUS, _TokenKind.TokenKind.MINUS, _TokenKind.TokenKind.INC)) {
                var token2 = nextToken();
                var rhExpr = eatProductExpression();
                checkRightOperand(token2, rhExpr);
                if (token2.getKind() === _TokenKind.TokenKind.PLUS) {
                  expr = _OpPlus.OpPlus.create(toPosToken(token2), expr, rhExpr);
                } else if (token2.getKind() === _TokenKind.TokenKind.MINUS) {
                  expr = _OpMinus.OpMinus.create(toPosToken(token2), expr, rhExpr);
                }
              }
              return expr;
            }
            function eatProductExpression() {
              var expr = eatPowerIncDecExpression();
              while (peekTokenAny(_TokenKind.TokenKind.STAR, _TokenKind.TokenKind.DIV, _TokenKind.TokenKind.MOD)) {
                var token2 = nextToken();
                var rhExpr = eatPowerIncDecExpression();
                checkOperands(token2, expr, rhExpr);
                if (token2.getKind() === _TokenKind.TokenKind.STAR) {
                  expr = _OpMultiply.OpMultiply.create(toPosToken(token2), expr, rhExpr);
                } else if (token2.getKind() === _TokenKind.TokenKind.DIV) {
                  expr = _OpDivide.OpDivide.create(toPosToken(token2), expr, rhExpr);
                } else {
                  expr = _OpModulus.OpModulus.create(toPosToken(token2), expr, rhExpr);
                }
              }
              return expr;
            }
            function eatPowerIncDecExpression() {
              var expr = eatUnaryExpression(), token2;
              if (peekTokenOne(_TokenKind.TokenKind.POWER)) {
                token2 = nextToken();
                var rhExpr = eatUnaryExpression();
                checkRightOperand(token2, rhExpr);
                return _OpPower.OpPower.create(toPosToken(token2), expr, rhExpr);
              }
              if (expr !== null && peekTokenAny(_TokenKind.TokenKind.INC, _TokenKind.TokenKind.DEC)) {
                token2 = nextToken();
                if (token2.getKind() === _TokenKind.TokenKind.INC) {
                  return _OpInc.OpInc.create(toPosToken(token2), true, expr);
                }
                return _OpDec.OpDec.create(toPosToken(token2), true, expr);
              }
              return expr;
            }
            function eatUnaryExpression() {
              var token2, expr;
              if (peekTokenAny(_TokenKind.TokenKind.PLUS, _TokenKind.TokenKind.MINUS, _TokenKind.TokenKind.NOT)) {
                token2 = nextToken();
                expr = eatUnaryExpression();
                if (token2.getKind() === _TokenKind.TokenKind.NOT) {
                  return _OpNot.OpNot.create(toPosToken(token2), expr);
                }
                if (token2.getKind() === _TokenKind.TokenKind.PLUS) {
                  return _OpPlus.OpPlus.create(toPosToken(token2), expr);
                }
                return _OpMinus.OpMinus.create(toPosToken(token2), expr);
              }
              if (peekTokenAny(_TokenKind.TokenKind.INC, _TokenKind.TokenKind.DEC)) {
                token2 = nextToken();
                expr = eatUnaryExpression();
                if (token2.getKind() === _TokenKind.TokenKind.INC) {
                  return _OpInc.OpInc.create(toPosToken(token2), false, expr);
                }
                return _OpDec.OpDec.create(toPosToken(token2), false, expr);
              }
              return eatPrimaryExpression();
            }
            function eatPrimaryExpression() {
              var nodes = [];
              var start = eatStartNode();
              nodes.push(start);
              while (maybeEatNode()) {
                nodes.push(pop());
              }
              if (nodes.length === 1) {
                return nodes[0];
              }
              return _CompoundExpression.CompoundExpression.create(toPosBounds(start.getStartPosition(), nodes[nodes.length - 1].getEndPosition()), nodes);
            }
            function maybeEatNode() {
              var expr = null;
              if (peekTokenAny(_TokenKind.TokenKind.DOT, _TokenKind.TokenKind.SAFE_NAVI)) {
                expr = eatDottedNode();
              } else {
                expr = maybeEatNonDottedNode();
              }
              if (expr === null) {
                return false;
              } else {
                push(expr);
                return true;
              }
            }
            function maybeEatNonDottedNode() {
              if (peekTokenOne(_TokenKind.TokenKind.LSQUARE)) {
                if (maybeEatIndexer()) {
                  return pop();
                }
              }
              return null;
            }
            function eatDottedNode() {
              var token2 = nextToken();
              var nullSafeNavigation = token2.getKind() === _TokenKind.TokenKind.SAFE_NAVI;
              if (maybeEatMethodOrProperty(nullSafeNavigation) || maybeEatFunctionOrVar() || maybeEatProjection(nullSafeNavigation) || maybeEatSelection(nullSafeNavigation)) {
                return pop();
              }
              if (peekToken() === null) {
                raiseInternalException(token2.startPos, "OOD");
              } else {
                raiseInternalException(token2.startPos, "UNEXPECTED_DATA_AFTER_DOT", toString6(peekToken()));
              }
              return null;
            }
            function maybeEatFunctionOrVar() {
              if (!peekTokenOne(_TokenKind.TokenKind.HASH)) {
                return false;
              }
              var token2 = nextToken();
              var functionOrVariableName = eatToken(_TokenKind.TokenKind.IDENTIFIER);
              var args = maybeEatMethodArgs();
              if (args === null) {
                push(_VariableReference.VariableReference.create(functionOrVariableName.data, toPosBounds(token2.startPos, functionOrVariableName.endPos)));
                return true;
              }
              push(_FunctionReference.FunctionReference.create(functionOrVariableName.data, toPosBounds(token2.startPos, functionOrVariableName.endPos), args));
              return true;
            }
            function maybeEatMethodArgs() {
              if (!peekTokenOne(_TokenKind.TokenKind.LPAREN)) {
                return null;
              }
              var args = [];
              consumeArguments(args);
              eatToken(_TokenKind.TokenKind.RPAREN);
              return args;
            }
            function eatConstructorArgs(accumulatedArguments) {
              if (!peekTokenOne(_TokenKind.TokenKind.LPAREN)) {
                raiseInternalException(toPosToken(peekToken()), "MISSING_CONSTRUCTOR_ARGS");
              }
              consumeArguments(accumulatedArguments);
              eatToken(_TokenKind.TokenKind.RPAREN);
            }
            function consumeArguments(accumulatedArguments) {
              var pos = peekToken().startPos;
              var next;
              do {
                nextToken();
                var token2 = peekToken();
                if (token2 === null) {
                  raiseInternalException(pos, "RUN_OUT_OF_ARGUMENTS");
                }
                if (token2.getKind() !== _TokenKind.TokenKind.RPAREN) {
                  accumulatedArguments.push(eatExpression());
                }
                next = peekToken();
              } while (next !== null && next.kind === _TokenKind.TokenKind.COMMA);
              if (next === null) {
                raiseInternalException(pos, "RUN_OUT_OF_ARGUMENTS");
              }
            }
            function eatStartNode() {
              if (maybeEatLiteral()) {
                return pop();
              } else if (maybeEatParenExpression()) {
                return pop();
              } else if (maybeEatTypeReference() || maybeEatNullReference() || maybeEatConstructorReference() || maybeEatMethodOrProperty(false) || maybeEatFunctionOrVar()) {
                return pop();
              } else if (maybeEatBeanReference()) {
                return pop();
              } else if (maybeEatProjection(false) || maybeEatSelection(false) || maybeEatIndexer()) {
                return pop();
              } else if (maybeEatInlineListOrMap()) {
                return pop();
              } else {
                return null;
              }
            }
            function maybeEatBeanReference() {
              if (peekTokenOne(_TokenKind.TokenKind.BEAN_REF)) {
                var beanRefToken = nextToken();
                var beanNameToken = null;
                var beanName = null;
                if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                  beanNameToken = eatToken(_TokenKind.TokenKind.IDENTIFIER);
                  beanName = beanNameToken.data;
                } else if (peekTokenOne(_TokenKind.TokenKind.LITERAL_STRING)) {
                  beanNameToken = eatToken(_TokenKind.TokenKind.LITERAL_STRING);
                  beanName = beanNameToken.stringValue();
                  beanName = beanName.substring(1, beanName.length() - 1);
                } else {
                  raiseInternalException(beanRefToken.startPos, "INVALID_BEAN_REFERENCE");
                }
                var beanReference = _BeanReference.BeanReference.create(toPosToken(beanNameToken), beanName);
                push(beanReference);
                return true;
              }
              return false;
            }
            function maybeEatTypeReference() {
              if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                var typeName = peekToken();
                if (typeName.stringValue() !== "T") {
                  return false;
                }
                var token2 = nextToken();
                if (peekTokenOne(_TokenKind.TokenKind.RSQUARE)) {
                  push(_PropertyReference.PropertyReference.create(token2.stringValue(), toPosToken(token2)));
                  return true;
                }
                eatToken(_TokenKind.TokenKind.LPAREN);
                var node = eatPossiblyQualifiedId();
                var dims = 0;
                while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.LSQUARE, true)) {
                  eatToken(_TokenKind.TokenKind.RSQUARE);
                  dims++;
                }
                eatToken(_TokenKind.TokenKind.RPAREN);
                push(_TypeReference.TypeReference.create(toPosToken(typeName), node, dims));
                return true;
              }
              return false;
            }
            function maybeEatNullReference() {
              if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                var nullToken = peekToken();
                if (nullToken.stringValue().toLowerCase() !== "null") {
                  return false;
                }
                nextToken();
                push(_NullLiteral.NullLiteral.create(toPosToken(nullToken)));
                return true;
              }
              return false;
            }
            function maybeEatProjection(nullSafeNavigation) {
              var token2 = peekToken();
              if (!peekTokenConsumeIfMatched(_TokenKind.TokenKind.PROJECT, true)) {
                return false;
              }
              var expr = eatExpression();
              eatToken(_TokenKind.TokenKind.RSQUARE);
              push(_Projection.Projection.create(nullSafeNavigation, toPosToken(token2), expr));
              return true;
            }
            function maybeEatInlineListOrMap() {
              var token2 = peekToken(), listElements = [];
              if (!peekTokenConsumeIfMatched(_TokenKind.TokenKind.LCURLY, true)) {
                return false;
              }
              var expr = null;
              var closingCurly = peekToken();
              if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.RCURLY, true)) {
                expr = _InlineList.InlineList.create(toPosBounds(token2.startPos, closingCurly.endPos));
              } else if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COLON, true)) {
                closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                expr = _InlineMap.InlineMap.create(toPosBounds(token2.startPos, closingCurly.endPos));
              } else {
                var firstExpression = eatExpression();
                if (peekTokenOne(_TokenKind.TokenKind.RCURLY)) {
                  listElements.push(firstExpression);
                  closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                  expr = _InlineList.InlineList.create(toPosBounds(token2.startPos, closingCurly.endPos), listElements);
                } else if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COMMA, true)) {
                  listElements.push(firstExpression);
                  do {
                    listElements.push(eatExpression());
                  } while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COMMA, true));
                  closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                  expr = _InlineList.InlineList.create(toPosToken(token2.startPos, closingCurly.endPos), listElements);
                } else if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COLON, true)) {
                  var mapElements = [];
                  mapElements.push(firstExpression);
                  mapElements.push(eatExpression());
                  while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COMMA, true)) {
                    mapElements.push(eatExpression());
                    eatToken(_TokenKind.TokenKind.COLON);
                    mapElements.push(eatExpression());
                  }
                  closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                  expr = _InlineMap.InlineMap.create(toPosBounds(token2.startPos, closingCurly.endPos), mapElements);
                } else {
                  raiseInternalException(token2.startPos, "OOD");
                }
              }
              push(expr);
              return true;
            }
            function maybeEatIndexer() {
              var token2 = peekToken();
              if (!peekTokenConsumeIfMatched(_TokenKind.TokenKind.LSQUARE, true)) {
                return false;
              }
              var expr = eatExpression();
              eatToken(_TokenKind.TokenKind.RSQUARE);
              push(_Indexer.Indexer.create(toPosToken(token2), expr));
              return true;
            }
            function maybeEatSelection(nullSafeNavigation) {
              var token2 = peekToken();
              if (!peekSelectToken()) {
                return false;
              }
              nextToken();
              var expr = eatExpression();
              if (expr === null) {
                raiseInternalException(toPosToken(token2), "MISSING_SELECTION_EXPRESSION");
              }
              eatToken(_TokenKind.TokenKind.RSQUARE);
              if (token2.getKind() === _TokenKind.TokenKind.SELECT_FIRST) {
                push(_Selection.Selection.create(nullSafeNavigation, _Selection.Selection.FIRST, toPosToken(token2), expr));
              } else if (token2.getKind() === _TokenKind.TokenKind.SELECT_LAST) {
                push(_Selection.Selection.create(nullSafeNavigation, _Selection.Selection.LAST, toPosToken(token2), expr));
              } else {
                push(_Selection.Selection.create(nullSafeNavigation, _Selection.Selection.ALL, toPosToken(token2), expr));
              }
              return true;
            }
            function eatPossiblyQualifiedId() {
              var qualifiedIdPieces = [];
              var node = peekToken();
              while (isValidQualifiedId(node)) {
                nextToken();
                if (node.kind !== _TokenKind.TokenKind.DOT) {
                  qualifiedIdPieces.push(_Identifier.Identifier.create(node.stringValue(), toPosToken(node)));
                }
                node = peekToken();
              }
              if (!qualifiedIdPieces.length) {
                if (node === null) {
                  raiseInternalException(expressionString.length(), "OOD");
                }
                raiseInternalException(node.startPos, "NOT_EXPECTED_TOKEN", "qualified ID", node.getKind().toString().toLowerCase());
              }
              var pos = toPosBounds(qualifiedIdPieces[0].getStartPosition(), qualifiedIdPieces[qualifiedIdPieces.length - 1].getEndPosition());
              return _QualifiedIdentifier.QualifiedIdentifier.create(pos, qualifiedIdPieces);
            }
            function isValidQualifiedId(node) {
              if (node === null || node.kind === _TokenKind.TokenKind.LITERAL_STRING) {
                return false;
              }
              if (node.kind === _TokenKind.TokenKind.DOT || node.kind === _TokenKind.TokenKind.IDENTIFIER) {
                return true;
              }
              var value = node.stringValue();
              return value && value.length && VALID_QUALIFIED_ID_PATTERN.test(value);
            }
            function maybeEatMethodOrProperty(nullSafeNavigation) {
              if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                var methodOrPropertyName = nextToken();
                var args = maybeEatMethodArgs();
                if (args === null) {
                  push(_PropertyReference.PropertyReference.create(nullSafeNavigation, methodOrPropertyName.stringValue(), toPosToken(methodOrPropertyName)));
                  return true;
                }
                push(_MethodReference.MethodReference.create(nullSafeNavigation, methodOrPropertyName.stringValue(), toPosToken(methodOrPropertyName), args));
                return true;
              }
              return false;
            }
            function maybeEatConstructorReference() {
              if (peekIdentifierToken("new")) {
                var newToken = nextToken();
                if (peekTokenOne(_TokenKind.TokenKind.RSQUARE)) {
                  push(_PropertyReference.PropertyReference.create(newToken.stringValue(), toPosToken(newToken)));
                  return true;
                }
                var possiblyQualifiedConstructorName = eatPossiblyQualifiedId();
                var nodes = [];
                nodes.push(possiblyQualifiedConstructorName);
                if (peekTokenOne(_TokenKind.TokenKind.LSQUARE)) {
                  var dimensions = [];
                  while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.LSQUARE, true)) {
                    if (!peekTokenOne(_TokenKind.TokenKind.RSQUARE)) {
                      dimensions.push(eatExpression());
                    } else {
                      dimensions.push(null);
                    }
                    eatToken(_TokenKind.TokenKind.RSQUARE);
                  }
                  if (maybeEatInlineListOrMap()) {
                    nodes.push(pop());
                  }
                  push(_ConstructorReference.ConstructorReference.create(toPosToken(newToken), dimensions, nodes));
                } else {
                  eatConstructorArgs(nodes);
                  push(_ConstructorReference.ConstructorReference.create(toPosToken(newToken), nodes));
                }
                return true;
              }
              return false;
            }
            function push(newNode) {
              constructedNodes.push(newNode);
            }
            function pop() {
              return constructedNodes.pop();
            }
            function maybeEatLiteral() {
              var token2 = peekToken();
              if (token2 === null) {
                return false;
              }
              if (token2.getKind() === _TokenKind.TokenKind.LITERAL_INT || token2.getKind() === _TokenKind.TokenKind.LITERAL_LONG) {
                push(_NumberLiteral.NumberLiteral.create(parseInt(token2.stringValue(), 10), toPosToken(token2)));
              } else if (token2.getKind() === _TokenKind.TokenKind.LITERAL_REAL || token2.getKind() === _TokenKind.TokenKind.LITERAL_REAL_FLOAT) {
                push(_NumberLiteral.NumberLiteral.create(parseFloat(token2.stringValue()), toPosToken(token2)));
              } else if (token2.getKind() === _TokenKind.TokenKind.LITERAL_HEXINT || token2.getKind() === _TokenKind.TokenKind.LITERAL_HEXLONG) {
                push(_NumberLiteral.NumberLiteral.create(parseInt(token2.stringValue(), 16), toPosToken(token2)));
              } else if (peekIdentifierToken("true")) {
                push(_BooleanLiteral.BooleanLiteral.create(true, toPosToken(token2)));
              } else if (peekIdentifierToken("false")) {
                push(_BooleanLiteral.BooleanLiteral.create(false, toPosToken(token2)));
              } else if (token2.getKind() === _TokenKind.TokenKind.LITERAL_STRING) {
                push(_StringLiteral.StringLiteral.create(token2.stringValue(), toPosToken(token2)));
              } else {
                return false;
              }
              nextToken();
              return true;
            }
            function maybeEatParenExpression() {
              if (peekTokenOne(_TokenKind.TokenKind.LPAREN)) {
                nextToken();
                var expr = eatExpression();
                eatToken(_TokenKind.TokenKind.RPAREN);
                push(expr);
                return true;
              } else {
                return false;
              }
            }
            function maybeEatRelationalOperator() {
              var token2 = peekToken();
              if (token2 === null) {
                return null;
              }
              if (token2.isNumericRelationalOperator()) {
                return token2;
              }
              if (token2.isIdentifier()) {
                var idString = token2.stringValue();
                if (idString.toLowerCase() === "instanceof") {
                  return token2.asInstanceOfToken();
                }
                if (idString.toLowerCase() === "matches") {
                  return token2.asMatchesToken();
                }
                if (idString.toLowerCase() === "between") {
                  return token2.asBetweenToken();
                }
              }
              return null;
            }
            function eatToken(expectedKind) {
              var token2 = nextToken();
              if (token2 === null) {
                raiseInternalException(expressionString.length, "OOD");
              }
              if (token2.getKind() !== expectedKind) {
                raiseInternalException(token2.startPos, "NOT_EXPECTED_TOKEN", expectedKind.toString().toLowerCase(), token2.getKind().toString().toLowerCase());
              }
              return token2;
            }
            function peekTokenOne(desiredTokenKind) {
              return peekTokenConsumeIfMatched(desiredTokenKind, false);
            }
            function peekTokenConsumeIfMatched(desiredTokenKind, consumeIfMatched) {
              if (!moreTokens()) {
                return false;
              }
              var token2 = peekToken();
              if (token2.getKind() === desiredTokenKind) {
                if (consumeIfMatched) {
                  tokenStreamPointer++;
                }
                return true;
              }
              if (desiredTokenKind === _TokenKind.TokenKind.IDENTIFIER) {
                if (token2.getKind().ordinal() >= _TokenKind.TokenKind.DIV.ordinal() && token2.getKind().ordinal() <= _TokenKind.TokenKind.NOT.ordinal() && token2.data !== null) {
                  return true;
                }
              }
              return false;
            }
            function peekTokenAny() {
              if (!moreTokens()) {
                return false;
              }
              var token2 = peekToken();
              var args = Array.prototype.slice.call(arguments);
              for (var i2 = 0, l = args.length; i2 < l; i2 += 1) {
                if (token2.getKind() === args[i2]) {
                  return true;
                }
              }
              return false;
            }
            function peekIdentifierToken(identifierString) {
              if (!moreTokens()) {
                return false;
              }
              var token2 = peekToken();
              return token2.getKind() === _TokenKind.TokenKind.IDENTIFIER && token2.stringValue().toLowerCase() === identifierString.toLowerCase();
            }
            function peekSelectToken() {
              if (!moreTokens()) {
                return false;
              }
              var token2 = peekToken();
              return token2.getKind() === _TokenKind.TokenKind.SELECT || token2.getKind() === _TokenKind.TokenKind.SELECT_FIRST || token2.getKind() === _TokenKind.TokenKind.SELECT_LAST;
            }
            function moreTokens() {
              return tokenStreamPointer < tokenStream.length;
            }
            function nextToken() {
              if (tokenStreamPointer >= tokenStreamLength) {
                return null;
              }
              return tokenStream[tokenStreamPointer++];
            }
            function peekToken() {
              if (tokenStreamPointer >= tokenStreamLength) {
                return null;
              }
              return tokenStream[tokenStreamPointer];
            }
            function raiseInternalException(pos, message, expected, actual) {
              if (expected) {
                message += "\nExpected: " + expected;
              }
              if (actual) {
                message += "\nActual: " + actual;
              }
              throw {
                name: "InternalParseException",
                message: "Error occurred while attempting to parse expression '" + expressionString + "' at position " + pos + ". Message: " + message
              };
            }
            function toString6(token2) {
              if (token2.getKind().hasPayload()) {
                return token2.stringValue();
              }
              return token2.getKind().toString().toLowerCase();
            }
            function checkOperands(token2, left, right) {
              checkLeftOperand(token2, left);
              checkRightOperand(token2, right);
            }
            function checkLeftOperand(token2, operandExpression) {
              if (operandExpression === null) {
                raiseInternalException(token2.startPos, "LEFT_OPERAND_PROBLEM");
              }
            }
            function checkRightOperand(token2, operandExpression) {
              if (operandExpression === null) {
                raiseInternalException(token2.startPos, "RIGHT_OPERAND_PROBLEM");
              }
            }
            function toPosToken(token2) {
              return (token2.startPos << 16) + token2.endPos;
            }
            function toPosBounds(start, end) {
              return (start << 16) + end;
            }
            return {
              setConfiguration,
              parse
            };
          };
        },
        /* 6 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Tokenizer = void 0;
          var _Token = __webpack_require__(7);
          var _TokenKind = __webpack_require__(2);
          var ALTERNATIVE_OPERATOR_NAMES = ["DIV", "EQ", "GE", "GT", "LE", "LT", "MOD", "NE", "NOT"], FLAGS = [], IS_DIGIT = 1, IS_HEXDIGIT = 2, IS_ALPHA = 4;
          function init2() {
            var ch;
            for (ch = "0".charCodeAt(0); ch <= "9".charCodeAt(0); ch += 1) {
              FLAGS[ch] |= IS_DIGIT | IS_HEXDIGIT;
            }
            for (ch = "A".charCodeAt(0); ch <= "F".charCodeAt(0); ch += 1) {
              FLAGS[ch] |= IS_HEXDIGIT;
            }
            for (ch = "a".charCodeAt(0); ch <= "f".charCodeAt(0); ch += 1) {
              FLAGS[ch] |= IS_HEXDIGIT;
            }
            for (ch = "A".charCodeAt(0); ch <= "Z".charCodeAt(0); ch += 1) {
              FLAGS[ch] |= IS_ALPHA;
            }
            for (ch = "a".charCodeAt(0); ch <= "z".charCodeAt(0); ch += 1) {
              FLAGS[ch] |= IS_ALPHA;
            }
          }
          init2();
          function tokenize(inputData) {
            var expressionString = inputData, toProcess = inputData + "\0", max3 = toProcess.length, pos = 0, tokens2 = [];
            function process2() {
              var ch;
              while (pos < max3) {
                ch = toProcess[pos];
                if (isAlphabetic(ch)) {
                  lexIdentifier();
                } else {
                  switch (ch) {
                    case "+":
                      if (isTwoCharToken(_TokenKind.TokenKind.INC)) {
                        pushPairToken(_TokenKind.TokenKind.INC);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.PLUS);
                      }
                      break;
                    case "_":
                      lexIdentifier();
                      break;
                    case "-":
                      if (isTwoCharToken(_TokenKind.TokenKind.DEC)) {
                        pushPairToken(_TokenKind.TokenKind.DEC);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.MINUS);
                      }
                      break;
                    case ":":
                      pushCharToken(_TokenKind.TokenKind.COLON);
                      break;
                    case ".":
                      pushCharToken(_TokenKind.TokenKind.DOT);
                      break;
                    case ",":
                      pushCharToken(_TokenKind.TokenKind.COMMA);
                      break;
                    case "*":
                      pushCharToken(_TokenKind.TokenKind.STAR);
                      break;
                    case "/":
                      pushCharToken(_TokenKind.TokenKind.DIV);
                      break;
                    case "%":
                      pushCharToken(_TokenKind.TokenKind.MOD);
                      break;
                    case "(":
                      pushCharToken(_TokenKind.TokenKind.LPAREN);
                      break;
                    case ")":
                      pushCharToken(_TokenKind.TokenKind.RPAREN);
                      break;
                    case "[":
                      pushCharToken(_TokenKind.TokenKind.LSQUARE);
                      break;
                    case "#":
                      pushCharToken(_TokenKind.TokenKind.HASH);
                      break;
                    case "]":
                      pushCharToken(_TokenKind.TokenKind.RSQUARE);
                      break;
                    case "{":
                      pushCharToken(_TokenKind.TokenKind.LCURLY);
                      break;
                    case "}":
                      pushCharToken(_TokenKind.TokenKind.RCURLY);
                      break;
                    case "@":
                      pushCharToken(_TokenKind.TokenKind.BEAN_REF);
                      break;
                    case "^":
                      if (isTwoCharToken(_TokenKind.TokenKind.SELECT_FIRST)) {
                        pushPairToken(_TokenKind.TokenKind.SELECT_FIRST);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.POWER);
                      }
                      break;
                    case "!":
                      if (isTwoCharToken(_TokenKind.TokenKind.NE)) {
                        pushPairToken(_TokenKind.TokenKind.NE);
                      } else if (isTwoCharToken(_TokenKind.TokenKind.PROJECT)) {
                        pushPairToken(_TokenKind.TokenKind.PROJECT);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.NOT);
                      }
                      break;
                    case "=":
                      if (isTwoCharToken(_TokenKind.TokenKind.EQ)) {
                        pushPairToken(_TokenKind.TokenKind.EQ);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.ASSIGN);
                      }
                      break;
                    case "&":
                      if (!isTwoCharToken(_TokenKind.TokenKind.SYMBOLIC_AND)) {
                        throw {
                          name: "SpelParseException",
                          message: "Missing character '&' in expression (" + expressionString + ") at position " + pos
                        };
                      }
                      pushPairToken(_TokenKind.TokenKind.SYMBOLIC_AND);
                      break;
                    case "|":
                      if (!isTwoCharToken(_TokenKind.TokenKind.SYMBOLIC_OR)) {
                        throw {
                          name: "SpelParseException",
                          message: "Missing character '|' in expression (" + expressionString + ") at position " + pos
                        };
                      }
                      pushPairToken(_TokenKind.TokenKind.SYMBOLIC_OR);
                      break;
                    case "?":
                      if (isTwoCharToken(_TokenKind.TokenKind.SELECT)) {
                        pushPairToken(_TokenKind.TokenKind.SELECT);
                      } else if (isTwoCharToken(_TokenKind.TokenKind.ELVIS)) {
                        pushPairToken(_TokenKind.TokenKind.ELVIS);
                      } else if (isTwoCharToken(_TokenKind.TokenKind.SAFE_NAVI)) {
                        pushPairToken(_TokenKind.TokenKind.SAFE_NAVI);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.QMARK);
                      }
                      break;
                    case "$":
                      if (isTwoCharToken(_TokenKind.TokenKind.SELECT_LAST)) {
                        pushPairToken(_TokenKind.TokenKind.SELECT_LAST);
                      } else {
                        lexIdentifier();
                      }
                      break;
                    case ">":
                      if (isTwoCharToken(_TokenKind.TokenKind.GE)) {
                        pushPairToken(_TokenKind.TokenKind.GE);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.GT);
                      }
                      break;
                    case "<":
                      if (isTwoCharToken(_TokenKind.TokenKind.LE)) {
                        pushPairToken(_TokenKind.TokenKind.LE);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.LT);
                      }
                      break;
                    case "0":
                    case "1":
                    case "2":
                    case "3":
                    case "4":
                    case "5":
                    case "6":
                    case "7":
                    case "8":
                    case "9":
                      lexNumericLiteral(ch === "0");
                      break;
                    case " ":
                    case "	":
                    case "\r":
                    case "\n":
                      pos += 1;
                      break;
                    case "'":
                      lexQuotedStringLiteral();
                      break;
                    case '"':
                      lexDoubleQuotedStringLiteral();
                      break;
                    case "\0":
                      pos += 1;
                      break;
                    case "\\":
                      throw {
                        name: "SpelParseException",
                        message: "Unexpected escape character in expression (" + expressionString + ") at position " + pos
                      };
                    default:
                      throw {
                        name: "SpelParseException",
                        message: "Cannot handle character '" + ch + "' in expression (" + expressionString + ") at position " + pos
                      };
                  }
                }
              }
            }
            function lexQuotedStringLiteral() {
              var start = pos, terminated = false, ch;
              while (!terminated) {
                pos += 1;
                ch = toProcess[pos];
                if (ch === "'") {
                  if (toProcess[pos + 1] === "'") {
                    pos += 1;
                  } else {
                    terminated = true;
                  }
                }
                if (ch.charCodeAt(0) === 0) {
                  throw {
                    name: "SpelParseException",
                    message: "Non-terminating quoted string in expression (" + expressionString + ") at position " + pos
                  };
                }
              }
              pos += 1;
              tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_STRING, subarray(start, pos), start, pos));
            }
            function lexDoubleQuotedStringLiteral() {
              var start = pos, terminated = false, ch;
              while (!terminated) {
                pos += 1;
                ch = toProcess[pos];
                if (ch === '"') {
                  if (toProcess[pos + 1] === '"') {
                    pos += 1;
                  } else {
                    terminated = true;
                  }
                }
                if (ch.charCodeAt(0) === 0) {
                  throw {
                    name: "SpelParseException",
                    message: "Non-terminating double-quoted string in expression (" + expressionString + ") at position " + pos
                  };
                }
              }
              pos += 1;
              tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_STRING, subarray(start, pos), start, pos));
            }
            function lexNumericLiteral(firstCharIsZero) {
              var isReal = false, start = pos, ch = toProcess[pos + 1], isHex = ch === "x" || ch === "X", dotpos, endOfNumber, possibleSign, isFloat;
              if (firstCharIsZero && isHex) {
                pos = pos + 1;
                do {
                  pos += 1;
                } while (isHexadecimalDigit(toProcess[pos]));
                if (isChar("L", "l")) {
                  pushHexIntToken(subarray(start + 2, pos), true, start, pos);
                  pos += 1;
                } else {
                  pushHexIntToken(subarray(start + 2, pos), false, start, pos);
                }
                return;
              }
              do {
                pos += 1;
              } while (isDigit(toProcess[pos]));
              ch = toProcess[pos];
              if (ch === ".") {
                isReal = true;
                dotpos = pos;
                do {
                  pos += 1;
                } while (isDigit(toProcess[pos]));
                if (pos === dotpos + 1) {
                  pos = dotpos;
                  pushIntToken(subarray(start, pos), false, start, pos);
                  return;
                }
              }
              endOfNumber = pos;
              if (isChar("L", "l")) {
                if (isReal) {
                  throw {
                    name: "SpelParseException",
                    message: "Real cannot be long in expression (" + expressionString + ") at position " + pos
                  };
                }
                pushIntToken(subarray(start, endOfNumber), true, start, endOfNumber);
                pos += 1;
              } else if (isExponentChar(toProcess[pos])) {
                isReal = true;
                pos += 1;
                possibleSign = toProcess[pos];
                if (isSign(possibleSign)) {
                  pos += 1;
                }
                do {
                  pos += 1;
                } while (isDigit(toProcess[pos]));
                isFloat = false;
                if (isFloatSuffix(toProcess[pos])) {
                  isFloat = true;
                  pos += 1;
                  endOfNumber = pos;
                } else if (isDoubleSuffix(toProcess[pos])) {
                  pos += 1;
                  endOfNumber = pos;
                }
                pushRealToken(subarray(start, pos), isFloat, start, pos);
              } else {
                ch = toProcess[pos];
                isFloat = false;
                if (isFloatSuffix(ch)) {
                  isReal = true;
                  isFloat = true;
                  pos += 1;
                  endOfNumber = pos;
                } else if (isDoubleSuffix(ch)) {
                  isReal = true;
                  pos += 1;
                  endOfNumber = pos;
                }
                if (isReal) {
                  pushRealToken(subarray(start, endOfNumber), isFloat, start, endOfNumber);
                } else {
                  pushIntToken(subarray(start, endOfNumber), false, start, endOfNumber);
                }
              }
            }
            function lexIdentifier() {
              var start = pos, substring, asString, idx;
              do {
                pos += 1;
              } while (isIdentifier(toProcess[pos]));
              substring = subarray(start, pos);
              if (pos - start === 2 || pos - start === 3) {
                asString = substring.toUpperCase();
                idx = ALTERNATIVE_OPERATOR_NAMES.indexOf(asString);
                if (idx >= 0) {
                  pushOneCharOrTwoCharToken(_TokenKind.TokenKind.valueOf(asString), start, substring);
                  return;
                }
              }
              tokens2.push(new _Token.Token(_TokenKind.TokenKind.IDENTIFIER, substring.replace("\0", ""), start, pos));
            }
            function pushIntToken(data, isLong, start, end) {
              if (isLong) {
                tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_LONG, data, start, end));
              } else {
                tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_INT, data, start, end));
              }
            }
            function pushHexIntToken(data, isLong, start, end) {
              if (data.length === 0) {
                if (isLong) {
                  throw {
                    name: "SpelParseException",
                    message: "Not a long in expression (" + expressionString + ") at position " + pos
                  };
                } else {
                  throw {
                    name: "SpelParseException",
                    message: "Not an int in expression (" + expressionString + ") at position " + pos
                  };
                }
              }
              if (isLong) {
                tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_HEXLONG, data, start, end));
              } else {
                tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_HEXINT, data, start, end));
              }
            }
            function pushRealToken(data, isFloat, start, end) {
              if (isFloat) {
                tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_REAL_FLOAT, data, start, end));
              } else {
                tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_REAL, data, start, end));
              }
            }
            function subarray(start, end) {
              return toProcess.substring(start, end);
            }
            function isTwoCharToken(kind) {
              if (kind.tokenChars.length === 2 && toProcess[pos] === kind.tokenChars[0]) {
                return toProcess[pos + 1] === kind.tokenChars[1];
              }
              return false;
            }
            function pushCharToken(kind) {
              tokens2.push(new _Token.Token(kind, null, pos, pos + 1));
              pos += 1;
            }
            function pushPairToken(kind) {
              tokens2.push(new _Token.Token(kind, null, pos, pos + 2));
              pos += 2;
            }
            function pushOneCharOrTwoCharToken(kind, pos2, data) {
              tokens2.push(new _Token.Token(kind, data, pos2, pos2 + kind.getLength()));
            }
            function isIdentifier(ch) {
              return isAlphabetic(ch) || isDigit(ch) || ch === "_" || ch === "$";
            }
            function isChar(a2, b) {
              var ch = toProcess[pos];
              return ch === a2 || ch === b;
            }
            function isExponentChar(ch) {
              return ch === "e" || ch === "E";
            }
            function isFloatSuffix(ch) {
              return ch === "f" || ch === "F";
            }
            function isDoubleSuffix(ch) {
              return ch === "d" || ch === "D";
            }
            function isSign(ch) {
              return ch === "+" || ch === "-";
            }
            function isDigit(ch) {
              if (ch.charCodeAt(0) > 255) {
                return false;
              }
              return (FLAGS[ch.charCodeAt(0)] & IS_DIGIT) !== 0;
            }
            function isAlphabetic(ch) {
              if (ch.charCodeAt(0) > 255) {
                return false;
              }
              return (FLAGS[ch.charCodeAt(0)] & IS_ALPHA) !== 0;
            }
            function isHexadecimalDigit(ch) {
              if (ch.charCodeAt(0) > 255) {
                return false;
              }
              return (FLAGS[ch.charCodeAt(0)] & IS_HEXDIGIT) !== 0;
            }
            process2();
            return tokens2;
          }
          exports3.Tokenizer = {
            tokenize
          };
        },
        /* 7 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Token = void 0;
          var _TokenKind = __webpack_require__(2);
          function Token(tokenKind, tokenData, startPos, endPos) {
            this.kind = tokenKind;
            this.startPos = startPos;
            this.endPos = endPos;
            if (tokenData) {
              this.data = tokenData;
            }
          }
          Token.prototype.getKind = function() {
            return this.kind;
          };
          Token.prototype.toString = function() {
            var s2 = "[";
            s2 += this.kind.toString();
            if (this.kind.hasPayload()) {
              s2 += ":" + this.data;
            }
            s2 += "]";
            s2 += "(" + this.startPos + "," + this.endPos + ")";
            return s2;
          };
          Token.prototype.isIdentifier = function() {
            return this.kind === _TokenKind.TokenKind.IDENTIFIER;
          };
          Token.prototype.isNumericRelationalOperator = function() {
            return this.kind === _TokenKind.TokenKind.GT || this.kind === _TokenKind.TokenKind.GE || this.kind === _TokenKind.TokenKind.LT || this.kind === _TokenKind.TokenKind.LE || this.kind === _TokenKind.TokenKind.EQ || this.kind === _TokenKind.TokenKind.NE;
          };
          Token.prototype.stringValue = function() {
            return this.data;
          };
          Token.prototype.asInstanceOfToken = function() {
            return new Token(_TokenKind.TokenKind.INSTANCEOF, this.startPos, this.endPos);
          };
          Token.prototype.asMatchesToken = function() {
            return new Token(_TokenKind.TokenKind.MATCHES, this.startPos, this.endPos);
          };
          Token.prototype.asBetweenToken = function() {
            return new Token(_TokenKind.TokenKind.BETWEEN, this.startPos, this.endPos);
          };
          Token.prototype.getStartPosition = function() {
            return this.startPos;
          };
          Token.prototype.getEndPosition = function() {
            return this.endPos;
          };
          exports3.Token = Token;
        },
        /* 8 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.BooleanLiteral = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(value, position) {
            var node = _SpelNode.SpelNode.create("boolean", position);
            node.getValue = function() {
              return value;
            };
            node.setValue = function(newValue) {
              return value = newValue;
            };
            return node;
          }
          exports3.BooleanLiteral = {
            create: createNode
          };
        },
        /* 9 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.NumberLiteral = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(value, position) {
            var node = _SpelNode.SpelNode.create("number", position);
            node.getValue = function() {
              return value;
            };
            node.setValue = function(newValue) {
              return value = newValue;
            };
            return node;
          }
          exports3.NumberLiteral = {
            create: createNode
          };
        },
        /* 10 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.StringLiteral = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(value, position) {
            var node = _SpelNode.SpelNode.create("string", position);
            function stripQuotes(value2) {
              if (value2[0] === "'" && value2[value2.length - 1] === "'" || value2[0] === '"' && value2[value2.length - 1] === '"') {
                value2 = value2.substring(1, value2.length - 1);
              }
              return value2.replace(/''/g, "'").replace(/""/g, '"');
            }
            value = stripQuotes(value);
            node.getValue = function() {
              return value;
            };
            node.setValue = function(newValue) {
              return value = newValue;
            };
            return node;
          }
          exports3.StringLiteral = {
            create: createNode
          };
        },
        /* 11 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.NullLiteral = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(value, position) {
            var node = _SpelNode.SpelNode.create("null", position);
            node.getValue = function() {
              return null;
            };
            return node;
          }
          exports3.NullLiteral = {
            create: createNode
          };
        },
        /* 12 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.FunctionReference = void 0;
          var _SpelNode = __webpack_require__(0);
          var _Stack2 = __webpack_require__(1);
          function createNode(functionName, position, args) {
            var node = _SpelNode.SpelNode.create("function", position);
            node.getRaw = function() {
              return {
                functionName,
                args
              };
            };
            node.getValue = function(state) {
              var locals = state.locals || {}, context2 = state.rootContext, compiledArgs = [];
              args.forEach(function(arg) {
                var currentActiveContext = state.activeContext;
                state.activeContext = new _Stack2.Stack();
                state.activeContext.push(state.rootContext);
                compiledArgs.push(arg.getValue(state));
                state.activeContext = currentActiveContext;
              });
              if (locals[functionName]) {
                return locals[functionName].apply(context2, compiledArgs);
              }
              throw {
                name: "FunctionDoesNotExistException",
                message: "Function '" + functionName + "' does not exist."
              };
            };
            return node;
          }
          exports3.FunctionReference = {
            create: createNode
          };
        },
        /* 13 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.MethodReference = void 0;
          var _SpelNode = __webpack_require__(0);
          var _Stack2 = __webpack_require__(1);
          function createNode(nullSafeNavigation, methodName, position, args) {
            var node = _SpelNode.SpelNode.create("method", position);
            node.getRaw = function() {
              return {
                methodName,
                args
              };
            };
            node.getValue = function(state) {
              var context2 = state.activeContext.peek(), compiledArgs = [], method;
              if (!context2) {
                throw {
                  name: "ContextDoesNotExistException",
                  message: "Attempting to look up property '" + methodName + "' for an undefined context."
                };
              }
              function maybeHandleNullSafeNavigation(member) {
                if (member === void 0 || member === null) {
                  if (nullSafeNavigation) {
                    return null;
                  }
                  throw {
                    name: "NullPointerException",
                    message: "Method " + methodName + " does not exist."
                  };
                }
                return member;
              }
              args.forEach(function(arg) {
                var currentActiveContext = state.activeContext;
                state.activeContext = new _Stack2.Stack();
                state.activeContext.push(state.rootContext);
                compiledArgs.push(arg.getValue(state));
                state.activeContext = currentActiveContext;
              });
              if (methodName.substr(0, 3) === "get" && !context2[methodName]) {
                return maybeHandleNullSafeNavigation(context2[methodName.charAt(3).toLowerCase() + methodName.substring(4)]);
              }
              if (methodName.substr(0, 3) === "set" && !context2[methodName]) {
                return context2[methodName.charAt(3).toLowerCase() + methodName.substring(4)] = compiledArgs[0];
              }
              if (Array.isArray(context2)) {
                if (methodName === "size") {
                  return context2.length;
                }
                if (methodName === "contains") {
                  return context2.includes(compiledArgs[0]);
                }
              }
              method = maybeHandleNullSafeNavigation(context2[methodName]);
              if (method) {
                return method.apply(context2, compiledArgs);
              }
              return null;
            };
            return node;
          }
          exports3.MethodReference = {
            create: createNode
          };
        },
        /* 14 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.PropertyReference = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(nullSafeNavigation, propertyName, position) {
            var node = _SpelNode.SpelNode.create("property", position);
            node.getRaw = function() {
              return propertyName;
            };
            node.getValue = function(state) {
              var context2 = state.activeContext.peek();
              if (!context2) {
                if (nullSafeNavigation) {
                  return null;
                }
                throw {
                  name: "ContextDoesNotExistException",
                  message: "Attempting to look up property '" + propertyName + "' for an undefined context."
                };
              }
              if (context2[propertyName] === void 0 || context2[propertyName] === null) {
                if (nullSafeNavigation) {
                  return null;
                }
                if (propertyName === "size" && Array.isArray(context2)) {
                  return context2.length;
                }
                throw {
                  name: "NullPointerException",
                  message: "Property '" + propertyName + "' does not exist."
                };
              }
              return context2[propertyName];
            };
            node.setValue = function(value, state) {
              var context2 = state.activeContext.peek();
              if (!context2) {
                throw {
                  name: "ContextDoesNotExistException",
                  message: "Attempting to assign property '" + propertyName + "' for an undefined context."
                };
              }
              return context2[propertyName] = value;
            };
            node.getName = function() {
              return propertyName;
            };
            return node;
          }
          exports3.PropertyReference = {
            create: createNode
          };
        },
        /* 15 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.VariableReference = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(variableName, position) {
            var node = _SpelNode.SpelNode.create("variable", position);
            node.getRaw = function() {
              return variableName;
            };
            node.getValue = function(state) {
              var context2 = state.activeContext.peek(), locals = state.locals;
              if (!context2) {
                throw {
                  name: "ContextDoesNotExistException",
                  message: "Attempting to look up variable '" + variableName + "' for an undefined context."
                };
              }
              if (variableName === "this") {
                return context2;
              }
              if (variableName === "root") {
                return state.rootContext;
              }
              return locals[variableName];
            };
            node.setValue = function(value, state) {
              var locals = state.locals;
              return locals[variableName] = value;
            };
            return node;
          }
          exports3.VariableReference = {
            create: createNode
          };
        },
        /* 16 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.CompoundExpression = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, expressionComponents) {
            var node = _SpelNode.SpelNode.create.apply(null, ["compound", position].concat(expressionComponents));
            function buildContextStack(state) {
              var childrenCount = node.getChildren().length, i2;
              for (i2 = 0; i2 < childrenCount; i2 += 1) {
                if (node.getChildren()[i2].getType() === "indexer") {
                  state.activeContext.push(state.activeContext.peek()[node.getChildren()[i2].getValue(state)]);
                } else {
                  state.activeContext.push(node.getChildren()[i2].getValue(state));
                }
              }
              return function unbuildContextStack() {
                for (i2 = 0; i2 < childrenCount; i2 += 1) {
                  state.activeContext.pop();
                }
              };
            }
            node.getValue = function(state) {
              var context2 = state.activeContext.peek(), value;
              if (!context2) {
                throw {
                  name: "ContextDoesNotExistException",
                  message: "Attempting to evaluate compound expression with an undefined context."
                };
              }
              var unbuildContextStack = buildContextStack(state);
              value = state.activeContext.peek();
              unbuildContextStack();
              return value;
            };
            node.setValue = function(value, state) {
              var unbuildContextStack = buildContextStack(state), childCount = node.getChildren().length;
              state.activeContext.pop();
              value = node.getChildren()[childCount - 1].setValue(value, state);
              state.activeContext.push(null);
              unbuildContextStack();
              return value;
            };
            return node;
          }
          exports3.CompoundExpression = {
            create: createNode
          };
        },
        /* 17 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Indexer = void 0;
          var _SpelNode = __webpack_require__(0);
          var _Stack2 = __webpack_require__(1);
          function createNode(position, expressionComponents) {
            var node = _SpelNode.SpelNode.create.apply(null, ["indexer", position].concat(expressionComponents));
            node.getValue = function(state) {
              var activeContext = state.activeContext, context2, childrenCount = node.getChildren().length, i2, value;
              state.activeContext = new _Stack2.Stack();
              state.activeContext.push(state.rootContext);
              context2 = state.activeContext.peek();
              if (!context2) {
                throw {
                  name: "ContextDoesNotExistException",
                  message: "Attempting to evaluate compound expression with an undefined context."
                };
              }
              for (i2 = 0; i2 < childrenCount; i2 += 1) {
                state.activeContext.push(node.getChildren()[i2].getValue(state));
              }
              value = state.activeContext.peek();
              for (i2 = 0; i2 < childrenCount; i2 += 1) {
                state.activeContext.pop();
              }
              state.activeContext = activeContext;
              return value;
            };
            return node;
          }
          exports3.Indexer = {
            create: createNode
          };
        },
        /* 18 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Assign = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, property2, assignedValue) {
            var node = _SpelNode.SpelNode.create("assign", position, property2, assignedValue);
            node.getValue = function(state) {
              var context2 = state.activeContext.peek();
              if (!context2) {
                throw {
                  name: "ContextDoesNotExistException",
                  message: "Attempting to assign property '" + property2.getValue(state) + "' for an undefined context."
                };
              }
              return property2.setValue(assignedValue.getValue(state), state);
            };
            return node;
          }
          exports3.Assign = {
            create: createNode
          };
        },
        /* 19 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpEQ = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-eq", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) === right.getValue(state);
            };
            return node;
          }
          exports3.OpEQ = {
            create: createNode
          };
        },
        /* 20 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpNE = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-ne", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) !== right.getValue(state);
            };
            return node;
          }
          exports3.OpNE = {
            create: createNode
          };
        },
        /* 21 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpGE = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-ge", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) >= right.getValue(state);
            };
            return node;
          }
          exports3.OpGE = {
            create: createNode
          };
        },
        /* 22 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpGT = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-gt", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) > right.getValue(state);
            };
            return node;
          }
          exports3.OpGT = {
            create: createNode
          };
        },
        /* 23 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpLE = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-le", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) <= right.getValue(state);
            };
            return node;
          }
          exports3.OpLE = {
            create: createNode
          };
        },
        /* 24 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpLT = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-lt", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) < right.getValue(state);
            };
            return node;
          }
          exports3.OpLT = {
            create: createNode
          };
        },
        /* 25 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpPlus = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-plus", position, left, right);
            node.getValue = function(state) {
              if (!right) {
                return +left.getValue(state);
              }
              return left.getValue(state) + right.getValue(state);
            };
            return node;
          }
          exports3.OpPlus = {
            create: createNode
          };
        },
        /* 26 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpMinus = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-minus", position, left, right);
            node.getValue = function(state) {
              if (!right) {
                return -left.getValue(state);
              }
              return left.getValue(state) - right.getValue(state);
            };
            return node;
          }
          exports3.OpMinus = {
            create: createNode
          };
        },
        /* 27 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpMultiply = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-multiply", position, left, right);
            node.getValue = function(state) {
              var leftValue = left.getValue(state), rightValue = right.getValue(state);
              if (typeof leftValue === "number" && typeof rightValue === "number") {
                return leftValue * rightValue;
              }
              if (typeof leftValue === "string" && typeof rightValue === "number") {
                var s2 = "", i2 = 0;
                for (; i2 < rightValue; i2 += 1) {
                  s2 += leftValue;
                }
                return s2;
              }
              return null;
            };
            return node;
          }
          exports3.OpMultiply = {
            create: createNode
          };
        },
        /* 28 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpDivide = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-divide", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) / right.getValue(state);
            };
            return node;
          }
          exports3.OpDivide = {
            create: createNode
          };
        },
        /* 29 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpModulus = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-modulus", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) % right.getValue(state);
            };
            return node;
          }
          exports3.OpModulus = {
            create: createNode
          };
        },
        /* 30 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpPower = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, base, exp) {
            var node = _SpelNode.SpelNode.create("op-power", position, base, exp);
            node.getValue = function(state) {
              return Math.pow(base.getValue(state), exp.getValue(state));
            };
            return node;
          }
          exports3.OpPower = {
            create: createNode
          };
        },
        /* 31 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpInc = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, postfix, int) {
            var node = _SpelNode.SpelNode.create("op-inc", position, int);
            node.getValue = function(state) {
              var cur = int.getValue(state);
              int.setValue(cur + 1, state);
              if (postfix) {
                return cur;
              }
              return cur + 1;
            };
            return node;
          }
          exports3.OpInc = {
            create: createNode
          };
        },
        /* 32 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpDec = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, postfix, int) {
            var node = _SpelNode.SpelNode.create("op-dec", position, int);
            node.getValue = function(state) {
              var cur = int.getValue(state);
              int.setValue(cur - 1, state);
              if (postfix) {
                return cur;
              }
              return cur - 1;
            };
            return node;
          }
          exports3.OpDec = {
            create: createNode
          };
        },
        /* 33 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpNot = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, expr) {
            var node = _SpelNode.SpelNode.create("op-not", position, expr);
            node.getValue = function(state) {
              return !expr.getValue(state);
            };
            return node;
          }
          exports3.OpNot = {
            create: createNode
          };
        },
        /* 34 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpAnd = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-and", position, left, right);
            node.getValue = function(state) {
              return !!left.getValue(state) && !!right.getValue(state);
            };
            return node;
          }
          exports3.OpAnd = {
            create: createNode
          };
        },
        /* 35 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpOr = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-or", position, left, right);
            node.getValue = function(state) {
              return !!left.getValue(state) || !!right.getValue(state);
            };
            return node;
          }
          exports3.OpOr = {
            create: createNode
          };
        },
        /* 36 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpMatches = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("matches", position, left, right);
            node.getValue = function(state) {
              var data = left.getValue(state);
              var regexpString = right.getValue(state);
              try {
                var regexp = new RegExp(regexpString);
                return !!regexp.exec(data);
              } catch (error2) {
                throw {
                  name: "EvaluationException",
                  message: error2.toString()
                };
              }
            };
            return node;
          }
          exports3.OpMatches = {
            create: createNode
          };
        },
        /* 37 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Ternary = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, expression, ifTrue, ifFalse) {
            var node = _SpelNode.SpelNode.create("ternary", position, expression, ifTrue, ifFalse);
            node.getValue = function(state) {
              return expression.getValue(state) ? ifTrue.getValue(state) : ifFalse.getValue(state);
            };
            return node;
          }
          exports3.Ternary = {
            create: createNode
          };
        },
        /* 38 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Elvis = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, expression, ifFalse) {
            var node = _SpelNode.SpelNode.create("elvis", position, expression, ifFalse);
            node.getValue = function(state) {
              return expression.getValue(state) !== null ? expression.getValue(state) : ifFalse.getValue(state);
            };
            return node;
          }
          exports3.Elvis = {
            create: createNode
          };
        },
        /* 39 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.InlineList = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, elements) {
            var node = _SpelNode.SpelNode.create("list", position), list2 = [].concat(elements || []);
            node.getRaw = function() {
              return list2;
            };
            node.getValue = function(state) {
              return list2.map(function(element) {
                return element.getValue(state);
              });
            };
            return node;
          }
          exports3.InlineList = {
            create: createNode
          };
        },
        /* 40 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.InlineMap = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, elements) {
            var node = _SpelNode.SpelNode.create("map", position), mapPieces = [].concat(elements || []);
            node.getValue = function(state) {
              var key = true, keyValue = null, map3 = {};
              mapPieces.forEach(function(piece) {
                if (key) {
                  if (piece.getType() === "property") {
                    keyValue = piece.getName();
                  } else {
                    keyValue = piece.getValue(state);
                  }
                } else {
                  map3[keyValue] = piece.getValue(state);
                }
                key = !key;
              });
              return map3;
            };
            return node;
          }
          exports3.InlineMap = {
            create: createNode
          };
        },
        /* 41 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Selection = void 0;
          var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _SpelNode = __webpack_require__(0);
          function matches(element, expr, state) {
            var doesMatch = false;
            state.activeContext.push(element);
            doesMatch = expr.getValue(state);
            state.activeContext.pop();
            return doesMatch;
          }
          function selectFromArray(collection, whichElement, expr, state) {
            var newCollection = collection.filter(function(element) {
              return matches(element, expr, state);
            });
            switch (whichElement) {
              case "ALL":
                return newCollection;
              case "FIRST":
                return newCollection[0] || null;
              case "LAST":
                if (newCollection.length) {
                  return newCollection[newCollection.length - 1];
                }
                return null;
            }
          }
          function selectFromMap(collection, whichElement, expr, state) {
            var newCollection = {}, entry, key, entries3 = [], returnValue = {};
            for (key in collection) {
              if (collection.hasOwnProperty(key)) {
                entry = {
                  key,
                  value: collection[key]
                };
                if (matches(entry, expr, state)) {
                  entries3.push(entry);
                }
              }
            }
            switch (whichElement) {
              case "ALL":
                entries3.forEach(function(entry2) {
                  newCollection[entry2.key] = entry2.value;
                });
                return newCollection;
              case "FIRST":
                if (entries3.length) {
                  returnValue[entries3[0].key] = entries3[0].value;
                  return returnValue;
                }
                return null;
              case "LAST":
                if (entries3.length) {
                  returnValue[entries3[entries3.length - 1].key] = entries3[entries3.length - 1].value;
                  return returnValue;
                }
                return null;
            }
            entries3.forEach(function(entry2) {
              newCollection[entry2.key] = entry2.value;
            });
          }
          function createNode(nullSafeNavigation, whichElement, position, expr) {
            var node = _SpelNode.SpelNode.create("selection", position, expr);
            node.getValue = function(state) {
              var collection = state.activeContext.peek();
              if (collection) {
                if (Array.isArray(collection)) {
                  return selectFromArray(collection, whichElement, expr, state);
                } else if ((typeof collection === "undefined" ? "undefined" : _typeof2(collection)) === "object") {
                  return selectFromMap(collection, whichElement, expr, state);
                }
              }
              return null;
            };
            return node;
          }
          exports3.Selection = {
            create: createNode,
            FIRST: "FIRST",
            LAST: "LAST",
            ALL: "ALL"
          };
        },
        /* 42 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Projection = void 0;
          var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _SpelNode = __webpack_require__(0);
          function projectCollection(collection, expr, state) {
            return collection.map(function(element) {
              var matches;
              state.activeContext.push(element);
              matches = expr.getValue(state);
              state.activeContext.pop();
              return matches;
            });
          }
          function createNode(nullSafeNavigation, position, expr) {
            var node = _SpelNode.SpelNode.create("projection", position, expr);
            node.getValue = function(state) {
              var collection = state.activeContext.peek(), entries3 = [], key;
              if (Array.isArray(collection)) {
                return projectCollection(collection, expr, state);
              } else if ((typeof collection === "undefined" ? "undefined" : _typeof2(collection)) === "object") {
                for (key in collection) {
                  if (collection.hasOwnProperty(key)) {
                    entries3.push(collection[key]);
                  }
                }
                return projectCollection(entries3, expr, state);
              }
              return null;
            };
            return node;
          }
          exports3.Projection = {
            create: createNode
          };
        },
        /* 43 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpInstanceof = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("instanceof", position, left, right);
            node.getValue = function(state) {
              throw {
                name: "MethodNotImplementedException",
                message: "OpInstanceOf: Not implemented"
              };
            };
            return node;
          }
          exports3.OpInstanceof = {
            create: createNode
          };
        },
        /* 44 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpBetween = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("between", position, left, right);
            node.getValue = function(state) {
              throw {
                name: "MethodNotImplementedException",
                message: "OpBetween: Not implemented"
              };
            };
            return node;
          }
          exports3.OpBetween = {
            create: createNode
          };
        },
        /* 45 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.TypeReference = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, node, _dims) {
            var node = _SpelNode.SpelNode.create("typeref", position, node);
            node.getValue = function(state) {
              throw {
                name: "MethodNotImplementedException",
                message: "TypeReference: Not implemented"
              };
            };
            return node;
          }
          exports3.TypeReference = {
            create: createNode
          };
        },
        /* 46 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.BeanReference = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, beanName) {
            var node = _SpelNode.SpelNode.create("beanref", position);
            node.getValue = function(state) {
              throw {
                name: "MethodNotImplementedException",
                message: "BeanReference: Not implemented"
              };
            };
            return node;
          }
          exports3.BeanReference = {
            create: createNode
          };
        },
        /* 47 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Identifier = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(identifierName, position) {
            var node = _SpelNode.SpelNode.create("identifier", position);
            node.getRaw = function() {
              return identifierName;
            };
            node.getValue = function(state) {
              throw {
                name: "MethodNotImplementedException",
                message: "Identifier: Not implemented"
              };
            };
            return node;
          }
          exports3.Identifier = {
            create: createNode
          };
        },
        /* 48 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.QualifiedIdentifier = void 0;
          var _SpelNode = __webpack_require__(0);
          function _toConsumableArray2(arr) {
            if (Array.isArray(arr)) {
              for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
                arr2[i2] = arr[i2];
              }
              return arr2;
            } else {
              return Array.from(arr);
            }
          }
          function createNode(position, pieces) {
            var node = _SpelNode.SpelNode.create.apply(_SpelNode.SpelNode, ["qualifiedidentifier", position].concat(_toConsumableArray2(pieces)));
            node.getRaw = function() {
              return pieces.map(function(p) {
                return p.getRaw();
              });
            };
            node.getValue = function(state) {
              throw {
                name: "MethodNotImplementedException",
                message: "QualifiedIdentifier: Not implemented"
              };
            };
            return node;
          }
          exports3.QualifiedIdentifier = {
            create: createNode
          };
        },
        /* 49 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.ConstructorReference = void 0;
          var _SpelNode = __webpack_require__(0);
          var _Stack2 = __webpack_require__(1);
          function _toConsumableArray2(arr) {
            if (Array.isArray(arr)) {
              for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
                arr2[i2] = arr[i2];
              }
              return arr2;
            } else {
              return Array.from(arr);
            }
          }
          function _toArray2(arr) {
            return Array.isArray(arr) ? arr : Array.from(arr);
          }
          function createNode(position, dimensions, nodes) {
            var isArray3 = nodes !== void 0;
            var dimension;
            if (isArray3) {
              dimension = dimensions.length && dimensions[0] && dimensions[0].getType() === "number" ? dimensions[0].getValue() : null;
            } else {
              nodes = dimensions;
              dimensions = void 0;
            }
            var _nodes = nodes, _nodes2 = _toArray2(_nodes);
            _nodes2[0];
            var args = _nodes2.slice(1);
            var node = _SpelNode.SpelNode.create.apply(_SpelNode.SpelNode, ["constructorref", position].concat(_toConsumableArray2(nodes)));
            node.getRaw = function() {
              return dimension;
            };
            node.getValue = function(state) {
              if (isArray3 && args.length <= 1) {
                var compiledArgs = [];
                args.forEach(function(arg) {
                  var currentActiveContext = state.activeContext;
                  state.activeContext = new _Stack2.Stack();
                  state.activeContext.push(state.rootContext);
                  compiledArgs.push(arg.getValue(state));
                  state.activeContext = currentActiveContext;
                });
                if (args.length === 1) {
                  return compiledArgs[0];
                } else {
                  return dimension ? new Array(dimension) : [];
                }
              }
              throw {
                name: "MethodNotImplementedException",
                message: "ConstructorReference: Not implemented"
              };
            };
            return node;
          }
          exports3.ConstructorReference = {
            create: createNode
          };
        },
        /* 50 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          function create(authentication, principal) {
            var context2 = {};
            context2.authentication = authentication || {};
            context2.principal = principal || {};
            context2.hasRole = function(role) {
              var hasRole = false;
              if (!role) {
                return false;
              }
              if (!context2.authentication && !Array.isArray(context2.authentication.authorities)) {
                return false;
              }
              context2.authentication.authorities.forEach(function(grantedAuthority) {
                if (grantedAuthority.authority.toLowerCase() === role.toLowerCase()) {
                  hasRole = true;
                }
              });
              return hasRole;
            };
            context2.hasPermission = function() {
              var args = Array.prototype.slice.call(arguments);
              if (args.length === 1) {
                return context2.hasRole(args[0]);
              }
            };
            return context2;
          }
          exports3.StandardContext = {
            create
          };
        }
        /******/
      ])
    );
  });
})(spel2js);
var spel2jsExports = spel2js.exports;
var SqlString$1 = {};
(function(exports2) {
  var SqlString2 = exports2;
  var ID_GLOBAL_REGEXP = /`/g;
  var QUAL_GLOBAL_REGEXP = /\./g;
  var CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g;
  var CHARS_ESCAPE_MAP = {
    "\0": "\\0",
    "\b": "\\b",
    "	": "\\t",
    "\n": "\\n",
    "\r": "\\r",
    "": "\\Z",
    '"': '\\"',
    "'": "\\'",
    "\\": "\\\\"
  };
  SqlString2.escapeId = function escapeId(val, forbidQualified) {
    if (Array.isArray(val)) {
      var sql = "";
      for (var i2 = 0; i2 < val.length; i2++) {
        sql += (i2 === 0 ? "" : ", ") + SqlString2.escapeId(val[i2], forbidQualified);
      }
      return sql;
    } else if (forbidQualified) {
      return "`" + String(val).replace(ID_GLOBAL_REGEXP, "``") + "`";
    } else {
      return "`" + String(val).replace(ID_GLOBAL_REGEXP, "``").replace(QUAL_GLOBAL_REGEXP, "`.`") + "`";
    }
  };
  SqlString2.escape = function escape2(val, stringifyObjects, timeZone) {
    if (val === void 0 || val === null) {
      return "NULL";
    }
    switch (typeof val) {
      case "boolean":
        return val ? "true" : "false";
      case "number":
        return val + "";
      case "object":
        if (Object.prototype.toString.call(val) === "[object Date]") {
          return SqlString2.dateToString(val, timeZone || "local");
        } else if (Array.isArray(val)) {
          return SqlString2.arrayToList(val, timeZone);
        } else if (Buffer.isBuffer(val)) {
          return SqlString2.bufferToString(val);
        } else if (typeof val.toSqlString === "function") {
          return String(val.toSqlString());
        } else if (stringifyObjects) {
          return escapeString(val.toString());
        } else {
          return SqlString2.objectToValues(val, timeZone);
        }
      default:
        return escapeString(val);
    }
  };
  SqlString2.arrayToList = function arrayToList(array, timeZone) {
    var sql = "";
    for (var i2 = 0; i2 < array.length; i2++) {
      var val = array[i2];
      if (Array.isArray(val)) {
        sql += (i2 === 0 ? "" : ", ") + "(" + SqlString2.arrayToList(val, timeZone) + ")";
      } else {
        sql += (i2 === 0 ? "" : ", ") + SqlString2.escape(val, true, timeZone);
      }
    }
    return sql;
  };
  SqlString2.format = function format2(sql, values2, stringifyObjects, timeZone) {
    if (values2 == null) {
      return sql;
    }
    if (!Array.isArray(values2)) {
      values2 = [values2];
    }
    var chunkIndex = 0;
    var placeholdersRegex = /\?+/g;
    var result = "";
    var valuesIndex = 0;
    var match;
    while (valuesIndex < values2.length && (match = placeholdersRegex.exec(sql))) {
      var len = match[0].length;
      if (len > 2) {
        continue;
      }
      var value = len === 2 ? SqlString2.escapeId(values2[valuesIndex]) : SqlString2.escape(values2[valuesIndex], stringifyObjects, timeZone);
      result += sql.slice(chunkIndex, match.index) + value;
      chunkIndex = placeholdersRegex.lastIndex;
      valuesIndex++;
    }
    if (chunkIndex === 0) {
      return sql;
    }
    if (chunkIndex < sql.length) {
      return result + sql.slice(chunkIndex);
    }
    return result;
  };
  SqlString2.dateToString = function dateToString(date, timeZone) {
    var dt = new Date(date);
    if (isNaN(dt.getTime())) {
      return "NULL";
    }
    var year;
    var month;
    var day;
    var hour;
    var minute;
    var second;
    var millisecond;
    if (timeZone === "local") {
      year = dt.getFullYear();
      month = dt.getMonth() + 1;
      day = dt.getDate();
      hour = dt.getHours();
      minute = dt.getMinutes();
      second = dt.getSeconds();
      millisecond = dt.getMilliseconds();
    } else {
      var tz = convertTimezone(timeZone);
      if (tz !== false && tz !== 0) {
        dt.setTime(dt.getTime() + tz * 6e4);
      }
      year = dt.getUTCFullYear();
      month = dt.getUTCMonth() + 1;
      day = dt.getUTCDate();
      hour = dt.getUTCHours();
      minute = dt.getUTCMinutes();
      second = dt.getUTCSeconds();
      millisecond = dt.getUTCMilliseconds();
    }
    var str = zeroPad(year, 4) + "-" + zeroPad(month, 2) + "-" + zeroPad(day, 2) + " " + zeroPad(hour, 2) + ":" + zeroPad(minute, 2) + ":" + zeroPad(second, 2) + "." + zeroPad(millisecond, 3);
    return escapeString(str);
  };
  SqlString2.bufferToString = function bufferToString(buffer) {
    return "X" + escapeString(buffer.toString("hex"));
  };
  SqlString2.objectToValues = function objectToValues(object, timeZone) {
    var sql = "";
    for (var key in object) {
      var val = object[key];
      if (typeof val === "function") {
        continue;
      }
      sql += (sql.length === 0 ? "" : ", ") + SqlString2.escapeId(key) + " = " + SqlString2.escape(val, true, timeZone);
    }
    return sql;
  };
  SqlString2.raw = function raw(sql) {
    if (typeof sql !== "string") {
      throw new TypeError("argument sql must be a string");
    }
    return {
      toSqlString: function toSqlString() {
        return sql;
      }
    };
  };
  function escapeString(val) {
    var chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
    var escapedVal = "";
    var match;
    while (match = CHARS_GLOBAL_REGEXP.exec(val)) {
      escapedVal += val.slice(chunkIndex, match.index) + CHARS_ESCAPE_MAP[match[0]];
      chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
    }
    if (chunkIndex === 0) {
      return "'" + val + "'";
    }
    if (chunkIndex < val.length) {
      return "'" + escapedVal + val.slice(chunkIndex) + "'";
    }
    return "'" + escapedVal + "'";
  }
  function zeroPad(number, length) {
    number = number.toString();
    while (number.length < length) {
      number = "0" + number;
    }
    return number;
  }
  function convertTimezone(tz) {
    if (tz === "Z") {
      return 0;
    }
    var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
    if (m) {
      return (m[1] === "-" ? -1 : 1) * (parseInt(m[2], 10) + (m[3] ? parseInt(m[3], 10) : 0) / 60) * 60;
    }
    return false;
  }
})(SqlString$1);
var sqlstring = SqlString$1;
const SqlStringOrig = /* @__PURE__ */ getDefaultExportFromCjs(sqlstring);
var SqlString = SqlStringOrig;
SqlString.trim = function(val) {
  if (val.charAt(0) == "'") return val.substring(1, val.length - 1);
  else return val;
};
SqlString.escapeLike = function(val) {
  var any_start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var any_end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var res = SqlString.escape(val);
  res = SqlString.trim(res);
  res = res.replace(/[%_]/g, "\\$&");
  res = (any_start ? "%" : "") + res + (any_end ? "%" : "");
  res = "'" + res + "'";
  return res;
};
var sqlEmptyValue = function sqlEmptyValue2(fieldDef) {
  var v = "''";
  var type2 = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.type;
  if (type2 == "date") {
    v = "'0000-00-00'";
  } else if (type2 == "datetime") {
    v = "'0000-00-00 00:00'";
  } else if (type2 == "time") {
    v = "'00:00'";
  } else if (type2 == "number") {
    v = "0";
  }
  return v;
};
var mongoEmptyValue = function mongoEmptyValue2(fieldDef) {
  var v = "";
  var type2 = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.type;
  if (type2 == "number") {
    v = 0;
  }
  return v;
};
var spelEscapeString = function spelEscapeString2(val) {
  return "'" + val.replace(/'/g, "''") + "'";
};
var spelInlineList = function spelInlineList2(vals) {
  var toArray3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var javaType;
  var jt;
  var numberJavaTypes = ["int", "float"];
  vals.map(function(v) {
    if (v !== void 0 && v !== null) {
      if (typeof v === "string") {
        jt = "String";
      } else if (typeof v === "number") {
        jt = Number.isInteger(v) ? "int" : "float";
      } else throw new Error("spelEscape: Can't use value ".concat(v, " in array"));
      if (!javaType) {
        javaType = jt;
      } else if (javaType != jt) {
        if (numberJavaTypes.includes(javaType) && numberJavaTypes.includes(jt)) {
          javaType = "float";
        } else throw new Error("spelEscape: Can't use different types in array: found ".concat(javaType, " and ").concat(jt));
      }
    }
  });
  if (!javaType) {
    javaType = "String";
  }
  var escapedVals;
  if (javaType == "float") {
    escapedVals = vals.map(function(v) {
      return spelEscape(v, true);
    });
  } else {
    escapedVals = vals.map(function(v) {
      return spelEscape(v);
    });
  }
  var res;
  if (toArray3) {
    res = "new ".concat(javaType, "[]{").concat(escapedVals.join(", "), "}");
  } else {
    res = "{".concat(escapedVals.join(", "), "}");
  }
  return res;
};
var spelFixList = function spelFixList2(val) {
  return "".concat(val, ".?[true]");
};
var spelEscape = function spelEscape2(val) {
  var numberToFloat = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var arrayToArray = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (val === void 0 || val === null) {
    return "null";
  }
  switch (_typeof$3(val)) {
    case "boolean":
      return val ? "true" : "false";
    case "number":
      if (!Number.isFinite(val) || isNaN(val)) return void 0;
      return val + (!Number.isInteger(val) || numberToFloat ? "f" : "");
    case "object":
      if (Array.isArray(val)) {
        return spelInlineList(val, arrayToArray);
      } else {
        throw new Error("spelEscape: Object is not supported");
      }
    default:
      return spelEscapeString(val);
  }
};
var spelFormatConcat = function spelFormatConcat2(parts) {
  if (parts && Array.isArray(parts) && parts.length) {
    return parts.map(function(part) {
      if (part.type == "const") {
        return spelEscape(part.value);
      } else if (part.type == "property") {
        return "" + part.value;
      } else if (part.type == "variable") {
        return "#" + part.value;
      }
      return void 0;
    }).filter(function(r2) {
      return r2 != void 0;
    }).join(" + ");
  } else {
    return "null";
  }
};
var spelImportConcat = function spelImportConcat2(val) {
  if (val == void 0) return [void 0, []];
  var errors = [];
  var value = val.valueType == "case_value" ? val.value : val;
  var valueArr = Array.isArray(value) ? value : [value];
  var res = valueArr.map(function(child) {
    if (child.valueSrc === "value") {
      if (child.value === null) {
        return void 0;
      } else {
        return {
          type: "const",
          value: child.value
        };
      }
    } else if (child.valueSrc === "field") {
      return {
        type: child.isVariable ? "variable" : "property",
        value: child.value
      };
    } else {
      errors.push("Unsupported valueSrc ".concat(child.valueSrc, " in concatenation"));
    }
  }).filter(function(v) {
    return v != void 0;
  });
  return [res, errors];
};
var stringifyForDisplay = function stringifyForDisplay2(v) {
  return v == null ? "NULL" : v.toString();
};
var wrapWithBrackets = function wrapWithBrackets2(v) {
  if (v == void 0) return v;
  if ((v === null || v === void 0 ? void 0 : v[0]) === "(" && (v === null || v === void 0 ? void 0 : v[(v === null || v === void 0 ? void 0 : v.length) - 1]) === ")") {
    return v;
  }
  return "(" + v + ")";
};
const _export = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SqlString,
  mongoEmptyValue,
  spelEscape,
  spelFixList,
  spelFormatConcat,
  spelImportConcat,
  sqlEmptyValue,
  stringifyForDisplay,
  wrapWithBrackets
}, Symbol.toStringTag, { value: "Module" }));
function _createForOfIteratorHelper$c(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$c(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null) it["return"]();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$c(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$c(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$c(o, minLen);
}
function _arrayLikeToArray$c(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function ownKeys$A(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$A(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$A(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$A(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var compareToSign = "${0}.compareTo(${1})";
var TypesWithCompareTo = {
  datetime: true,
  time: true,
  date: true
};
var spelFormat = function spelFormat2(tree2, config2) {
  return _spelFormat(tree2, config2, false);
};
var _spelFormat = function _spelFormat2(tree2, config2) {
  var returnErrors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var meta = {
    errors: []
  };
  var extendedConfig = extendConfig(config2, void 0, false);
  var res = formatItem$5(tree2, extendedConfig, meta, null);
  if (returnErrors) {
    return [res, meta.errors];
  } else {
    if (meta.errors.length) console.warn("Errors while exporting to SpEL:", meta.errors);
    return res;
  }
};
var formatItem$5 = function formatItem(item, config2, meta) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  if (!item) return void 0;
  var type2 = item.get("type");
  if (type2 === "group" || type2 === "rule_group") {
    return formatGroup$5(item, config2, meta, parentField);
  } else if (type2 === "rule") {
    return formatRule$5(item, config2, meta, parentField);
  } else if (type2 == "switch_group") {
    return formatSwitch$1(item, config2, meta);
  } else if (type2 == "case_group") {
    return formatCase$1(item, config2, meta, parentField);
  }
  return void 0;
};
var formatCase$1 = function formatCase(item, config2, meta) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var type2 = item.get("type");
  if (type2 != "case_group") {
    meta.errors.push("Unexpected child of type ".concat(type2, " inside switch"));
    return void 0;
  }
  var properties = item.get("properties") || new Map$2();
  var _formatItemValue = formatItemValue$2(config2, properties, meta, null, parentField, "!case_value"), _formatItemValue2 = _slicedToArray$1(_formatItemValue, 3), formattedValue = _formatItemValue2[0];
  _formatItemValue2[1];
  _formatItemValue2[2];
  var cond = formatGroup$5(item, config2, meta, parentField);
  return [cond, formattedValue];
};
var formatSwitch$1 = function formatSwitch(item, config2, meta) {
  item.get("properties") || new Map$2();
  var children = item.get("children1");
  if (!children) return void 0;
  var cases = children.map(function(currentChild) {
    return formatCase$1(currentChild, config2, meta, null);
  }).filter(function(currentChild) {
    return typeof currentChild !== "undefined";
  }).valueSeq().toArray();
  if (!cases.length) return void 0;
  if (cases.length == 1 && !cases[0][0]) {
    return cases[0][1];
  }
  var filteredCases = [];
  for (var i2 = 0; i2 < cases.length; i2++) {
    if (i2 != cases.length - 1 && !cases[i2][0]) {
      meta.errors.push("No condition for case ".concat(i2));
    } else {
      filteredCases.push(cases[i2]);
      if (i2 == cases.length - 1 && cases[i2][0]) {
        filteredCases.push([void 0, null]);
      }
    }
  }
  var left = "", right = "";
  for (var _i = 0; _i < filteredCases.length; _i++) {
    var _filteredCases$_i = _slicedToArray$1(filteredCases[_i], 2), cond = _filteredCases$_i[0], value = _filteredCases$_i[1];
    if (value == void 0) value = "null";
    if (cond == void 0) cond = "true";
    if (_i != filteredCases.length - 1) {
      left += "(".concat(cond, " ? ").concat(value, " : ");
      right += ")";
    } else {
      left += "".concat(value);
    }
  }
  return left + right;
};
var formatGroup$5 = function formatGroup(item, config2, meta) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var type2 = item.get("type");
  var properties = item.get("properties") || new Map$2();
  var mode = properties.get("mode");
  var children = item.get("children1") || new List();
  var field = properties.get("field");
  var conjunction = properties.get("conjunction");
  if (!conjunction) conjunction = defaultConjunction(config2);
  var conjunctionDefinition = config2.conjunctions[conjunction];
  var not2 = properties.get("not");
  var isRuleGroup = type2 === "rule_group";
  var isRuleGroupArray = isRuleGroup && mode != "struct";
  var groupField = isRuleGroupArray ? field : parentField;
  var groupFieldDef = getFieldConfig$8(config2, groupField) || {};
  var isSpelArray = groupFieldDef.isSpelArray;
  var fieldSeparator = config2.settings.fieldSeparator;
  var groupOperator = properties.get("operator");
  if (!groupOperator && (!mode || mode == "some")) {
    groupOperator = "some";
  }
  var realGroupOperator = checkOp(config2, groupOperator, field);
  var isGroupOpRev = realGroupOperator != groupOperator;
  var realGroupOperatorDefinition = groupOperator && getOperatorConfig$4(config2, realGroupOperator, field) || null;
  var isGroup0 = isRuleGroup && (!realGroupOperator || realGroupOperatorDefinition.cardinality == 0);
  var _formatItemValue3 = formatItemValue$2(config2, properties, meta, realGroupOperator, parentField, null), _formatItemValue4 = _slicedToArray$1(_formatItemValue3, 3), formattedValue = _formatItemValue4[0], valueSrc = _formatItemValue4[1], valueType = _formatItemValue4[2];
  var list2 = children.map(function(currentChild) {
    return formatItem$5(currentChild, config2, meta, groupField);
  }).filter(function(currentChild) {
    return typeof currentChild !== "undefined";
  });
  if (isRuleGroupArray && !isGroup0) {
    if (formattedValue == void 0) return void 0;
  } else {
    if (!list2.size) return void 0;
  }
  var omitBrackets = isRuleGroup;
  var filter4 = list2.size ? conjunctionDefinition.spelFormatConj.call(config2.ctx, list2, conjunction, not2, omitBrackets) : null;
  var ret;
  if (isRuleGroupArray) {
    var formattedField = formatField$3(meta, config2, field, parentField);
    var sep = fieldSeparator || ".";
    var getSize = sep + (isSpelArray ? "length" : "size()");
    var fullSize = "".concat(formattedField).concat(getSize);
    var filteredSize = filter4 ? "".concat(formattedField, ".?[").concat(filter4, "]").concat(getSize) : fullSize;
    var groupValue = isGroup0 ? fullSize : formattedValue;
    ret = formatExpression(meta, config2, properties, filteredSize, groupValue, realGroupOperator, valueSrc, valueType, isGroupOpRev);
  } else {
    ret = filter4;
  }
  return ret;
};
var buildFnToFormatOp$3 = function buildFnToFormatOp(operator, operatorDefinition, valueType) {
  var spelOp = operatorDefinition.spelOp;
  if (!spelOp) return void 0;
  var isSign = spelOp.includes("${0}");
  var isCompareTo = TypesWithCompareTo[valueType];
  var sop = spelOp;
  var fn;
  var cardinality = getOpCardinality$1(operatorDefinition);
  if (isCompareTo) {
    fn = function fn2(field, op2, values2, valueSrc, valueType2, opDef, operatorOptions, fieldDef) {
      var compareRes = compareToSign.replace(/\${(\w+)}/g, function(_, k) {
        return k == 0 ? field : cardinality > 1 ? values2[k - 1] : values2;
      });
      return "".concat(compareRes, " ").concat(sop, " 0");
    };
  } else if (isSign) {
    fn = function fn2(field, op2, values2, valueSrc, valueType2, opDef, operatorOptions, fieldDef) {
      return spelOp.replace(/\${(\w+)}/g, function(_, k) {
        return k == 0 ? field : cardinality > 1 ? values2[k - 1] : values2;
      });
    };
  } else if (cardinality == 0) {
    fn = function fn2(field, op2, values2, valueSrc, valueType2, opDef, operatorOptions, fieldDef) {
      return "".concat(field, " ").concat(sop);
    };
  } else if (cardinality == 1) {
    fn = function fn2(field, op2, values2, valueSrc, valueType2, opDef, operatorOptions, fieldDef) {
      return "".concat(field, " ").concat(sop, " ").concat(values2);
    };
  }
  return fn;
};
var formatExpression = function formatExpression2(meta, config2, properties, formattedField, formattedValue, operator, valueSrc, valueType) {
  var isRev = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
  var field = properties.get("field");
  var opDef = getOperatorConfig$4(config2, operator, field) || {};
  var fieldDef = getFieldConfig$8(config2, field) || {};
  var operatorOptions = properties.get("operatorOptions");
  var fn = opDef.spelFormatOp || buildFnToFormatOp$3(operator, opDef, valueType);
  if (!fn) {
    meta.errors.push("Operator ".concat(operator, " is not supported"));
    return void 0;
  }
  var args = [formattedField, operator, formattedValue, valueSrc, valueType, omit$2(opDef, opDefKeysToOmit), operatorOptions, fieldDef];
  var ret;
  ret = fn.call.apply(fn, [config2.ctx].concat(args));
  if (isRev) {
    ret = config2.settings.spelFormatReverse.call(config2.ctx, ret);
  }
  if (ret === void 0) {
    meta.errors.push("Operator ".concat(operator, " is not supported for value source ").concat(valueSrc));
  }
  return ret;
};
var checkOp = function checkOp2(config2, operator, field) {
  if (!operator) return void 0;
  var opDef = getOperatorConfig$4(config2, operator, field) || {};
  var reversedOp = opDef.reversedOp;
  var revOpDef = getOperatorConfig$4(config2, reversedOp, field) || {};
  var canFormatOp = opDef.spelOp || opDef.spelFormatOp;
  var canFormatRevOp = revOpDef.spelOp || revOpDef.spelFormatOp;
  if (!canFormatOp && !canFormatRevOp) {
    return void 0;
  }
  if (!canFormatOp && canFormatRevOp) {
    var _ref = [reversedOp, operator];
    operator = _ref[0];
    reversedOp = _ref[1];
    var _ref2 = [revOpDef, opDef];
    opDef = _ref2[0];
    revOpDef = _ref2[1];
  }
  return operator;
};
var formatRule$5 = function formatRule(item, config2, meta) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var properties = item.get("properties") || new Map$2();
  var field = properties.get("field");
  var fieldSrc = properties.get("fieldSrc");
  var operator = properties.get("operator");
  if (field == null || operator == null) return void 0;
  var realOp = checkOp(config2, operator, field);
  if (!realOp) {
    meta.errors.push("Operator ".concat(operator, " is not supported"));
    return void 0;
  }
  var isRev = realOp != operator;
  var _formatItemValue5 = formatItemValue$2(config2, properties, meta, realOp, parentField, null), _formatItemValue6 = _slicedToArray$1(_formatItemValue5, 3), formattedValue = _formatItemValue6[0], valueSrc = _formatItemValue6[1], valueType = _formatItemValue6[2];
  if (formattedValue === void 0) return void 0;
  var formattedField = formatLhs(meta, config2, field, fieldSrc, parentField);
  if (formattedField === void 0) return void 0;
  var res = formatExpression(meta, config2, properties, formattedField, formattedValue, realOp, valueSrc, valueType, isRev);
  return res;
};
var formatLhs = function formatLhs2(meta, config2, field, fieldSrc) {
  var parentField = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  if (fieldSrc === "func") return formatFunc$4(meta, config2, field, parentField);
  else return formatField$3(meta, config2, field, parentField);
};
var formatItemValue$2 = function formatItemValue(config2, properties, meta, operator, parentField) {
  var expectedValueType = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
  var field = properties.get("field");
  var iValueSrc = properties.get("valueSrc");
  var iValueType = properties.get("valueType");
  if (expectedValueType == "!case_value" || iValueType && iValueType.get(0) == "case_value") {
    field = "!case_value";
  }
  var fieldDef = getFieldConfig$8(config2, field) || {};
  var operatorDefinition = getOperatorConfig$4(config2, operator, field) || {};
  var cardinality = getOpCardinality$1(operatorDefinition);
  var iValue = properties.get("value");
  var asyncListValues = properties.get("asyncListValues");
  var valueSrcs = [];
  var valueTypes = [];
  var formattedValue;
  if (iValue != void 0) {
    var fvalue = iValue.map(function(currentValue, ind) {
      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
      var valueType = iValueType ? iValueType.get(ind) : null;
      var cValue = completeValue(currentValue, valueSrc, config2);
      var widget = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
      var fieldWidgetDef = getFieldWidgetConfig$3(config2, field, operator, widget, valueSrc, {
        forExport: true
      });
      var fv = formatValue$4(meta, config2, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDefinition, parentField, asyncListValues);
      if (fv !== void 0) {
        valueSrcs.push(valueSrc);
        valueTypes.push(valueType);
      }
      return fv;
    });
    var hasUndefinedValues = fvalue.filter(function(v) {
      return v === void 0;
    }).size > 0;
    if (!(fvalue.size < cardinality || hasUndefinedValues)) {
      formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;
    }
  }
  return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];
};
var formatValue$4 = function formatValue(meta, config2, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {
  var parentField = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : null;
  var asyncListValues = arguments.length > 10 ? arguments[10] : void 0;
  if (currentValue === void 0) return void 0;
  var ret;
  if (valueSrc === "field") {
    ret = formatField$3(meta, config2, currentValue, parentField);
  } else if (valueSrc === "func") {
    ret = formatFunc$4(meta, config2, currentValue, parentField);
  } else {
    if (typeof (fieldWidgetDef === null || fieldWidgetDef === void 0 ? void 0 : fieldWidgetDef.spelFormatValue) === "function") {
      var fn = fieldWidgetDef.spelFormatValue;
      var args = [
        currentValue,
        _objectSpread$A(_objectSpread$A({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
          asyncListValues
        }),
        //useful options: valueFormat for date/time
        omit$2(fieldWidgetDef, widgetDefKeysToOmit)
      ];
      if (operator) {
        args.push(operator);
        args.push(operatorDef);
      }
      if (valueSrc == "field") {
        var valFieldDefinition = getFieldConfig$8(config2, currentValue) || {};
        args.push(valFieldDefinition);
      }
      ret = fn.call.apply(fn, [config2.ctx].concat(args));
    } else {
      ret = spelEscape(currentValue);
    }
  }
  return ret;
};
var formatField$3 = function formatField(meta, config2, field) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  if (!field) return;
  var fieldSeparator = config2.settings.fieldSeparator;
  var fieldDefinition = getFieldConfig$8(config2, field) || {};
  var fieldParts = getFieldParts$3(field, config2);
  var fieldPartsConfigs = getFieldPartsConfigs(field, config2, parentField);
  var formatFieldFn = config2.settings.formatSpelField;
  var fieldName = formatFieldName(field, config2, meta, parentField);
  var fieldPartsMeta = fieldPartsConfigs.map(function(_ref3) {
    var _ref4 = _slicedToArray$1(_ref3, 3), key = _ref4[0], cnf = _ref4[1], parentCnf = _ref4[2];
    var parent2;
    if (parentCnf) {
      if (parentCnf.type == "!struct" || parentCnf.type == "!group" && parentCnf.mode == "struct") parent2 = cnf.isSpelMap ? "map" : "class";
      else if (parentCnf.type == "!group") parent2 = cnf.isSpelItemMap ? "[map]" : "[class]";
      else parent2 = "class";
    }
    var isSpelVariable = cnf === null || cnf === void 0 ? void 0 : cnf.isSpelVariable;
    return {
      key,
      parent: parent2,
      isSpelVariable,
      fieldSeparator
    };
  });
  var formattedField = formatFieldFn.call(config2.ctx, fieldName, parentField, fieldParts, fieldPartsMeta, fieldDefinition, config2);
  return formattedField;
};
var formatFunc$4 = function formatFunc(meta, config2, currentValue) {
  var _currentValue$get, _currentValue$get2;
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var funcKey = (_currentValue$get = currentValue.get) === null || _currentValue$get === void 0 ? void 0 : _currentValue$get.call(currentValue, "func");
  var args = (_currentValue$get2 = currentValue.get) === null || _currentValue$get2 === void 0 ? void 0 : _currentValue$get2.call(currentValue, "args");
  var funcConfig = getFuncConfig$2(config2, funcKey);
  if (!funcConfig) {
    meta.errors.push("Func ".concat(funcKey, " is not defined in config"));
    return void 0;
  }
  var formattedArgs = {};
  var gaps = [];
  var missingArgKeys = [];
  for (var argKey in funcConfig.args) {
    var _argValue, _argConfig$spelEscape;
    var argConfig = funcConfig.args[argKey];
    var fieldDef = getFieldConfig$8(config2, argConfig);
    var defaultValue = argConfig.defaultValue, isOptional = argConfig.isOptional;
    var defaultValueSrc = defaultValue !== null && defaultValue !== void 0 && defaultValue.func ? "func" : "value";
    var argVal = args ? args.get(argKey) : void 0;
    var argValue = argVal ? argVal.get("value") : void 0;
    var argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
    if (argValueSrc !== "func" && (_argValue = argValue) !== null && _argValue !== void 0 && _argValue.toJS) {
      argValue = argValue.toJS();
    }
    var argAsyncListValues = argVal ? argVal.get("asyncListValues") : void 0;
    var doEscape = (_argConfig$spelEscape = argConfig.spelEscapeForFormat) !== null && _argConfig$spelEscape !== void 0 ? _argConfig$spelEscape : true;
    var operator = null;
    var widget = getWidgetForFieldOp$3(config2, argConfig, operator, argValueSrc);
    var fieldWidgetDef = getFieldWidgetConfig$3(config2, argConfig, operator, widget, argValueSrc, {
      forExport: true
    });
    var formattedArgVal = formatValue$4(meta, config2, argValue, argValueSrc, argConfig.type, fieldWidgetDef, fieldDef, null, null, parentField, argAsyncListValues);
    if (argValue != void 0 && formattedArgVal === void 0) {
      if (argValueSrc != "func")
        meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
      return void 0;
    }
    var formattedDefaultVal = void 0;
    if (formattedArgVal === void 0 && !isOptional && defaultValue != void 0) {
      var defaultWidget = getWidgetForFieldOp$3(config2, argConfig, operator, defaultValueSrc);
      var defaultFieldWidgetDef = getFieldWidgetConfig$3(config2, argConfig, operator, defaultWidget, defaultValueSrc, {
        forExport: true
      });
      formattedDefaultVal = formatValue$4(meta, config2, defaultValue, defaultValueSrc, argConfig.type, defaultFieldWidgetDef, fieldDef, null, null, parentField, argAsyncListValues);
      if (formattedDefaultVal === void 0) {
        if (defaultValueSrc != "func")
          meta.errors.push("Can't format default value of arg ".concat(argKey, " for func ").concat(funcKey));
        return void 0;
      }
    }
    var finalFormattedVal = formattedArgVal !== null && formattedArgVal !== void 0 ? formattedArgVal : formattedDefaultVal;
    if (finalFormattedVal !== void 0) {
      var _argValue2;
      if (gaps.length) {
        var _iterator = _createForOfIteratorHelper$c(gaps), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var missedArgKey = _step.value;
            formattedArgs[missedArgKey] = void 0;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        gaps = [];
      }
      formattedArgs[argKey] = doEscape ? finalFormattedVal : (_argValue2 = argValue) !== null && _argValue2 !== void 0 ? _argValue2 : defaultValue;
    } else {
      if (!isOptional) missingArgKeys.push(argKey);
      gaps.push(argKey);
    }
  }
  if (missingArgKeys.length) {
    return void 0;
  }
  var ret;
  if (typeof funcConfig.spelFormatFunc === "function") {
    var fn = funcConfig.spelFormatFunc;
    var _args = [formattedArgs];
    ret = fn.call.apply(fn, [config2.ctx].concat(_args));
  } else if (funcConfig.spelFunc) {
    ret = funcConfig.spelFunc.replace(/\${(\w+)}/g, function(found, argKey2) {
      var _formattedArgs$argKey;
      return (_formattedArgs$argKey = formattedArgs[argKey2]) !== null && _formattedArgs$argKey !== void 0 ? _formattedArgs$argKey : found;
    });
    var optionalArgs = Object.keys(funcConfig.args || {}).reverse().filter(function(argKey2) {
      return !!funcConfig.args[argKey2].isOptional;
    });
    var _iterator2 = _createForOfIteratorHelper$c(optionalArgs), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var _argKey = _step2.value;
        if (formattedArgs[_argKey] != void 0) break;
        ret = ret.replace(new RegExp("(, )?\\${" + _argKey + "}", "g"), "");
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    ret = ret.replace(/\${(\w+)}/g, "null");
  } else {
    meta.errors.push("Func ".concat(funcKey, " is not supported"));
  }
  return ret;
};
function _createForOfIteratorHelper$b(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$b(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e2) {
        throw _e2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e3) {
    didErr = true;
    err = _e3;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null) it["return"]();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$b(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$b(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$b(o, minLen);
}
function _arrayLikeToArray$b(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function ownKeys$z(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$z(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$z(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$z(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var SpelPrimitiveTypes = {
  number: "number",
  string: "text",
  "boolean": "boolean",
  "null": "null"
  // should not be
};
var SpelPrimitiveClasses = {
  String: "text"
};
var ListValueType = "multiselect";
var isFuncableProperty = function isFuncableProperty2(p) {
  return ["length"].includes(p);
};
var isObject$a = function isObject3(v) {
  return _typeof$3(v) == "object" && v !== null && !Array.isArray(v);
};
var loadFromSpel = function loadFromSpel2(logicTree, config2) {
  return _loadFromSpel(logicTree, config2, true);
};
var _loadFromSpel = function _loadFromSpel2(spelStr, config2) {
  var returnErrors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var meta = {
    errors: []
  };
  var extendedConfig = extendConfig(config2, void 0, false);
  var conv = buildConv2(extendedConfig);
  var compiledExpression;
  var convertedObj;
  var jsTree = void 0;
  try {
    var compileRes = spel2jsExports.SpelExpressionEvaluator.compile(spelStr);
    compiledExpression = compileRes._compiledExpression;
  } catch (e2) {
    meta.errors.push(e2);
  }
  if (compiledExpression) {
    convertedObj = postprocessCompiled(compiledExpression, meta);
    logger$1.debug("convertedObj:", convertedObj, meta);
    jsTree = convertToTree(convertedObj, conv, extendedConfig, meta);
    if (jsTree && jsTree.type != "group" && jsTree.type != "switch_group") {
      jsTree = wrapInDefaultConj2(jsTree, extendedConfig, convertedObj["not"]);
    }
    logger$1.debug("jsTree:", jsTree);
  }
  var immTree = jsTree ? loadTree(jsTree) : void 0;
  if (returnErrors) {
    return [immTree, meta.errors];
  } else {
    if (meta.errors.length) console.warn("Errors while importing from SpEL:", meta.errors);
    return immTree;
  }
};
var postprocessCompiled = function postprocessCompiled2(expr, meta) {
  var parentExpr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var type2 = expr.getType();
  var children = expr.getChildren().map(function(child) {
    return postprocessCompiled2(child, meta, expr);
  });
  if (type2 == "op-or" || type2 == "op-and") {
    children = children.reduce(function(acc, child) {
      var canFlatize = child.type == type2 && !child.not;
      var flat = canFlatize ? child.children : [child];
      return [].concat(_toConsumableArray(acc), _toConsumableArray(flat));
    }, []);
  }
  if (type2 == "op-not") {
    if (children.length != 1) {
      meta.errors.push("Operator NOT should have 1 child, but got ".concat(children.length, "}"));
    }
    return _objectSpread$z(_objectSpread$z({}, children[0]), {}, {
      not: !(children[0].not || false)
    });
  }
  if (type2 == "compound") {
    children = children.filter(function(child) {
      var isListFix = child.type == "selection" && child.children.length == 1 && child.children[0].type == "boolean" && child.children[0].val == true;
      return !isListFix;
    });
    var selection = children.find(function(child) {
      return child.type == "selection";
    });
    if (selection && selection.children.length != 1) {
      meta.errors.push("Selection should have 1 child, but got ".concat(selection.children.length));
    }
    var filter4 = selection ? selection.children[0] : null;
    var lastChild = children[children.length - 1];
    var isSize = lastChild.type == "method" && lastChild.val.methodName == "size" || lastChild.type == "!func" && lastChild.methodName == "size";
    var isLength2 = lastChild.type == "property" && lastChild.val == "length";
    var sourceParts = children.filter(function(child) {
      return child !== selection && child !== lastChild;
    });
    var source = {
      type: "compound",
      children: sourceParts
    };
    var isAggr = (isSize || isLength2) && convertPath(sourceParts) != null;
    if (isAggr) {
      return {
        type: "!aggr",
        filter: filter4,
        source
      };
    }
    children = children.filter(function(child) {
      var isThis = child.type == "variable" && child.val == "this";
      var isRoot = child.type == "variable" && child.val == "root";
      return !(isThis || isRoot);
    });
    children = children.map(function(child) {
      if (child.type == "indexer" && child.children.length == 1) {
        return {
          type: "indexer",
          val: child.children[0].val,
          itype: child.children[0].type
        };
      } else {
        return child;
      }
    });
    if (lastChild.type == "!func") {
      var ret = {};
      var curr = ret;
      do {
        var _lastChild, _lastChild2;
        Object.assign(curr, lastChild);
        children = children.filter(function(child) {
          return child !== lastChild;
        });
        lastChild = children[children.length - 1];
        if (((_lastChild2 = lastChild) === null || _lastChild2 === void 0 ? void 0 : _lastChild2.type) == "!func") {
          curr.obj = {};
          curr = curr.obj;
        } else {
          if (children.length > 1) {
            curr.obj = {
              type: "compound",
              children
            };
          } else {
            curr.obj = lastChild;
          }
        }
      } while (((_lastChild = lastChild) === null || _lastChild === void 0 ? void 0 : _lastChild.type) == "!func");
      return ret;
    }
  }
  var val;
  try {
    if (expr.getRaw) {
      val = expr.getRaw();
    } else if (expr.getValue.length == 0) {
      val = expr.getValue();
    }
  } catch (e2) {
    logger$1.error("[spel2js] Error in getValue()", e2);
  }
  if (type2 == "ternary") {
    val = flatizeTernary2(children);
  }
  if (_typeof$3(val) === "object" && val !== null) {
    if (val.methodName || val.functionName) {
      val.args = val.args.map(function(child) {
        return postprocessCompiled2(child, meta, expr);
      });
    }
  }
  if (type2 == "list") {
    val = val.map(function(item) {
      return postprocessCompiled2(item, meta, expr);
    });
    if (!parentExpr && val.length == 1) {
      return val[0];
    }
  }
  if (type2 == "constructorref") {
    var qid = children.find(function(child) {
      return child.type == "qualifiedidentifier";
    });
    var cls = qid === null || qid === void 0 ? void 0 : qid.val;
    if (!cls) {
      meta.errors.push("Can't find qualifiedidentifier in constructorref children: ".concat(JSON.stringify(children)));
      return void 0;
    }
    var args = children.filter(function(child) {
      return child.type != "qualifiedidentifier";
    });
    return {
      type: "!new",
      cls,
      args
    };
  }
  if (type2 == "typeref") {
    var _qid = children.find(function(child) {
      return child.type == "qualifiedidentifier";
    });
    var _cls = _qid === null || _qid === void 0 ? void 0 : _qid.val;
    if (!_cls) {
      meta.errors.push("Can't find qualifiedidentifier in typeref children: ".concat(JSON.stringify(children)));
      return void 0;
    }
    children.filter(function(child) {
      return child.type != "qualifiedidentifier";
    });
    return {
      type: "!type",
      cls: _cls
    };
  }
  if (type2 == "function" || type2 == "method") {
    var _val = val, functionName = _val.functionName, methodName = _val.methodName, _args2 = _val.args;
    return {
      type: "!func",
      methodName: functionName || methodName,
      isVar: type2 == "function",
      args: _args2
    };
  }
  return {
    type: type2,
    children,
    val
  };
};
var flatizeTernary2 = function flatizeTernary3(children) {
  var flat = [];
  function _processTernaryChildren(tern) {
    var _tern = _slicedToArray$1(tern, 3), cond = _tern[0], if_val = _tern[1], else_val = _tern[2];
    flat.push([cond, if_val]);
    if ((else_val === null || else_val === void 0 ? void 0 : else_val.type) == "ternary") {
      _processTernaryChildren(else_val.children);
    } else {
      flat.push([void 0, else_val]);
    }
  }
  _processTernaryChildren(children);
  return flat;
};
var buildConv2 = function buildConv3(config2) {
  var operators2 = {};
  var _loop = function _loop4(opKey2) {
    var opConfig = config2.operators[opKey2];
    if (opConfig.spelOps) {
      opConfig.spelOps.forEach(function(spelOp2) {
        var opk2 = spelOp2;
        if (!operators2[opk2]) operators2[opk2] = [];
        operators2[opk2].push(opKey2);
      });
    } else if (opConfig.spelOp) {
      var opk = opConfig.spelOp;
      if (!operators2[opk]) operators2[opk] = [];
      operators2[opk].push(opKey2);
    } else {
      logger$1.log("[spel] No spelOp for operator ".concat(opKey2));
    }
  };
  for (var opKey in config2.operators) {
    _loop(opKey);
  }
  var conjunctions2 = {};
  for (var conjKey in config2.conjunctions) {
    var conjunctionDefinition = config2.conjunctions[conjKey];
    var ck = conjunctionDefinition.spelConj || conjKey.toLowerCase();
    conjunctions2[ck] = conjKey;
  }
  var funcs2 = {};
  var _iterator = _createForOfIteratorHelper$b(iterateFuncs(config2)), _step;
  try {
    var _loop22 = function _loop23() {
      var _step$value = _slicedToArray$1(_step.value, 2), funcPath = _step$value[0], funcConfig = _step$value[1];
      var fks = [];
      var spelFunc = funcConfig.spelFunc;
      if (typeof spelFunc === "string") {
        var optionalArgs = Object.keys(funcConfig.args || {}).reverse().filter(function(argKey) {
          return !!funcConfig.args[argKey].isOptional || funcConfig.args[argKey].defaultValue != void 0;
        });
        var funcSignMain = spelFunc.replace(/\${(\w+)}/g, function(_, _k) {
          return "?";
        });
        var funcSignsOptional = optionalArgs.reduce(function(acc, argKey) {
          return [].concat(_toConsumableArray(acc), [[argKey].concat(_toConsumableArray(acc[acc.length - 1] || []))]);
        }, []).map(function(optionalArgKeys) {
          return spelFunc.replace(/(?:, )?\${(\w+)}/g, function(found, a2) {
            return optionalArgKeys.includes(a2) ? "" : found;
          }).replace(/\${(\w+)}/g, function(_, _k) {
            return "?";
          });
        });
        fks = [funcSignMain].concat(_toConsumableArray(funcSignsOptional));
      }
      var _iterator3 = _createForOfIteratorHelper$b(fks), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var _fk = _step3.value;
          if (!funcs2[_fk]) funcs2[_fk] = [];
          funcs2[_fk].push(funcPath);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      _loop22();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var valueFuncs = {};
  for (var w in config2.widgets) {
    var widgetDef = config2.widgets[w];
    var spelImportFuncs = widgetDef.spelImportFuncs;
    widgetDef.type;
    if (spelImportFuncs) {
      var _iterator2 = _createForOfIteratorHelper$b(spelImportFuncs), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var fk = _step2.value;
          if (typeof fk === "string") {
            var fs = fk.replace(/\${(\w+)}/g, function(_, k) {
              return "?";
            });
            var argsOrder = _toConsumableArray(fk.matchAll(/\${(\w+)}/g)).map(function(_ref) {
              var _ref2 = _slicedToArray$1(_ref, 2), _ = _ref2[0], k = _ref2[1];
              return k;
            });
            if (!valueFuncs[fs]) valueFuncs[fs] = [];
            valueFuncs[fs].push({
              w,
              argsOrder
            });
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }
  var opFuncs = {};
  for (var op2 in config2.operators) {
    var opDef = config2.operators[op2];
    var spelOp = opDef.spelOp;
    if (spelOp !== null && spelOp !== void 0 && spelOp.includes("${0}")) {
      var _fs = spelOp.replace(/\${(\w+)}/g, function(_, k) {
        return "?";
      });
      var _argsOrder = _toConsumableArray(spelOp.matchAll(/\${(\w+)}/g)).map(function(_ref3) {
        var _ref4 = _slicedToArray$1(_ref3, 2);
        _ref4[0];
        var k = _ref4[1];
        return k;
      });
      if (!opFuncs[_fs]) opFuncs[_fs] = [];
      opFuncs[_fs].push({
        op: op2,
        argsOrder: _argsOrder
      });
    }
  }
  var compareToSS = compareToSign.replace(/\${(\w+)}/g, function(_, k) {
    return "?";
  });
  opFuncs[compareToSS] = [{
    op: "!compare",
    argsOrder: ["0", "1"]
  }];
  return {
    operators: operators2,
    conjunctions: conjunctions2,
    funcs: funcs2,
    valueFuncs,
    opFuncs
  };
};
var convertToTree = function convertToTree2(spel, conv, config2, meta) {
  var _spel$_groupField;
  var parentSpel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  if (!spel) return void 0;
  spel._groupField = (_spel$_groupField = spel._groupField) !== null && _spel$_groupField !== void 0 ? _spel$_groupField : parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField;
  var res, canParseAsArg = true;
  if (spel.type.indexOf("op-") === 0 || spel.type === "matches") {
    res = convertOp2(spel, conv, config2, meta, parentSpel);
  } else if (spel.type == "!aggr") {
    var _groupFilter;
    var groupFieldValue = convertToTree2(spel.source, conv, config2, meta, spel);
    spel._groupField = groupFieldValue === null || groupFieldValue === void 0 ? void 0 : groupFieldValue.value;
    var groupFilter = convertToTree2(spel.filter, conv, config2, meta, spel);
    if (((_groupFilter = groupFilter) === null || _groupFilter === void 0 ? void 0 : _groupFilter.type) == "rule") {
      groupFilter = wrapInDefaultConj2(groupFilter, config2, spel.filter.not);
    }
    res = {
      groupFilter,
      groupFieldValue
    };
    if (!parentSpel) {
      res = void 0;
      meta.errors.push("Unexpected !aggr in root");
      canParseAsArg = false;
    }
  } else if (spel.type == "ternary") {
    var children1 = {};
    spel.val.forEach(function(v) {
      var _v = _slicedToArray$1(v, 2), cond = _v[0], val = _v[1];
      var caseI = buildCase(cond, val, conv, config2, meta, spel);
      if (caseI) {
        children1[caseI.id] = caseI;
      }
    });
    res = {
      type: "switch_group",
      id: uuid(),
      children1,
      properties: {}
    };
  }
  if (!res && canParseAsArg) {
    res = convertArg(spel, conv, config2, meta, parentSpel);
  }
  if (res && !res.type && !parentSpel) {
    var sw = buildSimpleSwitch(spel, conv, config2, meta);
    if (sw) {
      res = sw;
    } else {
      res = void 0;
      meta.errors.push("Can't convert rule of type ".concat(spel.type, ", it looks like var/literal"));
    }
  }
  return res;
};
var convertOp2 = function convertOp3(spel, conv, config2, meta) {
  var parentSpel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var res;
  var op2 = spel.type.startsWith("op-") ? spel.type.slice("op-".length) : spel.type;
  var isUnary = (op2 == "minus" || op2 == "plus") && spel.children.length == 1;
  if (isUnary) {
    var negative = spel.negative;
    if (op2 == "minus") {
      negative = !negative;
    }
    spel.children[0].negative = negative;
    return convertToTree(spel.children[0], conv, config2, meta, parentSpel);
  }
  var isBetweenNormal = op2 == "and" && spel.children.length == 2 && spel.children[0].type == "op-ge" && spel.children[1].type == "op-le";
  var isBetweenRev = op2 == "or" && spel.children.length == 2 && spel.children[0].type == "op-lt" && spel.children[1].type == "op-gt";
  var isBetween2 = isBetweenNormal || isBetweenRev;
  if (isBetween2) {
    var _spel$children$0$chil = _slicedToArray$1(spel.children[0].children, 2), left = _spel$children$0$chil[0], from2 = _spel$children$0$chil[1];
    var _spel$children$1$chil = _slicedToArray$1(spel.children[1].children, 2), right = _spel$children$1$chil[0], to2 = _spel$children$1$chil[1];
    var isSameSource = compareArgs(left, right, spel, conv, config2, meta);
    if (isSameSource) {
      from2.val;
      to2.val;
      var oneSpel = {
        type: "op-between",
        children: [left, from2, to2],
        not: isBetweenRev
      };
      oneSpel._groupField = parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField;
      return convertOp3(oneSpel, conv, config2, meta, parentSpel);
    }
  }
  var opKeys = conv.operators[op2];
  if (op2 == "eq" && spel.children[1].type == "null") {
    opKeys = ["is_null"];
  } else if (op2 == "ne" && spel.children[1].type == "null") {
    opKeys = ["is_not_null"];
  } else if (op2 == "le" && spel.children[1].type == "string" && spel.children[1].val == "") {
    opKeys = ["is_empty"];
  } else if (op2 == "gt" && spel.children[1].type == "string" && spel.children[1].val == "") {
    opKeys = ["is_not_empty"];
  } else if (op2 == "between") {
    opKeys = ["between"];
  }
  var convertChildren = function convertChildren2() {
    var _newChildren;
    var newChildren = spel.children.map(function(child) {
      return convertToTree(child, conv, config2, meta, spel);
    });
    if (newChildren.length >= 2 && ((_newChildren = newChildren) === null || _newChildren === void 0 || (_newChildren = _newChildren[0]) === null || _newChildren === void 0 ? void 0 : _newChildren.type) == "!compare") {
      newChildren = newChildren[0].children;
    }
    return newChildren;
  };
  if (op2 == "and" || op2 == "or") {
    var children1 = {};
    var vals = convertChildren();
    vals.forEach(function(v) {
      if (v) {
        var id2 = uuid();
        v.id = id2;
        if (v.type != void 0) {
          children1[id2] = v;
        } else {
          meta.errors.push("Bad item in AND/OR: ".concat(JSON.stringify(v)));
        }
      }
    });
    res = {
      type: "group",
      id: uuid(),
      children1,
      properties: {
        conjunction: conv.conjunctions[op2],
        not: spel.not
      }
    };
  } else if (opKeys) {
    var _fieldObj$groupFieldV, _convertedArgs, _opConfig;
    var _vals = convertChildren();
    var fieldObj = _vals[0];
    var convertedArgs = _vals.slice(1);
    var groupField = fieldObj === null || fieldObj === void 0 || (_fieldObj$groupFieldV = fieldObj.groupFieldValue) === null || _fieldObj$groupFieldV === void 0 ? void 0 : _fieldObj$groupFieldV.value;
    var opArg = (_convertedArgs = convertedArgs) === null || _convertedArgs === void 0 ? void 0 : _convertedArgs[0];
    var opKey = opKeys[0];
    if (opKeys.length > 1) {
      var _vals$, _vals$2;
      var valueType = ((_vals$ = _vals[0]) === null || _vals$ === void 0 ? void 0 : _vals$.valueType) || ((_vals$2 = _vals[1]) === null || _vals$2 === void 0 ? void 0 : _vals$2.valueType);
      var field = fieldObj === null || fieldObj === void 0 ? void 0 : fieldObj.value;
      var widgets2 = opKeys.map(function(op3) {
        return {
          op: op3,
          widget: getWidgetForFieldOp$3(config2, field, op3)
        };
      });
      logger$1.warn("[spel] Spel operator ".concat(op2, " can be mapped to ").concat(opKeys, "."), "widgets:", widgets2, "vals:", _vals, "valueType=", valueType);
      if (op2 == "eq" || op2 == "ne") {
        var ws = widgets2.find(function(_ref5) {
          _ref5.op;
          var widget = _ref5.widget;
          return widget && widget != "field";
        });
        if (ws) {
          opKey = ws.op;
        }
      }
    }
    if (fieldObj !== null && fieldObj !== void 0 && fieldObj.groupFieldValue) {
      if (opArg && opArg.groupFieldValue && opArg.groupFieldValue.valueSrc == "field" && opArg.groupFieldValue.value == groupField) {
        opKey = "all";
        convertedArgs = [];
      } else if (opKey == "equal" && opArg.valueSrc == "value" && opArg.valueType == "number" && opArg.value == 0) {
        opKey = "none";
        convertedArgs = [];
      } else if (opKey == "greater" && opArg.valueSrc == "value" && opArg.valueType == "number" && opArg.value == 0) {
        opKey = "some";
        convertedArgs = [];
      }
    }
    var opConfig = config2.operators[opKey];
    var reversedOpConfig = config2.operators[(_opConfig = opConfig) === null || _opConfig === void 0 ? void 0 : _opConfig.reversedOp];
    var opNeedsReverse = spel.not && ["between"].includes(opKey);
    var opCanReverse = !!reversedOpConfig;
    var canRev = opCanReverse && (!!config2.settings.reverseOperatorsForNot || opNeedsReverse);
    var needRev = spel.not && canRev || opNeedsReverse;
    if (needRev) {
      opKey = opConfig.reversedOp;
      opConfig = config2.operators[opKey];
      spel.not = !spel.not;
    }
    var needWrapWithNot = !!spel.not;
    spel.not = false;
    if (!fieldObj) ;
    else if (fieldObj.groupFieldValue) {
      if (fieldObj.groupFieldValue.valueSrc != "field") {
        meta.errors.push("Expected group field ".concat(JSON.stringify(fieldObj)));
      }
      res = buildRuleGroup(fieldObj, opKey, convertedArgs, config2, meta);
    } else {
      if (fieldObj.valueSrc != "field" && fieldObj.valueSrc != "func") {
        meta.errors.push("Expected field/func at LHS, but got ".concat(JSON.stringify(fieldObj)));
      }
      var _field = fieldObj.value;
      res = buildRule(config2, meta, _field, opKey, convertedArgs, spel);
    }
    if (needWrapWithNot) {
      if (res.type !== "group") {
        res = wrapInDefaultConj2(res, config2, true);
      } else {
        res.properties.not = !res.properties.not;
      }
    }
  } else {
    if (!parentSpel) {
      res = buildSimpleSwitch(spel, conv, config2, meta);
    }
  }
  return res;
};
var convertPath = function convertPath2(parts) {
  var meta = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var expectingField = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var isError = false;
  var res = parts.map(function(c2) {
    if (c2.type == "variable" || c2.type == "property" || c2.type == "indexer" && c2.itype == "string") {
      return c2.val;
    } else {
      var _meta$errors, _meta$errors$push;
      isError = true;
      expectingField && (meta === null || meta === void 0 || (_meta$errors = meta.errors) === null || _meta$errors === void 0 || (_meta$errors$push = _meta$errors.push) === null || _meta$errors$push === void 0 ? void 0 : _meta$errors$push.call(_meta$errors, "Unexpected item in field path compound: ".concat(JSON.stringify(c2))));
    }
  });
  return !isError ? res : void 0;
};
var convertArg = function convertArg2(spel, conv, config2, meta) {
  var _spel$_groupField2, _config$settings$case;
  var parentSpel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  if (spel == void 0) return void 0;
  var fieldSeparator = config2.settings.fieldSeparator;
  spel._groupField = (_spel$_groupField2 = spel._groupField) !== null && _spel$_groupField2 !== void 0 ? _spel$_groupField2 : parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField;
  if (spel.type == "variable" || spel.type == "property") {
    var field = normalizeField(config2, spel.val, spel._groupField);
    var fieldConfig = getFieldConfig$8(config2, field);
    var isVariable = spel.type == "variable";
    return {
      valueSrc: "field",
      valueType: fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type,
      isVariable,
      value: field
    };
  } else if (spel.type == "compound") {
    var parts = convertPath(spel.children, meta);
    if (parts) {
      var _spel$children;
      var _field2 = normalizeField(config2, parts.join(fieldSeparator), spel._groupField);
      var _fieldConfig = getFieldConfig$8(config2, _field2);
      var _isVariable = ((_spel$children = spel.children) === null || _spel$children === void 0 || (_spel$children = _spel$children[0]) === null || _spel$children === void 0 ? void 0 : _spel$children.type) == "variable";
      return {
        valueSrc: "field",
        valueType: _fieldConfig === null || _fieldConfig === void 0 ? void 0 : _fieldConfig.type,
        isVariable: _isVariable,
        value: _field2
      };
    }
  } else if (SpelPrimitiveTypes[spel.type]) {
    var value = spel.val;
    var valueType = SpelPrimitiveTypes[spel.type];
    if (spel.negative) {
      value = -value;
    }
    return {
      valueSrc: "value",
      valueType,
      value
    };
  } else if (spel.type == "!new" && SpelPrimitiveClasses[spel.cls.at(-1)]) {
    var args = spel.args.map(function(v) {
      return convertArg2(v, conv, config2, meta, spel);
    });
    var _value = args === null || args === void 0 ? void 0 : args[0];
    var _valueType = SpelPrimitiveClasses[spel.cls.at(-1)];
    return _objectSpread$z(_objectSpread$z({}, _value), {}, {
      valueType: _valueType
    });
  } else if (spel.type == "list") {
    var _values$;
    var values2 = spel.val.map(function(v) {
      return convertArg2(v, conv, config2, meta, spel);
    });
    values2.length ? (_values$ = values2[0]) === null || _values$ === void 0 ? void 0 : _values$.valueType : null;
    var _value2 = values2.map(function(v) {
      return v === null || v === void 0 ? void 0 : v.value;
    });
    var _valueType2 = ListValueType;
    return {
      valueSrc: "value",
      valueType: _valueType2,
      value: _value2
    };
  } else if (spel.type === "op-plus" && (parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel.type) === "ternary" && ((_config$settings$case = config2.settings.caseValueField) === null || _config$settings$case === void 0 ? void 0 : _config$settings$case.type) === "case_value") {
    return buildCaseValueConcat(spel, conv, config2, meta);
  }
  var maybe = convertFunc(spel, conv, config2, meta, parentSpel);
  if (maybe !== void 0) {
    return maybe;
  }
  meta.errors.push("Can't convert arg of type ".concat(spel.type));
  return void 0;
};
var buildFuncSignatures = function buildFuncSignatures2(spel) {
  var brns = [{
    s: "",
    params: [],
    objs: []
  }];
  _buildFuncSignatures(spel, brns);
  return brns.map(function(_ref6) {
    var s2 = _ref6.s, params = _ref6.params;
    return {
      s: s2,
      params
    };
  }).reverse().filter(function(_ref7) {
    var s2 = _ref7.s;
    return s2 !== "" && s2 !== "?";
  });
};
var _buildFuncSignatures = function _buildFuncSignatures2(spel, brns) {
  var params = [], s2 = "";
  var type2 = spel.type, methodName = spel.methodName;
  spel.val;
  var obj = spel.obj, args = spel.args, isVar = spel.isVar, cls = spel.cls, children = spel.children;
  var lastChild = children === null || children === void 0 ? void 0 : children[children.length - 1];
  var currBrn = brns[brns.length - 1];
  if (type2 === "!func") {
    var o = obj;
    while (o) {
      var _currBrn$params;
      var _buildFuncSignatures22 = _buildFuncSignatures2(_objectSpread$z(_objectSpread$z({}, o), {}, {
        obj: null
      }), [{}]), _buildFuncSignatures3 = _slicedToArray$1(_buildFuncSignatures22, 2), s1 = _buildFuncSignatures3[0], params1 = _buildFuncSignatures3[1];
      if (s1 !== "?") {
        var newBrn = {
          s: currBrn.s,
          params: _toConsumableArray(currBrn.params),
          objs: _toConsumableArray(currBrn.objs)
        };
        currBrn.objs.unshift("?");
        currBrn.params.unshift(o);
        brns.push(newBrn);
        currBrn = brns[brns.length - 1];
      }
      currBrn.objs.unshift(s1);
      (_currBrn$params = currBrn.params).unshift.apply(_currBrn$params, _toConsumableArray(params1));
      o = o.type === "!func" ? o.obj : null;
    }
    var _iterator4 = _createForOfIteratorHelper$b(brns), _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
        var _brn$objs;
        var brn = _step4.value;
        params = [].concat(_toConsumableArray((brn === null || brn === void 0 ? void 0 : brn.params) || []), _toConsumableArray(args || []));
        s2 = "";
        if (brn !== null && brn !== void 0 && (_brn$objs = brn.objs) !== null && _brn$objs !== void 0 && _brn$objs.length) s2 += brn.objs.join(".") + ".";
        s2 += (isVar ? "#" : "") + methodName;
        s2 += "(" + (args || []).map(function(_) {
          return "?";
        }).join(", ") + ")";
        brn.s = s2;
        brn.params = params;
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  } else if (type2 === "!new") {
    params = args || [];
    s2 = "new ".concat(cls.join("."), "(").concat(params.map(function(_) {
      return "?";
    }).join(", "), ")");
  } else if (type2 === "!type") {
    s2 = "T(".concat(cls.join("."), ")");
  } else if (type2 === "compound" && lastChild.type === "property" && isFuncableProperty(lastChild.val)) {
    s2 = children.map(function(c2) {
      var _params;
      if (c2 === lastChild) return c2.val;
      var _buildFuncSignatures4 = _buildFuncSignatures2(_objectSpread$z(_objectSpread$z({}, c2), {}, {
        obj: null
      }), [{}]), _buildFuncSignatures5 = _slicedToArray$1(_buildFuncSignatures4, 2), s12 = _buildFuncSignatures5[0], params12 = _buildFuncSignatures5[1];
      (_params = params).push.apply(_params, _toConsumableArray(params12));
      return s12;
    }).join(".");
  } else {
    params = [spel];
    s2 = "?";
  }
  if (currBrn) {
    currBrn.s = s2;
    currBrn.params = params;
  }
  return [s2, params];
};
var convertFunc = function convertFunc2(spel, conv, config2, meta) {
  var _fsigns$;
  var parentSpel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var convertFuncArg = function convertFuncArg2(v) {
    return convertToTree(v, conv, config2, meta, spel);
  };
  var fsigns = buildFuncSignatures(spel);
  var firstSign = fsigns === null || fsigns === void 0 || (_fsigns$ = fsigns[0]) === null || _fsigns$ === void 0 ? void 0 : _fsigns$.s;
  if (fsigns.length) logger$1.debug("Signatures for ", spel, ":", firstSign, fsigns);
  var maybeValue = convertFuncToValue(spel, conv, config2, meta, parentSpel, fsigns, convertFuncArg);
  if (maybeValue !== void 0) return maybeValue;
  var maybeOp = convertFuncToOp(spel, conv, config2, meta, parentSpel, fsigns, convertFuncArg);
  if (maybeOp !== void 0) return maybeOp;
  var funcKey, funcConfig, argsObj;
  var _iterator5 = _createForOfIteratorHelper$b(fsigns), _step5;
  try {
    var _loop32 = function _loop33() {
      var _step5$value = _step5.value, s2 = _step5$value.s, params = _step5$value.params;
      var funcKeys = conv.funcs[s2];
      if (funcKeys) {
        funcKey = funcKeys[0];
        funcConfig = getFuncConfig$2(config2, funcKey);
        var _funcConfig = funcConfig, spelFunc = _funcConfig.spelFunc;
        var argsArr = params.map(convertFuncArg);
        var argsOrder = _toConsumableArray(spelFunc.matchAll(/\${(\w+)}/g)).map(function(_ref8) {
          var _ref9 = _slicedToArray$1(_ref8, 2), _ = _ref9[0], k = _ref9[1];
          return k;
        });
        argsObj = Object.fromEntries(argsOrder.map(function(argKey2, i2) {
          return [argKey2, argsArr[i2]];
        }));
        return 1;
      }
    };
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
      if (_loop32()) break;
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  if (!funcKey) {
    var _iterator6 = _createForOfIteratorHelper$b(iterateFuncs(config2)), _step6;
    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
        var _step6$value = _slicedToArray$1(_step6.value, 2), f = _step6$value[0], fc = _step6$value[1];
        if (fc.spelImport) {
          var parsed = void 0;
          try {
            parsed = fc.spelImport(spel);
          } catch (_e) {
          }
          if (parsed) {
            funcKey = f;
            funcConfig = getFuncConfig$2(config2, funcKey);
            argsObj = {};
            for (var argKey in parsed) {
              argsObj[argKey] = convertFuncArg(parsed[argKey]);
            }
          }
        }
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }
  }
  if (funcKey) {
    var funcArgs = {};
    for (var _argKey in funcConfig.args) {
      var argConfig = funcConfig.args[_argKey];
      var argVal = argsObj[_argKey];
      if (argVal === void 0) {
        argVal = argConfig === null || argConfig === void 0 ? void 0 : argConfig.defaultValue;
        if (argVal === void 0) {
          if (argConfig !== null && argConfig !== void 0 && argConfig.isOptional) ;
          else {
            meta.errors.push("No value for arg ".concat(_argKey, " of func ").concat(funcKey));
            return void 0;
          }
        } else {
          var _argVal;
          argVal = {
            value: argVal,
            valueSrc: (_argVal = argVal) !== null && _argVal !== void 0 && _argVal.func ? "func" : "value",
            valueType: argConfig.type
          };
        }
      }
      if (argVal) funcArgs[_argKey] = argVal;
    }
    return {
      valueSrc: "func",
      value: {
        func: funcKey,
        args: funcArgs
      },
      valueType: funcConfig.returnType
    };
  }
  var methodName = spel.methodName;
  if (methodName) meta.errors.push("Signature ".concat(firstSign, " - failed to convert"));
  return void 0;
};
var convertFuncToValue = function convertFuncToValue2(spel, conv, config2, meta, parentSpel, fsigns, convertFuncArg) {
  var errs, foundSign, foundWidget;
  var candidates = [];
  for (var w in config2.widgets) {
    var widgetDef = config2.widgets[w];
    var spelImportFuncs = widgetDef.spelImportFuncs;
    if (spelImportFuncs) {
      for (var i2 = 0; i2 < spelImportFuncs.length; i2++) {
        var fj = spelImportFuncs[i2];
        if (isObject$a(fj)) {
          var bag = {};
          if (isJsonCompatible(fj, spel, bag)) {
            for (var k in bag) {
              bag[k] = convertFuncArg(bag[k]);
            }
            candidates.push({
              s: "widgets.".concat(w, ".spelImportFuncs[").concat(i2, "]"),
              w,
              argsObj: bag
            });
          }
        }
      }
    }
  }
  var _iterator7 = _createForOfIteratorHelper$b(fsigns), _step7;
  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
      var _step7$value = _step7.value, _s = _step7$value.s, params = _step7$value.params;
      var found = conv.valueFuncs[_s] || [];
      var _iterator8 = _createForOfIteratorHelper$b(found), _step8;
      try {
        var _loop4 = function _loop42() {
          var _step8$value = _step8.value, w2 = _step8$value.w, argsOrder = _step8$value.argsOrder;
          var argsArr = params.map(convertFuncArg);
          var argsObj2 = Object.fromEntries(argsOrder.map(function(argKey, i3) {
            return [argKey, argsArr[i3]];
          }));
          candidates.push({
            s: _s,
            w: w2,
            argsObj: argsObj2
          });
        };
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
          _loop4();
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }
  for (var _i = 0, _candidates = candidates; _i < _candidates.length; _i++) {
    var _candidates$_i = _candidates[_i], s2 = _candidates$_i.s, _w = _candidates$_i.w, argsObj = _candidates$_i.argsObj;
    var _widgetDef = config2.widgets[_w];
    var spelImportValue5 = _widgetDef.spelImportValue, type2 = _widgetDef.type;
    foundWidget = _w;
    foundSign = s2;
    errs = [];
    for (var _k2 in argsObj) {
      if (!["value"].includes(argsObj[_k2].valueSrc)) {
        errs.push("".concat(_k2, " has unsupported value src ").concat(argsObj[_k2].valueSrc));
      }
    }
    var value = argsObj.v.value;
    if (spelImportValue5 && !errs.length) {
      var _spelImportValue$call = spelImportValue5.call(config2.ctx, argsObj.v, _widgetDef, argsObj);
      var _spelImportValue$call2 = _slicedToArray$1(_spelImportValue$call, 2);
      value = _spelImportValue$call2[0];
      errs = _spelImportValue$call2[1];
      if (errs && !Array.isArray(errs)) errs = [errs];
    }
    if (!errs.length) {
      return {
        valueSrc: "value",
        valueType: type2,
        value
      };
    }
  }
  if (foundWidget && errs.length) {
    meta.errors.push("Signature ".concat(foundSign, " - looks like convertable to ").concat(foundWidget, ", but: ").concat(errs.join("; ")));
  }
  return void 0;
};
var convertFuncToOp = function convertFuncToOp2(spel, conv, config2, meta, parentSpel, fsigns, convertFuncArg) {
  var errs, opKey, foundSign;
  var _iterator9 = _createForOfIteratorHelper$b(fsigns), _step9;
  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
      var _step9$value = _step9.value, s2 = _step9$value.s, params = _step9$value.params;
      var found = conv.opFuncs[s2] || [];
      var _iterator10 = _createForOfIteratorHelper$b(found), _step10;
      try {
        var _loop5 = function _loop52() {
          var _argsArr$filter$find;
          var _step10$value = _step10.value, op2 = _step10$value.op, argsOrder = _step10$value.argsOrder;
          var argsArr = params.map(convertFuncArg);
          opKey = op2;
          if (op2 === "!compare") {
            if (parentSpel.type.startsWith("op-") && parentSpel.children.length == 2 && parentSpel.children[1].type == "number" && parentSpel.children[1].val === 0) {
              return {
                v: {
                  type: "!compare",
                  children: argsArr
                }
              };
            } else {
              errs.push("Result of compareTo() should be compared to 0");
            }
          }
          foundSign = s2;
          errs = [];
          var opDef = config2.operators[opKey];
          var spelOp = opDef.spelOp, valueTypes = opDef.valueTypes;
          var argsObj = Object.fromEntries(argsOrder.map(function(argKey, i2) {
            return [argKey, argsArr[i2]];
          }));
          var field = argsObj["0"];
          var convertedArgs = Object.keys(argsObj).filter(function(k) {
            return parseInt(k) > 0;
          }).map(function(k) {
            return argsObj[k];
          });
          var valueType = (_argsArr$filter$find = argsArr.filter(function(a2) {
            return !!a2;
          }).find(function(_ref10) {
            var valueSrc = _ref10.valueSrc;
            return valueSrc === "value";
          })) === null || _argsArr$filter$find === void 0 ? void 0 : _argsArr$filter$find.valueType;
          if (valueTypes && valueType && !valueTypes.includes(valueType)) {
            errs.push("Op supports types ".concat(valueTypes, ", but got ").concat(valueType));
          }
          if (!errs.length) {
            return {
              v: buildRule(config2, meta, field, opKey, convertedArgs, spel)
            };
          }
        }, _ret;
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
          _ret = _loop5();
          if (_ret) return _ret.v;
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }
  if (opKey && errs.length) {
    meta.errors.push("Signature ".concat(foundSign, " - looks like convertable to ").concat(opKey, ", but: ").concat(errs.join("; ")));
  }
  return void 0;
};
var buildRule = function buildRule2(config2, meta, field, opKey, convertedArgs, spel) {
  var _field3, _opConfig2;
  if (convertedArgs.filter(function(v) {
    return v === void 0;
  }).length) {
    return void 0;
  }
  var fieldSrc = (_field3 = field) !== null && _field3 !== void 0 && _field3.func ? "func" : "field";
  if (isObject$a(field) && field.valueSrc) {
    fieldSrc = field.valueSrc;
    field = field.value;
  }
  var fieldConfig = getFieldConfig$8(config2, field);
  if (!fieldConfig) {
    meta.errors.push("No config for field ".concat(field));
    return void 0;
  }
  var parentFieldConfig = getFieldConfig$8(config2, spel === null || spel === void 0 ? void 0 : spel._groupField);
  var isRuleGroup = fieldConfig.type == "!group";
  isRuleGroup && fieldConfig.mode == "array";
  var isInRuleGroup = (parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.type) == "!group";
  var opConfig = config2.operators[opKey];
  var reversedOpConfig = config2.operators[(_opConfig2 = opConfig) === null || _opConfig2 === void 0 ? void 0 : _opConfig2.reversedOp];
  var opNeedsReverse = (spel === null || spel === void 0 ? void 0 : spel.not) && ["between"].includes(opKey);
  var opCanReverse = !!reversedOpConfig;
  var canRev = opCanReverse && (!!config2.settings.reverseOperatorsForNot || opNeedsReverse || !isRuleGroup && isInRuleGroup);
  var needRev = (spel === null || spel === void 0 ? void 0 : spel.not) && canRev || opNeedsReverse;
  if (needRev) {
    opKey = opConfig.reversedOp;
    opConfig = config2.operators[opKey];
    spel.not = !spel.not;
  }
  var needWrapWithNot = !!(spel !== null && spel !== void 0 && spel.not);
  var widget = getWidgetForFieldOp$3(config2, field, opKey);
  var widgetConfig = config2.widgets[widget || fieldConfig.mainWidget];
  var asyncListValuesArr = convertedArgs.map(function(v) {
    return v.asyncListValues;
  }).filter(function(v) {
    return v != void 0;
  });
  var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : void 0;
  var res = {
    type: "rule",
    id: uuid(),
    properties: _objectSpread$z({
      field,
      fieldSrc,
      operator: opKey,
      value: convertedArgs.map(function(v) {
        return v.value;
      }),
      valueSrc: convertedArgs.map(function(v) {
        return v.valueSrc;
      }),
      valueType: convertedArgs.map(function(v) {
        if (v.valueSrc == "value") {
          return (widgetConfig === null || widgetConfig === void 0 ? void 0 : widgetConfig.type) || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) || v.valueType;
        }
        return v.valueType;
      })
    }, asyncListValues ? {
      asyncListValues
    } : {})
  };
  if (needWrapWithNot) {
    res = wrapInDefaultConj2(res, config2, spel.not);
  }
  return res;
};
var buildRuleGroup = function buildRuleGroup2(_ref11, opKey, convertedArgs, config2, meta) {
  var groupFilter = _ref11.groupFilter, groupFieldValue = _ref11.groupFieldValue;
  if (groupFieldValue.valueSrc != "field") throw "Bad groupFieldValue: ".concat(JSON.stringify(groupFieldValue));
  var groupField = groupFieldValue.value;
  var groupOpRule = buildRule(config2, meta, groupField, opKey, convertedArgs);
  if (!groupOpRule) return void 0;
  var fieldConfig = getFieldConfig$8(config2, groupField);
  var mode = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mode;
  var res;
  if ((groupFilter === null || groupFilter === void 0 ? void 0 : groupFilter.type) === "group") {
    res = _objectSpread$z(_objectSpread$z({}, groupFilter || {}), {}, {
      type: "rule_group",
      properties: _objectSpread$z(_objectSpread$z(_objectSpread$z({}, groupOpRule.properties), (groupFilter === null || groupFilter === void 0 ? void 0 : groupFilter.properties) || {}), {}, {
        mode
      })
    });
  } else if (groupFilter) {
    res = _objectSpread$z(_objectSpread$z({}, groupOpRule || {}), {}, {
      type: "rule_group",
      children1: [groupFilter],
      properties: _objectSpread$z(_objectSpread$z({}, groupOpRule.properties), {}, {
        mode
      })
    });
  } else {
    res = _objectSpread$z(_objectSpread$z({}, groupOpRule || {}), {}, {
      type: "rule_group",
      properties: _objectSpread$z(_objectSpread$z({}, groupOpRule.properties), {}, {
        mode
      })
    });
  }
  if (!res.id) res.id = uuid();
  return res;
};
var compareArgs = function compareArgs2(left, right, spel, conv, config2, meta) {
  if (left.type == right.type) {
    if (left.type == "!aggr") {
      var _map = [left.source, right.source].map(function(v) {
        return convertArg(v, conv, config2, meta, spel);
      }), _map22 = _slicedToArray$1(_map, 2), leftSource = _map22[0], rightSource = _map22[1];
      return leftSource.value == rightSource.value;
    } else {
      var _map32 = [left, right].map(function(v) {
        return convertArg(v, conv, config2, meta, spel);
      }), _map4 = _slicedToArray$1(_map32, 2), leftVal = _map4[0], rightVal = _map4[1];
      return leftVal.value == rightVal.value;
    }
  }
  return false;
};
var buildSimpleSwitch = function buildSimpleSwitch2(val, conv, config2, meta) {
  var children1 = {};
  var cond = null;
  var caseI = buildCase(cond, val, conv, config2, meta);
  if (caseI) {
    children1[caseI.id] = caseI;
  }
  var res = {
    type: "switch_group",
    id: uuid(),
    children1,
    properties: {}
  };
  return res;
};
var buildCase = function buildCase2(cond, val, conv, config2, meta) {
  var spel = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
  var valProperties = buildCaseValProperties2(config2, meta, conv, val, spel);
  var caseI;
  if (cond) {
    caseI = convertToTree(cond, conv, config2, meta, spel);
    if (caseI && caseI.type) {
      if (caseI.type != "group") {
        caseI = wrapInDefaultConj2(caseI, config2);
      }
      caseI.type = "case_group";
    } else {
      meta.errors.push("Unexpected case: ".concat(JSON.stringify(caseI)));
      caseI = void 0;
    }
  } else {
    caseI = {
      id: uuid(),
      type: "case_group",
      properties: {}
    };
  }
  if (caseI) {
    caseI.properties = _objectSpread$z(_objectSpread$z({}, caseI.properties), valProperties);
  }
  return caseI;
};
var buildCaseValueConcat = function buildCaseValueConcat2(spel, conv, config2, meta) {
  var flat = [];
  function _processConcatChildren(children) {
    children.map(function(child) {
      if (child.type === "op-plus") {
        _processConcatChildren(child.children);
      } else {
        var convertedChild = convertArg(child, conv, config2, meta, spel);
        if (convertedChild) {
          flat.push(convertedChild);
        } else {
          meta.errors.push("Can't convert ".concat(child.type, " in concatenation"));
        }
      }
    });
  }
  _processConcatChildren(spel.children);
  return {
    valueSrc: "value",
    valueType: "case_value",
    value: flat
  };
};
var buildCaseValProperties2 = function buildCaseValProperties3(config2, meta, conv, val) {
  var _config$settings$case2, _convVal;
  var spel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var valProperties = {};
  var convVal;
  var widget;
  var widgetConfig;
  var caseValueFieldConfig = getFieldConfig$8(config2, "!case_value");
  if ((val === null || val === void 0 ? void 0 : val.type) === "op-plus" && ((_config$settings$case2 = config2.settings.caseValueField) === null || _config$settings$case2 === void 0 ? void 0 : _config$settings$case2.type) === "case_value") {
    widget = "case_value";
    convVal = buildCaseValueConcat(val, conv, config2, meta);
  } else {
    widget = caseValueFieldConfig === null || caseValueFieldConfig === void 0 ? void 0 : caseValueFieldConfig.mainWidget;
    widgetConfig = config2.widgets[widget];
    convVal = convertArg(val, conv, config2, meta, spel);
    if (convVal && convVal.valueSrc === "value") {
      var _widgetConfig;
      convVal.valueType = ((_widgetConfig = widgetConfig) === null || _widgetConfig === void 0 ? void 0 : _widgetConfig.type) || (caseValueFieldConfig === null || caseValueFieldConfig === void 0 ? void 0 : caseValueFieldConfig.type) || convVal.valueType;
    }
  }
  var widgetDef = config2.widgets[widget];
  if (widget === "case_value") {
    var importCaseValue = widgetDef === null || widgetDef === void 0 ? void 0 : widgetDef.spelImportValue;
    if (importCaseValue) {
      var _importCaseValue$call = importCaseValue.call(config2.ctx, convVal), _importCaseValue$call2 = _slicedToArray$1(_importCaseValue$call, 2), normVal = _importCaseValue$call2[0], normErrors = _importCaseValue$call2[1];
      normErrors.map(function(e2) {
        return meta.errors.push(e2);
      });
      if (normVal != void 0) {
        var _widgetDef$type;
        valProperties = {
          value: [normVal],
          valueSrc: ["value"],
          valueType: [(_widgetDef$type = widgetDef === null || widgetDef === void 0 ? void 0 : widgetDef.type) !== null && _widgetDef$type !== void 0 ? _widgetDef$type : "case_value"],
          field: "!case_value"
        };
      }
    }
  } else if (convVal != void 0 && ((_convVal = convVal) === null || _convVal === void 0 ? void 0 : _convVal.value) != void 0) {
    valProperties = {
      value: [convVal.value],
      valueSrc: [convVal.valueSrc],
      valueType: [convVal.valueType],
      field: "!case_value"
    };
  }
  return valProperties;
};
var wrapInDefaultConj2 = function wrapInDefaultConj3(rule3, config2) {
  var not2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  return {
    type: "group",
    id: uuid(),
    children1: _defineProperty$4({}, rule3.id, rule3),
    properties: {
      conjunction: defaultConjunction(config2),
      not: not2 || false
    }
  };
};
const Import = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _loadFromJsonLogic,
  _loadFromSpel,
  getTree,
  isImmutableTree,
  isJsonLogic,
  isTree,
  jsToImmutable,
  loadFromJsonLogic,
  loadFromSpel,
  loadTree
}, Symbol.toStringTag, { value: "Module" }));
function ownKeys$y(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$y(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$y(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$y(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var getDefaultField = function getDefaultField2(config2) {
  var canGetFirst = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var parentRuleGroupPath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var defaultField = config2.settings.defaultField;
  var f = (!parentRuleGroupPath ? defaultField : getDefaultSubField(config2, parentRuleGroupPath)) || canGetFirst && getFirstField(config2, parentRuleGroupPath) || null;
  if (f != null && typeof f !== "string" && !isImmutable$1(f)) {
    f = jsToImmutable(f);
  }
  return f;
};
var getDefaultSubField = function getDefaultSubField2(config2) {
  var _config$settings;
  var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!parentRuleGroupPath) return null;
  var fieldSeparator = (config2 === null || config2 === void 0 || (_config$settings = config2.settings) === null || _config$settings === void 0 ? void 0 : _config$settings.fieldSeparator) || ".";
  var parentRuleGroupConfig = getFieldConfig$8(config2, parentRuleGroupPath);
  var f = parentRuleGroupConfig === null || parentRuleGroupConfig === void 0 ? void 0 : parentRuleGroupConfig.defaultField;
  if (f) {
    f = [].concat(_toConsumableArray(getFieldParts$3(parentRuleGroupPath)), [f]).join(fieldSeparator);
  }
  return f;
};
var getDefaultFieldSrc = function getDefaultFieldSrc2(config2) {
  var _config$settings$fiel;
  var canGetFirst = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  return canGetFirst && ((_config$settings$fiel = config2.settings.fieldSources) === null || _config$settings$fiel === void 0 ? void 0 : _config$settings$fiel[0]) || "field";
};
var getDefaultOperator = function getDefaultOperator2(config2, field) {
  var canGetFirst = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var fieldConfig = getFieldConfig$8(config2, field);
  var fieldOperators = (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.operators) || [];
  var globalDefaultOperator = config2.settings.defaultOperator;
  if (globalDefaultOperator && !fieldOperators.includes(globalDefaultOperator)) globalDefaultOperator = null;
  var fieldDefaultOperator = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.defaultOperator;
  var fieldOwnDefaultOperator = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.ownDefaultOperator;
  var firstOperator = canGetFirst ? getFirstOperator(config2, field) : null;
  var op2 = fieldOwnDefaultOperator || globalDefaultOperator || fieldDefaultOperator || firstOperator;
  return op2;
};
var defaultOperatorOptions = function defaultOperatorOptions2(config2, operator, field) {
  var operatorConfig = operator ? getOperatorConfig$4(config2, operator, field) : null;
  if (!operatorConfig) return null;
  return operatorConfig.options ? new Immutable.Map(operatorConfig.options && operatorConfig.options.defaults || {}) : null;
};
var defaultRuleProperties = function defaultRuleProperties2(config2) {
  var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var item = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var canUseDefaultFieldAndOp = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var canGetFirst = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var field = null, operator = null, fieldSrc = null;
  var showErrorMessage = config2.settings.showErrorMessage;
  if (item) {
    var _item$properties, _item$properties2, _item$properties3;
    fieldSrc = item === null || item === void 0 || (_item$properties = item.properties) === null || _item$properties === void 0 ? void 0 : _item$properties.fieldSrc;
    field = item === null || item === void 0 || (_item$properties2 = item.properties) === null || _item$properties2 === void 0 ? void 0 : _item$properties2.field;
    operator = item === null || item === void 0 || (_item$properties3 = item.properties) === null || _item$properties3 === void 0 ? void 0 : _item$properties3.operator;
  } else if (canUseDefaultFieldAndOp) {
    field = getDefaultField(config2, canGetFirst, parentRuleGroupPath);
    if (field) {
      fieldSrc = isImmutable$1(field) ? "func" : "field";
    } else {
      fieldSrc = getDefaultFieldSrc(config2);
    }
    operator = getDefaultOperator(config2, field, true);
  } else {
    fieldSrc = getDefaultFieldSrc(config2);
  }
  var current = new Immutable.Map({
    fieldSrc,
    field,
    operator,
    value: new Immutable.List(),
    valueSrc: new Immutable.List(),
    //used for complex operators like proximity
    operatorOptions: defaultOperatorOptions(config2, operator, field)
  });
  if (showErrorMessage) {
    current = current.set("valueError", new Immutable.List());
  }
  if (field && operator) {
    var canFix = false;
    var _getNewValueForFieldO = getNewValueForFieldOp(config2, config2, current, field, operator, "operator", canFix), newValue = _getNewValueForFieldO.newValue, newValueSrc = _getNewValueForFieldO.newValueSrc, newValueType = _getNewValueForFieldO.newValueType, newValueError = _getNewValueForFieldO.newValueError, newFieldError = _getNewValueForFieldO.newFieldError;
    current = current.set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType);
    if (showErrorMessage) {
      current = current.set("valueError", newValueError).set("fieldError", newFieldError);
    }
  }
  return current;
};
var defaultGroupConjunction$1 = function defaultGroupConjunction(config2) {
  var fieldConfig = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  fieldConfig = getFieldConfig$8(config2, fieldConfig);
  var conjs = fieldConfig && fieldConfig.conjunctions || Object.keys(config2.conjunctions);
  if (conjs.length == 1) return conjs[0];
  return config2.settings.defaultGroupConjunction || config2.settings.defaultConjunction || conjs[0];
};
var defaultConjunction = function defaultConjunction2(config2) {
  return config2.settings.defaultConjunction || Object.keys(config2.conjunctions)[0];
};
var defaultGroupProperties = function defaultGroupProperties2(config2) {
  var fieldConfig = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  return new Immutable.Map({
    conjunction: defaultGroupConjunction$1(config2, fieldConfig),
    not: false
  });
};
var defaultItemProperties = function defaultItemProperties2(config2, item) {
  var _item$properties4;
  return item && item.type == "group" ? defaultGroupProperties(config2, item === null || item === void 0 || (_item$properties4 = item.properties) === null || _item$properties4 === void 0 ? void 0 : _item$properties4.field) : defaultRuleProperties(config2, null, item);
};
var defaultRule = function defaultRule2(id2, config2) {
  return _defineProperty$4({}, id2, new Immutable.Map({
    type: "rule",
    id: id2,
    properties: defaultRuleProperties(config2)
  }));
};
var defaultRoot$1 = function defaultRoot(config2) {
  var canAddDefaultRule = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  return new Immutable.Map({
    type: "group",
    id: uuid(),
    children1: new Immutable.OrderedMap(canAddDefaultRule ? _objectSpread$y({}, defaultRule(uuid(), config2)) : {}),
    properties: defaultGroupProperties(config2)
  });
};
var createListWithOneElement$2 = function createListWithOneElement(el) {
  if (isImmutableList(el)) return el;
  return createListFromArray([el]);
};
var createListFromArray = function createListFromArray2(arr) {
  if (isImmutableList(arr)) return arr;
  return new Immutable.List(arr);
};
var emptyProperties$1 = function emptyProperties() {
  return new Immutable.Map();
};
const defaultUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createListFromArray,
  createListWithOneElement: createListWithOneElement$2,
  defaultConjunction,
  defaultGroupConjunction: defaultGroupConjunction$1,
  defaultGroupProperties,
  defaultItemProperties,
  defaultOperatorOptions,
  defaultRoot: defaultRoot$1,
  defaultRule,
  defaultRuleProperties,
  emptyProperties: emptyProperties$1,
  getDefaultField,
  getDefaultFieldSrc,
  getDefaultOperator,
  getDefaultSubField
}, Symbol.toStringTag, { value: "Module" }));
function _createForOfIteratorHelper$a(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$a(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null) it["return"]();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$a(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$a(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$a(o, minLen);
}
function _arrayLikeToArray$a(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function ownKeys$x(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$x(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$x(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$x(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var queryString = function queryString2(item, config2) {
  var isForDisplay = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var isDebugMode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var meta = {
    errors: [],
    settings: {
      isForDisplay,
      isDebugMode
    }
  };
  var extendedConfig = extendConfig(config2, void 0, false);
  var res = formatItem$4(item, extendedConfig, meta, null);
  if (meta.errors.length) console.warn("Errors while exporting to string:", meta.errors);
  return res;
};
var formatItem$4 = function formatItem2(item, config2, meta) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  if (!item) return void 0;
  var type2 = item.get("type");
  item.get("children1");
  if (type2 === "group" || type2 === "rule_group") {
    return formatGroup$4(item, config2, meta, parentField);
  } else if (type2 === "rule") {
    return formatRule$4(item, config2, meta, parentField);
  }
  return void 0;
};
var formatGroup$4 = function formatGroup2(item, config2, meta) {
  var _config$operators$gro, _config$operators$gro2;
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var _meta$settings = meta.settings, isForDisplay = _meta$settings.isForDisplay, isDebugMode = _meta$settings.isDebugMode;
  var type2 = item.get("type");
  var properties = item.get("properties") || new Map$2();
  var mode = properties.get("mode");
  var children = item.get("children1") || new List();
  var isRuleGroup = type2 === "rule_group";
  var groupField = isRuleGroup && mode == "array" ? properties.get("field") : null;
  var groupOperator = type2 === "rule_group" ? properties.get("operator") : null;
  var groupOperatorCardinality = groupOperator ? (_config$operators$gro = (_config$operators$gro2 = config2.operators[groupOperator]) === null || _config$operators$gro2 === void 0 ? void 0 : _config$operators$gro2.cardinality) !== null && _config$operators$gro !== void 0 ? _config$operators$gro : 1 : void 0;
  var canHaveEmptyChildren = isRuleGroup && mode === "array" && groupOperatorCardinality >= 1;
  var not2 = properties.get("not");
  var list2 = children.map(function(currentChild) {
    return formatItem$4(currentChild, config2, meta, groupField);
  }).filter(function(currentChild) {
    return typeof currentChild !== "undefined";
  });
  if (!canHaveEmptyChildren && !list2.size && !isDebugMode) {
    return void 0;
  }
  var conjunction = properties.get("conjunction");
  if (!conjunction) conjunction = defaultConjunction(config2);
  var conjunctionDefinition = config2.conjunctions[conjunction];
  var conjStr = list2.size ? conjunctionDefinition.formatConj.call(config2.ctx, list2, conjunction, not2, isForDisplay) : null;
  var ret;
  if (groupField) {
    var aggrArgs = formatRule$4(item, config2, meta, parentField, true);
    if (aggrArgs) {
      var _config$settings$form;
      var isRev = aggrArgs.pop();
      var args = [conjStr].concat(_toConsumableArray(aggrArgs));
      ret = (_config$settings$form = config2.settings.formatAggr).call.apply(_config$settings$form, [config2.ctx].concat(_toConsumableArray(args)));
      if (isRev) {
        ret = config2.settings.formatReverse.call(config2.ctx, ret, null, null, null, null, isForDisplay);
      }
    }
  } else {
    ret = conjStr;
  }
  if (isDebugMode && ret == null) {
    ret = "?";
  }
  return ret;
};
var formatItemValue$1 = function formatItemValue2(config2, properties, meta, _operator, parentField) {
  var _meta$settings2 = meta.settings;
  _meta$settings2.isForDisplay;
  var isDebugMode = _meta$settings2.isDebugMode;
  var field = properties.get("field");
  var iValueSrc = properties.get("valueSrc");
  var iValueType = properties.get("valueType");
  var fieldDef = getFieldConfig$8(config2, field) || {};
  var operator = _operator || properties.get("operator");
  var operatorDef = getOperatorConfig$4(config2, operator, field) || {};
  var cardinality = getOpCardinality$1(operatorDef);
  var iValue = properties.get("value");
  var asyncListValues = properties.get("asyncListValues");
  var valueSrcs = [];
  var valueTypes = [];
  var formattedValue;
  var fvalue;
  if (iValue != void 0) {
    fvalue = iValue.map(function(currentValue, ind) {
      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
      var valueType = iValueType ? iValueType.get(ind) : null;
      var cValue = !isDebugMode ? completeValue(currentValue, valueSrc, config2) : currentValue;
      var widget = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
      var fieldWidgetDef = getFieldWidgetConfig$3(config2, field, operator, widget, valueSrc, {
        forExport: true
      });
      var fv = formatValue$3(config2, meta, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, parentField, asyncListValues);
      if (fv !== void 0) {
        valueSrcs.push(valueSrc);
        valueTypes.push(valueType);
      }
      return fv;
    });
    var hasUndefinedValues = fvalue.filter(function(v) {
      return v === void 0;
    }).size > 0;
    var isOK = !hasUndefinedValues && fvalue.size === cardinality;
    if (isOK) {
      formattedValue = cardinality == 1 ? fvalue.first() : fvalue;
    }
  }
  if (isDebugMode && !formattedValue) {
    formattedValue = cardinality > 1 ? new List(Array.from({
      length: cardinality
    }).map(function(_, i2) {
      var _fvalue$get, _fvalue;
      return (_fvalue$get = (_fvalue = fvalue) === null || _fvalue === void 0 ? void 0 : _fvalue.get(i2)) !== null && _fvalue$get !== void 0 ? _fvalue$get : "?";
    })) : "?";
  }
  return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];
};
var buildFnToFormatOp$2 = function buildFnToFormatOp2(operator, operatorDefinition, meta) {
  var isDebugMode = meta.settings.isDebugMode;
  var fop = (operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.labelForFormat) || operator;
  var cardinality = getOpCardinality$1(operatorDefinition);
  var fn;
  if (cardinality == 0) {
    fn = function fn2(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return "".concat(field, " ").concat(fop);
    };
  } else if (cardinality == 1) {
    fn = function fn2(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      if (isDebugMode && op2 === "?" && values2 === "?") {
        return field && field !== "?" ? "".concat(field, " ?") : "?";
      }
      return "".concat(field, " ").concat(fop, " ").concat(values2);
    };
  } else if (cardinality == 2) {
    fn = function fn2(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      var _values$first, _values$get;
      var valFrom = values2 === null || values2 === void 0 || (_values$first = values2.first) === null || _values$first === void 0 ? void 0 : _values$first.call(values2);
      var valTo = values2 === null || values2 === void 0 || (_values$get = values2.get) === null || _values$get === void 0 ? void 0 : _values$get.call(values2, 1);
      return "".concat(field, " ").concat(fop, " ").concat(valFrom, " AND ").concat(valTo);
    };
  }
  return fn;
};
var formatRule$4 = function formatRule2(item, config2, meta) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var returnArgs = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var _meta$settings3 = meta.settings, isForDisplay = _meta$settings3.isForDisplay, isDebugMode = _meta$settings3.isDebugMode;
  var properties = item.get("properties") || new Map$2();
  var field = properties.get("field");
  var fieldSrc = properties.get("fieldSrc");
  var operator = properties.get("operator");
  var operatorOptions = properties.get("operatorOptions");
  if ((field == null || operator == null) && !isDebugMode) return void 0;
  var fieldDef = getFieldConfig$8(config2, field) || {};
  var operatorDef = getOperatorConfig$4(config2, operator, field) || {};
  var reversedOp = operatorDef.reversedOp;
  var revOperatorDef = getOperatorConfig$4(config2, reversedOp, field) || {};
  var isRev = false;
  var fn = operatorDef.formatOp;
  if (!fn && reversedOp) {
    fn = revOperatorDef.formatOp;
    if (fn) {
      isRev = true;
      var _ref = [reversedOp, operator];
      operator = _ref[0];
      reversedOp = _ref[1];
      var _ref2 = [revOperatorDef, operatorDef];
      operatorDef = _ref2[0];
      revOperatorDef = _ref2[1];
    }
  }
  if (isDebugMode && !operator) {
    operator = "?";
  }
  if (!fn) fn = buildFnToFormatOp$2(operator, operatorDef, meta);
  if (!fn) return void 0;
  var formattedField = fieldSrc === "func" ? formatFunc$3(config2, meta, field, parentField) : formatField$2(config2, meta, field, parentField);
  if (formattedField == void 0) return void 0;
  var _formatItemValue = formatItemValue$1(config2, properties, meta, operator, parentField), _formatItemValue2 = _slicedToArray$1(_formatItemValue, 3), formattedValue = _formatItemValue2[0], valueSrc = _formatItemValue2[1], valueType = _formatItemValue2[2];
  if (formattedValue === void 0) {
    return void 0;
  }
  var args = [formattedField, operator, formattedValue, valueSrc, valueType, omit$2(operatorDef, opDefKeysToOmit), operatorOptions, isForDisplay, fieldDef, isRev];
  if (returnArgs) {
    return args;
  } else {
    var _fn;
    var ret = (_fn = fn).call.apply(_fn, [config2.ctx].concat(args));
    if (isRev) {
      ret = config2.settings.formatReverse.call(config2.ctx, ret, operator, reversedOp, operatorDef, revOperatorDef, isForDisplay);
    }
    return ret;
  }
};
var formatValue$3 = function formatValue2(config2, meta, value, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, opDef) {
  var parentField = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : null;
  var asyncListValues = arguments.length > 10 ? arguments[10] : void 0;
  var _meta$settings4 = meta.settings, isForDisplay = _meta$settings4.isForDisplay, isDebugMode = _meta$settings4.isDebugMode;
  if (value === void 0) {
    if (isDebugMode) {
      if ((fieldWidgetDef === null || fieldWidgetDef === void 0 ? void 0 : fieldWidgetDef.jsType) === "array") {
        return [];
      }
      return "?";
    } else {
      return void 0;
    }
  }
  var ret;
  if (valueSrc == "field") {
    ret = formatField$2(config2, meta, value, parentField);
  } else if (valueSrc == "func") {
    ret = formatFunc$3(config2, meta, value, parentField);
  } else {
    if (typeof (fieldWidgetDef === null || fieldWidgetDef === void 0 ? void 0 : fieldWidgetDef.formatValue) === "function") {
      var fn = fieldWidgetDef.formatValue;
      var args = [
        value,
        _objectSpread$x(_objectSpread$x({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
          asyncListValues
        }),
        //useful options: valueFormat for date/time
        omit$2(fieldWidgetDef, widgetDefKeysToOmit),
        isForDisplay
      ];
      if (operator) {
        args.push(operator);
        args.push(opDef);
      }
      if (valueSrc == "field") {
        var valFieldDefinition = getFieldConfig$8(config2, value) || {};
        args.push(valFieldDefinition);
      }
      ret = fn.call.apply(fn, [config2.ctx].concat(args));
    } else {
      ret = value;
    }
  }
  return ret;
};
var formatField$2 = function formatField2(config2, meta, field) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var cutParentField = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  var _meta$settings5 = meta.settings, isForDisplay = _meta$settings5.isForDisplay, isDebugMode = _meta$settings5.isDebugMode;
  var _config$settings = config2.settings;
  _config$settings.fieldSeparator;
  var fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay;
  var ret = null;
  if (field) {
    var fieldDefinition = getFieldConfig$8(config2, field) || {};
    var fieldParts = getFieldParts$3(field, config2);
    var fieldPartsLabels = getFieldPathLabels$2(field, config2, cutParentField ? parentField : null);
    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparatorDisplay) : null;
    var fieldLabel2 = fieldDefinition.label2 || fieldFullLabel;
    var formatFieldFn = config2.settings.formatField;
    var fieldName = formatFieldName(field, config2, meta, cutParentField ? parentField : null, {
      useTableName: true
    });
    ret = formatFieldFn(fieldName, fieldParts, fieldLabel2, fieldDefinition, config2, isForDisplay);
  } else if (isDebugMode) {
    ret = "?";
  }
  return ret;
};
var formatFunc$3 = function formatFunc2(config2, meta, funcValue) {
  var _funcValue$get, _funcValue$get2, _args$keySeq;
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var _meta$settings6 = meta.settings, isForDisplay = _meta$settings6.isForDisplay, isDebugMode = _meta$settings6.isDebugMode;
  var funcKey = funcValue === null || funcValue === void 0 || (_funcValue$get = funcValue.get) === null || _funcValue$get === void 0 ? void 0 : _funcValue$get.call(funcValue, "func");
  if (!funcKey) {
    return isDebugMode ? "?()" : void 0;
  }
  var args = (_funcValue$get2 = funcValue.get) === null || _funcValue$get2 === void 0 ? void 0 : _funcValue$get2.call(funcValue, "args");
  var funcConfig = getFuncConfig$2(config2, funcKey);
  if (!funcConfig) {
    if (!isDebugMode) {
      meta.errors.push("Func ".concat(funcKey, " is not defined in config"));
      return void 0;
    }
  }
  var funcParts = getFieldParts$3(funcKey, config2);
  var funcLastKey = funcParts[funcParts.length - 1];
  var funcName = isForDisplay && (funcConfig === null || funcConfig === void 0 ? void 0 : funcConfig.label) || funcLastKey;
  var formattedArgs = {};
  var gaps = [];
  var missingArgKeys = [];
  var formattedArgsWithNames = {};
  var argsKeys = funcConfig ? Object.keys(funcConfig.args || {}) : (args === null || args === void 0 || (_args$keySeq = args.keySeq) === null || _args$keySeq === void 0 ? void 0 : _args$keySeq.call(args).toArray()) || [];
  var _iterator = _createForOfIteratorHelper$a(argsKeys), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _argValue;
      var argKey = _step.value;
      var argConfig = funcConfig === null || funcConfig === void 0 ? void 0 : funcConfig.args[argKey];
      var fieldDef = getFieldConfig$8(config2, argConfig);
      var _ref5 = argConfig || {}, defaultValue = _ref5.defaultValue, isOptional = _ref5.isOptional;
      var defaultValueSrc = defaultValue !== null && defaultValue !== void 0 && defaultValue.func ? "func" : "value";
      var argName = isForDisplay && (argConfig === null || argConfig === void 0 ? void 0 : argConfig.label) || argKey;
      var argVal = args ? args.get(argKey) : void 0;
      var argValue = argVal ? argVal.get("value") : void 0;
      var argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
      if (argValueSrc !== "func" && (_argValue = argValue) !== null && _argValue !== void 0 && _argValue.toJS) {
        argValue = argValue.toJS();
      }
      var argAsyncListValues = argVal ? argVal.get("asyncListValues") : void 0;
      var formattedArgVal = formatValue$3(config2, meta, argValue, argValueSrc, argConfig === null || argConfig === void 0 ? void 0 : argConfig.type, fieldDef, argConfig, null, null, parentField, argAsyncListValues);
      if (argValue != void 0 && formattedArgVal === void 0) {
        if (argValueSrc != "func")
          meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
      }
      var formattedDefaultVal = void 0;
      if (formattedArgVal === void 0 && !isOptional && defaultValue != void 0) {
        formattedDefaultVal = formatValue$3(config2, meta, defaultValue, defaultValueSrc, argConfig === null || argConfig === void 0 ? void 0 : argConfig.type, fieldDef, argConfig, null, null, parentField, argAsyncListValues);
        if (formattedDefaultVal === void 0) {
          if (defaultValueSrc != "func")
            meta.errors.push("Can't format default value of arg ".concat(argKey, " for func ").concat(funcKey));
          return void 0;
        }
      }
      var finalFormattedVal = formattedArgVal !== null && formattedArgVal !== void 0 ? formattedArgVal : formattedDefaultVal;
      if (finalFormattedVal !== void 0) {
        if (gaps.length) {
          var _iterator2 = _createForOfIteratorHelper$a(argKey), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var _step2$value = _slicedToArray$1(_step2.value, 2), missedArgKey = _step2$value[0], missedArgName = _step2$value[1];
              formattedArgs[missedArgKey] = void 0;
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          gaps = [];
        }
        formattedArgs[argKey] = finalFormattedVal;
        formattedArgsWithNames[argName] = finalFormattedVal;
      } else {
        if (!isOptional) missingArgKeys.push(argKey);
        gaps.push([argKey, argName]);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (missingArgKeys.length) {
    if (!isDebugMode) {
      return void 0;
    }
  }
  var ret = null;
  if (typeof (funcConfig === null || funcConfig === void 0 ? void 0 : funcConfig.formatFunc) === "function") {
    var fn = funcConfig.formatFunc;
    var _args = [formattedArgs, isForDisplay];
    ret = fn.call.apply(fn, [config2.ctx].concat(_args));
  } else {
    var argsStr = Object.entries(isForDisplay ? formattedArgsWithNames : formattedArgs).map(function(_ref3) {
      var _ref4 = _slicedToArray$1(_ref3, 2), k = _ref4[0], v = _ref4[1];
      return isForDisplay ? "".concat(k, ": ").concat(v) : "".concat(v);
    }).join(", ");
    ret = "".concat(funcName, "(").concat(argsStr, ")");
  }
  return ret;
};
var EMPTY_GROUP = "EMPTY_GROUP";
var EMPTY_RULE_GROUP = "EMPTY_RULE_GROUP";
var EMPTY_QUERY = "EMPTY_QUERY";
var EMPTY_CASE = "EMPTY_CASE";
var NO_CONFIG_FOR_FIELD = "NO_CONFIG_FOR_FIELD";
var NO_CONFIG_FOR_OPERATOR = "NO_CONFIG_FOR_OPERATOR";
var FIXED_OPERATOR = "FIXED_OPERATOR";
var NO_CONFIG_FOR_FUNCTION = "NO_CONFIG_FOR_FUNCTION";
var INVALID_VALUE = "INVALID_VALUE";
var INVALID_FUNC_ARG_VALUE = "INVALID_FUNC_ARG_VALUE";
var UNSUPPORTED_FIELD_TYPE = "UNSUPPORTED_FIELD_TYPE";
var UNSUPPORTED_OPERATOR_FOR_FIELD = "UNSUPPORTED_OPERATOR_FOR_FIELD";
var INVALID_VALUE_SRC = "INVALID_VALUE_SRC";
var INCOMPLETE_RULE = "INCOMPLETE_RULE";
var INCOMPLETE_LHS = "INCOMPLETE_LHS";
var INCOMPLETE_RHS = "INCOMPLETE_RHS";
var BAD_MULTISELECT_VALUES = "BAD_MULTISELECT_VALUES";
var BAD_SELECT_VALUE = "BAD_SELECT_VALUE";
var INCORRECT_VALUE_TYPE = "INCORRECT_VALUE_TYPE";
var INCORRECT_VALUE_JS_TYPE = "INCORRECT_VALUE_JS_TYPE";
var VALUE_LENGTH_CONSTRAINT_FAIL = "VALUE_LENGTH_CONSTRAINT_FAIL";
var VALUE_MIN_CONSTRAINT_FAIL = "VALUE_MIN_CONSTRAINT_FAIL";
var VALUE_MAX_CONSTRAINT_FAIL = "VALUE_MAX_CONSTRAINT_FAIL";
var NO_CONFIG_FOR_FIELD_VALUE = "NO_CONFIG_FOR_FIELD_VALUE";
var CANT_COMPARE_FIELD_WITH_ITSELF = "CANT_COMPARE_FIELD_WITH_ITSELF";
var CANT_COMPARE_FIELD_WITH_FIELD = "CANT_COMPARE_FIELD_WITH_FIELD";
var INCORRECT_FIELD_TYPE = "INCORRECT_FIELD_TYPE";
var UNSUPPORTED_FUNCTION_FOR_FIELD = "UNSUPPORTED_FUNCTION_FOR_FIELD";
var REQUIRED_FUNCTION_ARG = "REQUIRED_FUNCTION_ARG";
var INCORRECT_FUNCTION_RETURN_TYPE = "INCORRECT_FUNCTION_RETURN_TYPE";
var INVALID_RANGE = "INVALID_RANGE";
var ITEM_POSITION = "ITEM_POSITION";
var ITEM_POSITION_ROOT = "ITEM_POSITION_ROOT";
var ITEM_POSITION_WITH_INDEX_PATH = "ITEM_POSITION_WITH_INDEX_PATH";
var ITEM_POSITION_IN_CASE = "ITEM_POSITION_IN_CASE";
var _CONTEXT_MIN_MAX = "range";
const isString$1 = (obj) => typeof obj === "string";
const defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
const makeString = (object) => {
  if (object == null) return "";
  return "" + object;
};
const copy = (a2, s2, t2) => {
  a2.forEach((m) => {
    if (s2[m]) t2[m] = s2[m];
  });
};
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
const canNotTraverseDeeper = (object) => !object || isString$1(object);
const getLastOfPath = (object, path, Empty) => {
  const stack = !isString$1(path) ? path : path.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
const setPath = (object, path, newValue) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  if (obj !== void 0 || path.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e2 = path[path.length - 1];
  let p = path.slice(0, path.length - 1);
  let last4 = getLastOfPath(object, p, Object);
  while (last4.obj === void 0 && p.length) {
    e2 = "".concat(p[p.length - 1], ".").concat(e2);
    p = p.slice(0, p.length - 1);
    last4 = getLastOfPath(object, p, Object);
    if (last4 && last4.obj && typeof last4.obj["".concat(last4.k, ".").concat(e2)] !== "undefined") {
      last4.obj = void 0;
    }
  }
  last4.obj["".concat(last4.k, ".").concat(e2)] = newValue;
};
const pushPath = (object, path, newValue, concat3) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  obj[k] = obj[k] || [];
  obj[k].push(newValue);
};
const getPath = (object, path) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path);
  if (!obj) return void 0;
  return obj[k];
};
const getPathWithDefaults = (data, defaultData, key) => {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
};
const deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (isString$1(target[prop]) || target[prop] instanceof String || isString$1(source[prop]) || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
const regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const escape = (data) => {
  if (isString$1(data)) {
    return data.replace(/[&<>"'\/]/g, (s2) => _entityMap[s2]);
  }
  return data;
};
class RegExpCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
}
const chars = [" ", ",", "?", "!", ";"];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c2) => nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0);
  if (possibleChars.length === 0) return true;
  const r2 = looksLikeObjectPathRegExpCache.getRegExp("(".concat(possibleChars.map((c2) => c2 === "?" ? "\\?" : c2).join("|"), ")"));
  let matched = !r2.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r2.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
};
const deepFind = function(obj, path) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj) return void 0;
  if (obj[path]) return obj[path];
  const tokens2 = path.split(keySeparator);
  let current = obj;
  for (let i2 = 0; i2 < tokens2.length; ) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j = i2; j < tokens2.length; ++j) {
      if (j !== i2) {
        nextPath += keySeparator;
      }
      nextPath += tokens2[j];
      next = current[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens2.length - 1) {
          continue;
        }
        i2 += j - i2 + 1;
        break;
      }
    }
    current = next;
  }
  return current;
};
const getCleanedCode = (code) => code && code.replace("_", "-");
const consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type2, args) {
    if (console && console[type2]) console[type2].apply(console, args);
  }
};
class Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString$1(args[0])) args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new Logger(this.logger, {
      ...{
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger(this.logger, options);
  }
}
var baseLogger = new Logger();
class EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach((_ref) => {
        let [observer, numTimesAdded] = _ref;
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach((_ref2) => {
        let [observer, numTimesAdded] = _ref2;
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
}
class ResourceStore extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index2 = this.options.ns.indexOf(ns);
    if (index2 > -1) {
      this.options.ns.splice(index2, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path;
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
    } else {
      path = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path.push(...key);
        } else if (isString$1(key) && keySeparator) {
          path.push(...key.split(keySeparator));
        } else {
          path.push(key);
        }
      }
    }
    const result = getPath(this.data, path);
    if (!result && !ns && !key && lng.indexOf(".") > -1) {
      lng = path[0];
      ns = path[1];
      key = path.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || !isString$1(key)) return result;
    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
  }
  addResource(lng, ns, key, value) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path = [lng, ns];
    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      value = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path, value);
    if (!options.silent) this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m in resources) {
      if (isString$1(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {
        silent: true
      });
    }
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      deep = resources;
      resources = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path) || {};
    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path, pack);
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    if (this.options.compatibilityAPI === "v1") return {
      ...{},
      ...this.getResource(lng, ns)
    };
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n2 = data && Object.keys(data) || [];
    return !!n2.find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var postProcessor = {
  processors: {},
  addPostProcessor(module2) {
    this.processors[module2.name] = module2;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
const checkedLoadedFor = {};
class Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key === void 0 || key === null) {
      return false;
    }
    const resolved = this.resolve(key, options);
    return resolved && resolved.res !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    if (isString$1(namespaces)) namespaces = [namespaces];
    return {
      key,
      namespaces
    };
  }
  translate(keys4, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object") options = {
      ...options
    };
    if (!options) options = {};
    if (keys4 === void 0 || keys4 === null) return "";
    if (!Array.isArray(keys4)) keys4 = [String(keys4)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys4[keys4.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: "".concat(namespace).concat(nsSeparator).concat(key),
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return "".concat(namespace).concat(nsSeparator).concat(key);
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys4, options);
    let res = resolved && resolved.res;
    const resUsedKey = resolved && resolved.usedKey || key;
    const resExactUsedKey = resolved && resolved.exactUsedKey || key;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = !isString$1(res) && typeof res !== "boolean" && typeof res !== "number";
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(isString$1(joinArrays) && Array.isArray(res))) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces
        }) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
        if (returnDetails) {
          resolved.res = r2;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }
        return r2;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(res);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in res) {
          if (Object.prototype.hasOwnProperty.call(res, m)) {
            const deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
            copy2[m] = this.translate(deepKey, {
              ...options,
              ...{
                joinArrays: false,
                ns: namespaces
              }
            });
            if (copy2[m] === deepKey) copy2[m] = res[m];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && isString$1(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys4, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== void 0 && !isString$1(options.count);
      const hasDefaultValue = Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : "";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const defaultValue = needsZeroSuffixLookup && options["defaultValue".concat(this.options.pluralSeparator, "zero")] || options["defaultValue".concat(defaultValueSuffix)] || options["defaultValue".concat(defaultValueSuffixOrdinalFallback)] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i2 = 0; i2 < fallbackLngs.length; i2++) {
            lngs.push(fallbackLngs[i2]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector && this.backendConnector.saveMissing) {
            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l, namespace, k, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, options);
              if (needsZeroSuffixLookup && options["defaultValue".concat(this.options.pluralSeparator, "zero")] && suffixes.indexOf("".concat(this.options.pluralSeparator, "zero")) < 0) {
                suffixes.push("".concat(this.options.pluralSeparator, "zero"));
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, options["defaultValue".concat(suffix)] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys4, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key);
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        if (this.options.compatibilityAPI !== "v1") {
          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace, ":").concat(key) : key, usedDefault ? res : void 0);
        } else {
          res = this.options.parseMissingKeyHandler(res);
        }
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(options);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat && this.i18nFormat.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation) this.interpolator.init({
        ...options,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...options.interpolation
          }
        }
      });
      const skipOnVariables = isString$1(res) && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && !isString$1(options.replace) ? options.replace : options;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) options.nest = false;
      }
      if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res) options.lng = this.language || resolved.usedLng;
      if (options.nest !== false) res = this.interpolator.nest(res, function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (lastKey && lastKey[0] === args[0] && !options.context) {
          _this.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
          return null;
        }
        return _this.translate(...args, key);
      }, options);
      if (options.interpolation) this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = isString$1(postProcess) ? [postProcess] : postProcess;
    if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys4) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString$1(keys4)) keys4 = [keys4];
    keys4.forEach((k) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && !isString$1(options.count);
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const needsContextHandling = options.context !== void 0 && (isString$1(options.context) || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
          this.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), '" won\'t get resolved as namespace "').concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = "".concat(this.options.pluralSeparator, "zero");
            const ordinalPrefix = "".concat(this.options.pluralSeparator, "ordinal").concat(this.options.pluralSeparator);
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = "".concat(key).concat(this.options.contextSeparator).concat(options.context);
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && !isString$1(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
}
const capitalize = (string) => string.charAt(0).toUpperCase() + string.slice(1);
class LanguageUtil {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p = code.split("-");
    if (p.length === 2) return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p = code.split("-");
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (isString$1(code) && code.indexOf("-") > -1) {
      if (typeof Intl !== "undefined" && typeof Intl.getCanonicalLocales !== "undefined") {
        try {
          let formattedCode = Intl.getCanonicalLocales(code)[0];
          if (formattedCode && this.options.lowerCaseLng) {
            formattedCode = formattedCode.toLowerCase();
          }
          if (formattedCode) return formattedCode;
        } catch (e2) {
        }
      }
      const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let p = code.split("-");
      if (this.options.lowerCaseLng) {
        p = p.map((part) => part.toLowerCase());
      } else if (p.length === 2) {
        p[0] = p[0].toLowerCase();
        p[1] = p[1].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
      } else if (p.length === 3) {
        p[0] = p[0].toLowerCase();
        if (p[1].length === 2) p[1] = p[1].toUpperCase();
        if (p[0] !== "sgn" && p[2].length === 2) p[2] = p[2].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
        if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
      }
      return p.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (isString$1(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c2) => {
      if (!c2) return;
      if (this.isSupportedCode(c2)) {
        codes.push(c2);
      } else {
        this.logger.warn("rejecting language code not found in supportedLngs: ".concat(c2));
      }
    };
    if (isString$1(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (isString$1(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
}
let sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
let _rulesPluralsTypes = {
  1: (n2) => Number(n2 > 1),
  2: (n2) => Number(n2 != 1),
  3: (n2) => 0,
  4: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
  5: (n2) => Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5),
  6: (n2) => Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2),
  7: (n2) => Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
  8: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3),
  9: (n2) => Number(n2 >= 2),
  10: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4),
  11: (n2) => Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3),
  12: (n2) => Number(n2 % 10 != 1 || n2 % 100 == 11),
  13: (n2) => Number(n2 !== 0),
  14: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3),
  15: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
  16: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2),
  17: (n2) => Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1),
  18: (n2) => Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2),
  19: (n2) => Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3),
  20: (n2) => Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2),
  21: (n2) => Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0),
  22: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3)
};
const nonIntlVersions = ["v1", "v2", "v3"];
const intlVersions = ["v4"];
const suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
const createRules = () => {
  const rules = {};
  sets.forEach((set3) => {
    set3.lngs.forEach((l) => {
      rules[l] = {
        numbers: set3.nr,
        plurals: _rulesPluralsTypes[set3.fc]
      };
    });
  });
  return rules;
};
class PluralResolver {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) {
      try {
        const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
        const type2 = options.ordinal ? "ordinal" : "cardinal";
        const cacheKey = JSON.stringify({
          cleanedCode,
          type: type2
        });
        if (cacheKey in this.pluralRulesCache) {
          return this.pluralRulesCache[cacheKey];
        }
        const rule3 = new Intl.PluralRules(cleanedCode, {
          type: type2
        });
        this.pluralRulesCache[cacheKey] = rule3;
        return rule3;
      } catch (err) {
        return;
      }
    }
    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule3 = this.getRule(code, options);
    if (this.shouldUseIntlApi()) {
      return rule3 && rule3.resolvedOptions().pluralCategories.length > 1;
    }
    return rule3 && rule3.numbers.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options).map((suffix) => "".concat(key).concat(suffix));
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule3 = this.getRule(code, options);
    if (!rule3) {
      return [];
    }
    if (this.shouldUseIntlApi()) {
      return rule3.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => "".concat(this.options.prepend).concat(options.ordinal ? "ordinal".concat(this.options.prepend) : "").concat(pluralCategory));
    }
    return rule3.numbers.map((number) => this.getSuffix(code, number, options));
  }
  getSuffix(code, count2) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule3 = this.getRule(code, options);
    if (rule3) {
      if (this.shouldUseIntlApi()) {
        return "".concat(this.options.prepend).concat(options.ordinal ? "ordinal".concat(this.options.prepend) : "").concat(rule3.select(count2));
      }
      return this.getSuffixRetroCompatible(rule3, count2);
    }
    this.logger.warn("no plural rule found for: ".concat(code));
    return "";
  }
  getSuffixRetroCompatible(rule3, count2) {
    const idx = rule3.noAbs ? rule3.plurals(count2) : rule3.plurals(Math.abs(count2));
    let suffix = rule3.numbers[idx];
    if (this.options.simplifyPluralSuffix && rule3.numbers.length === 2 && rule3.numbers[0] === 1) {
      if (suffix === 2) {
        suffix = "plural";
      } else if (suffix === 1) {
        suffix = "";
      }
    }
    const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
    if (this.options.compatibilityJSON === "v1") {
      if (suffix === 1) return "";
      if (typeof suffix === "number") return "_plural_".concat(suffix.toString());
      return returnSuffix();
    } else if (this.options.compatibilityJSON === "v2") {
      return returnSuffix();
    } else if (this.options.simplifyPluralSuffix && rule3.numbers.length === 2 && rule3.numbers[0] === 1) {
      return returnSuffix();
    }
    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  }
  shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  }
}
const deepFindWithDefaults = function(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path = getPathWithDefaults(data, defaultData, key);
  if (!path && ignoreJSONStructure && isString$1(key)) {
    path = deepFind(data, key, keySeparator);
    if (path === void 0) path = deepFind(defaultData, key, keySeparator);
  }
  return path;
};
const regexSafe = (val) => val.replace(/\$/g, "$$$$");
class Interpolator {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || ((value) => value);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1 !== void 0 ? escape$1 : escape;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp && existingRegExp.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, "".concat(this.prefix, "(.+?)").concat(this.suffix));
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix));
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix));
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path;
      }
      const p = key.split(this.formatSeparator);
      const k = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value = isString$1(temp) ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));
            value = "";
          }
        } else if (!isString$1(value) && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match;
    let value;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c2 = key.split(new RegExp("".concat(sep, "[ ]*{")));
      let optionsString = "{".concat(c2[1]);
      key = c2[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e2) {
        this.logger.warn("failed parsing options string in nesting for key ".concat(key), e2);
        return "".concat(key).concat(sep).concat(optionsString);
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString$1(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
        const r2 = match[1].split(this.formatSeparator).map((elem) => elem.trim());
        match[1] = r2.shift();
        formatters = r2;
        doReduce = true;
      }
      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && !isString$1(value)) return value;
      if (!isString$1(value)) value = makeString(value);
      if (!value) {
        this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
        value = "";
      }
      if (doReduce) {
        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
}
const parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest2] = opt.split(":");
          const val = rest2.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
const createCachedFormatter = (fn) => {
  const cache = {};
  return (val, lng, options) => {
    let optForCache = options;
    if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [options.interpolationkey]: void 0
      };
    }
    const key = lng + JSON.stringify(optForCache);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
};
class Formatter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => (val) => new Intl.NumberFormat(lng, {
        ...opt
      }).format(val)),
      currency: createCachedFormatter((lng, opt) => (val) => new Intl.NumberFormat(lng, {
        ...opt,
        style: "currency"
      }).format(val)),
      datetime: createCachedFormatter((lng, opt) => (val) => new Intl.DateTimeFormat(lng, {
        ...opt
      }).format(val)),
      relativetime: createCachedFormatter((lng, opt) => (val) => new Intl.RelativeTimeFormat(lng, {
        ...opt
      }).format(val, opt.range || "day")),
      list: createCachedFormatter((lng, opt) => (val) => new Intl.ListFormat(lng, {
        ...opt
      }).format(val))
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = options.interpolation.formatSeparator || ",";
  }
  add(name2, fc) {
    this.formats[name2.toLowerCase().trim()] = fc;
  }
  addCached(name2, fc) {
    this.formats[name2.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format2, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format2.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f) => f.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f) => f.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error2) {
          this.logger.warn(error2);
        }
        return formatted;
      } else {
        this.logger.warn("there was no format function for ".concat(formatName));
      }
      return mem;
    }, value);
    return result;
  }
}
const removePending = (q, name2) => {
  if (q.pending[name2] !== void 0) {
    delete q.pending[name2];
    q.pendingCount--;
  }
};
class Connector extends EventEmitter {
  constructor(backend, store, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    if (this.backend && this.backend.init) {
      this.backend.init(services, options.backend, options);
    }
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name2 = "".concat(lng, "|").concat(ns);
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name2] = 2;
        } else if (this.state[name2] < 0) ;
        else if (this.state[name2] === 1) {
          if (pending[name2] === void 0) pending[name2] = true;
        } else {
          this.state[name2] = 1;
          hasAllNamespaces = false;
          if (pending[name2] === void 0) pending[name2] = true;
          if (toLoad[name2] === void 0) toLoad[name2] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name2, err, data) {
    const s2 = name2.split("|");
    const lng = s2[0];
    const ns = s2[1];
    if (err) this.emit("failedLoading", lng, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name2] = err ? -1 : 2;
    if (err && data) this.state[name2] = 0;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name2);
      if (err) q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l) => {
          if (!loaded[l]) loaded[l] = {};
          const loadedKeys = q.loaded[l];
          if (loadedKeys.length) {
            loadedKeys.forEach((n2) => {
              if (loaded[l][n2] === void 0) loaded[l][n2] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r2 = fc(lng, ns);
        if (r2 && typeof r2.then === "function") {
          r2.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r2);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString$1(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString$1(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name2) => {
      this.loadOne(name2);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name2) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s2 = name2.split("|");
    const lng = s2[0];
    const ns = s2[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err) this.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
      if (!err && data) this.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);
      this.loaded(name2, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
      this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if (this.backend && this.backend.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r2;
          if (fc.length === 5) {
            r2 = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r2 = fc(languages, namespace, key, fallbackValue);
          }
          if (r2 && typeof r2.then === "function") {
            r2.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r2);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
}
const get$4 = () => ({
  debug: false,
  initImmediate: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (isString$1(args[1])) ret.defaultValue = args[1];
    if (isString$1(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value) => value,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  }
});
const transformOptions = (options) => {
  if (isString$1(options.ns)) options.ns = [options.ns];
  if (isString$1(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
  if (isString$1(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
};
const noop = () => {
};
const bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
class I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initImmediate) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (isString$1(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get$4();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    if (this.options.compatibilityAPI !== "v1") {
      this.options.interpolation = {
        ...defOpts.interpolation,
        ...this.options.interpolation
      };
    }
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else if (typeof Intl !== "undefined") {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s2 = this.services;
      s2.logger = baseLogger;
      s2.resourceStore = this.store;
      s2.languageUtils = lu;
      s2.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s2.formatter = createClassOnDemand(formatter);
        s2.formatter.init(s2, this.options);
        this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
      }
      s2.interpolator = new Interpolator(this.options);
      s2.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
      s2.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s2.languageDetector.init) s2.languageDetector.init(s2, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s2.i18nFormat.init) s2.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m) => {
        if (m.init) m.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initImmediate) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    let usedCallback = callback;
    const usedLng = isString$1(language) ? language : this.language;
    if (typeof language === "function") usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append = (lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l) => {
          if (l === "cimode") return;
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l) => append(l));
      } else {
        append(usedLng);
      }
      if (this.options.preload) {
        this.options.preload.forEach((l) => append(l));
      }
      this.services.backendConnector.load(toLoad, this.options.ns, (e2) => {
        if (!e2 && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e2);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module2) {
    if (!module2) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module2.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module2.type === "backend") {
      this.modules.backend = module2;
    }
    if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
      this.modules.logger = module2;
    }
    if (module2.type === "languageDetector") {
      this.modules.languageDetector = module2;
    }
    if (module2.type === "i18nFormat") {
      this.modules.i18nFormat = module2;
    }
    if (module2.type === "postProcessor") {
      postProcessor.addPostProcessor(module2);
    }
    if (module2.type === "formatter") {
      this.modules.formatter = module2;
    }
    if (module2.type === "3rdParty") {
      this.modules.external.push(module2);
    }
    return this;
  }
  setResolvedLanguage(l) {
    if (!l || !this.languages) return;
    if (["cimode", "dev"].indexOf(l) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l) => {
      this.language = l;
      this.languages = this.services.languageUtils.toResolveHierarchy(l);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l);
    };
    const done = (err, l) => {
      if (l) {
        setLngProps(l);
        this.translator.changeLanguage(l);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l);
        this.logger.log("languageChanged", l);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback) callback(err, function() {
        return _this2.t(...arguments);
      });
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const l = isString$1(lngs) ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l) {
        if (!this.language) {
          setLngProps(l);
        }
        if (!this.translator.language) this.translator.changeLanguage(l);
        if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l);
      }
      this.loadResources(l, (err) => {
        done(err, l);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest2 = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest2[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest2));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      if (options.keyPrefix !== "") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k) => "".concat(options.keyPrefix).concat(keySeparator).concat(k));
      } else {
        resultKey = options.keyPrefix ? "".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;
      }
      return _this3.t(resultKey, options);
    };
    if (isString$1(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = (l, n2) => {
      const loadState = this.services.backendConnector.state["".concat(l, "|").concat(n2)];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString$1(ns)) ns = [ns];
    ns.forEach((n2) => {
      if (this.options.ns.indexOf(n2) < 0) this.options.ns.push(n2);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (isString$1(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get$4());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone3 = new I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone3.logger = clone3.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m) => {
      clone3[m] = this[m];
    });
    clone3.services = {
      ...this.services
    };
    clone3.services.utils = {
      hasLoadedNamespace: clone3.hasLoadedNamespace.bind(clone3)
    };
    if (forkResourceStore) {
      clone3.store = new ResourceStore(this.store.data, mergedOptions);
      clone3.services.resourceStore = clone3.store;
    }
    clone3.translator = new Translator(clone3.services, mergedOptions);
    clone3.translator.on("*", function(event) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      clone3.emit(event, ...args);
    });
    clone3.init(mergedOptions, callback);
    clone3.translator.options = mergedOptions;
    clone3.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone3.hasLoadedNamespace.bind(clone3)
    };
    return clone3;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
var _translations;
var translations = (_translations = {}, _defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_translations, EMPTY_GROUP, "Empty group"), EMPTY_RULE_GROUP, "No conditions for group field {{field}}"), EMPTY_QUERY, "Empty query"), EMPTY_CASE, "Empty case"), NO_CONFIG_FOR_FIELD, "No config for field {{field}}"), FIXED_OPERATOR, "Fixed operator {{from}} to {{to}} for field {{field}}"), NO_CONFIG_FOR_OPERATOR, "No config for operator {{operator}}"), NO_CONFIG_FOR_FUNCTION, "No config for function {{funcKey}}"), INVALID_VALUE, "Invalid value"), INVALID_FUNC_ARG_VALUE, "Invalid value of arg {{argName}} for func {{funcName}}: {{argValidationError}}"), _defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_translations, UNSUPPORTED_FIELD_TYPE, "Type of field {{field}} is not supported"), UNSUPPORTED_OPERATOR_FOR_FIELD, "Operator {{operator}} is not supported for field {{field}}"), INCOMPLETE_RULE, "Incomplete rule"), INCOMPLETE_LHS, "Incomplete LHS"), INCOMPLETE_RHS, "Incomplete RHS"), INVALID_VALUE_SRC, "Invalid value src {{valueSrcs, list}}"), BAD_MULTISELECT_VALUES + "_one", "Value {{badValues, list}} is not in the list of allowed values"), BAD_MULTISELECT_VALUES + "_other", "Values {{badValues, list}} are not in the list of allowed values"), BAD_SELECT_VALUE, "Value {{value}} is not in the list of allowed values"), INCORRECT_VALUE_TYPE, "Value should have type {{wType}}, but got value of type {{valueType}}"), _defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_translations, INCORRECT_VALUE_JS_TYPE, "Value should have JS type {{jsType}}, but got value of type {{valueTypeof}}"), VALUE_LENGTH_CONSTRAINT_FAIL, "Value {{value}} should have max length {{fieldSettings.maxLength}} but got {{length}}"), VALUE_MIN_CONSTRAINT_FAIL, "Value {{value}} should be greater than or equal to {{fieldSettings.min}}"), VALUE_MIN_CONSTRAINT_FAIL + "_" + _CONTEXT_MIN_MAX, "Value {{value}} should be from {{fieldSettings.min}} to {{fieldSettings.max}}"), VALUE_MAX_CONSTRAINT_FAIL, "Value {{value}} should be less than or equal to {{fieldSettings.max}}"), VALUE_MAX_CONSTRAINT_FAIL + "_" + _CONTEXT_MIN_MAX, "Value {{value}} should be from {{fieldSettings.min}} to {{fieldSettings.max}}"), NO_CONFIG_FOR_FIELD_VALUE, "No config for field {{field}}"), CANT_COMPARE_FIELD_WITH_ITSELF, "Can't compare field {{field}} with itself"), CANT_COMPARE_FIELD_WITH_FIELD, "Can't compare field {{leftField}} with {{rightField}}"), INCORRECT_FIELD_TYPE, "Field {{field}} is of type {{type}}, but expected {{expected}}"), _defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_translations, UNSUPPORTED_FUNCTION_FOR_FIELD, "Unsupported function {{funcKey}} for field {{field}}"), REQUIRED_FUNCTION_ARG, "Value of arg {{argName}} for func {{funcName}} is required"), INCORRECT_FUNCTION_RETURN_TYPE, "Function {{funcKey}} should return value of type {{returnType}}, but got {{valueType}}"), INVALID_RANGE, "Invalid range"), ITEM_POSITION_ROOT, "Root"), ITEM_POSITION + "__rule", "Leaf #{{globalLeafNo}}"), ITEM_POSITION + "__group", "Group #{{globalGroupNo}}"), ITEM_POSITION + "__rule_group", "Rule-group #{{globalNoByType}}"), ITEM_POSITION + "__case_group", "Case #{{globalNoByType}}"), ITEM_POSITION + "__rule__deleted", "Deleted leaf #{{globalLeafNo}}"), _defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_translations, ITEM_POSITION + "__group__deleted", "Deleted group #{{globalGroupNo}}"), ITEM_POSITION + "__rule_group__deleted", "Deleted rule-group #{{globalNoByType}}"), ITEM_POSITION + "__case_group__deleted", "Deleted case #{{globalNoByType}}"), ITEM_POSITION_IN_CASE, "{{str}} in case #{{caseNo}}"), ITEM_POSITION_WITH_INDEX_PATH, "{{str}} (index path: {{indexPath, list}})"));
var NSV = "raqbvalidation";
var NSVP = "".concat(NSV, ":");
var i18n = instance.createInstance();
i18n.init({
  fallbackLng: "en"
});
i18n.addResources("en", NSV, translations);
var translateValidation = function translateValidation2(key, args) {
  if (key !== null && key !== void 0 && key.str) {
    return key.str;
  }
  if (key !== null && key !== void 0 && key.key) {
    return translateValidation2(key.key, key.args);
  }
  if (args === null) {
    return key;
  }
  return i18n.t(key.includes(":") ? key : NSVP + key, args);
};
function ownKeys$w(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$w(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$w(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$w(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var typeOf = function typeOf2(v) {
  if (_typeof$3(v) === "object" && v !== null && Array.isArray(v)) return "array";
  else return _typeof$3(v);
};
var isTypeOf = function isTypeOf2(v, type2) {
  if (typeOf(v) === type2) return true;
  if (type2 === "number" && !isNaN(v)) return true;
  return false;
};
var isValidTree = function isValidTree2(tree2, config2) {
  return getTreeBadFields(tree2, config2).length === 0;
};
var getTreeBadFields = function getTreeBadFields2(tree2, config2) {
  var showErrorMessage = config2.settings.showErrorMessage;
  var badFields = [];
  function _processNode(item, path, lev) {
    var _field$get, _field$get2;
    var id2 = item.get("id");
    var children = item.get("children1");
    var valueError = item.getIn(["properties", "valueError"]);
    var fieldError = item.getIn(["properties", "fieldError"]);
    var field = item.getIn(["properties", "field"]);
    var fieldStr = (_field$get = field === null || field === void 0 || (_field$get2 = field.get) === null || _field$get2 === void 0 ? void 0 : _field$get2.call(field, "func")) !== null && _field$get !== void 0 ? _field$get : field;
    var hasValueError = (valueError === null || valueError === void 0 ? void 0 : valueError.size) > 0 && valueError.filter(function(v) {
      return v != null;
    }).size > 0;
    var isBad = hasValueError || !!fieldError;
    if (isBad && showErrorMessage) {
      badFields.push(fieldStr);
    }
    if (children) {
      children.map(function(child, _childId) {
        if (child) {
          _processNode(child, path.concat(id2));
        }
      });
    }
  }
  if (tree2) _processNode(tree2, []);
  return Array.from(new Set(badFields));
};
var checkTree = function checkTree2(tree2, config2) {
  var extendedConfig = extendConfig(config2, void 0, true);
  var options = {
    removeEmptyGroups: config2.settings.removeEmptyGroupsOnLoad,
    removeIncompleteRules: config2.settings.removeIncompleteRulesOnLoad,
    removeEmptyRules: config2.settings.removeEmptyRulesOnLoad,
    forceFix: false
  };
  var _validateTree22 = _validateTree(tree2, null, extendedConfig, extendedConfig, options), fixedTree = _validateTree22.fixedTree, allErrors = _validateTree22.allErrors, isSanitized = _validateTree22.isSanitized;
  if (isSanitized && allErrors.length) {
    console.warn("Tree check errors: ", allErrors);
  }
  return fixedTree;
};
var validateTree = function validateTree2(tree2, config2) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var extendedConfig = extendConfig(config2, void 0, true);
  var finalOptions = _objectSpread$w(_objectSpread$w({}, options), {}, {
    // disbale sanitize options, just validate
    removeEmptyGroups: false,
    removeEmptyRules: false,
    removeIncompleteRules: false,
    forceFix: false
  });
  var _validateTree3 = _validateTree(tree2, null, extendedConfig, extendedConfig, finalOptions), allErrors = _validateTree3.allErrors;
  return allErrors;
};
var sanitizeTree = function sanitizeTree2(tree2, config2) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var extendedConfig = extendConfig(config2, void 0, true);
  var finalOptions = _objectSpread$w({
    // defaults
    removeEmptyGroups: true,
    removeEmptyRules: true,
    removeIncompleteRules: true,
    forceFix: false
  }, options);
  var _validateTree4 = _validateTree(tree2, null, extendedConfig, extendedConfig, finalOptions), fixedTree = _validateTree4.fixedTree, fixedErrors = _validateTree4.fixedErrors, nonFixedErrors = _validateTree4.nonFixedErrors, allErrors = _validateTree4.allErrors;
  return {
    fixedTree,
    fixedErrors,
    nonFixedErrors,
    allErrors
  };
};
var validateAndFixTree$1 = function validateAndFixTree(newTree2, _oldTree, newConfig, oldConfig, removeEmptyGroups, removeEmptyRules, removeIncompleteRules) {
  if (removeEmptyGroups === void 0) {
    removeEmptyGroups = newConfig.settings.removeEmptyGroupsOnLoad;
  }
  if (removeEmptyRules === void 0) {
    removeEmptyRules = newConfig.settings.removeEmptyRulesOnLoad;
  }
  if (removeIncompleteRules === void 0) {
    removeIncompleteRules = newConfig.settings.removeIncompleteRulesOnLoad;
  }
  var options = {
    // sanitize options
    removeEmptyGroups,
    removeEmptyRules,
    removeIncompleteRules,
    forceFix: false
  };
  var _validateTree5 = _validateTree(newTree2, _oldTree, newConfig, oldConfig, options), fixedTree = _validateTree5.fixedTree;
  _validateTree5.allErrors;
  var fixedErrors = _validateTree5.fixedErrors;
  _validateTree5.nonFixedErrors;
  var isSanitized = _validateTree5.isSanitized;
  if (isSanitized && fixedErrors.length) {
    console.warn("Fixed tree errors: ", fixedErrors);
  }
  fixedTree = fixPathsInTree(fixedTree);
  return fixedTree;
};
var _validateTree = function _validateTree2(tree2, _oldTree, config2, oldConfig, options) {
  if (!tree2) {
    return {
      fixedTree: tree2,
      allErrors: [],
      fixedErrors: [],
      nonFixedErrors: [],
      isSanitized: false
    };
  }
  var _ref = options || {}, removeEmptyGroups = _ref.removeEmptyGroups, removeEmptyRules = _ref.removeEmptyRules, removeIncompleteRules = _ref.removeIncompleteRules, forceFix = _ref.forceFix, _ref$translateErrors = _ref.translateErrors, translateErrors = _ref$translateErrors === void 0 ? true : _ref$translateErrors, _ref$includeStringifi = _ref.includeStringifiedItems, includeStringifiedItems = _ref$includeStringifi === void 0 ? true : _ref$includeStringifi, _ref$stringifyFixedIt = _ref.stringifyFixedItems, stringifyFixedItems = _ref$stringifyFixedIt === void 0 ? false : _ref$stringifyFixedIt, _ref$stringifyItemsUs = _ref.stringifyItemsUserFriendly, stringifyItemsUserFriendly = _ref$stringifyItemsUs === void 0 ? true : _ref$stringifyItemsUs, _ref$includeItemsPosi = _ref.includeItemsPositions, includeItemsPositions = _ref$includeItemsPosi === void 0 ? true : _ref$includeItemsPosi;
  var c2 = {
    config: config2,
    oldConfig,
    removeEmptyGroups,
    removeEmptyRules,
    removeIncompleteRules,
    forceFix
  };
  var meta = {
    errors: {}
  };
  var fixedTree = validateItem(tree2, [], null, meta, c2);
  var isSanitized = meta.sanitized;
  var allErrors = [];
  var flatItems, oldFlatItems;
  if (includeItemsPositions) {
    flatItems = getFlatTree$1(fixedTree).items;
  }
  for (var id2 in meta.errors) {
    var _meta$errors$id = meta.errors[id2], path = _meta$errors$id.path, errors = _meta$errors$id.errors;
    if (translateErrors) {
      errors = errors.map(function(e2) {
        return _objectSpread$w(_objectSpread$w({}, e2), {}, {
          str: translateValidation(e2)
        });
      });
    }
    var errorItem2 = {
      path,
      errors
    };
    if (includeStringifiedItems) {
      var item = getItemByPath(stringifyFixedItems ? fixedTree : tree2, path);
      var isRoot = path.length === 1;
      if (!isRoot && item.get("type") !== "group") {
        var isDebugMode = true;
        var isForDisplay = stringifyItemsUserFriendly;
        var itemStr = queryString(item, config2, isForDisplay, isDebugMode);
        errorItem2.itemStr = itemStr;
      }
    }
    if (includeItemsPositions) {
      var flatItem = flatItems[id2];
      var isDeleted = !flatItem;
      if (isDeleted) {
        if (!oldFlatItems) {
          oldFlatItems = getFlatTree$1(tree2).items;
        }
        flatItem = oldFlatItems[id2];
      }
      if (flatItem) {
        var itemPosition = _objectSpread$w(_objectSpread$w({}, flatItem.position), {}, {
          index: flatItem.index,
          type: flatItem.type,
          isDeleted
        });
        errorItem2.itemPosition = itemPosition;
        var trKey = !flatItem.index ? ITEM_POSITION_ROOT : ITEM_POSITION + "__" + flatItem.type + (isDeleted ? "__deleted" : "");
        var trArgs = _objectSpread$w({}, itemPosition);
        if (stringifyItemsUserFriendly) {
          var _itemPosition$indexPa;
          for (var _i = 0, _arr = ["caseNo", "globalLeafNo", "globalGroupNo", "globalNoByType"]; _i < _arr.length; _i++) {
            var k = _arr[_i];
            if (trArgs[k] != void 0) {
              trArgs[k] = trArgs[k] + 1;
            }
          }
          trArgs.indexPath = (_itemPosition$indexPa = itemPosition.indexPath) === null || _itemPosition$indexPa === void 0 ? void 0 : _itemPosition$indexPa.map(function(ind) {
            return ind + 1;
          });
        }
        errorItem2.itemPositionStr = translateValidation(trKey, trArgs);
        if (flatItem.index) {
          if (flatItem.caseId && flatItem.type !== "case_group") {
            errorItem2.itemPositionStr = translateValidation(ITEM_POSITION_IN_CASE, _objectSpread$w(_objectSpread$w({}, trArgs), {}, {
              str: errorItem2.itemPositionStr
            }));
          }
          if (flatItem.type !== "case_group") {
            errorItem2.itemPositionStr = translateValidation(ITEM_POSITION_WITH_INDEX_PATH, _objectSpread$w(_objectSpread$w({}, trArgs), {}, {
              str: errorItem2.itemPositionStr
            }));
          }
        }
      }
    }
    allErrors.push(errorItem2);
  }
  var fixedErrors = [];
  var nonFixedErrors = [];
  for (var _i2 = 0, _allErrors = allErrors; _i2 < _allErrors.length; _i2++) {
    var itemErrors = _allErrors[_i2];
    var fixedItemErrors = itemErrors.errors.filter(function(e2) {
      return !!e2.fixed;
    });
    var nonFixedItemErrors = itemErrors.errors.filter(function(e2) {
      return !e2.fixed && e2.key !== "EMPTY_QUERY";
    });
    if (fixedItemErrors.length) {
      fixedErrors.push(_objectSpread$w(_objectSpread$w({}, itemErrors), {}, {
        errors: fixedItemErrors
      }));
    }
    if (nonFixedItemErrors.length) {
      nonFixedErrors.push(_objectSpread$w(_objectSpread$w({}, itemErrors), {}, {
        errors: nonFixedItemErrors
      }));
    }
  }
  return {
    fixedTree,
    allErrors,
    fixedErrors,
    nonFixedErrors,
    isSanitized
  };
};
function _addError(meta, item, path, err) {
  var id2 = item.get("id");
  if (!meta.errors[id2]) {
    meta.errors[id2] = {
      path: [].concat(_toConsumableArray(path), [id2]),
      errors: []
    };
  }
  meta.errors[id2].errors.push(err);
}
function _setErrorsAsFixed(meta, item) {
  var id2 = item.get("id");
  if (meta.errors[id2]) {
    meta.errors[id2].errors.map(function(e2) {
      e2.fixed = true;
    });
  }
}
function validateItem(item, path, itemId, meta, c2) {
  var type2 = item === null || item === void 0 ? void 0 : item.get("type");
  if (type2 === "group" || type2 === "rule_group" || type2 == "case_group" || type2 == "switch_group") {
    return validateGroup(item, path, itemId, meta, c2);
  } else if (type2 === "rule") {
    return validateRule(item, path, itemId, meta, c2);
  } else {
    return item;
  }
}
function validateGroup(item, path, itemId, meta, c2) {
  var _properties$get, _config$operators$ope, _config$operators$ope2, _children, _children2, _children3;
  var removeEmptyGroups = c2.removeEmptyGroups, removeIncompleteRules = c2.removeIncompleteRules;
  c2.forceFix;
  var config2 = c2.config;
  config2.settings.showErrorMessage;
  var id2 = item.get("id");
  var children = item.get("children1");
  var isRoot = !path.length;
  var oldChildren = children;
  var type2 = item.get("type");
  var properties = item.get("properties");
  var field = properties === null || properties === void 0 ? void 0 : properties.get("field");
  var mode = properties === null || properties === void 0 ? void 0 : properties.get("mode");
  var operator = properties === null || properties === void 0 || (_properties$get = properties.get) === null || _properties$get === void 0 ? void 0 : _properties$get.call(properties, "operator");
  var isGroupExt = type2 === "rule_group" && mode === "array";
  var isCase = type2 === "case_group";
  var isDefaultCase = isCase && children == void 0;
  var cardinality = operator ? (_config$operators$ope = (_config$operators$ope2 = config2.operators[operator]) === null || _config$operators$ope2 === void 0 ? void 0 : _config$operators$ope2.cardinality) !== null && _config$operators$ope !== void 0 ? _config$operators$ope : 1 : void 0;
  var childrenAreRequired = isCase ? !isDefaultCase : isGroupExt ? cardinality == 0 : removeEmptyGroups;
  var canHaveValue = isGroupExt || isCase;
  if (!id2 && itemId) {
    id2 = itemId;
    item = item.set("id", id2);
    meta.sanitized = true;
  }
  if (canHaveValue) {
    item = validateRule(item, path, itemId, meta, c2);
  }
  var submeta = {
    errors: {}
  };
  children = (_children = children) === null || _children === void 0 ? void 0 : _children.map(function(currentChild, childId) {
    return validateItem(currentChild, path.concat(id2), childId, submeta, c2);
  });
  var nonEmptyChildren = (_children2 = children) === null || _children2 === void 0 ? void 0 : _children2.filter(function(currentChild) {
    return currentChild != void 0;
  });
  if (removeEmptyGroups) {
    children = nonEmptyChildren;
  }
  var sanitized = submeta.sanitized || (oldChildren === null || oldChildren === void 0 ? void 0 : oldChildren.size) != ((_children3 = children) === null || _children3 === void 0 ? void 0 : _children3.size);
  var isEmptyChildren = !(nonEmptyChildren !== null && nonEmptyChildren !== void 0 && nonEmptyChildren.size);
  var canDrop = removeEmptyGroups && !isRoot;
  if (isGroupExt && field) {
    canDrop = removeIncompleteRules;
  }
  if (isEmptyChildren && childrenAreRequired) {
    _addError(meta, item, path, {
      key: isRoot ? EMPTY_QUERY : isCase ? EMPTY_CASE : isGroupExt ? EMPTY_RULE_GROUP : EMPTY_GROUP,
      args: {
        field
      },
      fixed: canDrop
    });
    if (canDrop) {
      _setErrorsAsFixed(meta, item);
      item = void 0;
    }
  }
  if (sanitized) meta.sanitized = true;
  if (sanitized && item) item = item.set("children1", children);
  meta.errors = _objectSpread$w(_objectSpread$w({}, meta.errors), (submeta === null || submeta === void 0 ? void 0 : submeta.errors) || {});
  return item;
}
function validateRule(item, path, itemId, meta, c2) {
  var removeIncompleteRules = c2.removeIncompleteRules, removeEmptyRules = c2.removeEmptyRules, forceFix = c2.forceFix, config2 = c2.config, oldConfig = c2.oldConfig;
  var showErrorMessage = config2.settings.showErrorMessage;
  var canFix = !showErrorMessage || forceFix;
  var id2 = item.get("id");
  var type2 = item.get("type");
  var isCase = type2 === "case_group";
  var properties = item.get("properties");
  if (!properties) {
    if (isCase) {
      properties = new Immutable.Map();
    } else {
      var err = {
        key: INCOMPLETE_RULE,
        args: {},
        fixed: removeIncompleteRules || removeEmptyRules
      };
      _addError(meta, item, path, err);
      return void 0;
    }
  }
  var field = properties.get("field") || null;
  if (isCase) {
    field = "!case_value";
  }
  var fieldSrc = properties.get("fieldSrc") || null;
  var operator = properties.get("operator") || null;
  var operatorOptions = properties.get("operatorOptions");
  var valueSrc = properties.get("valueSrc");
  var value = properties.get("value");
  var valueError = properties.get("valueError");
  var fieldError = properties.get("fieldError");
  var serializeRule = function serializeRule2() {
    var _field, _field$toJS;
    return {
      field: ((_field = field) === null || _field === void 0 || (_field$toJS = _field.toJS) === null || _field$toJS === void 0 ? void 0 : _field$toJS.call(_field)) || field,
      fieldSrc,
      operator,
      operatorOptions: operatorOptions ? operatorOptions.toJS() : {},
      valueSrc: valueSrc ? valueSrc.toJS() : null,
      value: value ? value.toJS() : null,
      valueError: valueError ? valueError.toJS() : null,
      fieldError: fieldError ? fieldError : null
    };
  };
  var oldSerialized = serializeRule();
  if (!id2 && itemId) {
    id2 = itemId;
    item = item.set("id", id2);
    meta.sanitized = true;
  }
  var fieldDefinition = field ? getFieldConfig$8(config2, field) : null;
  if (field && !fieldDefinition) {
    _addError(meta, item, path, {
      key: NO_CONFIG_FOR_FIELD,
      args: {
        field
      },
      side: "lhs",
      fixed: removeIncompleteRules || removeEmptyRules
    });
    field = null;
  }
  if (field == null && !isCase) {
    properties = ["operator", "operatorOptions", "valueSrc", "value", "valueError", "fieldError", "field"].reduce(function(map3, key) {
      return map3["delete"](key);
    }, properties);
    operator = null;
  }
  if (!fieldSrc && field && !isCase) {
    fieldSrc = getFieldSrc(field);
    properties = properties.set("fieldSrc", fieldSrc);
  }
  if (operator === "range_between" || operator === "range_not_between") {
    operator = operator === "range_between" ? "between" : "not_between";
    properties = properties.set("operator", operator);
  }
  var operatorDefinition = operator ? getOperatorConfig$4(config2, operator, field) : null;
  if (operator && !operatorDefinition) {
    _addError(meta, item, path, {
      key: NO_CONFIG_FOR_OPERATOR,
      args: {
        operator
      },
      side: "op",
      fixed: removeIncompleteRules || removeEmptyRules
    });
    operator = null;
  }
  var availOps = field ? getOperatorsForField(config2, field) : [];
  if (field && !isCase) {
    if (!(availOps !== null && availOps !== void 0 && availOps.length)) {
      _addError(meta, item, path, {
        key: UNSUPPORTED_FIELD_TYPE,
        args: {
          field
        },
        side: "lhs",
        fixed: removeIncompleteRules || removeEmptyRules
      });
      operator = null;
    } else if (operator && availOps.indexOf(operator) == -1) {
      if (operator === "is_empty" || operator === "is_not_empty") {
        operator = operator === "is_empty" ? "is_null" : "is_not_null";
        properties = properties.set("operator", operator);
      } else {
        _addError(meta, item, path, {
          key: UNSUPPORTED_OPERATOR_FOR_FIELD,
          args: {
            operator,
            field
          },
          side: "lhs",
          fixed: removeIncompleteRules || removeEmptyRules
        });
        operator = null;
      }
    }
  }
  if (operator == null && !isCase) {
    properties = ["operatorOptions", "valueSrc", "value", "valueError"].reduce(function(map3, key) {
      return map3["delete"](key);
    }, properties);
  }
  operatorOptions = properties.get("operatorOptions");
  if (!operator || operatorOptions && !operatorDefinition.options) {
    operatorOptions = null;
    properties = properties["delete"]("operatorOptions");
  } else if (operator && !operatorOptions && operatorDefinition.options) {
    operatorOptions = defaultOperatorOptions(config2, operator, field);
    properties = properties.set("operatorOptions", operatorOptions);
  }
  valueSrc = properties.get("valueSrc");
  value = properties.get("value");
  var isEndValue = true;
  var _getNewValueForFieldO = getNewValueForFieldOp(config2, oldConfig, properties, field, operator, null, canFix, isEndValue), newValue = _getNewValueForFieldO.newValue, newValueSrc = _getNewValueForFieldO.newValueSrc, newValueError = _getNewValueForFieldO.newValueError, validationErrors = _getNewValueForFieldO.validationErrors, newFieldError = _getNewValueForFieldO.newFieldError, fixedField = _getNewValueForFieldO.fixedField;
  value = newValue;
  valueSrc = newValueSrc;
  valueError = newValueError;
  fieldError = newFieldError;
  field = fixedField;
  properties = properties.set("field", field);
  properties = properties.set("value", value);
  properties = properties.set("valueSrc", valueSrc);
  if (showErrorMessage) {
    properties = properties.set("valueError", valueError).set("fieldError", fieldError);
  } else {
    properties = properties["delete"]("valueError")["delete"]("fieldError");
  }
  var newSerialized = serializeRule();
  var hasBeenSanitized = !deepEqual(oldSerialized, newSerialized);
  var compl = whatRulePropertiesAreCompleted(properties.toObject(), config2);
  var isCompleted = isCase ? compl.parts.value : compl.score >= 3;
  if (hasBeenSanitized) {
    meta.sanitized = true;
    item = item.set("properties", properties);
  }
  validationErrors === null || validationErrors === void 0 || validationErrors.map(function(e2) {
    return _addError(meta, item, path, e2);
  });
  if (!isCompleted) {
    if (isCase) ;
    else {
      var shoudlRemoveRule = !compl.score ? removeEmptyRules : removeIncompleteRules;
      var incError = {
        key: INCOMPLETE_RULE,
        args: {}
      };
      if (!compl.parts.field) {
        incError.key = INCOMPLETE_LHS;
        incError.side = "lhs";
      } else if (!compl.parts.value) {
        var _newSerialized$valueS, _newSerialized$valueS2, _oldSerialized$valueS, _newSerialized$value;
        incError.key = INCOMPLETE_RHS;
        incError.side = "rhs";
        if ((_newSerialized$valueS = newSerialized.valueSrc) !== null && _newSerialized$valueS !== void 0 && _newSerialized$valueS[0] && ((_newSerialized$valueS2 = newSerialized.valueSrc) === null || _newSerialized$valueS2 === void 0 ? void 0 : _newSerialized$valueS2[0]) != ((_oldSerialized$valueS = oldSerialized.valueSrc) === null || _oldSerialized$valueS === void 0 ? void 0 : _oldSerialized$valueS[0]) && ((_newSerialized$value = newSerialized.value) === null || _newSerialized$value === void 0 ? void 0 : _newSerialized$value[0]) != void 0) {
          incError.key = INVALID_VALUE_SRC;
          incError.args = {
            valueSrcs: newSerialized.valueSrc
          };
        }
      }
      incError.fixed = shoudlRemoveRule;
      _addError(meta, item, path, incError);
      if (shoudlRemoveRule) {
        _setErrorsAsFixed(meta, item);
        item = void 0;
      }
    }
  }
  return item;
}
var validateValue = function validateValue2(config2, leftField, field, operator, value, valueType, valueSrc, asyncListValues) {
  var canFix = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
  var isEndValue = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : false;
  var canDropArgs = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : false;
  var allErrors = [];
  var fixedValue = value;
  if (value != null) {
    var _allErrors2, _allErrors3, _allErrors4, _allErrors5;
    if (valueSrc === "field") {
      var _validateFieldValue = validateFieldValue(leftField, field, value, valueSrc, valueType, asyncListValues, config2, operator, canFix, isEndValue);
      var _validateFieldValue2 = _slicedToArray$1(_validateFieldValue, 2);
      fixedValue = _validateFieldValue2[0];
      allErrors = _validateFieldValue2[1];
    } else if (valueSrc === "func") {
      var _validateFuncValue = validateFuncValue(leftField, field, value, valueSrc, valueType, asyncListValues, config2, operator, canFix, isEndValue, canDropArgs);
      var _validateFuncValue2 = _slicedToArray$1(_validateFuncValue, 2);
      fixedValue = _validateFuncValue2[0];
      allErrors = _validateFuncValue2[1];
    } else if (valueSrc === "value" || !valueSrc) {
      var _validateNormalValue = validateNormalValue(field, value, valueSrc, valueType, asyncListValues, config2, operator, canFix, isEndValue);
      var _validateNormalValue2 = _slicedToArray$1(_validateNormalValue, 2);
      fixedValue = _validateNormalValue2[0];
      allErrors = _validateNormalValue2[1];
    }
    var fixedAllErrors = !((_allErrors2 = allErrors) !== null && _allErrors2 !== void 0 && _allErrors2.find(function(e2) {
      return !e2.fixed;
    }));
    var shouldCallValidateFn = !!field && !["field", "func"].includes(valueSrc) && (!((_allErrors3 = allErrors) !== null && _allErrors3 !== void 0 && _allErrors3.length) || fixedAllErrors);
    if (shouldCallValidateFn) {
      var w = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
      var operatorDefinition = operator ? getOperatorConfig$4(config2, operator, field) : null;
      var fieldWidgetDefinition = getFieldWidgetConfig$3(config2, field, operator, w, valueSrc, {
        forExport: true
      });
      var rightFieldDefinition = valueSrc === "field" ? getFieldConfig$8(config2, value) : null;
      var fieldSettings = fieldWidgetDefinition;
      var fn = fieldWidgetDefinition.validateValue;
      if (typeof fn === "function") {
        var args = [fixedValue, fieldSettings, operator, operatorDefinition];
        if (valueSrc === "field") args.push(rightFieldDefinition);
        var validResult = fn.call.apply(fn, [config2.ctx].concat(args));
        if (_typeof$3(validResult) === "object" && validResult !== null && !Array.isArray(validResult)) {
          var _validResult$error;
          var newError;
          if ((_validResult$error = validResult.error) !== null && _validResult$error !== void 0 && _validResult$error.key) {
            newError = _objectSpread$w({}, validResult.error);
          } else {
            newError = {
              key: validResult.error,
              args: null
            };
          }
          if (validResult.fixedValue !== void 0 && canFix) {
            newError.fixed = true;
            newError.fixedFrom = fixedValue;
            newError.fixedTo = validResult.fixedValue;
            fixedValue = validResult.fixedValue;
          }
          allErrors.push(newError);
        } else if (typeof validResult === "boolean") {
          if (validResult == false) {
            allErrors.push({
              key: INVALID_VALUE,
              args: {}
            });
          }
        } else if (typeof validResult === "string") {
          allErrors.push({
            key: validResult,
            args: null
          });
        }
      }
    }
    fixedAllErrors = !((_allErrors4 = allErrors) !== null && _allErrors4 !== void 0 && _allErrors4.find(function(e2) {
      return !e2.fixed;
    }));
    if ((_allErrors5 = allErrors) !== null && _allErrors5 !== void 0 && _allErrors5.length && !fixedAllErrors && canFix) {
      var fieldConfig = getFieldConfig$8(config2, field);
      var _fieldSettings = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.fieldSettings;
      var defaultValue = _fieldSettings === null || _fieldSettings === void 0 ? void 0 : _fieldSettings.defaultValue;
      if (defaultValue !== void 0) {
        var lastError = allErrors[allErrors.length - 1];
        lastError.fixed = true;
        lastError.fixedFrom = fixedValue;
        lastError.fixedTo = defaultValue;
        fixedValue = defaultValue;
        allErrors.map(function(e2) {
          e2.fixed = true;
        });
      }
    }
  }
  return [fixedValue, allErrors];
};
var validateValueInList = function validateValueInList2(value, listValues2, canFix, isEndValue, removeInvalidMultiSelectValuesOnLoad) {
  var values2 = Immutable.List.isList(value) ? value.toJS() : value instanceof Array ? _toConsumableArray(value) : void 0;
  var fixedValue = value;
  var allErrors = [];
  if (values2) {
    var _values$reduce = values2.reduce(function(_ref2, val) {
      var _ref3 = _slicedToArray$1(_ref2, 2), goodVals = _ref3[0], badVals = _ref3[1];
      var vv2 = getItemInListValues(listValues2, val);
      if (vv2 == void 0) {
        return [goodVals, [].concat(_toConsumableArray(badVals), [val])];
      } else {
        return [[].concat(_toConsumableArray(goodVals), [vv2.value]), badVals];
      }
    }, [[], []]), _values$reduce2 = _slicedToArray$1(_values$reduce, 2), goodValues = _values$reduce2[0], badValues = _values$reduce2[1];
    var needFix = badValues.length > 0;
    canFix = canFix || removeInvalidMultiSelectValuesOnLoad === true;
    fixedValue = canFix && needFix ? goodValues : value;
    if (badValues.length) {
      var fixed = canFix && needFix;
      allErrors.push({
        key: BAD_MULTISELECT_VALUES,
        args: {
          badValues,
          count: badValues.length
        },
        fixed,
        fixedFrom: fixed ? values2 : void 0,
        fixedTo: fixed ? fixedValue : void 0
      });
    }
    return [fixedValue, allErrors];
  } else {
    var vv = getItemInListValues(listValues2, value);
    if (vv == void 0) {
      fixedValue = canFix ? null : value;
      allErrors.push({
        key: BAD_SELECT_VALUE,
        args: {
          value
        },
        fixed: canFix,
        fixedFrom: canFix ? value : void 0,
        fixedTo: canFix ? fixedValue : void 0
      });
    } else {
      fixedValue = vv.value;
    }
    return [fixedValue, allErrors];
  }
};
var validateNormalValue = function validateNormalValue2(field, value, valueSrc, valueType, asyncListValues, config2) {
  var operator = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  var canFix = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
  var isEndValue = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
  var allErrors = [];
  var fixedValue = value;
  if (field) {
    var fieldConfig = getFieldConfig$8(config2, field);
    var w = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
    var wConfig = config2.widgets[w];
    var wType = wConfig === null || wConfig === void 0 ? void 0 : wConfig.type;
    var jsType = wConfig === null || wConfig === void 0 ? void 0 : wConfig.jsType;
    var fieldSettings = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.fieldSettings;
    var listValues2 = (fieldSettings === null || fieldSettings === void 0 ? void 0 : fieldSettings.treeValues) || (fieldSettings === null || fieldSettings === void 0 ? void 0 : fieldSettings.listValues);
    var isAsyncListValues = !!(fieldSettings !== null && fieldSettings !== void 0 && fieldSettings.asyncFetch);
    var canSkipTypeCheck = listValues2 || isAsyncListValues;
    if (valueType && wType && valueType != wType) {
      allErrors.push({
        key: INCORRECT_VALUE_TYPE,
        args: {
          wType,
          valueType
        }
      });
      return [value, allErrors];
    }
    if (jsType && !isTypeOf(value, jsType) && !canSkipTypeCheck) {
      allErrors.push({
        key: INCORRECT_VALUE_JS_TYPE,
        args: {
          jsType,
          valueTypeof: typeOf(value)
        }
      });
      return [value, allErrors];
    }
    if (fieldSettings) {
      var realListValues = asyncListValues || listValues2;
      if (realListValues && !fieldSettings.allowCustomValues && w !== "case_value") {
        var _validateValueInList = validateValueInList(value, realListValues, canFix, isEndValue, config2.settings.removeInvalidMultiSelectValuesOnLoad);
        var _validateValueInList2 = _slicedToArray$1(_validateValueInList, 2);
        fixedValue = _validateValueInList2[0];
        allErrors = _validateValueInList2[1];
      }
      if (fieldSettings.maxLength > 0 && value != null && String(value).length > fieldSettings.maxLength) {
        fixedValue = canFix ? String(value).substring(0, fieldSettings.maxLength) : value;
        allErrors.push({
          key: VALUE_LENGTH_CONSTRAINT_FAIL,
          args: {
            value,
            length: String(value).length,
            fieldSettings
          },
          fixed: canFix,
          fixedFrom: canFix ? value : void 0,
          fixedTo: canFix ? fixedValue : void 0
        });
      }
      var minMaxContext = fieldSettings.min != void 0 && fieldSettings.max != void 0 ? _CONTEXT_MIN_MAX : void 0;
      if (fieldSettings.min != null && value < fieldSettings.min) {
        fixedValue = canFix ? fieldSettings.min : value;
        allErrors.push({
          key: VALUE_MIN_CONSTRAINT_FAIL,
          args: {
            value,
            fieldSettings,
            context: minMaxContext
          },
          fixed: canFix,
          fixedFrom: canFix ? value : void 0,
          fixedTo: canFix ? fixedValue : void 0
        });
      }
      if (fieldSettings.max != null && value > fieldSettings.max) {
        fixedValue = canFix ? fieldSettings.max : value;
        allErrors.push({
          key: VALUE_MAX_CONSTRAINT_FAIL,
          args: {
            value,
            fieldSettings,
            context: minMaxContext
          },
          fixed: canFix,
          fixedFrom: canFix ? value : void 0,
          fixedTo: canFix ? fixedValue : void 0
        });
      }
    }
  }
  return [fixedValue, allErrors];
};
var validateFieldValue = function validateFieldValue2(leftField, field, value, _valueSrc, valueType, asyncListValues, config2) {
  var operator = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null;
  var allErrors = [];
  var _config$settings = config2.settings, fieldSeparator = _config$settings.fieldSeparator, canCompareFieldWithField2 = _config$settings.canCompareFieldWithField;
  var isFuncArg = _typeof$3(field) == "object" && (field === null || field === void 0 ? void 0 : field._isFuncArg);
  var leftFieldStr = Array.isArray(leftField) ? leftField.join(fieldSeparator) : leftField;
  var leftFieldConfig = getFieldConfig$8(config2, leftField);
  var rightFieldStr = Array.isArray(value) ? value.join(fieldSeparator) : value;
  var rightFieldConfig = getFieldConfig$8(config2, value);
  if (!rightFieldConfig) {
    allErrors.push({
      key: NO_CONFIG_FOR_FIELD_VALUE,
      args: {
        field: rightFieldStr
      }
    });
    return [value, allErrors];
  }
  if (leftField && rightFieldStr === leftFieldStr && !isFuncArg) {
    allErrors.push({
      key: CANT_COMPARE_FIELD_WITH_ITSELF,
      args: {
        field: leftFieldStr
      }
    });
    return [value, allErrors];
  }
  if (valueType && valueType != rightFieldConfig.type) {
    allErrors.push({
      key: INCORRECT_FIELD_TYPE,
      args: {
        field: rightFieldStr,
        type: rightFieldConfig.type,
        expected: valueType
      }
    });
    return [value, allErrors];
  }
  if (leftField && !isFuncArg && canCompareFieldWithField2) {
    var canUse = canCompareFieldWithField2(leftFieldStr, leftFieldConfig, rightFieldStr, rightFieldConfig, operator);
    if (!canUse) {
      allErrors.push({
        key: CANT_COMPARE_FIELD_WITH_FIELD,
        args: {
          leftField: leftFieldStr,
          rightField: rightFieldStr
        }
      });
      return [value, allErrors];
    }
  }
  return [value];
};
var validateFuncValue = function validateFuncValue2(leftField, field, value, _valueSrc, valueType, asyncListValues, config2) {
  var _value$get, _funcConfig$label;
  var operator = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null;
  var canFix = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
  var isEndValue = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : false;
  var canDropArgs = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : false;
  var fixedValue = value;
  var allErrors = [];
  if (!value) {
    return [value];
  }
  var funcKey = (_value$get = value.get) === null || _value$get === void 0 ? void 0 : _value$get.call(value, "func");
  if (!funcKey) {
    return [value];
  }
  var fieldDef = getFieldConfig$8(config2, field);
  if (fieldDef !== null && fieldDef !== void 0 && fieldDef.funcs && !fieldDef.funcs.includes(funcKey)) {
    allErrors.push({
      key: UNSUPPORTED_FUNCTION_FOR_FIELD,
      args: {
        funcKey,
        field
      }
    });
    return [value, allErrors];
  }
  var funcConfig = getFuncConfig$2(config2, funcKey);
  if (!funcConfig) {
    allErrors.push({
      key: NO_CONFIG_FOR_FUNCTION,
      args: {
        funcKey
      }
    });
    return [value, allErrors];
  }
  var funcName = (_funcConfig$label = funcConfig.label) !== null && _funcConfig$label !== void 0 ? _funcConfig$label : funcKey;
  if (valueType && funcConfig.returnType != valueType) {
    allErrors.push({
      key: INCORRECT_FUNCTION_RETURN_TYPE,
      args: {
        funcKey,
        funcName,
        returnType: funcConfig.returnType,
        valueType
      }
    });
    return [value, allErrors];
  }
  canFix = canFix || canDropArgs;
  for (var argKey in funcConfig.args) {
    var _argDef$label;
    var argConfig = funcConfig.args[argKey];
    var args = fixedValue.get("args");
    var argVal = args ? args.get(argKey) : void 0;
    var argDef = getFieldConfig$8(config2, argConfig);
    var argName = (_argDef$label = argDef === null || argDef === void 0 ? void 0 : argDef.label) !== null && _argDef$label !== void 0 ? _argDef$label : argKey;
    var argValue = argVal ? argVal.get("value") : void 0;
    var argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
    if (argValue !== void 0) {
      var _validateValue = validateValue(config2, leftField, argDef, operator, argValue, argConfig.type, argValueSrc, asyncListValues, canFix, isEndValue, canDropArgs), _validateValue2 = _slicedToArray$1(_validateValue, 2), fixedArgVal = _validateValue2[0], argErrors = _validateValue2[1];
      var isValid3 = !(argErrors !== null && argErrors !== void 0 && argErrors.length);
      var willFix = canFix && fixedArgVal !== argValue;
      var canDropOrReset = canFix && !isValid3 && !willFix && (isEndValue || canDropArgs);
      if (willFix) {
        fixedValue = fixedValue.setIn(["args", argKey, "value"], fixedArgVal);
      }
      if (canDropOrReset) {
        fixedValue = fixedValue.deleteIn(["args", argKey]);
        fixedValue = setFuncDefaultArg(config2, fixedValue, funcConfig, argKey);
      }
      if (!isValid3) {
        var _ref4, _argErrors$find;
        var firstError = (_ref4 = (_argErrors$find = argErrors.find(function(e2) {
          return !e2.fixed && !e2.ignore;
        })) !== null && _argErrors$find !== void 0 ? _argErrors$find : argErrors.find(function(e2) {
          return !e2.fixed;
        })) !== null && _ref4 !== void 0 ? _ref4 : argErrors[0];
        var fixed = willFix || canDropOrReset;
        var ignore = argErrors.filter(function(e2) {
          return !e2.ignore;
        }).length === 0;
        if (firstError) {
          var argValidationError = translateValidation(firstError);
          allErrors.push({
            key: INVALID_FUNC_ARG_VALUE,
            args: {
              funcKey,
              funcName,
              argKey,
              argName,
              argValidationError,
              // more meta
              argErrors
            },
            ignore,
            fixed,
            fixedFrom: fixed ? argValue : void 0,
            fixedTo: fixed ? willFix ? fixedArgVal : argConfig.defaultValue : void 0
          });
        }
      }
    } else if (!argConfig.isOptional && (isEndValue || canDropArgs)) {
      var canReset = canFix && argConfig.defaultValue !== void 0 && (isEndValue || canDropArgs);
      var canAddError = isEndValue;
      if (canAddError) {
        allErrors.push({
          key: REQUIRED_FUNCTION_ARG,
          args: {
            funcKey,
            funcName,
            argKey,
            argName
          },
          fixed: canReset,
          fixedTo: canReset ? argConfig.defaultValue : void 0,
          ignore: !canReset
          // tip: don't show error message in UI about missing arg after validation API call
        });
      }
      if (canReset) {
        fixedValue = fixedValue.deleteIn(["args", argKey]);
        fixedValue = setFuncDefaultArg(config2, fixedValue, funcConfig, argKey);
      }
    }
  }
  return [fixedValue, allErrors];
};
var validateRange = function validateRange2(config2, field, operator, values2, valueSrcs) {
  var operatorConfig = getOperatorConfig$4(config2, operator, field);
  var operatorCardinality = operator ? getOpCardinality$1(operatorConfig) : null;
  var valueSrcsArr = valueSrcs.toJS ? valueSrcs.toJS() : valueSrcs;
  var valuesArr = values2.toJS ? values2.toJS() : values2;
  var areValueSrcsPureValues = valueSrcsArr.filter(function(vs) {
    return vs == "value" || vs == null;
  }).length == operatorCardinality;
  var rangeError;
  if (operatorConfig !== null && operatorConfig !== void 0 && operatorConfig.validateValues && areValueSrcsPureValues) {
    var valueSrc = valueSrcsArr[0];
    var w = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
    var fieldWidgetDefinition = getFieldWidgetConfig$3(config2, field, operator, w, valueSrc);
    var jsValues = fieldWidgetDefinition !== null && fieldWidgetDefinition !== void 0 && fieldWidgetDefinition.toJS ? valuesArr.map(function(v) {
      var jsVal = fieldWidgetDefinition.toJS.call(config2.ctx, v, fieldWidgetDefinition);
      if (jsVal instanceof Date) {
        jsVal = jsVal.getTime();
      }
      return jsVal;
    }) : valuesArr;
    var validResult = operatorConfig.validateValues(jsValues);
    if (typeof validResult === "boolean") {
      if (validResult == false) {
        rangeError = {
          key: INVALID_RANGE,
          args: {
            jsValues,
            values: valuesArr
          }
        };
      }
    }
  }
  return rangeError;
};
var getNewValueForFieldOp = function getNewValueForFieldOp2(config2) {
  var _currentField, _currentField$get, _newField, _newField$get;
  var oldConfig = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var current = arguments.length > 2 ? arguments[2] : void 0;
  var newField = arguments.length > 3 ? arguments[3] : void 0;
  var newOperator = arguments.length > 4 ? arguments[4] : void 0;
  var changedProp = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
  var canFix = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
  var isEndValue = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
  var canDropArgs = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
  if (!oldConfig) oldConfig = config2;
  var _config$settings2 = config2.settings, keepInputOnChangeFieldSrc = _config$settings2.keepInputOnChangeFieldSrc, convertableWidgets = _config$settings2.convertableWidgets, clearValueOnChangeField = _config$settings2.clearValueOnChangeField, clearValueOnChangeOp = _config$settings2.clearValueOnChangeOp;
  var isCase = newField == "!case_value";
  var currentField = current.get("field");
  if (!currentField && isCase) {
    currentField = newField;
  }
  var currentFieldType = current.get("fieldType");
  var currentFieldSrc = current.get("fieldSrc");
  var currentOperator = current.get("operator");
  var currentValue = current.get("value");
  var currentValueSrc = current.get("valueSrc", new Immutable.List());
  var currentValueType = current.get("valueType", new Immutable.List());
  var currentValueError = current.get("valueError", new Immutable.List());
  var asyncListValues = current.get("asyncListValues");
  var isOkWithoutOperator = isCase;
  var currentOperatorConfig = getOperatorConfig$4(oldConfig, currentOperator);
  var newOperatorConfig = getOperatorConfig$4(config2, newOperator, newField);
  var currentOperatorCardinality = isCase ? 1 : currentOperator ? getOpCardinality$1(currentOperatorConfig) : null;
  var operatorCardinality = isCase ? 1 : newOperator ? getOpCardinality$1(newOperatorConfig) : null;
  var currentFieldConfig = getFieldConfig$8(oldConfig, currentField);
  var newFieldConfig = getFieldConfig$8(config2, newField);
  var isOkWithoutField = !currentField && currentFieldType && keepInputOnChangeFieldSrc;
  var currentType = (currentFieldConfig === null || currentFieldConfig === void 0 ? void 0 : currentFieldConfig.type) || currentFieldType;
  var newType = (newFieldConfig === null || newFieldConfig === void 0 ? void 0 : newFieldConfig.type) || !newField && isOkWithoutField && currentType;
  var currentListValuesType = currentFieldConfig === null || currentFieldConfig === void 0 ? void 0 : currentFieldConfig.listValuesType;
  var newListValuesType = newFieldConfig === null || newFieldConfig === void 0 ? void 0 : newFieldConfig.listValuesType;
  var currentFieldSimpleValue = ((_currentField = currentField) === null || _currentField === void 0 || (_currentField$get = _currentField.get) === null || _currentField$get === void 0 ? void 0 : _currentField$get.call(_currentField, "func")) || currentField;
  var newFieldSimpleValue = ((_newField = newField) === null || _newField === void 0 || (_newField$get = _newField.get) === null || _newField$get === void 0 ? void 0 : _newField$get.call(_newField, "func")) || newField;
  var hasFieldChanged = newFieldSimpleValue != currentFieldSimpleValue;
  var validationErrors = [];
  var canReuseValue = (currentField || isOkWithoutField) && (currentOperator && newOperator || isOkWithoutOperator) && currentValue != void 0;
  if (!(currentType && newType && currentType == newType) || changedProp === "field" && hasFieldChanged && clearValueOnChangeField || changedProp === "operator" && clearValueOnChangeOp) {
    canReuseValue = false;
  }
  if (hasFieldChanged && selectTypes.includes(newType)) {
    if (newListValuesType && newListValuesType === currentListValuesType) ;
    else {
      canReuseValue = false;
    }
  }
  if (!isOkWithoutOperator && (!(currentValue !== null && currentValue !== void 0 && currentValue.size) && operatorCardinality || currentValue !== null && currentValue !== void 0 && currentValue.size && !operatorCardinality)) {
    canReuseValue = false;
  }
  var newFieldError;
  if (currentFieldSrc === "func" && newField) {
    var _validateValue3 = validateValue(config2, null, null, newOperator, newField, newType, currentFieldSrc, asyncListValues, canFix, isEndValue, canDropArgs), _validateValue4 = _slicedToArray$1(_validateValue3, 2), fixedField = _validateValue4[0], fieldErrors = _validateValue4[1];
    var isValid3 = !(fieldErrors !== null && fieldErrors !== void 0 && fieldErrors.length);
    var willFix = fixedField !== newField;
    var willFixAllErrors = !isValid3 && willFix && !fieldErrors.find(function(e2) {
      return !e2.fixed;
    });
    var willRevert = canFix && !isValid3 && !willFixAllErrors && !!changedProp && newField !== currentField;
    var willDrop = false;
    if (willDrop) {
      newField = null;
    } else if (willRevert) {
      newField = currentField;
    } else if (willFix) {
      newField = fixedField;
    }
    if (!isValid3) {
      var showError = !isValid3 && !willFixAllErrors && !willDrop && !willRevert;
      var firstError = fieldErrors.find(function(e2) {
        return !e2.fixed && !e2.ignore;
      });
      if (showError && firstError) {
        newFieldError = translateValidation(firstError);
      }
      fieldErrors.map(function(e2) {
        return validationErrors.push(_objectSpread$w(_objectSpread$w({
          side: "lhs"
        }, e2), {}, {
          fixed: e2.fixed || willRevert || willDrop
        }));
      });
    }
  }
  for (var i2 = 0; i2 < operatorCardinality; i2++) {
    var vs = currentValueSrc.get(i2) || null;
    var currentWidget = getWidgetForFieldOp$3(oldConfig, currentField, currentOperator, vs);
    var newWidget = getWidgetForFieldOp$3(config2, newField, newOperator, vs);
    var currentValueWidget = vs === "value" ? currentWidget : getWidgetForFieldOp$3(oldConfig, currentField, currentOperator, "value");
    var newValueWidget = vs === "value" ? newWidget : getWidgetForFieldOp$3(config2, newField, newOperator, "value");
    var canReuseWidget = newValueWidget == currentValueWidget || (convertableWidgets[currentValueWidget] || []).includes(newValueWidget) || !currentValueWidget && isOkWithoutField;
    if (!canReuseWidget) {
      canReuseValue = false;
    }
  }
  if (currentOperator != newOperator && [currentOperator, newOperator].includes("proximity")) {
    canReuseValue = false;
  }
  var firstValueSrc = currentValueSrc.first();
  var firstWidgetConfig = getFieldWidgetConfig$3(config2, newField, newOperator, null, firstValueSrc);
  var valueSources = getValueSourcesForFieldOp$1(config2, newField, newOperator, null);
  if (!newField && isOkWithoutField) {
    valueSources = Object.keys(config2.settings.valueSourcesInfo);
  }
  var defaultValueSrc = valueSources[0];
  var defaultValueType;
  if (operatorCardinality === 1 && firstWidgetConfig && firstWidgetConfig.type !== void 0) {
    defaultValueType = firstWidgetConfig.type;
  } else if (operatorCardinality === 1 && newFieldConfig && newFieldConfig.type !== void 0) {
    defaultValueType = newFieldConfig.type === "!group" ? "number" : newFieldConfig.type;
  }
  var canExtendValueToRange = canReuseValue && changedProp === "operator" && currentOperatorCardinality === 1 && operatorCardinality === 2;
  var valueFixes = [];
  var valueSrcFixes = [];
  var valueTypeFixes = [];
  var valueErrors = Array.from({
    length: operatorCardinality
  }, function() {
    return null;
  });
  if (canReuseValue) {
    var _loop = function _loop4(_i32) {
      var v = currentValue.get(_i32);
      var vType = currentValueType.get(_i32) || null;
      var vSrc = currentValueSrc.get(_i32) || null;
      if (canExtendValueToRange && _i32 === 1) {
        v = valueFixes[0] !== void 0 ? valueFixes[0] : currentValue.get(0);
        valueFixes[_i32] = v;
        vType = currentValueType.get(0) || null;
        vSrc = currentValueSrc.get(0) || null;
      }
      var isValidSrc2 = vSrc ? valueSources.find(function(v2) {
        return v2 == vSrc;
      }) !== void 0 : true;
      var _validateValue5 = validateValue(config2, newField, newField, newOperator, v, vType, vSrc, asyncListValues, canFix, isEndValue, canDropArgs), _validateValue6 = _slicedToArray$1(_validateValue5, 2), fixedValue = _validateValue6[0], allErrors = _validateValue6[1];
      var isValid4 = !(allErrors !== null && allErrors !== void 0 && allErrors.length);
      var willFix2 = fixedValue !== v;
      var willFixAllErrors2 = !isValid4 && willFix2 && !(allErrors !== null && allErrors !== void 0 && allErrors.find(function(e2) {
        return !e2.fixed;
      }));
      var allErrorsHandled = !(allErrors !== null && allErrors !== void 0 && allErrors.find(function(e2) {
        return !e2.fixed && !e2.ignore;
      }));
      var willDrop2 = !isValidSrc2 || canFix && !isValid4 && !willFixAllErrors2 && (!allErrorsHandled || hasFieldChanged);
      if (!isValid4) {
        allErrors === null || allErrors === void 0 || allErrors.map(function(e2) {
          return validationErrors.push(_objectSpread$w(_objectSpread$w({
            side: "rhs",
            delta: _i32
          }, e2), {}, {
            fixed: e2.fixed || willDrop2
          }));
        });
      }
      if (willDrop2) {
        valueFixes[_i32] = null;
        if (_i32 === 0) {
          delete valueFixes[1];
        }
      }
      var showError2 = !isValid4 && !willFix2;
      var firstError2 = allErrors === null || allErrors === void 0 ? void 0 : allErrors.find(function(e2) {
        return !e2.fixed && !e2.ignore;
      });
      if (showError2 && firstError2) {
        valueErrors[_i32] = translateValidation(firstError2);
      }
      if (willFix2) {
        valueFixes[_i32] = fixedValue;
      }
      if (canExtendValueToRange && _i32 === 0 && !isValid4 && !willFix2) {
        canExtendValueToRange = false;
      }
      if (canExtendValueToRange && _i32 === 0 && ["func", "field"].includes(vSrc)) {
        canExtendValueToRange = false;
      }
    };
    for (var _i3 = 0; _i3 < operatorCardinality; _i3++) {
      _loop(_i3);
    }
  }
  if (!canReuseValue) {
    for (var _i4 = 0; _i4 < operatorCardinality; _i4++) {
      if (operatorCardinality === 1) {
        var _newFieldConfig$field;
        var dv = getFirstDefined([newFieldConfig === null || newFieldConfig === void 0 ? void 0 : newFieldConfig.defaultValue, newFieldConfig === null || newFieldConfig === void 0 || (_newFieldConfig$field = newFieldConfig.fieldSettings) === null || _newFieldConfig$field === void 0 ? void 0 : _newFieldConfig$field.defaultValue, firstWidgetConfig === null || firstWidgetConfig === void 0 ? void 0 : firstWidgetConfig.defaultValue]);
        valueFixes[_i4] = dv;
        if (dv !== null && dv !== void 0 && dv.func) {
          valueSrcFixes[_i4] = "func";
        }
      }
    }
  }
  for (var _i5 = 0; _i5 < operatorCardinality; _i5++) {
    var _vs = canReuseValue && currentValueSrc.get(_i5) || null;
    var vt = canReuseValue && currentValueType.get(_i5) || null;
    if (canReuseValue && canExtendValueToRange && _i5 === 1) {
      var _valueSrcFixes$_i, _valueTypeFixes$_i;
      _vs = (_valueSrcFixes$_i = valueSrcFixes[_i5]) !== null && _valueSrcFixes$_i !== void 0 ? _valueSrcFixes$_i : currentValueSrc.get(0);
      vt = (_valueTypeFixes$_i = valueTypeFixes[_i5]) !== null && _valueTypeFixes$_i !== void 0 ? _valueTypeFixes$_i : currentValueType.get(0);
      valueSrcFixes[_i5] = _vs;
      valueTypeFixes[_i5] = vt;
    }
    var isValidSrc = valueSources.includes(_vs);
    if (!isValidSrc) {
      valueSrcFixes[_i5] = defaultValueSrc;
    }
    if (!vt) {
      valueTypeFixes[_i5] = defaultValueType;
    }
  }
  var newValue = currentValue;
  if (valueFixes.length > 0 || !canReuseValue) {
    newValue = new Immutable.List(Array.from({
      length: operatorCardinality
    }, function(_ignore, i3) {
      return valueFixes[i3] !== void 0 ? valueFixes[i3] : canReuseValue ? currentValue.get(i3) : void 0;
    }));
  }
  var newValueSrc = currentValueSrc;
  if (valueSrcFixes.length > 0 || !canReuseValue) {
    newValueSrc = new Immutable.List(Array.from({
      length: operatorCardinality
    }, function(_ignore, i3) {
      var _valueSrcFixes$i;
      return (_valueSrcFixes$i = valueSrcFixes[i3]) !== null && _valueSrcFixes$i !== void 0 ? _valueSrcFixes$i : canReuseValue && currentValueSrc.get(i3) || null;
    }));
  }
  var newValueType = currentValueType;
  if (valueTypeFixes.length > 0 || !canReuseValue) {
    newValueType = new Immutable.List(Array.from({
      length: operatorCardinality
    }, function(_ignore, i3) {
      var _valueTypeFixes$i;
      return (_valueTypeFixes$i = valueTypeFixes[i3]) !== null && _valueTypeFixes$i !== void 0 ? _valueTypeFixes$i : canReuseValue && currentValueType.get(i3) || null;
    }));
  }
  var rangeErrorObj = validateRange(config2, newField, newOperator, newValue, newValueSrc);
  if (rangeErrorObj) {
    var rangeValidationError = translateValidation(rangeErrorObj);
    var _willFix = canFix && operatorCardinality >= 2;
    var badValue = newValue;
    if (_willFix) {
      valueFixes[1] = newValue.get(0);
      newValue = newValue.set(1, valueFixes[1]);
      valueErrors[1] = valueErrors[0];
    }
    var _showError = !_willFix;
    if (_showError) {
      valueErrors.push(rangeValidationError);
    }
    validationErrors.push(_objectSpread$w(_objectSpread$w({
      side: "rhs",
      delta: -1
    }, rangeErrorObj), {}, {
      fixed: _willFix,
      fixedFrom: _willFix ? [badValue.get(0), badValue.get(1)] : void 0,
      fixedTo: _willFix ? [newValue.get(0), newValue.get(1)] : void 0
    }));
  }
  var newValueError = currentValueError;
  var hasValueErrorChanged = (currentValueError === null || currentValueError === void 0 ? void 0 : currentValueError.size) !== valueErrors.length || valueErrors.filter(function(v, i3) {
    return v != currentValueError.get(i3);
  }).length > 0;
  if (hasValueErrorChanged) {
    newValueError = new Immutable.List(valueErrors);
  }
  return {
    canReuseValue,
    newValue,
    newValueSrc,
    newValueType,
    operatorCardinality,
    fixedField: newField,
    newValueError,
    newFieldError,
    validationErrors
  };
};
const validation = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _validateTree,
  checkTree,
  getNewValueForFieldOp,
  getTreeBadFields,
  isValidTree,
  sanitizeTree,
  translateValidation,
  validateAndFixTree: validateAndFixTree$1,
  validateRange,
  validateTree,
  validateValue
}, Symbol.toStringTag, { value: "Module" }));
var isObject$9 = function isObject4(v) {
  return _typeof$3(v) == "object" && v !== null && !Array.isArray(v);
};
var completeFuncValue = function completeFuncValue2(value, config2) {
  if (!value) return void 0;
  var funcKey = value.get("func");
  var funcConfig = funcKey && getFuncConfig$2(config2, funcKey);
  if (!funcConfig) return void 0;
  var complValue = value;
  var tmpHasOptional = false;
  for (var argKey in funcConfig.args) {
    var argConfig = funcConfig.args[argKey];
    var valueSources = argConfig.valueSources, isOptional = argConfig.isOptional, defaultValue = argConfig.defaultValue;
    var filteredValueSources = filterValueSourcesForField(config2, valueSources, argConfig);
    var args = complValue.get("args");
    var argDefaultValueSrc = filteredValueSources.length == 1 ? filteredValueSources[0] : void 0;
    var argVal = args ? args.get(argKey) : void 0;
    var argValue = argVal ? argVal.get("value") : void 0;
    var argValueSrc = (argVal ? argVal.get("valueSrc") : void 0) || argDefaultValueSrc;
    if (argValue !== void 0) {
      var completeArgValue = completeValue(argValue, argValueSrc, config2);
      if (completeArgValue === void 0) {
        return void 0;
      } else if (completeArgValue !== argValue) {
        complValue = complValue.setIn(["args", argKey, "value"], completeArgValue);
      }
      if (tmpHasOptional) {
        return void 0;
      }
    } else if (defaultValue !== void 0 && !isObject$9(defaultValue)) {
      complValue = complValue.setIn(["args", argKey, "value"], getDefaultArgValue(argConfig));
      complValue = complValue.setIn(["args", argKey, "valueSrc"], "value");
    } else if (isOptional) {
      tmpHasOptional = true;
    } else {
      return void 0;
    }
  }
  return complValue;
};
var setFunc = function setFunc2(value, funcKey, config2, canFixArgs) {
  var fieldSeparator = config2.settings.fieldSeparator;
  value = value || new Immutable.Map();
  if (Array.isArray(funcKey)) {
    funcKey = funcKey.join(fieldSeparator);
  }
  var oldFuncKey = value.get("func");
  var oldArgs = value.get("args");
  value = value.set("func", funcKey);
  var funcConfig = funcKey && getFuncConfig$2(config2, funcKey);
  var newFuncSignature = funcKey && getFuncSignature(config2, funcKey);
  var oldFuncSignature = oldFuncKey && getFuncSignature(config2, oldFuncKey);
  var keepArgsKeys = getCompatibleArgsOnFuncChange(oldFuncSignature, newFuncSignature, oldArgs, config2, canFixArgs);
  if (keepArgsKeys.length) {
    var argsKeys = Object.keys(newFuncSignature.args);
    var deleteArgsKeys = argsKeys.filter(function(k) {
      return !keepArgsKeys.includes(k);
    });
    value = deleteArgsKeys.reduce(function(value2, k) {
      return value2.deleteIn(["args", k]);
    }, value);
  } else {
    value = value.set("args", new Immutable.Map());
  }
  value = setFuncDefaultArgs(config2, value, funcConfig);
  return value;
};
var setFuncDefaultArgs = function setFuncDefaultArgs2(config2, funcValue, funcConfig) {
  if (funcConfig) {
    for (var argKey in funcConfig.args) {
      funcValue = setFuncDefaultArg(config2, funcValue, funcConfig, argKey);
    }
  }
  return funcValue;
};
var setFuncDefaultArg = function setFuncDefaultArg2(config2, funcValue, funcConfig, argKey) {
  var argConfig = funcConfig.args[argKey];
  var valueSources = argConfig.valueSources, defaultValue = argConfig.defaultValue;
  var filteredValueSources = filterValueSourcesForField(config2, valueSources, argConfig);
  var firstValueSrc = filteredValueSources.length ? filteredValueSources[0] : void 0;
  var defaultValueSrc = defaultValue ? isObject$9(defaultValue) && !!defaultValue.func ? "func" : "value" : void 0;
  var argDefaultValueSrc = defaultValueSrc || firstValueSrc;
  var hasValue = funcValue.getIn(["args", argKey]);
  if (!hasValue) {
    if (defaultValue !== void 0) {
      funcValue = funcValue.setIn(["args", argKey, "value"], getDefaultArgValue(argConfig));
    }
    if (argDefaultValueSrc) {
      funcValue = funcValue.setIn(["args", argKey, "valueSrc"], argDefaultValueSrc);
    }
  }
  return funcValue;
};
var getDefaultArgValue = function getDefaultArgValue2(_ref) {
  var value = _ref.defaultValue;
  if (isObject$9(value) && !Immutable.Map.isMap(value) && value.func) {
    return Immutable.fromJS(value, function(k, v) {
      return Immutable.Iterable.isIndexed(v) ? v.toList() : v.toOrderedMap();
    });
  }
  return value;
};
var setArgValue = function setArgValue2(value, argKey, argVal, argConfig, config2) {
  if (value && value.get("func")) {
    value = value.setIn(["args", argKey, "value"], argVal);
    var valueSrc = value.getIn(["args", argKey, "valueSrc"]);
    var valueSources = argConfig.valueSources;
    var filteredValueSources = filterValueSourcesForField(config2, valueSources, argConfig);
    var argDefaultValueSrc = filteredValueSources.length == 1 ? filteredValueSources[0] : void 0;
    if (!argDefaultValueSrc && filteredValueSources.includes("value")) {
      argDefaultValueSrc = "value";
    }
    if (!valueSrc && argDefaultValueSrc) {
      value = value.setIn(["args", argKey, "valueSrc"], argDefaultValueSrc);
    }
  }
  return value;
};
var setArgValueSrc = function setArgValueSrc2(value, argKey, argValSrc, _argConfig, _config) {
  if (value && value.get("func")) {
    value = value.setIn(["args", argKey], new Immutable.Map({
      valueSrc: argValSrc
    }));
  }
  return value;
};
var getCompatibleArgsOnFuncChange = function getCompatibleArgsOnFuncChange2(s1, s2, argVals, config2) {
  var canFixArgs = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  if ((s1 === null || s1 === void 0 ? void 0 : s1.returnType) != (s2 === null || s2 === void 0 ? void 0 : s2.returnType)) return [];
  var keys4 = Object.keys(s2.args);
  var compatibleKeys = keys4.filter(function(k, i2) {
    var arg2 = s2.args[k];
    var arg1 = s1.args[k];
    Object.keys(s1.args).indexOf(k);
    if (!arg1 && (arg2.defaultValue !== void 0 || arg2.isOptional)) {
      return true;
    }
    if ((arg1 === null || arg1 === void 0 ? void 0 : arg1.type) != arg2.type) return false;
    if (selectTypes.includes(arg2.type)) {
      if (!arg1.listValuesType || arg1.listValuesType !== arg2.listValuesType) return false;
    }
    if (argVals) {
      var _argValidErrors$filte;
      var argVal = argVals.get(k);
      var argValue = argVal === null || argVal === void 0 ? void 0 : argVal.get("value");
      var argValueSrc = argVal === null || argVal === void 0 ? void 0 : argVal.get("valueSrc");
      if (argValueSrc && arg2.valueSources && !arg2.valueSources.includes(argValueSrc)) return false;
      var leftField = null, operator = null, argDef = arg2, asyncListValues = null, isEndValue = true;
      var _validateValue = validateValue(config2, leftField, argDef, operator, argValue, argDef.type, argValueSrc, asyncListValues, canFixArgs, isEndValue), _validateValue2 = _slicedToArray$1(_validateValue, 2);
      _validateValue2[0];
      var argValidErrors = _validateValue2[1];
      if (argValidErrors !== null && argValidErrors !== void 0 && (_argValidErrors$filte = argValidErrors.filter(function(e2) {
        return !e2.fixed;
      })) !== null && _argValidErrors$filte !== void 0 && _argValidErrors$filte.length) return false;
    }
    return true;
  });
  return compatibleKeys;
};
const funcUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  completeFuncValue,
  getCompatibleArgsOnFuncChange,
  setArgValue,
  setArgValueSrc,
  setFunc,
  setFuncDefaultArg
}, Symbol.toStringTag, { value: "Module" }));
var selectTypes = ["select", "multiselect", "treeselect", "treemultiselect"];
var getOperatorsForType = function getOperatorsForType2(config2, fieldType) {
  var _config$types$fieldTy;
  return ((_config$types$fieldTy = config2.types[fieldType]) === null || _config$types$fieldTy === void 0 ? void 0 : _config$types$fieldTy.operators) || null;
};
var getOperatorsForField = function getOperatorsForField2(config2, field) {
  var fieldConfig = getFieldConfig$8(config2, field);
  var fieldOps = fieldConfig ? fieldConfig.operators : [];
  return fieldOps;
};
var getFirstOperator = function getFirstOperator2(config2, field) {
  var _fieldOps$;
  var fieldOps = getOperatorsForField(config2, field);
  return (_fieldOps$ = fieldOps === null || fieldOps === void 0 ? void 0 : fieldOps[0]) !== null && _fieldOps$ !== void 0 ? _fieldOps$ : null;
};
var calculateValueType = function calculateValueType2(value, valueSrc, config2) {
  var calculatedValueType = null;
  if (value) {
    if (valueSrc === "field") {
      var fieldConfig = getFieldConfig$8(config2, value);
      if (fieldConfig) {
        calculatedValueType = fieldConfig.type;
      }
    } else if (valueSrc === "func") {
      var funcKey = value.get("func");
      if (funcKey) {
        var funcConfig = getFuncConfig$2(config2, funcKey);
        if (funcConfig) {
          calculatedValueType = funcConfig.returnType || funcConfig.type;
        }
      }
    }
  }
  return calculatedValueType;
};
var getFuncPathLabels$1 = function getFuncPathLabels(field, config2) {
  var parentField = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  return getFieldPathLabels$2(field, config2, parentField, "funcs", "subfields");
};
var getFieldPathLabels$2 = function getFieldPathLabels(field, config2) {
  var parentField = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var fieldsKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "fields";
  var subfieldsKey = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "subfields";
  if (!field) return null;
  var fieldSeparator = config2.settings.fieldSeparator;
  var parts = getFieldParts$3(field, config2);
  var parentParts = getFieldParts$3(parentField, config2);
  var res = parts.slice(parentParts.length).map(function(_curr, ind, arr) {
    return arr.slice(0, ind + 1);
  }).map(function(parts2) {
    return [].concat(_toConsumableArray(parentParts), _toConsumableArray(parts2)).join(fieldSeparator);
  }).map(function(part) {
    var cnf = getFieldRawConfig(config2, part, fieldsKey, subfieldsKey);
    return cnf && cnf.label || last$2(part.split(fieldSeparator));
  }).filter(function(label2) {
    return label2 != null;
  });
  return res;
};
var getFieldPartsConfigs = function getFieldPartsConfigs2(field, config2) {
  var parentField = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  if (!field) return null;
  var parentFieldDef = parentField && getFieldRawConfig(config2, parentField) || null;
  var fieldSeparator = config2.settings.fieldSeparator;
  var parts = getFieldParts$3(field, config2);
  var isDescendant = isFieldDescendantOfField(field, parentField, config2);
  var parentParts = !isDescendant ? [] : getFieldParts$3(parentField, config2);
  return parts.slice(parentParts.length).map(function(_curr, ind, arr) {
    return arr.slice(0, ind + 1);
  }).map(function(parts2) {
    return {
      part: [].concat(_toConsumableArray(parentParts), _toConsumableArray(parts2)).join(fieldSeparator),
      key: parts2[parts2.length - 1]
    };
  }).map(function(_ref) {
    var part = _ref.part, key = _ref.key;
    var cnf = getFieldRawConfig(config2, part);
    return {
      key,
      cnf
    };
  }).map(function(_ref2, ind, arr) {
    var key = _ref2.key, cnf = _ref2.cnf;
    var parentCnf = ind > 0 ? arr[ind - 1].cnf : parentFieldDef;
    return [key, cnf, parentCnf];
  });
};
var getValueLabel$1 = function getValueLabel(config2, field, operator, delta2) {
  var valueSrc = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var isSpecialRange = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
  var fieldWidgetConfig = getFieldWidgetConfig$3(config2, field, operator, null, valueSrc) || {};
  var mergedOpConfig = getOperatorConfig$4(config2, operator, field) || {};
  var cardinality = isSpecialRange ? 1 : mergedOpConfig.cardinality;
  var ret = null;
  if (cardinality > 1) {
    var valueLabels = fieldWidgetConfig.valueLabels || mergedOpConfig.valueLabels;
    if (valueLabels) ret = valueLabels[delta2];
    if (ret && _typeof$3(ret) !== "object") {
      ret = {
        label: ret,
        placeholder: ret
      };
    }
    if (!ret) {
      ret = {
        label: config2.settings.valueLabel + " " + (delta2 + 1),
        placeholder: config2.settings.valuePlaceholder + " " + (delta2 + 1)
      };
    }
  } else {
    var label2 = fieldWidgetConfig.valueLabel;
    var placeholder2 = fieldWidgetConfig.valuePlaceholder;
    ret = {
      label: label2 || config2.settings.valueLabel,
      placeholder: placeholder2 || config2.settings.valuePlaceholder
    };
  }
  return ret;
};
function _getWidgetsAndSrcsForFieldOp(config2, field) {
  var operator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var valueSrc = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var widgets2 = [];
  var valueSrcs = [];
  if (!field) return {
    widgets: widgets2,
    valueSrcs
  };
  var fieldCacheKey = getFieldId$1(field);
  var cacheKey = fieldCacheKey ? "".concat(fieldCacheKey, "__").concat(operator, "__").concat(valueSrc) : null;
  var cached = _getFromConfigCache(config2, "_getWidgetsAndSrcsForFieldOp", cacheKey);
  if (cached) return cached;
  var isFuncArg = _typeof$3(field) === "object" && (!!field.func && !!field.arg || field._isFuncArg);
  var fieldConfig = getFieldConfig$8(config2, field);
  var opConfig = operator ? config2.operators[operator] : null;
  if (fieldConfig !== null && fieldConfig !== void 0 && fieldConfig.widgets) {
    var _loop = function _loop4() {
      var widgetConfig = fieldConfig.widgets[widget];
      if (!config2.widgets[widget]) {
        return 1;
      }
      var widgetValueSrc = config2.widgets[widget].valueSrc || "value";
      var canAdd = true;
      if (widget === "field") {
        canAdd = canAdd && filterValueSourcesForField(config2, ["field"], fieldConfig).length > 0;
      }
      if (widget === "func") {
        canAdd = canAdd && filterValueSourcesForField(config2, ["func"], fieldConfig).length > 0;
      }
      if (valueSrc === "value" && !widgetConfig.operators && !isFuncArg && field !== "!case_value") canAdd = false;
      if (widgetConfig.operators && operator) canAdd = canAdd && widgetConfig.operators.indexOf(operator) != -1;
      if (valueSrc && valueSrc != widgetValueSrc && valueSrc !== "const") canAdd = false;
      if (opConfig && opConfig.cardinality == 0 && widgetValueSrc !== "value") canAdd = false;
      if (canAdd) {
        var _fieldConfig$valueSou, _opConfig$valueSource;
        widgets2.push(widget);
        var canAddValueSrc = ((_fieldConfig$valueSou = fieldConfig.valueSources) === null || _fieldConfig$valueSou === void 0 ? void 0 : _fieldConfig$valueSou.indexOf(widgetValueSrc)) != -1;
        if ((opConfig === null || opConfig === void 0 || (_opConfig$valueSource = opConfig.valueSources) === null || _opConfig$valueSource === void 0 ? void 0 : _opConfig$valueSource.indexOf(widgetValueSrc)) == -1) canAddValueSrc = false;
        if (canAddValueSrc && !valueSrcs.find(function(v) {
          return v == widgetValueSrc;
        })) valueSrcs.push(widgetValueSrc);
      }
    };
    for (var widget in fieldConfig.widgets) {
      if (_loop()) continue;
    }
  }
  var widgetWeight = function widgetWeight2(w) {
    var wg = 0;
    if (fieldConfig.preferWidgets) {
      if (fieldConfig.preferWidgets.includes(w)) wg += 10 - fieldConfig.preferWidgets.indexOf(w);
    } else if (w == fieldConfig.mainWidget) {
      wg += 100;
    }
    if (w === "field") {
      wg -= 1;
    }
    if (w === "func") {
      wg -= 2;
    }
    return wg;
  };
  widgets2.sort(function(w1, w2) {
    return widgetWeight(w2) - widgetWeight(w1);
  });
  var res = {
    widgets: widgets2,
    valueSrcs
  };
  _saveToConfigCache(config2, "_getWidgetsAndSrcsForFieldOp", cacheKey, res);
  return res;
}
var getWidgetsForFieldOp = function getWidgetsForFieldOp2(config2, field, operator) {
  var valueSrc = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var _getWidgetsAndSrcsFor = _getWidgetsAndSrcsForFieldOp(config2, field, operator, valueSrc), widgets2 = _getWidgetsAndSrcsFor.widgets;
  return widgets2;
};
var filterValueSourcesForField = function filterValueSourcesForField2(config2, valueSrcs, fieldDefinition) {
  var _fieldDefinition$type;
  if (!fieldDefinition) return valueSrcs;
  var fieldType = (_fieldDefinition$type = fieldDefinition.type) !== null && _fieldDefinition$type !== void 0 ? _fieldDefinition$type : fieldDefinition.returnType;
  if (fieldType === "!group") {
    fieldType = "number";
  }
  if (!valueSrcs) valueSrcs = Object.keys(config2.settings.valueSourcesInfo);
  return valueSrcs.filter(function(vs) {
    var canAdd = true;
    if (vs === "field") {
      if (config2.__fieldsCntByType) {
        var minCnt = fieldDefinition._isFuncArg ? 0 : 1;
        canAdd = canAdd && config2.__fieldsCntByType[fieldType] > minCnt;
      }
    }
    if (vs === "func") {
      if (fieldDefinition.funcs) {
        canAdd = canAdd && fieldDefinition.funcs.length > 0;
      }
      if (config2.__funcsCntByType) {
        canAdd = canAdd && config2.__funcsCntByType[fieldType] > 0;
      }
    }
    return canAdd;
  });
};
var getValueSourcesForFieldOp$1 = function getValueSourcesForFieldOp(config2, field, operator) {
  var fieldDefinition = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var _getWidgetsAndSrcsFor2 = _getWidgetsAndSrcsForFieldOp(config2, field, operator, null), valueSrcs = _getWidgetsAndSrcsFor2.valueSrcs;
  var filteredValueSrcs = filterValueSourcesForField(config2, valueSrcs, fieldDefinition);
  return filteredValueSrcs;
};
var getWidgetForFieldOp$3 = function getWidgetForFieldOp(config2, field, operator) {
  var valueSrc = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var _getWidgetsAndSrcsFor3 = _getWidgetsAndSrcsForFieldOp(config2, field, operator, valueSrc), widgets2 = _getWidgetsAndSrcsFor3.widgets;
  var widget = null;
  if (widgets2.length) widget = widgets2[0];
  return widget;
};
var formatFieldName = function formatFieldName2(field, config2, meta) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  if (!field) return;
  var fieldDef = getFieldConfig$8(config2, field) || {};
  var fieldSeparator = config2.settings.fieldSeparator;
  var fieldParts = getFieldParts$3(field, config2);
  var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field;
  if (options !== null && options !== void 0 && options.useTableName && fieldDef.tableName) {
    var fieldPartsCopy = _toConsumableArray(fieldParts);
    fieldPartsCopy[0] = fieldDef.tableName;
    fieldName = fieldPartsCopy.join(fieldSeparator);
  }
  if (fieldDef.fieldName) {
    fieldName = fieldDef.fieldName;
  }
  if (parentField) {
    getFieldConfig$8(config2, parentField) || {};
    var parentFieldName = parentField;
    if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {
      fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);
    } else {
      if (fieldDef.fieldName) ;
      else {
        meta.errors.push("Can't cut group ".concat(parentFieldName, " from field ").concat(fieldName));
      }
    }
  }
  return fieldName;
};
var isEmptyItem = function isEmptyItem2(item, config2) {
  var type2 = item.get("type");
  var mode = item.getIn(["properties", "mode"]);
  if (type2 == "rule_group" && mode == "array") {
    return isEmptyRuleGroupExt(item, config2);
  } else if (type2 == "group" || type2 == "rule_group") {
    return isEmptyGroup(item, config2);
  } else {
    return isEmptyRule(item, config2);
  }
};
var isEmptyRuleGroupExt = function isEmptyRuleGroupExt2(item, config2) {
  var children = item.get("children1");
  var properties = item.get("properties");
  return isEmptyRuleGroupExtPropertiesAndChildren$1(properties.toObject(), children, config2);
};
var isEmptyRuleGroupExtPropertiesAndChildren$1 = function isEmptyRuleGroupExtPropertiesAndChildren(properties, children, config2) {
  var _config$operators$ope, _config$operators$ope2;
  var operator = properties.operator;
  var cardinality = (_config$operators$ope = (_config$operators$ope2 = config2.operators[operator]) === null || _config$operators$ope2 === void 0 ? void 0 : _config$operators$ope2.cardinality) !== null && _config$operators$ope !== void 0 ? _config$operators$ope : 1;
  var childrenAreRequired = cardinality == 0;
  var filledParts = {
    group: !isEmptyRuleProperties$1(properties, config2),
    children: !isEmptyGroupChildren$1(children, config2)
  };
  var hasEnough = filledParts.group && (childrenAreRequired ? filledParts.children : true);
  return !hasEnough;
};
var isEmptyGroup = function isEmptyGroup2(group3, config2) {
  var children = group3.get("children1");
  return isEmptyGroupChildren$1(children, config2);
};
var isEmptyGroupChildren$1 = function isEmptyGroupChildren(children, config2) {
  var hasEnough = (children === null || children === void 0 ? void 0 : children.size) > 0 && children.filter(function(ch) {
    return !isEmptyItem(ch, config2);
  }).size > 0;
  return !hasEnough;
};
var isEmptyRule = function isEmptyRule2(rule3, config2) {
  var properties = rule3.get("properties");
  return isEmptyRuleProperties$1((properties === null || properties === void 0 ? void 0 : properties.toObject()) || {}, config2);
};
var isEmptyRuleProperties$1 = function isEmptyRuleProperties(properties, config2) {
  var liteCheck = true;
  var scoreThreshold = 3;
  var compl = whatRulePropertiesAreCompleted(properties, config2, liteCheck);
  var hasEnough = compl.score >= scoreThreshold;
  return !hasEnough;
};
var whatRulePropertiesAreCompleted = function whatRulePropertiesAreCompleted2(_ref3, config2) {
  var _config$operators$ope3, _config$operators$ope4, _value$filter;
  var field = _ref3.field, fieldSrc = _ref3.fieldSrc;
  _ref3.fieldType;
  var operator = _ref3.operator, value = _ref3.value, valueSrc = _ref3.valueSrc;
  _ref3.valueType;
  var liteCheck = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var cardinality = (_config$operators$ope3 = (_config$operators$ope4 = config2.operators[operator]) === null || _config$operators$ope4 === void 0 ? void 0 : _config$operators$ope4.cardinality) !== null && _config$operators$ope3 !== void 0 ? _config$operators$ope3 : 1;
  var valueSrcs = valueSrc !== null && valueSrc !== void 0 && valueSrc.get ? valueSrc.toJS() : valueSrc;
  var res = {
    parts: {},
    score: 0
  };
  res.parts.field = liteCheck ? field != null : isCompletedValue(field, fieldSrc, config2);
  res.parts.operator = !!operator;
  res.parts.value = (value === null || value === void 0 || (_value$filter = value.filter(function(val, delta2) {
    return isCompletedValue(val, valueSrcs === null || valueSrcs === void 0 ? void 0 : valueSrcs[delta2], config2, liteCheck);
  })) === null || _value$filter === void 0 ? void 0 : _value$filter.size) >= (liteCheck ? Math.min(cardinality, 1) : cardinality);
  res.score = Object.keys(res.parts).filter(function(k) {
    return !!res.parts[k];
  }).length;
  if (liteCheck && res.score < 3) {
    var deepCheck = true;
    if (!res.parts.value && fieldSrc === "func" && isCompletedValue(field, fieldSrc, config2, false, deepCheck)) {
      res.score++;
    }
    if (!res.parts.field) {
      value === null || value === void 0 || value.map(function(val, delta2) {
        if ((valueSrcs === null || valueSrcs === void 0 ? void 0 : valueSrcs[delta2]) === "func" && isCompletedValue(val, valueSrcs === null || valueSrcs === void 0 ? void 0 : valueSrcs[delta2], config2, false, deepCheck)) {
          res.score++;
        }
      });
    }
  }
  return res;
};
var isCompletedValue = function isCompletedValue2(value, valueSrc, config2) {
  var liteCheck = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var deepCheck = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  if (!liteCheck && valueSrc == "func" && value) {
    var _value$get;
    var funcKey = (_value$get = value.get) === null || _value$get === void 0 ? void 0 : _value$get.call(value, "func");
    var funcConfig = getFuncConfig$2(config2, funcKey);
    if (funcConfig) {
      var args = value.get("args");
      for (var argKey in funcConfig.args) {
        var argConfig = funcConfig.args[argKey];
        var argVal = args ? args.get(argKey) : void 0;
        var argValue = argVal ? argVal.get("value") : void 0;
        var argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
        if (argValue == void 0 && (argConfig === null || argConfig === void 0 ? void 0 : argConfig.defaultValue) === void 0 && !(argConfig !== null && argConfig !== void 0 && argConfig.isOptional)) {
          return false;
        }
        if (argValue != void 0) {
          if (!isCompletedValue2(argValue, argValueSrc, config2, deepCheck ? liteCheck : true)) {
            return false;
          }
        }
      }
      return true;
    }
  }
  return value != void 0;
};
var completeValue = function completeValue2(value, valueSrc, config2) {
  if (valueSrc == "func") return completeFuncValue(value, config2);
  else return value;
};
var getOneChildOrDescendant = function getOneChildOrDescendant2(item) {
  var children = item.get("children1");
  if ((children === null || children === void 0 ? void 0 : children.size) == 1) {
    var child = children.first();
    var childType = child.get("type");
    if (childType === "group") {
      return getOneChildOrDescendant2(child);
    }
    return child;
  }
  return null;
};
const ruleUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  calculateValueType,
  completeValue,
  filterValueSourcesForField,
  formatFieldName,
  getFieldPartsConfigs,
  getFieldPathLabels: getFieldPathLabels$2,
  getFirstOperator,
  getFuncPathLabels: getFuncPathLabels$1,
  getOneChildOrDescendant,
  getOperatorsForField,
  getOperatorsForType,
  getValueLabel: getValueLabel$1,
  getValueSourcesForFieldOp: getValueSourcesForFieldOp$1,
  getWidgetForFieldOp: getWidgetForFieldOp$3,
  getWidgetsForFieldOp,
  isEmptyGroupChildren: isEmptyGroupChildren$1,
  isEmptyItem,
  isEmptyRuleGroupExtPropertiesAndChildren: isEmptyRuleGroupExtPropertiesAndChildren$1,
  isEmptyRuleProperties: isEmptyRuleProperties$1,
  selectTypes,
  whatRulePropertiesAreCompleted
}, Symbol.toStringTag, { value: "Module" }));
var baseAssignValue$2 = _baseAssignValue, eq$2 = eq_1;
function assignMergeValue$3(object, key, value) {
  if (value !== void 0 && !eq$2(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}
var _assignMergeValue = assignMergeValue$3;
function createBaseFor$2(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$2;
var createBaseFor$1 = _createBaseFor;
var baseFor$3 = createBaseFor$1();
var _baseFor = baseFor$3;
var isArrayLike$4 = isArrayLike_1, isObjectLike$2 = isObjectLike_1;
function isArrayLikeObject$2(value) {
  return isObjectLike$2(value) && isArrayLike$4(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$2;
function safeGet$3(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var _safeGet = safeGet$3;
var copyObject$1 = _copyObject, keysIn$2 = keysIn_1;
function toPlainObject$2(value) {
  return copyObject$1(value, keysIn$2(value));
}
var toPlainObject_1 = toPlainObject$2;
var assignMergeValue$2 = _assignMergeValue, cloneBuffer$1 = _cloneBufferExports, cloneTypedArray$1 = _cloneTypedArray, copyArray$1 = _copyArray, initCloneObject$1 = _initCloneObject, isArguments$1 = isArguments_1, isArray$4 = isArray_1, isArrayLikeObject$1 = isArrayLikeObject_1, isBuffer$1 = isBufferExports, isFunction$1 = isFunction_1, isObject$8 = isObject_1, isPlainObject$1 = isPlainObject_1, isTypedArray$1 = isTypedArray_1, safeGet$2 = _safeGet, toPlainObject$1 = toPlainObject_1;
function baseMergeDeep$2(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$2(object, key), srcValue = safeGet$2(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$2(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$4(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$4(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject$1(objValue)) {
        newValue = copyArray$1(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer$1(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray$1(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject$1(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;
      if (isArguments$1(objValue)) {
        newValue = toPlainObject$1(objValue);
      } else if (!isObject$8(objValue) || isFunction$1(objValue)) {
        newValue = initCloneObject$1(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$2(object, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$2;
var Stack$2 = _Stack, assignMergeValue$1 = _assignMergeValue, baseFor$2 = _baseFor, baseMergeDeep$1 = _baseMergeDeep, isObject$7 = isObject_1, keysIn$1 = keysIn_1, safeGet$1 = _safeGet;
function baseMerge$3(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor$2(source, function(srcValue, key) {
    stack || (stack = new Stack$2());
    if (isObject$7(srcValue)) {
      baseMergeDeep$1(object, source, key, srcIndex, baseMerge$3, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet$1(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue$1(object, key, newValue);
    }
  }, keysIn$1);
}
var _baseMerge = baseMerge$3;
var identity$3 = identity_1, overRest$1 = _overRest, setToString$1 = _setToString;
function baseRest$2(func, start) {
  return setToString$1(overRest$1(func, start, identity$3), func + "");
}
var _baseRest = baseRest$2;
var eq$1 = eq_1, isArrayLike$3 = isArrayLike_1, isIndex$1 = _isIndex, isObject$6 = isObject_1;
function isIterateeCall$3(value, index2, object) {
  if (!isObject$6(object)) {
    return false;
  }
  var type2 = typeof index2;
  if (type2 == "number" ? isArrayLike$3(object) && isIndex$1(index2, object.length) : type2 == "string" && index2 in object) {
    return eq$1(object[index2], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$3;
var baseRest$1 = _baseRest, isIterateeCall$2 = _isIterateeCall;
function createAssigner$3(assigner) {
  return baseRest$1(function(object, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall$2(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$3;
var baseMerge$2 = _baseMerge, createAssigner$2 = _createAssigner;
var merge$1 = createAssigner$2(function(object, source, srcIndex) {
  baseMerge$2(object, source, srcIndex);
});
var merge_1 = merge$1;
const merge$2 = /* @__PURE__ */ getDefaultExportFromCjs(merge_1);
var clone$4 = { exports: {} };
(function(module2) {
  var clone3 = function() {
    function _instanceof(obj, type2) {
      return type2 != null && obj instanceof type2;
    }
    var nativeMap;
    try {
      nativeMap = Map;
    } catch (_) {
      nativeMap = function() {
      };
    }
    var nativeSet;
    try {
      nativeSet = Set;
    } catch (_) {
      nativeSet = function() {
      };
    }
    var nativePromise;
    try {
      nativePromise = Promise;
    } catch (_) {
      nativePromise = function() {
      };
    }
    function clone4(parent2, circular, depth, prototype, includeNonEnumerable) {
      if (typeof circular === "object") {
        depth = circular.depth;
        prototype = circular.prototype;
        includeNonEnumerable = circular.includeNonEnumerable;
        circular = circular.circular;
      }
      var allParents = [];
      var allChildren = [];
      var useBuffer = typeof Buffer != "undefined";
      if (typeof circular == "undefined")
        circular = true;
      if (typeof depth == "undefined")
        depth = Infinity;
      function _clone(parent3, depth2) {
        if (parent3 === null)
          return null;
        if (depth2 === 0)
          return parent3;
        var child;
        var proto2;
        if (typeof parent3 != "object") {
          return parent3;
        }
        if (_instanceof(parent3, nativeMap)) {
          child = new nativeMap();
        } else if (_instanceof(parent3, nativeSet)) {
          child = new nativeSet();
        } else if (_instanceof(parent3, nativePromise)) {
          child = new nativePromise(function(resolve, reject) {
            parent3.then(function(value) {
              resolve(_clone(value, depth2 - 1));
            }, function(err) {
              reject(_clone(err, depth2 - 1));
            });
          });
        } else if (clone4.__isArray(parent3)) {
          child = [];
        } else if (clone4.__isRegExp(parent3)) {
          child = new RegExp(parent3.source, __getRegExpFlags(parent3));
          if (parent3.lastIndex) child.lastIndex = parent3.lastIndex;
        } else if (clone4.__isDate(parent3)) {
          child = new Date(parent3.getTime());
        } else if (useBuffer && Buffer.isBuffer(parent3)) {
          if (Buffer.allocUnsafe) {
            child = Buffer.allocUnsafe(parent3.length);
          } else {
            child = new Buffer(parent3.length);
          }
          parent3.copy(child);
          return child;
        } else if (_instanceof(parent3, Error)) {
          child = Object.create(parent3);
        } else {
          if (typeof prototype == "undefined") {
            proto2 = Object.getPrototypeOf(parent3);
            child = Object.create(proto2);
          } else {
            child = Object.create(prototype);
            proto2 = prototype;
          }
        }
        if (circular) {
          var index2 = allParents.indexOf(parent3);
          if (index2 != -1) {
            return allChildren[index2];
          }
          allParents.push(parent3);
          allChildren.push(child);
        }
        if (_instanceof(parent3, nativeMap)) {
          parent3.forEach(function(value, key) {
            var keyChild = _clone(key, depth2 - 1);
            var valueChild = _clone(value, depth2 - 1);
            child.set(keyChild, valueChild);
          });
        }
        if (_instanceof(parent3, nativeSet)) {
          parent3.forEach(function(value) {
            var entryChild = _clone(value, depth2 - 1);
            child.add(entryChild);
          });
        }
        for (var i2 in parent3) {
          var attrs;
          if (proto2) {
            attrs = Object.getOwnPropertyDescriptor(proto2, i2);
          }
          if (attrs && attrs.set == null) {
            continue;
          }
          child[i2] = _clone(parent3[i2], depth2 - 1);
        }
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(parent3);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            var symbol = symbols[i2];
            var descriptor = Object.getOwnPropertyDescriptor(parent3, symbol);
            if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
              continue;
            }
            child[symbol] = _clone(parent3[symbol], depth2 - 1);
            if (!descriptor.enumerable) {
              Object.defineProperty(child, symbol, {
                enumerable: false
              });
            }
          }
        }
        if (includeNonEnumerable) {
          var allPropertyNames = Object.getOwnPropertyNames(parent3);
          for (var i2 = 0; i2 < allPropertyNames.length; i2++) {
            var propertyName = allPropertyNames[i2];
            var descriptor = Object.getOwnPropertyDescriptor(parent3, propertyName);
            if (descriptor && descriptor.enumerable) {
              continue;
            }
            child[propertyName] = _clone(parent3[propertyName], depth2 - 1);
            Object.defineProperty(child, propertyName, {
              enumerable: false
            });
          }
        }
        return child;
      }
      return _clone(parent2, depth);
    }
    clone4.clonePrototype = function clonePrototype(parent2) {
      if (parent2 === null)
        return null;
      var c2 = function() {
      };
      c2.prototype = parent2;
      return new c2();
    };
    function __objToStr(o) {
      return Object.prototype.toString.call(o);
    }
    clone4.__objToStr = __objToStr;
    function __isDate(o) {
      return typeof o === "object" && __objToStr(o) === "[object Date]";
    }
    clone4.__isDate = __isDate;
    function __isArray(o) {
      return typeof o === "object" && __objToStr(o) === "[object Array]";
    }
    clone4.__isArray = __isArray;
    function __isRegExp(o) {
      return typeof o === "object" && __objToStr(o) === "[object RegExp]";
    }
    clone4.__isRegExp = __isRegExp;
    function __getRegExpFlags(re) {
      var flags3 = "";
      if (re.global) flags3 += "g";
      if (re.ignoreCase) flags3 += "i";
      if (re.multiline) flags3 += "m";
      return flags3;
    }
    clone4.__getRegExpFlags = __getRegExpFlags;
    return clone4;
  }();
  if (module2.exports) {
    module2.exports = clone3;
  }
})(clone$4);
var cloneExports = clone$4.exports;
const clone$3 = /* @__PURE__ */ getDefaultExportFromCjs(cloneExports);
var logic = { exports: {} };
(function(module2, exports2) {
  (function(root2, factory26) {
    {
      module2.exports = factory26();
    }
  })(commonjsGlobal, function() {
    if (!Array.isArray) {
      Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
      };
    }
    function arrayUnique(array) {
      var a2 = [];
      for (var i2 = 0, l = array.length; i2 < l; i2++) {
        if (a2.indexOf(array[i2]) === -1) {
          a2.push(array[i2]);
        }
      }
      return a2;
    }
    var jsonLogic15 = {};
    var operations = {
      "==": function(a2, b) {
        return a2 == b;
      },
      "===": function(a2, b) {
        return a2 === b;
      },
      "!=": function(a2, b) {
        return a2 != b;
      },
      "!==": function(a2, b) {
        return a2 !== b;
      },
      ">": function(a2, b) {
        return a2 > b;
      },
      ">=": function(a2, b) {
        return a2 >= b;
      },
      "<": function(a2, b, c2) {
        return c2 === void 0 ? a2 < b : a2 < b && b < c2;
      },
      "<=": function(a2, b, c2) {
        return c2 === void 0 ? a2 <= b : a2 <= b && b <= c2;
      },
      "!!": function(a2) {
        return jsonLogic15.truthy(a2);
      },
      "!": function(a2) {
        return !jsonLogic15.truthy(a2);
      },
      "%": function(a2, b) {
        return a2 % b;
      },
      "log": function(a2) {
        console.log(a2);
        return a2;
      },
      "in": function(a2, b) {
        if (!b || typeof b.indexOf === "undefined") return false;
        return b.indexOf(a2) !== -1;
      },
      "cat": function() {
        return Array.prototype.join.call(arguments, "");
      },
      "substr": function(source, start, end) {
        if (end < 0) {
          var temp = String(source).substr(start);
          return temp.substr(0, temp.length + end);
        }
        return String(source).substr(start, end);
      },
      "+": function() {
        return Array.prototype.reduce.call(arguments, function(a2, b) {
          return parseFloat(a2, 10) + parseFloat(b, 10);
        }, 0);
      },
      "*": function() {
        return Array.prototype.reduce.call(arguments, function(a2, b) {
          return parseFloat(a2, 10) * parseFloat(b, 10);
        });
      },
      "-": function(a2, b) {
        if (b === void 0) {
          return -a2;
        } else {
          return a2 - b;
        }
      },
      "/": function(a2, b) {
        return a2 / b;
      },
      "min": function() {
        return Math.min.apply(this, arguments);
      },
      "max": function() {
        return Math.max.apply(this, arguments);
      },
      "merge": function() {
        return Array.prototype.reduce.call(arguments, function(a2, b) {
          return a2.concat(b);
        }, []);
      },
      "var": function(a2, b) {
        var not_found = b === void 0 ? null : b;
        var data = this;
        if (typeof a2 === "undefined" || a2 === "" || a2 === null) {
          return data;
        }
        var sub_props = String(a2).split(".");
        for (var i2 = 0; i2 < sub_props.length; i2++) {
          if (data === null || data === void 0) {
            return not_found;
          }
          data = data[sub_props[i2]];
          if (data === void 0) {
            return not_found;
          }
        }
        return data;
      },
      "missing": function() {
        var missing = [];
        var keys4 = Array.isArray(arguments[0]) ? arguments[0] : arguments;
        for (var i2 = 0; i2 < keys4.length; i2++) {
          var key = keys4[i2];
          var value = jsonLogic15.apply({ "var": key }, this);
          if (value === null || value === "") {
            missing.push(key);
          }
        }
        return missing;
      },
      "missing_some": function(need_count, options) {
        var are_missing = jsonLogic15.apply({ "missing": options }, this);
        if (options.length - are_missing.length >= need_count) {
          return [];
        } else {
          return are_missing;
        }
      }
    };
    jsonLogic15.is_logic = function(logic2) {
      return typeof logic2 === "object" && // An object
      logic2 !== null && // but not null
      !Array.isArray(logic2) && // and not an array
      Object.keys(logic2).length === 1;
    };
    jsonLogic15.truthy = function(value) {
      if (Array.isArray(value) && value.length === 0) {
        return false;
      }
      return !!value;
    };
    jsonLogic15.get_operator = function(logic2) {
      return Object.keys(logic2)[0];
    };
    jsonLogic15.get_values = function(logic2) {
      return logic2[jsonLogic15.get_operator(logic2)];
    };
    jsonLogic15.apply = function(logic2, data) {
      if (Array.isArray(logic2)) {
        return logic2.map(function(l) {
          return jsonLogic15.apply(l, data);
        });
      }
      if (!jsonLogic15.is_logic(logic2)) {
        return logic2;
      }
      var op2 = jsonLogic15.get_operator(logic2);
      var values2 = logic2[op2];
      var i2;
      var current;
      var scopedLogic;
      var scopedData;
      var initial;
      if (!Array.isArray(values2)) {
        values2 = [values2];
      }
      if (op2 === "if" || op2 == "?:") {
        for (i2 = 0; i2 < values2.length - 1; i2 += 2) {
          if (jsonLogic15.truthy(jsonLogic15.apply(values2[i2], data))) {
            return jsonLogic15.apply(values2[i2 + 1], data);
          }
        }
        if (values2.length === i2 + 1) {
          return jsonLogic15.apply(values2[i2], data);
        }
        return null;
      } else if (op2 === "and") {
        for (i2 = 0; i2 < values2.length; i2 += 1) {
          current = jsonLogic15.apply(values2[i2], data);
          if (!jsonLogic15.truthy(current)) {
            return current;
          }
        }
        return current;
      } else if (op2 === "or") {
        for (i2 = 0; i2 < values2.length; i2 += 1) {
          current = jsonLogic15.apply(values2[i2], data);
          if (jsonLogic15.truthy(current)) {
            return current;
          }
        }
        return current;
      } else if (op2 === "filter") {
        scopedData = jsonLogic15.apply(values2[0], data);
        scopedLogic = values2[1];
        if (!Array.isArray(scopedData)) {
          return [];
        }
        return scopedData.filter(function(datum) {
          return jsonLogic15.truthy(jsonLogic15.apply(scopedLogic, datum));
        });
      } else if (op2 === "map") {
        scopedData = jsonLogic15.apply(values2[0], data);
        scopedLogic = values2[1];
        if (!Array.isArray(scopedData)) {
          return [];
        }
        return scopedData.map(function(datum) {
          return jsonLogic15.apply(scopedLogic, datum);
        });
      } else if (op2 === "reduce") {
        scopedData = jsonLogic15.apply(values2[0], data);
        scopedLogic = values2[1];
        initial = typeof values2[2] !== "undefined" ? jsonLogic15.apply(values2[2], data) : null;
        if (!Array.isArray(scopedData)) {
          return initial;
        }
        return scopedData.reduce(
          function(accumulator, current2) {
            return jsonLogic15.apply(
              scopedLogic,
              { current: current2, accumulator }
            );
          },
          initial
        );
      } else if (op2 === "all") {
        scopedData = jsonLogic15.apply(values2[0], data);
        scopedLogic = values2[1];
        if (!Array.isArray(scopedData) || !scopedData.length) {
          return false;
        }
        for (i2 = 0; i2 < scopedData.length; i2 += 1) {
          if (!jsonLogic15.truthy(jsonLogic15.apply(scopedLogic, scopedData[i2]))) {
            return false;
          }
        }
        return true;
      } else if (op2 === "none") {
        scopedData = jsonLogic15.apply(values2[0], data);
        scopedLogic = values2[1];
        if (!Array.isArray(scopedData) || !scopedData.length) {
          return true;
        }
        for (i2 = 0; i2 < scopedData.length; i2 += 1) {
          if (jsonLogic15.truthy(jsonLogic15.apply(scopedLogic, scopedData[i2]))) {
            return false;
          }
        }
        return true;
      } else if (op2 === "some") {
        scopedData = jsonLogic15.apply(values2[0], data);
        scopedLogic = values2[1];
        if (!Array.isArray(scopedData) || !scopedData.length) {
          return false;
        }
        for (i2 = 0; i2 < scopedData.length; i2 += 1) {
          if (jsonLogic15.truthy(jsonLogic15.apply(scopedLogic, scopedData[i2]))) {
            return true;
          }
        }
        return false;
      }
      values2 = values2.map(function(val) {
        return jsonLogic15.apply(val, data);
      });
      if (operations.hasOwnProperty(op2) && typeof operations[op2] === "function") {
        return operations[op2].apply(data, values2);
      } else if (op2.indexOf(".") > 0) {
        var sub_ops = String(op2).split(".");
        var operation = operations;
        for (i2 = 0; i2 < sub_ops.length; i2++) {
          if (!operation.hasOwnProperty(sub_ops[i2])) {
            throw new Error("Unrecognized operation " + op2 + " (failed at " + sub_ops.slice(0, i2 + 1).join(".") + ")");
          }
          operation = operation[sub_ops[i2]];
        }
        return operation.apply(data, values2);
      }
      throw new Error("Unrecognized operation " + op2);
    };
    jsonLogic15.uses_data = function(logic2) {
      var collection = [];
      if (jsonLogic15.is_logic(logic2)) {
        var op2 = jsonLogic15.get_operator(logic2);
        var values2 = logic2[op2];
        if (!Array.isArray(values2)) {
          values2 = [values2];
        }
        if (op2 === "var") {
          collection.push(values2[0]);
        } else {
          values2.forEach(function(val) {
            collection.push.apply(collection, jsonLogic15.uses_data(val));
          });
        }
      }
      return arrayUnique(collection);
    };
    jsonLogic15.add_operation = function(name2, code) {
      operations[name2] = code;
    };
    jsonLogic15.rm_operation = function(name2) {
      delete operations[name2];
    };
    jsonLogic15.rule_like = function(rule3, pattern) {
      if (pattern === rule3) {
        return true;
      }
      if (pattern === "@") {
        return true;
      }
      if (pattern === "number") {
        return typeof rule3 === "number";
      }
      if (pattern === "string") {
        return typeof rule3 === "string";
      }
      if (pattern === "array") {
        return Array.isArray(rule3) && !jsonLogic15.is_logic(rule3);
      }
      if (jsonLogic15.is_logic(pattern)) {
        if (jsonLogic15.is_logic(rule3)) {
          var pattern_op = jsonLogic15.get_operator(pattern);
          var rule_op = jsonLogic15.get_operator(rule3);
          if (pattern_op === "@" || pattern_op === rule_op) {
            return jsonLogic15.rule_like(
              jsonLogic15.get_values(rule3, false),
              jsonLogic15.get_values(pattern, false)
            );
          }
        }
        return false;
      }
      if (Array.isArray(pattern)) {
        if (Array.isArray(rule3)) {
          if (pattern.length !== rule3.length) {
            return false;
          }
          for (var i2 = 0; i2 < pattern.length; i2 += 1) {
            if (!jsonLogic15.rule_like(rule3[i2], pattern[i2])) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      }
      return false;
    };
    return jsonLogic15;
  });
})(logic);
var logicExports = logic.exports;
const JL = /* @__PURE__ */ getDefaultExportFromCjs(logicExports);
function ownKeys$v(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$v(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$v(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$v(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function applyJsonLogic(logic2, data) {
  return JL.apply(logic2, data);
}
function addJsonLogicOperation(name2, op2) {
  return JL.add_operation(name2, op2);
}
var customJsonLogicOperations = {
  CALL: function CALL(fn, ctx2) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    return fn.call.apply(fn, [ctx2].concat(args));
  },
  JSX: function JSX(type2, props) {
    return {
      type: type2,
      props
    };
  },
  mergeObjects: function mergeObjects(obj1, obj2) {
    return _objectSpread$v(_objectSpread$v({}, obj1), obj2);
  },
  fromEntries: function fromEntries(entries3) {
    return Object.fromEntries(entries3);
  },
  strlen: function strlen(str) {
    return (str === null || str === void 0 ? void 0 : str.length) || 0;
  },
  regexTest: function regexTest(str, pattern, flags3) {
    return (str === null || str === void 0 ? void 0 : str.match(new RegExp(pattern, flags3))) != null;
  },
  now: function now() {
    return /* @__PURE__ */ new Date();
  },
  date_add: function date_add(date, val, dim) {
    return hooks(date).add(val, dim).toDate();
  },
  toLowerCase: function toLowerCase(str) {
    return str.toLowerCase();
  },
  toUpperCase: function toUpperCase(str) {
    return str.toUpperCase();
  }
};
function addRequiredJsonLogicOperations() {
  for (var k in customJsonLogicOperations) {
    addJsonLogicOperation(k, customJsonLogicOperations[k]);
  }
}
function _createForOfIteratorHelper$9(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$9(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null) it["return"]();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$9(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$9(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$9(o, minLen);
}
function _arrayLikeToArray$9(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function ownKeys$u(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$u(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$u(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$u(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
addRequiredJsonLogicOperations();
function applyJsonLogicWithPath(logic2, data, path) {
  var ret;
  try {
    ret = JL.apply(logic2, data);
  } catch (e2) {
    e2.message = "".concat(path.join("."), " :: ").concat(e2.message);
    throw e2;
  }
  return ret;
}
function callContextFn(_this, fn, args, path) {
  var ret;
  try {
    ret = fn.call.apply(fn, [_this].concat(_toConsumableArray(args)));
  } catch (e2) {
    e2.message = "".concat(path.join("."), " :: ").concat(e2.message);
    throw e2;
  }
  return ret;
}
var configKeys = ["conjunctions", "fields", "types", "operators", "widgets", "settings", "funcs", "ctx"];
var compileMetaFieldSettings = {
  asyncFetch: {
    type: "f",
    args: ["search", "offset"]
  },
  labelYes: {
    type: "r"
  },
  labelNo: {
    type: "r"
  },
  marks: {
    type: "r",
    isArr: true
  },
  validateValue: {
    type: "f",
    args: ["val", "fieldSettings", "op", "opDef", "rightFieldDef"]
  }
};
var compileMetaWidget = _objectSpread$u(_objectSpread$u({}, compileMetaFieldSettings), {}, {
  factory: {
    type: "rf"
  },
  formatValue: {
    type: "f",
    args: ["val", "fieldDef", "wgtDef", "isForDisplay", "op", "opDef", "rightFieldDef"]
  },
  sqlFormatValue: {
    type: "f",
    args: ["val", "fieldDef", "wgtDef", "op", "opDef", "rightFieldDef"]
  },
  spelFormatValue: {
    type: "f",
    args: ["val", "fieldDef", "wgtDef", "op", "opDef", "rightFieldDef"]
  },
  spelImportValue: {
    type: "f",
    args: ["val", "wgtDef", "args"]
  },
  mongoFormatValue: {
    type: "f",
    args: ["val", "fieldDef", "wgtDef", "op", "opDef"]
  },
  elasticSearchFormatValue: {
    type: "f",
    args: ["queryType", "val", "op", "field", "config"]
  },
  jsonLogic: {
    type: "f",
    args: ["val", "fieldDef", "wgtDef", "op", "opDef"]
  },
  jsonLogicImport: {
    type: "f",
    args: ["val"]
  },
  validateValue: {
    type: "f",
    args: ["val", "fieldSettings", "op", "opDef", "rightFieldDef"]
  },
  // obsolete
  toJS: {
    type: "f",
    args: ["val"]
  }
});
var compileMetaOperator = {
  options: {
    // proximity
    factory: {
      type: "rf"
    }
  },
  formatOp: {
    type: "f",
    args: ["field", "op", "vals", "valueSrc", "valueType", "opDef", "operatorOptions", "isForDisplay", "fieldDef"]
  },
  mongoFormatOp: {
    type: "f",
    args: ["field", "op", "vals", "useExpr", "valueSrc", "valueType", "opDef", "operatorOptions", "fieldDef"]
  },
  sqlFormatOp: {
    type: "f",
    args: ["field", "op", "vals", "valueSrc", "valueType", "opDef", "operatorOptions", "fieldDef"]
  },
  spelFormatOp: {
    type: "f",
    args: ["field", "op", "vals", "valueSrc", "valueType", "opDef", "operatorOptions", "fieldDef"]
  },
  jsonLogic: {
    type: "f",
    ignore: "string",
    args: ["field", "op", "vals", "opDef", "operatorOptions", "fieldDef"]
  },
  elasticSearchQueryType: {
    type: "f",
    ignore: "string",
    args: ["valueType"]
  },
  textSeparators: {
    type: "r",
    isArr: true
  }
};
var compileMetaConjunction = {
  formatConj: {
    type: "f",
    args: ["children", "conj", "not", "isForDisplay"]
  },
  sqlFormatConj: {
    type: "f",
    args: ["children", "conj", "not"]
  },
  spelFormatConj: {
    type: "f",
    args: ["children", "conj", "not", "omitBrackets"]
  }
};
var compileMetaWidgetForType = {
  widgetProps: compileMetaWidget,
  opProps: compileMetaOperator
};
var compileMetaFunc = {
  renderBrackets: {
    type: "r",
    isArr: true
  },
  renderSeps: {
    type: "r",
    isArr: true
  },
  jsonLogic: {
    type: "f",
    ignore: "string",
    args: ["formattedArgs"]
  },
  jsonLogicImport: {
    type: "f",
    args: ["val"]
  },
  spelImport: {
    type: "f",
    args: ["spel"]
  },
  formatFunc: {
    type: "f",
    args: ["formattedArgs", "isForDisplay"]
  },
  sqlFormatFunc: {
    type: "f",
    args: ["formattedArgs"]
  },
  mongoFormatFunc: {
    type: "f",
    args: ["formattedArgs"]
  },
  spelFormatFunc: {
    type: "f",
    args: ["formattedArgs"]
  }
};
var compileMetaFieldLike = _objectSpread$u(_objectSpread$u({}, compileMetaFieldSettings), {}, {
  fieldSettings: compileMetaFieldSettings
});
var compileMetaField = _objectSpread$u(_objectSpread$u({}, compileMetaFieldSettings), {}, {
  fieldSettings: compileMetaFieldSettings,
  widgets: {
    x: compileMetaWidgetForType
  },
  mainWidgetProps: compileMetaWidget
});
var compileMetaSettings = {
  locale: {
    mui: {
      type: "f",
      args: [],
      invokeWith: [],
      ignore: "jl"
    }
  },
  caseValueField: compileMetaField,
  canCompareFieldWithField: {
    type: "f",
    args: ["leftField", "leftFieldConfig", "rightField", "rightFieldConfig", "op"]
  },
  formatReverse: {
    type: "f",
    args: ["q", "op", "reversedOp", "operatorDefinition", "revOperatorDefinition", "isForDisplay"]
  },
  sqlFormatReverse: {
    type: "f",
    args: ["q"]
  },
  spelFormatReverse: {
    type: "f",
    args: ["q"]
  },
  formatField: {
    type: "f",
    args: ["field", "parts", "label2", "fieldDefinition", "config", "isForDisplay"]
  },
  formatSpelField: {
    type: "f",
    args: ["field", "parentField", "parts", "partsExt", "fieldDefinition", "config"]
  },
  formatAggr: {
    type: "f",
    args: ["whereStr", "aggrField", "operator", "value", "valueSrc", "valueType", "opDef", "operatorOptions", "isForDisplay", "aggrFieldDef"]
  },
  normalizeListValues: {
    type: "f",
    args: ["listValues", "type", "fieldSettings"]
  },
  renderConfirm: {
    type: "f",
    args: ["props"]
  },
  useConfirm: {
    type: "f",
    args: []
  },
  renderField: {
    type: "rf"
  },
  renderOperator: {
    type: "rf"
  },
  renderFunc: {
    type: "rf"
  },
  renderConjs: {
    type: "rf"
  },
  renderButton: {
    type: "rf"
  },
  renderIcon: {
    type: "rf"
  },
  renderButtonGroup: {
    type: "rf"
  },
  renderValueSources: {
    type: "rf"
  },
  renderFieldSources: {
    type: "rf"
  },
  renderProvider: {
    type: "rf"
  },
  renderSwitch: {
    type: "rf"
  },
  renderSwitchPrefix: {
    type: "r"
  },
  renderItem: {
    type: "rf"
  },
  renderBeforeWidget: {
    type: "rf"
  },
  renderAfterWidget: {
    type: "rf"
  },
  renderBeforeActions: {
    type: "rf"
  },
  renderAfterActions: {
    type: "rf"
  },
  renderBeforeCaseValue: {
    type: "rf"
  },
  renderAfterCaseValue: {
    type: "rf"
  },
  renderRuleError: {
    type: "rf"
  }
};
var compileMeta = {
  fields: {
    x: compileMetaField
  },
  widgets: {
    x: compileMetaWidget
  },
  conjunctions: {
    x: compileMetaConjunction
  },
  operators: {
    x: compileMetaOperator
  },
  types: {
    x: {
      widgets: {
        x: compileMetaWidgetForType
      }
    }
  },
  funcs: {
    x: _objectSpread$u(_objectSpread$u(_objectSpread$u({}, compileMetaFieldLike), compileMetaFunc), {}, {
      args: {
        x: _objectSpread$u({}, compileMetaFieldLike)
      }
    })
  },
  settings: compileMetaSettings
};
var isObject$5 = function isObject5(v) {
  return _typeof$3(v) == "object" && v !== null && !Array.isArray(v);
};
var compressConfig = function compressConfig2(config2, baseConfig2) {
  if (config2.__fieldNames) {
    throw new Error("Don't apply `compressConfig()` to extended config");
  }
  var zipConfig = pick$1(config2, configKeys);
  delete zipConfig.ctx;
  var _clean = function _clean2(target, base, path, meta) {
    if (isObject$5(target)) {
      if (isDirtyJSX(target)) {
        target = cleanJSX(target);
      }
      if (path[0] === "funcs" && !base) {
        var funcKey = path[path.length - 1];
        base = getFieldRawConfig({
          funcs: meta.BasicFuncs
        }, funcKey, "funcs", "subfields") || void 0;
        if (base) {
          target["$$key"] = funcKey;
        }
      }
      if (base !== void 0 && isObject$5(base)) {
        for (var k2 in base) {
          if (Object.prototype.hasOwnProperty.call(base, k2)) {
            if (!Object.keys(target).includes(k2) || target[k2] === void 0 && base[k2] !== void 0) {
              target[k2] = "$$deleted";
            } else {
              target[k2] = _clean2(target[k2], base[k2], [].concat(_toConsumableArray(path), [k2]), meta);
              if (target[k2] === void 0) {
                delete target[k2];
              }
            }
          }
        }
      }
      for (var _k in target) {
        if (Object.prototype.hasOwnProperty.call(target, _k)) {
          if (!base || !Object.keys(base).includes(_k)) {
            var _base;
            target[_k] = _clean2(target[_k], (_base = base) === null || _base === void 0 ? void 0 : _base[_k], [].concat(_toConsumableArray(path), [_k]), meta);
          }
          if (target[_k] === void 0) {
            delete target[_k];
          }
        }
      }
      if (Object.keys(target).length === 0) {
        target = void 0;
      }
    } else if (Array.isArray(target)) {
      target.forEach(function(val, ind) {
        target[ind] = _clean2(target[ind], void 0, [].concat(_toConsumableArray(path), [ind]), meta);
      });
    }
    if (base !== void 0 && shallowEqual$4(target, base, true)) {
      return void 0;
    }
    if (typeof target === "function") {
      throw new Error("compressConfig: function at ".concat(path.join("."), " should be converted to JsonLogic"));
    }
    return target;
  };
  for (var _i = 0, _configKeys = configKeys; _i < _configKeys.length; _i++) {
    var rootKey = _configKeys[_i];
    if (rootKey === "ctx") ;
    else if (rootKey === "fields") {
      zipConfig[rootKey] = clone$3(zipConfig[rootKey]);
      _clean(zipConfig[rootKey], {}, [rootKey]);
    } else if (rootKey === "funcs") {
      zipConfig[rootKey] = clone$3(zipConfig[rootKey] || {});
      for (var k in zipConfig[rootKey]) {
        _clean(zipConfig[rootKey][k], null, [rootKey, k], {
          BasicFuncs
        });
      }
    } else {
      zipConfig[rootKey] = clone$3(zipConfig[rootKey]);
      _clean(zipConfig[rootKey], baseConfig2[rootKey], [rootKey]);
    }
  }
  return zipConfig;
};
var decompressConfig = function decompressConfig2(zipConfig, baseConfig2, ctx2) {
  if (!zipConfig.settings.useConfigCompress) {
    throw new Error("Please enable `useConfigCompress` in config settings to use decompressConfig()");
  }
  var unzipConfig = {};
  var _mergeDeep = function _mergeDeep2(target, mixin2, path) {
    if (isObject$5(mixin2)) {
      if (!isObject$5(target)) {
        target = {};
      }
      for (var k in mixin2) {
        if (Object.prototype.hasOwnProperty.call(mixin2, k)) {
          if (mixin2[k] === "$$deleted") {
            delete target[k];
          } else {
            target[k] = _mergeDeep2(target[k], mixin2[k], [].concat(_toConsumableArray(path), [k]));
          }
        }
      }
    } else if (Array.isArray(mixin2)) {
      target = clone$3(mixin2);
    } else {
      target = mixin2;
    }
    return target;
  };
  var _resolveAndMergeDeep = function _resolveAndMergeDeep2(target, path, meta) {
    var resolved = false;
    if (isObject$5(target) && Object.prototype.hasOwnProperty.call(target, "$$key") && target["$$key"]) {
      var func = getFieldRawConfig({
        funcs: meta.BasicFuncs
      }, target["$$key"], "funcs", "subfields");
      if (func) {
        delete target["$$key"];
        target = _mergeDeep(clone$3(func), target, path);
        resolved = true;
      } else {
        throw new Error("decompressConfig: basic function not found by key ".concat(target["$$key"], " at ").concat(path.join(".")));
      }
    }
    if (!resolved) {
      if (isObject$5(target)) {
        for (var k in target) {
          if (Object.prototype.hasOwnProperty.call(target, k)) {
            target[k] = _resolveAndMergeDeep2(target[k], [].concat(_toConsumableArray(path), [k]), meta);
          }
        }
      } else if (Array.isArray(target)) {
        var _iterator = _createForOfIteratorHelper$9(target), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _k2 = _step.value;
            target[_k2] = _resolveAndMergeDeep2(target[_k2], [].concat(_toConsumableArray(path), [_k2]), meta);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
    return target;
  };
  for (var _i2 = 0, _configKeys2 = configKeys; _i2 < _configKeys2.length; _i2++) {
    var rootKey = _configKeys2[_i2];
    if (rootKey === "ctx") {
      unzipConfig[rootKey] = merge$2({}, baseConfig2.ctx || {}, ctx2 || {});
    } else if (rootKey === "funcs") {
      unzipConfig[rootKey] = clone$3(zipConfig[rootKey] || {});
      _resolveAndMergeDeep(unzipConfig[rootKey], [rootKey], {
        BasicFuncs
      });
    } else if (rootKey === "fields") {
      unzipConfig[rootKey] = clone$3(zipConfig[rootKey] || {});
    } else {
      unzipConfig[rootKey] = clone$3(baseConfig2[rootKey] || {});
      _mergeDeep(unzipConfig[rootKey], zipConfig[rootKey] || {}, [rootKey]);
    }
  }
  return unzipConfig;
};
var compileConfig = function compileConfig2(config2) {
  if (config2.__compliled) {
    return config2;
  }
  config2 = clone$3(config2);
  var opts = {
    ctx: config2.ctx
  };
  var logs = [];
  _compileConfigParts(config2, config2, opts, compileMeta, logs);
  Object.defineProperty(config2, "__compliled", {
    enumerable: false,
    writable: false,
    value: true
  });
  return config2;
};
function _compileConfigParts(config2, subconfig, opts, meta, logs) {
  var path = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
  if (!subconfig) return;
  !path.length;
  for (var k in meta) {
    var submeta = meta[k];
    var newPath = k === "x" ? path : [].concat(_toConsumableArray(path), [k]);
    if (submeta.type === "r") {
      var targetObj = subconfig;
      var val = targetObj[k];
      if (submeta.isArr) {
        for (var ind in val) {
          var newVal = renderReactElement(val[ind], opts, [].concat(_toConsumableArray(newPath), [ind]));
          if (newVal !== val[ind]) {
            logs.push("Compiled ".concat(newPath.join("."), "[").concat(ind, "]"));
            val[ind] = newVal;
          }
        }
      } else {
        var _newVal = renderReactElement(val, opts, newPath, void 0);
        if (_newVal !== val) {
          logs.push("Compiled R ".concat(newPath.join(".")));
          targetObj[k] = _newVal;
        }
      }
    } else if (submeta.type === "rf") {
      var _targetObj = subconfig;
      var _val = _targetObj[k];
      var _newVal2 = compileJsonLogicReact(_val, opts, newPath, submeta.ignore);
      if (_newVal2 !== _val) {
        logs.push("Compiled JL-RF ".concat(newPath.join(".")));
        _targetObj[k] = _newVal2;
      }
    } else if (submeta.type === "f") {
      var _targetObj2 = subconfig;
      var _val2 = _targetObj2[k];
      var _newVal3 = compileJsonLogic(_val2, opts, newPath, submeta.args, submeta.ignore);
      if (submeta.invokeWith && _newVal3 && typeof _newVal3 === "function") {
        var _newVal4;
        _newVal3 = (_newVal4 = _newVal3).call.apply(_newVal4, [null].concat(_toConsumableArray(submeta.invokeWith)));
      }
      if (_newVal3 !== _val2) {
        logs.push("Compiled JL-F ".concat(newPath.join(".")));
        _targetObj2[k] = _newVal3;
      }
    } else if (k === "x") {
      for (var field in subconfig) {
        newPath = [].concat(_toConsumableArray(path), [field]);
        var def = subconfig[field];
        _compileConfigParts(config2, def, opts, submeta, logs, newPath);
        if (def.subfields) {
          _compileConfigParts(config2, def.subfields, opts, meta, logs, newPath);
        }
      }
    } else {
      var _def = subconfig[k];
      _compileConfigParts(config2, _def, opts, submeta, logs, newPath);
    }
  }
}
function compileJsonLogicReact(jl, opts, path) {
  if (isJsonLogic(jl)) {
    return function(props, ctx2) {
      ctx2 = ctx2 || (opts === null || opts === void 0 ? void 0 : opts.ctx);
      var data = {
        props,
        ctx: ctx2
      };
      var re = applyJsonLogicWithPath(jl, data, path);
      if (typeof re === "string") {
        re = {
          type: re,
          props
        };
      }
      var ret = renderReactElement(re, {
        ctx: ctx2
      }, path);
      return ret;
    };
  } else if (typeof jl === "string") {
    return function(props, ctx2) {
      ctx2 = ctx2 || (opts === null || opts === void 0 ? void 0 : opts.ctx);
      var fn = jl.split(".").reduce(function(o, k) {
        return o === null || o === void 0 ? void 0 : o[k];
      }, ctx2);
      if (fn) {
        return callContextFn(this, fn, [props, ctx2], path);
      } else {
        var re = {
          type: jl,
          props
        };
        var ret = renderReactElement(re, {
          ctx: ctx2
        }, path);
        return ret;
      }
    };
  }
  return jl;
}
function compileJsonLogic(jl, opts, path, argNames) {
  var ignore = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
  if (isJsonLogic(jl) && ignore !== "jl") {
    return (function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var ctx2 = this || (opts === null || opts === void 0 ? void 0 : opts.ctx);
      var data = (argNames || []).reduce(function(acc, k, i2) {
        return _objectSpread$u(_objectSpread$u({}, acc), {}, _defineProperty$4({}, k, args[i2]));
      }, {
        args,
        ctx: ctx2
      });
      var ret = applyJsonLogicWithPath(jl, data, path);
      return ret;
    }).bind(opts === null || opts === void 0 ? void 0 : opts.ctx);
  } else if (typeof jl === "string" && ignore !== "string") {
    return (function() {
      var ctx2 = this || (opts === null || opts === void 0 ? void 0 : opts.ctx);
      var fn = jl.split(".").reduce(function(o, k) {
        return o === null || o === void 0 ? void 0 : o[k];
      }, ctx2);
      if (fn) {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return callContextFn(this, fn, args, path);
      } else {
        throw new Error("".concat(path.join("."), " :: Function ").concat(jl, " is not found in ctx"));
      }
    }).bind(opts === null || opts === void 0 ? void 0 : opts.ctx);
  }
  return jl;
}
function getReactComponentFromCtx(name2, ctx2) {
  var _ctx$components;
  return (ctx2 === null || ctx2 === void 0 || (_ctx$components = ctx2.components) === null || _ctx$components === void 0 ? void 0 : _ctx$components[name2]) || ctx2.W[name2] || ctx2.O[name2];
}
function renderReactElement(jsx, opts, path) {
  var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : void 0;
  if (isJSX(jsx)) {
    var _props;
    var type2 = jsx.type, props = jsx.props;
    if (typeof type2 !== "string") {
      throw new Error("renderReactElement for ".concat(path.join("."), ": type should be string"));
    }
    var Cmp = getReactComponentFromCtx(type2, opts.ctx) || type2.toLowerCase();
    var children;
    if (key !== void 0) {
      props = _objectSpread$u(_objectSpread$u({}, props), {}, {
        key
      });
    }
    if ((_props = props) !== null && _props !== void 0 && _props.children) {
      children = renderReactElement(props.children, opts, path);
      props = _objectSpread$u(_objectSpread$u({}, props), {}, {
        children
      });
    }
    var res = opts.ctx.RCE(Cmp, props);
    return res;
  } else if (jsx instanceof Array) {
    return jsx.map(function(el, i2) {
      return renderReactElement(el, opts, path, "" + i2);
    });
  }
  return jsx;
}
var baseMerge$1 = _baseMerge, createAssigner$1 = _createAssigner;
var mergeWith = createAssigner$1(function(object, source, srcIndex, customizer) {
  baseMerge$1(object, source, srcIndex, customizer);
});
var mergeWith_1 = mergeWith;
const mergeWith$1 = /* @__PURE__ */ getDefaultExportFromCjs(mergeWith_1);
var settings$4 = {
  reverseOperatorsForNot: false,
  canShortMongoQuery: true,
  formatField: function formatField3(field, parts, label2, fieldDefinition, config2, isForDisplay) {
    if (isForDisplay) return label2;
    else return field;
  },
  caseValueField: {
    type: "case_value"
  },
  fieldSources: ["field"],
  keepInputOnChangeFieldSrc: true,
  fieldItemKeysForSearch: ["label", "path", "altLabel", "grouplabel"],
  listKeysForSearch: ["title", "value"],
  valueSourcesInfo: {
    value: {}
  },
  fieldSeparator: ".",
  fieldSeparatorDisplay: ".",
  canReorder: true,
  canRegroup: true,
  canDeleteLocked: false,
  canLeaveEmptyGroup: true,
  shouldCreateEmptyGroup: false,
  exportPreserveGroups: false,
  removeEmptyGroupsOnLoad: true,
  removeEmptyRulesOnLoad: true,
  removeIncompleteRulesOnLoad: false,
  removeInvalidMultiSelectValuesOnLoad: true,
  showErrorMessage: false,
  setOpOnChangeField: ["keep", "default"],
  // 'default' (default if present), 'keep' (keep prev from last field), 'first', 'none'
  groupOperators: ["some", "all", "none"],
  defaultGroupConjunction: "AND",
  // localization
  locale: {
    moment: "en"
  },
  valueLabel: "Value",
  valuePlaceholder: "Value",
  fieldLabel: "Field",
  operatorLabel: "Operator",
  funcLabel: "Function",
  fieldPlaceholder: "Select field",
  funcPlaceholder: "Select function",
  operatorPlaceholder: "Select operator",
  lockLabel: "Lock",
  lockedLabel: "Locked",
  deleteLabel: "Delete",
  addGroupLabel: "Add group",
  addCaseLabel: "Add condition",
  addDefaultCaseLabel: "Add default condition",
  defaultCaseLabel: "Default:",
  addRuleLabel: "Add rule",
  addSubRuleLabel: "Add sub rule",
  delGroupLabel: "Delete",
  notLabel: "Not",
  fieldSourcesPopupTitle: "Select source",
  valueSourcesPopupTitle: "Select value source",
  removeRuleConfirmOptions: null,
  removeGroupConfirmOptions: null
};
function _createForOfIteratorHelper$8(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$8(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null) it["return"]();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$8(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$8(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$8(o, minLen);
}
function _arrayLikeToArray$8(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
var memoId = 0;
var configId = 0;
var commonMemo;
var memos = {};
var getCommonMemo = function getCommonMemo2() {
  if (!commonMemo) {
    commonMemo = createConfigMemo$1({
      reactIndex: void 0,
      maxSize: 3,
      canCompile: void 0
      // default is true
    });
  }
  return commonMemo;
};
var findExtendedConfigInAllMemos = function findExtendedConfigInAllMemos2(config2, needsToBeCompiled) {
  var foundExtConfig;
  for (var k in memos) {
    var found = memos[k].findExtendedConfig(config2, needsToBeCompiled);
    if (found) {
      foundExtConfig = found;
      break;
    }
  }
  return foundExtConfig;
};
var createConfigMemo$1 = function createConfigMemo() {
  var meta = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    reactIndex: void 0,
    maxSize: 2,
    // current and prev
    canCompile: true
  };
  var configStore = /* @__PURE__ */ new Map();
  var maxSize = meta.maxSize || 2;
  var currentMemoId = ++memoId;
  var currentMemo;
  var pickConfig = function pickConfig2(props) {
    return pick$1(props, configKeys);
  };
  var extendAndStore = function extendAndStore2(config2) {
    var extendedConfig = extendConfig(config2, ++configId, meta.canCompile);
    storeConfigPair(config2, extendedConfig);
    return extendedConfig;
  };
  var getSize = function getSize2() {
    return configStore.size;
  };
  var storeConfigPair = function storeConfigPair2(config2, extendedConfig) {
    if (configStore.size + 1 > maxSize) {
      configStore["delete"](configStore.keys().next().value);
    }
    configStore.set(config2, extendedConfig);
  };
  var findBasic = function findBasic2(findConfig) {
    var _iterator = _createForOfIteratorHelper$8(configStore.keys()), _step;
    try {
      var _loop = function _loop4() {
        var basicConfig = _step.value;
        var extConfig = configStore.get(basicConfig);
        var found = configKeys.map(function(k) {
          return extConfig[k] === findConfig[k];
        }).filter(function(v) {
          return !v;
        }).length === 0;
        if (found) {
          return {
            v: basicConfig
          };
        }
      }, _ret;
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _ret = _loop();
        if (_ret) return _ret.v;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return findConfig;
  };
  var findExtended = function findExtended2(findConfig, needsToBeCompiled) {
    var _iterator2 = _createForOfIteratorHelper$8(configStore.keys()), _step2;
    try {
      var _loop22 = function _loop23() {
        var savedConfig = _step2.value;
        var foundParts = configKeys.filter(function(k) {
          return savedConfig[k] === findConfig[k];
        });
        var found = foundParts.length === configKeys.length && (needsToBeCompiled ? savedConfig.__compliled : true);
        if (found) {
          return {
            v: configStore.get(savedConfig)
          };
        }
      }, _ret2;
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        _ret2 = _loop22();
        if (_ret2) return _ret2.v;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    var _iterator3 = _createForOfIteratorHelper$8(configStore.values()), _step3;
    try {
      var _loop32 = function _loop33() {
        var extendedConfig = _step3.value;
        var foundParts = configKeys.filter(function(k) {
          return extendedConfig[k] === findConfig[k];
        });
        var found = foundParts.length === configKeys.length && (needsToBeCompiled ? extendedConfig.__compliled : true);
        if (found) {
          return {
            v: extendedConfig
          };
        }
      }, _ret3;
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        _ret3 = _loop32();
        if (_ret3) return _ret3.v;
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
    return null;
  };
  var findOrExtend = function findOrExtend2(config2) {
    return findExtended(config2) || extendAndStore(config2);
  };
  var clearConfigMemo = function clearConfigMemo2() {
    configStore.clear();
    delete memos[currentMemoId];
    if (commonMemo === currentMemo) {
      commonMemo = void 0;
    }
  };
  currentMemo = {
    getExtendedConfig: function getExtendedConfig(props) {
      return findOrExtend(pickConfig(props));
    },
    findExtendedConfig: findExtended,
    getBasicConfig: findBasic,
    clearConfigMemo,
    configId,
    storeConfigPair,
    getSize,
    configStore,
    memoId: currentMemoId,
    meta
  };
  if (meta.reactIndex === void 0) {
    commonMemo = currentMemo;
  }
  memos[currentMemoId] = currentMemo;
  return currentMemo;
};
function _createForOfIteratorHelper$7(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null) it["return"]();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$7(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$7(o, minLen);
}
function _arrayLikeToArray$7(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function ownKeys$t(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$t(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$t(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$t(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var extendConfig = function extendConfig2(config2, configId2) {
  var canCompile = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  canCompile = canCompile && config2.settings.useConfigCompress;
  if (config2.__configId) {
    return config2;
  }
  var cachedExtConfig = findExtendedConfigInAllMemos(config2, canCompile);
  if (cachedExtConfig) {
    return cachedExtConfig;
  }
  var origConfig = config2;
  if (canCompile) {
    if (config2.__compliled) {
      config2 = clone$3(config2);
    } else {
      config2 = compileConfig(config2);
    }
  } else {
    config2 = clone$3(config2);
  }
  config2.settings = mergeWith$1({}, settings$4, config2.settings, mergeCustomizerNoArrays);
  config2.__fieldsCntByType = {};
  config2.__funcsCntByType = {};
  config2.__fieldNames = {};
  extendTypesConfig(config2.types, config2);
  extendFieldsConfig(config2.fields, config2);
  extendFuncsConfig(config2.funcs, config2);
  var caseValueField = config2.settings.caseValueField;
  if (caseValueField) {
    extendFieldConfig(caseValueField, config2, [], false, true);
  }
  var momentLocale = config2.settings.locale.moment;
  if (momentLocale) {
    hooks.locale(momentLocale);
  }
  Object.defineProperty(config2, "__configId", {
    enumerable: false,
    writable: false,
    value: configId2 || uuid()
  });
  config2.__cache = {};
  deepFreeze(config2);
  var memo = getCommonMemo();
  memo.storeConfigPair(origConfig, config2);
  return config2;
};
function extendTypesConfig(typesConfig, config2) {
  for (var type2 in typesConfig) {
    var typeConfig = typesConfig[type2];
    extendTypeConfig(type2, typeConfig, config2);
  }
}
function extendTypeConfig(type2, typeConfig, config2) {
  var operators2 = null, defaultOperator = null;
  typeConfig.mainWidget = typeConfig.mainWidget || Object.keys(typeConfig.widgets).filter(function(w) {
    return w != "field" && w != "func";
  })[0];
  var excludeOperators = typeConfig.excludeOperators || [];
  for (var widget in typeConfig.widgets) {
    var typeWidgetConfig = typeConfig.widgets[widget];
    var defOp = typeWidgetConfig.defaultOperator;
    if (typeWidgetConfig.operators) {
      var typeWidgetOperators = typeWidgetConfig.operators.filter(function(op2) {
        return !excludeOperators.includes(op2);
      });
      operators2 = mergeArraysSmart(operators2, typeWidgetOperators);
    }
    if (defOp && !excludeOperators.includes(defOp)) {
      if (!defaultOperator || widget === typeConfig.mainWidget) {
        defaultOperator = defOp;
      }
    }
    if (widget == typeConfig.mainWidget) {
      typeWidgetConfig.widgetProps = _objectSpread$t(_objectSpread$t({}, typeConfig.mainWidgetProps || {}), typeWidgetConfig.widgetProps || {});
    }
    typeConfig.widgets[widget] = typeWidgetConfig;
  }
  if (!typeConfig.valueSources) typeConfig.valueSources = Object.keys(config2.settings.valueSourcesInfo);
  var _iterator = _createForOfIteratorHelper$7(typeConfig.valueSources), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var valueSrc = _step.value;
      if (valueSrc != "value" && !typeConfig.widgets[valueSrc]) {
        typeConfig.widgets[valueSrc] = {};
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (!typeConfig.operators && operators2) typeConfig.operators = Array.from(new Set(operators2));
  if (!typeConfig.defaultOperator && defaultOperator) typeConfig.defaultOperator = defaultOperator;
}
function extendFieldsConfig(subconfig, config2) {
  var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  for (var field in subconfig) {
    var fieldPathArr = [].concat(_toConsumableArray(path), [field]);
    extendFieldConfig(subconfig[field], config2, fieldPathArr);
    if (subconfig[field].subfields) {
      extendFieldsConfig(subconfig[field].subfields, config2, fieldPathArr);
    }
  }
}
function extendFuncsConfig(subconfig, config2) {
  var _config$settings;
  var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  if (!subconfig) return;
  var fieldSeparator = (config2 === null || config2 === void 0 || (_config$settings = config2.settings) === null || _config$settings === void 0 ? void 0 : _config$settings.fieldSeparator) || ".";
  for (var funcKey in subconfig) {
    var funcPathArr = [].concat(_toConsumableArray(path), [funcKey]);
    var funcPathStr = funcPathArr.join(fieldSeparator);
    var funcDef = subconfig[funcKey];
    if (funcDef.returnType) {
      funcDef.type = funcDef.returnType;
      if (!config2.__funcsCntByType[funcDef.returnType]) config2.__funcsCntByType[funcDef.returnType] = 0;
      config2.__funcsCntByType[funcDef.returnType]++;
    }
    extendFieldConfig(funcDef, config2, funcPathArr, false);
    if (funcDef.args) {
      for (var argKey in funcDef.args) {
        extendFieldConfig(funcDef.args[argKey], config2, [].concat(_toConsumableArray(funcPathArr), [argKey]), true);
      }
      var argKeys = Object.keys(funcDef.args);
      var tmpIsOptional = true;
      var _iterator2 = _createForOfIteratorHelper$7(argKeys.reverse()), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _argKey = _step2.value;
          var argDef = funcDef.args[_argKey];
          if (!tmpIsOptional && argDef.isOptional) {
            logger$1.info("Arg ".concat(_argKey, " for func ").concat(funcPathStr, " can't be optional"));
            delete argDef.isOptional;
          }
          if (!argDef.isOptional) tmpIsOptional = false;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    if (funcDef.subfields) {
      extendFuncsConfig(funcDef.subfields, config2, [].concat(_toConsumableArray(path), [funcKey]));
    }
  }
}
function normalizeFieldSettings(fieldConfig, config2, type2) {
  var _fieldConfig$fieldSet, _fieldConfig$fieldSet2;
  var keysToPutInFieldSettings = ["listValues", "treeValues", "allowCustomValues", "validateValue"];
  for (var _i = 0, _keysToPutInFieldSett = keysToPutInFieldSettings; _i < _keysToPutInFieldSett.length; _i++) {
    var k = _keysToPutInFieldSett[_i];
    if (fieldConfig[k]) {
      if (!fieldConfig.fieldSettings) fieldConfig.fieldSettings = {};
      fieldConfig.fieldSettings[k] = fieldConfig[k];
      delete fieldConfig[k];
    }
  }
  if ((_fieldConfig$fieldSet = fieldConfig.fieldSettings) !== null && _fieldConfig$fieldSet !== void 0 && _fieldConfig$fieldSet.listValues) {
    if (config2.settings.normalizeListValues) {
      fieldConfig.fieldSettings.listValues = config2.settings.normalizeListValues.call(config2.ctx, fieldConfig.fieldSettings.listValues, type2, fieldConfig.fieldSettings);
    }
  }
  if ((_fieldConfig$fieldSet2 = fieldConfig.fieldSettings) !== null && _fieldConfig$fieldSet2 !== void 0 && _fieldConfig$fieldSet2.treeValues) {
    if (config2.settings.normalizeListValues) {
      fieldConfig.fieldSettings.treeValues = config2.settings.normalizeListValues.call(config2.ctx, fieldConfig.fieldSettings.treeValues, type2, fieldConfig.fieldSettings);
    }
  }
}
function extendFieldConfig(fieldConfig, config2) {
  var _fieldSeparator;
  var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var isFuncArg = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var isCaseValue = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var _config$settings2 = config2.settings, showLabels = _config$settings2.showLabels, fieldSeparator = _config$settings2.fieldSeparator;
  fieldSeparator = (_fieldSeparator = fieldSeparator) !== null && _fieldSeparator !== void 0 ? _fieldSeparator : ".";
  var argKey = path[path.length - 1];
  var funcKey = isFuncArg ? path.slice(0, path.length - 1).join(fieldSeparator) : path.join(fieldSeparator);
  var isFunc = !!fieldConfig.returnType;
  var type2 = fieldConfig.type || fieldConfig.returnType;
  var typeConfig = config2.types[type2];
  var excludeOperatorsForField = fieldConfig.excludeOperators || [];
  var operators2 = (fieldConfig.operators || (typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.operators) || []).filter(function(op2) {
    return !excludeOperatorsForField.includes(op2);
  });
  var defaultOperator = fieldConfig.defaultOperator || (typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.defaultOperator);
  if (excludeOperatorsForField.includes(defaultOperator)) defaultOperator = void 0;
  var hasOwnDefaultOperator = !!defaultOperator && defaultOperator == fieldConfig.defaultOperator;
  if (hasOwnDefaultOperator) {
    fieldConfig.ownDefaultOperator = fieldConfig.defaultOperator;
  }
  if (!typeConfig) {
    fieldConfig.disabled = true;
    return;
  }
  if (!isFuncArg && !isFunc && !isCaseValue) {
    if (!config2.__fieldsCntByType[type2]) config2.__fieldsCntByType[type2] = 0;
    config2.__fieldsCntByType[type2]++;
  }
  if (isFuncArg) {
    fieldConfig._isFuncArg = true;
    fieldConfig._argKey = argKey;
    fieldConfig._funcKey = funcKey;
  }
  if (isFunc) {
    fieldConfig._isFunc = true;
    fieldConfig._funcKey = funcKey;
  }
  if (isCaseValue) {
    fieldConfig._isCaseValue = true;
  }
  normalizeFieldSettings(fieldConfig, config2, type2);
  var excludeKeysFromType = ["widgets", "operators", "defaultOperator"];
  Object.keys(typeConfig).filter(function(k) {
    return !excludeKeysFromType.includes(k);
  }).map(function(k) {
    if (!fieldConfig[k]) {
      fieldConfig[k] = shallowCopy(typeConfig[k]);
    }
  });
  var excludeOperatorsForType = typeConfig.excludeOperators || [];
  if (fieldConfig.operators) {
    excludeOperatorsForType = excludeOperatorsForType.filter(function(op2) {
      return !fieldConfig.operators.includes(op2);
    });
  }
  if (!fieldConfig.widgets) fieldConfig.widgets = {};
  var _loop = function _loop4() {
    var fieldWidgetConfig = _objectSpread$t({}, fieldConfig.widgets[widget] || {});
    var typeWidgetConfig = typeConfig.widgets[widget] || {};
    if (!isFuncArg) {
      var defOp = fieldWidgetConfig.defaultOperator;
      var excludeOperators = [].concat(_toConsumableArray(excludeOperatorsForField), _toConsumableArray(excludeOperatorsForType));
      var shouldIncludeOperators = fieldConfig.preferWidgets && (widget === "field" || fieldConfig.preferWidgets.includes(widget)) || excludeOperators.length > 0;
      if (fieldWidgetConfig.operators) {
        var addOperators = fieldWidgetConfig.operators.filter(function(op3) {
          return !excludeOperators.includes(op3);
        });
        fieldWidgetConfig.operators = addOperators;
        operators2 = mergeArraysSmart(operators2, addOperators);
      } else if (shouldIncludeOperators && typeWidgetConfig.operators) {
        var _addOperators = typeWidgetConfig.operators.filter(function(op3) {
          return !excludeOperators.includes(op3);
        });
        fieldWidgetConfig.operators = _addOperators;
        operators2 = mergeArraysSmart(operators2, _addOperators);
      }
      if (defOp && !excludeOperators.includes(defOp)) {
        if (!defaultOperator || !hasOwnDefaultOperator && widget === fieldConfig.mainWidget) {
          defaultOperator = defOp;
        }
      }
    }
    if (widget === fieldConfig.mainWidget) {
      fieldWidgetConfig.widgetProps = _objectSpread$t(_objectSpread$t(_objectSpread$t({}, typeWidgetConfig.widgetProps || {}), fieldConfig.mainWidgetProps || {}), fieldWidgetConfig.widgetProps || {});
    } else {
      fieldWidgetConfig.widgetProps = _objectSpread$t(_objectSpread$t({}, typeWidgetConfig.widgetProps || {}), fieldWidgetConfig.widgetProps || {});
    }
    var opKeys = Array.from(new Set([].concat(_toConsumableArray(Object.keys(typeWidgetConfig.opProps || {})), _toConsumableArray(Object.keys(fieldWidgetConfig.opProps || {})))));
    if (opKeys.length) {
      var opProps = {};
      var _iterator3 = _createForOfIteratorHelper$7(opKeys), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var _typeWidgetConfig$opP, _fieldWidgetConfig$op;
          var op2 = _step3.value;
          opProps[op2] = _objectSpread$t(_objectSpread$t({}, ((_typeWidgetConfig$opP = typeWidgetConfig.opProps) === null || _typeWidgetConfig$opP === void 0 ? void 0 : _typeWidgetConfig$opP[op2]) || {}), ((_fieldWidgetConfig$op = fieldWidgetConfig.opProps) === null || _fieldWidgetConfig$op === void 0 ? void 0 : _fieldWidgetConfig$op[op2]) || {});
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      fieldWidgetConfig.opProps = opProps;
    }
    var _fieldWidgetConfig = fieldWidgetConfig, valueLabel = _fieldWidgetConfig.valueLabel, valuePlaceholder = _fieldWidgetConfig.valuePlaceholder;
    if (isFuncArg) {
      if (!valueLabel) fieldWidgetConfig.valueLabel = fieldConfig.label || argKey;
      if (!valuePlaceholder && !showLabels) fieldWidgetConfig.valuePlaceholder = fieldConfig.label || argKey;
    }
    fieldWidgetConfig = _objectSpread$t(_objectSpread$t({}, typeWidgetConfig), fieldWidgetConfig);
    fieldConfig.widgets[widget] = fieldWidgetConfig;
  };
  for (var widget in typeConfig.widgets) {
    _loop();
  }
  if (!isFuncArg) {
    if (!fieldConfig.operators) {
      fieldConfig.operators = Array.from(new Set(operators2));
    }
    if (!fieldConfig.defaultOperator) {
      fieldConfig.defaultOperator = defaultOperator;
    }
  }
  if (!isFuncArg && !isFunc && !isCaseValue) {
    var _computeFieldName = computeFieldName(config2, path), fieldName = _computeFieldName.fieldName, inGroup = _computeFieldName.inGroup;
    if (fieldName) {
      fieldConfig.fieldName = fieldName;
      if (!config2.__fieldNames[fieldName]) config2.__fieldNames[fieldName] = [];
      config2.__fieldNames[fieldName].push({
        fullPath: path,
        inGroup
      });
    }
  }
}
function computeFieldName(config2, path) {
  if (!path) return {};
  var fieldSeparator = config2.settings.fieldSeparator;
  var _reduce = _toConsumableArray(path).reduce(function(_ref, f, i2, arr) {
    var computedPath2 = _ref.computedPath, computed2 = _ref.computed, inGroup2 = _ref.inGroup;
    var fullPath = [].concat(_toConsumableArray(arr.slice(0, i2)), [f]);
    var fConfig = getFieldRawConfig(config2, fullPath);
    if ((fConfig === null || fConfig === void 0 ? void 0 : fConfig.type) === "!group" && i2 < arr.length - 1) {
      inGroup2 = fullPath.join(fieldSeparator);
      computedPath2 = [];
    } else if (fConfig !== null && fConfig !== void 0 && fConfig.fieldName) {
      computed2 = true;
      computedPath2 = [fConfig.fieldName];
    } else {
      computedPath2 = [].concat(_toConsumableArray(computedPath2), [f]);
    }
    return {
      computedPath: computedPath2,
      computed: computed2,
      inGroup: inGroup2
    };
  }, {
    computedPath: [],
    computed: false,
    inGroup: void 0
  }), computedPath = _reduce.computedPath, computed = _reduce.computed, inGroup = _reduce.inGroup;
  return computed ? {
    fieldName: computedPath.join(fieldSeparator),
    inGroup
  } : {};
}
function ownKeys$s(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$s(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$s(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$s(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var _marked = /* @__PURE__ */ _regeneratorRuntime.mark(iterateFuncs), _marked2 = /* @__PURE__ */ _regeneratorRuntime.mark(iterateFields);
var _widgetDefKeysToOmit$1 = widgetDefKeysToOmit;
function iterateFuncs(config2) {
  return _regeneratorRuntime.wrap(function iterateFuncs$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        return _context.delegateYield(_iterateFields(config2, config2.funcs || {}, []), "t0", 1);
      case 1:
      case "end":
        return _context.stop();
    }
  }, _marked);
}
function iterateFields(config2) {
  return _regeneratorRuntime.wrap(function iterateFields$(_context2) {
    while (1) switch (_context2.prev = _context2.next) {
      case 0:
        return _context2.delegateYield(_iterateFields(config2, config2.fields || {}, []), "t0", 1);
      case 1:
      case "end":
        return _context2.stop();
    }
  }, _marked2);
}
function _iterateFields(config2, subfields, path) {
  var subfieldsKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "subfields";
  return /* @__PURE__ */ _regeneratorRuntime.mark(function _callee(_config$settings) {
    var fieldSeparator, fieldKey, fieldConfig;
    return _regeneratorRuntime.wrap(function _callee$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          fieldSeparator = (config2 === null || config2 === void 0 || (_config$settings = config2.settings) === null || _config$settings === void 0 ? void 0 : _config$settings.fieldSeparator) || ".";
          _context3.t0 = _regeneratorRuntime.keys(subfields);
        case 2:
          if ((_context3.t1 = _context3.t0()).done) {
            _context3.next = 13;
            break;
          }
          fieldKey = _context3.t1.value;
          fieldConfig = subfields[fieldKey];
          if (!fieldConfig[subfieldsKey]) {
            _context3.next = 9;
            break;
          }
          return _context3.delegateYield(_iterateFields(config2, fieldConfig[subfieldsKey], [].concat(_toConsumableArray(path), [fieldKey]), subfieldsKey), "t2", 7);
        case 7:
          _context3.next = 11;
          break;
        case 9:
          _context3.next = 11;
          return [[].concat(_toConsumableArray(path), [fieldKey]).join(fieldSeparator), fieldConfig];
        case 11:
          _context3.next = 2;
          break;
        case 13:
        case "end":
          return _context3.stop();
      }
    }, _callee);
  })();
}
var getFieldRawConfig = function getFieldRawConfig2(config2, field) {
  var _config$settings3;
  var fieldsKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "fields";
  var subfieldsKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "subfields";
  if (!field) return null;
  if (field === "!case_value") {
    var _config$settings2;
    return config2 === null || config2 === void 0 || (_config$settings2 = config2.settings) === null || _config$settings2 === void 0 ? void 0 : _config$settings2.caseValueField;
  }
  var fieldSeparator = (config2 === null || config2 === void 0 || (_config$settings3 = config2.settings) === null || _config$settings3 === void 0 ? void 0 : _config$settings3.fieldSeparator) || ".";
  var parts = getFieldParts$3(field, config2);
  var targetFields = config2[fieldsKey];
  if (!targetFields) return null;
  var fields = targetFields;
  var fieldConfig = null;
  var path = [];
  for (var i2 = 0; i2 < parts.length; i2++) {
    var part = parts[i2];
    path.push(part);
    var pathKey = path.join(fieldSeparator);
    fieldConfig = fields[pathKey];
    if (i2 < parts.length - 1) {
      if (fieldConfig && fieldConfig[subfieldsKey]) {
        fields = fieldConfig[subfieldsKey];
        path = [];
      } else {
        fieldConfig = null;
      }
    }
  }
  return fieldConfig;
};
var normalizeField = function normalizeField2(config2, field) {
  var _config$__fieldNames$, _config$__fieldNames$2;
  var parentField = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var fieldSeparator = config2.settings.fieldSeparator;
  var path = [parentField].concat(_toConsumableArray(field.split(fieldSeparator))).filter(function(f) {
    return f != null;
  });
  var findStr = field;
  var normalizedPath = (_config$__fieldNames$ = config2.__fieldNames[findStr]) === null || _config$__fieldNames$ === void 0 || (_config$__fieldNames$2 = _config$__fieldNames$.find) === null || _config$__fieldNames$2 === void 0 || (_config$__fieldNames$2 = _config$__fieldNames$2.call(_config$__fieldNames$, function(_ref) {
    var inGroup = _ref.inGroup;
    if (inGroup) return parentField === null || parentField === void 0 ? void 0 : parentField.startsWith(inGroup);
    return true;
  })) === null || _config$__fieldNames$2 === void 0 ? void 0 : _config$__fieldNames$2.fullPath;
  return (normalizedPath || path).join(fieldSeparator);
};
var getFuncSignature = function getFuncSignature2(config2, func) {
  if (!func) return null;
  var funcConfig = getFieldRawConfig(config2, func, "funcs", "subfields");
  if (!funcConfig) return null;
  var returnType = funcConfig.returnType, args = funcConfig.args;
  var argsSignature = Object.fromEntries(Object.entries(args || {}).map(function(_ref2) {
    var _ref3 = _slicedToArray$1(_ref2, 2), k = _ref3[0], v = _ref3[1];
    var argSignature = pick$1(v, [
      "type",
      "valueSources",
      "defaultValue",
      "fieldSettings",
      // "asyncListValues", // not supported
      "isOptional",
      // to get proper caching key
      "_funcKey",
      "_argKey",
      "_isFuncArg"
    ]);
    return [k, argSignature];
  }));
  var signature = {
    returnType,
    args: argsSignature
  };
  return signature;
};
var getFuncConfig$2 = function getFuncConfig(config2, func) {
  if (!func) return null;
  var funcConfig = getFieldRawConfig(config2, func, "funcs", "subfields");
  if (!funcConfig) return null;
  return funcConfig;
};
var getFuncArgConfig = function getFuncArgConfig2(config2, funcKey, argKey) {
  var funcConfig = getFuncConfig$2(config2, funcKey);
  if (!funcConfig) return null;
  var argConfig = funcConfig.args && funcConfig.args[argKey] || null;
  if (!argConfig) return null;
  return argConfig;
};
var isFieldDescendantOfField = function isFieldDescendantOfField2(field, parentField) {
  var _config$settings4;
  var config2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  if (!parentField) return false;
  var fieldSeparator = (config2 === null || config2 === void 0 || (_config$settings4 = config2.settings) === null || _config$settings4 === void 0 ? void 0 : _config$settings4.fieldSeparator) || ".";
  var path = getFieldPath(field, config2);
  var parentPath = getFieldPath(parentField, config2);
  return path.startsWith(parentPath + fieldSeparator);
};
var getFieldPath = function getFieldPath2(field) {
  var _config$settings5;
  var config2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (typeof field === "string") return field;
  var fieldSeparator = (config2 === null || config2 === void 0 || (_config$settings5 = config2.settings) === null || _config$settings5 === void 0 ? void 0 : _config$settings5.fieldSeparator) || ".";
  return getFieldParts$3(field, config2).join(fieldSeparator);
};
var getFieldParts$3 = function getFieldParts(field) {
  var _config$settings6, _field$get, _field$split;
  var config2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!field) return [];
  if (Array.isArray(field)) return field;
  var fieldSeparator = (config2 === null || config2 === void 0 || (_config$settings6 = config2.settings) === null || _config$settings6 === void 0 ? void 0 : _config$settings6.fieldSeparator) || ".";
  if (field !== null && field !== void 0 && field.func) {
    return Array.isArray(field.func) ? field.func : field.func.split(fieldSeparator);
  }
  if (field !== null && field !== void 0 && (_field$get = field.get) !== null && _field$get !== void 0 && _field$get.call(field, "func")) {
    var _field$get2;
    return field === null || field === void 0 || (_field$get2 = field.get) === null || _field$get2 === void 0 ? void 0 : _field$get2.call(field, "func").split(fieldSeparator);
  }
  return (field === null || field === void 0 || (_field$split = field.split) === null || _field$split === void 0 ? void 0 : _field$split.call(field, fieldSeparator)) || [];
};
var getFieldPathParts$3 = function getFieldPathParts(field, config2) {
  var onlyKeys = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (!field) return null;
  var fieldSeparator = config2.settings.fieldSeparator;
  var parts = getFieldParts$3(field, config2);
  if (onlyKeys) return parts;
  else return parts.map(function(_curr, ind, arr) {
    return arr.slice(0, ind + 1);
  }).map(function(parts2) {
    return parts2.join(fieldSeparator);
  });
};
var getFieldId$1 = function getFieldId(field) {
  var _field$get3;
  if (typeof field === "string" || Array.isArray(field)) {
    return "field:".concat(getFieldPath(field));
  }
  if (_typeof$3(field) === "object" && field) {
    if (field._funcKey && field._argKey) {
      return "arg:".concat(getFieldPath(field._funcKey), "__").concat(field._argKey);
    }
    if (field._funcKey) {
      return "func:".concat(getFieldPath(field._funcKey));
    }
    if (field.func && field.arg) {
      return "arg:".concat(getFieldPath(field.func), "__").concat(field.arg);
    }
    if (field.func) {
      return "func:".concat(getFieldPath(field.func));
    }
    if (field.type) {
      return null;
    }
  }
  if (field !== null && field !== void 0 && (_field$get3 = field.get) !== null && _field$get3 !== void 0 && _field$get3.call(field, "func")) {
    if (field !== null && field !== void 0 && field.get("arg")) {
      return "arg:".concat(getFieldPath(field.get("func")), "__").concat(field.get("arg"));
    } else {
      return "func:".concat(getFieldPath(field.get("func")));
    }
  }
  return null;
};
var _getFromConfigCache = function _getFromConfigCache2(config2, bucketKey, cacheKey) {
  var _config$__cache;
  return (_config$__cache = config2.__cache) === null || _config$__cache === void 0 || (_config$__cache = _config$__cache[bucketKey]) === null || _config$__cache === void 0 ? void 0 : _config$__cache[cacheKey];
};
var _saveToConfigCache = function _saveToConfigCache2(config2, bucketKey, cacheKey, value) {
  if (!config2.__cache || !cacheKey) {
    return;
  }
  if (!config2.__cache[bucketKey]) {
    config2.__cache[bucketKey] = {};
  }
  config2.__cache[bucketKey][cacheKey] = value;
};
var getFieldSrc = function getFieldSrc2(field) {
  var _field$get4;
  if (!field) return null;
  if (_typeof$3(field) === "object") {
    if (!field.func && !!field.type) {
      return "field";
    }
    if (field.func) {
      if (field.func && field.arg) {
        return null;
      } else {
        return "func";
      }
    }
  }
  if (field !== null && field !== void 0 && (_field$get4 = field.get) !== null && _field$get4 !== void 0 && _field$get4.call(field, "func")) {
    if (field !== null && field !== void 0 && field.get("arg")) {
      return null;
    } else {
      return "func";
    }
  }
  return "field";
};
var getFieldConfig$8 = function getFieldConfig(config2, field) {
  var _field$get5;
  if (!field) return null;
  if (_typeof$3(field) == "object") {
    if (!field.func && !!field.type) {
      return field;
    }
    if (field.func) {
      if (field.func && field.arg) {
        return getFuncArgConfig(config2, field.func, field.arg);
      } else {
        return getFuncConfig$2(config2, field.func);
      }
    }
  }
  if (field !== null && field !== void 0 && (_field$get5 = field.get) !== null && _field$get5 !== void 0 && _field$get5.call(field, "func")) {
    if (field !== null && field !== void 0 && field.get("arg")) {
      return getFuncArgConfig(config2, field.get("func"), field.get("arg"));
    } else {
      return getFuncConfig$2(config2, field.get("func"));
    }
  }
  var fieldConfig = getFieldRawConfig(config2, field);
  if (!fieldConfig) return null;
  return fieldConfig;
};
var getOperatorConfig$4 = function getOperatorConfig(config2, operator) {
  var field = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  if (!operator) return null;
  var opConfig = config2.operators[operator];
  if (field) {
    var _widgetConfig$opProps, _fieldWidgetConfig$op;
    var fieldCacheKey = getFieldId$1(field);
    var cacheKey = fieldCacheKey ? "".concat(fieldCacheKey, "__").concat(operator) : null;
    var cached = _getFromConfigCache(config2, "getOperatorConfig", cacheKey);
    if (cached) return cached;
    var fieldConfig = getFieldConfig$8(config2, field);
    var widget = getWidgetForFieldOp$3(config2, field, operator, null);
    var widgetConfig = config2.widgets[widget] || {};
    var fieldWidgetConfig = (fieldConfig && fieldConfig.widgets ? fieldConfig.widgets[widget] : {}) || {};
    var widgetOpProps = ((_widgetConfig$opProps = widgetConfig.opProps) === null || _widgetConfig$opProps === void 0 ? void 0 : _widgetConfig$opProps[operator]) || {};
    var fieldWidgetOpProps = ((_fieldWidgetConfig$op = fieldWidgetConfig.opProps) === null || _fieldWidgetConfig$op === void 0 ? void 0 : _fieldWidgetConfig$op[operator]) || {};
    var mergedConfig = _objectSpread$s(_objectSpread$s(_objectSpread$s({}, opConfig), widgetOpProps), fieldWidgetOpProps);
    _saveToConfigCache(config2, "getOperatorConfig", cacheKey, mergedConfig);
    return mergedConfig;
  } else {
    return opConfig;
  }
};
var getFieldWidgetConfig$3 = function getFieldWidgetConfig(config2, field) {
  var _fieldConfig$widgets;
  var operator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var widget = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var valueSrc = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var meta = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
  if (!field) return null;
  var fieldConfig = getFieldConfig$8(config2, field);
  var fieldCacheKey = getFieldId$1(field);
  if (!widget) {
    widget = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
  }
  var cacheKey = fieldCacheKey ? "".concat(fieldCacheKey, "__").concat(operator, "__").concat(widget, "__").concat(valueSrc) : null;
  var cached = _getFromConfigCache(config2, "getFieldWidgetConfig", cacheKey);
  if (cached) return cached;
  var widgetConfig = config2.widgets[widget] || {};
  var fieldWidgetConfig = (fieldConfig === null || fieldConfig === void 0 || (_fieldConfig$widgets = fieldConfig.widgets) === null || _fieldConfig$widgets === void 0 ? void 0 : _fieldConfig$widgets[widget]) || {};
  var fieldWidgetProps = fieldWidgetConfig.widgetProps || {};
  var valueFieldSettings = valueSrc === "value" || !valueSrc ? fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.fieldSettings : {};
  var mergedConfig = _objectSpread$s(_objectSpread$s(_objectSpread$s(_objectSpread$s({}, widgetConfig), fieldWidgetConfig), fieldWidgetProps), valueFieldSettings);
  _saveToConfigCache(config2, "getFieldWidgetConfig", cacheKey, mergedConfig);
  if (meta.forExport) {
    mergedConfig = omit$2(mergedConfig, "factory");
  }
  return mergedConfig;
};
var getFirstField = function getFirstField2(config2) {
  var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var fieldSeparator = config2.settings.fieldSeparator;
  var parentPathArr = getFieldParts$3(parentRuleGroupPath, config2);
  var parentField = parentRuleGroupPath ? getFieldRawConfig(config2, parentRuleGroupPath) : config2;
  var firstField = parentField, key = null, keysPath = [];
  do {
    var _firstField;
    var subfields = firstField === config2 ? config2.fields : (_firstField = firstField) === null || _firstField === void 0 ? void 0 : _firstField.subfields;
    if (!subfields || !Object.keys(subfields).length) {
      firstField = key = null;
      break;
    }
    key = Object.keys(subfields)[0];
    keysPath.push(key);
    firstField = subfields[key];
  } while (firstField.type == "!struct" || firstField.type == "!group");
  return (parentPathArr || []).concat(keysPath).join(fieldSeparator);
};
const configUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _getFromConfigCache,
  _saveToConfigCache,
  _widgetDefKeysToOmit: _widgetDefKeysToOmit$1,
  applyJsonLogic,
  cleanJSX,
  compileConfig,
  compressConfig,
  configKeys,
  createConfigMemo: createConfigMemo$1,
  decompressConfig,
  extendConfig,
  findExtendedConfigInAllMemos,
  getCommonMemo,
  getFieldConfig: getFieldConfig$8,
  getFieldId: getFieldId$1,
  getFieldParts: getFieldParts$3,
  getFieldPath,
  getFieldPathParts: getFieldPathParts$3,
  getFieldRawConfig,
  getFieldSrc,
  getFieldWidgetConfig: getFieldWidgetConfig$3,
  getFirstField,
  getFuncArgConfig,
  getFuncConfig: getFuncConfig$2,
  getFuncSignature,
  getOperatorConfig: getOperatorConfig$4,
  isDirtyJSX,
  isFieldDescendantOfField,
  isJSX,
  iterateFields,
  iterateFuncs,
  normalizeField
}, Symbol.toStringTag, { value: "Module" }));
function ownKeys$r(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$r(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$r(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$r(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var queryBuilderFormat = function queryBuilderFormat2(item, config2) {
  var meta = {
    usedFields: []
  };
  var res = formatItem$3(item, config2, meta);
  if (!res) return void 0;
  return _objectSpread$r(_objectSpread$r({}, res), meta);
};
var formatItem$3 = function formatItem3(item, config2, meta) {
  if (!item) return void 0;
  var type2 = item.get("type");
  var children = item.get("children1");
  if ((type2 === "group" || type2 === "rule_group") && children && children.size) {
    return formatGroup$3(item, config2, meta);
  } else if (type2 === "rule") {
    return formatRule$3(item, config2, meta);
  }
  return void 0;
};
var formatGroup$3 = function formatGroup3(item, config2, meta) {
  var properties = item.get("properties") || new Map$2();
  var children = item.get("children1");
  var id2 = item.get("id");
  var list2 = children.map(function(currentChild) {
    return formatItem$3(currentChild, config2, meta);
  }).filter(function(currentChild) {
    return typeof currentChild !== "undefined";
  });
  if (!list2.size) return void 0;
  var conjunction = properties.get("conjunction");
  if (!conjunction) conjunction = defaultConjunction(config2);
  var not2 = properties.get("not");
  var resultQuery = {
    id: id2,
    rules: list2.toList(),
    condition: conjunction.toUpperCase(),
    not: not2
  };
  return resultQuery;
};
var formatRule$3 = function formatRule3(item, config2, meta) {
  var _valueType;
  var properties = item.get("properties") || new Map$2();
  var id2 = item.get("id");
  var operator = properties.get("operator");
  var options = properties.get("operatorOptions");
  var field = properties.get("field");
  var value = properties.get("value");
  var valueSrc = properties.get("valueSrc");
  var valueType = properties.get("valueType");
  var hasUndefinedValues = value.filter(function(v) {
    return v === void 0;
  }).size > 0;
  if (field == null || operator == null || hasUndefinedValues) return void 0;
  var fieldDefinition = getFieldConfig$8(config2, field) || {};
  var operatorDefinition = getOperatorConfig$4(config2, operator, field) || {};
  var fieldType = fieldDefinition.type || "undefined";
  var cardinality = getOpCardinality$1(operatorDefinition);
  var typeConfig = config2.types[fieldDefinition.type] || {};
  var fieldName = formatFieldName(field, config2, meta);
  if (value.size < cardinality) return void 0;
  if (meta.usedFields.indexOf(field) == -1) meta.usedFields.push(field);
  value = value.toArray();
  valueSrc = valueSrc.toArray();
  valueType = ((_valueType = valueType) === null || _valueType === void 0 ? void 0 : _valueType.toArray()) || [];
  var values2 = [];
  for (var i2 = 0; i2 < value.length; i2++) {
    var val = {
      type: valueType[i2],
      value: value[i2]
    };
    values2.push(val);
    if (valueSrc[i2] == "field") {
      var secondField = value[i2];
      if (meta.usedFields.indexOf(secondField) == -1) meta.usedFields.push(secondField);
    }
  }
  var operatorOptions = options ? options.toJS() : null;
  if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;
  var ruleQuery = {
    id: id2,
    fieldName,
    type: fieldType,
    input: typeConfig.mainWidget,
    operator
  };
  if (operatorOptions) ruleQuery.operatorOptions = operatorOptions;
  ruleQuery.values = values2;
  return ruleQuery;
};
function ownKeys$q(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$q(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$q(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$q(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _createForOfIteratorHelper$6(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null) it["return"]();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$6(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$6(o, minLen);
}
function _arrayLikeToArray$6(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
var jsonLogicFormat = function jsonLogicFormat2(item, config2) {
  var meta = {
    usedFields: [],
    errors: []
  };
  var extendedConfig = extendConfig(config2, void 0, false);
  var logic2 = formatItem$2(item, extendedConfig, meta, false, true);
  var errors = meta.errors, usedFields = meta.usedFields;
  extendedConfig.settings.fieldSeparator;
  var data = {};
  var _iterator = _createForOfIteratorHelper$6(usedFields), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var ff = _step.value;
      var parts = getFieldParts$3(ff, config2);
      var def = getFieldConfig$8(extendedConfig, ff) || {};
      var tmp = data;
      for (var i2 = 0; i2 < parts.length; i2++) {
        var p = parts[i2];
        var pdef = getFieldConfig$8(extendedConfig, parts.slice(0, i2 + 1)) || {};
        if (i2 != parts.length - 1) {
          if (pdef.type == "!group" && pdef.mode != "struct") {
            if (!tmp[p]) tmp[p] = [{}];
            tmp = tmp[p][0];
          } else {
            if (!tmp[p]) tmp[p] = {};
            tmp = tmp[p];
          }
        } else {
          if (!tmp[p]) tmp[p] = null;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return {
    errors,
    logic: logic2,
    data
  };
};
var formatItem$2 = function formatItem4(item, config2, meta) {
  var _not = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var isRoot = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var parentField = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
  if (!item) return void 0;
  var type2 = item.get("type");
  var properties = item.get("properties") || new Map$2();
  var isLocked = properties.get("isLocked");
  var lockedOp = config2.settings.jsonLogic.lockedOp;
  var ret;
  if (type2 === "group" || type2 === "rule_group") {
    ret = formatGroup$2(item, config2, meta, _not, isRoot, parentField);
  } else if (type2 === "rule") {
    ret = formatRule$2(item, config2, meta, _not, parentField);
  } else if (type2 == "switch_group") {
    ret = formatSwitch2(item, config2, meta, _not);
  } else if (type2 == "case_group") {
    ret = formatCase2(item, config2, meta, _not, parentField);
  }
  if (isLocked && ret && lockedOp) {
    ret = _defineProperty$4({}, lockedOp, ret);
  }
  return ret;
};
var formatGroup$2 = function formatGroup4(item, config2, meta) {
  var _groupOperatorDef, _groupOperatorDef2, _groupOperatorDef3, _reversedGroupOpDef, _reversedGroupOpDef2, _getOneChildOrDescend;
  var _not = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var isRoot = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var parentField = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
  var type2 = item.get("type");
  var properties = item.get("properties") || new Map$2();
  var mode = properties.get("mode");
  var children = item.get("children1") || new List();
  var field = properties.get("field");
  var fieldDefinition = getFieldConfig$8(config2, field);
  var conjunction = properties.get("conjunction");
  if (!conjunction) conjunction = defaultConjunction(config2);
  var conjunctionDefinition = config2.conjunctions[conjunction];
  var conj = conjunctionDefinition.jsonLogicConj || conjunction.toLowerCase();
  var origNot = !!properties.get("not");
  var isRuleGroup = type2 === "rule_group" && !isRoot;
  var isRuleGroupArray = isRuleGroup && mode != "struct";
  var groupField = isRuleGroupArray ? field : parentField;
  var groupOperator = properties.get("operator");
  var groupOperatorDef = groupOperator && getOperatorConfig$4(config2, groupOperator, field) || null;
  var formattedValue = formatItemValue3(config2, properties, meta, groupOperator, parentField);
  var isGroup0 = isRuleGroup && (!groupOperator || ((_groupOperatorDef = groupOperatorDef) === null || _groupOperatorDef === void 0 ? void 0 : _groupOperatorDef.cardinality) == 0);
  var isRuleGroupWithChildren = isRuleGroup && (children === null || children === void 0 ? void 0 : children.size) > 0;
  isRuleGroup && !(children !== null && children !== void 0 && children.size);
  var not2 = origNot;
  var filterNot2 = false;
  if (isRuleGroupWithChildren) {
    filterNot2 = origNot;
    not2 = _not;
  } else {
    if (_not) {
      not2 = !not2;
    }
  }
  var revChildren = false;
  var reversedGroupOp = (_groupOperatorDef2 = groupOperatorDef) === null || _groupOperatorDef2 === void 0 ? void 0 : _groupOperatorDef2.reversedOp;
  var reversedGroupOpDef = getOperatorConfig$4(config2, reversedGroupOp, field);
  var groupOpNeedsReverse = !((_groupOperatorDef3 = groupOperatorDef) !== null && _groupOperatorDef3 !== void 0 && _groupOperatorDef3.jsonLogic) && !!((_reversedGroupOpDef = reversedGroupOpDef) !== null && _reversedGroupOpDef !== void 0 && _reversedGroupOpDef.jsonLogic);
  var groupOpCanReverse = !!((_reversedGroupOpDef2 = reversedGroupOpDef) !== null && _reversedGroupOpDef2 !== void 0 && _reversedGroupOpDef2.jsonLogic);
  var oneChildType = (_getOneChildOrDescend = getOneChildOrDescendant(item)) === null || _getOneChildOrDescend === void 0 ? void 0 : _getOneChildOrDescend.get("type");
  var canRevChildren = !!config2.settings.reverseOperatorsForNot && (!isRuleGroup && not2 && oneChildType === "rule" || filterNot2 && (children === null || children === void 0 ? void 0 : children.size) === 1);
  if (canRevChildren) {
    if (isRuleGroupWithChildren) {
      filterNot2 = !filterNot2;
    } else {
      not2 = !not2;
    }
    revChildren = true;
  }
  var canRevGroupOp = not2 && isRuleGroup && groupOpCanReverse && (!!config2.settings.reverseOperatorsForNot || groupOpNeedsReverse);
  if (canRevGroupOp) {
    not2 = !not2;
    var _ref = [reversedGroupOp, groupOperator];
    groupOperator = _ref[0];
    reversedGroupOp = _ref[1];
    var _ref2 = [reversedGroupOpDef, groupOperatorDef];
    groupOperatorDef = _ref2[0];
    reversedGroupOpDef = _ref2[1];
  }
  var list2 = children.map(function(currentChild) {
    return formatItem$2(currentChild, config2, meta, revChildren, false, groupField);
  }).filter(function(currentChild) {
    return typeof currentChild !== "undefined";
  });
  var shouldPreserveGroups = !!config2.settings.exportPreserveGroups;
  if (isRuleGroupArray && !isGroup0) {
    if (formattedValue == void 0) return void 0;
  } else {
    if (!list2.size && !shouldPreserveGroups) return void 0;
  }
  var preserveSingleRuleGroup = isRoot || shouldPreserveGroups || list2.size != 1;
  if (!preserveSingleRuleGroup && origNot && !revChildren) {
    preserveSingleRuleGroup = children.some(function(currentChild) {
      var _currentChild$get, _config$operators, _config$operators$rev, _config$operators2;
      var op3 = (_currentChild$get = currentChild.get("properties")) === null || _currentChild$get === void 0 ? void 0 : _currentChild$get.get("operator");
      var revOp = (_config$operators = config2["operators"]) === null || _config$operators === void 0 || (_config$operators = _config$operators[op3]) === null || _config$operators === void 0 ? void 0 : _config$operators.reversedOp;
      return (_config$operators$rev = (_config$operators2 = config2.operators) === null || _config$operators2 === void 0 || (_config$operators2 = _config$operators2[revOp]) === null || _config$operators2 === void 0 ? void 0 : _config$operators2._jsonLogicIsExclamationOp) !== null && _config$operators$rev !== void 0 ? _config$operators$rev : false;
    });
  }
  var resultQuery = {};
  if (preserveSingleRuleGroup) resultQuery[conj] = list2.toList().toJS();
  else resultQuery = list2.first();
  if (filterNot2) {
    resultQuery = {
      "!": resultQuery
    };
  }
  if (isRuleGroupArray) {
    var formattedField = formatField$1(meta, config2, field, parentField);
    if (isGroup0) {
      var op2 = groupOperator || "some";
      resultQuery = _defineProperty$4({}, op2, [formattedField, resultQuery]);
    } else {
      var filter4 = !list2.size ? formattedField : {
        "filter": [formattedField, resultQuery]
      };
      var count2 = {
        "reduce": [filter4, {
          "+": [1, {
            "var": "accumulator"
          }]
        }, 0]
      };
      resultQuery = formatLogic(config2, properties, count2, formattedValue, groupOperator, null, fieldDefinition);
    }
  }
  if (not2) {
    resultQuery = {
      "!": resultQuery
    };
  }
  return resultQuery;
};
var formatRule$2 = function formatRule4(item, config2, meta) {
  var _operatorDefinition, _operatorDefinition2, _revOperatorDefinitio, _operatorDefinition3, _revOperatorDefinitio2, _revOperatorDefinitio3;
  var _not = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var parentField = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var properties = item.get("properties") || new Map$2();
  var field = properties.get("field");
  var fieldSrc = properties.get("fieldSrc");
  var operator = properties.get("operator");
  var operatorOptions = properties.get("operatorOptions");
  operatorOptions = operatorOptions ? operatorOptions.toJS() : null;
  if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;
  if (field == null || operator == null) return void 0;
  var fieldDefinition = getFieldConfig$8(config2, field);
  var operatorDefinition = getOperatorConfig$4(config2, operator, field);
  var reversedOp = (_operatorDefinition = operatorDefinition) === null || _operatorDefinition === void 0 ? void 0 : _operatorDefinition.reversedOp;
  var revOperatorDefinition = getOperatorConfig$4(config2, reversedOp, field);
  if (!((_operatorDefinition2 = operatorDefinition) !== null && _operatorDefinition2 !== void 0 && _operatorDefinition2.jsonLogic) && !((_revOperatorDefinitio = revOperatorDefinition) !== null && _revOperatorDefinitio !== void 0 && _revOperatorDefinitio.jsonLogic)) {
    meta.errors.push("Operator ".concat(operator, " is not supported"));
    return void 0;
  }
  var not2 = _not;
  var opNeedsReverse = !((_operatorDefinition3 = operatorDefinition) !== null && _operatorDefinition3 !== void 0 && _operatorDefinition3.jsonLogic) && !!((_revOperatorDefinitio2 = revOperatorDefinition) !== null && _revOperatorDefinitio2 !== void 0 && _revOperatorDefinitio2.jsonLogic);
  var opCanReverse = !!((_revOperatorDefinitio3 = revOperatorDefinition) !== null && _revOperatorDefinitio3 !== void 0 && _revOperatorDefinitio3.jsonLogic);
  var canRev = opCanReverse && (!!config2.settings.reverseOperatorsForNot || opNeedsReverse);
  var needRev = not2 && canRev || opNeedsReverse;
  if (needRev) {
    not2 = !not2;
    var _ref3 = [reversedOp, operator];
    operator = _ref3[0];
    reversedOp = _ref3[1];
    var _ref4 = [revOperatorDefinition, operatorDefinition];
    operatorDefinition = _ref4[0];
    revOperatorDefinition = _ref4[1];
  }
  var formattedValue = formatItemValue3(config2, properties, meta, operator, parentField);
  if (formattedValue === void 0) return void 0;
  var formattedField = fieldSrc === "func" ? formatFunc$2(meta, config2, field, parentField) : formatField$1(meta, config2, field, parentField);
  if (formattedField === void 0) return void 0;
  return formatLogic(config2, properties, formattedField, formattedValue, operator, operatorOptions, fieldDefinition, not2);
};
var formatSwitch2 = function formatSwitch3(item, config2, meta) {
  var _not = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var children = item.get("children1");
  if (!children) return void 0;
  var cases = children.map(function(currentChild) {
    return formatCase2(currentChild, config2, meta, _not, null);
  }).filter(function(currentChild) {
    return typeof currentChild !== "undefined";
  }).valueSeq().toArray();
  var filteredCases = [];
  for (var i2 = 0; i2 < cases.length; i2++) {
    if (i2 !== cases.length - 1 && !cases[i2][0]) {
      meta.errors.push("No condition for case ".concat(i2));
    } else {
      filteredCases.push(cases[i2]);
      if (i2 === cases.length - 1 && cases[i2][0]) {
        filteredCases.push([void 0, null]);
      }
    }
  }
  if (!filteredCases.length) return void 0;
  if (filteredCases.length === 1) {
    var _filteredCases$ = _slicedToArray$1(filteredCases[0], 2);
    _filteredCases$[0];
    var _defVal = _filteredCases$[1];
    if (_defVal == void 0) _defVal = null;
    return _defVal;
  }
  var ret = {
    "if": []
  };
  var ifArgs = ret["if"];
  var _filteredCases = _slicedToArray$1(filteredCases[filteredCases.length - 1], 2);
  _filteredCases[0];
  var defVal = _filteredCases[1];
  for (var _i = 0; _i < filteredCases.length - 1; _i++) {
    var isLastIf = _i === filteredCases.length - 2;
    var _filteredCases$_i = _slicedToArray$1(filteredCases[_i], 2), cond = _filteredCases$_i[0], value = _filteredCases$_i[1];
    if (value == void 0) value = null;
    if (cond == void 0) cond = true;
    ifArgs.push(cond);
    ifArgs.push(value);
    if (isLastIf) {
      ifArgs.push(defVal);
    } else {
      ifArgs.push({
        "if": []
      });
      ifArgs = ifArgs[ifArgs.length - 1]["if"];
    }
  }
  return ret;
};
var formatCase2 = function formatCase3(item, config2, meta) {
  var _not = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var parentField = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var type2 = item.get("type");
  if (type2 != "case_group") {
    meta.errors.push("Unexpected child of type ".concat(type2, " inside switch"));
    return void 0;
  }
  var properties = item.get("properties") || new Map$2();
  var cond = formatGroup$2(item, config2, meta, _not, parentField);
  var formattedItem = formatItemValue3(config2, properties, meta, null, parentField, "!case_value");
  return [cond, formattedItem];
};
var formatItemValue3 = function formatItemValue4(config2, properties, meta, operator, parentField) {
  var expectedValueType = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
  var field = properties.get("field");
  var iValueSrc = properties.get("valueSrc");
  var iValueType = properties.get("valueType");
  if (expectedValueType == "!case_value" || iValueType && iValueType.get(0) == "case_value") {
    field = "!case_value";
  }
  var fieldDefinition = getFieldConfig$8(config2, field);
  var operatorDefinition = getOperatorConfig$4(config2, operator, field);
  var cardinality = getOpCardinality$1(operatorDefinition);
  var iValue = properties.get("value");
  var asyncListValues = properties.get("asyncListValues");
  if (iValue == void 0) return void 0;
  var oldUsedFields = meta.usedFields;
  var fvalue = iValue.map(function(currentValue, ind) {
    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
    var valueType = iValueType ? iValueType.get(ind) : null;
    var cValue = completeValue(currentValue, valueSrc, config2);
    var widget = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
    var fieldWidgetDef = getFieldWidgetConfig$3(config2, field, operator, widget, valueSrc, {
      forExport: true
    });
    var fv = formatValue$2(meta, config2, cValue, valueSrc, valueType, fieldWidgetDef, fieldDefinition, operator, operatorDefinition, parentField, asyncListValues);
    return fv;
  });
  var hasUndefinedValues = fvalue.filter(function(v) {
    return v === void 0;
  }).size > 0;
  if (fvalue.size < cardinality || hasUndefinedValues) {
    meta.usedFields = oldUsedFields;
    return void 0;
  }
  return cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;
};
var formatValue$2 = function formatValue3(meta, config2, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {
  var parentField = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : null;
  var asyncListValues = arguments.length > 10 ? arguments[10] : void 0;
  if (currentValue === void 0) return void 0;
  var ret;
  if (valueSrc == "field") {
    ret = formatField$1(meta, config2, currentValue, parentField);
  } else if (valueSrc == "func") {
    ret = formatFunc$2(meta, config2, currentValue, parentField);
  } else if (typeof (fieldWidgetDef === null || fieldWidgetDef === void 0 ? void 0 : fieldWidgetDef.jsonLogic) === "function") {
    var fn = fieldWidgetDef.jsonLogic;
    var args = [
      currentValue,
      _objectSpread$q(_objectSpread$q({}, fieldDef ? pick$1(fieldDef, ["fieldSettings", "listValues"]) : {}), {}, {
        asyncListValues
      }),
      //useful options: valueFormat for date/time
      omit$2(fieldWidgetDef, widgetDefKeysToOmit)
    ];
    if (operator) {
      args.push(operator);
      args.push(operatorDef);
    }
    ret = fn.call.apply(fn, [config2.ctx].concat(args));
  } else {
    ret = currentValue;
  }
  return ret;
};
var formatFunc$2 = function formatFunc3(meta, config2, currentValue) {
  var _currentValue$get, _currentValue$get2;
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var funcKey = (_currentValue$get = currentValue.get) === null || _currentValue$get === void 0 ? void 0 : _currentValue$get.call(currentValue, "func");
  var args = (_currentValue$get2 = currentValue.get) === null || _currentValue$get2 === void 0 ? void 0 : _currentValue$get2.call(currentValue, "args");
  var funcConfig = getFuncConfig$2(config2, funcKey);
  var funcParts = getFieldParts$3(funcKey, config2);
  var funcLastKey = funcParts[funcParts.length - 1];
  if (!funcConfig) {
    meta.errors.push("Func ".concat(funcKey, " is not defined in config"));
    return void 0;
  }
  if (!(funcConfig !== null && funcConfig !== void 0 && funcConfig.jsonLogic)) {
    meta.errors.push("Func ".concat(funcKey, " is not supported"));
    return void 0;
  }
  var formattedArgs = {};
  var gaps = [];
  var missingArgKeys = [];
  for (var argKey in funcConfig.args) {
    var _argValue;
    var argConfig = funcConfig.args[argKey];
    var fieldDef = getFieldConfig$8(config2, argConfig);
    var defaultValue = argConfig.defaultValue, isOptional = argConfig.isOptional;
    var defaultValueSrc = defaultValue !== null && defaultValue !== void 0 && defaultValue.func ? "func" : "value";
    var argVal = args ? args.get(argKey) : void 0;
    var argValue = argVal ? argVal.get("value") : void 0;
    var argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
    if (argValueSrc !== "func" && (_argValue = argValue) !== null && _argValue !== void 0 && _argValue.toJS) {
      argValue = argValue.toJS();
    }
    var operator = null;
    var widget = getWidgetForFieldOp$3(config2, argConfig, operator, argValueSrc);
    var fieldWidgetDef = getFieldWidgetConfig$3(config2, argConfig, operator, widget, argValueSrc, {
      forExport: true
    });
    var formattedArgVal = formatValue$2(meta, config2, argValue, argValueSrc, argConfig.type, fieldWidgetDef, fieldDef, null, null, parentField);
    if (argValue != void 0 && formattedArgVal === void 0) {
      if (argValueSrc != "func")
        meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
      return void 0;
    }
    var formattedDefaultVal = void 0;
    if (formattedArgVal === void 0 && !isOptional && defaultValue != void 0) {
      var defaultWidget = getWidgetForFieldOp$3(config2, argConfig, operator, defaultValueSrc);
      var defaultFieldWidgetDef = getFieldWidgetConfig$3(config2, argConfig, operator, defaultWidget, defaultValueSrc, {
        forExport: true
      });
      formattedDefaultVal = formatValue$2(meta, config2, defaultValue, defaultValueSrc, argConfig.type, defaultFieldWidgetDef, fieldDef, null, null, parentField);
      if (formattedDefaultVal === void 0) {
        if (defaultValueSrc != "func")
          meta.errors.push("Can't format default value of arg ".concat(argKey, " for func ").concat(funcKey));
        return void 0;
      }
    }
    var finalFormattedVal = formattedArgVal !== null && formattedArgVal !== void 0 ? formattedArgVal : formattedDefaultVal;
    if (finalFormattedVal !== void 0) {
      if (gaps.length) {
        var _iterator2 = _createForOfIteratorHelper$6(gaps), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var missedArgKey = _step2.value;
            formattedArgs[missedArgKey] = void 0;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        gaps = [];
      }
      formattedArgs[argKey] = finalFormattedVal;
    } else {
      if (!isOptional) missingArgKeys.push(argKey);
      gaps.push(argKey);
    }
  }
  if (missingArgKeys.length) {
    return void 0;
  }
  var formattedArgsArr = Object.values(formattedArgs);
  var ret;
  if (typeof funcConfig.jsonLogic === "function") {
    var fn = funcConfig.jsonLogic;
    var _args = [formattedArgs];
    ret = fn.call.apply(fn, [config2.ctx].concat(_args));
  } else {
    var funcName = funcConfig.jsonLogic || funcLastKey;
    var isMethod = !!funcConfig.jsonLogicIsMethod;
    if (isMethod) {
      var obj = formattedArgsArr[0], params = formattedArgsArr.slice(1);
      if (params.length) {
        ret = {
          "method": [obj, funcName, params]
        };
      } else {
        ret = {
          "method": [obj, funcName]
        };
      }
    } else {
      ret = _defineProperty$4({}, funcName, formattedArgsArr);
    }
  }
  return ret;
};
var formatField$1 = function formatField4(meta, config2, field) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var _config$settings = config2.settings, fieldSeparator = _config$settings.fieldSeparator, jsonLogic15 = _config$settings.jsonLogic;
  var ret;
  if (field) {
    if (Array.isArray(field)) field = field.join(fieldSeparator);
    var fieldDef = getFieldConfig$8(config2, field) || {};
    var fieldName = formatFieldName(field, config2, meta, parentField);
    var varName = fieldDef.jsonLogicVar || (fieldDef.type == "!group" ? jsonLogic15.groupVarKey : "var");
    ret = _defineProperty$4({}, varName, fieldName);
    if (meta.usedFields.indexOf(field) == -1) meta.usedFields.push(field);
  }
  return ret;
};
var buildFnToFormatOp$1 = function buildFnToFormatOp3(operator, operatorDefinition, formattedField, formattedValue) {
  var formatteOp = operator;
  var cardinality = getOpCardinality$1(operatorDefinition);
  if (typeof operatorDefinition.jsonLogic == "string") formatteOp = operatorDefinition.jsonLogic;
  var rangeOps = ["<", "<=", ">", ">="];
  var eqOps = ["==", "!="];
  var fn = function fn2(field, op2, val, opDef, opOpts) {
    if (cardinality == 0 && eqOps.includes(formatteOp)) return _defineProperty$4({}, formatteOp, [formattedField, null]);
    else if (cardinality == 0) return _defineProperty$4({}, formatteOp, formattedField);
    else if (cardinality == 1) return _defineProperty$4({}, formatteOp, [formattedField, formattedValue]);
    else if (cardinality == 2 && rangeOps.includes(formatteOp)) return _defineProperty$4({}, formatteOp, [formattedValue[0], formattedField, formattedValue[1]]);
    else return _defineProperty$4({}, formatteOp, [formattedField].concat(_toConsumableArray(formattedValue)));
  };
  return fn;
};
var formatLogic = function formatLogic2(config2, properties, formattedField, formattedValue, operator) {
  var operatorOptions = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
  var fieldDefinition = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  var isRev = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
  var field = properties.get("field");
  var operatorDefinition = getOperatorConfig$4(config2, operator, field) || {};
  var fn = typeof operatorDefinition.jsonLogic == "function" ? operatorDefinition.jsonLogic : buildFnToFormatOp$1(operator, operatorDefinition, formattedField, formattedValue);
  var args = [formattedField, operator, formattedValue, omit$2(operatorDefinition, opDefKeysToOmit), operatorOptions, fieldDefinition];
  var ruleQuery = fn.call.apply(fn, [config2.ctx].concat(args));
  if (isRev) {
    ruleQuery = {
      "!": ruleQuery
    };
  }
  return ruleQuery;
};
function _createForOfIteratorHelper$5(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null) it["return"]();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$5(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$5(o, minLen);
}
function _arrayLikeToArray$5(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function ownKeys$p(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$p(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$p(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$p(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var isObject$4 = function isObject6(v) {
  return _typeof$3(v) == "object" && v !== null && !Array.isArray(v);
};
var mongodbFormat = function mongodbFormat2(tree2, config2) {
  return _mongodbFormat(tree2, config2, false);
};
var _mongodbFormat = function _mongodbFormat2(tree2, config2) {
  var returnErrors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var meta = {
    errors: []
  };
  var extendedConfig = extendConfig(config2, void 0, false);
  var res = formatItem$1([], tree2, extendedConfig, meta);
  if (returnErrors) {
    return [res, meta.errors];
  } else {
    if (meta.errors.length) console.warn("Errors while exporting to MongoDb:", meta.errors);
    return res;
  }
};
var formatItem$1 = function formatItem5(parents2, item, config2, meta) {
  var _not = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var _canWrapExpr = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
  var _formatFieldName = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : void 0;
  var _value = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : void 0;
  if (!item) return void 0;
  var type2 = item.get("type");
  if (type2 === "group" || type2 === "rule_group") {
    return formatGroup$1(parents2, item, config2, meta, _not, _canWrapExpr, _formatFieldName, _value);
  } else if (type2 === "rule") {
    return formatRule$1(parents2, item, config2, meta, _not, _canWrapExpr, _formatFieldName, _value);
  }
  return void 0;
};
var formatGroup$1 = function formatGroup5(parents2, item, config2, meta) {
  var _groupOperatorDef$car, _groupOperatorDef, _groupOperatorDef2, _groupOperatorDef3, _reversedGroupOpDef, _reversedGroupOpDef2, _getOneChildOrDescend, _conjunction;
  var _not = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var type2 = item.get("type");
  var properties = item.get("properties") || new Map$2();
  var origNot = !!properties.get("not");
  var children = item.get("children1") || new List();
  var _config$settings = config2.settings, canShortMongoQuery = _config$settings.canShortMongoQuery, fieldSeparator = _config$settings.fieldSeparator;
  var sep = fieldSeparator;
  var hasParentRuleGroup = parents2.filter(function(it) {
    return it.get("type") == "rule_group";
  }).length > 0;
  var parentPath = parents2.filter(function(it) {
    return it.get("type") == "rule_group";
  }).map(function(it) {
    return it.get("properties").get("field");
  }).slice(-1).pop();
  var realParentPath = hasParentRuleGroup && parentPath;
  var isRuleGroup = type2 === "rule_group";
  var groupField = isRuleGroup ? properties.get("field") : null;
  var groupOperator = isRuleGroup ? properties.get("operator") : null;
  var groupOperatorDef = groupOperator && getOperatorConfig$4(config2, groupOperator, groupField) || null;
  var groupOperatorCardinality = groupOperator ? (_groupOperatorDef$car = (_groupOperatorDef = groupOperatorDef) === null || _groupOperatorDef === void 0 ? void 0 : _groupOperatorDef.cardinality) !== null && _groupOperatorDef$car !== void 0 ? _groupOperatorDef$car : 1 : void 0;
  var groupFieldName = formatFieldName(groupField, config2, meta, realParentPath);
  var groupFieldDef = getFieldConfig$8(config2, groupField) || {};
  var mode = groupFieldDef.mode;
  var canHaveEmptyChildren = groupField && mode === "array" && groupOperatorCardinality >= 1;
  var isRuleGroupWithChildren = isRuleGroup && (children === null || children === void 0 ? void 0 : children.size) > 0;
  isRuleGroup && !(children !== null && children !== void 0 && children.size);
  var revChildren = false;
  var not2 = origNot;
  var filterNot2 = false;
  if (isRuleGroupWithChildren) {
    filterNot2 = origNot;
    not2 = _not;
  } else {
    if (_not) {
      not2 = !not2;
    }
  }
  var reversedGroupOp = (_groupOperatorDef2 = groupOperatorDef) === null || _groupOperatorDef2 === void 0 ? void 0 : _groupOperatorDef2.reversedOp;
  var reversedGroupOpDef = getOperatorConfig$4(config2, reversedGroupOp, groupField);
  var groupOpNeedsReverse = !((_groupOperatorDef3 = groupOperatorDef) !== null && _groupOperatorDef3 !== void 0 && _groupOperatorDef3.mongoFormatOp) && !!((_reversedGroupOpDef = reversedGroupOpDef) !== null && _reversedGroupOpDef !== void 0 && _reversedGroupOpDef.mongoFormatOp);
  var groupOpCanReverse = !!((_reversedGroupOpDef2 = reversedGroupOpDef) !== null && _reversedGroupOpDef2 !== void 0 && _reversedGroupOpDef2.mongoFormatOp);
  var oneChildType = (_getOneChildOrDescend = getOneChildOrDescendant(item)) === null || _getOneChildOrDescend === void 0 ? void 0 : _getOneChildOrDescend.get("type");
  var canRevChildren = !!config2.settings.reverseOperatorsForNot && (!isRuleGroup && not2 && oneChildType === "rule" || filterNot2 && (children === null || children === void 0 ? void 0 : children.size) === 1);
  if (canRevChildren) {
    if (isRuleGroupWithChildren) {
      filterNot2 = !filterNot2;
    } else {
      not2 = !not2;
    }
    revChildren = true;
  }
  var canRevGroupOp = not2 && isRuleGroup && groupOpCanReverse && (!!config2.settings.reverseOperatorsForNot || groupOpNeedsReverse);
  if (canRevGroupOp) {
    not2 = !not2;
    var _ref = [reversedGroupOp, groupOperator];
    groupOperator = _ref[0];
    reversedGroupOp = _ref[1];
    var _ref2 = [reversedGroupOpDef, groupOperatorDef];
    groupOperatorDef = _ref2[0];
    reversedGroupOpDef = _ref2[1];
  }
  var conjunction = properties.get("conjunction");
  if (!conjunction) conjunction = defaultConjunction(config2);
  var conjunctionDefinition = config2.conjunctions[conjunction];
  if (!conjunctionDefinition) return void 0;
  var reversedConj = conjunctionDefinition.reversedConj;
  var canRev = not2 && ((_conjunction = conjunction) === null || _conjunction === void 0 ? void 0 : _conjunction.toLowerCase()) === "or" && reversedConj && !isRuleGroup && !!config2.settings.canShortMongoQuery && !!config2.settings.reverseOperatorsForNot;
  if (canRev) {
    conjunction = reversedConj;
    conjunctionDefinition = config2.conjunctions[conjunction];
    not2 = !not2;
    revChildren = true;
  }
  var mongoConj = conjunctionDefinition.mongoConj;
  var list2 = children.map(function(currentChild) {
    return formatItem$1([].concat(_toConsumableArray(parents2), [item]), currentChild, config2, meta, revChildren, mode != "array", mode == "array" ? function(f) {
      return "$$el".concat(sep).concat(f);
    } : void 0);
  }).filter(function(formattedChild) {
    return typeof formattedChild !== "undefined";
  });
  if (!canHaveEmptyChildren && !list2.size) {
    return void 0;
  }
  var resultQuery;
  if (list2.size == 1) {
    resultQuery = list2.first();
  } else if (list2.size > 1) {
    var rules = list2.toList().toJS();
    var canShort = canShortMongoQuery && mongoConj == "$and";
    if (canShort) {
      resultQuery = rules.reduce(function(acc, rule3) {
        if (!acc) return void 0;
        for (var k in rule3) {
          if (k[0] == "$") {
            acc = void 0;
            break;
          }
          if (acc[k] == void 0) {
            acc[k] = rule3[k];
          } else {
            var prev = acc[k], next = rule3[k];
            if (!isObject$4(prev)) {
              prev = {
                "$eq": prev
              };
            }
            if (!isObject$4(next)) {
              next = {
                "$eq": next
              };
            }
            var prevOp = Object.keys(prev)[0], nextOp = Object.keys(next)[0];
            if (prevOp == nextOp) {
              acc = void 0;
              break;
            }
            acc[k] = Object.assign({}, prev, next);
          }
        }
        return acc;
      }, {});
    }
    if (!resultQuery) {
      resultQuery = _defineProperty$4({}, mongoConj, rules);
    }
  }
  if (groupField) {
    if (mode == "array") {
      var totalQuery = {
        "$size": {
          "$ifNull": ["$" + groupFieldName, []]
        }
      };
      var filterQuery = resultQuery ? {
        "$size": {
          "$ifNull": [{
            "$filter": {
              input: "$" + groupFieldName,
              as: "el",
              cond: resultQuery
            }
          }, []]
        }
      } : totalQuery;
      resultQuery = formatItem$1(parents2, item.set("type", "rule"), config2, meta, filterNot2, false, function(_f) {
        return filterQuery;
      }, totalQuery);
      resultQuery = {
        "$expr": resultQuery
      };
    } else {
      resultQuery = _defineProperty$4({}, groupFieldName, {
        "$elemMatch": resultQuery
      });
    }
  }
  if (not2) {
    resultQuery = {
      "$not": resultQuery
    };
  }
  return resultQuery;
};
var formatRule$1 = function formatRule5(parents2, item, config2, meta) {
  var _operatorDefinition, _operatorDefinition2, _revOperatorDefinitio, _operatorDefinition3, _revOperatorDefinitio2, _revOperatorDefinitio3, _operatorDefinition4;
  var _not = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var _canWrapExpr = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
  var _formatFieldName = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : void 0;
  var _value = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : void 0;
  var properties = item.get("properties") || new Map$2();
  var hasParentRuleGroup = parents2.filter(function(it) {
    return it.get("type") == "rule_group";
  }).length > 0;
  var parentPath = parents2.filter(function(it) {
    return it.get("type") == "rule_group";
  }).map(function(it) {
    return it.get("properties").get("field");
  }).slice(-1).pop();
  var realParentPath = hasParentRuleGroup && parentPath;
  var operator = properties.get("operator");
  var operatorOptions = properties.get("operatorOptions");
  var field = properties.get("field");
  var fieldSrc = properties.get("fieldSrc");
  var iValue = properties.get("value");
  var iValueSrc = properties.get("valueSrc");
  var iValueType = properties.get("valueType");
  var asyncListValues = properties.get("asyncListValues");
  if (field == null || operator == null || iValue === void 0) return void 0;
  var fieldDef = getFieldConfig$8(config2, field);
  var operatorDefinition = getOperatorConfig$4(config2, operator, field);
  var reversedOp = (_operatorDefinition = operatorDefinition) === null || _operatorDefinition === void 0 ? void 0 : _operatorDefinition.reversedOp;
  var revOperatorDefinition = getOperatorConfig$4(config2, reversedOp, field);
  var cardinality = getOpCardinality$1(operatorDefinition);
  if (!((_operatorDefinition2 = operatorDefinition) !== null && _operatorDefinition2 !== void 0 && _operatorDefinition2.mongoFormatOp) && !((_revOperatorDefinitio = revOperatorDefinition) !== null && _revOperatorDefinitio !== void 0 && _revOperatorDefinitio.mongoFormatOp)) {
    meta.errors.push("Operator ".concat(operator, " is not supported"));
    return void 0;
  }
  var not2 = _not;
  var opNeedsReverse = !((_operatorDefinition3 = operatorDefinition) !== null && _operatorDefinition3 !== void 0 && _operatorDefinition3.mongoFormatOp) && !!((_revOperatorDefinitio2 = revOperatorDefinition) !== null && _revOperatorDefinitio2 !== void 0 && _revOperatorDefinitio2.mongoFormatOp);
  var opCanReverse = !!((_revOperatorDefinitio3 = revOperatorDefinition) !== null && _revOperatorDefinitio3 !== void 0 && _revOperatorDefinitio3.mongoFormatOp);
  var canRev = opCanReverse && (!!config2.settings.reverseOperatorsForNot || opNeedsReverse);
  var needRev = canRev && not2 || opNeedsReverse;
  if (needRev) {
    var _ref3 = [reversedOp, operator];
    operator = _ref3[0];
    reversedOp = _ref3[1];
    var _ref4 = [revOperatorDefinition, operatorDefinition];
    operatorDefinition = _ref4[0];
    revOperatorDefinition = _ref4[1];
    not2 = !not2;
  }
  var formattedField;
  var useExpr = false;
  if (fieldSrc == "func") {
    var _formatFunc = formatFunc$1(meta, config2, field, realParentPath);
    var _formatFunc2 = _slicedToArray$1(_formatFunc, 2);
    formattedField = _formatFunc2[0];
    useExpr = _formatFunc2[1];
  } else {
    formattedField = formatFieldName(field, config2, meta, realParentPath);
    if (_formatFieldName) {
      useExpr = true;
      formattedField = _formatFieldName(formattedField);
    }
  }
  if (formattedField == void 0) return void 0;
  var valueSrcs = [];
  var valueTypes = [];
  var formattedValue;
  if (iValue != void 0) {
    var fvalue = iValue.map(function(currentValue, ind) {
      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
      var valueType = iValueType ? iValueType.get(ind) : null;
      var cValue = completeValue(currentValue, valueSrc, config2);
      var widget = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
      var fieldWidgetDef = getFieldWidgetConfig$3(config2, field, operator, widget, valueSrc, {
        forExport: true
      });
      var _formatValue = formatValue$1(meta, config2, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, realParentPath, operator, operatorDefinition, asyncListValues), _formatValue2 = _slicedToArray$1(_formatValue, 2), fv = _formatValue2[0], fvUseExpr = _formatValue2[1];
      if (fv !== void 0) {
        useExpr = useExpr || fvUseExpr;
        valueSrcs.push(valueSrc);
        valueTypes.push(valueType);
      }
      return fv;
    });
    var hasUndefinedValues = fvalue.filter(function(v) {
      return v === void 0;
    }).size > 0;
    if (fvalue.size < cardinality || hasUndefinedValues) return void 0;
    formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;
  }
  var wrapExpr = useExpr && _canWrapExpr;
  var fn = (_operatorDefinition4 = operatorDefinition) === null || _operatorDefinition4 === void 0 ? void 0 : _operatorDefinition4.mongoFormatOp;
  var args = [formattedField, operator, _value !== void 0 && formattedValue == null ? _value : formattedValue, useExpr, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], omit$2(operatorDefinition, opDefKeysToOmit), operatorOptions, fieldDef];
  var ruleQuery = fn.call.apply(fn, [config2.ctx].concat(args));
  if (wrapExpr) {
    ruleQuery = {
      "$expr": ruleQuery
    };
  }
  if (not2) {
    ruleQuery = {
      "$not": ruleQuery
    };
  }
  return ruleQuery;
};
var formatValue$1 = function formatValue4(meta, config2, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, parentPath, operator, operatorDef, asyncListValues) {
  if (currentValue === void 0) return [void 0, false];
  var ret;
  var useExpr = false;
  if (valueSrc == "field") {
    var _formatRightField = formatRightField(meta, config2, currentValue, parentPath);
    var _formatRightField2 = _slicedToArray$1(_formatRightField, 2);
    ret = _formatRightField2[0];
    useExpr = _formatRightField2[1];
  } else if (valueSrc == "func") {
    var _formatFunc3 = formatFunc$1(meta, config2, currentValue, parentPath);
    var _formatFunc4 = _slicedToArray$1(_formatFunc3, 2);
    ret = _formatFunc4[0];
    useExpr = _formatFunc4[1];
  } else {
    if (typeof (fieldWidgetDef === null || fieldWidgetDef === void 0 ? void 0 : fieldWidgetDef.mongoFormatValue) === "function") {
      var fn = fieldWidgetDef.mongoFormatValue;
      var args = [
        currentValue,
        _objectSpread$p(_objectSpread$p({}, fieldDef ? pick$1(fieldDef, ["fieldSettings", "listValues"]) : {}), {}, {
          asyncListValues
        }),
        //useful options: valueFormat for date/time
        omit$2(fieldWidgetDef, widgetDefKeysToOmit)
      ];
      if (operator) {
        args.push(operator);
        args.push(operatorDef);
      }
      ret = fn.call.apply(fn, [config2.ctx].concat(args));
    } else {
      ret = currentValue;
    }
  }
  return [ret, useExpr];
};
var formatRightField = function formatRightField2(meta, config2, rightField, parentPath) {
  var fieldSeparator = config2.settings.fieldSeparator;
  var ret;
  var useExpr = true;
  if (rightField) {
    var rightFieldDefinition = getFieldConfig$8(config2, rightField) || {};
    var fieldParts = getFieldParts$3(rightField, config2);
    var fieldPartsLabels = getFieldPathLabels$2(rightField, config2);
    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;
    var formatFieldFn = config2.settings.formatField;
    var rightFieldName = formatFieldName(rightField, config2, meta, parentPath);
    var formattedField = formatFieldFn(rightFieldName, fieldParts, fieldFullLabel, rightFieldDefinition, config2, false);
    ret = "$" + formattedField;
  }
  return [ret, useExpr];
};
var formatFunc$1 = function formatFunc4(meta, config2, currentValue, parentPath) {
  var _currentValue$get, _currentValue$get2;
  var useExpr = true;
  var ret;
  var funcKey = (_currentValue$get = currentValue.get) === null || _currentValue$get === void 0 ? void 0 : _currentValue$get.call(currentValue, "func");
  var args = (_currentValue$get2 = currentValue.get) === null || _currentValue$get2 === void 0 ? void 0 : _currentValue$get2.call(currentValue, "args");
  var funcConfig = getFuncConfig$2(config2, funcKey);
  if (!funcConfig) {
    meta.errors.push("Func ".concat(funcKey, " is not defined in config"));
    return [void 0, false];
  }
  var funcParts = getFieldParts$3(funcKey, config2);
  var funcLastKey = funcParts[funcParts.length - 1];
  var funcName = funcConfig.mongoFunc || funcLastKey;
  var mongoArgsAsObject = funcConfig.mongoArgsAsObject;
  var formattedArgs = {};
  var argsCnt = 0;
  var lastArg = void 0;
  var gaps = [];
  var missingArgKeys = [];
  for (var argKey in funcConfig.args) {
    var _argValue;
    argsCnt++;
    var argConfig = funcConfig.args[argKey];
    var fieldDef = getFieldConfig$8(config2, argConfig);
    var defaultValue = argConfig.defaultValue, isOptional = argConfig.isOptional;
    var defaultValueSrc = defaultValue !== null && defaultValue !== void 0 && defaultValue.func ? "func" : "value";
    var argVal = args ? args.get(argKey) : void 0;
    var argValue = argVal ? argVal.get("value") : void 0;
    var argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
    if (argValueSrc !== "func" && (_argValue = argValue) !== null && _argValue !== void 0 && _argValue.toJS) {
      argValue = argValue.toJS();
    }
    var argAsyncListValues = argVal ? argVal.get("asyncListValues") : void 0;
    var operator = null;
    var widget = getWidgetForFieldOp$3(config2, argConfig, operator, argValueSrc);
    var fieldWidgetDef = getFieldWidgetConfig$3(config2, argConfig, operator, widget, argValueSrc, {
      forExport: true
    });
    var _formatValue3 = formatValue$1(meta, config2, argValue, argValueSrc, argConfig.type, fieldWidgetDef, fieldDef, parentPath, null, null, argAsyncListValues), _formatValue4 = _slicedToArray$1(_formatValue3, 2), formattedArgVal = _formatValue4[0];
    _formatValue4[1];
    if (argValue != void 0 && formattedArgVal === void 0) {
      if (argValueSrc != "func")
        meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
      return [void 0, false];
    }
    var formattedDefaultVal = void 0;
    if (formattedArgVal === void 0 && !isOptional && defaultValue != void 0) {
      var defaultWidget = getWidgetForFieldOp$3(config2, argConfig, operator, defaultValueSrc);
      var defaultFieldWidgetDef = getFieldWidgetConfig$3(config2, argConfig, operator, defaultWidget, defaultValueSrc, {
        forExport: true
      });
      var _formatValue5 = formatValue$1(meta, config2, defaultValue, defaultValueSrc, argConfig.type, defaultFieldWidgetDef, fieldDef, parentPath, null, null, argAsyncListValues);
      var _formatValue6 = _slicedToArray$1(_formatValue5, 2);
      formattedDefaultVal = _formatValue6[0];
      _formatValue6[1];
      if (formattedDefaultVal === void 0) {
        if (defaultValueSrc != "func")
          meta.errors.push("Can't format default value of arg ".concat(argKey, " for func ").concat(funcKey));
        return [void 0, false];
      }
    }
    var finalFormattedVal = formattedArgVal !== null && formattedArgVal !== void 0 ? formattedArgVal : formattedDefaultVal;
    if (finalFormattedVal !== void 0) {
      if (gaps.length) {
        var _iterator = _createForOfIteratorHelper$5(gaps), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var missedArgKey = _step.value;
            formattedArgs[missedArgKey] = void 0;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        gaps = [];
      }
      formattedArgs[argKey] = finalFormattedVal;
      lastArg = finalFormattedVal;
    } else {
      if (!isOptional) missingArgKeys.push(argKey);
      gaps.push(argKey);
    }
  }
  if (missingArgKeys.length) {
    return [void 0, false];
  }
  if (typeof funcConfig.mongoFormatFunc === "function") {
    var fn = funcConfig.mongoFormatFunc;
    var _args = [formattedArgs];
    ret = fn.call.apply(fn, [config2.ctx].concat(_args));
  } else if (funcConfig.mongoFormatFunc === null) {
    meta.errors.push("Functon ".concat(funcName, " is not supported"));
    return [void 0, false];
  } else {
    if (mongoArgsAsObject) ret = _defineProperty$4({}, funcName, formattedArgs);
    else if (argsCnt == 1 && lastArg !== void 0) ret = _defineProperty$4({}, funcName, lastArg);
    else ret = _defineProperty$4({}, funcName, Object.values(formattedArgs));
  }
  return [ret, useExpr];
};
function _createForOfIteratorHelper$4(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null) it["return"]();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$4(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$4(o, minLen);
}
function _arrayLikeToArray$4(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function ownKeys$o(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$o(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$o(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$o(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var sqlFormat = function sqlFormat2(tree2, config2) {
  return _sqlFormat(tree2, config2, false);
};
var _sqlFormat = function _sqlFormat2(tree2, config2) {
  var returnErrors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var meta = {
    errors: []
  };
  var extendedConfig = extendConfig(config2, void 0, false);
  var res = formatItem6(tree2, extendedConfig, meta);
  if (returnErrors) {
    return [res, meta.errors];
  } else {
    if (meta.errors.length) console.warn("Errors while exporting to SQL:", meta.errors);
    return res;
  }
};
var formatItem6 = function formatItem7(item, config2, meta) {
  if (!item) return void 0;
  var type2 = item.get("type");
  item.get("children1");
  if (type2 === "group" || type2 === "rule_group") {
    return formatGroup6(item, config2, meta);
  } else if (type2 === "rule") {
    return formatRule6(item, config2, meta);
  }
  return void 0;
};
var formatGroup6 = function formatGroup7(item, config2, meta) {
  var type2 = item.get("type");
  var properties = item.get("properties") || new Map$2();
  var children = item.get("children1") || new List();
  var isRuleGroup = type2 === "rule_group";
  var groupField = isRuleGroup ? properties.get("field") : null;
  var groupFieldDef = getFieldConfig$8(config2, groupField) || {};
  var mode = groupFieldDef.mode;
  if (mode == "array") {
    meta.errors.push("Aggregation is not supported for ".concat(groupField));
  }
  var not2 = properties.get("not");
  var list2 = children.map(function(currentChild) {
    return formatItem6(currentChild, config2, meta);
  }).filter(function(currentChild) {
    return typeof currentChild !== "undefined";
  });
  if (!list2.size) return void 0;
  var conjunction = properties.get("conjunction");
  if (!conjunction) conjunction = defaultConjunction(config2);
  var conjunctionDefinition = config2.conjunctions[conjunction];
  return conjunctionDefinition.sqlFormatConj.call(config2.ctx, list2, conjunction, not2);
};
var buildFnToFormatOp4 = function buildFnToFormatOp5(operator, operatorDefinition) {
  var sqlOp = operatorDefinition.sqlOp || operator;
  var cardinality = getOpCardinality$1(operatorDefinition);
  var fn;
  if (cardinality == 0) {
    fn = function fn2(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      return "".concat(field, " ").concat(sqlOp);
    };
  } else if (cardinality == 1) {
    fn = function fn2(field, op2, value, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      return "".concat(field, " ").concat(sqlOp, " ").concat(value);
    };
  } else if (cardinality == 2) {
    fn = function fn2(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      var _values$first, _values$get;
      var valFrom = values2 === null || values2 === void 0 || (_values$first = values2.first) === null || _values$first === void 0 ? void 0 : _values$first.call(values2);
      var valTo = values2 === null || values2 === void 0 || (_values$get = values2.get) === null || _values$get === void 0 ? void 0 : _values$get.call(values2, 1);
      return "".concat(field, " ").concat(sqlOp, " ").concat(valFrom, " AND ").concat(valTo);
    };
  }
  return fn;
};
var formatRule6 = function formatRule7(item, config2, meta) {
  var properties = item.get("properties") || new Map$2();
  var field = properties.get("field");
  var fieldSrc = properties.get("fieldSrc");
  var operator = properties.get("operator");
  var operatorOptions = properties.get("operatorOptions");
  var iValueSrc = properties.get("valueSrc");
  var iValueType = properties.get("valueType");
  var iValue = properties.get("value");
  var asyncListValues = properties.get("asyncListValues");
  if (field == null || operator == null) return void 0;
  var fieldDefinition = getFieldConfig$8(config2, field) || {};
  var opDef = getOperatorConfig$4(config2, operator, field) || {};
  var reversedOp = opDef.reversedOp;
  var revOpDef = getOperatorConfig$4(config2, reversedOp, field) || {};
  var cardinality = getOpCardinality$1(opDef);
  var isRev = false;
  var canFormatOp = opDef.sqlOp || opDef.sqlFormatOp;
  var canFormatRevOp = revOpDef.sqlOp || revOpDef.sqlFormatOp;
  if (!canFormatOp && !canFormatRevOp) {
    meta.errors.push("Operator ".concat(operator, " is not supported"));
    return void 0;
  }
  if (!canFormatOp && canFormatRevOp) {
    isRev = true;
    var _ref = [reversedOp, operator];
    operator = _ref[0];
    reversedOp = _ref[1];
    var _ref2 = [revOpDef, opDef];
    opDef = _ref2[0];
    revOpDef = _ref2[1];
  }
  var valueSrcs = [];
  var valueTypes = [];
  var formattedValue;
  if (iValue != void 0) {
    var fvalue = iValue.map(function(currentValue, ind) {
      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
      var valueType = iValueType ? iValueType.get(ind) : null;
      var cValue = completeValue(currentValue, valueSrc, config2);
      var widget = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
      var fieldWidgetDefinition = getFieldWidgetConfig$3(config2, field, operator, widget, valueSrc, {
        forExport: true
      });
      var fv = formatValue5(meta, config2, cValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, opDef, asyncListValues);
      if (fv !== void 0) {
        valueSrcs.push(valueSrc);
        valueTypes.push(valueType);
      }
      return fv;
    });
    var hasUndefinedValues = fvalue.filter(function(v) {
      return v === void 0;
    }).size > 0;
    if (hasUndefinedValues || fvalue.size < cardinality) return void 0;
    formattedValue = cardinality == 1 ? fvalue.first() : fvalue;
  }
  var fn = opDef.sqlFormatOp || buildFnToFormatOp4(operator, opDef);
  if (!fn) {
    meta.errors.push("Operator ".concat(operator, " is not supported"));
    return void 0;
  }
  var formattedField = fieldSrc == "func" ? formatFunc5(meta, config2, field) : formatField5(meta, config2, field);
  if (formattedField == void 0) return void 0;
  var args = [formattedField, operator, formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], omit$2(opDef, opDefKeysToOmit), operatorOptions, fieldDefinition];
  var ret;
  ret = fn.call.apply(fn, [config2.ctx].concat(args));
  if (isRev) {
    ret = config2.settings.sqlFormatReverse.call(config2.ctx, ret);
  }
  if (ret === void 0) {
    meta.errors.push("Operator ".concat(operator, " is not supported for value source ").concat(valueSrcs.join(", ")));
    return void 0;
  }
  return ret;
};
var formatValue5 = function formatValue6(meta, config2, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, asyncListValues) {
  if (currentValue === void 0) return void 0;
  var ret;
  if (valueSrc == "field") {
    ret = formatField5(meta, config2, currentValue);
  } else if (valueSrc == "func") {
    ret = formatFunc5(meta, config2, currentValue);
  } else {
    if (typeof (fieldWidgetDef === null || fieldWidgetDef === void 0 ? void 0 : fieldWidgetDef.sqlFormatValue) === "function") {
      var fn = fieldWidgetDef.sqlFormatValue;
      var args = [
        currentValue,
        _objectSpread$o(_objectSpread$o({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
          asyncListValues
        }),
        //useful options: valueFormat for date/time
        omit$2(fieldWidgetDef, widgetDefKeysToOmit)
      ];
      if (operator) {
        args.push(operator);
        args.push(operatorDef);
      }
      if (valueSrc == "field") {
        var valFieldDefinition = getFieldConfig$8(config2, currentValue) || {};
        args.push(valFieldDefinition);
      }
      ret = fn.call.apply(fn, [config2.ctx].concat(args));
    } else {
      if (Array.isArray(currentValue)) {
        ret = currentValue.map(function(v) {
          return SqlString.escape(v);
        });
      } else {
        ret = SqlString.escape(currentValue);
      }
    }
  }
  return ret;
};
var formatField5 = function formatField6(meta, config2, field) {
  if (!field) return;
  var fieldSeparator = config2.settings.fieldSeparator;
  var fieldDefinition = getFieldConfig$8(config2, field) || {};
  var fieldParts = getFieldParts$3(field, config2);
  var fieldPartsLabels = getFieldPathLabels$2(field, config2);
  var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;
  var formatFieldFn = config2.settings.formatField;
  var fieldName = formatFieldName(field, config2, meta, null, {
    useTableName: true
  });
  var formattedField = formatFieldFn(fieldName, fieldParts, fieldFullLabel, fieldDefinition, config2);
  return formattedField;
};
var formatFunc5 = function formatFunc6(meta, config2, currentValue) {
  var _currentValue$get, _currentValue$get2;
  var funcKey = (_currentValue$get = currentValue.get) === null || _currentValue$get === void 0 ? void 0 : _currentValue$get.call(currentValue, "func");
  var args = (_currentValue$get2 = currentValue.get) === null || _currentValue$get2 === void 0 ? void 0 : _currentValue$get2.call(currentValue, "args");
  var funcConfig = getFuncConfig$2(config2, funcKey);
  if (!funcConfig) {
    meta.errors.push("Func ".concat(funcKey, " is not defined in config"));
    return void 0;
  }
  var funcParts = getFieldParts$3(funcKey, config2);
  var funcLastKey = funcParts[funcParts.length - 1];
  var funcName = funcConfig.sqlFunc || funcLastKey;
  var formattedArgs = {};
  var gaps = [];
  var missingArgKeys = [];
  for (var argKey in funcConfig.args) {
    var _argValue;
    var argConfig = funcConfig.args[argKey];
    var fieldDef = getFieldConfig$8(config2, argConfig);
    var defaultValue = argConfig.defaultValue, isOptional = argConfig.isOptional;
    var defaultValueSrc = defaultValue !== null && defaultValue !== void 0 && defaultValue.func ? "func" : "value";
    var argVal = args ? args.get(argKey) : void 0;
    var argValue = argVal ? argVal.get("value") : void 0;
    var argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
    if (argValueSrc !== "func" && (_argValue = argValue) !== null && _argValue !== void 0 && _argValue.toJS) {
      argValue = argValue.toJS();
    }
    var argAsyncListValues = argVal ? argVal.get("asyncListValues") : void 0;
    var formattedArgVal = formatValue5(meta, config2, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, argAsyncListValues);
    if (argValue != void 0 && formattedArgVal === void 0) {
      if (argValueSrc != "func")
        meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
      return void 0;
    }
    var formattedDefaultVal = void 0;
    if (formattedArgVal === void 0 && !isOptional && defaultValue != void 0) {
      formattedDefaultVal = formatValue5(meta, config2, defaultValue, defaultValueSrc, argConfig.type, fieldDef, argConfig, null, null, argAsyncListValues);
      if (formattedDefaultVal === void 0) {
        if (defaultValueSrc != "func")
          meta.errors.push("Can't format default value of arg ".concat(argKey, " for func ").concat(funcKey));
        return void 0;
      }
    }
    var finalFormattedVal = formattedArgVal !== null && formattedArgVal !== void 0 ? formattedArgVal : formattedDefaultVal;
    if (finalFormattedVal !== void 0) {
      if (gaps.length) {
        var _iterator = _createForOfIteratorHelper$4(argKey), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var missedArgKey = _step.value;
            formattedArgs[missedArgKey] = void 0;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        gaps = [];
      }
      formattedArgs[argKey] = finalFormattedVal;
    } else {
      if (!isOptional) missingArgKeys.push(argKey);
      gaps.push(argKey);
    }
  }
  if (missingArgKeys.length) {
    return void 0;
  }
  var ret;
  if (typeof funcConfig.sqlFormatFunc === "function") {
    var fn = funcConfig.sqlFormatFunc;
    var _args = [formattedArgs];
    ret = fn.call.apply(fn, [config2.ctx].concat(_args));
  } else {
    var argsStr = Object.entries(formattedArgs).map(function(_ref3) {
      var _ref4 = _slicedToArray$1(_ref3, 2);
      _ref4[0];
      var v = _ref4[1];
      return v;
    }).join(", ");
    ret = "".concat(funcName, "(").concat(argsStr, ")");
  }
  return ret;
};
function ownKeys$n(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$n(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$n(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$n(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function buildEsGeoPoint(geoPointString) {
  if (geoPointString == null) {
    return null;
  }
  var coordsNumberArray = geoPointString.split(",").map(Number);
  return {
    top_left: {
      lat: coordsNumberArray[0],
      lon: coordsNumberArray[1]
    },
    bottom_right: {
      lat: coordsNumberArray[2],
      lon: coordsNumberArray[3]
    }
  };
}
function buildEsRangeParameters(value, operator) {
  if (value.length > 1) {
    return {
      gte: "".concat(value[0]),
      lte: "".concat(value[1])
    };
  }
  var dateTime = value[0];
  switch (operator) {
    case "on_date":
    case "not_on_date":
    case "equal":
    case "select_equals":
    case "not_equal":
      return {
        gte: "".concat(dateTime, "||/d"),
        lte: "".concat(dateTime, "||+1d")
      };
    case "less_or_equal":
      return {
        lte: "".concat(dateTime)
      };
    case "greater_or_equal":
      return {
        gte: "".concat(dateTime)
      };
    case "less":
      return {
        lt: "".concat(dateTime)
      };
    case "greater":
      return {
        gt: "".concat(dateTime)
      };
    default:
      return void 0;
  }
}
function buildEsWildcardParameters(value) {
  return {
    value: "*" + value + "*"
  };
}
function determineOccurrence(combinator, not2) {
  switch (combinator) {
    case "AND":
      return not2 ? "must_not" : "must";
    case "OR":
      return not2 ? "should_not" : "should";
    case "NOT":
      return not2 ? "must" : "must_not";
    default:
      return void 0;
  }
}
function buildRegexpParameters(value) {
  return {
    value
  };
}
function determineField(fieldName, config2) {
  return fieldName;
}
function buildParameters(queryType, value, operator, fieldName, config2, syntax2) {
  var textField = determineField(fieldName);
  switch (queryType) {
    case "filter":
      return {
        script: config2.operators[operator].elasticSearchScript(fieldName, value)
      };
    case "exists":
      return {
        field: fieldName
      };
    case "match":
      return _defineProperty$4({}, textField, value[0]);
    case "term":
      return syntax2 === ES_7_SYNTAX ? _defineProperty$4({}, fieldName, {
        value: value[0]
      }) : _defineProperty$4({}, fieldName, value[0]);
    case "geo_bounding_box":
      return _defineProperty$4({}, fieldName, buildEsGeoPoint(value[0]));
    case "range":
      return _defineProperty$4({}, fieldName, buildEsRangeParameters(value, operator));
    case "wildcard":
      return _defineProperty$4({}, fieldName, buildEsWildcardParameters(value[0]));
    case "regexp":
      return _defineProperty$4({}, fieldName, buildRegexpParameters(value[0]));
    default:
      return void 0;
  }
}
function buildEsRule(fieldName, value, operator, config2, valueSrc, syntax2) {
  if (!fieldName || !operator || value == void 0) return void 0;
  var op2 = operator;
  var opConfig = config2.operators[op2];
  if (!opConfig) return void 0;
  var _opConfig = opConfig, elasticSearchQueryType2 = _opConfig.elasticSearchQueryType;
  var not2 = false;
  if (!elasticSearchQueryType2 && opConfig.reversedOp) {
    not2 = true;
    op2 = opConfig.reversedOp;
    opConfig = config2.operators[op2];
    var _opConfig2 = opConfig;
    elasticSearchQueryType2 = _opConfig2.elasticSearchQueryType;
  }
  var widget = getWidgetForFieldOp$3(config2, fieldName, op2, valueSrc);
  var widgetConfig = config2.widgets[widget];
  if (!widgetConfig) return void 0;
  var elasticSearchFormatValue2 = widgetConfig.elasticSearchFormatValue;
  var queryType;
  if (typeof elasticSearchQueryType2 === "function") {
    queryType = elasticSearchQueryType2(widget);
  } else {
    queryType = elasticSearchQueryType2;
  }
  if (!queryType) {
    return void 0;
  }
  var parameters;
  if (typeof elasticSearchFormatValue2 === "function") {
    parameters = elasticSearchFormatValue2(queryType, value, op2, fieldName, config2);
  } else {
    parameters = buildParameters(queryType, value, op2, fieldName, config2, syntax2);
  }
  if (not2) {
    return {
      bool: {
        must_not: _defineProperty$4({}, queryType, _objectSpread$n({}, parameters))
      }
    };
  } else {
    return _defineProperty$4({}, queryType, _objectSpread$n({}, parameters));
  }
}
function buildEsGroup(children, conjunction, not2, recursiveFxn, config2, syntax2) {
  if (!children || !children.size) return void 0;
  var childrenArray = children.valueSeq().toArray();
  var occurrence = determineOccurrence(conjunction, not2);
  var result = childrenArray.map(function(c2) {
    return recursiveFxn(c2, config2, syntax2);
  }).filter(function(v) {
    return v !== void 0;
  });
  if (!result.length) return void 0;
  var resultFlat = result.flat(Infinity);
  return {
    bool: _defineProperty$4({}, occurrence, resultFlat)
  };
}
var ES_7_SYNTAX = "ES_7_SYNTAX";
var ES_6_SYNTAX = "ES_6_SYNTAX";
function elasticSearchFormat(tree2, config2) {
  var syntax2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ES_6_SYNTAX;
  var extendedConfig = extendConfig(config2, void 0, false);
  if (!tree2) return void 0;
  var type2 = tree2.get("type");
  var properties = tree2.get("properties") || /* @__PURE__ */ new Map();
  if (type2 === "rule" && properties.get("field")) {
    var _properties$get, _properties$get2, _properties$get3;
    var operator = properties.get("operator");
    var field = properties.get("field");
    var fieldSrc = properties.get("fieldSrc");
    var value = (_properties$get = properties.get("value")) === null || _properties$get === void 0 ? void 0 : _properties$get.toJS();
    (_properties$get2 = properties.get("valueType")) === null || _properties$get2 === void 0 ? void 0 : _properties$get2.get(0);
    var valueSrc = (_properties$get3 = properties.get("valueSrc")) === null || _properties$get3 === void 0 ? void 0 : _properties$get3.get(0);
    if (valueSrc === "func" || fieldSrc == "func") {
      return;
    }
    if (value && Array.isArray(value[0])) {
      return value[0].map(function(val) {
        return buildEsRule(field, [val], operator, extendedConfig, valueSrc, syntax2);
      });
    } else {
      return buildEsRule(field, value, operator, extendedConfig, valueSrc, syntax2);
    }
  }
  if (type2 === "group" || type2 === "rule_group") {
    var not2 = properties.get("not");
    var conjunction = properties.get("conjunction");
    if (!conjunction) conjunction = defaultConjunction(extendedConfig);
    var children = tree2.get("children1");
    return buildEsGroup(children, conjunction, not2, elasticSearchFormat, extendedConfig, syntax2);
  }
}
const Export = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _mongodbFormat,
  _spelFormat,
  _sqlFormat,
  elasticSearchFormat,
  jsonLogicFormat,
  mongodbFormat,
  queryBuilderFormat,
  queryString,
  spelFormat,
  sqlFormat
}, Symbol.toStringTag, { value: "Module" }));
function asyncGeneratorStep(n2, t2, e2, r2, o, a2, c2) {
  try {
    var i2 = n2[a2](c2), u = i2.value;
  } catch (n3) {
    return void e2(n3);
  }
  i2.done ? t2(u) : Promise.resolve(u).then(r2, o);
}
function _asyncToGenerator(n2) {
  return function() {
    var t2 = this, e2 = arguments;
    return new Promise(function(r2, o) {
      var a2 = n2.apply(t2, e2);
      function _next(n3) {
        asyncGeneratorStep(a2, r2, o, _next, _throw, "next", n3);
      }
      function _throw(n3) {
        asyncGeneratorStep(a2, r2, o, _next, _throw, "throw", n3);
      }
      _next(void 0);
    });
  };
}
var _excluded$9 = ["title", "value", "disabled", "groupTitle", "grouplabel", "renderTitle", "children", "label", "isCustom", "isHidden"];
function _createForOfIteratorHelper$3(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null) it["return"]();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$3(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function ownKeys$m(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$m(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$m(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$m(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var findLastIndex2 = function findLastIndex3(arr, fn) {
  if (arr.findLastIndex) {
    return arr.findLastIndex(fn);
  } else {
    var ind = _toConsumableArray(arr).reverse().findIndex(fn);
    return ind == -1 ? -1 : arr.length - 1 - ind;
  }
};
var simulateAsyncFetch = function simulateAsyncFetch2(all) {
  var cPageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var delay = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e3;
  return /* @__PURE__ */ function() {
    var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee(search, offset2, meta) {
      var pageSize2, filtered, currentOffset, values2, newOffset, hasMore;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            pageSize2 = (meta === null || meta === void 0 ? void 0 : meta.pageSize) != void 0 ? meta.pageSize : cPageSize;
            filtered = listValuesToArray$1(all).filter(function(_ref2) {
              var title2 = _ref2.title, value = _ref2.value;
              return search == null ? true : title2.toUpperCase().indexOf(search.toUpperCase()) != -1 || "".concat(value).toUpperCase().indexOf(search.toUpperCase()) != -1;
            });
            pageSize2 ? Math.ceil(filtered.length / pageSize2) : 0;
            currentOffset = offset2 || 0;
            values2 = pageSize2 ? filtered.slice(currentOffset, currentOffset + pageSize2) : filtered;
            newOffset = pageSize2 ? currentOffset + values2.length : null;
            hasMore = pageSize2 ? newOffset < filtered.length : false;
            if (!delay) {
              _context.next = 11;
              break;
            }
            _context.next = 11;
            return sleep$1(delay);
          case 11:
            return _context.abrupt("return", {
              values: values2,
              hasMore
            });
          case 12:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function(_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();
};
var mergeListValues$1 = function mergeListValues(values2, newValues) {
  var toStart = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var hideNewValues = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (!newValues) return values2;
  var old = values2 || [];
  var newFiltered = newValues.filter(function(v) {
    return old.find(function(av) {
      return "" + av.value == "" + v.value;
    }) == void 0;
  }).map(function(v) {
    return hideNewValues ? _objectSpread$m(_objectSpread$m({}, v), {}, {
      isHidden: true
    }) : v;
  });
  var merged = toStart ? [].concat(_toConsumableArray(newFiltered), _toConsumableArray(old)) : [].concat(_toConsumableArray(old), _toConsumableArray(newFiltered));
  return merged;
};
var optionToListValue$1 = function optionToListValue(val, listValues2, allowCustomValues) {
  var _val$value;
  var v = val == null || val == "" ? void 0 : (_val$value = val === null || val === void 0 ? void 0 : val.value) !== null && _val$value !== void 0 ? _val$value : val;
  var item = getListValue$1(v, listValues2);
  var customItem = allowCustomValues && !item ? makeCustomListValue$1(v) : void 0;
  var listValue = item || customItem;
  var lvs = listValue ? [listValue] : void 0;
  return [v, lvs];
};
var optionsToListValues$1 = function optionsToListValues(vals, listValues2, allowCustomValues) {
  var newSelectedListValues = vals.map(function(val, _i) {
    var _val$value2;
    var v = val == null || val == "" ? void 0 : (_val$value2 = val === null || val === void 0 ? void 0 : val.value) !== null && _val$value2 !== void 0 ? _val$value2 : val;
    var item = getListValue$1(v, listValues2);
    var customItem = allowCustomValues && !item ? makeCustomListValue$1(v) : void 0;
    var listValue = item || customItem;
    return listValue;
  }).filter(function(o) {
    return o != void 0;
  });
  var newSelectedValues = newSelectedListValues.map(function(o) {
    var _o$value;
    return (_o$value = o === null || o === void 0 ? void 0 : o.value) !== null && _o$value !== void 0 ? _o$value : o;
  });
  if (!newSelectedValues.length) newSelectedValues = void 0;
  return [newSelectedValues, newSelectedListValues];
};
var listValueToOption$1 = function listValueToOption(lv) {
  if (lv == null) return null;
  var title2 = lv.title, value = lv.value, disabled = lv.disabled, groupTitle = lv.groupTitle, grouplabel = lv.grouplabel, renderTitle = lv.renderTitle, children = lv.children, label2 = lv.label, isCustom = lv.isCustom, isHidden = lv.isHidden, rest2 = _objectWithoutProperties$2(lv, _excluded$9);
  var option = {
    value,
    title: title2 || label2 || children
    // fix issue #930 for AntD
  };
  if (disabled) option.disabled = disabled;
  if (isCustom) option.isCustom = isCustom;
  if (isHidden) option.isHidden = isHidden;
  if (groupTitle || grouplabel) option.groupTitle = groupTitle || grouplabel;
  if (renderTitle) option.renderTitle = renderTitle;
  option = _objectSpread$m(_objectSpread$m({}, option), rest2);
  return option;
};
var fixListValuesGroupOrder$1 = function fixListValuesGroupOrder(listValues2) {
  var newValues = [];
  var groupTitles = [];
  var _iterator = _createForOfIteratorHelper$3(listValues2), _step;
  try {
    var _loop = function _loop4() {
      var lv = _step.value;
      var i2 = findLastIndex2(newValues, function(lv1) {
        var _lv1$groupTitle, _lv$groupTitle;
        return ((_lv1$groupTitle = lv1.groupTitle) !== null && _lv1$groupTitle !== void 0 ? _lv1$groupTitle : "") == ((_lv$groupTitle = lv.groupTitle) !== null && _lv$groupTitle !== void 0 ? _lv$groupTitle : "");
      });
      if (lv.groupTitle != void 0 && !groupTitles.includes(lv.groupTitle)) {
        groupTitles.push(lv.groupTitle);
        if (groupTitles.length === 1) {
          newValues = newValues.map(function(nv) {
            return _objectSpread$m(_objectSpread$m({}, nv), {}, {
              groupTitle: ""
            });
          });
        }
      }
      if (lv.groupTitle == void 0 && groupTitles.length) {
        lv = _objectSpread$m(_objectSpread$m({}, lv), {}, {
          groupTitle: ""
        });
      }
      if (i2 != -1) {
        newValues.splice(i2 + 1, 0, lv);
      } else {
        newValues.push(lv);
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return newValues;
};
const autocomplete = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fixListValuesGroupOrder: fixListValuesGroupOrder$1,
  getListValue: getListValue$1,
  listValueToOption: listValueToOption$1,
  mergeListValues: mergeListValues$1,
  optionToListValue: optionToListValue$1,
  optionsToListValues: optionsToListValues$1,
  simulateAsyncFetch
}, Symbol.toStringTag, { value: "Module" }));
const BasicUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Autocomplete: autocomplete,
  ConfigUtils: configUtils,
  DefaultUtils: defaultUtils,
  ExportUtils: _export,
  FuncUtils: funcUtils,
  ListUtils: listValues,
  OtherUtils: stuff,
  RuleUtils: ruleUtils,
  TreeUtils: treeUtils,
  Validation: validation,
  checkTree,
  clone: clone$3,
  compressConfig,
  decompressConfig,
  getSwitchValues,
  i18n,
  isValidTree,
  moment: hooks,
  sanitizeTree,
  uuid,
  validateAndFixTree: validateAndFixTree$1,
  validateTree
}, Symbol.toStringTag, { value: "Module" }));
var NOW = {
  label: "Now",
  returnType: "datetime",
  jsonLogic: "now",
  jsonLogicCustomOps: {
    now: {}
  },
  //spelFunc: "new java.util.Date()",
  spelFunc: "T(java.time.LocalDateTime).now()",
  sqlFormatFunc: function sqlFormatFunc() {
    return "NOW()";
  },
  mongoFormatFunc: function mongoFormatFunc() {
    return /* @__PURE__ */ new Date();
  },
  formatFunc: function formatFunc7() {
    return "NOW";
  }
};
var RELATIVE_DATETIME = {
  label: "Relative",
  returnType: "datetime",
  renderBrackets: ["", ""],
  renderSeps: ["", "", ""],
  spelFormatFunc: function spelFormatFunc(_ref) {
    var date = _ref.date, op2 = _ref.op, val = _ref.val, dim = _ref.dim;
    var dimPlural = dim.charAt(0).toUpperCase() + dim.slice(1) + "s";
    var method = op2 + dimPlural;
    return "".concat(date, ".").concat(method, "(").concat(val, ")");
  },
  spelImport: function spelImport(spel) {
    var _spel$methodName;
    var date, op2, val, dim;
    var matchRes = (_spel$methodName = spel.methodName) === null || _spel$methodName === void 0 ? void 0 : _spel$methodName.match(/^(minus|plus)(\w+)s$/);
    if (matchRes) {
      dim = matchRes[2].toLowerCase();
      op2 = matchRes[1];
      if (["minus", "plus"].includes(op2)) {
        if (["day", "week", "month", "year"].includes(dim)) {
          op2 = {
            type: "string",
            val: op2
          };
          dim = {
            type: "string",
            val: dim
          };
          val = spel.args[0];
          date = spel.obj;
          return {
            date,
            op: op2,
            val,
            dim
          };
        }
      }
    }
  },
  jsonLogic: function jsonLogic(_ref2) {
    var date = _ref2.date, op2 = _ref2.op, val = _ref2.val, dim = _ref2.dim;
    return {
      "date_add": [date, val * (op2 == "minus" ? -1 : 1), dim]
    };
  },
  jsonLogicImport: function jsonLogicImport(v) {
    var date = v["date_add"][0];
    var val = Math.abs(v["date_add"][1]);
    var op2 = v["date_add"][1] >= 0 ? "plus" : "minus";
    var dim = v["date_add"][2];
    return [date, op2, val, dim];
  },
  jsonLogicCustomOps: {
    date_add: {}
  },
  // MySQL
  //todo: other SQL dialects?
  sqlFormatFunc: function sqlFormatFunc2(_ref3) {
    var date = _ref3.date, op2 = _ref3.op, val = _ref3.val, dim = _ref3.dim;
    return "DATE_ADD(".concat(date, ", INTERVAL ").concat(parseInt(val) * (op2 == "minus" ? -1 : 1), " ").concat(dim.replace(/^'|'$/g, ""), ")");
  },
  mongoFormatFunc: null,
  //todo: support?
  formatFunc: function formatFunc8(_ref4) {
    var date = _ref4.date, op2 = _ref4.op, val = _ref4.val, dim = _ref4.dim;
    return !val ? date : "".concat(date, " ").concat(op2 == "minus" ? "-" : "+", " ").concat(val, " ").concat(dim);
  },
  args: {
    date: {
      label: "Date",
      type: "datetime",
      defaultValue: {
        func: "NOW",
        args: []
      },
      valueSources: ["func", "field", "value"],
      spelEscapeForFormat: true
    },
    op: {
      label: "Op",
      type: "select",
      defaultValue: "plus",
      valueSources: ["value"],
      mainWidgetProps: {
        customProps: {
          showSearch: false
        }
      },
      fieldSettings: {
        listValues: {
          plus: "+",
          minus: "-"
        }
      },
      spelEscapeForFormat: false
    },
    val: {
      label: "Value",
      type: "number",
      fieldSettings: {
        min: 0
      },
      defaultValue: 0,
      valueSources: ["value"],
      spelEscapeForFormat: false
    },
    dim: {
      label: "Dimension",
      type: "select",
      defaultValue: "day",
      valueSources: ["value"],
      mainWidgetProps: {
        customProps: {
          showSearch: false
        }
      },
      fieldSettings: {
        listValues: {
          day: "day",
          week: "week",
          month: "month",
          year: "year"
        }
      },
      spelEscapeForFormat: false
    }
  }
};
var LOWER = {
  label: "Lowercase",
  mongoFunc: "$toLower",
  jsonLogic: "toLowerCase",
  spelFunc: "${str}.toLowerCase()",
  //jsonLogicIsMethod: true, // Removed in JsonLogic 2.x due to Prototype Pollution
  jsonLogicCustomOps: {
    toLowerCase: {}
  },
  returnType: "text",
  args: {
    str: {
      label: "String",
      type: "text",
      valueSources: ["value", "field", "func"]
    }
  }
};
var UPPER = {
  label: "Uppercase",
  mongoFunc: "$toUpper",
  jsonLogic: "toUpperCase",
  spelFunc: "${str}.toUpperCase()",
  //jsonLogicIsMethod: true, // Removed in JsonLogic 2.x due to Prototype Pollution
  jsonLogicCustomOps: {
    toUpperCase: {}
  },
  returnType: "text",
  args: {
    str: {
      label: "String",
      type: "text",
      valueSources: ["value", "field", "func"]
    }
  }
};
var LINEAR_REGRESSION = {
  label: "Linear regression",
  returnType: "number",
  formatFunc: function formatFunc9(_ref5, _) {
    var coef = _ref5.coef, bias = _ref5.bias, val = _ref5.val;
    return "(".concat(coef, " * ").concat(val, " + ").concat(bias, ")");
  },
  sqlFormatFunc: function sqlFormatFunc3(_ref6) {
    var coef = _ref6.coef, bias = _ref6.bias, val = _ref6.val;
    return "(".concat(coef, " * ").concat(val, " + ").concat(bias, ")");
  },
  spelFormatFunc: function spelFormatFunc2(_ref7) {
    var coef = _ref7.coef, bias = _ref7.bias, val = _ref7.val;
    return "(".concat(coef, " * ").concat(val, " + ").concat(bias, ")");
  },
  spelImport: function spelImport2(spel) {
    var coef, val, bias, a2;
    if (spel.type === "op-plus") {
      var _spel$children = _slicedToArray$1(spel.children, 2);
      a2 = _spel$children[0];
      bias = _spel$children[1];
      if (a2.type === "op-multiply") {
        var _a$children = _slicedToArray$1(a2.children, 2);
        coef = _a$children[0];
        val = _a$children[1];
        return {
          coef,
          val,
          bias
        };
      }
    }
  },
  mongoFormatFunc: function mongoFormatFunc2(_ref8) {
    var coef = _ref8.coef, bias = _ref8.bias, val = _ref8.val;
    return {
      "$sum": [{
        "$multiply": [coef, val]
      }, bias]
    };
  },
  jsonLogic: function jsonLogic2(_ref9) {
    var coef = _ref9.coef, bias = _ref9.bias, val = _ref9.val;
    return {
      "+": [{
        "*": [coef, val]
      }, bias]
    };
  },
  jsonLogicImport: function jsonLogicImport2(v) {
    var coef = v["+"][0]["*"][0];
    var val = v["+"][0]["*"][1];
    var bias = v["+"][1];
    return [coef, val, bias];
  },
  renderBrackets: ["", ""],
  renderSeps: [" * ", " + "],
  args: {
    coef: {
      label: "Coef",
      type: "number",
      defaultValue: 1,
      valueSources: ["value"]
    },
    val: {
      label: "Value",
      type: "number",
      valueSources: ["value", "field"]
    },
    bias: {
      label: "Bias",
      type: "number",
      defaultValue: 0,
      valueSources: ["value"]
    }
  }
};
var mongoFormatOp1 = function mongoFormatOp12(mop, mc, not2, field, _op, value, useExpr, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
  var $field = typeof field == "string" && !field.startsWith("$") ? "$" + field : field;
  var mv = mc(value, fieldDef);
  if (mv === void 0) return void 0;
  if (not2) {
    if (!useExpr && (!mop || mop == "$eq")) return _defineProperty$4({}, field, {
      "$ne": mv
    });
    return !useExpr ? _defineProperty$4({}, field, {
      "$not": _defineProperty$4({}, mop, mv)
    }) : {
      "$not": _defineProperty$4({}, mop, [$field, mv])
    };
  } else {
    if (!useExpr && (!mop || mop == "$eq")) return _defineProperty$4({}, field, mv);
    return !useExpr ? _defineProperty$4({}, field, _defineProperty$4({}, mop, mv)) : _defineProperty$4({}, mop, [$field, mv]);
  }
};
var mongoFormatOp2 = function mongoFormatOp22(mops, not2, field, _op, values2, useExpr, valueSrcs, valueTypes, opDef, operatorOptions, fieldDef) {
  var $field = typeof field == "string" && !field.startsWith("$") ? "$" + field : field;
  if (not2) {
    return !useExpr ? _defineProperty$4({}, field, {
      "$not": _defineProperty$4(_defineProperty$4({}, mops[0], values2[0]), mops[1], values2[1])
    }) : {
      "$not": {
        "$and": [_defineProperty$4({}, mops[0], [$field, values2[0]]), _defineProperty$4({}, mops[1], [$field, values2[1]])]
      }
    };
  } else {
    return !useExpr ? _defineProperty$4({}, field, _defineProperty$4(_defineProperty$4({}, mops[0], values2[0]), mops[1], values2[1])) : {
      "$and": [_defineProperty$4({}, mops[0], [$field, values2[0]]), _defineProperty$4({}, mops[1], [$field, values2[1]])]
    };
  }
};
var ctx$2 = {
  utils: {
    SqlString,
    moment: hooks,
    mongoFormatOp1,
    mongoFormatOp2,
    mongoEmptyValue,
    escapeRegExp,
    sqlEmptyValue,
    stringifyForDisplay,
    getTitleInListValues: getTitleInListValues$1,
    spelEscape,
    spelFixList,
    wrapWithBrackets
  }
};
function _createForOfIteratorHelper$2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null) it["return"]();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function ownKeys$l(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$l(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$l(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$l(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var conjunctions$2 = {
  AND: {
    label: "And",
    mongoConj: "$and",
    jsonLogicConj: "and",
    sqlConj: "AND",
    spelConj: "and",
    spelConjs: ["and", "&&"],
    reversedConj: "OR",
    formatConj: function formatConj(children, conj, not2, isForDisplay) {
      var ret = children.size > 1 ? children.join(" " + (isForDisplay ? "AND" : "&&") + " ") : children.first();
      if (children.size > 1 || not2) {
        ret = this.utils.wrapWithBrackets(ret);
      }
      if (not2) {
        ret = "NOT " + ret;
      }
      return ret;
    },
    sqlFormatConj: function sqlFormatConj(children, conj, not2) {
      var ret = children.size > 1 ? children.join(" AND ") : children.first();
      if (children.size > 1 || not2) {
        ret = this.utils.wrapWithBrackets(ret);
      }
      if (not2) {
        ret = "NOT " + ret;
      }
      return ret;
    },
    spelFormatConj: function spelFormatConj(children, conj, not2, omitBrackets) {
      if (not2) omitBrackets = false;
      var ret = children.size > 1 ? children.join(" && ") : children.first();
      if ((children.size > 1 || not2) && !omitBrackets) {
        ret = this.utils.wrapWithBrackets(ret);
      }
      if (not2) {
        ret = "!" + ret;
      }
      return ret;
    }
  },
  OR: {
    label: "Or",
    mongoConj: "$or",
    jsonLogicConj: "or",
    sqlConj: "OR",
    spelConj: "or",
    spelConjs: ["or", "||"],
    reversedConj: "AND",
    formatConj: function formatConj2(children, conj, not2, isForDisplay) {
      return children.size > 1 ? (not2 ? "NOT " : "") + "(" + children.join(" " + (isForDisplay ? "OR" : "||") + " ") + ")" : (not2 ? "NOT (" : "") + children.first() + (not2 ? ")" : "");
    },
    sqlFormatConj: function sqlFormatConj2(children, conj, not2) {
      return children.size > 1 ? (not2 ? "NOT " : "") + "(" + children.join(" OR ") + ")" : (not2 ? "NOT (" : "") + children.first() + (not2 ? ")" : "");
    },
    spelFormatConj: function spelFormatConj2(children, conj, not2, omitBrackets) {
      if (not2) omitBrackets = false;
      return children.size > 1 ? (not2 ? "!" : "") + (omitBrackets ? "" : "(") + children.join(" || ") + (omitBrackets ? "" : ")") : (not2 ? "!(" : "") + children.first() + (not2 ? ")" : "");
    }
  }
};
var operators$2 = {
  equal: {
    label: "==",
    labelForFormat: "==",
    sqlOp: "=",
    spelOp: "==",
    spelOps: ["==", "eq"],
    reversedOp: "not_equal",
    formatOp: function formatOp(field, op2, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) {
      var opStr = isForDisplay ? "=" : opDef.label;
      if (valueTypes == "boolean" && isForDisplay) return value == "No" ? "NOT ".concat(field) : "".concat(field);
      else return "".concat(field, " ").concat(opStr, " ").concat(value);
    },
    mongoFormatOp: function mongoFormatOp() {
      var _this$utils;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return (_this$utils = this.utils).mongoFormatOp1.apply(_this$utils, ["$eq", function(v) {
        return v;
      }, false].concat(args));
    },
    jsonLogic: "==",
    elasticSearchQueryType: "term"
  },
  not_equal: {
    isNotOp: true,
    label: "!=",
    labelForFormat: "!=",
    sqlOp: "<>",
    spelOp: "!=",
    spelOps: ["!=", "ne"],
    reversedOp: "equal",
    formatOp: function formatOp2(field, op2, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) {
      if (valueTypes == "boolean" && isForDisplay) return value == "No" ? "".concat(field) : "NOT ".concat(field);
      else return "".concat(field, " ").concat(opDef.label, " ").concat(value);
    },
    mongoFormatOp: function mongoFormatOp3() {
      var _this$utils2;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return (_this$utils2 = this.utils).mongoFormatOp1.apply(_this$utils2, ["$ne", function(v) {
        return v;
      }, false].concat(args));
    },
    jsonLogic: "!="
  },
  less: {
    label: "<",
    labelForFormat: "<",
    sqlOp: "<",
    spelOp: "<",
    spelOps: ["<", "lt"],
    reversedOp: "greater_or_equal",
    mongoFormatOp: function mongoFormatOp4() {
      var _this$utils3;
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return (_this$utils3 = this.utils).mongoFormatOp1.apply(_this$utils3, ["$lt", function(v) {
        return v;
      }, false].concat(args));
    },
    jsonLogic: "<",
    elasticSearchQueryType: "range"
  },
  less_or_equal: {
    label: "<=",
    labelForFormat: "<=",
    sqlOp: "<=",
    spelOp: "<=",
    spelOps: ["<=", "le"],
    reversedOp: "greater",
    mongoFormatOp: function mongoFormatOp5() {
      var _this$utils4;
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return (_this$utils4 = this.utils).mongoFormatOp1.apply(_this$utils4, ["$lte", function(v) {
        return v;
      }, false].concat(args));
    },
    jsonLogic: "<=",
    elasticSearchQueryType: "range"
  },
  greater: {
    label: ">",
    labelForFormat: ">",
    sqlOp: ">",
    spelOp: ">",
    spelOps: [">", "gt"],
    reversedOp: "less_or_equal",
    mongoFormatOp: function mongoFormatOp6() {
      var _this$utils5;
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return (_this$utils5 = this.utils).mongoFormatOp1.apply(_this$utils5, ["$gt", function(v) {
        return v;
      }, false].concat(args));
    },
    jsonLogic: ">",
    elasticSearchQueryType: "range"
  },
  greater_or_equal: {
    label: ">=",
    labelForFormat: ">=",
    sqlOp: ">=",
    spelOp: ">=",
    spelOps: [">=", "ge"],
    reversedOp: "less",
    mongoFormatOp: function mongoFormatOp7() {
      var _this$utils6;
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return (_this$utils6 = this.utils).mongoFormatOp1.apply(_this$utils6, ["$gte", function(v) {
        return v;
      }, false].concat(args));
    },
    jsonLogic: ">=",
    elasticSearchQueryType: "range"
  },
  like: {
    label: "Contains",
    labelForFormat: "Contains",
    reversedOp: "not_like",
    sqlOp: "LIKE",
    spelOp: "${0}.contains(${1})",
    valueTypes: ["text"],
    mongoFormatOp: function mongoFormatOp8() {
      var _this$utils7, _this = this;
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return (_this$utils7 = this.utils).mongoFormatOp1.apply(_this$utils7, ["$regex", function(v) {
        return typeof v == "string" ? _this.utils.escapeRegExp(v) : void 0;
      }, false].concat(args));
    },
    jsonLogic: function jsonLogic3(field, op2, val) {
      return {
        "in": [val, field]
      };
    },
    jsonLogic2: "#in",
    valueSources: ["value"],
    elasticSearchQueryType: "regexp"
  },
  not_like: {
    isNotOp: true,
    label: "Not contains",
    reversedOp: "like",
    labelForFormat: "Not Contains",
    sqlOp: "NOT LIKE",
    mongoFormatOp: function mongoFormatOp9() {
      var _this$utils8, _this2 = this;
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }
      return (_this$utils8 = this.utils).mongoFormatOp1.apply(_this$utils8, ["$regex", function(v) {
        return typeof v == "string" ? _this2.utils.escapeRegExp(v) : void 0;
      }, true].concat(args));
    },
    jsonLogic: function jsonLogic4(field, op2, val) {
      return {
        "!": {
          "in": [val, field]
        }
      };
    },
    jsonLogic2: "#!in",
    _jsonLogicIsExclamationOp: true,
    valueSources: ["value"]
  },
  starts_with: {
    label: "Starts with",
    labelForFormat: "Starts with",
    sqlOp: "LIKE",
    spelOp: "${0}.startsWith(${1})",
    mongoFormatOp: function mongoFormatOp10() {
      var _this$utils9, _this3 = this;
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }
      return (_this$utils9 = this.utils).mongoFormatOp1.apply(_this$utils9, ["$regex", function(v) {
        return typeof v == "string" ? "^" + _this3.utils.escapeRegExp(v) : void 0;
      }, false].concat(args));
    },
    jsonLogic: void 0,
    // not supported
    valueSources: ["value"]
  },
  ends_with: {
    label: "Ends with",
    labelForFormat: "Ends with",
    sqlOp: "LIKE",
    spelOp: "${0}.endsWith(${1})",
    mongoFormatOp: function mongoFormatOp11() {
      var _this$utils10, _this4 = this;
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }
      return (_this$utils10 = this.utils).mongoFormatOp1.apply(_this$utils10, ["$regex", function(v) {
        return typeof v == "string" ? _this4.utils.escapeRegExp(v) + "$" : void 0;
      }, false].concat(args));
    },
    jsonLogic: void 0,
    // not supported
    valueSources: ["value"]
  },
  between: {
    label: "Between",
    labelForFormat: "BETWEEN",
    sqlOp: "BETWEEN",
    cardinality: 2,
    formatOp: function formatOp3(field, op2, values2, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) {
      var valFrom = values2.first();
      var valTo = values2.get(1);
      if (isForDisplay) return "".concat(field, " BETWEEN ").concat(valFrom, " AND ").concat(valTo);
      else return "".concat(field, " >= ").concat(valFrom, " && ").concat(field, " <= ").concat(valTo);
    },
    spelFormatOp: function spelFormatOp(field, op2, values2, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
      var valFrom = values2[0];
      var valTo = values2[1];
      return "".concat(field, " >= ").concat(valFrom, " && ").concat(field, " <= ").concat(valTo);
    },
    mongoFormatOp: function mongoFormatOp13() {
      var _this$utils11;
      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        args[_key11] = arguments[_key11];
      }
      return (_this$utils11 = this.utils).mongoFormatOp2.apply(_this$utils11, [["$gte", "$lte"], false].concat(args));
    },
    valueLabels: ["Value from", "Value to"],
    textSeparators: [null, "and"],
    reversedOp: "not_between",
    jsonLogic: "<=",
    validateValues: function validateValues(values2) {
      if (values2[0] != void 0 && values2[1] != void 0) {
        return values2[0] <= values2[1];
      }
      return null;
    },
    elasticSearchQueryType: function elasticSearchQueryType(type2) {
      return type2 === "time" ? "filter" : "range";
    }
  },
  not_between: {
    isNotOp: true,
    label: "Not between",
    labelForFormat: "NOT BETWEEN",
    sqlOp: "NOT BETWEEN",
    cardinality: 2,
    formatOp: function formatOp4(field, op2, values2, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) {
      var valFrom = values2.first();
      var valTo = values2.get(1);
      if (isForDisplay) return "".concat(field, " NOT BETWEEN ").concat(valFrom, " AND ").concat(valTo);
      else return "(".concat(field, " < ").concat(valFrom, " || ").concat(field, " > ").concat(valTo, ")");
    },
    spelFormatOp: function spelFormatOp2(field, op2, values2, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
      var valFrom = values2[0];
      var valTo = values2[1];
      return "(".concat(field, " < ").concat(valFrom, " || ").concat(field, " > ").concat(valTo, ")");
    },
    mongoFormatOp: function mongoFormatOp14() {
      var _this$utils12;
      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        args[_key12] = arguments[_key12];
      }
      return (_this$utils12 = this.utils).mongoFormatOp2.apply(_this$utils12, [["$gte", "$lte"], true].concat(args));
    },
    valueLabels: ["Value from", "Value to"],
    textSeparators: [null, "and"],
    reversedOp: "between",
    jsonLogic: function jsonLogic5(field, op2, val) {
      return {
        "!": {
          "<=": [Array.isArray(val) ? val[0] : val, field, Array.isArray(val) ? val[1] : val]
        }
      };
    },
    jsonLogic2: "!<=",
    _jsonLogicIsExclamationOp: true,
    validateValues: function validateValues2(values2) {
      if (values2[0] != void 0 && values2[1] != void 0) {
        return values2[0] <= values2[1];
      }
      return null;
    }
  },
  is_empty: {
    label: "Is empty",
    labelForFormat: "IS EMPTY",
    cardinality: 0,
    reversedOp: "is_not_empty",
    formatOp: function formatOp5(field, op2, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return isForDisplay ? "".concat(field, " IS EMPTY") : "!".concat(field);
    },
    sqlFormatOp: function sqlFormatOp(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      var empty2 = this.utils.sqlEmptyValue(fieldDef);
      return "COALESCE(".concat(field, ", ").concat(empty2, ") = ").concat(empty2);
    },
    spelFormatOp: function spelFormatOp3(field, op2, values2, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
      return "".concat(field, " <= ''");
    },
    mongoFormatOp: function mongoFormatOp15() {
      var _this$utils13, _this5 = this;
      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        args[_key13] = arguments[_key13];
      }
      return (_this$utils13 = this.utils).mongoFormatOp1.apply(_this$utils13, ["$in", function(v, fieldDef) {
        return [_this5.utils.mongoEmptyValue(fieldDef), null];
      }, false].concat(args));
    },
    jsonLogic: "!"
  },
  is_not_empty: {
    isNotOp: true,
    label: "Is not empty",
    labelForFormat: "IS NOT EMPTY",
    cardinality: 0,
    reversedOp: "is_empty",
    formatOp: function formatOp6(field, op2, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return isForDisplay ? "".concat(field, " IS NOT EMPTY") : "!!".concat(field);
    },
    sqlFormatOp: function sqlFormatOp2(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      var empty2 = this.utils.sqlEmptyValue(fieldDef);
      return "COALESCE(".concat(field, ", ").concat(empty2, ") <> ").concat(empty2);
    },
    spelFormatOp: function spelFormatOp4(field, op2, values2, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
      return "".concat(field, " > ''");
    },
    mongoFormatOp: function mongoFormatOp16() {
      var _this$utils14, _this6 = this;
      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        args[_key14] = arguments[_key14];
      }
      return (_this$utils14 = this.utils).mongoFormatOp1.apply(_this$utils14, ["$nin", function(v, fieldDef) {
        return [_this6.utils.mongoEmptyValue(fieldDef), null];
      }, false].concat(args));
    },
    jsonLogic: "!!",
    elasticSearchQueryType: "exists"
  },
  is_null: {
    label: "Is null",
    labelForFormat: "IS NULL",
    sqlOp: "IS NULL",
    cardinality: 0,
    reversedOp: "is_not_null",
    formatOp: function formatOp7(field, op2, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return isForDisplay ? "".concat(field, " IS NULL") : "!".concat(field);
    },
    spelFormatOp: function spelFormatOp5(field, op2, values2, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
      return "".concat(field, " == null");
    },
    // check if value is null OR not exists
    mongoFormatOp: function mongoFormatOp17() {
      var _this$utils15;
      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        args[_key15] = arguments[_key15];
      }
      return (_this$utils15 = this.utils).mongoFormatOp1.apply(_this$utils15, ["$eq", function(v) {
        return null;
      }, false].concat(args));
    },
    jsonLogic: "=="
  },
  is_not_null: {
    label: "Is not null",
    labelForFormat: "IS NOT NULL",
    sqlOp: "IS NOT NULL",
    cardinality: 0,
    reversedOp: "is_null",
    formatOp: function formatOp8(field, op2, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return isForDisplay ? "".concat(field, " IS NOT NULL") : "!!".concat(field);
    },
    spelFormatOp: function spelFormatOp6(field, op2, values2, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
      return "".concat(field, " != null");
    },
    // check if value exists and is not null
    mongoFormatOp: function mongoFormatOp18() {
      var _this$utils16;
      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
        args[_key16] = arguments[_key16];
      }
      return (_this$utils16 = this.utils).mongoFormatOp1.apply(_this$utils16, ["$ne", function(v) {
        return null;
      }, false].concat(args));
    },
    jsonLogic: "!=",
    elasticSearchQueryType: "exists"
  },
  select_equals: {
    label: "==",
    labelForFormat: "==",
    sqlOp: "=",
    // enum/set
    formatOp: function formatOp9(field, op2, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      var opStr = isForDisplay ? "=" : "==";
      return "".concat(field, " ").concat(opStr, " ").concat(value);
    },
    spelOp: "==",
    spelOps: ["==", "eq"],
    mongoFormatOp: function mongoFormatOp19() {
      var _this$utils17;
      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
        args[_key17] = arguments[_key17];
      }
      return (_this$utils17 = this.utils).mongoFormatOp1.apply(_this$utils17, ["$eq", function(v) {
        return v;
      }, false].concat(args));
    },
    reversedOp: "select_not_equals",
    jsonLogic: "==",
    elasticSearchQueryType: "term"
  },
  select_not_equals: {
    isNotOp: true,
    label: "!=",
    labelForFormat: "!=",
    sqlOp: "<>",
    // enum/set
    formatOp: function formatOp10(field, op2, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return "".concat(field, " != ").concat(value);
    },
    spelOp: "!=",
    spelOps: ["!=", "ne"],
    mongoFormatOp: function mongoFormatOp20() {
      var _this$utils18;
      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
        args[_key18] = arguments[_key18];
      }
      return (_this$utils18 = this.utils).mongoFormatOp1.apply(_this$utils18, ["$ne", function(v) {
        return v;
      }, false].concat(args));
    },
    reversedOp: "select_equals",
    jsonLogic: "!="
  },
  select_any_in: {
    label: "Any in",
    labelForFormat: "IN",
    sqlOp: "IN",
    formatOp: function formatOp11(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      if (valueSrc == "value") return "".concat(field, " IN (").concat(values2.join(", "), ")");
      else return "".concat(field, " IN (").concat(values2, ")");
    },
    sqlFormatOp: function sqlFormatOp3(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      if (valueSrc == "value") {
        return "".concat(field, " IN (").concat(values2.join(", "), ")");
      } else return void 0;
    },
    valueTypes: ["multiselect"],
    spelOp: "${1}.contains(${0})",
    mongoFormatOp: function mongoFormatOp21() {
      var _this$utils19;
      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
        args[_key19] = arguments[_key19];
      }
      return (_this$utils19 = this.utils).mongoFormatOp1.apply(_this$utils19, ["$in", function(v) {
        return v;
      }, false].concat(args));
    },
    reversedOp: "select_not_any_in",
    jsonLogic: "in",
    elasticSearchQueryType: "term"
  },
  select_not_any_in: {
    isNotOp: true,
    label: "Not in",
    labelForFormat: "NOT IN",
    sqlOp: "NOT IN",
    formatOp: function formatOp12(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      if (valueSrc == "value") return "".concat(field, " NOT IN (").concat(values2.join(", "), ")");
      else return "".concat(field, " NOT IN (").concat(values2, ")");
    },
    sqlFormatOp: function sqlFormatOp4(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      if (valueSrc == "value") {
        return "".concat(field, " NOT IN (").concat(values2.join(", "), ")");
      } else return void 0;
    },
    mongoFormatOp: function mongoFormatOp23() {
      var _this$utils20;
      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
        args[_key20] = arguments[_key20];
      }
      return (_this$utils20 = this.utils).mongoFormatOp1.apply(_this$utils20, ["$nin", function(v) {
        return v;
      }, false].concat(args));
    },
    reversedOp: "select_any_in",
    jsonLogic: function jsonLogic6(field, op2, val) {
      return {
        "!": {
          "in": [field, val]
        }
      };
    },
    jsonLogic2: "!in",
    _jsonLogicIsExclamationOp: true
  },
  // it's not "contains all", but "contains any" operator
  multiselect_contains: {
    label: "Contains",
    labelForFormat: "CONTAINS",
    formatOp: function formatOp13(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      if (valueSrc == "value") return "".concat(field, " CONTAINS [").concat(values2.join(", "), "]");
      else return "".concat(field, " CONTAINS ").concat(values2);
    },
    reversedOp: "multiselect_not_contains",
    jsonLogic2: "some-in",
    jsonLogic: function jsonLogic7(field, op2, vals) {
      return {
        "some": [field, {
          "in": [{
            "var": ""
          }, vals]
        }]
      };
    },
    //spelOp: "${0}.containsAll(${1})",
    spelOp: "T(CollectionUtils).containsAny(${0}, ${1})",
    elasticSearchQueryType: "term",
    mongoFormatOp: function mongoFormatOp24() {
      var _this$utils21;
      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
        args[_key21] = arguments[_key21];
      }
      return (_this$utils21 = this.utils).mongoFormatOp1.apply(_this$utils21, ["$in", function(v) {
        return v;
      }, false].concat(args));
    }
  },
  multiselect_not_contains: {
    isNotOp: true,
    label: "Not contains",
    labelForFormat: "NOT CONTAINS",
    formatOp: function formatOp14(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      if (valueSrc == "value") return "".concat(field, " NOT CONTAINS [").concat(values2.join(", "), "]");
      else return "".concat(field, " NOT CONTAINS ").concat(values2);
    },
    reversedOp: "multiselect_contains",
    jsonLogic2: "!some-in",
    jsonLogic: function jsonLogic8(field, op2, vals) {
      return {
        "!": {
          "some": [field, {
            "in": [{
              "var": ""
            }, vals]
          }]
        }
      };
    },
    _jsonLogicIsExclamationOp: true
  },
  multiselect_equals: {
    label: "Equals",
    labelForFormat: "==",
    sqlOp: "=",
    formatOp: function formatOp15(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      var opStr = isForDisplay ? "=" : "==";
      if (valueSrc == "value") return "".concat(field, " ").concat(opStr, " [").concat(values2.join(", "), "]");
      else return "".concat(field, " ").concat(opStr, " ").concat(values2);
    },
    sqlFormatOp: function sqlFormatOp5(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      var _this7 = this;
      if (valueSrc == "value")
        return "".concat(field, " = '").concat(values2.map(function(v) {
          return _this7.utils.SqlString.trim(v);
        }).join(","), "'");
      else return void 0;
    },
    spelOp: "${0}.equals(${1})",
    mongoFormatOp: function mongoFormatOp25() {
      var _this$utils22;
      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
        args[_key22] = arguments[_key22];
      }
      return (_this$utils22 = this.utils).mongoFormatOp1.apply(_this$utils22, ["$eq", function(v) {
        return v;
      }, false].concat(args));
    },
    reversedOp: "multiselect_not_equals",
    jsonLogic2: "all-in",
    jsonLogic: function jsonLogic9(field, op2, vals) {
      return {
        // it's not "equals", but "includes" operator - just for example
        "all": [field, {
          "in": [{
            "var": ""
          }, vals]
        }]
      };
    },
    elasticSearchQueryType: "term"
  },
  multiselect_not_equals: {
    isNotOp: true,
    label: "Not equals",
    labelForFormat: "!=",
    sqlOp: "<>",
    formatOp: function formatOp16(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      if (valueSrc == "value") return "".concat(field, " != [").concat(values2.join(", "), "]");
      else return "".concat(field, " != ").concat(values2);
    },
    sqlFormatOp: function sqlFormatOp6(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      var _this8 = this;
      if (valueSrc == "value")
        return "".concat(field, " != '").concat(values2.map(function(v) {
          return _this8.utils.SqlString.trim(v);
        }).join(","), "'");
      else return void 0;
    },
    mongoFormatOp: function mongoFormatOp26() {
      var _this$utils23;
      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
        args[_key23] = arguments[_key23];
      }
      return (_this$utils23 = this.utils).mongoFormatOp1.apply(_this$utils23, ["$ne", function(v) {
        return v;
      }, false].concat(args));
    },
    reversedOp: "multiselect_equals",
    jsonLogic2: "!all-in",
    jsonLogic: function jsonLogic10(field, op2, vals) {
      return {
        // it's not "equals", but "includes" operator - just for example
        "!": {
          "all": [field, {
            "in": [{
              "var": ""
            }, vals]
          }]
        }
      };
    },
    _jsonLogicIsExclamationOp: true
  },
  proximity: {
    label: "Proximity search",
    cardinality: 2,
    valueLabels: [{
      label: "Word 1",
      placeholder: "Enter first word"
    }, {
      label: "Word 2",
      placeholder: "Enter second word"
    }],
    textSeparators: [
      //'Word 1',
      //'Word 2'
    ],
    formatOp: function formatOp17(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      var val1 = values2.first();
      var val2 = values2.get(1);
      var prox = operatorOptions === null || operatorOptions === void 0 ? void 0 : operatorOptions.get("proximity");
      return "".concat(field, " ").concat(val1, " NEAR/").concat(prox, " ").concat(val2);
    },
    sqlFormatOp: function sqlFormatOp7(field, op2, values2, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      var val1 = values2.first();
      var val2 = values2.get(1);
      var aVal1 = this.utils.SqlString.trim(val1);
      var aVal2 = this.utils.SqlString.trim(val2);
      var prox = operatorOptions === null || operatorOptions === void 0 ? void 0 : operatorOptions.get("proximity");
      return "CONTAINS(".concat(field, ", 'NEAR((").concat(aVal1, ", ").concat(aVal2, "), ").concat(prox, ")')");
    },
    mongoFormatOp: void 0,
    // not supported
    jsonLogic: void 0,
    // not supported
    options: {
      optionLabel: "Near",
      // label on top of "near" selectbox (for config.settings.showLabels==true)
      optionTextBefore: "Near",
      // label before "near" selectbox (for config.settings.showLabels==false)
      optionPlaceholder: "Select words between",
      // placeholder for "near" selectbox
      minProximity: 2,
      maxProximity: 10,
      defaults: {
        proximity: 2
      }
    }
  },
  some: {
    label: "Some",
    labelForFormat: "SOME",
    cardinality: 0,
    jsonLogic: "some",
    spelFormatOp: function spelFormatOp7(filteredSize) {
      return "".concat(filteredSize, " > 0");
    },
    mongoFormatOp: function mongoFormatOp27() {
      var _this$utils24;
      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {
        args[_key24] = arguments[_key24];
      }
      return (_this$utils24 = this.utils).mongoFormatOp1.apply(_this$utils24, ["$gt", function(v) {
        return 0;
      }, false].concat(args));
    }
    // reversedOp: undefined,
  },
  all: {
    label: "All",
    labelForFormat: "ALL",
    cardinality: 0,
    jsonLogic: "all",
    spelFormatOp: function spelFormatOp8(filteredSize, op2, fullSize) {
      return "".concat(filteredSize, " == ").concat(fullSize);
    },
    mongoFormatOp: function mongoFormatOp28() {
      var _this$utils25;
      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {
        args[_key25] = arguments[_key25];
      }
      return (_this$utils25 = this.utils).mongoFormatOp1.apply(_this$utils25, ["$eq", function(v) {
        return v;
      }, false].concat(args));
    }
    // reversedOp: "none",
  },
  none: {
    label: "None",
    labelForFormat: "NONE",
    cardinality: 0,
    jsonLogic: "none",
    spelFormatOp: function spelFormatOp9(filteredSize) {
      return "".concat(filteredSize, " == 0");
    },
    mongoFormatOp: function mongoFormatOp29() {
      var _this$utils26;
      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {
        args[_key26] = arguments[_key26];
      }
      return (_this$utils26 = this.utils).mongoFormatOp1.apply(_this$utils26, ["$eq", function(v) {
        return 0;
      }, false].concat(args));
    }
    // reversedOp: "all",
  }
};
var widgets$3 = {
  text: {
    type: "text",
    jsType: "string",
    valueSrc: "value",
    valueLabel: "String",
    valuePlaceholder: "Enter string",
    formatValue: function formatValue7(val, fieldDef, wgtDef, isForDisplay) {
      return isForDisplay ? this.utils.stringifyForDisplay(val) : JSON.stringify(val);
    },
    spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef, op2, opDef) {
      return this.utils.spelEscape(val);
    },
    sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op2, opDef) {
      if (opDef.sqlOp == "LIKE" || opDef.sqlOp == "NOT LIKE") {
        return this.utils.SqlString.escapeLike(val, op2 != "starts_with", op2 != "ends_with");
      } else {
        return this.utils.SqlString.escape(val);
      }
    },
    toJS: function toJS2(val, fieldSettings) {
      return val;
    },
    mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
      return val;
    }
  },
  textarea: {
    type: "text",
    jsType: "string",
    valueSrc: "value",
    valueLabel: "Text",
    valuePlaceholder: "Enter text",
    formatValue: function formatValue8(val, fieldDef, wgtDef, isForDisplay) {
      return isForDisplay ? this.utils.stringifyForDisplay(val) : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue2(val, fieldDef, wgtDef, op2, opDef) {
      if (opDef.sqlOp == "LIKE" || opDef.sqlOp == "NOT LIKE") {
        return this.utils.SqlString.escapeLike(val, op2 != "starts_with", op2 != "ends_with");
      } else {
        return this.utils.SqlString.escape(val);
      }
    },
    spelFormatValue: function spelFormatValue2(val) {
      return this.utils.spelEscape(val);
    },
    toJS: function toJS3(val, fieldSettings) {
      return val;
    },
    mongoFormatValue: function mongoFormatValue2(val, fieldDef, wgtDef) {
      return val;
    },
    fullWidth: true
  },
  number: {
    type: "number",
    jsType: "number",
    valueSrc: "value",
    valueLabel: "Number",
    valuePlaceholder: "Enter number",
    valueLabels: [{
      label: "Number from",
      placeholder: "Enter number from"
    }, {
      label: "Number to",
      placeholder: "Enter number to"
    }],
    formatValue: function formatValue9(val, fieldDef, wgtDef, isForDisplay) {
      return isForDisplay ? this.utils.stringifyForDisplay(val) : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue3(val, fieldDef, wgtDef, op2, opDef) {
      return this.utils.SqlString.escape(val);
    },
    spelFormatValue: function spelFormatValue3(val, fieldDef, wgtDef) {
      var isFloat = wgtDef.step && !Number.isInteger(wgtDef.step);
      return this.utils.spelEscape(val, isFloat);
    },
    toJS: function toJS4(val, fieldSettings) {
      return val;
    },
    mongoFormatValue: function mongoFormatValue3(val, fieldDef, wgtDef) {
      return val;
    }
  },
  slider: {
    type: "number",
    jsType: "number",
    valueSrc: "value",
    valueLabel: "Number",
    valuePlaceholder: "Enter number or move slider",
    formatValue: function formatValue10(val, fieldDef, wgtDef, isForDisplay) {
      return isForDisplay ? this.utils.stringifyForDisplay(val) : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue4(val, fieldDef, wgtDef, op2, opDef) {
      return this.utils.SqlString.escape(val);
    },
    spelFormatValue: function spelFormatValue4(val) {
      return this.utils.spelEscape(val);
    },
    toJS: function toJS5(val, fieldSettings) {
      return val;
    },
    mongoFormatValue: function mongoFormatValue4(val, fieldDef, wgtDef) {
      return val;
    }
  },
  select: {
    type: "select",
    jsType: "string",
    valueSrc: "value",
    valueLabel: "Value",
    valuePlaceholder: "Select value",
    formatValue: function formatValue11(val, fieldDef, wgtDef, isForDisplay) {
      var valLabel = this.utils.getTitleInListValues(fieldDef.fieldSettings.listValues || fieldDef.asyncListValues, val);
      return isForDisplay ? this.utils.stringifyForDisplay(valLabel) : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue5(val, fieldDef, wgtDef, op2, opDef) {
      return this.utils.SqlString.escape(val);
    },
    spelFormatValue: function spelFormatValue5(val) {
      return this.utils.spelEscape(val);
    },
    toJS: function toJS6(val, fieldSettings) {
      return val;
    },
    mongoFormatValue: function mongoFormatValue5(val, fieldDef, wgtDef) {
      return val;
    }
  },
  multiselect: {
    type: "multiselect",
    jsType: "array",
    valueSrc: "value",
    valueLabel: "Values",
    valuePlaceholder: "Select values",
    formatValue: function formatValue12(vals, fieldDef, wgtDef, isForDisplay) {
      var _this9 = this;
      var valsLabels = vals.map(function(v) {
        return _this9.utils.getTitleInListValues(fieldDef.fieldSettings.listValues || fieldDef.asyncListValues, v);
      });
      return isForDisplay ? valsLabels.map(this.utils.stringifyForDisplay) : vals.map(JSON.stringify);
    },
    sqlFormatValue: function sqlFormatValue6(vals, fieldDef, wgtDef, op2, opDef) {
      var _this10 = this;
      return vals.map(function(v) {
        return _this10.utils.SqlString.escape(v);
      });
    },
    spelFormatValue: function spelFormatValue6(vals, fieldDef, wgtDef, op2, opDef) {
      var isCallable = opDef && opDef.spelOp && opDef.spelOp.startsWith("${1}");
      var res = this.utils.spelEscape(vals);
      if (isCallable) {
        res = this.utils.spelFixList(res);
      }
      return res;
    },
    toJS: function toJS7(val, fieldSettings) {
      return val;
    },
    mongoFormatValue: function mongoFormatValue6(val, fieldDef, wgtDef) {
      return val;
    }
  },
  date: {
    type: "date",
    jsType: "string",
    valueSrc: "value",
    dateFormat: "DD.MM.YYYY",
    valueFormat: "YYYY-MM-DD",
    valueLabel: "Date",
    valuePlaceholder: "Enter date",
    valueLabels: [{
      label: "Date from",
      placeholder: "Enter date from"
    }, {
      label: "Date to",
      placeholder: "Enter date to"
    }],
    formatValue: function formatValue13(val, fieldDef, wgtDef, isForDisplay) {
      var dateVal = this.utils.moment(val, wgtDef.valueFormat);
      return isForDisplay ? dateVal.format(wgtDef.dateFormat) : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue7(val, fieldDef, wgtDef, op2, opDef) {
      var dateVal = this.utils.moment(val, wgtDef.valueFormat);
      return this.utils.SqlString.escape(dateVal.format("YYYY-MM-DD"));
    },
    spelFormatValue: function spelFormatValue7(val, fieldDef, wgtDef, op2, opDef) {
      var dateVal = this.utils.moment(val, wgtDef.valueFormat);
      var v = dateVal.format("YYYY-MM-DD");
      var fmt = "yyyy-MM-dd";
      return "T(java.time.LocalDate).parse('".concat(v, "', T(java.time.format.DateTimeFormatter).ofPattern('").concat(fmt, "'))");
    },
    spelImportFuncs: [
      //"new java.text.SimpleDateFormat(${fmt}).parse(${v})",
      {
        obj: {
          cls: ["java", "time", "LocalDate"]
        },
        methodName: "parse",
        args: [{
          "var": "v"
        }, {
          obj: {
            cls: ["java", "time", "format", "DateTimeFormatter"]
          },
          methodName: "ofPattern",
          args: [{
            "var": "fmt"
          }]
        }]
      }
    ],
    spelImportValue: function spelImportValue(val, wgtDef, args) {
      var _args$fmt, _args$fmt$includes, _args$fmt2, _args$fmt2$toLowerCas;
      if (!wgtDef) return [void 0, "No widget def to get value format"];
      if (args !== null && args !== void 0 && (_args$fmt = args.fmt) !== null && _args$fmt !== void 0 && (_args$fmt = _args$fmt.value) !== null && _args$fmt !== void 0 && (_args$fmt$includes = _args$fmt.includes) !== null && _args$fmt$includes !== void 0 && _args$fmt$includes.call(_args$fmt, " ") || (_args$fmt2 = args.fmt) !== null && _args$fmt2 !== void 0 && (_args$fmt2 = _args$fmt2.value) !== null && _args$fmt2 !== void 0 && (_args$fmt2$toLowerCas = _args$fmt2.toLowerCase) !== null && _args$fmt2$toLowerCas !== void 0 && _args$fmt2$toLowerCas.call(_args$fmt2).includes("hh:mm")) return [void 0, "Invalid date format ".concat(JSON.stringify(args.fmt))];
      var dateVal = this.utils.moment(val.value, this.utils.moment.ISO_8601);
      if (dateVal.isValid()) {
        return [dateVal.format(wgtDef === null || wgtDef === void 0 ? void 0 : wgtDef.valueFormat), []];
      } else {
        return [void 0, "Invalid date"];
      }
    },
    jsonLogic: function jsonLogic11(val, fieldDef, wgtDef) {
      return this.utils.moment(val, wgtDef.valueFormat).toDate();
    },
    toJS: function toJS8(val, fieldSettings) {
      var dateVal = this.utils.moment(val, fieldSettings.valueFormat);
      return dateVal.isValid() ? dateVal.toDate() : void 0;
    },
    mongoFormatValue: function mongoFormatValue7(val, fieldDef, wgtDef) {
      var dateVal = this.utils.moment(val, wgtDef.valueFormat);
      return dateVal.isValid() ? dateVal.toDate() : void 0;
    }
  },
  time: {
    type: "time",
    jsType: "string",
    valueSrc: "value",
    timeFormat: "HH:mm",
    valueFormat: "HH:mm:ss",
    use12Hours: false,
    valueLabel: "Time",
    valuePlaceholder: "Enter time",
    valueLabels: [{
      label: "Time from",
      placeholder: "Enter time from"
    }, {
      label: "Time to",
      placeholder: "Enter time to"
    }],
    formatValue: function formatValue14(val, fieldDef, wgtDef, isForDisplay) {
      var dateVal = this.utils.moment(val, wgtDef.valueFormat);
      return isForDisplay ? dateVal.format(wgtDef.timeFormat) : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue8(val, fieldDef, wgtDef, op2, opDef) {
      var dateVal = this.utils.moment(val, wgtDef.valueFormat);
      return this.utils.SqlString.escape(dateVal.format("HH:mm:ss"));
    },
    spelFormatValue: function spelFormatValue8(val, fieldDef, wgtDef, op2, opDef) {
      var dateVal = this.utils.moment(val, wgtDef.valueFormat);
      var v = dateVal.format("HH:mm:ss");
      return "T(java.time.LocalTime).parse('".concat(v, "')");
    },
    spelImportFuncs: [
      "T(java.time.LocalTime).parse(${v})"
      //"new java.text.SimpleDateFormat(${fmt}).parse(${v})"
    ],
    spelImportValue: function spelImportValue2(val, wgtDef, args) {
      var _args$fmt3, _args$fmt3$toLowerCas, _args$fmt4;
      if (!wgtDef) return [void 0, "No widget def to get value format"];
      if (args !== null && args !== void 0 && args.fmt && (!((_args$fmt3 = args.fmt) !== null && _args$fmt3 !== void 0 && (_args$fmt3 = _args$fmt3.value) !== null && _args$fmt3 !== void 0 && (_args$fmt3$toLowerCas = _args$fmt3.toLowerCase) !== null && _args$fmt3$toLowerCas !== void 0 && _args$fmt3$toLowerCas.call(_args$fmt3).includes("hh:mm")) || (_args$fmt4 = args.fmt) !== null && _args$fmt4 !== void 0 && (_args$fmt4 = _args$fmt4.value) !== null && _args$fmt4 !== void 0 && _args$fmt4.includes(" "))) return [void 0, "Invalid time format ".concat(JSON.stringify(args.fmt))];
      var dateVal = this.utils.moment(val.value, "HH:mm:ss");
      if (dateVal.isValid()) {
        return [dateVal.format(wgtDef === null || wgtDef === void 0 ? void 0 : wgtDef.valueFormat), []];
      } else {
        return [void 0, "Invalid date"];
      }
    },
    jsonLogic: function jsonLogic12(val, fieldDef, wgtDef) {
      var dateVal = this.utils.moment(val, wgtDef.valueFormat);
      return dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second");
    },
    toJS: function toJS9(val, fieldSettings) {
      var dateVal = this.utils.moment(val, fieldSettings.valueFormat);
      return dateVal.isValid() ? dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second") : void 0;
    },
    mongoFormatValue: function mongoFormatValue8(val, fieldDef, wgtDef) {
      var dateVal = this.utils.moment(val, wgtDef.valueFormat);
      return dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second");
    },
    elasticSearchFormatValue: function elasticSearchFormatValue(queryType, value, operator, fieldName) {
      return {
        script: {
          script: {
            source: "doc[".concat(fieldName, "][0].getHour() >== params.min && doc[").concat(fieldName, "][0].getHour() <== params.max"),
            params: {
              min: value[0],
              max: value[1]
            }
          }
        }
      };
    }
  },
  datetime: {
    type: "datetime",
    jsType: "string",
    valueSrc: "value",
    timeFormat: "HH:mm",
    dateFormat: "DD.MM.YYYY",
    valueFormat: "YYYY-MM-DD HH:mm:ss",
    use12Hours: false,
    valueLabel: "Datetime",
    valuePlaceholder: "Enter datetime",
    valueLabels: [{
      label: "Datetime from",
      placeholder: "Enter datetime from"
    }, {
      label: "Datetime to",
      placeholder: "Enter datetime to"
    }],
    formatValue: function formatValue15(val, fieldDef, wgtDef, isForDisplay) {
      var dateVal = this.utils.moment(val, wgtDef.valueFormat);
      return isForDisplay ? dateVal.format(wgtDef.dateFormat + " " + wgtDef.timeFormat) : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue9(val, fieldDef, wgtDef, op2, opDef) {
      var dateVal = this.utils.moment(val, wgtDef.valueFormat);
      return this.utils.SqlString.escape(dateVal.toDate());
    },
    spelFormatValue: function spelFormatValue9(val, fieldDef, wgtDef, op2, opDef) {
      var dateVal = this.utils.moment(val, wgtDef.valueFormat);
      var v = dateVal.format("YYYY-MM-DD HH:mm:ss");
      var fmt = "yyyy-MM-dd HH:mm:ss";
      return "T(java.time.LocalDateTime).parse('".concat(v, "', T(java.time.format.DateTimeFormatter).ofPattern('").concat(fmt, "'))");
    },
    spelImportFuncs: [
      //"new java.text.SimpleDateFormat(${fmt}).parse(${v})",
      {
        obj: {
          cls: ["java", "time", "LocalDateTime"]
        },
        methodName: "parse",
        args: [{
          "var": "v"
        }, {
          obj: {
            cls: ["java", "time", "format", "DateTimeFormatter"]
          },
          methodName: "ofPattern",
          args: [{
            "var": "fmt"
          }]
        }]
      }
    ],
    spelImportValue: function spelImportValue3(val, wgtDef, args) {
      var _args$fmt5, _args$fmt5$includes;
      if (!wgtDef) return [void 0, "No widget def to get value format"];
      if (!(args !== null && args !== void 0 && (_args$fmt5 = args.fmt) !== null && _args$fmt5 !== void 0 && (_args$fmt5 = _args$fmt5.value) !== null && _args$fmt5 !== void 0 && (_args$fmt5$includes = _args$fmt5.includes) !== null && _args$fmt5$includes !== void 0 && _args$fmt5$includes.call(_args$fmt5, " "))) return [void 0, "Invalid datetime format ".concat(JSON.stringify(args.fmt))];
      var dateVal = this.utils.moment(val.value, this.utils.moment.ISO_8601);
      if (dateVal.isValid()) {
        return [dateVal.format(wgtDef === null || wgtDef === void 0 ? void 0 : wgtDef.valueFormat), []];
      } else {
        return [void 0, "Invalid date"];
      }
    },
    jsonLogic: function jsonLogic13(val, fieldDef, wgtDef) {
      return this.utils.moment(val, wgtDef.valueFormat).toDate();
    },
    toJS: function toJS10(val, fieldSettings) {
      var dateVal = this.utils.moment(val, fieldSettings.valueFormat);
      return dateVal.isValid() ? dateVal.toDate() : void 0;
    },
    mongoFormatValue: function mongoFormatValue9(val, fieldDef, wgtDef) {
      var dateVal = this.utils.moment(val, wgtDef.valueFormat);
      return dateVal.isValid() ? dateVal.toDate() : void 0;
    }
  },
  "boolean": {
    type: "boolean",
    jsType: "boolean",
    valueSrc: "value",
    labelYes: "Yes",
    labelNo: "No",
    formatValue: function formatValue16(val, fieldDef, wgtDef, isForDisplay) {
      return isForDisplay ? val ? "Yes" : "No" : JSON.stringify(!!val);
    },
    sqlFormatValue: function sqlFormatValue10(val, fieldDef, wgtDef, op2, opDef) {
      return this.utils.SqlString.escape(val);
    },
    spelFormatValue: function spelFormatValue10(val, fieldDef, wgtDef, op2, opDef) {
      return this.utils.spelEscape(val);
    },
    defaultValue: false,
    toJS: function toJS11(val, fieldSettings) {
      return val;
    },
    mongoFormatValue: function mongoFormatValue10(val, fieldDef, wgtDef) {
      return val;
    }
  },
  field: {
    valueSrc: "field",
    formatValue: function formatValue17(val, fieldDef, wgtDef, isForDisplay, op2, opDef, rightFieldDef) {
      return isForDisplay ? rightFieldDef.label || val : val;
    },
    sqlFormatValue: function sqlFormatValue11(val, fieldDef, wgtDef, op2, opDef, rightFieldDef) {
      return val;
    },
    spelFormatValue: function spelFormatValue11(val, fieldDef, wgtDef, op2, opDef) {
      return val;
    },
    valueLabel: "Field to compare",
    valuePlaceholder: "Select field to compare"
  },
  func: {
    valueSrc: "func",
    valueLabel: "Function",
    valuePlaceholder: "Select function"
  },
  /**
   * @deprecated
   */
  case_value: {
    valueSrc: "value",
    type: "case_value",
    spelFormatValue: function spelFormatValue12(val) {
      return this.utils.spelEscape(val === "" ? null : val);
    },
    spelImportValue: function spelImportValue4(val) {
      return [val.value, []];
    },
    jsonLogic: function jsonLogic14(val) {
      return val === "" ? null : val;
    }
  }
};
var types$4 = {
  text: {
    defaultOperator: "equal",
    mainWidget: "text",
    widgets: {
      text: {
        operators: ["equal", "not_equal", "like", "not_like", "starts_with", "ends_with", "proximity", "is_empty", "is_not_empty", "is_null", "is_not_null"],
        widgetProps: {},
        opProps: {}
      },
      textarea: {
        operators: ["equal", "not_equal", "like", "not_like", "starts_with", "ends_with", "is_empty", "is_not_empty", "is_null", "is_not_null"],
        widgetProps: {},
        opProps: {}
      },
      field: {
        operators: [
          //unary ops (like `is_empty`) will be excluded anyway, see getWidgetsForFieldOp()
          "equal",
          "not_equal",
          "proximity"
          //can exclude if you want
        ]
      }
    }
  },
  number: {
    defaultOperator: "equal",
    mainWidget: "number",
    widgets: {
      number: {
        operators: [
          "equal",
          "not_equal",
          "less",
          "less_or_equal",
          "greater",
          "greater_or_equal",
          "between",
          "not_between",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      },
      slider: {
        operators: [
          "equal",
          "not_equal",
          "less",
          "less_or_equal",
          "greater",
          "greater_or_equal",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      }
    }
  },
  date: {
    defaultOperator: "equal",
    widgets: {
      date: {
        operators: [
          "equal",
          "not_equal",
          "less",
          "less_or_equal",
          "greater",
          "greater_or_equal",
          "between",
          "not_between",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      }
    }
  },
  time: {
    defaultOperator: "equal",
    widgets: {
      time: {
        operators: [
          "equal",
          "not_equal",
          "less",
          "less_or_equal",
          "greater",
          "greater_or_equal",
          "between",
          "not_between",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      }
    }
  },
  datetime: {
    defaultOperator: "equal",
    widgets: {
      datetime: {
        operators: [
          "equal",
          "not_equal",
          "less",
          "less_or_equal",
          "greater",
          "greater_or_equal",
          "between",
          "not_between",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      }
    }
  },
  select: {
    mainWidget: "select",
    defaultOperator: "select_equals",
    widgets: {
      select: {
        operators: [
          "select_equals",
          "select_not_equals",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      },
      multiselect: {
        operators: [
          "select_any_in",
          "select_not_any_in",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      }
    }
  },
  multiselect: {
    defaultOperator: "multiselect_equals",
    widgets: {
      multiselect: {
        operators: [
          "multiselect_contains",
          "multiselect_not_contains",
          "multiselect_equals",
          "multiselect_not_equals",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      }
    }
  },
  "boolean": {
    defaultOperator: "equal",
    widgets: {
      "boolean": {
        operators: ["equal", "not_equal", "is_null", "is_not_null"],
        widgetProps: {
          //you can enable this if you don't use fields as value sources
          // hideOperator: true,
          // operatorInlineLabel: "is",
        }
      },
      field: {
        operators: ["equal", "not_equal"]
      }
    }
  },
  "!group": {
    defaultOperator: "some",
    mainWidget: "number",
    widgets: {
      number: {
        widgetProps: {
          min: 0
        },
        operators: [
          // w/o operand
          "some",
          "all",
          "none",
          // w/ operand - count
          "equal",
          "not_equal",
          "less",
          "less_or_equal",
          "greater",
          "greater_or_equal",
          "between",
          "not_between"
        ],
        opProps: {
          equal: {
            label: "Count =="
          },
          not_equal: {
            label: "Count !="
          },
          less: {
            label: "Count <"
          },
          less_or_equal: {
            label: "Count <="
          },
          greater: {
            label: "Count >"
          },
          greater_or_equal: {
            label: "Count >="
          },
          between: {
            label: "Count between"
          },
          not_between: {
            label: "Count not between"
          }
        }
      }
    }
  },
  /**
   * @deprecated
   */
  "case_value": {
    mainWidget: "case_value",
    widgets: {
      case_value: {
        widgetProps: {}
      }
    }
  }
};
var settings$3 = _objectSpread$l(_objectSpread$l({}, settings$4), {}, {
  convertableWidgets: {
    "number": ["slider", "rangeslider"],
    "slider": ["number", "rangeslider"],
    "rangeslider": ["number", "slider"],
    "text": ["textarea"],
    "textarea": ["text"]
  },
  formatSpelField: function formatSpelField(field, parentField, parts, partsExt, fieldDefinition, config2) {
    var _this11 = this;
    var fieldName = partsExt.map(function(_ref, ind) {
      var key = _ref.key, parent2 = _ref.parent, sep = _ref.fieldSeparator;
      if (ind == 0) {
        if (parent2 == "[map]") return "#this[".concat(_this11.utils.spelEscape(key), "]");
        else if (parent2 == "[class]") return key;
        else return key;
      } else {
        if (parent2 == "map" || parent2 == "[map]") return "[".concat(_this11.utils.spelEscape(key), "]");
        else if (parent2 == "class" || parent2 == "[class]") return "".concat(sep).concat(key);
        else return "".concat(sep).concat(key);
      }
    }).join("");
    if (fieldDefinition.fieldName) {
      fieldName = field;
    }
    if (fieldDefinition.isSpelVariable) {
      fieldName = "#" + fieldName;
    }
    return fieldName;
  },
  sqlFormatReverse: function sqlFormatReverse(q) {
    if (q == void 0) return void 0;
    return "NOT" + this.utils.wrapWithBrackets(q);
  },
  spelFormatReverse: function spelFormatReverse(q) {
    if (q == void 0) return void 0;
    return "!" + this.utils.wrapWithBrackets(q);
  },
  formatReverse: function formatReverse(q, operator, reversedOp, operatorDefinition, revOperatorDefinition, isForDisplay) {
    if (q == void 0) return void 0;
    if (isForDisplay) return "NOT " + this.utils.wrapWithBrackets(q);
    else return "!" + this.utils.wrapWithBrackets(q);
  },
  formatAggr: function formatAggr(whereStr, aggrField, operator, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay, aggrFieldDef) {
    var labelForFormat = opDef.labelForFormat, cardinality = opDef.cardinality;
    if (cardinality == 0) {
      var cond = whereStr ? " HAVE ".concat(whereStr) : "";
      return "".concat(labelForFormat, " OF ").concat(aggrField).concat(cond);
    } else if (cardinality == void 0 || cardinality == 1) {
      var _cond = whereStr ? " WHERE ".concat(whereStr) : "";
      return "COUNT OF ".concat(aggrField).concat(_cond, " ").concat(labelForFormat, " ").concat(value);
    } else if (cardinality == 2) {
      var _cond2 = whereStr ? " WHERE ".concat(whereStr) : "";
      var valFrom = value.first();
      var valTo = value.get(1);
      return "COUNT OF ".concat(aggrField).concat(_cond2, " ").concat(labelForFormat, " ").concat(valFrom, " AND ").concat(valTo);
    }
  },
  jsonLogic: {
    groupVarKey: "var",
    altVarKey: "var",
    lockedOp: "locked"
  },
  canCompareFieldWithField: function canCompareFieldWithField(leftField, leftFieldConfig, rightField, rightFieldConfig) {
    return true;
  },
  // enable compare fields
  valueSourcesInfo: {
    value: {
      label: "Value"
    },
    field: {
      label: "Field",
      widget: "field"
    },
    func: {
      label: "Function",
      widget: "func"
    }
  }
});
var _addMixins = function _addMixins2(config2, mixins) {
  var doAdd = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var mixinFuncs = {
    rangeslider: mixinWidgetRangeslider,
    treeselect: mixinWidgetTreeselect,
    treemultiselect: mixinWidgetTreemultiselect,
    rangeable__date: mixinRangeableWidget("date", "date")
  };
  var _iterator = _createForOfIteratorHelper$2(mixins), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var mixName = _step.value;
      var mixinFunc = mixinFuncs[mixName];
      if (mixinFunc) {
        config2 = mixinFunc(config2, doAdd);
      } else {
        throw new Error("Can't ".concat(doAdd ? "add" : "remove", " mixin ").concat(mixName));
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return config2;
};
var addMixins = function addMixins2(config2, mixins) {
  return _addMixins(config2, mixins, true);
};
var removeMixins = function removeMixins2(config2, mixins) {
  return _addMixins(config2, mixins, false);
};
var mixinRangeableWidget = function mixinRangeableWidget2(type2, widget) {
  return function(config2) {
    var addMixin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    var types2 = config2.types;
    types2 = _objectSpread$l(_objectSpread$l({}, types2), {}, _defineProperty$4({}, type2, _objectSpread$l(_objectSpread$l({}, types2[type2]), {}, {
      widgets: _objectSpread$l({}, types2[type2].widgets)
    })));
    if (addMixin) {
      types2[type2].widgets[widget] = _objectSpread$l({
        opProps: {
          between: {
            isSpecialRange: true,
            textSeparators: [null, null]
          },
          not_between: {
            isSpecialRange: true,
            textSeparators: [null, null]
          }
        }
      }, types2[type2].widgets[widget]);
    } else {
      delete types2[type2].widgets[widget];
    }
    return _objectSpread$l(_objectSpread$l({}, config2), {}, {
      types: types2
    });
  };
};
var mixinWidgetRangeslider = function mixinWidgetRangeslider2(config2) {
  var addMixin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var widgets2 = config2.widgets, types2 = config2.types;
  widgets2 = _objectSpread$l({}, widgets2);
  if (addMixin) {
    widgets2.rangeslider = _objectSpread$l({
      type: "number",
      jsType: "number",
      valueSrc: "value",
      valueLabel: "Range",
      valuePlaceholder: "Select range",
      valueLabels: [{
        label: "Number from",
        placeholder: "Enter number from"
      }, {
        label: "Number to",
        placeholder: "Enter number to"
      }],
      formatValue: function formatValue18(val, fieldDef, wgtDef, isForDisplay) {
        return isForDisplay ? this.utils.stringifyForDisplay(val) : JSON.stringify(val);
      },
      sqlFormatValue: function sqlFormatValue12(val, fieldDef, wgtDef, op2, opDef) {
        return this.utils.SqlString.escape(val);
      },
      spelFormatValue: function spelFormatValue13(val) {
        return this.utils.spelEscape(val);
      },
      singleWidget: "slider",
      toJS: function toJS12(val, fieldSettings) {
        return val;
      }
    }, widgets2.rangeslider);
  } else {
    delete widgets2.rangeslider;
  }
  types2 = _objectSpread$l(_objectSpread$l({}, types2), {}, {
    number: _objectSpread$l(_objectSpread$l({}, types2.number), {}, {
      widgets: _objectSpread$l({}, types2.number.widgets)
    })
  });
  if (addMixin) {
    types2.number.widgets.rangeslider = _objectSpread$l({
      opProps: {
        between: {
          isSpecialRange: true
        },
        not_between: {
          isSpecialRange: true
        }
      },
      operators: [
        "between",
        "not_between",
        // "is_empty",
        // "is_not_empty",
        "is_null",
        "is_not_null"
      ]
    }, types2.number.widgets.rangeslider);
  } else {
    delete types2.number.widgets.rangeslider;
  }
  return _objectSpread$l(_objectSpread$l({}, config2), {}, {
    widgets: widgets2,
    types: types2
  });
};
var mixinWidgetTreeselect = function mixinWidgetTreeselect2(config2) {
  var addMixin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var widgets2 = config2.widgets, types2 = config2.types;
  widgets2 = _objectSpread$l({}, widgets2);
  if (addMixin) {
    widgets2.treeselect = _objectSpread$l({
      type: "treeselect",
      jsType: "string",
      valueSrc: "value",
      valueLabel: "Value",
      valuePlaceholder: "Select value",
      formatValue: function formatValue18(val, fieldDef, wgtDef, isForDisplay) {
        var treeData = fieldDef.fieldSettings.treeValues || fieldDef.fieldSettings.listValues || fieldDef.asyncListValues;
        var valLabel = this.utils.getTitleInListValues(treeData, val);
        return isForDisplay ? this.utils.stringifyForDisplay(valLabel) : JSON.stringify(val);
      },
      sqlFormatValue: function sqlFormatValue12(val, fieldDef, wgtDef, op2, opDef) {
        return this.utils.SqlString.escape(val);
      },
      spelFormatValue: function spelFormatValue13(val) {
        return this.utils.spelEscape(val);
      },
      toJS: function toJS12(val, fieldSettings) {
        return val;
      }
    }, widgets2.treeselect);
  } else {
    delete widgets2.treeselect;
  }
  types2 = _objectSpread$l({}, types2);
  if (addMixin) {
    types2.treeselect = _objectSpread$l({
      mainWidget: "treeselect",
      defaultOperator: "select_equals",
      widgets: {
        treeselect: {
          operators: ["select_equals", "select_not_equals"]
        },
        treemultiselect: {
          operators: ["select_any_in", "select_not_any_in"]
        }
      }
    }, types2.treeselect);
  } else {
    delete types2.treeselect;
  }
  return _objectSpread$l(_objectSpread$l({}, config2), {}, {
    widgets: widgets2,
    types: types2
  });
};
var mixinWidgetTreemultiselect = function mixinWidgetTreemultiselect2(config2) {
  var addMixin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var widgets2 = config2.widgets, types2 = config2.types;
  widgets2 = _objectSpread$l({}, widgets2);
  if (addMixin) {
    widgets2.treemultiselect = _objectSpread$l({
      type: "treemultiselect",
      jsType: "array",
      valueSrc: "value",
      valueLabel: "Values",
      valuePlaceholder: "Select values",
      formatValue: function formatValue18(vals, fieldDef, wgtDef, isForDisplay) {
        var _this12 = this;
        var treeData = fieldDef.fieldSettings.treeValues || fieldDef.fieldSettings.listValues || fieldDef.asyncListValues;
        var valsLabels = vals.map(function(v) {
          return _this12.utils.getTitleInListValues(treeData, v);
        });
        return isForDisplay ? valsLabels.map(this.utils.stringifyForDisplay) : vals.map(JSON.stringify);
      },
      sqlFormatValue: function sqlFormatValue12(vals, fieldDef, wgtDef, op2, opDef) {
        var _this13 = this;
        return vals.map(function(v) {
          return _this13.utils.SqlString.escape(v);
        });
      },
      spelFormatValue: function spelFormatValue13(val) {
        return this.utils.spelEscape(val);
      },
      toJS: function toJS12(val, fieldSettings) {
        return val;
      }
    }, widgets2.treemultiselect);
  } else {
    delete widgets2.treemultiselect;
  }
  types2 = _objectSpread$l({}, types2);
  if (addMixin) {
    types2.treemultiselect = _objectSpread$l({
      defaultOperator: "multiselect_equals",
      widgets: {
        treemultiselect: {
          operators: ["multiselect_equals", "multiselect_not_equals"]
        }
      }
    }, types2.treemultiselect);
  } else {
    delete types2.treemultiselect;
  }
  return _objectSpread$l(_objectSpread$l({}, config2), {}, {
    widgets: widgets2,
    types: types2
  });
};
var ConfigMixins = {
  addMixins,
  removeMixins
};
var config$3 = {
  conjunctions: conjunctions$2,
  operators: operators$2,
  widgets: widgets$3,
  types: types$4,
  settings: settings$3,
  ctx: ctx$2
};
config$3 = addMixins(config$3, ["rangeslider", "treeselect", "treemultiselect"]);
const CoreConfig = config$3;
var ADD_GROUP = "ADD_GROUP";
var ADD_CASE_GROUP = "ADD_CASE_GROUP";
var REMOVE_GROUP = "REMOVE_GROUP";
var SET_CONJUNCTION = "SET_CONJUNCTION";
var SET_NOT = "SET_NOT";
var ADD_RULE = "ADD_RULE";
var REMOVE_RULE = "REMOVE_RULE";
var SET_FIELD = "SET_FIELD";
var SET_FIELD_SRC = "SET_FIELD_SRC";
var SET_OPERATOR = "SET_OPERATOR";
var SET_VALUE = "SET_VALUE";
var SET_VALUE_SRC = "SET_VALUE_SRC";
var SET_FUNC_VALUE = "SET_FUNC_VALUE";
var SET_OPERATOR_OPTION = "SET_OPERATOR_OPTION";
var SET_LOCK = "SET_LOCK";
var SET_TREE = "SET_TREE";
var MOVE_ITEM = "MOVE_ITEM";
var PLACEMENT_AFTER$1 = "after";
var PLACEMENT_BEFORE$1 = "before";
var PLACEMENT_APPEND$1 = "append";
var PLACEMENT_PREPEND$1 = "prepend";
var SET_DRAG_PROGRESS$1 = "SET_DRAG_PROGRESS";
var SET_DRAG_START$1 = "SET_DRAG_START";
var SET_DRAG_END$1 = "SET_DRAG_END";
var baseFor$1 = _baseFor, keys$2 = keys_1;
function baseForOwn$4(object, iteratee) {
  return object && baseFor$1(object, iteratee, keys$2);
}
var _baseForOwn = baseForOwn$4;
var Stack$1 = _Stack, baseIsEqual$2 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$7 = 1, COMPARE_UNORDERED_FLAG$5 = 2;
function baseIsMatch$2(object, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack$1();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$7 | COMPARE_UNORDERED_FLAG$5, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$2;
var isObject$3 = isObject_1;
function isStrictComparable$3(value) {
  return value === value && !isObject$3(value);
}
var _isStrictComparable = isStrictComparable$3;
var isStrictComparable$2 = _isStrictComparable, keys$1 = keys_1;
function getMatchData$2(object) {
  var result = keys$1(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable$2(value)];
  }
  return result;
}
var _getMatchData = getMatchData$2;
function matchesStrictComparable$3(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var _matchesStrictComparable = matchesStrictComparable$3;
var baseIsMatch$1 = _baseIsMatch, getMatchData$1 = _getMatchData, matchesStrictComparable$2 = _matchesStrictComparable;
function baseMatches$2(source) {
  var matchData = getMatchData$1(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$2(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch$1(object, source, matchData);
  };
}
var _baseMatches = baseMatches$2;
var baseGet$2 = _baseGet;
function get$3(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet$2(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get$3;
var baseIsEqual$1 = _baseIsEqual, get$2 = get_1, hasIn$1 = hasIn_1, isKey$2 = _isKey, isStrictComparable$1 = _isStrictComparable, matchesStrictComparable$1 = _matchesStrictComparable, toKey$2 = _toKey;
var COMPARE_PARTIAL_FLAG$6 = 1, COMPARE_UNORDERED_FLAG$4 = 2;
function baseMatchesProperty$2(path, srcValue) {
  if (isKey$2(path) && isStrictComparable$1(srcValue)) {
    return matchesStrictComparable$1(toKey$2(path), srcValue);
  }
  return function(object) {
    var objValue = get$2(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn$1(object, path) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$6 | COMPARE_UNORDERED_FLAG$4);
  };
}
var _baseMatchesProperty = baseMatchesProperty$2;
function baseProperty$2(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var _baseProperty = baseProperty$2;
var baseGet$1 = _baseGet;
function basePropertyDeep$2(path) {
  return function(object) {
    return baseGet$1(object, path);
  };
}
var _basePropertyDeep = basePropertyDeep$2;
var baseProperty$1 = _baseProperty, basePropertyDeep$1 = _basePropertyDeep, isKey$1 = _isKey, toKey$1 = _toKey;
function property$2(path) {
  return isKey$1(path) ? baseProperty$1(toKey$1(path)) : basePropertyDeep$1(path);
}
var property_1 = property$2;
var baseMatches$1 = _baseMatches, baseMatchesProperty$1 = _baseMatchesProperty, identity$2 = identity_1, isArray$3 = isArray_1, property$1 = property_1;
function baseIteratee$4(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$2;
  }
  if (typeof value == "object") {
    return isArray$3(value) ? baseMatchesProperty$1(value[0], value[1]) : baseMatches$1(value);
  }
  return property$1(value);
}
var _baseIteratee = baseIteratee$4;
var baseAssignValue$1 = _baseAssignValue, baseForOwn$3 = _baseForOwn, baseIteratee$3 = _baseIteratee;
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee$3(iteratee);
  baseForOwn$3(object, function(value, key, object2) {
    baseAssignValue$1(result, key, iteratee(value, key, object2));
  });
  return result;
}
var mapValues_1 = mapValues;
const mapValues$1 = /* @__PURE__ */ getDefaultExportFromCjs(mapValues_1);
function ownKeys$k(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$k(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$k(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$k(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _createForOfIteratorHelper$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null) it["return"]();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
var addNewGroup = function addNewGroup2(state, path, type2, generatedId, properties, config2) {
  var _properties$get;
  var children = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  var meta = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : {};
  var targetItem = state.getIn(expandTreePath(path));
  if (!targetItem) {
    return state;
  }
  var groupUuid = (properties === null || properties === void 0 || (_properties$get = properties.get) === null || _properties$get === void 0 ? void 0 : _properties$get.call(properties, "id")) || generatedId;
  var shouldCreateEmptyGroup = config2.settings.shouldCreateEmptyGroup;
  var groupPath = path.push(groupUuid);
  var canAddNewRule = !shouldCreateEmptyGroup;
  var isDefaultCase = !!(meta !== null && meta !== void 0 && meta.isDefaultCase);
  var origState = state;
  state = addItem(state, path, type2, groupUuid, defaultGroupProperties(config2).merge(fromJS(properties) || {}), config2, children);
  if (state !== origState) {
    if (!children && !isDefaultCase) {
      state = state.setIn(expandTreePath(groupPath, "children1"), new Immutable.OrderedMap());
      if (canAddNewRule) {
        state = addItem(state, groupPath, "rule", uuid(), defaultRuleProperties(config2), config2);
      }
    }
    state = fixPathsInTree(state);
  }
  return state;
};
var removeGroup$1 = function removeGroup(state, path, config2) {
  var targetItem = state.getIn(expandTreePath(path));
  if (!targetItem) {
    return state;
  }
  state = removeItem(state, path);
  var canLeaveEmptyGroup = config2.settings.canLeaveEmptyGroup;
  var parentPath = path.slice(0, -1);
  var isEmptyParentGroup = !hasChildren(state, parentPath);
  if (isEmptyParentGroup && !canLeaveEmptyGroup) {
    state = fixEmptyGroupsInTree(state);
    if (isEmptyTree(state) && !canLeaveEmptyGroup) {
      var canUseDefaultFieldAndOp = false;
      var canGetFirst = false;
      state = addItem(state, new Immutable.List(), "rule", uuid(), defaultRuleProperties(config2, void 0, void 0, canUseDefaultFieldAndOp, canGetFirst), config2);
    }
  }
  state = fixPathsInTree(state);
  return state;
};
var removeRule$1 = function removeRule(state, path, config2) {
  var targetItem = state.getIn(expandTreePath(path));
  if (!targetItem) {
    return state;
  }
  state = removeItem(state, path);
  var canLeaveEmptyGroup = config2.settings.canLeaveEmptyGroup;
  var parentPath = path.pop();
  var parent2 = state.getIn(expandTreePath(parentPath));
  var parentField = parent2.getIn(["properties", "field"]);
  var parentOperator = parent2.getIn(["properties", "operator"]);
  var parentFieldConfig = parentField ? getFieldConfig$8(config2, parentField) : null;
  var parentOperatorConfig = parentOperator ? getOperatorConfig$4(config2, parentOperator, parentField) : null;
  var hasGroupCountRule = parentField && parentOperator && parentOperatorConfig.cardinality != 0;
  var isParentRuleGroup = parent2.get("type") == "rule_group";
  var isEmptyParentGroup = !hasChildren(state, parentPath);
  var canLeaveEmpty = isParentRuleGroup ? hasGroupCountRule && parentFieldConfig.initialEmptyWhere : canLeaveEmptyGroup;
  if (isEmptyParentGroup && !canLeaveEmpty) {
    if (isParentRuleGroup) {
      state = state.deleteIn(expandTreePath(parentPath));
    }
    state = fixEmptyGroupsInTree(state);
    if (isEmptyTree(state) && !canLeaveEmptyGroup) {
      var canUseDefaultFieldAndOp = false;
      var canGetFirst = false;
      state = addItem(state, new Immutable.List(), "rule", uuid(), defaultRuleProperties(config2, void 0, void 0, canUseDefaultFieldAndOp, canGetFirst), config2);
    }
  }
  state = fixPathsInTree(state);
  return state;
};
var setNot$1 = function setNot(state, path, not2) {
  var targetItem = state.getIn(expandTreePath(path));
  if (!targetItem) {
    return state;
  }
  state = state.setIn(expandTreePath(path, "properties", "not"), not2);
  return state;
};
var setLock$1 = function setLock(state, path, lock) {
  var targetItem = state.getIn(expandTreePath(path));
  if (!targetItem) {
    return state;
  }
  state = removeIsLockedInTree(state.setIn(expandTreePath(path, "properties", "isLocked"), lock));
  return state;
};
var setConjunction$1 = function setConjunction(state, path, conjunction) {
  var targetItem = state.getIn(expandTreePath(path));
  if (!targetItem) {
    return state;
  }
  state = state.setIn(expandTreePath(path, "properties", "conjunction"), conjunction);
  return state;
};
var addItem = function addItem2(state, path, type2, generatedId, properties, config2) {
  var _properties$get2;
  var children = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  if (type2 === "switch_group") throw new Error("Can't add switch_group programmatically");
  var targetItem = state.getIn(expandTreePath(path));
  if (!targetItem) {
    return state;
  }
  var id2 = (properties === null || properties === void 0 || (_properties$get2 = properties.get) === null || _properties$get2 === void 0 ? void 0 : _properties$get2.call(properties, "id")) || generatedId;
  var _config$settings = config2.settings, maxNumberOfCases = _config$settings.maxNumberOfCases, maxNumberOfRules = _config$settings.maxNumberOfRules, maxNesting = _config$settings.maxNesting;
  var rootType = state.get("type");
  var isTernary = rootType === "switch_group";
  var caseGroup = isTernary ? state.getIn(expandTreePath(path.take(2))) : null;
  var childrenPath = expandTreePath(path, "children1");
  var targetChildren = state.getIn(childrenPath);
  var hasChildren3 = !!targetChildren && targetChildren.size;
  var targetChildrenSize = hasChildren3 ? targetChildren.size : null;
  var currentNumber, maxNumber;
  if (type2 === "case_group") {
    currentNumber = targetChildrenSize;
    maxNumber = maxNumberOfCases;
  } else if (type2 === "group") {
    currentNumber = path.size;
    maxNumber = maxNesting;
  } else if ((targetItem === null || targetItem === void 0 ? void 0 : targetItem.get("type")) === "rule_group") ;
  else {
    currentNumber = isTernary ? getTotalRulesCountInTree$2(caseGroup) : getTotalRulesCountInTree$2(state);
    maxNumber = maxNumberOfRules;
  }
  var canAdd = maxNumber && currentNumber ? currentNumber < maxNumber : true;
  var item = {
    type: type2,
    id: id2,
    properties
  };
  _addChildren1(config2, item, children);
  var isLastDefaultCase = type2 === "case_group" && hasChildren3 && targetChildren.last().get("children1") == null;
  if (canAdd) {
    var newChildren = new Immutable.OrderedMap(_defineProperty$4({}, id2, new Immutable.Map(item)));
    if (!hasChildren3) {
      state = state.setIn(childrenPath, newChildren);
    } else if (isLastDefaultCase) {
      var last4 = targetChildren.last();
      var newChildrenWithLast = new Immutable.OrderedMap(_defineProperty$4(_defineProperty$4({}, id2, new Immutable.Map(item)), last4.get("id"), last4));
      state = state.deleteIn(expandTreePath(childrenPath, "children1", last4.get("id")));
      state = state.mergeIn(childrenPath, newChildrenWithLast);
    } else {
      state = state.mergeIn(childrenPath, newChildren);
    }
    state = fixPathsInTree(state);
  }
  return state;
};
var removeItem = function removeItem2(state, path) {
  state = state.deleteIn(expandTreePath(path));
  state = fixPathsInTree(state);
  return state;
};
var moveItem$1 = function moveItem(state, fromPath, toPath, placement, config2) {
  var from2 = getItemByPath(state, fromPath);
  var sourcePath = fromPath.pop();
  var source = fromPath.size > 1 ? getItemByPath(state, sourcePath) : null;
  var sourceChildren = source ? source.get("children1") : null;
  var to2 = getItemByPath(state, toPath);
  var targetPath = placement == PLACEMENT_APPEND$1 || placement == PLACEMENT_PREPEND$1 ? toPath : toPath.pop();
  var target = placement == PLACEMENT_APPEND$1 || placement == PLACEMENT_PREPEND$1 ? to2 : toPath.size > 1 ? getItemByPath(state, targetPath) : null;
  var targetChildren = target ? target.get("children1") : null;
  if (!source || !target || !from2) {
    return state;
  }
  var isSameParent = source.get("id") == target.get("id");
  var isSourceInsideTarget = targetPath.size < sourcePath.size && deepEqual(targetPath.toArray(), sourcePath.toArray().slice(0, targetPath.size));
  var isTargetInsideSource = targetPath.size > sourcePath.size && deepEqual(sourcePath.toArray(), targetPath.toArray().slice(0, sourcePath.size));
  var sourceSubpathFromTarget = null;
  var targetSubpathFromSource = null;
  if (isSourceInsideTarget) {
    sourceSubpathFromTarget = Immutable.List(sourcePath.toArray().slice(targetPath.size));
  } else if (isTargetInsideSource) {
    targetSubpathFromSource = Immutable.List(targetPath.toArray().slice(sourcePath.size));
  }
  var newTargetChildren = targetChildren, newSourceChildren = sourceChildren;
  if (!isTargetInsideSource) newSourceChildren = newSourceChildren["delete"](from2.get("id"));
  if (isSameParent) {
    newTargetChildren = newSourceChildren;
  } else if (isSourceInsideTarget) {
    newTargetChildren = newTargetChildren.updateIn(expandTreeSubpath(sourceSubpathFromTarget, "children1"), function(_oldChildren) {
      return newSourceChildren;
    });
  }
  if (placement == PLACEMENT_BEFORE$1 || placement == PLACEMENT_AFTER$1) {
    newTargetChildren = Immutable.OrderedMap().withMutations(function(r2) {
      var _iterator = _createForOfIteratorHelper$1(newTargetChildren.entries()), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray$1(_step.value, 2), itemId = _step$value[0], item = _step$value[1];
          if (itemId == (to2 === null || to2 === void 0 ? void 0 : to2.get("id")) && placement == PLACEMENT_BEFORE$1) {
            r2.set(from2.get("id"), from2);
          }
          r2.set(itemId, item);
          if (itemId == (to2 === null || to2 === void 0 ? void 0 : to2.get("id")) && placement == PLACEMENT_AFTER$1) {
            r2.set(from2.get("id"), from2);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
  } else if (placement == PLACEMENT_APPEND$1) {
    newTargetChildren = newTargetChildren.merge(Immutable.OrderedMap(_defineProperty$4({}, from2.get("id"), from2)));
  } else if (placement == PLACEMENT_PREPEND$1) {
    newTargetChildren = Immutable.OrderedMap(_defineProperty$4({}, from2.get("id"), from2)).merge(newTargetChildren);
  }
  if (isTargetInsideSource) {
    newSourceChildren = newSourceChildren.updateIn(expandTreeSubpath(targetSubpathFromSource, "children1"), function(_oldChildren) {
      return newTargetChildren;
    });
    newSourceChildren = newSourceChildren["delete"](from2.get("id"));
  }
  if (!isSameParent && !isSourceInsideTarget) state = state.updateIn(expandTreePath(sourcePath, "children1"), function(_oldChildren) {
    return newSourceChildren;
  });
  if (!isTargetInsideSource) state = state.updateIn(expandTreePath(targetPath, "children1"), function(_oldChildren) {
    return newTargetChildren;
  });
  state = fixPathsInTree(state);
  return state;
};
var setFieldSrc$1 = function setFieldSrc(state, path, srcKey, config2) {
  var currentRule = state.getIn(expandTreePath(path));
  if (!currentRule) {
    return state;
  }
  var keepInputOnChangeFieldSrc = config2.settings.keepInputOnChangeFieldSrc;
  var currentProperties = currentRule.get("properties");
  var currentField = currentProperties === null || currentProperties === void 0 ? void 0 : currentProperties.get("field");
  var currentFielType = currentProperties === null || currentProperties === void 0 ? void 0 : currentProperties.get("fieldType");
  var currentFieldConfig = getFieldConfig$8(config2, currentField);
  var fieldType = (currentFieldConfig === null || currentFieldConfig === void 0 ? void 0 : currentFieldConfig.type) || currentFielType;
  if (!fieldType || fieldType === "!group" || fieldType === "!struct") {
    fieldType = null;
  }
  var canReuseValue = !selectTypes.includes(fieldType);
  var keepInput = keepInputOnChangeFieldSrc && !isEmptyItem(currentRule, config2) && canReuseValue;
  if (!keepInput) {
    state = state.setIn(expandTreePath(path, "properties"), defaultRuleProperties(config2, null, null, false));
  } else {
    state = state.setIn(expandTreePath(path, "properties", "field"), null);
    state = state.deleteIn(expandTreePath(path, "properties", "fieldError"));
    state = state.setIn(expandTreePath(path, "properties", "fieldType"), fieldType);
  }
  state = state.setIn(expandTreePath(path, "properties", "fieldSrc"), srcKey);
  return state;
};
var setFuncValue$1 = function setFuncValue(config2, state, path, delta2, parentFuncs, argKey, argValue, valueType, asyncListValues) {
  var _meta = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : {};
  var currentRule = state.getIn(expandTreePath(path));
  if (!currentRule) {
    return state;
  }
  var isLHS = delta2 === -1;
  var currentProperties = currentRule.get("properties");
  var currentField = currentProperties.get("field");
  var currentValue = currentProperties.get("value");
  var currentV = isLHS ? currentField : currentValue.getIn([delta2]);
  var funcsPath = [];
  var targetFV = currentV;
  var _iterator2 = _createForOfIteratorHelper$1(parentFuncs || []), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var _step2$value = _slicedToArray$1(_step2.value, 2), _funcK = _step2$value[0], _argK = _step2$value[1];
      funcsPath.push([_funcK, _argK, targetFV]);
      if (_funcK !== targetFV.get("func")) {
        var funcPath = funcsPath.map(function(_ref) {
          var _ref2 = _slicedToArray$1(_ref, 2), f = _ref2[0], a2 = _ref2[1];
          return "".concat(f, "(").concat(a2, ")");
        }).join("/") || "root";
        throw new Error("In ".concat(isLHS ? "LHS" : "RHS", " for path ").concat(funcPath, " expected func key ").concat(_funcK, " but got ").concat(parent.get("func")));
      }
      targetFV = targetFV.getIn(["args", _argK, "value"]);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  if (!argKey) {
    var newFuncKey = argValue;
    var canFixArgs = true;
    targetFV = setFunc(targetFV, newFuncKey, config2, canFixArgs);
    _meta.canDropArgs = true;
  } else {
    var funcKey = targetFV.get("func");
    var funcDefinition = getFuncConfig$2(config2, funcKey);
    var args = funcDefinition.args;
    var argDefinition = args[argKey];
    if (valueType === "!valueSrc") {
      targetFV = setArgValueSrc(targetFV, argKey, argValue);
    } else {
      targetFV = setArgValue(targetFV, argKey, argValue, argDefinition, config2);
    }
  }
  var newV = targetFV;
  while (funcsPath.length) {
    var _funcsPath$pop = funcsPath.pop(), _funcsPath$pop2 = _slicedToArray$1(_funcsPath$pop, 3), funcK = _funcsPath$pop2[0], argK = _funcsPath$pop2[1], parentFV = _funcsPath$pop2[2];
    var _funcDefinition = getFuncConfig$2(config2, funcK);
    var _args = _funcDefinition.args;
    var _argDefinition = _args[argK];
    newV = setArgValue(parentFV, argK, newV, _argDefinition, config2);
  }
  if (isLHS) {
    return setField$1(state, path, newV, config2, asyncListValues, _meta);
  } else {
    return setValue$1(state, path, delta2, newV, void 0, config2, asyncListValues, _meta);
  }
};
var setField$1 = function setField(state, path, newField, config2, asyncListValues) {
  var _newFieldConfig$opera, _currentField$get, _newField, _newField$get;
  var _meta = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
  var currentRule = state.getIn(expandTreePath(path));
  if (!currentRule) {
    return {
      state
    };
  }
  var isEndValue = _meta.isEndValue, canDropArgs = _meta.canDropArgs;
  if (!newField) {
    state = removeItem(state, path);
    return {
      state
    };
  }
  var _config$settings2 = config2.settings, fieldSeparator = _config$settings2.fieldSeparator, setOpOnChangeField = _config$settings2.setOpOnChangeField, showErrorMessage = _config$settings2.showErrorMessage;
  if (Array.isArray(newField)) newField = newField.join(fieldSeparator);
  var currentType = currentRule.get("type");
  var currentProperties = currentRule.get("properties");
  var wasRuleGroup = currentType == "rule_group";
  var currentFieldSrc = currentProperties === null || currentProperties === void 0 ? void 0 : currentProperties.get("fieldSrc");
  var newFieldConfig = getFieldConfig$8(config2, newField);
  if (!newFieldConfig) {
    console.warn("No config for LHS ".concat(newField));
    return {
      state
    };
  }
  var fieldType = newFieldConfig.type;
  if (fieldType === "!group" || fieldType === "!struct") {
    fieldType = null;
  }
  var currentOperator = currentProperties === null || currentProperties === void 0 ? void 0 : currentProperties.get("operator");
  var currentOperatorOptions = currentProperties === null || currentProperties === void 0 ? void 0 : currentProperties.get("operatorOptions");
  var currentField = currentProperties === null || currentProperties === void 0 ? void 0 : currentProperties.get("field");
  var isRuleGroup = newFieldConfig.type == "!group";
  var isRuleGroupExt = isRuleGroup && newFieldConfig.mode == "array";
  var isChangeToAnotherType = wasRuleGroup != isRuleGroup;
  var lastOp = newFieldConfig && ((_newFieldConfig$opera = newFieldConfig.operators) === null || _newFieldConfig$opera === void 0 ? void 0 : _newFieldConfig$opera.indexOf(currentOperator)) !== -1 ? currentOperator : null;
  var isSameFunc = currentFieldSrc === "func" && (currentField === null || currentField === void 0 || (_currentField$get = currentField.get) === null || _currentField$get === void 0 ? void 0 : _currentField$get.call(currentField, "func")) === ((_newField = newField) === null || _newField === void 0 || (_newField$get = _newField.get) === null || _newField$get === void 0 ? void 0 : _newField$get.call(_newField, "func"));
  var forceKeepOp = isSameFunc && !!lastOp;
  var newOperator = null;
  var availOps = currentFieldSrc === "func" ? getOperatorsForType(config2, fieldType) : getOperatorsForField(config2, newField);
  if (availOps && availOps.length == 1) newOperator = availOps[0];
  else if (forceKeepOp) newOperator = lastOp;
  else if (availOps && availOps.length > 1) {
    var _iterator3 = _createForOfIteratorHelper$1(setOpOnChangeField), _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        var strategy = _step3.value;
        if (strategy == "keep" && !isChangeToAnotherType) newOperator = lastOp;
        else if (strategy == "default") newOperator = getDefaultOperator(config2, newField, false);
        else if (strategy == "first") newOperator = getFirstOperator(config2, newField);
        if (newOperator)
          break;
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }
  if (!isRuleGroup && !newFieldConfig.operators) {
    console.warn("Type ".concat(newFieldConfig.type, " is not supported"));
    return {
      state
    };
  }
  if (wasRuleGroup && !isRuleGroup) {
    state = state.setIn(expandTreePath(path, "type"), "rule");
    state = state.deleteIn(expandTreePath(path, "children1"));
    state = state.setIn(expandTreePath(path, "properties"), new Immutable.OrderedMap());
  }
  if (!currentProperties) {
    state = state.setIn(expandTreePath(path, "properties"), new Immutable.OrderedMap());
  }
  var canFix = !showErrorMessage;
  if (isRuleGroup) {
    state = state.setIn(expandTreePath(path, "type"), "rule_group");
    var _getNewValueForFieldO = getNewValueForFieldOp(config2, config2, currentProperties, newField, newOperator, "field", canFix, isEndValue, canDropArgs);
    _getNewValueForFieldO.canReuseValue;
    var newValue = _getNewValueForFieldO.newValue, newValueSrc = _getNewValueForFieldO.newValueSrc, newValueType = _getNewValueForFieldO.newValueType, operatorCardinality = _getNewValueForFieldO.operatorCardinality;
    var groupProperties = defaultGroupProperties(config2, newFieldConfig).merge({
      field: newField,
      fieldSrc: "field",
      mode: newFieldConfig.mode
    });
    if (isRuleGroupExt) {
      groupProperties = groupProperties.merge({
        operator: newOperator,
        value: newValue,
        valueSrc: newValueSrc,
        valueType: newValueType
      });
    }
    state = state.setIn(expandTreePath(path, "children1"), new Immutable.OrderedMap());
    state = state.setIn(expandTreePath(path, "properties"), groupProperties);
    if (newFieldConfig.initialEmptyWhere && operatorCardinality == 1) ;
    else {
      state = addItem(state, path, "rule", uuid(), defaultRuleProperties(config2, newField), config2);
    }
    state = fixPathsInTree(state);
  } else {
    state = state.updateIn(expandTreePath(path, "properties"), function(map3) {
      return map3.withMutations(function(current) {
        var _getNewValueForFieldO2 = getNewValueForFieldOp(config2, config2, current, newField, newOperator, "field", canFix, isEndValue, canDropArgs), canReuseValue = _getNewValueForFieldO2.canReuseValue, newValue2 = _getNewValueForFieldO2.newValue, newValueSrc2 = _getNewValueForFieldO2.newValueSrc, newValueType2 = _getNewValueForFieldO2.newValueType, newValueError = _getNewValueForFieldO2.newValueError, newFieldError = _getNewValueForFieldO2.newFieldError, fixedField = _getNewValueForFieldO2.fixedField;
        var newCorrectField = newField;
        var willFixField = fixedField !== newField;
        if (willFixField) {
          newCorrectField = fixedField;
        }
        if (showErrorMessage) {
          current = current.set("fieldError", newFieldError);
          current = current.set("valueError", newValueError);
        }
        var newOperatorOptions = canReuseValue ? currentOperatorOptions : defaultOperatorOptions(config2, newOperator, newCorrectField);
        current = current.set("field", newCorrectField)["delete"]("fieldType").set("fieldSrc", currentFieldSrc).set("operator", newOperator).set("operatorOptions", newOperatorOptions).set("value", newValue2).set("valueSrc", newValueSrc2).set("valueType", newValueType2);
        if (!canReuseValue) {
          current = current["delete"]("asyncListValues");
        }
        return current;
      });
    });
  }
  return {
    state
  };
};
var setOperator$1 = function setOperator(state, path, newOperator, config2) {
  var currentRule = state.getIn(expandTreePath(path));
  if (!currentRule) {
    return state;
  }
  var showErrorMessage = config2.settings.showErrorMessage;
  var properties = currentRule.get("properties");
  var children = currentRule.get("children1");
  var currentField = properties.get("field");
  properties.get("fieldSrc");
  var fieldConfig = getFieldConfig$8(config2, currentField);
  var isRuleGroup = (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) == "!group";
  var operatorConfig = getOperatorConfig$4(config2, newOperator, currentField);
  var operatorCardinality = operatorConfig ? getOpCardinality$1(operatorConfig) : null;
  var canFix = true;
  state = state.updateIn(expandTreePath(path, "properties"), function(map3) {
    return map3.withMutations(function(current) {
      var currentField2 = current.get("field");
      var currentOperatorOptions = current.get("operatorOptions");
      current.get("value", new Immutable.List());
      current.get("valueSrc", new Immutable.List());
      current.get("operator");
      var _getNewValueForFieldO3 = getNewValueForFieldOp(config2, config2, current, currentField2, newOperator, "operator", canFix), canReuseValue = _getNewValueForFieldO3.canReuseValue, newValue = _getNewValueForFieldO3.newValue, newValueSrc = _getNewValueForFieldO3.newValueSrc, newValueType = _getNewValueForFieldO3.newValueType, newValueError = _getNewValueForFieldO3.newValueError;
      if (showErrorMessage) {
        current = current.set("valueError", newValueError);
      }
      var newOperatorOptions = canReuseValue ? currentOperatorOptions : defaultOperatorOptions(config2, newOperator, currentField2);
      if (!canReuseValue) {
        current = current["delete"]("asyncListValues");
      }
      return current.set("operator", newOperator).set("operatorOptions", newOperatorOptions).set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType);
    });
  });
  if (isRuleGroup) {
    if (operatorCardinality == 0 && children.size == 0) {
      state = addItem(state, path, "rule", uuid(), defaultRuleProperties(config2, currentField), config2);
    }
  }
  return state;
};
var setValue$1 = function setValue(state, path, delta2, value, valueType, config2, asyncListValues) {
  var _meta = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : {};
  var currentRule = state.getIn(expandTreePath(path));
  if (!currentRule) {
    return {
      state
    };
  }
  var canDropArgs = _meta.canDropArgs, isEndValue = _meta.isEndValue;
  var _config$settings3 = config2.settings, fieldSeparator = _config$settings3.fieldSeparator, showErrorMessage = _config$settings3.showErrorMessage;
  var valueSrc = state.getIn(expandTreePath(path, "properties", "valueSrc", delta2 + "")) || null;
  if (valueSrc === "field" && Array.isArray(value)) value = value.join(fieldSeparator);
  var field = state.getIn(expandTreePath(path, "properties", "field")) || null;
  var operator = state.getIn(expandTreePath(path, "properties", "operator")) || null;
  var operatorConfig = getOperatorConfig$4(config2, operator, field);
  var operatorCardinality = operator ? getOpCardinality$1(operatorConfig) : null;
  var calculatedValueType = valueType || calculateValueType(value, valueSrc, config2);
  var canFix = !showErrorMessage;
  var _validateValue = validateValue(config2, field, field, operator, value, calculatedValueType, valueSrc, asyncListValues, canFix, isEndValue, canDropArgs), _validateValue2 = _slicedToArray$1(_validateValue, 2), fixedValue = _validateValue2[0], allErrors = _validateValue2[1];
  var firstError = allErrors === null || allErrors === void 0 ? void 0 : allErrors.find(function(e2) {
    return !e2.fixed && !e2.ignore;
  });
  var validationError = firstError ? translateValidation(firstError) : null;
  var willFix = fixedValue !== value;
  if (willFix) {
    value = fixedValue;
  }
  state = initEmptyValueLists(state, path, config2, operatorCardinality);
  var values2 = Array.from({
    length: operatorCardinality
  }, function(_, i2) {
    return i2 == delta2 ? value : state.getIn(expandTreePath(path, "properties", "value", i2 + "")) || null;
  });
  var valueSrcs = Array.from({
    length: operatorCardinality
  }, function(_, i2) {
    return state.getIn(expandTreePath(path, "properties", "valueSrc", i2 + "")) || null;
  });
  var rangeErrorObj = validateRange(config2, field, operator, values2, valueSrcs);
  var rangeValidationError = rangeErrorObj ? translateValidation(rangeErrorObj) : null;
  var isValid3 = !validationError && !rangeValidationError;
  var canUpdValue = showErrorMessage ? true : isValid3 || willFix;
  if (canUpdValue) {
    state = state.deleteIn(expandTreePath(path, "properties", "asyncListValues"));
    if (typeof value === "undefined") {
      state = state.setIn(expandTreePath(path, "properties", "value", delta2), void 0);
      state = state.setIn(expandTreePath(path, "properties", "valueType", delta2), null);
    } else {
      if (asyncListValues) {
        state = state.setIn(expandTreePath(path, "properties", "asyncListValues"), asyncListValues);
      }
      state = state.setIn(expandTreePath(path, "properties", "value", delta2), value);
      state = state.setIn(expandTreePath(path, "properties", "valueType", delta2), calculatedValueType);
    }
  }
  if (showErrorMessage) {
    var lastValueErrorArr = state.getIn(expandTreePath(path, "properties", "valueError"));
    if (!lastValueErrorArr) {
      state = state.setIn(expandTreePath(path, "properties", "valueError"), new Immutable.List(new Array(operatorCardinality)));
    }
    state = state.setIn(expandTreePath(path, "properties", "valueError", delta2), validationError);
    if (operatorCardinality >= 2) {
      state = state.setIn(expandTreePath(path, "properties", "valueError", operatorCardinality), rangeValidationError);
    }
  }
  return {
    state
  };
};
var setValueSrc$1 = function setValueSrc(state, path, delta2, srcKey, config2) {
  var currentRule = state.getIn(expandTreePath(path));
  if (!currentRule) {
    return state;
  }
  var showErrorMessage = config2.settings.showErrorMessage;
  var field = state.getIn(expandTreePath(path, "properties", "field")) || null;
  var operator = state.getIn(expandTreePath(path, "properties", "operator")) || null;
  var operatorConfig = getOperatorConfig$4(config2, operator, field);
  var operatorCardinality = operator ? getOpCardinality$1(operatorConfig) : null;
  state = initEmptyValueLists(state, path, config2, operatorCardinality);
  state = state.setIn(expandTreePath(path, "properties", "value", delta2 + ""), void 0);
  state = state.setIn(expandTreePath(path, "properties", "valueType", delta2 + ""), null);
  state = state.deleteIn(expandTreePath(path, "properties", "asyncListValues"));
  if (showErrorMessage) {
    state = state.setIn(expandTreePath(path, "properties", "valueError", delta2), null);
    if (operatorConfig.validateValues) {
      state = state.setIn(expandTreePath(path, "properties", "valueError", operatorCardinality), null);
    }
  }
  if (typeof srcKey === "undefined") {
    state = state.setIn(expandTreePath(path, "properties", "valueSrc", delta2 + ""), null);
  } else {
    state = state.setIn(expandTreePath(path, "properties", "valueSrc", delta2 + ""), srcKey);
  }
  if (srcKey) {
    var properties = state.getIn(expandTreePath(path, "properties"));
    var canFix = true;
    var _getNewValueForFieldO4 = getNewValueForFieldOp(config2, config2, properties, field, operator, "valueSrc", canFix), canReuseValue = _getNewValueForFieldO4.canReuseValue, newValue = _getNewValueForFieldO4.newValue, newValueSrc = _getNewValueForFieldO4.newValueSrc, newValueType = _getNewValueForFieldO4.newValueType;
    _getNewValueForFieldO4.newValueError;
    if (!canReuseValue && newValueSrc.get(delta2) == srcKey) {
      state = state.setIn(expandTreePath(path, "properties", "value", delta2 + ""), newValue.get(delta2));
      state = state.setIn(expandTreePath(path, "properties", "valueType", delta2 + ""), newValueType.get(delta2));
    }
  }
  return state;
};
var setOperatorOption$1 = function setOperatorOption(state, path, name2, value) {
  var currentRule = state.getIn(expandTreePath(path));
  if (!currentRule) {
    return state;
  }
  return state.setIn(expandTreePath(path, "properties", "operatorOptions", name2), value);
};
var checkEmptyGroups = function checkEmptyGroups2(state, config2) {
  var canLeaveEmptyGroup = config2.settings.canLeaveEmptyGroup;
  if (!canLeaveEmptyGroup) {
    state = fixEmptyGroupsInTree(state);
  }
  return state;
};
var initEmptyValueLists = function initEmptyValueLists2(state, path, config2, operatorCardinality) {
  if (!operatorCardinality) {
    var field = state.getIn(expandTreePath(path, "properties", "field")) || null;
    var operator = state.getIn(expandTreePath(path, "properties", "operator")) || null;
    var operatorConfig = getOperatorConfig$4(config2, operator, field);
    operatorCardinality = operator ? getOpCardinality$1(operatorConfig) : null;
  }
  for (var _i = 0, _arr = ["value", "valueType", "valueError", "valueSrc"]; _i < _arr.length; _i++) {
    var k = _arr[_i];
    if (!state.getIn(expandTreePath(path, "properties", k))) {
      state = state.setIn(expandTreePath(path, "properties", k), new Immutable.List(operatorCardinality ? Array.from({
        length: operatorCardinality
      }) : []));
    }
  }
  return state;
};
var _addChildren1 = function _addChildren12(config2, item, children) {
  if (children && Array.isArray(children)) {
    item.children1 = new Immutable.OrderedMap(children.reduce(function(map3, it) {
      var _it$id;
      var id1 = (_it$id = it.id) !== null && _it$id !== void 0 ? _it$id : uuid();
      var it1 = _objectSpread$k(_objectSpread$k({}, it), {}, {
        properties: defaultItemProperties(config2, it).merge(fromJS(it.properties) || {}),
        id: id1
      });
      _addChildren12(config2, it1, it1.children1);
      return _objectSpread$k(_objectSpread$k({}, map3), {}, _defineProperty$4({}, id1, new Immutable.Map(it1)));
    }, {}));
  }
};
var getField = function getField2(state, path) {
  var field = state.getIn(expandTreePath(path, "properties", "field")) || null;
  return field;
};
var emptyDrag = {
  dragging: {
    id: null,
    x: null,
    y: null,
    w: null,
    h: null
  },
  mousePos: {},
  dragStart: {
    id: null
  }
};
var getActionMeta = function getActionMeta2(action2, state) {
  if (!action2 || !action2.type) return null;
  var actionKeysToOmit = ["config", "asyncListValues"];
  var actionTypesToIgnore = [SET_TREE, SET_DRAG_START$1, SET_DRAG_PROGRESS$1, SET_DRAG_END$1];
  var meta = mapValues$1(omit$1(action2, actionKeysToOmit), applyToJS);
  var affectedField = action2.path && getField(state.tree, action2.path) || action2.field;
  if (affectedField) {
    var _affectedField;
    if ((_affectedField = affectedField) !== null && _affectedField !== void 0 && _affectedField.toJS) affectedField = affectedField.toJS();
    meta.affectedField = affectedField;
  }
  if (actionTypesToIgnore.includes(action2.type) || action2.type.indexOf("@@redux") == 0) meta = null;
  return meta;
};
const TreeStore = function(initialConfig, tree2, getMemoizedTree, setLastTree, getLastConfig) {
  var initTree = tree2;
  var emptyState = _objectSpread$k({
    tree: initTree
  }, emptyDrag);
  return function() {
    var _ref3, _getLastConfig;
    var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : emptyState;
    var action2 = arguments.length > 1 ? arguments[1] : void 0;
    var config2 = (_ref3 = (_getLastConfig = getLastConfig === null || getLastConfig === void 0 ? void 0 : getLastConfig()) !== null && _getLastConfig !== void 0 ? _getLastConfig : action2 === null || action2 === void 0 ? void 0 : action2.config) !== null && _ref3 !== void 0 ? _ref3 : initialConfig;
    var unset = {
      __lastAction: void 0
    };
    var set3 = {};
    var actionMeta = getActionMeta(action2, state);
    switch (action2 === null || action2 === void 0 ? void 0 : action2.type) {
      case SET_TREE: {
        var validatedTree = getMemoizedTree(config2, action2.tree);
        set3.tree = validatedTree;
        break;
      }
      case ADD_CASE_GROUP: {
        set3.tree = addNewGroup(state.tree, action2.path, "case_group", action2.id, action2.properties, config2, action2.children, action2.meta);
        break;
      }
      case ADD_GROUP: {
        set3.tree = addNewGroup(state.tree, action2.path, "group", action2.id, action2.properties, config2, action2.children, action2.meta);
        break;
      }
      case REMOVE_GROUP: {
        set3.tree = removeGroup$1(state.tree, action2.path, config2);
        break;
      }
      case ADD_RULE: {
        set3.tree = addItem(state.tree, action2.path, action2.ruleType, action2.id, action2.properties, config2, action2.children);
        break;
      }
      case REMOVE_RULE: {
        set3.tree = removeRule$1(state.tree, action2.path, config2);
        break;
      }
      case SET_CONJUNCTION: {
        set3.tree = setConjunction$1(state.tree, action2.path, action2.conjunction);
        break;
      }
      case SET_NOT: {
        set3.tree = setNot$1(state.tree, action2.path, action2.not);
        break;
      }
      case SET_FIELD: {
        var _setField = setField$1(state.tree, action2.path, action2.field, config2, action2.asyncListValues, action2._meta), newTree2 = _setField.state;
        set3.tree = newTree2;
        break;
      }
      case SET_FIELD_SRC: {
        set3.tree = setFieldSrc$1(state.tree, action2.path, action2.srcKey, config2);
        break;
      }
      case SET_LOCK: {
        set3.tree = setLock$1(state.tree, action2.path, action2.lock);
        break;
      }
      case SET_OPERATOR: {
        set3.tree = setOperator$1(state.tree, action2.path, action2.operator, config2);
        break;
      }
      case SET_VALUE: {
        var _setValue = setValue$1(state.tree, action2.path, action2.delta, action2.value, action2.valueType, config2, action2.asyncListValues, action2._meta), _newTree = _setValue.state;
        set3.tree = _newTree;
        break;
      }
      case SET_FUNC_VALUE: {
        var _setFuncValue = setFuncValue$1(config2, state.tree, action2.path, action2.delta, action2.parentFuncs, action2.argKey, action2.value, action2.valueType, action2.asyncListValues, action2._meta), _newTree2 = _setFuncValue.state;
        set3.tree = _newTree2;
        break;
      }
      case SET_VALUE_SRC: {
        set3.tree = setValueSrc$1(state.tree, action2.path, action2.delta, action2.srcKey, config2, action2._meta);
        break;
      }
      case SET_OPERATOR_OPTION: {
        set3.tree = setOperatorOption$1(state.tree, action2.path, action2.name, action2.value);
        break;
      }
      case MOVE_ITEM: {
        set3.tree = moveItem$1(state.tree, action2.fromPath, action2.toPath, action2.placement);
        break;
      }
      case SET_DRAG_START$1: {
        set3.dragStart = action2.dragStart;
        set3.dragging = action2.dragging;
        set3.mousePos = action2.mousePos;
        break;
      }
      case SET_DRAG_PROGRESS$1: {
        set3.mousePos = action2.mousePos;
        set3.dragging = action2.dragging;
        break;
      }
      case SET_DRAG_END$1: {
        set3.tree = checkEmptyGroups(state.tree, config2);
        set3 = _objectSpread$k(_objectSpread$k({}, set3), emptyDrag);
        break;
      }
    }
    if (actionMeta) {
      set3.__lastAction = actionMeta;
    }
    if (setLastTree && set3.tree && state.tree) {
      setLastTree(state.tree);
    }
    return _objectSpread$k(_objectSpread$k(_objectSpread$k({}, state), unset), set3);
  };
};
var setTree = function setTree2(config2, tree2) {
  return {
    type: SET_TREE,
    tree: tree2,
    config: config2
  };
};
var addRule = function addRule2(config2, path, properties) {
  var ruleType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "rule";
  var children = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var parentRuleGroupPath = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
  return {
    type: ADD_RULE,
    ruleType,
    children,
    path: toImmutableList(path),
    id: uuid(),
    properties: defaultRuleProperties(config2, parentRuleGroupPath).merge(fromJS(properties) || {}),
    config: config2
  };
};
var removeRule2 = function removeRule3(config2, path) {
  return {
    type: REMOVE_RULE,
    path: toImmutableList(path),
    config: config2
  };
};
var addDefaultCaseGroup = function addDefaultCaseGroup2(config2, path, properties) {
  var children = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    type: ADD_CASE_GROUP,
    path: toImmutableList(path),
    children,
    id: uuid(),
    properties: defaultGroupProperties(config2).merge(fromJS(properties) || {}),
    config: config2,
    meta: {
      isDefaultCase: true
    }
  };
};
var addCaseGroup = function addCaseGroup2(config2, path, properties) {
  var children = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    type: ADD_CASE_GROUP,
    path: toImmutableList(path),
    children,
    id: uuid(),
    properties: defaultGroupProperties(config2).merge(fromJS(properties) || {}),
    config: config2
  };
};
var addGroup = function addGroup2(config2, path, properties) {
  var children = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    type: ADD_GROUP,
    path: toImmutableList(path),
    children,
    id: uuid(),
    properties: defaultGroupProperties(config2).merge(fromJS(properties) || {}),
    config: config2
  };
};
var removeGroup2 = function removeGroup3(config2, path) {
  return {
    type: REMOVE_GROUP,
    path: toImmutableList(path),
    config: config2
  };
};
var moveItem2 = function moveItem3(config2, fromPath, toPath, placement) {
  return {
    type: MOVE_ITEM,
    fromPath: toImmutableList(fromPath),
    toPath: toImmutableList(toPath),
    placement,
    config: config2
  };
};
const tree$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addCaseGroup,
  addDefaultCaseGroup,
  addGroup,
  addRule,
  moveItem: moveItem2,
  removeGroup: removeGroup2,
  removeRule: removeRule2,
  setTree
}, Symbol.toStringTag, { value: "Module" }));
var setConjunction2 = function setConjunction3(config2, path, conjunction) {
  return {
    type: SET_CONJUNCTION,
    path: toImmutableList(path),
    conjunction
  };
};
var setNot2 = function setNot3(config2, path, not2) {
  return {
    type: SET_NOT,
    path: toImmutableList(path),
    not: not2
  };
};
var setLock2 = function setLock3(config2, path, lock) {
  return {
    type: SET_LOCK,
    path: toImmutableList(path),
    lock
  };
};
const group$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  setConjunction: setConjunction2,
  setLock: setLock2,
  setNot: setNot2
}, Symbol.toStringTag, { value: "Module" }));
var setField2 = function setField3(config2, path, field, asyncListValues, _meta) {
  return {
    type: SET_FIELD,
    path: toImmutableList(path),
    field,
    config: config2,
    asyncListValues,
    _meta
  };
};
var setFieldSrc2 = function setFieldSrc3(config2, path, srcKey) {
  return {
    type: SET_FIELD_SRC,
    path: toImmutableList(path),
    srcKey,
    config: config2
  };
};
var setOperator2 = function setOperator3(config2, path, operator) {
  return {
    type: SET_OPERATOR,
    path: toImmutableList(path),
    operator,
    config: config2
  };
};
var setValue2 = function setValue3(config2, path, delta2, value, valueType, asyncListValues, _meta) {
  return {
    type: SET_VALUE,
    path: toImmutableList(path),
    delta: delta2,
    value,
    valueType,
    asyncListValues,
    config: config2,
    _meta
  };
};
var setValueSrc2 = function setValueSrc3(config2, path, delta2, srcKey, _meta) {
  return {
    type: SET_VALUE_SRC,
    path: toImmutableList(path),
    delta: delta2,
    srcKey,
    config: config2,
    _meta
  };
};
var setFuncValue2 = function setFuncValue3(config2, path, delta2, parentFuncs, argKey, value, valueType, asyncListValues, _meta) {
  return {
    type: SET_FUNC_VALUE,
    path: toImmutableList(path),
    delta: delta2,
    parentFuncs,
    argKey,
    value,
    valueType,
    asyncListValues,
    config: config2,
    _meta
  };
};
var setOperatorOption2 = function setOperatorOption3(config2, path, name2, value) {
  return {
    type: SET_OPERATOR_OPTION,
    path: toImmutableList(path),
    name: name2,
    value,
    config: config2
  };
};
const rule$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  setField: setField2,
  setFieldSrc: setFieldSrc2,
  setFuncValue: setFuncValue2,
  setOperator: setOperator2,
  setOperatorOption: setOperatorOption2,
  setValue: setValue2,
  setValueSrc: setValueSrc2
}, Symbol.toStringTag, { value: "Module" }));
function ownKeys$j(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$j(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$j(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$j(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var Utils$1 = _objectSpread$j(_objectSpread$j(_objectSpread$j({}, BasicUtils), {}, {
  Export,
  Import,
  // intrenal
  ConfigMixins
}, Export), Import);
const context = /* @__PURE__ */ React.createContext();
var PLACEMENT_AFTER = "after";
var PLACEMENT_BEFORE = "before";
var PLACEMENT_APPEND = "append";
var PLACEMENT_PREPEND = "prepend";
var SET_DRAG_PROGRESS = "SET_DRAG_PROGRESS";
var SET_DRAG_START = "SET_DRAG_START";
var SET_DRAG_END = "SET_DRAG_END";
var setDragProgress = function setDragProgress2(mousePos, dragging) {
  return {
    type: SET_DRAG_PROGRESS,
    mousePos,
    dragging
  };
};
var setDragStart = function setDragStart2(dragStart, dragging, mousePos) {
  return {
    type: SET_DRAG_START,
    dragStart,
    dragging,
    mousePos
  };
};
var setDragEnd = function setDragEnd2() {
  return {
    type: SET_DRAG_END
  };
};
var tree = tree$1, group = group$1, rule = rule$1;
var define_process_env_default = {};
var getOpCardinality = function getOpCardinality22(opDef) {
  var _opDef$cardinality;
  return (_opDef$cardinality = opDef === null || opDef === void 0 ? void 0 : opDef.cardinality) !== null && _opDef$cardinality !== void 0 ? _opDef$cardinality : 1;
};
var truncateString = function truncateString2(str, n2, useWordBoundary) {
  if (!n2 || !str || str.length <= n2) {
    return str;
  }
  var subString = str.substr(0, n2 - 1);
  return subString + "...";
};
var immutableEqual = function immutableEqual2(v1, v2) {
  if (v1 === v2) {
    return true;
  } else {
    return v1 === null || v1 === void 0 ? void 0 : v1.equals(v2);
  }
};
var shallowEqual$3 = function shallowEqual22(a2, b) {
  var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (a2 === b) {
    return true;
  } else if (Array.isArray(a2)) return shallowEqualArrays(a2, b, deep);
  else if (a2 && typeof a2.equals === "function") return a2.equals(b);
  else if (_typeof$3(a2) === "object") return shallowEqualObjects(a2, b, deep);
  else return a2 === b;
};
function shallowEqualArrays(arrA, arrB) {
  var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (arrA === arrB) {
    return true;
  }
  if (!arrA || !arrB) {
    return false;
  }
  var len = arrA.length;
  if (arrB.length !== len) {
    return false;
  }
  for (var i2 = 0; i2 < len; i2++) {
    var isEqual2 = deep ? shallowEqual$3(arrA[i2], arrB[i2], deep) : arrA[i2] === arrB[i2];
    if (!isEqual2) {
      return false;
    }
  }
  return true;
}
function shallowEqualObjects(objA, objB) {
  var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (objA === objB) {
    return true;
  }
  if (!objA || !objB) {
    return false;
  }
  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var len = aKeys.length;
  if (bKeys.length !== len) {
    return false;
  }
  for (var i2 = 0; i2 < len; i2++) {
    var key = aKeys[i2];
    var isEqual2 = deep ? shallowEqual$3(objA[key], objB[key], deep) : objA[key] === objB[key];
    if (!isEqual2) {
      return false;
    }
  }
  return true;
}
var isDev = function isDev22() {
  return typeof process !== "undefined" && define_process_env_default && false;
};
var getLogger = function getLogger22() {
  var devMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  var verbose = devMode != void 0 ? devMode : isDev();
  return verbose ? console : {
    error: function error2() {
    },
    log: function log() {
    },
    warn: function warn2() {
    },
    debug: function debug() {
    },
    info: function info() {
    }
  };
};
var logger = getLogger();
var validateAndFixTree2 = Utils$1.Validation.validateAndFixTree;
var createValidationMemo = function createValidationMemo2() {
  var originalTree;
  var validatedTree;
  var configId2;
  return function(config2, tree2) {
    var oldConfig = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    var sanitizeTree3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    if (!tree2) {
      return null;
    }
    if (config2.__configId === configId2 && (immutableEqual(tree2, originalTree) || immutableEqual(tree2, validatedTree))) {
      return validatedTree;
    } else {
      configId2 = config2.__configId;
      originalTree = tree2;
      if (sanitizeTree3 === false) {
        validatedTree = validateAndFixTree2(tree2, null, config2, oldConfig || config2, false, false, false);
      } else {
        validatedTree = validateAndFixTree2(tree2, null, config2, oldConfig || config2);
      }
      return validatedTree;
    }
  };
};
var getReactContainerType = function getReactContainerType2(el) {
  if (el._reactRootContainer) {
    return "root";
  }
  if (Object.getOwnPropertyNames(el).filter(function(k) {
    return k.startsWith("__reactContainer");
  }).length > 0) {
    return "container";
  }
  return void 0;
};
var getReactRootNodeType = function getReactRootNodeType2(node) {
  if (!node) {
    return void 0;
  }
  var type2 = getReactContainerType(node);
  if (type2 !== void 0) {
    return type2;
  } else {
    return getReactRootNodeType2(node.parentNode);
  }
};
var isUsingLegacyReactDomRender = function isUsingLegacyReactDomRender2(node) {
  return getReactRootNodeType(node) === "root";
};
var liteShouldComponentUpdate = function liteShouldComponentUpdate2(self2, config2) {
  return function(nextProps, nextState) {
    var prevProps = self2.props;
    var prevState = self2.state;
    var should = nextProps != prevProps || nextState != prevState;
    if (should) {
      if (prevState == nextState && prevProps != nextProps) {
        var chs = [];
        for (var k in nextProps) {
          var changed = nextProps[k] != prevProps[k];
          if (changed) {
            if (config2[k] == "ignore") changed = false;
            else if (config2[k] == "shallow_deep") changed = !shallowEqual$3(nextProps[k], prevProps[k], true);
            else if (config2[k] == "shallow") changed = !shallowEqual$3(nextProps[k], prevProps[k]);
            else if (typeof config2[k] == "function") changed = config2[k](nextProps[k], prevProps[k], nextProps, prevProps);
          }
          if (changed) chs.push(k);
        }
        if (!chs.length) should = false;
      }
    }
    return should;
  };
};
var pureShouldComponentUpdate = function pureShouldComponentUpdate2(self2) {
  return function(nextProps, nextState) {
    return !shallowEqual$3(self2.props, nextProps) || !shallowEqual$3(self2.state, nextState);
  };
};
var canUseOldComponentWillReceiveProps = function canUseOldComponentWillReceiveProps2() {
  var v = React.version.split(".").map(parseInt.bind(null, 10));
  return v[0] == 16 && v[1] < 3 || v[0] < 16;
};
var useOnPropsChanged = function useOnPropsChanged2(obj) {
  if (!obj.shouldComponentUpdate) {
    obj.shouldComponentUpdate = pureShouldComponentUpdate(obj);
  }
  if (canUseOldComponentWillReceiveProps()) {
    obj.componentWillReceiveProps = function(nextProps) {
      obj.onPropsChanged(nextProps);
    };
  } else {
    var origShouldComponentUpdate = obj.shouldComponentUpdate;
    var newShouldComponentUpdate = function newShouldComponentUpdate2(nextProps, nextState) {
      var shouldNotify = !shallowEqual$3(obj.props, nextProps);
      if (shouldNotify) {
        obj.onPropsChanged(nextProps);
      }
      var shouldUpdate = origShouldComponentUpdate.call(obj, nextProps, nextState);
      return shouldUpdate;
    };
    obj.shouldComponentUpdate = newShouldComponentUpdate.bind(obj);
  }
};
var bindActionCreators = function bindActionCreators2(actionCreators, config2, dispatch) {
  return mapValues$1(actionCreators, function(actionCreator) {
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return dispatch(actionCreator.apply(void 0, [config2].concat(args)));
    };
  });
};
const ReactUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindActionCreators,
  isUsingLegacyReactDomRender,
  liteShouldComponentUpdate,
  pureShouldComponentUpdate,
  useOnPropsChanged
}, Symbol.toStringTag, { value: "Module" }));
function ownKeys$i(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$i(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$i(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$i(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _callSuper$r(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$r() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$r() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$r = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var Query = /* @__PURE__ */ function(_Component) {
  function Query2(props) {
    var _this;
    _classCallCheck$b(this, Query2);
    _this = _callSuper$r(this, Query2, [props]);
    _this.shouldComponentUpdate = liteShouldComponentUpdate(_this, {
      tree: function tree2(nextValue) {
        if (nextValue === _this.oldValidatedTree && _this.oldValidatedTree === _this.validatedTree) {
          return false;
        }
        return true;
      }
    });
    useOnPropsChanged(_this);
    _this._updateActions(props);
    _this.validatedTree = props.getMemoizedTree(props.config, props.tree, void 0, props.sanitizeTree);
    _this.oldValidatedTree = _this.validatedTree;
    var basicConfig = props.getBasicConfig(props.config);
    props.onInit && props.onInit(_this.validatedTree, basicConfig, void 0, _this.actions);
    return _this;
  }
  _inherits$b(Query2, _Component);
  return _createClass$9(Query2, [{
    key: "_updateActions",
    value: function _updateActions(props) {
      var config2 = props.config, dispatch = props.dispatch;
      this.actions = bindActionCreators(_objectSpread$i(_objectSpread$i(_objectSpread$i({}, tree), group), rule), config2, dispatch);
    }
  }, {
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var onChange = nextProps.onChange;
      var oldConfig = this.props.config;
      var newTree2 = nextProps.tree;
      this.props.tree;
      var newConfig = nextProps.config;
      this.oldValidatedTree = this.validatedTree;
      this.validatedTree = newTree2;
      if (oldConfig !== newConfig) {
        this._updateActions(nextProps);
        this.validatedTree = nextProps.getMemoizedTree(newConfig, newTree2, oldConfig);
      }
      var validatedTreeChanged = !immutableEqual(this.validatedTree, this.oldValidatedTree);
      if (validatedTreeChanged) {
        var newBasicConfig = nextProps.getBasicConfig(newConfig);
        onChange && onChange(this.validatedTree, newBasicConfig, nextProps.__lastAction, this.actions);
      }
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, renderBuilder = _this$props.renderBuilder, dispatch = _this$props.dispatch;
      var builderProps = {
        tree: this.validatedTree,
        actions: this.actions,
        config: config2,
        dispatch
      };
      return renderBuilder(builderProps);
    }
  }]);
}(reactExports.Component);
Query.propTypes = {
  config: PropTypes.object.isRequired,
  onChange: PropTypes.func,
  onInit: PropTypes.func,
  renderBuilder: PropTypes.func,
  tree: PropTypes.any
  //instanceOf(Immutable.Map)
  //dispatch: PropTypes.func.isRequired,
  //__lastAction
  //getMemoizedTree: PropTypes.func.isRequired,
  //getBasicConfig: PropTypes.func.isRequired,
  //sanitizeTree
};
var ConnectedQuery = connect$1(function(state) {
  return {
    tree: state.tree,
    __lastAction: state.__lastAction
  };
}, null, null, {
  context
})(Query);
ConnectedQuery.displayName = "ConnectedQuery";
function _callSuper$q(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$q() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$q() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$q = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var defaultRoot2 = Utils$1.DefaultUtils.defaultRoot;
var createConfigMemo2 = Utils$1.ConfigUtils.createConfigMemo;
var QueryContainer = /* @__PURE__ */ function(_Component) {
  function QueryContainer2(props, context2) {
    var _this$_reactInternals, _this$_reactInternals2;
    var _this;
    _classCallCheck$b(this, QueryContainer2);
    _this = _callSuper$q(this, QueryContainer2, [props, context2]);
    _this.setLastTree = function(lastTree) {
      if (_this.prevTree) {
        _this.prevprevTree = _this.prevTree;
      }
      _this.prevTree = lastTree;
    };
    _this.getConfig = function() {
      return _this.config;
    };
    _this.shouldComponentUpdate = liteShouldComponentUpdate(_this, {
      value: function value(nextValue, prevValue) {
        return false;
      }
    });
    useOnPropsChanged(_this);
    var _createConfigMemo = createConfigMemo2({
      reactIndex: (_this$_reactInternals = (_this$_reactInternals2 = _this._reactInternals) === null || _this$_reactInternals2 === void 0 ? void 0 : _this$_reactInternals2.index) !== null && _this$_reactInternals !== void 0 ? _this$_reactInternals : -1,
      maxSize: 2,
      // current and prev
      canCompile: true
    }), getExtendedConfig = _createConfigMemo.getExtendedConfig, getBasicConfig = _createConfigMemo.getBasicConfig, clearConfigMemo = _createConfigMemo.clearConfigMemo;
    _this.getMemoizedConfig = getExtendedConfig;
    _this.getBasicConfig = getBasicConfig;
    _this.clearConfigMemo = clearConfigMemo;
    _this.getMemoizedTree = createValidationMemo();
    var config2 = _this.getMemoizedConfig(props);
    var shouldCreateEmptyGroup = config2.settings.shouldCreateEmptyGroup;
    var canAddDefaultRule = !shouldCreateEmptyGroup;
    var emptyTree = defaultRoot2(config2, canAddDefaultRule);
    var sanitizeTree3 = !!props.value;
    var tree2 = props.value || emptyTree;
    var validatedTree = _this.getMemoizedTree(config2, tree2, void 0, sanitizeTree3);
    var reducer = TreeStore(config2, validatedTree, _this.getMemoizedTree, _this.setLastTree, _this.getConfig);
    var store = createStore(reducer);
    _this.config = config2;
    _this.state = {
      store
    };
    _this.QueryWrapper = function(pr) {
      return config2.settings.renderProvider(pr, config2.ctx);
    };
    return _this;
  }
  _inherits$b(QueryContainer2, _Component);
  return _createClass$9(QueryContainer2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clearConfigMemo();
    }
  }, {
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var oldConfig = this.config;
      var nextConfig = this.getMemoizedConfig(nextProps);
      var isConfigChanged = oldConfig !== nextConfig;
      var storeValue = this.state.store.getState().tree;
      var isTreeChanged = !immutableEqual(nextProps.value, this.props.value) && !immutableEqual(nextProps.value, storeValue);
      var currentTree = isTreeChanged ? nextProps.value || defaultRoot2(nextProps) : storeValue;
      var isTreeTrulyChanged = isTreeChanged && !immutableEqual(nextProps.value, this.prevTree) && !immutableEqual(nextProps.value, this.prevprevTree);
      this.sanitizeTree = isTreeTrulyChanged || isConfigChanged;
      if (isConfigChanged) {
        if (prevProps.settings.renderProvider !== nextProps.settings.renderProvider) {
          this.QueryWrapper = function(props) {
            return nextConfig.settings.renderProvider(props, nextConfig.ctx);
          };
        }
        this.config = nextConfig;
      }
      if (isTreeChanged || isConfigChanged) {
        var validatedTree = this.getMemoizedTree(nextConfig, currentTree, oldConfig, this.sanitizeTree);
        this.state.store.dispatch(tree.setTree(nextConfig, validatedTree));
      }
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$props = this.props, renderBuilder = _this$props.renderBuilder, get_children = _this$props.get_children, onChange = _this$props.onChange, onInit = _this$props.onInit;
      var store = this.state.store;
      var config2 = this.config;
      var QueryWrapper = this.QueryWrapper;
      return /* @__PURE__ */ React.createElement(QueryWrapper, {
        config: config2
      }, /* @__PURE__ */ React.createElement(Provider, {
        store,
        context
      }, /* @__PURE__ */ React.createElement(ConnectedQuery, {
        config: config2,
        getMemoizedTree: this.getMemoizedTree,
        getBasicConfig: this.getBasicConfig,
        sanitizeTree: this.sanitizeTree,
        onChange,
        onInit,
        renderBuilder: renderBuilder || get_children
      })));
    }
  }]);
}(reactExports.Component);
QueryContainer.propTypes = {
  //config
  conjunctions: PropTypes.object.isRequired,
  fields: PropTypes.object.isRequired,
  types: PropTypes.object.isRequired,
  operators: PropTypes.object.isRequired,
  widgets: PropTypes.object.isRequired,
  settings: PropTypes.object.isRequired,
  ctx: PropTypes.object.isRequired,
  onChange: PropTypes.func,
  onInit: PropTypes.func,
  renderBuilder: PropTypes.func,
  value: PropTypes.any
  //instanceOf(Immutable.Map)
};
function _callSuper$p(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$p() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$p() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$p = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var getFieldConfig$7 = Utils$1.ConfigUtils.getFieldConfig;
var createRuleContainer = function createRuleContainer2(Rule2) {
  var _RuleContainer;
  return _RuleContainer = /* @__PURE__ */ function(_Component) {
    function RuleContainer2(props) {
      var _this;
      _classCallCheck$b(this, RuleContainer2);
      _this = _callSuper$p(this, RuleContainer2, [props]);
      _this.dummyFn = function() {
      };
      _this.removeSelf = function() {
        _this.props.actions.removeRule(_this.props.path);
      };
      _this.setLock = function() {
        var lock = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        _this.props.actions.setLock(_this.props.path, lock);
      };
      _this.setField = function(field, asyncListValues, _meta) {
        _this.props.actions.setField(_this.props.path, field, asyncListValues, _meta);
      };
      _this.setFieldSrc = function(srcKey) {
        _this.props.actions.setFieldSrc(_this.props.path, srcKey);
      };
      _this.setOperator = function(operator) {
        _this.props.actions.setOperator(_this.props.path, operator);
      };
      _this.setOperatorOption = function(name2, value) {
        _this.props.actions.setOperatorOption(_this.props.path, name2, value);
      };
      _this.setValue = function(delta2, value, type2, asyncListValues, _meta) {
        _this.props.actions.setValue(_this.props.path, delta2, value, type2, asyncListValues, _meta);
      };
      _this.setValueSrc = function(delta2, srcKey, _meta) {
        _this.props.actions.setValueSrc(_this.props.path, delta2, srcKey, _meta);
      };
      _this.setFuncValue = function(delta2, parentFuncs, argKey, value, type2, asyncListValues, _meta) {
        _this.props.actions.setFuncValue(_this.props.path, delta2, parentFuncs, argKey, value, type2, asyncListValues, _meta);
      };
      _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_this);
      _this.dummyFn.isDummyFn = true;
      return _this;
    }
    _inherits$b(RuleContainer2, _Component);
    return _createClass$9(RuleContainer2, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        var prevProps = this.props;
        var prevState = this.state;
        var should = this.pureShouldComponentUpdate(nextProps, nextState);
        if (should) {
          if (prevState == nextState && prevProps != nextProps) {
            var draggingId = nextProps.dragging.id || prevProps.dragging.id;
            var isDraggingMe = draggingId == nextProps.id;
            var chs = [];
            for (var k in nextProps) {
              var changed = nextProps[k] != prevProps[k];
              if (k == "dragging" && !isDraggingMe) {
                changed = false;
              }
              if (changed) {
                chs.push(k);
              }
            }
            if (!chs.length) should = false;
          }
        }
        return should;
      }
    }, {
      key: "render",
      value: function render3() {
        var isDraggingMe = this.props.dragging.id == this.props.id;
        var fieldConfig = getFieldConfig$7(this.props.config, this.props.field);
        var fieldType = this.props.fieldType || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) || null;
        var showErrorMessage = this.props.config.settings.showErrorMessage;
        fieldConfig && fieldConfig.type == "!struct";
        var isInDraggingTempo = !isDraggingMe && this.props.isDraggingTempo;
        var _this$props = this.props, valueError = _this$props.valueError, fieldError = _this$props.fieldError;
        var oneError = [fieldError].concat(_toConsumableArray((valueError === null || valueError === void 0 ? void 0 : valueError.toArray()) || [])).filter(function(e2) {
          return !!e2;
        }).shift() || null;
        var hasError = oneError != null && showErrorMessage;
        return /* @__PURE__ */ React.createElement("div", {
          className: classNames("group-or-rule-container", "rule-container", hasError ? "rule-with-error" : null),
          "data-id": this.props.id
        }, [isDraggingMe ? /* @__PURE__ */ React.createElement(Rule2, {
          key: "dragging",
          id: this.props.id,
          groupId: this.props.groupId,
          isDraggingMe: true,
          isDraggingTempo: true,
          dragging: this.props.dragging,
          setField: this.dummyFn,
          setFieldSrc: this.dummyFn,
          setFuncValue: this.dummyFn,
          setOperator: this.dummyFn,
          setOperatorOption: this.dummyFn,
          setLock: this.dummyFn,
          removeSelf: this.dummyFn,
          setValue: this.dummyFn,
          setValueSrc: this.dummyFn,
          selectedField: this.props.field || null,
          selectedFieldSrc: this.props.fieldSrc || "field",
          selectedFieldType: fieldType,
          parentField: this.props.parentField || null,
          selectedOperator: this.props.operator || null,
          value: this.props.value || null,
          valueSrc: this.props.valueSrc || null,
          valueType: this.props.valueType || null,
          valueError: this.props.valueError || null,
          fieldError: this.props.fieldError || null,
          operatorOptions: this.props.operatorOptions,
          config: this.props.config,
          reordableNodesCnt: this.props.reordableNodesCnt,
          totalRulesCnt: this.props.totalRulesCnt,
          asyncListValues: this.props.asyncListValues,
          isLocked: this.props.isLocked,
          isTrueLocked: this.props.isTrueLocked,
          parentReordableNodesCnt: this.props.parentReordableNodesCnt
        }) : null, /* @__PURE__ */ React.createElement(Rule2, {
          key: this.props.id,
          id: this.props.id,
          groupId: this.props.groupId,
          isDraggingMe,
          isDraggingTempo: isInDraggingTempo,
          onDragStart: this.props.onDragStart,
          setLock: isInDraggingTempo ? this.dummyFn : this.setLock,
          removeSelf: isInDraggingTempo ? this.dummyFn : this.removeSelf,
          setField: isInDraggingTempo ? this.dummyFn : this.setField,
          setFieldSrc: isInDraggingTempo ? this.dummyFn : this.setFieldSrc,
          setFuncValue: isInDraggingTempo ? this.dummyFn : this.setFuncValue,
          setOperator: isInDraggingTempo ? this.dummyFn : this.setOperator,
          setOperatorOption: isInDraggingTempo ? this.dummyFn : this.setOperatorOption,
          setValue: isInDraggingTempo ? this.dummyFn : this.setValue,
          setValueSrc: isInDraggingTempo ? this.dummyFn : this.setValueSrc,
          selectedField: this.props.field || null,
          selectedFieldSrc: this.props.fieldSrc || "field",
          selectedFieldType: fieldType,
          parentField: this.props.parentField || null,
          selectedOperator: this.props.operator || null,
          value: this.props.value || null,
          valueSrc: this.props.valueSrc || null,
          valueType: this.props.valueType || null,
          valueError: this.props.valueError || null,
          fieldError: this.props.fieldError || null,
          operatorOptions: this.props.operatorOptions,
          config: this.props.config,
          reordableNodesCnt: this.props.reordableNodesCnt,
          totalRulesCnt: this.props.totalRulesCnt,
          asyncListValues: this.props.asyncListValues,
          isLocked: this.props.isLocked,
          isTrueLocked: this.props.isTrueLocked,
          parentReordableNodesCnt: this.props.parentReordableNodesCnt
        })]);
      }
    }]);
  }(reactExports.Component), _RuleContainer.propTypes = {
    id: PropTypes.string.isRequired,
    groupId: PropTypes.string,
    config: PropTypes.object.isRequired,
    path: PropTypes.any.isRequired,
    //instanceOf(Immutable.List)
    operator: PropTypes.string,
    field: PropTypes.any,
    fieldSrc: PropTypes.string,
    fieldType: PropTypes.string,
    actions: PropTypes.object.isRequired,
    //{removeRule: Function, setField, setFieldSrc, setOperator, setOperatorOption, setValue, setValueSrc, ...}
    onDragStart: PropTypes.func,
    value: PropTypes.any,
    //depends on widget
    valueSrc: PropTypes.any,
    asyncListValues: PropTypes.array,
    valueError: PropTypes.any,
    fieldError: PropTypes.string,
    operatorOptions: PropTypes.object,
    reordableNodesCnt: PropTypes.number,
    parentField: PropTypes.string,
    //from RuleGroup
    isLocked: PropTypes.bool,
    isTrueLocked: PropTypes.bool,
    //connected:
    dragging: PropTypes.object,
    //{id, x, y, w, h}
    isDraggingTempo: PropTypes.bool
  }, _RuleContainer;
};
const RuleContainer = function(Rule2) {
  var ConnectedRuleContainer = connect$1(function(state) {
    return {
      dragging: state.dragging
    };
  }, null, null, {
    context
  })(createRuleContainer(Rule2));
  ConnectedRuleContainer.displayName = "ConnectedRuleContainer";
  return ConnectedRuleContainer;
};
function _callSuper$o(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$o() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$o() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$o = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var clone$2 = Utils$1.clone;
var getFlatTree2 = Utils$1.TreeUtils.getFlatTree;
var _isReorderingTree = false;
var createSortableContainer = function createSortableContainer2(Builder2) {
  var _SortableContainer;
  var CanMoveFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  return _SortableContainer = /* @__PURE__ */ function(_Component) {
    function SortableContainer2(props) {
      var _this;
      _classCallCheck$b(this, SortableContainer2);
      _this = _callSuper$o(this, SortableContainer2, [props]);
      _this._getEventTarget = function(e2, dragStart) {
        return e2 && e2.__mocked_window || document.body || window;
      };
      _this.onDragStart = function(id2, dom, e2) {
        var treeEl = dom.closest(".query-builder");
        if (_this._isUsingLegacyReactDomRender === void 0) {
          _this._isUsingLegacyReactDomRender = isUsingLegacyReactDomRender(treeEl);
        }
        document.body.classList.add("qb-dragging");
        treeEl.classList.add("qb-dragging");
        var treeElContainer = treeEl.closest(".query-builder-container") || treeEl;
        treeElContainer = _this._getScrollParent(treeElContainer) || document.body;
        var scrollTop = treeElContainer.scrollTop;
        _this._getDraggableNodeEl(treeEl);
        _this._getPlaceholderNodeEl(treeEl);
        var tmpAllGroups = treeEl.querySelectorAll(".group--children");
        var anyGroup = tmpAllGroups.length ? tmpAllGroups[0] : null;
        var groupPadding;
        if (anyGroup) {
          groupPadding = window.getComputedStyle(anyGroup, null).getPropertyValue("padding-left");
          groupPadding = parseInt(groupPadding);
        }
        var dragging = {
          id: id2,
          x: dom.offsetLeft,
          y: dom.offsetTop,
          w: dom.offsetWidth,
          h: dom.offsetHeight,
          itemInfo: _this.tree.items[id2],
          paddingLeft: groupPadding
        };
        var dragStart = {
          id: id2,
          x: dom.offsetLeft,
          y: dom.offsetTop,
          scrollTop,
          clientX: e2.clientX,
          clientY: e2.clientY,
          itemInfo: clone$2(_this.tree.items[id2]),
          treeEl,
          treeElContainer
        };
        var mousePos = {
          clientX: e2.clientX,
          clientY: e2.clientY
        };
        var target = _this._getEventTarget(e2, dragStart);
        _this.eventTarget = target;
        target.addEventListener("mousemove", _this.onDrag);
        target.addEventListener("mouseup", _this.onDragEnd);
        _this.props.setDragStart(dragStart, dragging, mousePos);
      };
      _this.onDrag = function(e2) {
        var doHandleDrag = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        var dragging = Object.assign({}, _this.props.dragging);
        var startDragging = _this.props.dragStart;
        var paddingLeft = dragging.paddingLeft;
        var treeElContainer = startDragging.treeElContainer;
        var scrollTop = treeElContainer.scrollTop;
        dragging.itemInfo = _this.tree.items[dragging.id];
        if (!dragging.itemInfo) {
          return;
        }
        var mousePos = {
          clientX: e2.clientX,
          clientY: e2.clientY
        };
        var startMousePos = {
          clientX: startDragging.clientX,
          clientY: startDragging.clientY
        };
        if (e2.__mock_dom) {
          var treeEl = startDragging.treeEl;
          var dragEl = _this._getDraggableNodeEl(treeEl);
          var plhEl = _this._getPlaceholderNodeEl(treeEl);
          e2.__mock_dom({
            treeEl,
            dragEl,
            plhEl
          });
        }
        if (!startDragging.plX) {
          var _treeEl = startDragging.treeEl;
          var _plhEl2 = _this._getPlaceholderNodeEl(_treeEl);
          if (_plhEl2) {
            startDragging.plX = _plhEl2.getBoundingClientRect().left + window.scrollX;
            startDragging.plY = _plhEl2.getBoundingClientRect().top + window.scrollY;
          }
        }
        var startX = startDragging.x;
        var startY = startDragging.y;
        var startClientX = startDragging.clientX;
        var startClientY = startDragging.clientY;
        var startScrollTop = startDragging.scrollTop;
        var pos = {
          x: startX + (e2.clientX - startClientX),
          y: startY + (e2.clientY - startClientY) + (scrollTop - startScrollTop)
        };
        dragging.x = pos.x;
        dragging.y = pos.y;
        dragging.paddingLeft = paddingLeft;
        dragging.mousePos = mousePos;
        dragging.startMousePos = startMousePos;
        _this.props.setDragProgress(mousePos, dragging);
        var moved = doHandleDrag ? _this.handleDrag(dragging, e2, CanMoveFn) : false;
        if (!moved) {
          if (e2.preventDefault) e2.preventDefault();
        }
      };
      _this.onDragEnd = function() {
        var treeEl = _this.props.dragStart.treeEl;
        _this.props.setDragEnd();
        treeEl.classList.remove("qb-dragging");
        document.body.classList.remove("qb-dragging");
        _this._cacheEls = {};
        var target = _this.eventTarget || _this._getEventTarget();
        target.removeEventListener("mousemove", _this.onDrag);
        target.removeEventListener("mouseup", _this.onDragEnd);
      };
      _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_this);
      useOnPropsChanged(_this);
      _this.onPropsChanged(props);
      return _this;
    }
    _inherits$b(SortableContainer2, _Component);
    return _createClass$9(SortableContainer2, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        this.tree = getFlatTree2(nextProps.tree);
      }
    }, {
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        var prevProps = this.props;
        var prevState = this.state;
        var should = this.pureShouldComponentUpdate(nextProps, nextState);
        if (should) {
          if (prevState == nextState && prevProps != nextProps) {
            var chs = [];
            for (var k in nextProps) {
              var changed = nextProps[k] != prevProps[k];
              if (changed) {
                if (k != "dragging" && k != "mousePos") chs.push(k);
              }
            }
            if (!chs.length) should = false;
          }
        }
        return should;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(_prevProps, _prevState) {
        var dragging = this.props.dragging;
        var startDragging = this.props.dragStart;
        _isReorderingTree = false;
        if (startDragging && startDragging.id) {
          dragging.itemInfo = this.tree.items[dragging.id];
          if (dragging.itemInfo) {
            if (dragging.itemInfo.index != startDragging.itemInfo.index || dragging.itemInfo.parent != startDragging.itemInfo.parent) {
              var treeEl = startDragging.treeEl;
              var treeElContainer = startDragging.treeElContainer;
              var plhEl = this._getPlaceholderNodeEl(treeEl, true);
              if (plhEl) {
                var plX = plhEl.getBoundingClientRect().left + window.scrollX;
                var plY = plhEl.getBoundingClientRect().top + window.scrollY;
                var oldPlX = startDragging.plX;
                var oldPlY = startDragging.plY;
                var scrollTop = treeElContainer.scrollTop;
                startDragging.plX = plX;
                startDragging.plY = plY;
                startDragging.itemInfo = clone$2(dragging.itemInfo);
                startDragging.y = plhEl.offsetTop;
                startDragging.x = plhEl.offsetLeft;
                startDragging.clientY += plY - oldPlY;
                startDragging.clientX += plX - oldPlX;
                if (treeElContainer != document.body) startDragging.scrollTop = scrollTop;
                this.onDrag(this.props.mousePos, false);
              }
            }
          }
        }
      }
    }, {
      key: "_getNodeElById",
      value: function _getNodeElById(treeEl, indexId) {
        var ignoreCache = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        if (indexId == null) return null;
        if (!this._cacheEls) this._cacheEls = {};
        var el = this._cacheEls[indexId];
        if (el && document.contains(el) && !ignoreCache) return el;
        el = treeEl.querySelector('.group-or-rule-container[data-id="' + indexId + '"]');
        this._cacheEls[indexId] = el;
        return el;
      }
    }, {
      key: "_getDraggableNodeEl",
      value: function _getDraggableNodeEl(treeEl) {
        var ignoreCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!this._cacheEls) this._cacheEls = {};
        var el = this._cacheEls["draggable"];
        if (el && document.contains(el) && !ignoreCache) return el;
        var els = treeEl.getElementsByClassName("qb-draggable");
        el = els.length ? els[0] : null;
        this._cacheEls["draggable"] = el;
        return el;
      }
    }, {
      key: "_getPlaceholderNodeEl",
      value: function _getPlaceholderNodeEl(treeEl) {
        var ignoreCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!this._cacheEls) this._cacheEls = {};
        var el = this._cacheEls["placeholder"];
        if (el && document.contains(el) && !ignoreCache) return el;
        var els = treeEl.getElementsByClassName("qb-placeholder");
        el = els.length ? els[0] : null;
        this._cacheEls["placeholder"] = el;
        return el;
      }
    }, {
      key: "_isScrollable",
      value: function _isScrollable(node) {
        var overflowY = window.getComputedStyle(node)["overflow-y"];
        return (overflowY === "scroll" || overflowY === "auto") && node.scrollHeight > node.offsetHeight;
      }
    }, {
      key: "_getScrollParent",
      value: function _getScrollParent(node) {
        if (node == null) return null;
        if (node === document.body || this._isScrollable(node)) {
          return node;
        } else {
          return this._getScrollParent(node.parentNode);
        }
      }
    }, {
      key: "handleDrag",
      value: function handleDrag(dragInfo, e2, canMoveFn) {
        var _this2 = this;
        var canMoveBeforeAfterGroup = true;
        var itemInfo = dragInfo.itemInfo;
        var paddingLeft = dragInfo.paddingLeft;
        var moveInfo = null;
        var treeEl = this.props.dragStart.treeEl;
        var dragId = dragInfo.id;
        var dragEl = this._getDraggableNodeEl(treeEl);
        var plhEl = this._getPlaceholderNodeEl(treeEl);
        var dragRect, plhRect, hovRect, treeRect;
        if (dragEl && plhEl) {
          dragRect = dragEl.getBoundingClientRect();
          plhRect = plhEl.getBoundingClientRect();
          if (!plhRect.width) {
            return;
          }
          var dragDirs = {
            hrz: 0,
            vrt: 0
          };
          if (dragRect.top < plhRect.top) dragDirs.vrt = -1;
          else if (dragRect.bottom > plhRect.bottom) dragDirs.vrt = 1;
          if (dragRect.left > plhRect.left) dragDirs.hrz = 1;
          else if (dragRect.left < plhRect.left) dragDirs.hrz = -1;
          treeRect = treeEl.getBoundingClientRect();
          var trgCoord = {
            x: treeRect.left + (treeRect.right - treeRect.left) / 2,
            y: dragDirs.vrt >= 0 ? dragRect.bottom : dragRect.top
          };
          var hovCNodeEl;
          if (e2.__mocked_hov_container) {
            hovCNodeEl = e2.__mocked_hov_container;
          } else {
            var hovNodeEl = document.elementFromPoint(trgCoord.x, trgCoord.y - 1);
            hovCNodeEl = hovNodeEl ? hovNodeEl.closest(".group-or-rule-container") : null;
            if (!hovCNodeEl && hovNodeEl && hovNodeEl.classList.contains("query-builder-container")) {
              var _hovNodeEl$firstChild;
              var rootGroupContainer = hovNodeEl === null || hovNodeEl === void 0 || (_hovNodeEl$firstChild = hovNodeEl.firstChild) === null || _hovNodeEl$firstChild === void 0 ? void 0 : _hovNodeEl$firstChild.firstChild;
              if (rootGroupContainer && rootGroupContainer.classList.contains("group-or-rule-container")) {
                hovCNodeEl = rootGroupContainer;
              }
            }
          }
          if (!hovCNodeEl) {
            logger.log("out of tree bounds!");
          } else {
            var isGroup2 = hovCNodeEl.classList.contains("group-container");
            var hovNodeId = hovCNodeEl.getAttribute("data-id");
            var hovEl = hovCNodeEl;
            var doAppend = false;
            var doPrepend = false;
            if (hovEl) {
              hovRect = hovEl.getBoundingClientRect();
              var hovHeight = hovRect.bottom - hovRect.top;
              var hovII = this.tree.items[hovNodeId];
              if (!hovII) {
                throw new Error("There is an issue with rendering. If you use Next.js, please check getServerSideProps() method.");
              }
              var trgRect = null, trgEl = null, trgII = null, altII = null;
              if (dragDirs.vrt == 0) {
                trgII = itemInfo;
                trgEl = plhEl;
                if (trgEl) trgRect = trgEl.getBoundingClientRect();
              } else {
                if (isGroup2) {
                  if (dragDirs.vrt > 0) {
                    var hovInnerEl = hovCNodeEl.getElementsByClassName("group--header");
                    var hovEl2 = hovInnerEl.length ? hovInnerEl[0] : null;
                    if (hovEl2) {
                      var hovRect2 = hovEl2.getBoundingClientRect();
                      var hovHeight2 = hovRect2.bottom - hovRect2.top;
                      var isOverHover = dragRect.bottom - hovRect2.top > hovHeight2 * 3 / 4;
                      if (isOverHover && hovII.top > dragInfo.itemInfo.top) {
                        trgII = hovII;
                        trgRect = hovRect2;
                        trgEl = hovEl2;
                        doPrepend = true;
                      }
                    }
                  } else if (dragDirs.vrt < 0) {
                    if (hovII.lev >= itemInfo.lev) {
                      var isClimbToHover = hovRect.bottom - dragRect.top >= 2;
                      if (isClimbToHover && hovII.top < dragInfo.itemInfo.top) {
                        trgII = hovII;
                        trgRect = hovRect;
                        trgEl = hovEl;
                        doAppend = true;
                      }
                    }
                  }
                  if (!doPrepend && !doAppend || canMoveBeforeAfterGroup) {
                    var _isOverHover = dragDirs.vrt < 0 ? hovRect.bottom - dragRect.top > hovHeight - 5 : dragRect.bottom - hovRect.top > hovHeight - 5;
                    if (_isOverHover) {
                      if (!doPrepend && !doAppend) {
                        trgII = hovII;
                        trgRect = hovRect;
                        trgEl = hovEl;
                      }
                      {
                        altII = hovII;
                      }
                    }
                  }
                } else {
                  var _isOverHover2 = dragDirs.vrt < 0 ? hovRect.bottom - dragRect.top > hovHeight / 2 : dragRect.bottom - hovRect.top > hovHeight / 2;
                  if (_isOverHover2) {
                    trgII = hovII;
                    trgRect = hovRect;
                    trgEl = hovEl;
                  }
                }
              }
              var isSamePos = trgII && trgII.id == dragId;
              if (trgRect) {
                var dragLeftOffset = dragRect.left - treeRect.left;
                trgRect.left - treeRect.left;
                var dragLev = Math.max(0, Math.round(dragLeftOffset / paddingLeft));
                var availMoves = [];
                var altMoves = [];
                if (isSamePos) ;
                else {
                  if (isGroup2) {
                    if (doAppend) {
                      availMoves.push([PLACEMENT_APPEND, trgII, trgII.lev + 1]);
                    } else if (doPrepend) {
                      availMoves.push([PLACEMENT_PREPEND, trgII, trgII.lev + 1]);
                    }
                    if (altII) {
                      var isToRoot = altII.lev == 0;
                      var isToCase = altII.type == "case_group" && itemInfo.type != "case_group";
                      var prevCaseId = altII.prev && this.tree.items[altII.prev].caseId;
                      var nextCaseId = altII.next && this.tree.items[altII.next].caseId;
                      if (itemInfo.caseId == prevCaseId) prevCaseId = null;
                      if (itemInfo.caseId == nextCaseId) nextCaseId = null;
                      var prevCase = prevCaseId && this.tree.items[prevCaseId];
                      var nextCase = nextCaseId && this.tree.items[nextCaseId];
                      if (dragDirs.vrt > 0) {
                        if (isToRoot) {
                          altMoves.push([PLACEMENT_APPEND, altII, altII.lev + 1]);
                        } else if (isToCase && nextCase) {
                          altMoves.push([PLACEMENT_PREPEND, nextCase, nextCase.lev + 1]);
                        } else {
                          altMoves.push([PLACEMENT_AFTER, altII, altII.lev]);
                        }
                      } else if (dragDirs.vrt < 0) {
                        if (isToRoot) {
                          altMoves.push([PLACEMENT_PREPEND, altII, altII.lev + 1]);
                        } else if (isToCase && prevCase) {
                          altMoves.push([PLACEMENT_APPEND, prevCase, prevCase.lev + 1]);
                        } else {
                          altMoves.push([PLACEMENT_BEFORE, altII, altII.lev]);
                        }
                      }
                    }
                  }
                  if (!doAppend && !doPrepend) {
                    if (dragDirs.vrt < 0) {
                      availMoves.push([PLACEMENT_BEFORE, trgII, trgII.lev]);
                    } else if (dragDirs.vrt > 0) {
                      availMoves.push([PLACEMENT_AFTER, trgII, trgII.lev]);
                    }
                  }
                }
                var addCaseII = function addCaseII2(am) {
                  var toII = am[1];
                  var fromCaseII = itemInfo.caseId ? _this2.tree.items[itemInfo.caseId] : null;
                  var toCaseII = toII.caseId ? _this2.tree.items[toII.caseId] : null;
                  return [].concat(_toConsumableArray(am), [fromCaseII, toCaseII]);
                };
                availMoves = availMoves.map(addCaseII);
                altMoves = altMoves.map(addCaseII);
                availMoves = availMoves.filter(function(am) {
                  var placement = am[0];
                  var trg = am[1];
                  if ((placement == PLACEMENT_BEFORE || placement == PLACEMENT_AFTER) && trg.parent == null) return false;
                  if (trg.collapsed && (placement == PLACEMENT_APPEND || placement == PLACEMENT_PREPEND)) return false;
                  var isInside = trg.id == itemInfo.id;
                  if (!isInside) {
                    var tmp = trg;
                    while (tmp.parent) {
                      tmp = _this2.tree.items[tmp.parent];
                      if (tmp.id == itemInfo.id) {
                        isInside = true;
                        break;
                      }
                    }
                  }
                  return !isInside;
                }).map(function(am) {
                  var placement = am[0], toII = am[1];
                  am[2];
                  am[3];
                  am[4];
                  var toParentII = null;
                  if (placement == PLACEMENT_APPEND || placement == PLACEMENT_PREPEND) toParentII = toII;
                  else toParentII = _this2.tree.items[toII.parent];
                  if (toParentII && toParentII.parent == null) toParentII = null;
                  am[5] = toParentII;
                  return am;
                });
                var bestMode = null;
                var filteredMoves = availMoves.filter(function(am) {
                  return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);
                });
                if (filteredMoves.length == 0 && altMoves.length > 0) {
                  filteredMoves = altMoves.filter(function(am) {
                    return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);
                  });
                }
                var levs = filteredMoves.map(function(am) {
                  return am[2];
                });
                var curLev = itemInfo.lev;
                var allLevs = levs.concat(curLev);
                var closestDragLev = null;
                if (allLevs.indexOf(dragLev) != -1) closestDragLev = dragLev;
                else if (dragLev > Math.max.apply(Math, _toConsumableArray(allLevs))) closestDragLev = Math.max.apply(Math, _toConsumableArray(allLevs));
                else if (dragLev < Math.min.apply(Math, _toConsumableArray(allLevs))) closestDragLev = Math.min.apply(Math, _toConsumableArray(allLevs));
                bestMode = filteredMoves.find(function(am) {
                  return am[2] == closestDragLev;
                });
                if (!isSamePos && !bestMode && filteredMoves.length) bestMode = filteredMoves[0];
                moveInfo = bestMode;
              }
            }
          }
        }
        if (moveInfo) {
          this.move(itemInfo, moveInfo[1], moveInfo[0], moveInfo[3]);
          return true;
        }
        return false;
      }
    }, {
      key: "canMove",
      value: function canMove(fromII, toII, placement, fromCaseII, toCaseII, toParentII, canMoveFn) {
        if (!fromII || !toII) return false;
        if (fromII.id === toII.id) return false;
        var _this$props$config$se = this.props.config.settings, canRegroup = _this$props$config$se.canRegroup, canRegroupCases = _this$props$config$se.canRegroupCases, maxNesting = _this$props$config$se.maxNesting, maxNumberOfRules = _this$props$config$se.maxNumberOfRules, canLeaveEmptyCase = _this$props$config$se.canLeaveEmptyCase;
        var newLev = toParentII ? toParentII.lev + 1 : toII.lev;
        var newDepthLev = newLev + (fromII.depth || 0);
        var isBeforeAfter = placement == PLACEMENT_BEFORE || placement == PLACEMENT_AFTER;
        var isPend = placement == PLACEMENT_PREPEND || placement == PLACEMENT_APPEND;
        var isLev1 = isBeforeAfter && toII.lev == 1 || isPend && toII.lev == 0;
        var isParentChange = fromII.parent != toII.parent;
        var isStructChange = isPend || isParentChange;
        var isForbiddenStructChange = fromII.type == "case_group" && !isLev1 || fromII.parentType == "rule_group" || toII.type == "rule_group" || toII.parentType == "rule_group" || fromII.type != "case_group" && toII.type == "case_group" && isBeforeAfter || fromII.type != "case_group" && toII.type == "switch_group" || !canRegroupCases && fromII.caseId != toII.caseId;
        var isLockedChange = toII.isLocked || fromII.isLocked || toParentII && toParentII.isLocked;
        if (maxNesting && newDepthLev > maxNesting) return false;
        if (isStructChange && (!canRegroup || isForbiddenStructChange || isLockedChange)) return false;
        if (fromII.type != "case_group" && fromII.caseId != toII.caseId) {
          var isLastFromCase = fromCaseII ? fromCaseII._height == 2 : false;
          var newRulesInTargetCase = toCaseII ? toCaseII.atomicRulesCountInCase + 1 : 0;
          if (maxNumberOfRules && newRulesInTargetCase > maxNumberOfRules) return false;
          if (isLastFromCase && !canLeaveEmptyCase) return false;
        }
        if (fromII.type == "case_group" && (fromII.isDefaultCase || toII.isDefaultCase || toII.type == "switch_group" && placement == PLACEMENT_APPEND)) {
          return false;
        }
        var res = true;
        if (canMoveFn) {
          res = canMoveFn(fromII.node.toJS(), toII.node.toJS(), placement, toParentII ? toParentII.node.toJS() : null);
        }
        return res;
      }
    }, {
      key: "move",
      value: function move(fromII, toII, placement, toParentII) {
        if (!this._isUsingLegacyReactDomRender) {
          _isReorderingTree = true;
        }
        this.props.actions.moveItem(fromII.path, toII.path, placement);
      }
    }, {
      key: "render",
      value: function render3() {
        return /* @__PURE__ */ React.createElement(Builder2, _extends$h({}, this.props, {
          onDragStart: this.onDragStart
        }));
      }
    }]);
  }(reactExports.Component), _SortableContainer.propTypes = {
    tree: PropTypes.any.isRequired,
    //instanceOf(Immutable.Map)
    actions: PropTypes.object.isRequired
    // {moveItem: Function, ..}
    //... see Builder
  }, _SortableContainer;
};
const SortableContainer = function(Builder2) {
  var CanMoveFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var ConnectedSortableContainer = connect$1(function(state) {
    return {
      dragging: state.dragging,
      dragStart: state.dragStart,
      mousePos: state.mousePos
    };
  }, {
    setDragStart,
    setDragProgress,
    setDragEnd
  }, null, {
    context
  })(createSortableContainer(Builder2, CanMoveFn));
  ConnectedSortableContainer.displayName = "ConnectedSortableContainer";
  return ConnectedSortableContainer;
};
var _excluded$8 = ["isDraggingTempo", "isDraggingMe", "dragging"];
function _callSuper$n(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$n() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$n() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$n = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
const Draggable = function(className) {
  return function(GroupOrRule) {
    var _Draggable;
    return _Draggable = /* @__PURE__ */ function(_PureComponent) {
      function Draggable2(props) {
        var _this;
        _classCallCheck$b(this, Draggable2);
        _this = _callSuper$n(this, Draggable2, [props]);
        _this.handleDraggerMouseDown = function(e2) {
          var nodeId = _this.props.id;
          var dom = _this.wrapper.current;
          if (_this.props.onDragStart) {
            _this.props.onDragStart(nodeId, dom, e2);
          }
        };
        _this.wrapper = /* @__PURE__ */ React.createRef();
        return _this;
      }
      _inherits$b(Draggable2, _PureComponent);
      return _createClass$9(Draggable2, [{
        key: "render",
        value: function render3() {
          var _this$props = this.props, isDraggingTempo = _this$props.isDraggingTempo, isDraggingMe = _this$props.isDraggingMe, dragging = _this$props.dragging, otherProps = _objectWithoutProperties$2(_this$props, _excluded$8);
          var isTrueLocked = otherProps.isTrueLocked;
          var styles2 = {};
          if (isDraggingMe && isDraggingTempo) {
            if (_isReorderingTree) ;
            else {
              styles2 = {
                top: dragging.y,
                left: dragging.x,
                width: dragging.w
              };
            }
          }
          var cn = classNames(className, "group-or-rule", isDraggingMe && isDraggingTempo ? "qb-draggable" : null, isDraggingMe && !isDraggingTempo ? "qb-placeholder" : null, isTrueLocked ? "locked" : null);
          return /* @__PURE__ */ React.createElement("div", {
            className: cn,
            style: styles2,
            ref: this.wrapper,
            "data-id": this.props.id
          }, /* @__PURE__ */ React.createElement(GroupOrRule, _extends$h({
            handleDraggerMouseDown: this.handleDraggerMouseDown,
            isDraggingMe,
            isDraggingTempo
          }, otherProps)));
        }
      }]);
    }(reactExports.PureComponent), _Draggable.propTypes = {
      isDraggingTempo: PropTypes.bool,
      isDraggingMe: PropTypes.bool,
      onDragStart: PropTypes.func,
      dragging: PropTypes.object,
      //{id, x, y, w, h}
      isLocked: PropTypes.bool,
      isTrueLocked: PropTypes.bool
    }, _Draggable;
  };
};
var arrayMap$2 = _arrayMap, baseIteratee$2 = _baseIteratee, basePickBy = _basePickBy, getAllKeysIn = _getAllKeysIn;
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap$2(getAllKeysIn(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee$2(predicate);
  return basePickBy(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}
var pickBy_1 = pickBy;
const pickBy$1 = /* @__PURE__ */ getDefaultExportFromCjs(pickBy_1);
function ownKeys$h(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$h(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$h(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$h(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _callSuper$m(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$m() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$m() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$m = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var _Utils$ConfigUtils$6 = Utils$1.ConfigUtils, getFieldConfig$6 = _Utils$ConfigUtils$6.getFieldConfig, getOperatorConfig$3 = _Utils$ConfigUtils$6.getOperatorConfig;
var Operator = /* @__PURE__ */ function(_Component) {
  function Operator2(props) {
    var _this;
    _classCallCheck$b(this, Operator2);
    _this = _callSuper$m(this, Operator2, [props]);
    _this.shouldComponentUpdate = liteShouldComponentUpdate(_this, {
      // tip: rely on selectedFieldId instead
      selectedField: function selectedField(nextValue, prevValue) {
        return false;
      }
    });
    useOnPropsChanged(_this);
    _this.onPropsChanged(props);
    return _this;
  }
  _inherits$b(Operator2, _Component);
  return _createClass$9(Operator2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForMeta = ["config", "selectedField", "selectedFieldSrc", "selectedFieldType", "selectedOperator"];
      var needUpdateMeta = !this.meta || keysForMeta.map(function(k) {
        return nextProps[k] !== prevProps[k];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref) {
      var _config$types$selecte;
      var config2 = _ref.config, selectedField = _ref.selectedField, selectedFieldType = _ref.selectedFieldType, selectedOperator = _ref.selectedOperator;
      var fieldConfig = getFieldConfig$6(config2, selectedField);
      var operators2 = _toConsumableArray((fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.operators) || ((_config$types$selecte = config2.types[selectedFieldType]) === null || _config$types$selecte === void 0 ? void 0 : _config$types$selecte.operators) || []);
      if (!selectedField && !operators2.includes(selectedOperator)) {
        operators2.push(selectedOperator);
      }
      var operatorsOptions = mapValues$1(pickBy$1(config2.operators, function(item, key) {
        return (operators2 === null || operators2 === void 0 ? void 0 : operators2.indexOf(key)) !== -1;
      }), function(_opts, op2) {
        return getOperatorConfig$3(config2, op2, selectedField);
      });
      var items = this.buildOptions(config2, operatorsOptions, operators2);
      var selectedOpts = operatorsOptions[selectedOperator] || {};
      var placeholder2 = this.props.config.settings.operatorPlaceholder;
      var selectedKey = selectedOperator;
      var selectedKeys = selectedKey ? [selectedKey] : null;
      var selectedPath = selectedKeys;
      var selectedLabel = selectedOpts.label;
      var selectedAltLabel = selectedOpts.label2 || selectedOpts.tooltip;
      return {
        placeholder: placeholder2,
        items,
        selectedKey,
        selectedKeys,
        selectedPath,
        selectedLabel,
        selectedAltLabel,
        selectedOpts,
        fieldConfig
      };
    }
  }, {
    key: "buildOptions",
    value: function buildOptions3(config2, fields, ops) {
      if (!fields || !ops) return null;
      return keys$9(fields).sort(function(a2, b) {
        return ops.indexOf(a2) - ops.indexOf(b);
      }).map(function(fieldKey) {
        var field = fields[fieldKey];
        var label2 = field.label;
        var altLabel = field.label2;
        var tooltip = field.tooltip;
        return {
          key: fieldKey,
          path: fieldKey,
          label: label2,
          altLabel,
          tooltip
        };
      });
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, customProps = _this$props.customProps, setOperator4 = _this$props.setOperator, readonly = _this$props.readonly, id2 = _this$props.id, groupId = _this$props.groupId;
      var renderOperator3 = config2.settings.renderOperator;
      var renderProps = _objectSpread$h({
        id: id2,
        groupId,
        config: config2,
        customProps,
        readonly,
        setField: setOperator4
      }, this.meta);
      if (!renderProps.items) return null;
      return renderOperator3(renderProps, config2.ctx);
    }
  }]);
}(reactExports.Component);
Operator.propTypes = {
  id: PropTypes.string,
  groupId: PropTypes.string,
  config: PropTypes.object.isRequired,
  selectedField: PropTypes.any,
  selectedFieldId: PropTypes.string,
  selectedFieldType: PropTypes.string,
  selectedFieldSrc: PropTypes.string,
  selectedOperator: PropTypes.string,
  readonly: PropTypes.bool,
  customProps: PropTypes.object,
  //actions
  setOperator: PropTypes.func.isRequired
};
var _excluded$7 = ["children"];
var Col = function Col2(_ref) {
  var children = _ref.children, props = _objectWithoutProperties$2(_ref, _excluded$7);
  return /* @__PURE__ */ React.createElement("div", props, children);
};
var dummyFn = function dummyFn2() {
};
var DragIcon$1 = function DragIcon() {
  return /* @__PURE__ */ React.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "gray",
    width: "18px",
    height: "18px"
  }, /* @__PURE__ */ React.createElement("path", {
    d: "M0 0h24v24H0V0z",
    fill: "none"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"
  }));
};
var WithConfirmFn = function WithConfirmFn2(Cmp) {
  return function(props) {
    var useConfirm4 = props.config.settings.useConfirm;
    var confirmFn = useConfirm4 ? useConfirm4.call(props.config.ctx, props.config.ctx) : null;
    return /* @__PURE__ */ React.createElement(Cmp, _extends$h({}, props, {
      confirmFn
    }));
  };
};
var getWidgetId = function getWidgetId2(_ref2) {
  var id2 = _ref2.id, isLHS = _ref2.isLHS, delta2 = _ref2.delta, parentFuncs = _ref2.parentFuncs;
  return [id2, isLHS ? "L" : "R", isLHS ? -1 : delta2 || 0, (parentFuncs || []).map(function(_ref3) {
    var _ref4 = _slicedToArray$1(_ref3, 2), f = _ref4[0], a2 = _ref4[1];
    return "".concat(f, "(").concat(a2, ")");
  }).join("/")].join(":");
};
var getRenderFromConfig = function getRenderFromConfig2(config2, renderFn) {
  var Cmp;
  if (typeof renderFn === "function") {
    Cmp = function Cmp2(pr) {
      return renderFn === null || renderFn === void 0 ? void 0 : renderFn(pr, config2.ctx);
    };
    Cmp.displayName = renderFn.name;
  } else {
    Cmp = renderFn;
  }
  return Cmp;
};
function _callSuper$l(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$l() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$l() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$l = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var OperatorWrapper = /* @__PURE__ */ function(_PureComponent) {
  function OperatorWrapper2() {
    _classCallCheck$b(this, OperatorWrapper2);
    return _callSuper$l(this, OperatorWrapper2, arguments);
  }
  _inherits$b(OperatorWrapper2, _PureComponent);
  return _createClass$9(OperatorWrapper2, [{
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, selectedField = _this$props.selectedField, selectedFieldSrc = _this$props.selectedFieldSrc, selectedFieldType = _this$props.selectedFieldType, selectedOperator = _this$props.selectedOperator, setOperator4 = _this$props.setOperator, selectedFieldId = _this$props.selectedFieldId, showOperator = _this$props.showOperator, showOperatorLabel = _this$props.showOperatorLabel, selectedFieldWidgetConfig = _this$props.selectedFieldWidgetConfig, readonly = _this$props.readonly, id2 = _this$props.id, groupId = _this$props.groupId;
      var operator = showOperator && /* @__PURE__ */ React.createElement(Col, {
        key: "operators-for-" + selectedFieldId,
        className: "rule--operator"
      }, config2.settings.showLabels && /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, config2.settings.operatorLabel), /* @__PURE__ */ React.createElement(Operator, {
        key: "operator",
        config: config2,
        selectedField,
        selectedFieldSrc,
        selectedFieldType,
        selectedFieldId,
        selectedOperator,
        setOperator: setOperator4,
        customProps: config2.settings.customOperatorSelectProps,
        readonly,
        id: id2,
        groupId
      }));
      var hiddenOperator = showOperatorLabel && /* @__PURE__ */ React.createElement(Col, {
        key: "operators-for-" + selectedFieldId,
        className: "rule--operator"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "rule--operator-wrapper"
      }, config2.settings.showLabels ? /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, " ") : null, /* @__PURE__ */ React.createElement("div", {
        className: "rule--operator-text-wrapper"
      }, /* @__PURE__ */ React.createElement("span", {
        className: "rule--operator-text"
      }, selectedFieldWidgetConfig.operatorInlineLabel))));
      return [operator, hiddenOperator];
    }
  }]);
}(reactExports.PureComponent);
function ownKeys$g(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$g(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$g(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$g(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _callSuper$k(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$k() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$k() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$k = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var getFieldPathLabels$1 = Utils$1.RuleUtils.getFieldPathLabels;
var _Utils$ConfigUtils$5 = Utils$1.ConfigUtils, getFieldConfig$5 = _Utils$ConfigUtils$5.getFieldConfig, getFieldParts$2 = _Utils$ConfigUtils$5.getFieldParts, getFieldPathParts$2 = _Utils$ConfigUtils$5.getFieldPathParts;
var Field = /* @__PURE__ */ function(_Component) {
  function Field2(props) {
    var _this;
    _classCallCheck$b(this, Field2);
    _this = _callSuper$k(this, Field2, [props]);
    _this.setField = function(field, asyncListValues) {
      var _meta = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var id2 = _this.props.id;
      if (!_meta.widgetId) {
        var widgetId = [id2, "L", -1].join(":");
        _meta.widgetId = widgetId;
      }
      _this.props.setField(field, asyncListValues, _meta);
    };
    useOnPropsChanged(_this);
    _this.onPropsChanged(props);
    return _this;
  }
  _inherits$b(Field2, _Component);
  return _createClass$9(Field2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForMeta = ["selectedField", "selectedFieldSrc", "selectedFieldType", "config", "parentField"];
      var needUpdateMeta = !this.meta || keysForMeta.map(function(k) {
        return nextProps[k] !== prevProps[k];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref) {
      var selectedField = _ref.selectedField, selectedFieldType = _ref.selectedFieldType, config2 = _ref.config, parentField = _ref.parentField;
      var selectedKey = selectedField;
      var _config$settings = config2.settings, maxLabelsLength = _config$settings.maxLabelsLength, fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay, fieldPlaceholder = _config$settings.fieldPlaceholder;
      _config$settings.fieldSeparator;
      var isFieldSelected = !!selectedField;
      var placeholder2 = !isFieldSelected ? truncateString(fieldPlaceholder, maxLabelsLength) : null;
      var currField = isFieldSelected ? getFieldConfig$5(config2, selectedKey) : null;
      var selectedOpts = currField || {};
      var selectedKeys = getFieldPathParts$2(selectedKey, config2);
      var selectedPath = getFieldPathParts$2(selectedKey, config2, true);
      var selectedLabel = this.getFieldLabel(currField, selectedKey, config2);
      var partsLabels = getFieldPathLabels$1(selectedKey, config2);
      var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
      if (selectedFullLabel == selectedLabel || parentField) selectedFullLabel = null;
      var selectedAltLabel = selectedOpts.label2 || selectedOpts.tooltip;
      var parentFieldPath = getFieldParts$2(parentField, config2);
      var parentFieldConfig = parentField ? getFieldConfig$5(config2, parentField) : null;
      var sourceFields = parentField ? parentFieldConfig && parentFieldConfig.subfields : config2.fields;
      var lookingForFieldType = !isFieldSelected && selectedFieldType;
      var items = this.buildOptions(parentFieldPath, config2, sourceFields, lookingForFieldType, parentFieldPath);
      var errorText = lookingForFieldType ? "Please select field" : null;
      if (selectedKey && _typeof$3(selectedKey) === "object") {
        selectedKey = void 0;
      }
      return {
        placeholder: placeholder2,
        items,
        parentField,
        selectedKey,
        selectedKeys,
        selectedPath,
        selectedLabel,
        selectedOpts,
        selectedAltLabel,
        selectedFullLabel,
        errorText
      };
    }
  }, {
    key: "getFieldLabel",
    value: function getFieldLabel(fieldOpts, fieldKey, config2) {
      if (!fieldKey) return null;
      var maxLabelsLength = config2.settings.maxLabelsLength;
      var fieldParts = getFieldParts$2(fieldKey, config2);
      var label2 = (fieldOpts === null || fieldOpts === void 0 ? void 0 : fieldOpts.label) || last$2(fieldParts);
      label2 = truncateString(label2, maxLabelsLength);
      return label2;
    }
  }, {
    key: "buildOptions",
    value: function buildOptions3(parentFieldPath, config2, fields) {
      var _this2 = this;
      var fieldType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : void 0;
      var path = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
      var optGroup = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
      if (!fields) return null;
      var _config$settings2 = config2.settings, fieldSeparator = _config$settings2.fieldSeparator, fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
      var prefix = path !== null && path !== void 0 && path.length ? path.join(fieldSeparator) + fieldSeparator : "";
      var countFieldsMatchesType = function countFieldsMatchesType2(fields2) {
        return Object.keys(fields2 || {}).reduce(function(acc, fieldKey) {
          var field = fields2[fieldKey];
          if (field.type === "!struct") {
            return acc + countFieldsMatchesType2(field.subfields);
          } else {
            return acc + (field.type === fieldType ? 1 : 0);
          }
        }, 0);
      };
      return keys$9(fields).map(function(fieldKey) {
        var fullFieldPath = [].concat(_toConsumableArray(path !== null && path !== void 0 ? path : []), [fieldKey]);
        var field = fields[fieldKey];
        var label2 = _this2.getFieldLabel(field, fullFieldPath, config2);
        var partsLabels = getFieldPathLabels$1(fullFieldPath, config2);
        var fullLabel = partsLabels.join(fieldSeparatorDisplay);
        if (fullLabel == label2 || parentFieldPath !== null && parentFieldPath !== void 0 && parentFieldPath.length) fullLabel = null;
        var altLabel = field.label2;
        var tooltip = field.tooltip;
        var disabled = field.disabled;
        if (field.hideForSelect) return void 0;
        if (field.type == "!struct") {
          var items = _this2.buildOptions(parentFieldPath, config2, field.subfields, fieldType, fullFieldPath, {
            label: label2,
            tooltip
          });
          var hasItemsMatchesType = countFieldsMatchesType(field.subfields) > 0;
          return {
            disabled,
            key: fieldKey,
            path: prefix + fieldKey,
            label: label2,
            fullLabel,
            altLabel,
            tooltip,
            items,
            matchesType: hasItemsMatchesType
          };
        } else {
          var matchesType = fieldType !== void 0 ? field.type === fieldType : void 0;
          return {
            disabled,
            key: fieldKey,
            path: prefix + fieldKey,
            label: label2,
            fullLabel,
            altLabel,
            tooltip,
            grouplabel: optGroup === null || optGroup === void 0 ? void 0 : optGroup.label,
            group: optGroup,
            matchesType
          };
        }
      }).filter(function(o) {
        return !!o;
      });
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, customProps = _this$props.customProps, setFieldSrc4 = _this$props.setFieldSrc, readonly = _this$props.readonly, id2 = _this$props.id, groupId = _this$props.groupId;
      var renderField3 = config2.settings.renderField;
      var renderProps = _objectSpread$g({
        id: id2,
        groupId,
        config: config2,
        customProps,
        readonly,
        setField: this.setField,
        setFieldSrc: setFieldSrc4
      }, this.meta);
      return renderField3(renderProps, config2.ctx);
    }
  }]);
}(reactExports.Component);
Field.propTypes = {
  id: PropTypes.string,
  groupId: PropTypes.string,
  config: PropTypes.object.isRequired,
  selectedField: PropTypes.any,
  selectedFieldSrc: PropTypes.string,
  selectedFieldType: PropTypes.string,
  parentField: PropTypes.string,
  customProps: PropTypes.object,
  readonly: PropTypes.bool,
  //actions
  setField: PropTypes.func.isRequired,
  setFieldSrc: PropTypes.func
};
function ownKeys$f(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$f(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$f(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$f(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _callSuper$j(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$j() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$j() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$j = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var clone$1 = Utils$1.clone;
var _Utils$ConfigUtils$4 = Utils$1.ConfigUtils, getFieldConfig$4 = _Utils$ConfigUtils$4.getFieldConfig, getFuncConfig$1 = _Utils$ConfigUtils$4.getFuncConfig, getFieldParts$1 = _Utils$ConfigUtils$4.getFieldParts, getFieldPathParts$1 = _Utils$ConfigUtils$4.getFieldPathParts;
var _Utils$RuleUtils$2 = Utils$1.RuleUtils, getFuncPathLabels2 = _Utils$RuleUtils$2.getFuncPathLabels, getWidgetForFieldOp$2 = _Utils$RuleUtils$2.getWidgetForFieldOp;
var shallowEqual$2 = Utils$1.OtherUtils.shallowEqual;
var FuncSelect = /* @__PURE__ */ function(_Component) {
  function FuncSelect2(props) {
    var _this;
    _classCallCheck$b(this, FuncSelect2);
    _this = _callSuper$j(this, FuncSelect2, [props]);
    useOnPropsChanged(_this);
    _this.onPropsChanged(props);
    return _this;
  }
  _inherits$b(FuncSelect2, _Component);
  return _createClass$9(FuncSelect2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForItems = ["config", "field", "fieldType", "fieldSrc", "operator", "isFuncArg", "isLHS", "parentFuncs"];
      var keysForMeta = ["config", "field", "fieldType", "fieldSrc", "value", "isLHS"];
      var needUpdateItems = !this.items || keysForItems.map(function(k) {
        return k === "parentFuncs" ? !shallowEqual$2(nextProps[k], prevProps[k], true) : nextProps[k] !== prevProps[k];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      var needUpdateMeta = !this.meta || keysForMeta.map(function(k) {
        return nextProps[k] !== prevProps[k];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
      if (needUpdateItems) {
        this.items = this.getItems(nextProps, this.meta);
      }
    }
  }, {
    key: "getItems",
    value: function getItems(_ref, _ref2) {
      var config2 = _ref.config, field = _ref.field, fieldType = _ref.fieldType, isLHS = _ref.isLHS, operator = _ref.operator, parentFuncs = _ref.parentFuncs, fieldDefinition = _ref.fieldDefinition, isFuncArg = _ref.isFuncArg;
      var lookingForFieldType = _ref2.lookingForFieldType;
      var canUseFuncForField = config2.settings.canUseFuncForField;
      var filteredFuncs = this.filterFuncs(config2, config2.funcs, field, fieldType, isLHS, operator, canUseFuncForField, parentFuncs, isFuncArg, fieldDefinition);
      var items = this.buildOptions(config2, filteredFuncs, lookingForFieldType);
      return items;
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref3) {
      var config2 = _ref3.config;
      _ref3._field;
      var fieldType = _ref3.fieldType, value = _ref3.value, isLHS = _ref3.isLHS, isFuncArg = _ref3.isFuncArg;
      var _config$settings = config2.settings, funcPlaceholder = _config$settings.funcPlaceholder, fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay;
      var selectedFuncKey = value;
      var isFuncSelected = !!value;
      var placeholder2 = !isFuncSelected ? funcPlaceholder : null;
      var currFunc = isFuncSelected ? getFuncConfig$1(config2, selectedFuncKey) : null;
      var selectedOpts = currFunc || {};
      var selectedKeys = getFieldPathParts$1(selectedFuncKey, config2);
      var selectedPath = getFieldPathParts$1(selectedFuncKey, config2, true);
      var selectedLabel = this.getFuncLabel(currFunc, selectedFuncKey, config2);
      var partsLabels = getFuncPathLabels2(selectedFuncKey, config2);
      var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
      if (selectedFullLabel == selectedLabel) selectedFullLabel = null;
      var isRootFuncAtLHS = isLHS && !isFuncArg;
      var lookingForFieldType = isRootFuncAtLHS && !isFuncSelected && fieldType;
      var errorText = lookingForFieldType ? "Please select function" : null;
      return {
        placeholder: placeholder2,
        selectedKey: selectedFuncKey,
        selectedKeys,
        selectedPath,
        selectedLabel,
        selectedOpts,
        selectedFullLabel,
        errorText,
        lookingForFieldType
      };
    }
  }, {
    key: "filterFuncs",
    value: function filterFuncs(config2, funcs2, leftFieldFullkey, fieldType, isLHS, operator, canUseFuncForField, parentFuncs, isFuncArg, fieldDefinition) {
      funcs2 = clone$1(funcs2);
      var fieldSeparator = config2.settings.fieldSeparator;
      var leftFieldConfig = getFieldConfig$4(config2, leftFieldFullkey);
      var expectedType;
      var targetDefinition = leftFieldConfig;
      var widget = getWidgetForFieldOp$2(config2, leftFieldFullkey, operator, "value");
      widget && config2.widgets[widget];
      if (isFuncArg) {
        targetDefinition = fieldDefinition;
        expectedType = fieldDefinition === null || fieldDefinition === void 0 ? void 0 : fieldDefinition.type;
      } else if (leftFieldConfig) {
        expectedType = leftFieldConfig.type;
      } else if (!isLHS) {
        expectedType = fieldType;
      }
      function _filter(list2, path) {
        for (var funcKey in list2) {
          var subfields = list2[funcKey].subfields;
          var subpath = (path ? path : []).concat(funcKey);
          var funcFullkey = subpath.join(fieldSeparator);
          var funcConfig = getFuncConfig$1(config2, funcFullkey);
          if (funcConfig.type == "!struct") {
            if (_filter(subfields, subpath) == 0) delete list2[funcKey];
          } else {
            var _targetDefinition;
            var canUse = !expectedType || funcConfig.returnType == expectedType;
            if ((_targetDefinition = targetDefinition) !== null && _targetDefinition !== void 0 && _targetDefinition.funcs) canUse = canUse && targetDefinition.funcs.includes(funcFullkey);
            if (canUseFuncForField) canUse = canUse && canUseFuncForField(leftFieldFullkey, leftFieldConfig, funcFullkey, funcConfig, operator);
            if (!funcConfig.allowSelfNesting && parentFuncs && parentFuncs.map(function(_ref4) {
              var _ref5 = _slicedToArray$1(_ref4, 2), func = _ref5[0];
              _ref5[1];
              return func;
            }).includes(funcFullkey)) canUse = false;
            if (!canUse) delete list2[funcKey];
          }
        }
        return keys$9(list2).length;
      }
      _filter(funcs2, []);
      return funcs2;
    }
  }, {
    key: "buildOptions",
    value: function buildOptions3(config2, funcs2) {
      var _this2 = this;
      var fieldType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
      var path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      var optGroup = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
      if (!funcs2) return null;
      var _config$settings2 = config2.settings, fieldSeparator = _config$settings2.fieldSeparator, fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
      var prefix = path !== null && path !== void 0 && path.length ? path.join(fieldSeparator) + fieldSeparator : "";
      var countFieldsMatchesType = function countFieldsMatchesType2(fields) {
        return Object.keys(fields || {}).reduce(function(acc, fieldKey) {
          var field = fields[fieldKey];
          if (field.type === "!struct") {
            return acc + countFieldsMatchesType2(field.subfields);
          } else {
            return acc + (field.type === fieldType ? 1 : 0);
          }
        }, 0);
      };
      return keys$9(funcs2).map(function(funcKey) {
        var fullFuncPath = [].concat(_toConsumableArray(path !== null && path !== void 0 ? path : []), [funcKey]);
        var func = funcs2[funcKey];
        var label2 = _this2.getFuncLabel(func, fullFuncPath, config2);
        var partsLabels = getFuncPathLabels2(fullFuncPath, config2);
        var fullLabel = partsLabels.join(fieldSeparatorDisplay);
        if (fullLabel == label2) fullLabel = null;
        var tooltip = func.tooltip;
        if (func.type == "!struct") {
          var items = _this2.buildOptions(config2, func.subfields, fieldType, fullFuncPath, {
            label: label2,
            tooltip
          });
          var hasItemsMatchesType = countFieldsMatchesType(func.subfields) > 0;
          return {
            key: funcKey,
            path: prefix + funcKey,
            label: label2,
            fullLabel,
            tooltip,
            items,
            matchesType: hasItemsMatchesType
          };
        } else {
          var matchesType = fieldType !== void 0 ? func.returnType === fieldType : void 0;
          return {
            key: funcKey,
            path: prefix + funcKey,
            label: label2,
            fullLabel,
            tooltip,
            grouplabel: optGroup === null || optGroup === void 0 ? void 0 : optGroup.label,
            group: optGroup,
            matchesType
          };
        }
      });
    }
  }, {
    key: "getFuncLabel",
    value: function getFuncLabel(funcOpts, funcKey, config2) {
      if (!funcKey) return null;
      var maxLabelsLength = config2.settings.maxLabelsLength;
      var funcParts = getFieldParts$1(funcKey, config2);
      var label2 = (funcOpts === null || funcOpts === void 0 ? void 0 : funcOpts.label) || last$2(funcParts);
      label2 = truncateString(label2, maxLabelsLength);
      return label2;
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, customProps = _this$props.customProps, setValue4 = _this$props.setValue, readonly = _this$props.readonly, id2 = _this$props.id, groupId = _this$props.groupId;
      var renderFunc3 = config2.settings.renderFunc;
      var renderProps = _objectSpread$f({
        config: config2,
        customProps,
        readonly,
        setField: setValue4,
        items: this.items,
        id: id2,
        groupId
      }, this.meta);
      return renderFunc3(renderProps, config2.ctx);
    }
  }]);
}(reactExports.Component);
FuncSelect.propTypes = {
  id: PropTypes.string,
  groupId: PropTypes.string,
  config: PropTypes.object.isRequired,
  field: PropTypes.any,
  fieldType: PropTypes.string,
  fieldSrc: PropTypes.string,
  operator: PropTypes.string,
  customProps: PropTypes.object,
  value: PropTypes.string,
  setValue: PropTypes.func.isRequired,
  readonly: PropTypes.bool,
  parentFuncs: PropTypes.array,
  fieldDefinition: PropTypes.object,
  isFuncArg: PropTypes.bool,
  isLHS: PropTypes.bool
};
var nativeCeil = Math.ceil, nativeMax$3 = Math.max;
function baseRange$1(start, end, step, fromRight) {
  var index2 = -1, length = nativeMax$3(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
  while (length--) {
    result[fromRight ? length : ++index2] = start;
    start += step;
  }
  return result;
}
var _baseRange = baseRange$1;
var reWhitespace$1 = /\s/;
function trimmedEndIndex$2(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace$1.test(string.charAt(index2))) {
  }
  return index2;
}
var _trimmedEndIndex = trimmedEndIndex$2;
var trimmedEndIndex$1 = _trimmedEndIndex;
var reTrimStart$1 = /^\s+/;
function baseTrim$2(string) {
  return string ? string.slice(0, trimmedEndIndex$1(string) + 1).replace(reTrimStart$1, "") : string;
}
var _baseTrim = baseTrim$2;
var baseTrim$1 = _baseTrim, isObject$2 = isObject_1, isSymbol$1 = isSymbol_1;
var NAN$1 = 0 / 0;
var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary$1 = /^0b[01]+$/i;
var reIsOctal$1 = /^0o[0-7]+$/i;
var freeParseInt$1 = parseInt;
function toNumber$3(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$1(value)) {
    return NAN$1;
  }
  if (isObject$2(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$2(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim$1(value);
  var isBinary = reIsBinary$1.test(value);
  return isBinary || reIsOctal$1.test(value) ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8) : reIsBadHex$1.test(value) ? NAN$1 : +value;
}
var toNumber_1 = toNumber$3;
var toNumber$2 = toNumber_1;
var INFINITY$2 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite$2(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber$2(value);
  if (value === INFINITY$2 || value === -INFINITY$2) {
    var sign2 = value < 0 ? -1 : 1;
    return sign2 * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_1 = toFinite$2;
var baseRange = _baseRange, isIterateeCall$1 = _isIterateeCall, toFinite$1 = toFinite_1;
function createRange$1(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != "number" && isIterateeCall$1(start, end, step)) {
      end = step = void 0;
    }
    start = toFinite$1(start);
    if (end === void 0) {
      end = start;
      start = 0;
    } else {
      end = toFinite$1(end);
    }
    step = step === void 0 ? start < end ? 1 : -1 : toFinite$1(step);
    return baseRange(start, end, step, fromRight);
  };
}
var _createRange = createRange$1;
var createRange = _createRange;
var range = createRange();
var range_1 = range;
const range$1 = /* @__PURE__ */ getDefaultExportFromCjs(range_1);
var _excluded$6 = ["widgetFactory"], _excluded2 = ["factory"];
function ownKeys$e(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$e(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$e(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$e(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var getTitleInListValues2 = Utils$1.ListUtils.getTitleInListValues;
var _widgetDefKeysToOmit = Utils$1.ConfigUtils._widgetDefKeysToOmit;
var _Utils$TreeUtils$2 = Utils$1.TreeUtils, _fixImmutableValue2 = _Utils$TreeUtils$2._fixImmutableValue, isImmutable = _Utils$TreeUtils$2.isImmutable;
var WidgetFactoryMemo = /* @__PURE__ */ reactExports.memo(function(_ref) {
  var widgetFactory = _ref.widgetFactory, widgetProps = _objectWithoutProperties$2(_ref, _excluded$6);
  var config2 = widgetProps.config, isFuncArg = widgetProps.isFuncArg, fieldDefinition = widgetProps.fieldDefinition;
  var _ref2 = fieldDefinition || {}, fieldSettings = _ref2.fieldSettings, defaultValue = _ref2.defaultValue, valueSources = _ref2.valueSources;
  var isConst = isFuncArg && (valueSources === null || valueSources === void 0 ? void 0 : valueSources.length) == 1 && (valueSources === null || valueSources === void 0 ? void 0 : valueSources[0]) === "const";
  var listValues2 = (fieldSettings === null || fieldSettings === void 0 ? void 0 : fieldSettings.treeValues) || (fieldSettings === null || fieldSettings === void 0 ? void 0 : fieldSettings.listValues);
  if (isConst && defaultValue) {
    if (typeof defaultValue === "boolean") {
      return defaultValue ? widgetProps.labelYes || "YES" : widgetProps.labelNo || "NO";
    } else if (listValues2) {
      if (Array.isArray(defaultValue)) return defaultValue.map(function(v) {
        return getTitleInListValues2(listValues2, v) || v;
      }).join(", ");
      else return getTitleInListValues2(listValues2, defaultValue) || defaultValue;
    }
    return "" + defaultValue;
  }
  if (!widgetFactory) {
    return "?";
  }
  return widgetFactory(widgetProps, config2.ctx);
});
WidgetFactoryMemo.displayName = "WidgetFactoryMemo";
var WidgetFactory = function WidgetFactory2(_ref3) {
  var delta2 = _ref3.delta, isFuncArg = _ref3.isFuncArg, valueSrc = _ref3.valueSrc, immValue = _ref3.value, immValueError = _ref3.valueError, fieldError = _ref3.fieldError, asyncListValues = _ref3.asyncListValues, isSpecialRange = _ref3.isSpecialRange, fieldDefinition = _ref3.fieldDefinition, widget = _ref3.widget, widgetDefinition = _ref3.widgetDefinition, widgetValueLabel = _ref3.widgetValueLabel, valueLabels = _ref3.valueLabels, textSeparators = _ref3.textSeparators, setValue4 = _ref3.setValue, setFuncValue4 = _ref3.setFuncValue, config2 = _ref3.config, field = _ref3.field, fieldSrc = _ref3.fieldSrc, fieldPath = _ref3.fieldPath, fieldType = _ref3.fieldType, isLHS = _ref3.isLHS, operator = _ref3.operator, readonly = _ref3.readonly, parentField = _ref3.parentField, parentFuncs = _ref3.parentFuncs, id2 = _ref3.id, groupId = _ref3.groupId, widgetId = _ref3.widgetId;
  var widgetFactory = widgetDefinition.factory, fieldWidgetProps = _objectWithoutProperties$2(widgetDefinition, _excluded2);
  var fixedImmValue = immValue ? immValue.map(function(v) {
    return _fixImmutableValue2(v);
  }) : void 0;
  var value = reactExports.useMemo(function() {
    if (isSpecialRange) {
      var _value = [fixedImmValue === null || fixedImmValue === void 0 ? void 0 : fixedImmValue.get(0), fixedImmValue === null || fixedImmValue === void 0 ? void 0 : fixedImmValue.get(1)];
      if (_value[0] === void 0 && _value[1] === void 0) _value = void 0;
      return _value;
    }
    return fixedImmValue === null || fixedImmValue === void 0 ? void 0 : fixedImmValue.get(delta2);
  }, [isSpecialRange, immValue]);
  var valueError = reactExports.useMemo(function() {
    if (!immValueError) {
      return null;
    }
    if (isSpecialRange) {
      return [immValueError.get(0), immValueError.get(1), immValueError.get(2)];
    }
    return immValueError === null || immValueError === void 0 ? void 0 : immValueError.get(delta2);
  }, [isSpecialRange, immValue]);
  var errorMessage = isLHS ? fieldError : valueError;
  var _ref4 = fieldDefinition || {}, fieldSettings = _ref4.fieldSettings;
  var label2 = widgetValueLabel.label, placeholder2 = widgetValueLabel.placeholder;
  var placeholders = valueLabels ? valueLabels.placeholder : null;
  var simpleField = isImmutable(field) ? null : field;
  var widgetProps = omit$1(_objectSpread$e(_objectSpread$e(_objectSpread$e({}, fieldWidgetProps), fieldSettings), {}, {
    config: config2,
    field: simpleField,
    // !!! using of field prop in widget is strongly discouraged
    fieldPath,
    fieldSrc,
    fieldType,
    isLHS,
    parentField,
    parentFuncs,
    fieldDefinition,
    operator,
    delta: delta2,
    isSpecialRange,
    isFuncArg,
    value,
    valueSrc,
    valueError,
    fieldError,
    errorMessage,
    label: label2,
    placeholder: placeholder2,
    placeholders,
    textSeparators,
    setValue: setValue4,
    setFuncValue: setFuncValue4,
    readonly,
    asyncListValues,
    id: id2,
    groupId,
    widgetId,
    widgetFactory,
    widget
  }), [].concat(_toConsumableArray(_widgetDefKeysToOmit), ["toJS"]));
  return /* @__PURE__ */ React.createElement(WidgetFactoryMemo, _extends$h({
    widgetFactory
  }, widgetProps));
};
WidgetFactory.displayName = "WidgetFactory";
function _callSuper$i(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$i() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$i() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$i = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var _Utils$ConfigUtils$3 = Utils$1.ConfigUtils, getFieldConfig$3 = _Utils$ConfigUtils$3.getFieldConfig, getOperatorConfig$2 = _Utils$ConfigUtils$3.getOperatorConfig, getFieldWidgetConfig$2 = _Utils$ConfigUtils$3.getFieldWidgetConfig;
var _Utils$RuleUtils$1 = Utils$1.RuleUtils, getValueSourcesForFieldOp2 = _Utils$RuleUtils$1.getValueSourcesForFieldOp, getWidgetForFieldOp$1 = _Utils$RuleUtils$1.getWidgetForFieldOp, getValueLabel2 = _Utils$RuleUtils$1.getValueLabel;
var createListWithOneElement$1 = Utils$1.DefaultUtils.createListWithOneElement;
var shallowEqual$1 = Utils$1.OtherUtils.shallowEqual;
Utils$1.TreeUtils.isImmutable;
var funcArgDummyOpDef = {
  cardinality: 1
};
var Widget = /* @__PURE__ */ function(_Component) {
  function Widget2(_props) {
    var _this;
    _classCallCheck$b(this, Widget2);
    _this = _callSuper$i(this, Widget2, [_props]);
    _this._setValue = function(isSpecialRange, delta2, widgetType, widgetId, value, asyncListValues) {
      var _meta = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : {};
      if (!_meta.widgetId) {
        _meta.widgetId = widgetId;
      }
      if (isSpecialRange && Array.isArray(value)) {
        var oldRange = [_this.props.value.get(0), _this.props.value.get(1)];
        if (oldRange[0] != value[0]) _this.props.setValue(0, value[0], widgetType, asyncListValues, _meta);
        if (oldRange[1] != value[1]) _this.props.setValue(1, value[1], widgetType, asyncListValues, _meta);
      } else {
        _this.props.setValue(delta2, value, widgetType, asyncListValues, _meta);
      }
    };
    _this._setValueSrc = function(delta2, widgetId, srcKey) {
      var _meta = {
        widgetId
      };
      _this.props.setValueSrc(delta2, srcKey, _meta);
    };
    _this.renderWidget = function(delta2, meta, props) {
      var config2 = props.config, isFuncArg = props.isFuncArg, leftField = props.leftField, operator = props.operator, values2 = props.value, valueError = props.valueError, fieldError = props.fieldError, readonly = props.readonly, parentField = props.parentField, parentFuncs = props.parentFuncs, id2 = props.id, groupId = props.groupId, fieldSrc = props.fieldSrc, fieldType = props.fieldType, isLHS = props.isLHS, setFuncValue4 = props.setFuncValue;
      var settings2 = config2.settings;
      var widgets2 = meta.widgets, iValues = meta.iValues, aField = meta.aField, valueSources = meta.valueSources;
      var value = isFuncArg ? iValues : values2;
      var field = isFuncArg ? leftField : aField;
      var _widgets$delta = widgets2[delta2], valueSrc = _widgets$delta.valueSrc, valueLabel = _widgets$delta.valueLabel, widgetId = _widgets$delta.widgetId;
      var hasValueSources = valueSources.length > 1 && !readonly;
      var widgetLabel = settings2.showLabels ? /* @__PURE__ */ React.createElement("label", {
        key: "label-" + widgetId,
        className: "rule--label"
      }, valueLabel.label) : null;
      return /* @__PURE__ */ React.createElement("div", {
        key: "wrapper-" + widgetId,
        className: classNames(valueSrc === "func" ? "widget--func" : "widget--widget", hasValueSources ? "widget--has-valuerscs" : "widget--has-no-valuerscs")
      }, valueSrc === "func" ? null : widgetLabel, /* @__PURE__ */ React.createElement(WidgetFactory, _extends$h({
        key: widgetId,
        id: id2,
        groupId,
        widgetId,
        valueSrc,
        delta: delta2,
        value,
        valueError,
        fieldError,
        isFuncArg,
        isLHS
      }, pick$1(meta, ["isSpecialRange", "fieldDefinition", "asyncListValues"]), pick$1(widgets2[delta2], ["widget", "widgetDefinition", "widgetValueLabel", "valueLabels", "textSeparators", "setValue"]), {
        setFuncValue: setFuncValue4,
        config: config2,
        field,
        fieldSrc,
        fieldType,
        parentField,
        parentFuncs,
        operator,
        readonly
      })));
    };
    _this.renderValueSources = function(delta2, meta, props) {
      var config2 = props.config, isFuncArg = props.isFuncArg, leftField = props.leftField, operator = props.operator, readonly = props.readonly;
      var settings2 = config2.settings;
      var valueSources = meta.valueSources, widgets2 = meta.widgets, aField = meta.aField, valueSourcesOptions = meta.valueSourcesOptions;
      var field = isFuncArg ? leftField : aField;
      var _widgets$delta2 = widgets2[delta2], valueSrc = _widgets$delta2.valueSrc, setValueSrc4 = _widgets$delta2.setValueSrc;
      var ValueSources2 = _this.ValueSources;
      var sourceLabel = settings2.showLabels ? /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, " ") : null;
      return valueSources.length > 1 && !readonly && /* @__PURE__ */ React.createElement("div", {
        key: "wrapper-valuesrc-" + delta2,
        className: "widget--valuesrc"
      }, sourceLabel, /* @__PURE__ */ React.createElement(ValueSources2, {
        key: "valuesrc-" + delta2,
        delta: delta2,
        valueSources: valueSourcesOptions,
        valueSrc,
        config: config2,
        field,
        operator,
        setValueSrc: setValueSrc4,
        readonly,
        title: settings2.valueSourcesPopupTitle
      }));
    };
    _this.renderSep = function(delta2, meta, props) {
      var config2 = props.config;
      var widgets2 = meta.widgets;
      var settings2 = config2.settings;
      var sepText = widgets2[delta2].sepText;
      var sepLabel = settings2.showLabels ? /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, " ") : null;
      return sepText && /* @__PURE__ */ React.createElement("div", {
        key: "widget-separators-" + delta2,
        className: classNames("widget--sep", delta2 == 0 && "widget--sep-first")
      }, sepLabel, /* @__PURE__ */ React.createElement("span", null, sepText));
    };
    _this.renderWidgetDelta = function(delta2) {
      var sep = _this.renderSep(delta2, _this.meta, _this.props);
      var sources = _this.renderValueSources(delta2, _this.meta, _this.props);
      var widgetCmp = _this.renderWidget(delta2, _this.meta, _this.props);
      return [sep, sources, widgetCmp];
    };
    useOnPropsChanged(_this);
    _this.onPropsChanged(_props);
    return _this;
  }
  _inherits$b(Widget2, _Component);
  return _createClass$9(Widget2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var configChanged = !this.ValueSources || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.config) !== (nextProps === null || nextProps === void 0 ? void 0 : nextProps.config);
      var keysForMeta = ["config", "id", "parentFuncs", "field", "fieldId", "fieldSrc", "fieldType", "fieldFunc", "fieldArg", "leftField", "operator", "valueSrc", "asyncListValues", "isLHS", "isFuncArg", "isForRuleGroup", "isCaseValue", "value"];
      var changedKeys = keysForMeta.filter(function(k) {
        if (k === "parentFuncs") {
          return !shallowEqual$1(nextProps[k], prevProps[k], true);
        }
        if (k === "field") {
          return nextProps["fieldId"] !== prevProps["fieldId"];
        }
        return nextProps[k] !== prevProps[k];
      });
      var needUpdateMeta = !this.meta || changedKeys.length > 0;
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps, changedKeys);
      }
      if (configChanged) {
        var config2 = nextProps.config;
        var renderValueSources3 = config2.settings.renderValueSources;
        this.ValueSources = getRenderFromConfig(config2, renderValueSources3);
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref) {
      var _iValueSrcs, _iValueSrcs2, _this$meta, _this$meta2, _this2 = this;
      var config2 = _ref.config, simpleField = _ref.field;
      _ref.fieldSrc;
      var fieldType = _ref.fieldType, fieldFunc = _ref.fieldFunc, fieldArg = _ref.fieldArg, operator = _ref.operator, valueSrcs = _ref.valueSrc, values2 = _ref.value, isForRuleGroup = _ref.isForRuleGroup, isCaseValue = _ref.isCaseValue, isFuncArg = _ref.isFuncArg;
      _ref.leftField;
      var asyncListValues = _ref.asyncListValues, parentFuncs = _ref.parentFuncs, isLHS = _ref.isLHS, id2 = _ref.id;
      var changedKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var valueSourcesInfo = config2.settings.valueSourcesInfo;
      var field = isFuncArg ? {
        func: fieldFunc,
        arg: fieldArg
      } : simpleField;
      var isOkWithoutField = !simpleField && fieldType;
      var iValueSrcs = valueSrcs;
      var iValues = values2;
      if (isFuncArg || isForRuleGroup || isCaseValue) {
        iValueSrcs = createListWithOneElement$1(valueSrcs);
        iValues = createListWithOneElement$1(values2);
      }
      var fieldDefinition = getFieldConfig$3(config2, field);
      if (!fieldDefinition && isOkWithoutField) {
        fieldDefinition = config2.types[fieldType];
      }
      var defaultWidget = getWidgetForFieldOp$1(config2, field, operator);
      if (!defaultWidget && isOkWithoutField) {
        var _config$types$fieldTy;
        defaultWidget = (_config$types$fieldTy = config2.types[fieldType]) === null || _config$types$fieldTy === void 0 ? void 0 : _config$types$fieldTy.mainWidget;
      }
      var operatorDefinition = isFuncArg ? funcArgDummyOpDef : getOperatorConfig$2(config2, operator, field);
      if ((fieldDefinition == null || operatorDefinition == null) && !isCaseValue) {
        return null;
      }
      var isSpecialRange = operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.isSpecialRange;
      var isSpecialRangeForSrcField = isSpecialRange && (((_iValueSrcs = iValueSrcs) === null || _iValueSrcs === void 0 ? void 0 : _iValueSrcs.get(0)) === "field" || ((_iValueSrcs2 = iValueSrcs) === null || _iValueSrcs2 === void 0 ? void 0 : _iValueSrcs2.get(1)) === "field");
      var isTrueSpecialRange = isSpecialRange && !isSpecialRangeForSrcField;
      var cardinality = isTrueSpecialRange ? 1 : getOpCardinality(operatorDefinition);
      if (cardinality === 0) {
        return null;
      }
      var valueSources = (_this$meta = this.meta) === null || _this$meta === void 0 ? void 0 : _this$meta.valueSources;
      var valueSourcesOptions = (_this$meta2 = this.meta) === null || _this$meta2 === void 0 ? void 0 : _this$meta2.valueSourcesOptions;
      if (!valueSources || ["field", "operator", "config", "fieldDefinition", "isForRuleGroup"].filter(function(k) {
        return changedKeys.includes(k);
      }).length) {
        valueSources = getValueSourcesForFieldOp2(config2, field, operator, fieldDefinition);
        if (isForRuleGroup) {
          valueSources = ["value"];
        }
        if (!field) {
          valueSources = Object.keys(valueSourcesInfo);
        }
        valueSourcesOptions = valueSources.map(function(srcKey) {
          return [srcKey, {
            label: valueSourcesInfo[srcKey].label
          }];
        });
      }
      var widgets2 = range$1(0, cardinality).map(function(delta2) {
        var _this2$meta, _iValueSrcs3, _widgetDefinition, _this2$meta2;
        var oldWidgetMeta = (_this2$meta = _this2.meta) === null || _this2$meta === void 0 || (_this2$meta = _this2$meta.widgets) === null || _this2$meta === void 0 ? void 0 : _this2$meta[delta2];
        var valueSrc = ((_iValueSrcs3 = iValueSrcs) === null || _iValueSrcs3 === void 0 ? void 0 : _iValueSrcs3.get(delta2)) || null;
        var widget = getWidgetForFieldOp$1(config2, field, operator, valueSrc);
        var widgetDefinition = getFieldWidgetConfig$2(config2, field, operator, widget, valueSrc);
        if (isSpecialRangeForSrcField) {
          widget = widgetDefinition.singleWidget;
          widgetDefinition = getFieldWidgetConfig$2(config2, field, operator, widget, valueSrc);
        }
        if (!widgetDefinition && isOkWithoutField) {
          widget = ["func", "field"].includes(valueSrc) ? valueSrc : defaultWidget;
          widgetDefinition = config2.widgets[widget];
        }
        var widgetType = (_widgetDefinition = widgetDefinition) === null || _widgetDefinition === void 0 ? void 0 : _widgetDefinition.type;
        var valueLabel = getValueLabel2(config2, field, operator, delta2, valueSrc, isTrueSpecialRange);
        var widgetValueLabel = getValueLabel2(config2, field, operator, delta2, null, isTrueSpecialRange);
        var sepText = operatorDefinition !== null && operatorDefinition !== void 0 && operatorDefinition.textSeparators ? operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.textSeparators[delta2] : null;
        var valueLabels = null;
        var textSeparators = null;
        if (isSpecialRange) {
          valueLabels = [getValueLabel2(config2, field, operator, 0), getValueLabel2(config2, field, operator, 1)];
          valueLabels = {
            placeholder: [valueLabels[0].placeholder, valueLabels[1].placeholder],
            label: [valueLabels[0].label, valueLabels[1].label]
          };
          textSeparators = operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.textSeparators;
        }
        var widgetId = getWidgetId({
          id: id2,
          isLHS,
          delta: delta2,
          parentFuncs
        });
        var vsId = widgetId + ":VS";
        var setValueSrc4 = oldWidgetMeta === null || oldWidgetMeta === void 0 ? void 0 : oldWidgetMeta.setValueSrc;
        if (!setValueSrc4 || (oldWidgetMeta === null || oldWidgetMeta === void 0 ? void 0 : oldWidgetMeta.widgetId) !== widgetId) {
          setValueSrc4 = _this2._setValueSrc.bind(_this2, delta2, vsId);
        }
        var setValue4 = oldWidgetMeta === null || oldWidgetMeta === void 0 ? void 0 : oldWidgetMeta.setValue;
        if (!setValue4 || (oldWidgetMeta === null || oldWidgetMeta === void 0 ? void 0 : oldWidgetMeta.widgetId) !== widgetId || (oldWidgetMeta === null || oldWidgetMeta === void 0 ? void 0 : oldWidgetMeta.widgetType) !== widgetType || ((_this2$meta2 = _this2.meta) === null || _this2$meta2 === void 0 ? void 0 : _this2$meta2.isSpecialRange) !== isSpecialRange) {
          setValue4 = _this2._setValue.bind(_this2, isSpecialRange, delta2, widgetType, widgetId);
        }
        return {
          valueSrc,
          valueLabel,
          widget,
          sepText,
          widgetDefinition,
          widgetValueLabel,
          valueLabels,
          textSeparators,
          setValueSrc: setValueSrc4,
          setValue: setValue4,
          widgetId,
          widgetType
        };
      });
      return {
        defaultWidget,
        fieldDefinition,
        operatorDefinition,
        isSpecialRange: isTrueSpecialRange,
        cardinality,
        valueSources,
        valueSourcesOptions,
        widgets: widgets2,
        iValues,
        //correct for isFuncArg
        aField: field,
        //correct for isFuncArg
        asyncListValues
      };
    }
  }, {
    key: "render",
    value: function render3() {
      if (!this.meta) return null;
      var _this$meta3 = this.meta, defaultWidget = _this$meta3.defaultWidget, cardinality = _this$meta3.cardinality;
      if (!defaultWidget) return null;
      var name2 = defaultWidget;
      return /* @__PURE__ */ React.createElement(Col, {
        className: "rule--widget rule--widget--".concat(name2.toUpperCase()),
        key: "widget-col-" + name2
      }, range$1(0, cardinality).map(this.renderWidgetDelta));
    }
  }]);
}(reactExports.Component);
Widget.propTypes = {
  config: PropTypes.object.isRequired,
  value: PropTypes.any,
  //instanceOf(Immutable.List)
  valueSrc: PropTypes.any,
  //instanceOf(Immutable.List)
  valueError: PropTypes.any,
  //instanceOf(Immutable.List)
  fieldError: PropTypes.string,
  field: PropTypes.any,
  fieldSrc: PropTypes.string,
  fieldType: PropTypes.string,
  fieldId: PropTypes.string,
  operator: PropTypes.string,
  readonly: PropTypes.bool,
  asyncListValues: PropTypes.array,
  id: PropTypes.string,
  groupId: PropTypes.string,
  //actions
  setValue: PropTypes.func,
  setValueSrc: PropTypes.func,
  setFuncValue: PropTypes.func,
  // for isFuncArg
  isFuncArg: PropTypes.bool,
  fieldFunc: PropTypes.string,
  fieldArg: PropTypes.string,
  leftField: PropTypes.any,
  // for RuleGroupExt
  isForRuleGroup: PropTypes.bool,
  parentField: PropTypes.string,
  // for func in func
  parentFuncs: PropTypes.array,
  isLHS: PropTypes.bool,
  // for case_value
  isCaseValue: PropTypes.bool
};
function _callSuper$h(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$h() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$h() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$h = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var getFuncConfig2 = Utils$1.ConfigUtils.getFuncConfig;
var shallowEqual = Utils$1.OtherUtils.shallowEqual;
var FuncWidget = /* @__PURE__ */ function(_Component) {
  function FuncWidget2(props) {
    var _this;
    _classCallCheck$b(this, FuncWidget2);
    _this = _callSuper$h(this, FuncWidget2, [props]);
    _this.setFunc = function(funcKey) {
      var _meta = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _this$props = _this.props, isLHS = _this$props.isLHS, delta2 = _this$props.delta, parentFuncs = _this$props.parentFuncs, id2 = _this$props.id;
      if (!_meta.widgetId) {
        var widgetId = getWidgetId({
          id: id2,
          isLHS,
          delta: delta2,
          parentFuncs
        });
        _meta.widgetId = widgetId;
      }
      _this.props.setFuncValue(isLHS ? -1 : delta2 || 0, parentFuncs, null, funcKey, "!func", void 0, _meta);
    };
    _this.setArgValue = function(argKey, argVal, widgetType, asyncListValues, _meta) {
      var _this$props2 = _this.props;
      _this$props2.config;
      var delta2 = _this$props2.delta, isLHS = _this$props2.isLHS, parentFuncs = _this$props2.parentFuncs;
      _this.props.setFuncValue(isLHS ? -1 : delta2 || 0, parentFuncs, argKey, argVal, widgetType, asyncListValues, _meta);
    };
    _this.setArgValueSrc = function(argKey, argValSrc, _meta) {
      var _this$props3 = _this.props;
      _this$props3.config;
      var delta2 = _this$props3.delta, isLHS = _this$props3.isLHS, parentFuncs = _this$props3.parentFuncs;
      _this.props.setFuncValue(isLHS ? -1 : delta2 || 0, parentFuncs, argKey, argValSrc, "!valueSrc", void 0, _meta);
    };
    _this.renderFuncSelect = function() {
      var _value$get, _value$get2;
      var _this$props4 = _this.props, config2 = _this$props4.config, field = _this$props4.field, fieldType = _this$props4.fieldType, fieldSrc = _this$props4.fieldSrc, isLHS = _this$props4.isLHS, operator = _this$props4.operator, customProps = _this$props4.customProps, value = _this$props4.value, readonly = _this$props4.readonly, parentFuncs = _this$props4.parentFuncs, id2 = _this$props4.id, groupId = _this$props4.groupId, isFuncArg = _this$props4.isFuncArg, fieldDefinition = _this$props4.fieldDefinition;
      var funcKey = (_value$get = value === null || value === void 0 || (_value$get2 = value.get) === null || _value$get2 === void 0 ? void 0 : _value$get2.call(value, "func")) !== null && _value$get !== void 0 ? _value$get : null;
      var selectProps = {
        value: funcKey,
        setValue: _this.setFunc,
        config: config2,
        field,
        fieldType,
        fieldSrc,
        isLHS,
        operator,
        customProps,
        readonly,
        parentFuncs,
        isFuncArg,
        fieldDefinition,
        id: id2,
        groupId
      };
      var _config$settings = config2.settings, showLabels = _config$settings.showLabels, funcLabel = _config$settings.funcLabel;
      var widgetLabel = showLabels ? /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, funcLabel) : null;
      return /* @__PURE__ */ React.createElement(Col, {
        key: "func",
        className: "rule--func"
      }, widgetLabel, /* @__PURE__ */ React.createElement(FuncSelect, selectProps));
    };
    _this.renderArgLabel = function(argKey, argDefinition) {
      var valueSources = argDefinition.valueSources, type2 = argDefinition.type, showPrefix = argDefinition.showPrefix, label2 = argDefinition.label;
      var config2 = _this.props.config;
      var isConst = valueSources && valueSources.length == 1 && valueSources[0] == "const";
      var forceShow = !config2.settings.showLabels && (type2 == "boolean" || isConst) && showPrefix;
      if (!forceShow) return null;
      return /* @__PURE__ */ React.createElement(Col, {
        className: "rule--func--arg-label"
      }, label2 || argKey);
    };
    _this.renderArgLabelSep = function(argKey, argDefinition) {
      var valueSources = argDefinition.valueSources, type2 = argDefinition.type, showPrefix = argDefinition.showPrefix;
      var config2 = _this.props.config;
      var isConst = valueSources && valueSources.length == 1 && valueSources[0] == "const";
      var forceShow = !config2.settings.showLabels && (type2 == "boolean" || isConst) && showPrefix;
      if (!forceShow) return null;
      return /* @__PURE__ */ React.createElement(Col, {
        className: "rule--func--arg-label-sep"
      }, ":");
    };
    _this.renderArgVal = function(funcKey, argKey, argDefinition) {
      var _this$props5 = _this.props, config2 = _this$props5.config, field = _this$props5.field, fieldType = _this$props5.fieldType, fieldSrc = _this$props5.fieldSrc, isLHS = _this$props5.isLHS;
      _this$props5.operator;
      var value = _this$props5.value, readonly = _this$props5.readonly, parentFuncs = _this$props5.parentFuncs, id2 = _this$props5.id, groupId = _this$props5.groupId, fieldError = _this$props5.fieldError, valueError = _this$props5.valueError, setFuncValue4 = _this$props5.setFuncValue;
      var arg = value ? value.getIn(["args", argKey]) : null;
      var argVal = arg ? arg.get("value") : void 0;
      var defaultValueSource = argDefinition.valueSources.length == 1 ? argDefinition.valueSources[0] : void 0;
      var argValSrc = arg ? arg.get("valueSrc") || defaultValueSource || "value" : defaultValueSource;
      var widgetProps = {
        config: config2,
        fieldFunc: funcKey,
        fieldArg: argKey,
        leftField: field,
        fieldType,
        // type of leftField
        fieldSrc,
        // src of leftField
        fieldError,
        // error in LHS
        valueError,
        // error in RHS
        isLHS,
        operator: null,
        value: argVal,
        valueSrc: argValSrc,
        setValue: _this.setArgValue,
        setValueSrc: _this.setArgValueSrc,
        setFuncValue: setFuncValue4,
        funcKey,
        argKey,
        argDefinition,
        readonly,
        parentFuncs,
        id: id2,
        groupId
      };
      return /* @__PURE__ */ React.createElement(Col, {
        className: "rule--func--arg-value"
      }, /* @__PURE__ */ React.createElement(ArgWidget, widgetProps));
    };
    _this.renderArgSep = function(argKey, argDefinition, argIndex, _ref) {
      var renderSeps = _ref.renderSeps;
      if (!argIndex) return null;
      return /* @__PURE__ */ React.createElement(Col, {
        className: "rule--func--arg-sep"
      }, renderSeps ? renderSeps[argIndex - 1] : ", ");
    };
    _this.renderBracketBefore = function(_ref2) {
      var renderBrackets = _ref2.renderBrackets;
      return /* @__PURE__ */ React.createElement(Col, {
        key: "before_args",
        className: "rule--func--bracket-before"
      }, renderBrackets ? renderBrackets[0] : "(");
    };
    _this.renderBracketAfter = function(_ref3) {
      var renderBrackets = _ref3.renderBrackets;
      return /* @__PURE__ */ React.createElement(Col, {
        key: "after_args",
        className: "rule--func--bracket-after"
      }, renderBrackets ? renderBrackets[1] : ")");
    };
    _this.renderFuncArgs = function() {
      var _this$meta = _this.meta, funcDefinition = _this$meta.funcDefinition, funcKey = _this$meta.funcKey;
      if (!funcKey) return null;
      var _ref4 = funcDefinition || {}, args = _ref4.args;
      if (!args) return null;
      return /* @__PURE__ */ React.createElement(React.Fragment, null, _this.renderBracketBefore(funcDefinition), /* @__PURE__ */ React.createElement(Col, {
        key: "args-".concat(funcKey),
        className: "rule--func--args rule--func--".concat(funcKey, "--args")
      }, Object.keys(args).map(function(argKey, argIndex) {
        return /* @__PURE__ */ React.createElement(Col, {
          key: "arg-".concat(argKey, "-").concat(argIndex),
          className: "rule--func--arg rule--func--".concat(funcKey, "--arg--").concat(argKey)
        }, _this.renderArgSep(argKey, args[argKey], argIndex, funcDefinition), _this.renderArgLabel(argKey, args[argKey]), _this.renderArgLabelSep(argKey, args[argKey]), _this.renderArgVal(funcKey, argKey, args[argKey]));
      })), _this.renderBracketAfter(funcDefinition));
    };
    useOnPropsChanged(_this);
    _this.onPropsChanged(props);
    return _this;
  }
  _inherits$b(FuncWidget2, _Component);
  return _createClass$9(FuncWidget2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForMeta = ["config", "field", "operator", "value", "fieldSrc", "fieldType", "isLHS"];
      var needUpdateMeta = !this.meta || keysForMeta.map(function(k) {
        return k === "parentFuncs" ? !shallowEqual(nextProps[k], prevProps[k], true) : nextProps[k] !== prevProps[k];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref5) {
      var _value$get3, _value$get4;
      var config2 = _ref5.config;
      _ref5.field;
      _ref5.operator;
      var value = _ref5.value;
      var funcKey = (_value$get3 = value === null || value === void 0 || (_value$get4 = value.get) === null || _value$get4 === void 0 ? void 0 : _value$get4.call(value, "func")) !== null && _value$get3 !== void 0 ? _value$get3 : null;
      var funcDefinition = funcKey ? getFuncConfig2(config2, funcKey) : null;
      return {
        funcDefinition,
        funcKey
      };
    }
  }, {
    key: "render",
    value: function render3() {
      var parentFuncs = this.props.parentFuncs;
      var funcPath = parentFuncs ? parentFuncs.map(function(_ref6) {
        var _ref7 = _slicedToArray$1(_ref6, 2), f = _ref7[0], a2 = _ref7[1];
        return "".concat(f, "_").concat(a2);
      }).join("-") : "root";
      var funcLevel = (parentFuncs === null || parentFuncs === void 0 ? void 0 : parentFuncs.length) || 0;
      return /* @__PURE__ */ React.createElement(Col, {
        className: "rule--func--wrapper rule--func--wrapper--under-".concat(funcPath, " rule--func--wrapper--lev-").concat(funcLevel)
      }, this.renderFuncSelect(), this.renderFuncArgs());
    }
  }]);
}(reactExports.Component);
FuncWidget.propTypes = {
  id: PropTypes.string,
  groupId: PropTypes.string,
  config: PropTypes.object.isRequired,
  field: PropTypes.any,
  fieldSrc: PropTypes.string,
  fieldType: PropTypes.string,
  fieldError: PropTypes.string,
  operator: PropTypes.string,
  customProps: PropTypes.object,
  value: PropTypes.object,
  //instanceOf(Immutable.Map) //with keys 'func' and `args`
  setValue: PropTypes.func.isRequired,
  setFuncValue: PropTypes.func,
  readonly: PropTypes.bool,
  parentFuncs: PropTypes.array,
  fieldDefinition: PropTypes.object,
  isFuncArg: PropTypes.bool,
  isLHS: PropTypes.bool,
  valueError: PropTypes.string
};
var ArgWidget = /* @__PURE__ */ function(_Component2) {
  function ArgWidget2(props) {
    var _this2;
    _classCallCheck$b(this, ArgWidget2);
    _this2 = _callSuper$h(this, ArgWidget2, [props]);
    _this2.setValue = function(_delta, value, widgetType, asyncListValues, _meta) {
      var _this2$props = _this2.props, setValue4 = _this2$props.setValue, argKey = _this2$props.argKey;
      setValue4(argKey, value, widgetType, asyncListValues, _meta);
    };
    _this2.setValueSrc = function(_delta, valueSrc, _meta) {
      var _this2$props2 = _this2.props, setValueSrc4 = _this2$props2.setValueSrc, argKey = _this2$props2.argKey;
      setValueSrc4(argKey, valueSrc, _meta);
    };
    useOnPropsChanged(_this2);
    _this2.onPropsChanged(props);
    return _this2;
  }
  _inherits$b(ArgWidget2, _Component2);
  return _createClass$9(ArgWidget2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForMeta = ["parentFuncs", "funcKey", "argKey"];
      var needUpdateMeta = !this.meta || keysForMeta.map(function(k) {
        return k === "parentFuncs" ? !shallowEqual(nextProps[k], prevProps[k], true) : nextProps[k] !== prevProps[k];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref8) {
      var parentFuncs = _ref8.parentFuncs, funcKey = _ref8.funcKey, argKey = _ref8.argKey;
      var newParentFuncs = [].concat(_toConsumableArray(parentFuncs || []), [[funcKey, argKey]]);
      return {
        parentFuncs: newParentFuncs
      };
    }
  }, {
    key: "render",
    value: function render3() {
      var parentFuncs = this.meta.parentFuncs;
      return /* @__PURE__ */ React.createElement(Widget, _extends$h({}, this.props, {
        setValue: this.setValue,
        setValueSrc: this.setValueSrc,
        isFuncArg: true,
        parentFuncs
      }));
    }
  }]);
}(reactExports.Component);
ArgWidget.propTypes = {
  funcKey: PropTypes.string.isRequired,
  argKey: PropTypes.string.isRequired,
  setValue: PropTypes.func.isRequired,
  setValueSrc: PropTypes.func.isRequired,
  readonly: PropTypes.bool,
  isLHS: PropTypes.bool,
  parentFuncs: PropTypes.array,
  id: PropTypes.string,
  groupId: PropTypes.string
};
function _callSuper$g(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$g() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$g() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$g = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var FieldWrapper = /* @__PURE__ */ function(_Component) {
  function FieldWrapper2(props) {
    var _this;
    _classCallCheck$b(this, FieldWrapper2);
    _this = _callSuper$g(this, FieldWrapper2, [props]);
    _this.renderField = function() {
      var _this$props = _this.props, config2 = _this$props.config, classname = _this$props.classname, selectedField = _this$props.selectedField, selectedFieldSrc = _this$props.selectedFieldSrc, selectedFieldType = _this$props.selectedFieldType, setField4 = _this$props.setField, setFuncValue4 = _this$props.setFuncValue, parentField = _this$props.parentField, readonly = _this$props.readonly, id2 = _this$props.id, groupId = _this$props.groupId, fieldError = _this$props.fieldError, valueError = _this$props.valueError;
      var supportedFieldSrcs = ["func", "field"];
      if (!supportedFieldSrcs.includes(selectedFieldSrc)) {
        return "?";
      }
      var field = selectedFieldSrc === "func" ? /* @__PURE__ */ React.createElement(FuncWidget, {
        isLHS: true,
        config: config2,
        value: selectedField,
        fieldSrc: selectedFieldSrc,
        fieldType: selectedFieldType,
        fieldError,
        valueError,
        parentField,
        setValue: setField4,
        setFuncValue: setFuncValue4,
        readonly,
        id: id2,
        groupId,
        key: "field-func-" + id2
      }) : /* @__PURE__ */ React.createElement(Field, {
        config: config2,
        selectedField,
        selectedFieldSrc,
        selectedFieldType,
        parentField,
        setField: setField4,
        customProps: config2.settings.customFieldSelectProps,
        readonly,
        id: id2,
        groupId,
        key: "field-" + id2
      });
      var fieldLabel = selectedFieldSrc === "func" ? config2.settings.funcLabel : config2.settings.fieldLabel;
      var label2 = config2.settings.showLabels && selectedFieldSrc !== "func" && /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, fieldLabel);
      return /* @__PURE__ */ React.createElement("div", {
        key: selectedFieldSrc,
        className: classname
      }, label2, field);
    };
    _this.renderFieldSources = function() {
      if (!_this.meta) return null;
      var _this$props2 = _this.props, config2 = _this$props2.config, readonly = _this$props2.readonly, selectedFieldSrc = _this$props2.selectedFieldSrc, setFieldSrc4 = _this$props2.setFieldSrc, id2 = _this$props2.id;
      var fieldSourcesOptions = _this.meta.fieldSourcesOptions;
      var settings2 = config2.settings;
      var ValueSources2 = _this.ValueSources;
      var sourceLabel = settings2.showLabels ? /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, " ") : null;
      return fieldSourcesOptions.length > 1 && !readonly && /* @__PURE__ */ React.createElement("div", {
        key: "fieldsrc",
        className: "rule--fieldsrc"
      }, sourceLabel, /* @__PURE__ */ React.createElement(ValueSources2, {
        key: "fieldsrc-" + id2,
        valueSources: fieldSourcesOptions,
        valueSrc: selectedFieldSrc,
        config: config2,
        setValueSrc: setFieldSrc4,
        readonly,
        title: settings2.fieldSourcesPopupTitle
      }));
    };
    useOnPropsChanged(_this);
    _this.onPropsChanged(props);
    return _this;
  }
  _inherits$b(FieldWrapper2, _Component);
  return _createClass$9(FieldWrapper2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var configChanged = !this.ValueSources || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.config) !== (nextProps === null || nextProps === void 0 ? void 0 : nextProps.config);
      var keysForMeta = ["config"];
      var needUpdateMeta = !this.meta || keysForMeta.map(function(k) {
        return nextProps[k] !== prevProps[k];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
      if (configChanged) {
        var config2 = nextProps.config;
        var renderValueSources3 = config2.settings.renderValueSources;
        this.ValueSources = function(pr) {
          return renderValueSources3(pr, config2.ctx);
        };
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref) {
      var config2 = _ref.config;
      var _config$settings = config2.settings, valueSourcesInfo = _config$settings.valueSourcesInfo, fieldSources = _config$settings.fieldSources;
      var fieldSourcesOptions = fieldSources.map(function(srcKey) {
        return [srcKey, {
          label: valueSourcesInfo[srcKey].label
        }];
      });
      return {
        fieldSourcesOptions
      };
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$props3 = this.props;
      _this$props3.classname;
      var canSelectFieldSource = _this$props3.canSelectFieldSource;
      var fieldSources = canSelectFieldSource && this.renderFieldSources();
      var field = this.renderField();
      if (!canSelectFieldSource) {
        return field;
      } else {
        return /* @__PURE__ */ React.createElement(Col, {
          className: "rule--field-wrapper"
        }, fieldSources, field);
      }
    }
  }]);
}(reactExports.Component);
var _excluded$5 = ["factory"];
function _callSuper$f(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$f() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$f() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$f = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var getOperatorConfig$1 = Utils$1.ConfigUtils.getOperatorConfig;
var OperatorOptions = /* @__PURE__ */ function(_PureComponent) {
  function OperatorOptions2() {
    _classCallCheck$b(this, OperatorOptions2);
    return _callSuper$f(this, OperatorOptions2, arguments);
  }
  _inherits$b(OperatorOptions2, _PureComponent);
  return _createClass$9(OperatorOptions2, [{
    key: "render",
    value: function render3() {
      if (!this.props.selectedOperator) return null;
      var operatorDefinitions = getOperatorConfig$1(this.props.config, this.props.selectedOperator, this.props.selectedField);
      if (typeof operatorDefinitions.options === "undefined") {
        return null;
      }
      var _operatorDefinitions$ = operatorDefinitions.options, optionsFactory = _operatorDefinitions$.factory, basicOptionsProps = _objectWithoutProperties$2(_operatorDefinitions$, _excluded$5);
      var optionsProps = Object.assign({}, basicOptionsProps, {
        config: this.props.config,
        field: this.props.selectedField,
        fieldSrc: this.props.selectedFieldSrc,
        operator: this.props.selectedOperator,
        options: this.props.operatorOptions,
        setOption: this.props.setOperatorOption,
        readonly: this.props.readonly
      });
      var optionsCmp = optionsFactory(optionsProps, this.props.config.ctx);
      var name2 = this.props.selectedOperator;
      return /* @__PURE__ */ React.createElement("div", {
        className: "rule--operator rule--operator--".concat(name2.toUpperCase())
      }, optionsCmp);
    }
  }]);
}(reactExports.PureComponent);
OperatorOptions.propTypes = {
  config: PropTypes.object.isRequired,
  operatorOptions: PropTypes.any.isRequired,
  //instanceOf(Immutable.Map)
  selectedField: PropTypes.any,
  selectedFieldSrc: PropTypes.string,
  selectedOperator: PropTypes.string.isRequired,
  readonly: PropTypes.bool,
  //actions
  setOperatorOption: PropTypes.func.isRequired
};
function ownKeys$d(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$d(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$d(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$d(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _callSuper$e(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$e() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$e() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$e = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var _Utils$ConfigUtils$2 = Utils$1.ConfigUtils, getFieldConfig$2 = _Utils$ConfigUtils$2.getFieldConfig, getOperatorConfig2 = _Utils$ConfigUtils$2.getOperatorConfig, getFieldWidgetConfig$1 = _Utils$ConfigUtils$2.getFieldWidgetConfig, getFieldId2 = _Utils$ConfigUtils$2.getFieldId;
var isEmptyRuleProperties2 = Utils$1.RuleUtils.isEmptyRuleProperties;
var Rule = /* @__PURE__ */ function(_Component) {
  function Rule2(props) {
    var _this;
    _classCallCheck$b(this, Rule2);
    _this = _callSuper$e(this, Rule2, [props]);
    useOnPropsChanged(_this);
    _this.removeSelf = _this.removeSelf.bind(_this);
    _this.setLock = _this.setLock.bind(_this);
    _this.onPropsChanged(props);
    return _this;
  }
  _inherits$b(Rule2, _Component);
  return _createClass$9(Rule2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var _this2 = this;
      var prevProps = this.props;
      var configChanged = !this.Icon || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.config) !== (nextProps === null || nextProps === void 0 ? void 0 : nextProps.config);
      var keysForMeta = ["selectedField", "selectedFieldSrc", "selectedFieldType", "selectedOperator", "config", "reordableNodesCnt", "isLocked"];
      var needUpdateMeta = !this.meta || keysForMeta.map(function(k) {
        return nextProps[k] !== prevProps[k];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
      if (configChanged) {
        var config2 = nextProps.config;
        var _config$settings = config2.settings, renderIcon3 = _config$settings.renderIcon, renderButton3 = _config$settings.renderButton, renderButtonGroup3 = _config$settings.renderButtonGroup, renderSwitch3 = _config$settings.renderSwitch, renderBeforeWidget = _config$settings.renderBeforeWidget, renderAfterWidget = _config$settings.renderAfterWidget, renderRuleError = _config$settings.renderRuleError;
        this.Icon = getRenderFromConfig(config2, renderIcon3);
        this.Btn = getRenderFromConfig(config2, renderButton3);
        this.BtnGrp = getRenderFromConfig(config2, renderButtonGroup3);
        this.Switch = getRenderFromConfig(config2, renderSwitch3);
        this.BeforeWidget = getRenderFromConfig(config2, renderBeforeWidget);
        this.AfterWidget = getRenderFromConfig(config2, renderAfterWidget);
        this.RuleError = getRenderFromConfig(config2, renderRuleError);
      }
      this.doRemove = function() {
        _this2.props.removeSelf();
      };
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref) {
      var selectedField = _ref.selectedField, selectedFieldType = _ref.selectedFieldType, selectedOperator = _ref.selectedOperator, config2 = _ref.config, reordableNodesCnt = _ref.reordableNodesCnt, isLocked = _ref.isLocked;
      var keepInputOnChangeFieldSrc = config2.settings.keepInputOnChangeFieldSrc;
      var selectedFieldId = getFieldId2(selectedField, config2);
      var selectedFieldConfig = getFieldConfig$2(config2, selectedField);
      var isSelectedGroup = selectedFieldConfig && selectedFieldConfig.type === "!struct";
      var isOkWithoutField = keepInputOnChangeFieldSrc && selectedFieldType;
      var isFieldSelected = !!selectedField || isOkWithoutField;
      var isFieldAndOpSelected = isFieldSelected && selectedOperator;
      var selectedOperatorConfig = getOperatorConfig2(config2, selectedOperator, selectedField);
      var selectedOperatorHasOptions = selectedOperatorConfig && selectedOperatorConfig.options != null;
      var selectedFieldWidgetConfig = getFieldWidgetConfig$1(config2, selectedField, selectedOperator, null, null) || {};
      var hideOperator = selectedFieldWidgetConfig.hideOperator;
      var showDragIcon = config2.settings.canReorder && reordableNodesCnt > 1 && !isLocked;
      var showOperator = isFieldSelected && !hideOperator;
      var showOperatorLabel = isFieldSelected && hideOperator && selectedFieldWidgetConfig.operatorInlineLabel;
      var showWidget = isFieldAndOpSelected && !isSelectedGroup;
      var showOperatorOptions = isFieldAndOpSelected && selectedOperatorHasOptions;
      return {
        selectedFieldId,
        selectedFieldWidgetConfig,
        showDragIcon,
        showOperator,
        showOperatorLabel,
        showWidget,
        showOperatorOptions
      };
    }
  }, {
    key: "setLock",
    value: function setLock4(lock) {
      this.props.setLock(lock);
    }
  }, {
    key: "removeSelf",
    value: function removeSelf() {
      var _this$props = this.props, confirmFn = _this$props.confirmFn, config2 = _this$props.config;
      var _config$settings2 = config2.settings, renderConfirm3 = _config$settings2.renderConfirm, confirmOptions = _config$settings2.removeRuleConfirmOptions;
      if (confirmOptions && !this.isEmptyCurrentRule()) {
        renderConfirm3.call(config2.ctx, _objectSpread$d(_objectSpread$d({}, confirmOptions), {}, {
          onOk: this.doRemove,
          onCancel: null,
          confirmFn
        }), config2.ctx);
      } else {
        this.doRemove();
      }
    }
  }, {
    key: "_buildWidgetProps",
    value: function _buildWidgetProps(_ref2, _ref3) {
      var selectedField = _ref2.selectedField, selectedFieldSrc = _ref2.selectedFieldSrc, selectedFieldType = _ref2.selectedFieldType, selectedOperator = _ref2.selectedOperator, operatorOptions = _ref2.operatorOptions, value = _ref2.value, valueType = _ref2.valueType, valueSrc = _ref2.valueSrc, asyncListValues = _ref2.asyncListValues, valueError = _ref2.valueError, fieldError = _ref2.fieldError, parentField = _ref2.parentField;
      var selectedFieldId = _ref3.selectedFieldId;
      return {
        field: selectedField,
        fieldSrc: selectedFieldSrc,
        fieldType: selectedFieldType,
        fieldId: selectedFieldId,
        operator: selectedOperator,
        operatorOptions,
        value,
        valueType,
        valueSrc,
        asyncListValues,
        valueError,
        fieldError,
        parentField
      };
    }
  }, {
    key: "isEmptyCurrentRule",
    value: function isEmptyCurrentRule() {
      var config2 = this.props.config;
      var ruleData = this._buildWidgetProps(this.props, this.meta);
      return isEmptyRuleProperties2(ruleData, config2);
    }
  }, {
    key: "renderField",
    value: function renderField3() {
      var _this$props2 = this.props, config2 = _this$props2.config, isLocked = _this$props2.isLocked, parentField = _this$props2.parentField, groupId = _this$props2.groupId, id2 = _this$props2.id, selectedFieldSrc = _this$props2.selectedFieldSrc, selectedField = _this$props2.selectedField, selectedFieldType = _this$props2.selectedFieldType, setField4 = _this$props2.setField, setFuncValue4 = _this$props2.setFuncValue, setFieldSrc4 = _this$props2.setFieldSrc, fieldError = _this$props2.fieldError;
      var immutableFieldsMode = config2.settings.immutableFieldsMode;
      var selectedFieldId = this.meta.selectedFieldId;
      return /* @__PURE__ */ React.createElement(FieldWrapper, {
        key: "field",
        classname: classNames(selectedFieldSrc == "func" ? "rule--field--func" : "rule--field"),
        config: config2,
        canSelectFieldSource: !parentField,
        selectedField,
        selectedFieldSrc,
        selectedFieldType,
        selectedFieldId,
        fieldError,
        setField: !immutableFieldsMode ? setField4 : dummyFn,
        setFuncValue: !immutableFieldsMode ? setFuncValue4 : dummyFn,
        setFieldSrc: !immutableFieldsMode ? setFieldSrc4 : dummyFn,
        parentField,
        readonly: immutableFieldsMode || isLocked,
        id: id2,
        groupId
      });
    }
  }, {
    key: "renderOperator",
    value: function renderOperator3() {
      var _this$props3 = this.props, config2 = _this$props3.config, isLocked = _this$props3.isLocked;
      var _this$meta = this.meta, selectedFieldId = _this$meta.selectedFieldId, selectedFieldWidgetConfig = _this$meta.selectedFieldWidgetConfig, showOperator = _this$meta.showOperator, showOperatorLabel = _this$meta.showOperatorLabel;
      var immutableOpsMode = config2.settings.immutableOpsMode;
      return /* @__PURE__ */ React.createElement(OperatorWrapper, {
        key: "operator",
        config: config2,
        selectedField: this.props.selectedField,
        selectedFieldSrc: this.props.selectedFieldSrc,
        selectedFieldType: this.props.selectedFieldType,
        selectedFieldId,
        selectedOperator: this.props.selectedOperator,
        setOperator: !immutableOpsMode ? this.props.setOperator : dummyFn,
        showOperator,
        showOperatorLabel,
        selectedFieldWidgetConfig,
        readonly: immutableOpsMode || isLocked,
        id: this.props.id,
        groupId: this.props.groupId
      });
    }
  }, {
    key: "renderWidget",
    value: function renderWidget() {
      var _this$props4 = this.props, config2 = _this$props4.config, isLocked = _this$props4.isLocked;
      var showWidget = this.meta.showWidget;
      var immutableValuesMode = config2.settings.immutableValuesMode;
      if (!showWidget) return null;
      var widget = /* @__PURE__ */ React.createElement(Widget, _extends$h({
        key: "values"
      }, this._buildWidgetProps(this.props, this.meta), {
        config: config2,
        setValue: !immutableValuesMode ? this.props.setValue : dummyFn,
        setValueSrc: !immutableValuesMode ? this.props.setValueSrc : dummyFn,
        setFuncValue: !immutableValuesMode ? this.props.setFuncValue : dummyFn,
        readonly: immutableValuesMode || isLocked,
        id: this.props.id,
        groupId: this.props.groupId
      }));
      return /* @__PURE__ */ React.createElement(Col, {
        key: "widget-for-" + this.props.selectedOperator,
        className: "rule--value"
      }, widget);
    }
  }, {
    key: "renderOperatorOptions",
    value: function renderOperatorOptions() {
      var config2 = this.props.config;
      var showOperatorOptions = this.meta.showOperatorOptions;
      var _config$settings3 = config2.settings, immutableOpsMode = _config$settings3.immutableOpsMode, immutableValuesMode = _config$settings3.immutableValuesMode;
      if (!showOperatorOptions) return null;
      var opOpts = /* @__PURE__ */ React.createElement(OperatorOptions, {
        key: "operatorOptions",
        selectedField: this.props.selectedField,
        selectedOperator: this.props.selectedOperator,
        operatorOptions: this.props.operatorOptions,
        setOperatorOption: !immutableOpsMode ? this.props.setOperatorOption : dummyFn,
        config: config2,
        readonly: immutableValuesMode
      });
      return /* @__PURE__ */ React.createElement(Col, {
        key: "op-options-for-" + this.props.selectedOperator,
        className: "rule--operator-options"
      }, opOpts);
    }
  }, {
    key: "renderBeforeWidget",
    value: function renderBeforeWidget() {
      var BeforeWidget = this.BeforeWidget;
      if (!BeforeWidget) return null;
      return /* @__PURE__ */ React.createElement(Col, {
        key: "before-widget-for-" + this.props.selectedOperator,
        className: "rule--before-widget"
      }, /* @__PURE__ */ React.createElement(BeforeWidget, this.props));
    }
  }, {
    key: "renderAfterWidget",
    value: function renderAfterWidget() {
      var AfterWidget = this.AfterWidget;
      if (!AfterWidget) return null;
      return /* @__PURE__ */ React.createElement(Col, {
        key: "after-widget-for-" + this.props.selectedOperator,
        className: "rule--after-widget"
      }, /* @__PURE__ */ React.createElement(AfterWidget, this.props));
    }
  }, {
    key: "renderError",
    value: function renderError() {
      var _this$props5 = this.props, config2 = _this$props5.config, valueError = _this$props5.valueError, fieldError = _this$props5.fieldError;
      var showErrorMessage = config2.settings.showErrorMessage;
      var RuleError = this.RuleError;
      var oneError = [fieldError].concat(_toConsumableArray((valueError === null || valueError === void 0 ? void 0 : valueError.toArray()) || [])).filter(function(e2) {
        return !!e2;
      }).shift() || null;
      return showErrorMessage && oneError && /* @__PURE__ */ React.createElement("div", {
        className: "rule--error"
      }, RuleError ? /* @__PURE__ */ React.createElement(RuleError, {
        error: oneError
      }) : oneError);
    }
  }, {
    key: "renderDrag",
    value: function renderDrag() {
      var handleDraggerMouseDown = this.props.handleDraggerMouseDown;
      var showDragIcon = this.meta.showDragIcon;
      var Icon3 = this.Icon;
      var icon = /* @__PURE__ */ React.createElement(Icon3, {
        type: "drag"
      });
      return showDragIcon && /* @__PURE__ */ React.createElement("div", {
        key: "rule-drag-icon",
        onMouseDown: handleDraggerMouseDown,
        className: "qb-drag-handler rule--drag-handler"
      }, icon);
    }
  }, {
    key: "renderDel",
    value: function renderDel() {
      var _this$props6 = this.props, config2 = _this$props6.config, isLocked = _this$props6.isLocked;
      var _config$settings4 = config2.settings, deleteLabel = _config$settings4.deleteLabel, immutableGroupsMode = _config$settings4.immutableGroupsMode, canDeleteLocked = _config$settings4.canDeleteLocked;
      var Icon3 = this.Icon;
      var Btn = this.Btn;
      return !immutableGroupsMode && (!isLocked || isLocked && canDeleteLocked) && /* @__PURE__ */ React.createElement(Btn, {
        key: "rule-del",
        type: "delRule",
        onClick: this.removeSelf,
        label: deleteLabel,
        config: config2,
        renderIcon: Icon3
      });
    }
  }, {
    key: "renderLock",
    value: function renderLock() {
      var _this$props7 = this.props, config2 = _this$props7.config, isLocked = _this$props7.isLocked, isTrueLocked = _this$props7.isTrueLocked, id2 = _this$props7.id;
      var _config$settings5 = config2.settings, lockLabel = _config$settings5.lockLabel, lockedLabel = _config$settings5.lockedLabel, showLock = _config$settings5.showLock;
      var Switch2 = this.Switch;
      return showLock && !(isLocked && !isTrueLocked) && /* @__PURE__ */ React.createElement(Switch2, {
        key: "rule-lock",
        type: "lock",
        id: id2,
        value: isLocked,
        setValue: this.setLock,
        label: lockLabel,
        checkedLabel: lockedLabel,
        hideLabel: true,
        config: config2
      });
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$meta2 = this.meta, showOperatorOptions = _this$meta2.showOperatorOptions, selectedFieldWidgetConfig = _this$meta2.selectedFieldWidgetConfig;
      var _this$props8 = this.props, valueSrc = _this$props8.valueSrc, value = _this$props8.value, config2 = _this$props8.config;
      var canShrinkValue = (valueSrc === null || valueSrc === void 0 ? void 0 : valueSrc.first()) == "value" && !showOperatorOptions && value.size == 1 && selectedFieldWidgetConfig.fullWidth;
      var BtnGrp = this.BtnGrp;
      var parts = [this.renderField(), this.renderOperator(), this.renderBeforeWidget(), this.renderWidget(), this.renderAfterWidget(), this.renderOperatorOptions()];
      var body = /* @__PURE__ */ React.createElement("div", {
        key: "rule-body",
        className: classNames("rule--body", canShrinkValue && "can--shrink--value")
      }, parts);
      var error2 = this.renderError();
      var drag = this.renderDrag();
      var lock = this.renderLock();
      var del = this.renderDel();
      return /* @__PURE__ */ React.createElement(React.Fragment, null, drag, /* @__PURE__ */ React.createElement("div", {
        key: "rule-body-wrapper",
        className: "rule--body--wrapper"
      }, body, error2), /* @__PURE__ */ React.createElement("div", {
        key: "rule-header-wrapper",
        className: "rule--header"
      }, /* @__PURE__ */ React.createElement(BtnGrp, {
        key: "rule-header-group",
        config: config2
      }, lock, del)));
    }
  }]);
}(reactExports.Component);
Rule.propTypes = {
  id: PropTypes.string.isRequired,
  groupId: PropTypes.string,
  selectedField: PropTypes.any,
  selectedFieldSrc: PropTypes.string,
  selectedFieldType: PropTypes.string,
  selectedOperator: PropTypes.string,
  operatorOptions: PropTypes.object,
  config: PropTypes.object.isRequired,
  value: PropTypes.any,
  //depends on widget
  valueSrc: PropTypes.any,
  valueType: PropTypes.any,
  asyncListValues: PropTypes.array,
  isDraggingMe: PropTypes.bool,
  isDraggingTempo: PropTypes.bool,
  parentField: PropTypes.string,
  //from RuleGroup
  valueError: PropTypes.any,
  fieldError: PropTypes.string,
  isLocked: PropTypes.bool,
  isTrueLocked: PropTypes.bool,
  //path: PropTypes.instanceOf(Immutable.List),
  //actions
  handleDraggerMouseDown: PropTypes.func,
  setField: PropTypes.func,
  setFieldSrc: PropTypes.func,
  setOperator: PropTypes.func,
  setOperatorOption: PropTypes.func,
  setLock: PropTypes.func,
  removeSelf: PropTypes.func,
  setValue: PropTypes.func,
  setValueSrc: PropTypes.func,
  setFuncValue: PropTypes.func,
  reordableNodesCnt: PropTypes.number,
  totalRulesCnt: PropTypes.number,
  parentReordableNodesCnt: PropTypes.number
};
const Rule$1 = RuleContainer(Draggable("rule")(WithConfirmFn(Rule)));
function baseClamp$1(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var _baseClamp = baseClamp$1;
var toFinite = toFinite_1;
function toInteger$1(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_1 = toInteger$1;
var baseClamp = _baseClamp, baseToString$1 = _baseToString, toInteger = toInteger_1, toString$1 = toString_1;
function startsWith(string, target, position) {
  string = toString$1(string);
  position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
  target = baseToString$1(target);
  return string.slice(position, position + target.length) == target;
}
var startsWith_1 = startsWith;
const startsWith$1 = /* @__PURE__ */ getDefaultExportFromCjs(startsWith_1);
function _callSuper$d(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$d() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$d() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$d = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var defaultGroupConjunction2 = Utils$1.DefaultUtils.defaultGroupConjunction;
var createGroupContainer = function createGroupContainer2(Group2, itemType) {
  var _GroupContainer;
  return _GroupContainer = /* @__PURE__ */ function(_Component) {
    function GroupContainer2(_props) {
      var _this;
      _classCallCheck$b(this, GroupContainer2);
      _this = _callSuper$d(this, GroupContainer2, [_props]);
      _this._selectedConjunction = function(props) {
        props = props || _this.props;
        return props.conjunction || defaultGroupConjunction2(props.config, props.field);
      };
      _this.setConjunction = function() {
        var conj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        _this.props.actions.setConjunction(_this.props.path, conj);
      };
      _this.setNot = function() {
        var not2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        _this.props.actions.setNot(_this.props.path, not2);
      };
      _this.setLock = function() {
        var lock = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        _this.props.actions.setLock(_this.props.path, lock);
      };
      _this.dummyFn = function() {
      };
      _this.removeSelf = function() {
        _this.props.actions.removeGroup(_this.props.path);
      };
      _this.addGroup = function() {
        _this.props.actions.addGroup(_this.props.path);
      };
      _this.addCaseGroup = function() {
        _this.props.actions.addCaseGroup(_this.props.path);
      };
      _this.addDefaultCaseGroup = function() {
        _this.props.actions.addDefaultCaseGroup(_this.props.path);
      };
      _this.addRule = function() {
        var parentRuleGroupPath = itemType == "rule_group" ? _this.props.field : null;
        _this.props.actions.addRule(_this.props.path, void 0, void 0, void 0, parentRuleGroupPath);
      };
      _this.setField = function(field, asyncListValues, _meta) {
        _this.props.actions.setField(_this.props.path, field, asyncListValues, _meta);
      };
      _this.setOperator = function(operator) {
        _this.props.actions.setOperator(_this.props.path, operator);
      };
      _this.setValue = function(delta2, value, type2, asyncListValues, _meta) {
        _this.props.actions.setValue(_this.props.path, delta2, value, type2, asyncListValues, _meta);
      };
      _this.setValueSrc = function(delta2, srcKey, _meta) {
        _this.props.actions.setValueSrc(_this.props.path, delta2, srcKey, _meta);
      };
      _this.setFuncValue = function(delta2, parentFuncs, argKey, value, type2, asyncListValues, _meta) {
        _this.props.actions.setFuncValue(_this.props.path, delta2, parentFuncs, argKey, value, type2, asyncListValues, _meta);
      };
      _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_this);
      useOnPropsChanged(_this);
      _this.selectedConjunction = _this._selectedConjunction(_props);
      _this.conjunctionOptions = _this._getConjunctionOptions(_props);
      _this.dummyFn.isDummyFn = true;
      return _this;
    }
    _inherits$b(GroupContainer2, _Component);
    return _createClass$9(GroupContainer2, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        var prevProps = this.props;
        var prevState = this.state;
        var should = this.pureShouldComponentUpdate(nextProps, nextState);
        if (should) {
          if (prevState == nextState && prevProps != nextProps) {
            var draggingId = nextProps.dragging.id || prevProps.dragging.id;
            var isDraggingMe = draggingId == nextProps.id;
            var chs = [];
            for (var k in nextProps) {
              var changed = nextProps[k] != prevProps[k];
              if (k == "dragging" && !isDraggingMe) {
                changed = false;
              }
              if (changed) {
                chs.push(k);
              }
            }
            if (!chs.length) should = false;
          }
        }
        return should;
      }
    }, {
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        var config2 = nextProps.config;
        nextProps.id;
        var conjunction = nextProps.conjunction;
        var oldConfig = this.props.config;
        var oldConjunction = this.props.conjunction;
        if (oldConfig != config2 || oldConjunction != conjunction) {
          this.selectedConjunction = this._selectedConjunction(nextProps);
          this.conjunctionOptions = this._getConjunctionOptions(nextProps);
        }
      }
    }, {
      key: "_getConjunctionOptions",
      value: function _getConjunctionOptions(props) {
        var _this2 = this;
        return mapValues$1(props.config.conjunctions, function(item, index2) {
          return {
            id: "conjunction-".concat(props.id, "-").concat(index2),
            name: "conjunction[".concat(props.id, "]"),
            key: index2,
            label: item.label,
            checked: index2 === _this2._selectedConjunction(props)
          };
        });
      }
    }, {
      key: "render",
      value: function render3() {
        var showErrorMessage = this.props.config.settings.showErrorMessage;
        var isDraggingMe = this.props.dragging.id == this.props.id;
        var currentNesting = this.props.path.size;
        var maxNesting = this.props.config.settings.maxNesting;
        var isInDraggingTempo = !isDraggingMe && this.props.isDraggingTempo;
        var fieldType = this.props.fieldType || null;
        var valueError = this.props.valueError;
        var oneError = _toConsumableArray((valueError === null || valueError === void 0 ? void 0 : valueError.toArray()) || []).filter(function(e2) {
          return !!e2;
        }).shift() || null;
        var hasError = oneError != null && showErrorMessage;
        var allowFurtherNesting = typeof maxNesting === "undefined" || currentNesting < maxNesting;
        var isRoot = currentNesting == 1;
        return /* @__PURE__ */ React.createElement("div", {
          className: classNames("group-or-rule-container", "group-container", hasError ? "group-with-error" : null),
          "data-id": this.props.id
        }, [isDraggingMe ? /* @__PURE__ */ React.createElement(Group2, {
          key: "dragging",
          id: this.props.id,
          groupId: this.props.groupId,
          isDraggingMe: true,
          isDraggingTempo: true,
          dragging: this.props.dragging,
          isRoot,
          allowFurtherNesting,
          conjunctionOptions: this.conjunctionOptions,
          not: this.props.not,
          selectedConjunction: this.selectedConjunction,
          setConjunction: this.dummyFn,
          setNot: this.dummyFn,
          setLock: this.dummyFn,
          removeSelf: this.dummyFn,
          addGroup: this.dummyFn,
          addCaseGroup: this.dummyFn,
          addDefaultCaseGroup: this.dummyFn,
          addRule: this.dummyFn,
          setField: this.dummyFn,
          setFuncValue: this.dummyFn,
          setOperator: this.dummyFn,
          setValue: this.dummyFn,
          setValueSrc: this.dummyFn,
          value: this.props.value || null,
          valueError: this.props.valueError || null,
          valueSrc: this.props.valueSrc || null,
          config: this.props.config,
          children1: this.props.children1,
          actions: this.props.actions,
          reordableNodesCnt: this.props.reordableNodesCnt,
          totalRulesCnt: this.props.totalRulesCnt,
          selectedField: this.props.field || null,
          selectedFieldSrc: this.props.fieldSrc || "field",
          selectedFieldType: fieldType,
          parentField: this.props.parentField || null,
          selectedOperator: this.props.operator || null,
          isLocked: this.props.isLocked,
          isTrueLocked: this.props.isTrueLocked,
          parentReordableNodesCnt: this.props.parentReordableNodesCnt
        }) : null, /* @__PURE__ */ React.createElement(Group2, {
          key: this.props.id,
          id: this.props.id,
          groupId: this.props.groupId,
          isDraggingMe,
          isDraggingTempo: isInDraggingTempo,
          onDragStart: this.props.onDragStart,
          isRoot,
          allowFurtherNesting,
          conjunctionOptions: this.conjunctionOptions,
          not: this.props.not,
          selectedConjunction: this.selectedConjunction,
          setConjunction: isInDraggingTempo ? this.dummyFn : this.setConjunction,
          setNot: isInDraggingTempo ? this.dummyFn : this.setNot,
          setLock: isInDraggingTempo ? this.dummyFn : this.setLock,
          removeSelf: isInDraggingTempo ? this.dummyFn : this.removeSelf,
          addGroup: isInDraggingTempo ? this.dummyFn : this.addGroup,
          addCaseGroup: isInDraggingTempo ? this.dummyFn : this.addCaseGroup,
          addDefaultCaseGroup: isInDraggingTempo ? this.dummyFn : this.addDefaultCaseGroup,
          addRule: isInDraggingTempo ? this.dummyFn : this.addRule,
          setField: isInDraggingTempo ? this.dummyFn : this.setField,
          setFuncValue: isInDraggingTempo ? this.dummyFn : this.setFuncValue,
          setOperator: isInDraggingTempo ? this.dummyFn : this.setOperator,
          setValue: isInDraggingTempo ? this.dummyFn : this.setValue,
          setValueSrc: isInDraggingTempo ? this.dummyFn : this.setValueSrc,
          value: this.props.value || null,
          valueError: this.props.valueError || null,
          valueSrc: this.props.valueSrc || null,
          config: this.props.config,
          children1: this.props.children1,
          actions: this.props.actions,
          reordableNodesCnt: this.props.reordableNodesCnt,
          totalRulesCnt: this.props.totalRulesCnt,
          selectedField: this.props.field || null,
          selectedFieldSrc: this.props.fieldSrc || "field",
          selectedFieldType: fieldType,
          parentField: this.props.parentField || null,
          selectedOperator: this.props.operator || null,
          isLocked: this.props.isLocked,
          isTrueLocked: this.props.isTrueLocked,
          parentReordableNodesCnt: this.props.parentReordableNodesCnt
        })]);
      }
    }]);
  }(reactExports.Component), _GroupContainer.propTypes = {
    config: PropTypes.object.isRequired,
    actions: PropTypes.object.isRequired,
    //{setConjunction: Function, removeGroup, addGroup, addRule, ...}
    path: PropTypes.any.isRequired,
    //instanceOf(Immutable.List)
    id: PropTypes.string.isRequired,
    groupId: PropTypes.string,
    not: PropTypes.bool,
    conjunction: PropTypes.string,
    children1: PropTypes.any,
    //instanceOf(Immutable.OrderedMap)
    onDragStart: PropTypes.func,
    reordableNodesCnt: PropTypes.number,
    field: PropTypes.any,
    // for RuleGroup
    fieldSrc: PropTypes.string,
    // for RuleGroup
    fieldType: PropTypes.string,
    // for RuleGroup
    parentField: PropTypes.string,
    //from RuleGroup
    value: PropTypes.any,
    // for RuleGroup, CaseGroup
    valueSrc: PropTypes.any,
    valueError: PropTypes.any,
    isLocked: PropTypes.bool,
    isTrueLocked: PropTypes.bool,
    //connected:
    dragging: PropTypes.object,
    //{id, x, y, w, h}
    isDraggingTempo: PropTypes.bool
  }, _GroupContainer;
};
const GroupContainer = function(Group2, itemType) {
  var ConnectedGroupContainer = connect$1(function(state) {
    return {
      dragging: state.dragging
    };
  }, null, null, {
    context
  })(createGroupContainer(Group2, itemType));
  ConnectedGroupContainer.displayName = "ConnectedGroupContainer";
  return ConnectedGroupContainer;
};
function _callSuper$c(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$c() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$c() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$c = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var groupActionsPositionList$1 = {
  topLeft: "group--actions--tl",
  topCenter: "group--actions--tc",
  topRight: "group--actions--tr",
  bottomLeft: "group--actions--bl",
  bottomCenter: "group--actions--bc",
  bottomRight: "group--actions--br"
};
var defaultPosition$2 = "topRight";
var GroupActions = /* @__PURE__ */ function(_PureComponent) {
  function GroupActions2() {
    _classCallCheck$b(this, GroupActions2);
    return _callSuper$c(this, GroupActions2, arguments);
  }
  _inherits$b(GroupActions2, _PureComponent);
  return _createClass$9(GroupActions2, [{
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, addRule3 = _this$props.addRule, addGroup3 = _this$props.addGroup, removeSelf = _this$props.removeSelf, setLock4 = _this$props.setLock, isLocked = _this$props.isLocked, isTrueLocked = _this$props.isTrueLocked, id2 = _this$props.id, canAddGroup = _this$props.canAddGroup, canAddRule = _this$props.canAddRule, canDeleteGroup = _this$props.canDeleteGroup;
      var _config$settings = config2.settings, immutableGroupsMode = _config$settings.immutableGroupsMode, addRuleLabel = _config$settings.addRuleLabel, addGroupLabel = _config$settings.addGroupLabel, delGroupLabel = _config$settings.delGroupLabel, groupActionsPosition = _config$settings.groupActionsPosition, renderButton3 = _config$settings.renderButton, renderIcon3 = _config$settings.renderIcon, renderSwitch3 = _config$settings.renderSwitch, renderButtonGroup3 = _config$settings.renderButtonGroup, lockLabel = _config$settings.lockLabel, lockedLabel = _config$settings.lockedLabel, showLock = _config$settings.showLock, canDeleteLocked = _config$settings.canDeleteLocked;
      var Icon3 = function Icon4(pr) {
        return renderIcon3(pr, config2.ctx);
      };
      var Btn = function Btn2(pr) {
        return renderButton3(pr, config2.ctx);
      };
      var Switch2 = function Switch3(pr) {
        return renderSwitch3(pr, config2.ctx);
      };
      var BtnGrp = function BtnGrp2(pr) {
        return renderButtonGroup3(pr, config2.ctx);
      };
      var position = groupActionsPositionList$1[groupActionsPosition || defaultPosition$2];
      var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /* @__PURE__ */ React.createElement(Switch2, {
        type: "lock",
        id: id2,
        value: isLocked,
        setValue: setLock4,
        label: lockLabel,
        checkedLabel: lockedLabel,
        config: config2
      });
      var addRuleBtn = !immutableGroupsMode && canAddRule && !isLocked && /* @__PURE__ */ React.createElement(Btn, {
        type: "addRule",
        onClick: addRule3,
        label: addRuleLabel,
        readonly: isLocked,
        config: config2,
        renderIcon: Icon3
      });
      var addGroupBtn = !immutableGroupsMode && canAddGroup && !isLocked && /* @__PURE__ */ React.createElement(Btn, {
        type: "addGroup",
        onClick: addGroup3,
        label: addGroupLabel,
        readonly: isLocked,
        config: config2,
        renderIcon: Icon3
      });
      var delGroupBtn = !immutableGroupsMode && canDeleteGroup && (!isLocked || isLocked && canDeleteLocked) && /* @__PURE__ */ React.createElement(Btn, {
        type: "delGroup",
        onClick: removeSelf,
        label: delGroupLabel,
        config: config2,
        renderIcon: Icon3
      });
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--actions ".concat(position)
      }, /* @__PURE__ */ React.createElement(BtnGrp, {
        config: config2
      }, setLockSwitch, addRuleBtn, addGroupBtn, delGroupBtn));
    }
  }]);
}(reactExports.PureComponent);
function ownKeys$c(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$c(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$c(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$c(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _callSuper$b(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$b() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$b() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$b = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var isEmptyGroupChildren2 = Utils$1.RuleUtils.isEmptyGroupChildren;
var defaultPosition$1 = "topRight";
var BasicGroup = /* @__PURE__ */ function(_Component) {
  function BasicGroup2(props) {
    var _this;
    _classCallCheck$b(this, BasicGroup2);
    _this = _callSuper$b(this, BasicGroup2, [props]);
    _this.childrenClassName = function() {
      return "";
    };
    _this.renderBeforeActions = function() {
      var BeforeActions = _this.BeforeActions;
      if (BeforeActions == void 0) return null;
      return /* @__PURE__ */ React.createElement(BeforeActions, _extends$h({
        key: "group-actions-before"
      }, _this.props));
    };
    _this.renderAfterActions = function() {
      var AfterActions = _this.AfterActions;
      if (AfterActions == void 0) return null;
      return /* @__PURE__ */ React.createElement(AfterActions, _extends$h({
        key: "group-actions-after"
      }, _this.props));
    };
    useOnPropsChanged(_this);
    _this.onPropsChanged(props);
    _this.removeSelf = _this.removeSelf.bind(_this);
    _this.setLock = _this.setLock.bind(_this);
    _this.renderItem = _this.renderItem.bind(_this);
    return _this;
  }
  _inherits$b(BasicGroup2, _Component);
  return _createClass$9(BasicGroup2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var _this2 = this;
      var prevProps = this.props;
      var configChanged = !this.Icon || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.config) !== (nextProps === null || nextProps === void 0 ? void 0 : nextProps.config);
      if (configChanged) {
        var config2 = nextProps.config;
        var _config$settings = config2.settings, renderIcon3 = _config$settings.renderIcon, renderConjs3 = _config$settings.renderConjs, renderBeforeActions = _config$settings.renderBeforeActions, renderAfterActions = _config$settings.renderAfterActions;
        this.Icon = getRenderFromConfig(config2, renderIcon3);
        this.Conjs = getRenderFromConfig(config2, renderConjs3);
        this.BeforeActions = getRenderFromConfig(config2, renderBeforeActions);
        this.AfterActions = getRenderFromConfig(config2, renderAfterActions);
      }
      this.doRemove = function() {
        _this2.props.removeSelf();
      };
    }
  }, {
    key: "isGroupTopPosition",
    value: function isGroupTopPosition() {
      return startsWith$1(this.props.config.settings.groupActionsPosition || defaultPosition$1, "top");
    }
  }, {
    key: "setLock",
    value: function setLock4(lock) {
      this.props.setLock(lock);
    }
  }, {
    key: "removeSelf",
    value: function removeSelf() {
      var _this$props = this.props, confirmFn = _this$props.confirmFn, config2 = _this$props.config;
      var _config$settings2 = config2.settings, renderConfirm3 = _config$settings2.renderConfirm, confirmOptions = _config$settings2.removeGroupConfirmOptions;
      if (confirmOptions && !this.isEmptyCurrentGroup()) {
        renderConfirm3.call(config2.ctx, _objectSpread$c(_objectSpread$c({}, confirmOptions), {}, {
          onOk: this.doRemove,
          onCancel: null,
          confirmFn
        }), config2.ctx);
      } else {
        this.doRemove();
      }
    }
  }, {
    key: "isEmptyCurrentGroup",
    value: function isEmptyCurrentGroup() {
      var _this$props2 = this.props, children1 = _this$props2.children1, config2 = _this$props2.config;
      return isEmptyGroupChildren2(children1, config2);
    }
  }, {
    key: "showNot",
    value: function showNot() {
      var config2 = this.props.config;
      return config2.settings.showNot;
    }
    // show conjs for 2+ children?
  }, {
    key: "showConjs",
    value: function showConjs() {
      var _this$props3 = this.props, conjunctionOptions = _this$props3.conjunctionOptions;
      _this$props3.children1;
      _this$props3.config;
      var conjunctionCount = Object.keys(conjunctionOptions).length;
      return conjunctionCount > 1 || this.showNot();
    }
  }, {
    key: "isNoChildren",
    value: function isNoChildren() {
      var children1 = this.props.children1;
      return children1 ? children1.size == 0 : true;
    }
  }, {
    key: "isOneChild",
    value: function isOneChild() {
      var children1 = this.props.children1;
      return children1 ? children1.size < 2 : true;
    }
  }, {
    key: "renderChildrenWrapper",
    value: function renderChildrenWrapper() {
      var children1 = this.props.children1;
      return children1 && /* @__PURE__ */ React.createElement("div", {
        key: "group-children",
        className: classNames("group--children", !this.showConjs() ? "hide--conjs" : "", this.isOneChild() ? "hide--line" : "", this.isOneChild() ? "one--child" : "", this.childrenClassName())
      }, this.renderChildren());
    }
  }, {
    key: "renderHeaderWrapper",
    value: function renderHeaderWrapper() {
      var isGroupTopPosition = this.isGroupTopPosition();
      return /* @__PURE__ */ React.createElement("div", {
        key: "group-header",
        className: classNames("group--header", this.isOneChild() ? "one--child" : "", !this.showConjs() ? "hide--conjs" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "")
      }, this.renderHeader(), isGroupTopPosition && this.renderBeforeActions(), isGroupTopPosition && this.renderActions(), isGroupTopPosition && this.renderAfterActions());
    }
  }, {
    key: "renderFooterWrapper",
    value: function renderFooterWrapper() {
      var isGroupTopPosition = this.isGroupTopPosition();
      return !isGroupTopPosition && /* @__PURE__ */ React.createElement("div", {
        key: "group-footer",
        className: "group--footer"
      }, this.renderBeforeActions(), this.renderActions(), this.renderAfterActions());
    }
  }, {
    key: "renderActions",
    value: function renderActions() {
      var _this$props4 = this.props, config2 = _this$props4.config, addRule3 = _this$props4.addRule, addGroup3 = _this$props4.addGroup, isLocked = _this$props4.isLocked, isTrueLocked = _this$props4.isTrueLocked, id2 = _this$props4.id;
      return /* @__PURE__ */ React.createElement(GroupActions, {
        key: "group-actions",
        config: config2,
        addRule: addRule3,
        addGroup: addGroup3,
        canAddGroup: this.canAddGroup(),
        canAddRule: this.canAddRule(),
        canDeleteGroup: this.canDeleteGroup(),
        removeSelf: this.removeSelf,
        setLock: this.setLock,
        isLocked,
        isTrueLocked,
        id: id2
      });
    }
  }, {
    key: "canAddGroup",
    value: function canAddGroup() {
      return this.props.allowFurtherNesting;
    }
  }, {
    key: "canAddRule",
    value: function canAddRule() {
      var maxNumberOfRules = this.props.config.settings.maxNumberOfRules;
      var totalRulesCnt = this.props.totalRulesCnt;
      if (maxNumberOfRules) {
        return totalRulesCnt < maxNumberOfRules;
      }
      return true;
    }
  }, {
    key: "canDeleteGroup",
    value: function canDeleteGroup() {
      return !this.props.isRoot;
    }
  }, {
    key: "renderChildren",
    value: function renderChildren() {
      var children1 = this.props.children1;
      return children1 ? children1.valueSeq().toArray().map(this.renderItem) : null;
    }
  }, {
    key: "renderItem",
    value: function renderItem(item) {
      if (!item) {
        return void 0;
      }
      var props = this.props;
      var config2 = props.config, actions = props.actions, onDragStart = props.onDragStart, isLocked = props.isLocked;
      var isRuleGroup = item.get("type") == "group" && item.getIn(["properties", "field"]) != null;
      var type2 = isRuleGroup ? "rule_group" : item.get("type");
      return /* @__PURE__ */ React.createElement(Item, _extends$h({}, this.extraPropsForItem(item), {
        key: item.get("id"),
        id: item.get("id"),
        groupId: props.id,
        path: item.get("path"),
        type: type2,
        properties: item.get("properties"),
        config: config2,
        actions,
        children1: item.get("children1"),
        reordableNodesCnt: this.reordableNodesCntForItem(item),
        totalRulesCnt: this.totalRulesCntForItem(item),
        parentReordableNodesCnt: this.reordableNodesCnt(),
        onDragStart,
        isDraggingTempo: this.props.isDraggingTempo,
        isParentLocked: isLocked
      }));
    }
  }, {
    key: "extraPropsForItem",
    value: function extraPropsForItem(_item) {
      return {};
    }
  }, {
    key: "reordableNodesCnt",
    value: function reordableNodesCnt() {
      if (this.props.isLocked) return 0;
      return this.props.reordableNodesCnt;
    }
  }, {
    key: "totalRulesCntForItem",
    value: function totalRulesCntForItem(_item) {
      return this.props.totalRulesCnt;
    }
  }, {
    key: "reordableNodesCntForItem",
    value: function reordableNodesCntForItem(_item) {
      if (this.props.isLocked) return 0;
      return this.reordableNodesCnt();
    }
  }, {
    key: "showDragIcon",
    value: function showDragIcon() {
      var _this$props5 = this.props, config2 = _this$props5.config, isRoot = _this$props5.isRoot, isLocked = _this$props5.isLocked;
      var reordableNodesCnt = this.reordableNodesCnt();
      return config2.settings.canReorder && !isRoot && reordableNodesCnt > 1 && !isLocked;
    }
  }, {
    key: "renderDrag",
    value: function renderDrag() {
      var handleDraggerMouseDown = this.props.handleDraggerMouseDown;
      var Icon3 = this.Icon;
      var icon = /* @__PURE__ */ React.createElement(Icon3, {
        type: "drag"
      });
      return this.showDragIcon() && /* @__PURE__ */ React.createElement("div", {
        key: "group-drag-icon",
        onMouseDown: handleDraggerMouseDown,
        className: "qb-drag-handler group--drag-handler"
      }, icon);
    }
  }, {
    key: "conjunctionOptions",
    value: function conjunctionOptions() {
      var conjunctionOptions2 = this.props.conjunctionOptions;
      return conjunctionOptions2;
    }
  }, {
    key: "renderConjs",
    value: function renderConjs3() {
      var _this$props6 = this.props, config2 = _this$props6.config, children1 = _this$props6.children1, id2 = _this$props6.id, selectedConjunction = _this$props6.selectedConjunction, setConjunction4 = _this$props6.setConjunction, not2 = _this$props6.not, setNot4 = _this$props6.setNot, isLocked = _this$props6.isLocked;
      var _config$settings3 = config2.settings, immutableGroupsMode = _config$settings3.immutableGroupsMode;
      _config$settings3.renderConjs;
      _config$settings3.showNot;
      var notLabel = _config$settings3.notLabel;
      var conjunctionOptions = this.conjunctionOptions();
      if (!this.showConjs()) return null;
      if (!children1 || !children1.size) return null;
      var renderProps = {
        disabled: this.isOneChild(),
        readonly: immutableGroupsMode || isLocked,
        selectedConjunction,
        setConjunction: immutableGroupsMode ? dummyFn : setConjunction4,
        conjunctionOptions,
        config: config2,
        not: not2 || false,
        id: id2,
        setNot: immutableGroupsMode ? dummyFn : setNot4,
        notLabel,
        showNot: this.showNot(),
        isLocked
      };
      var Conjs2 = this.Conjs;
      return /* @__PURE__ */ React.createElement(Conjs2, _extends$h({
        key: "group-conjs"
      }, renderProps));
    }
  }, {
    key: "renderHeader",
    value: function renderHeader() {
      return /* @__PURE__ */ React.createElement("div", {
        key: "group-conjunctions",
        className: "group--conjunctions"
      }, this.renderConjs(), this.renderDrag());
    }
  }, {
    key: "render",
    value: function render3() {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, this.renderHeaderWrapper(), this.renderChildrenWrapper(), this.renderFooterWrapper());
    }
  }]);
}(reactExports.Component);
BasicGroup.propTypes = {
  reordableNodesCnt: PropTypes.number,
  conjunctionOptions: PropTypes.object.isRequired,
  allowFurtherNesting: PropTypes.bool.isRequired,
  isRoot: PropTypes.bool.isRequired,
  not: PropTypes.bool,
  selectedConjunction: PropTypes.string,
  config: PropTypes.object.isRequired,
  id: PropTypes.string.isRequired,
  groupId: PropTypes.string,
  path: PropTypes.any,
  //instanceOf(Immutable.List)
  children1: PropTypes.any,
  //instanceOf(Immutable.OrderedMap)
  isDraggingMe: PropTypes.bool,
  isDraggingTempo: PropTypes.bool,
  isLocked: PropTypes.bool,
  isTrueLocked: PropTypes.bool,
  //actions
  handleDraggerMouseDown: PropTypes.func,
  onDragStart: PropTypes.func,
  addRule: PropTypes.func.isRequired,
  addGroup: PropTypes.func.isRequired,
  removeSelf: PropTypes.func.isRequired,
  setConjunction: PropTypes.func.isRequired,
  setNot: PropTypes.func.isRequired,
  setLock: PropTypes.func.isRequired,
  actions: PropTypes.object.isRequired
};
const Group = GroupContainer(Draggable("group")(WithConfirmFn(BasicGroup)), "group");
function _superPropBase(t2, o) {
  for (; !{}.hasOwnProperty.call(t2, o) && null !== (t2 = _getPrototypeOf$1(t2)); ) ;
  return t2;
}
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e2, t2, r2) {
    var p = _superPropBase(e2, t2);
    if (p) {
      var n2 = Object.getOwnPropertyDescriptor(p, t2);
      return n2.get ? n2.get.call(arguments.length < 3 ? e2 : r2) : n2.value;
    }
  }, _get.apply(null, arguments);
}
function _callSuper$a(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$a() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$a() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$a = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var RuleGroupActions = /* @__PURE__ */ function(_PureComponent) {
  function RuleGroupActions2() {
    _classCallCheck$b(this, RuleGroupActions2);
    return _callSuper$a(this, RuleGroupActions2, arguments);
  }
  _inherits$b(RuleGroupActions2, _PureComponent);
  return _createClass$9(RuleGroupActions2, [{
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, addRule3 = _this$props.addRule, canAddRule = _this$props.canAddRule, canDeleteGroup = _this$props.canDeleteGroup, removeSelf = _this$props.removeSelf, setLock4 = _this$props.setLock, isLocked = _this$props.isLocked, isTrueLocked = _this$props.isTrueLocked, id2 = _this$props.id;
      var _config$settings = config2.settings, immutableGroupsMode = _config$settings.immutableGroupsMode, addRuleLabel = _config$settings.addRuleLabel, delGroupLabel = _config$settings.delGroupLabel, renderButton3 = _config$settings.renderButton, renderIcon3 = _config$settings.renderIcon, renderSwitch3 = _config$settings.renderSwitch, renderButtonGroup3 = _config$settings.renderButtonGroup, lockLabel = _config$settings.lockLabel, lockedLabel = _config$settings.lockedLabel, showLock = _config$settings.showLock, canDeleteLocked = _config$settings.canDeleteLocked;
      var Icon3 = function Icon4(pr) {
        return renderIcon3(pr, config2.ctx);
      };
      var Btn = function Btn2(pr) {
        return renderButton3(pr, config2.ctx);
      };
      var Switch2 = function Switch3(pr) {
        return renderSwitch3(pr, config2.ctx);
      };
      var BtnGrp = function BtnGrp2(pr) {
        return renderButtonGroup3(pr, config2.ctx);
      };
      var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /* @__PURE__ */ React.createElement(Switch2, {
        type: "lock",
        id: id2,
        value: isLocked,
        setValue: setLock4,
        label: lockLabel,
        checkedLabel: lockedLabel,
        hideLabel: true,
        config: config2
      });
      var addRuleBtn = !immutableGroupsMode && canAddRule && !isLocked && /* @__PURE__ */ React.createElement(Btn, {
        type: "addRuleGroup",
        onClick: addRule3,
        label: addRuleLabel,
        readonly: isLocked,
        config: config2,
        renderIcon: Icon3
      });
      var delGroupBtn = !immutableGroupsMode && canDeleteGroup && (!isLocked || isLocked && canDeleteLocked) && /* @__PURE__ */ React.createElement(Btn, {
        type: "delRuleGroup",
        onClick: removeSelf,
        label: delGroupLabel,
        config: config2,
        renderIcon: Icon3
      });
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--actions"
      }, /* @__PURE__ */ React.createElement(BtnGrp, {
        config: config2
      }, setLockSwitch, addRuleBtn, delGroupBtn));
    }
  }]);
}(reactExports.PureComponent);
function ownKeys$b(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$b(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$b(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$b(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _callSuper$9(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$9() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$9() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$9 = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var RuleGroup = /* @__PURE__ */ function(_BasicGroup) {
  function RuleGroup2(props) {
    var _this;
    _classCallCheck$b(this, RuleGroup2);
    _this = _callSuper$9(this, RuleGroup2, [props]);
    _this.childrenClassName = function() {
      return "rule_group--children";
    };
    _this.renderHeaderWrapper = function() {
      return null;
    };
    _this.renderFooterWrapper = function() {
      return null;
    };
    _this.renderConjs = function() {
      return null;
    };
    _this.canAddGroup = function() {
      return false;
    };
    _this.canAddRule = function() {
      return true;
    };
    _this.canDeleteGroup = function() {
      return false;
    };
    return _this;
  }
  _inherits$b(RuleGroup2, _BasicGroup);
  return _createClass$9(RuleGroup2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      _get(_getPrototypeOf$1(RuleGroup2.prototype), "onPropsChanged", this).call(this, nextProps);
    }
  }, {
    key: "reordableNodesCntForItem",
    value: function reordableNodesCntForItem(_item) {
      if (this.props.isLocked) return 0;
      var children1 = this.props.children1;
      return (children1 === null || children1 === void 0 ? void 0 : children1.size) || 0;
    }
  }, {
    key: "renderChildrenWrapper",
    value: function renderChildrenWrapper() {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, this.renderDrag(), this.renderField(), this.renderActions(), _get(_getPrototypeOf$1(RuleGroup2.prototype), "renderChildrenWrapper", this).call(this));
    }
  }, {
    key: "renderField",
    value: function renderField3() {
      var _this$props = this.props, config2 = _this$props.config, selectedField = _this$props.selectedField, selectedFieldSrc = _this$props.selectedFieldSrc, selectedFieldType = _this$props.selectedFieldType, setField4 = _this$props.setField, setFuncValue4 = _this$props.setFuncValue, setFieldSrc4 = _this$props.setFieldSrc, parentField = _this$props.parentField, id2 = _this$props.id, groupId = _this$props.groupId, isLocked = _this$props.isLocked;
      var immutableFieldsMode = config2.settings.immutableFieldsMode;
      return /* @__PURE__ */ React.createElement(FieldWrapper, {
        key: "field",
        classname: "group--field",
        config: config2,
        canSelectFieldSource: false,
        selectedField,
        selectedFieldSrc,
        selectedFieldType,
        setField: setField4,
        setFuncValue: setFuncValue4,
        setFieldSrc: setFieldSrc4,
        parentField,
        readonly: immutableFieldsMode || isLocked,
        id: id2,
        groupId
      });
    }
  }, {
    key: "renderActions",
    value: function renderActions() {
      var _this$props2 = this.props, config2 = _this$props2.config, addRule3 = _this$props2.addRule, isLocked = _this$props2.isLocked, isTrueLocked = _this$props2.isTrueLocked, id2 = _this$props2.id;
      return /* @__PURE__ */ React.createElement(RuleGroupActions, {
        config: config2,
        addRule: addRule3,
        canAddRule: this.canAddRule(),
        canDeleteGroup: this.canDeleteGroup(),
        removeSelf: this.removeSelf,
        setLock: this.setLock,
        isLocked,
        isTrueLocked,
        id: id2
      });
    }
  }, {
    key: "extraPropsForItem",
    value: function extraPropsForItem(_item) {
      return {
        parentField: this.props.selectedField
      };
    }
  }]);
}(BasicGroup);
RuleGroup.propTypes = _objectSpread$b(_objectSpread$b({}, BasicGroup.propTypes), {}, {
  selectedField: PropTypes.any,
  selectedFieldSrc: PropTypes.string,
  parentField: PropTypes.string,
  setField: PropTypes.func,
  setFieldSrc: PropTypes.func
});
const RuleGroup$1 = GroupContainer(Draggable("group rule_group")(WithConfirmFn(RuleGroup)), "rule_group");
function _callSuper$8(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$8() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$8() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$8 = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var RuleGroupExtActions = /* @__PURE__ */ function(_PureComponent) {
  function RuleGroupExtActions2() {
    _classCallCheck$b(this, RuleGroupExtActions2);
    return _callSuper$8(this, RuleGroupExtActions2, arguments);
  }
  _inherits$b(RuleGroupExtActions2, _PureComponent);
  return _createClass$9(RuleGroupExtActions2, [{
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, addRule3 = _this$props.addRule, canAddRule = _this$props.canAddRule, canDeleteGroup = _this$props.canDeleteGroup, removeSelf = _this$props.removeSelf, setLock4 = _this$props.setLock, isLocked = _this$props.isLocked, isTrueLocked = _this$props.isTrueLocked, id2 = _this$props.id;
      var _config$settings = config2.settings, immutableGroupsMode = _config$settings.immutableGroupsMode, addSubRuleLabel = _config$settings.addSubRuleLabel, delGroupLabel = _config$settings.delGroupLabel, renderButton3 = _config$settings.renderButton, renderIcon3 = _config$settings.renderIcon, renderSwitch3 = _config$settings.renderSwitch, renderButtonGroup3 = _config$settings.renderButtonGroup, lockLabel = _config$settings.lockLabel, lockedLabel = _config$settings.lockedLabel, showLock = _config$settings.showLock, canDeleteLocked = _config$settings.canDeleteLocked;
      var Icon3 = function Icon4(pr) {
        return renderIcon3(pr, config2.ctx);
      };
      var Btn = function Btn2(pr) {
        return renderButton3(pr, config2.ctx);
      };
      var Switch2 = function Switch3(pr) {
        return renderSwitch3(pr, config2.ctx);
      };
      var BtnGrp = function BtnGrp2(pr) {
        return renderButtonGroup3(pr, config2.ctx);
      };
      var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /* @__PURE__ */ React.createElement(Switch2, {
        type: "lock",
        id: id2,
        value: isLocked,
        setValue: setLock4,
        label: lockLabel,
        checkedLabel: lockedLabel,
        config: config2
      });
      var addRuleBtn = !immutableGroupsMode && canAddRule && !isLocked && /* @__PURE__ */ React.createElement(Btn, {
        type: "addRuleGroupExt",
        onClick: addRule3,
        label: addSubRuleLabel,
        readonly: isLocked,
        config: config2,
        renderIcon: Icon3
      });
      var delGroupBtn = !immutableGroupsMode && canDeleteGroup && (!isLocked || isLocked && canDeleteLocked) && /* @__PURE__ */ React.createElement(Btn, {
        type: "delRuleGroup",
        onClick: removeSelf,
        label: delGroupLabel,
        config: config2,
        renderIcon: Icon3
      });
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--actions group--actions--tr"
      }, /* @__PURE__ */ React.createElement(BtnGrp, {
        config: config2
      }, setLockSwitch, addRuleBtn, delGroupBtn));
    }
  }]);
}(reactExports.PureComponent);
function ownKeys$a(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$a(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$a(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$a(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null) it["return"]();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function _callSuper$7(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$7() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$7() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$7 = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var _Utils$ConfigUtils$1 = Utils$1.ConfigUtils, getFieldConfig$1 = _Utils$ConfigUtils$1.getFieldConfig, getFieldWidgetConfig2 = _Utils$ConfigUtils$1.getFieldWidgetConfig;
var isEmptyRuleGroupExtPropertiesAndChildren2 = Utils$1.RuleUtils.isEmptyRuleGroupExtPropertiesAndChildren;
var RuleGroupExt = /* @__PURE__ */ function(_BasicGroup) {
  function RuleGroupExt2(props) {
    var _this;
    _classCallCheck$b(this, RuleGroupExt2);
    _this = _callSuper$7(this, RuleGroupExt2, [props]);
    _this.childrenClassName = function() {
      return "rule_group_ext--children";
    };
    _this.renderFooterWrapper = function() {
      return null;
    };
    _this.canAddGroup = function() {
      return false;
    };
    _this.canAddRule = function() {
      return true;
    };
    _this.canDeleteGroup = function() {
      return true;
    };
    return _this;
  }
  _inherits$b(RuleGroupExt2, _BasicGroup);
  return _createClass$9(RuleGroupExt2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      _get(_getPrototypeOf$1(RuleGroupExt2.prototype), "onPropsChanged", this).call(this, nextProps);
    }
  }, {
    key: "renderHeaderWrapper",
    value: function renderHeaderWrapper() {
      return /* @__PURE__ */ React.createElement("div", {
        key: "group-header",
        className: classNames("group--header", this.isOneChild() ? "one--child" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "", this.showDragIcon() ? "with--drag" : "hide--drag", this.showConjs() && (!this.isOneChild() || this.showNot()) ? "with--conjs" : "hide--conjs")
      }, this.renderHeader(), this.renderGroupField(), this.renderActions());
    }
  }, {
    key: "renderHeader",
    value: function renderHeader() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--conjunctions"
      }, this.renderConjs(), this.renderDrag());
    }
  }, {
    key: "renderGroupField",
    value: function renderGroupField() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--field--count--rule"
      }, this.renderField(), this.renderOperator(), this.renderWidget(), this.renderError());
    }
  }, {
    key: "renderError",
    value: function renderError() {
      var _this$props = this.props, config2 = _this$props.config, valueError = _this$props.valueError;
      var _config$settings = config2.settings, renderRuleError = _config$settings.renderRuleError, showErrorMessage = _config$settings.showErrorMessage;
      var oneError = _toConsumableArray((valueError === null || valueError === void 0 ? void 0 : valueError.toArray()) || []).filter(function(e2) {
        return !!e2;
      }).shift() || null;
      return showErrorMessage && oneError && /* @__PURE__ */ React.createElement("div", {
        className: "rule_group--error"
      }, renderRuleError ? renderRuleError({
        error: oneError
      }, config2.ctx) : oneError);
    }
  }, {
    key: "showNot",
    value: function showNot() {
      var _this$props2 = this.props, config2 = _this$props2.config, selectedField = _this$props2.selectedField;
      _this$props2.selectedOperator;
      var selectedFieldConfig = getFieldConfig$1(config2, selectedField) || {};
      return selectedFieldConfig.showNot != void 0 ? selectedFieldConfig.showNot : config2.settings.showNot;
    }
  }, {
    key: "conjunctionOptions",
    value: function conjunctionOptions() {
      var _this$props3 = this.props, config2 = _this$props3.config, selectedField = _this$props3.selectedField;
      _this$props3.selectedOperator;
      var selectedFieldConfig = getFieldConfig$1(config2, selectedField) || {};
      var conjunctionOptions2 = _get(_getPrototypeOf$1(RuleGroupExt2.prototype), "conjunctionOptions", this).call(this);
      if (selectedFieldConfig.conjunctions) {
        var filtered = {};
        var _iterator = _createForOfIteratorHelper(selectedFieldConfig.conjunctions), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var k = _step.value;
            var options = conjunctionOptions2[k];
            if (options) {
              filtered[k] = options;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        conjunctionOptions2 = filtered;
      }
      return conjunctionOptions2;
    }
  }, {
    key: "renderField",
    value: function renderField3() {
      var _this$props4 = this.props, config2 = _this$props4.config, selectedField = _this$props4.selectedField, selectedFieldSrc = _this$props4.selectedFieldSrc, selectedFieldType = _this$props4.selectedFieldType, setField4 = _this$props4.setField, setFieldSrc4 = _this$props4.setFieldSrc, setFuncValue4 = _this$props4.setFuncValue, parentField = _this$props4.parentField, id2 = _this$props4.id, groupId = _this$props4.groupId, isLocked = _this$props4.isLocked;
      var immutableFieldsMode = config2.settings.immutableFieldsMode;
      return /* @__PURE__ */ React.createElement(FieldWrapper, {
        key: "field",
        classname: "rule--field",
        config: config2,
        canSelectFieldSource: false,
        selectedField,
        selectedFieldSrc,
        selectedFieldType,
        setField: setField4,
        setFuncValue: setFuncValue4,
        setFieldSrc: setFieldSrc4,
        parentField,
        readonly: immutableFieldsMode || isLocked,
        id: id2,
        groupId
      });
    }
  }, {
    key: "renderOperator",
    value: function renderOperator3() {
      var _this$props5 = this.props, config2 = _this$props5.config, selectedField = _this$props5.selectedField, selectedFieldSrc = _this$props5.selectedFieldSrc, selectedOperator = _this$props5.selectedOperator;
      _this$props5.setField;
      var setOperator4 = _this$props5.setOperator, isLocked = _this$props5.isLocked;
      var immutableFieldsMode = config2.settings.immutableFieldsMode;
      var selectedFieldWidgetConfig = getFieldWidgetConfig2(config2, selectedField, selectedOperator) || {};
      var hideOperator = selectedFieldWidgetConfig.hideOperator;
      var showOperatorLabel = selectedField && hideOperator && selectedFieldWidgetConfig.operatorInlineLabel;
      var showOperator = selectedField && !hideOperator;
      return /* @__PURE__ */ React.createElement(OperatorWrapper, {
        key: "operator",
        classname: "group--operator",
        config: config2,
        selectedField,
        selectedFieldSrc,
        selectedOperator,
        setOperator: setOperator4,
        showOperator,
        showOperatorLabel,
        selectedFieldWidgetConfig,
        readonly: immutableFieldsMode || isLocked,
        id: this.props.id,
        groupId: this.props.groupId
      });
    }
  }, {
    key: "isEmptyCurrentGroup",
    value: function isEmptyCurrentGroup() {
      var _this$props6 = this.props, children1 = _this$props6.children1, config2 = _this$props6.config;
      var ruleData = this._buildWidgetProps(this.props);
      return isEmptyRuleGroupExtPropertiesAndChildren2(ruleData, children1, config2);
    }
  }, {
    key: "_buildWidgetProps",
    value: function _buildWidgetProps(_ref) {
      var selectedField = _ref.selectedField, selectedFieldSrc = _ref.selectedFieldSrc, selectedFieldType = _ref.selectedFieldType, selectedOperator = _ref.selectedOperator, operatorOptions = _ref.operatorOptions, value = _ref.value, valueType = _ref.valueType;
      _ref.valueSrc;
      _ref.asyncListValues;
      var valueError = _ref.valueError;
      _ref.fieldError;
      var parentField = _ref.parentField;
      return {
        field: selectedField,
        fieldSrc: selectedFieldSrc,
        fieldType: selectedFieldType,
        operator: selectedOperator,
        operatorOptions,
        value,
        valueType,
        // new Immutable.List(["number"])
        // todo: aggregation can be not only number?
        valueSrc: ["value"],
        //new Immutable.List(["value"]), // should be fixed in isEmptyRuleGroupExtPropertiesAndChildren
        //asyncListValues,
        valueError,
        fieldError: null,
        parentField
      };
    }
  }, {
    key: "renderWidget",
    value: function renderWidget() {
      var _this$props7 = this.props, config2 = _this$props7.config, selectedField = _this$props7.selectedField, selectedOperator = _this$props7.selectedOperator, isLocked = _this$props7.isLocked;
      var immutableValuesMode = config2.settings.immutableValuesMode;
      var isFieldAndOpSelected = selectedField && selectedOperator;
      var showWidget = isFieldAndOpSelected;
      if (!showWidget) return null;
      var widget = /* @__PURE__ */ React.createElement(Widget, _extends$h({
        key: "values",
        isForRuleGroup: true
      }, this._buildWidgetProps(this.props), {
        config: config2,
        setValue: !immutableValuesMode ? this.props.setValue : dummyFn,
        setValueSrc: dummyFn,
        readonly: immutableValuesMode || isLocked,
        id: this.props.id,
        groupId: this.props.groupId
      }));
      return /* @__PURE__ */ React.createElement(Col, {
        key: "widget-for-" + this.props.selectedOperator,
        className: "rule--value"
      }, widget);
    }
  }, {
    key: "renderActions",
    value: function renderActions() {
      var _this$props8 = this.props, config2 = _this$props8.config, addRule3 = _this$props8.addRule, isLocked = _this$props8.isLocked, isTrueLocked = _this$props8.isTrueLocked, id2 = _this$props8.id;
      return /* @__PURE__ */ React.createElement(RuleGroupExtActions, {
        config: config2,
        addRule: addRule3,
        canAddRule: this.canAddRule(),
        canDeleteGroup: this.canDeleteGroup(),
        removeSelf: this.removeSelf,
        setLock: this.setLock,
        isLocked,
        isTrueLocked,
        id: id2
      });
    }
  }, {
    key: "reordableNodesCntForItem",
    value: function reordableNodesCntForItem(_item) {
      if (this.props.isLocked) return 0;
      var children1 = this.props.children1;
      return (children1 === null || children1 === void 0 ? void 0 : children1.size) || 0;
    }
  }, {
    key: "extraPropsForItem",
    value: function extraPropsForItem(_item) {
      return {
        parentField: this.props.selectedField
      };
    }
  }]);
}(BasicGroup);
RuleGroupExt.propTypes = _objectSpread$a(_objectSpread$a({}, BasicGroup.propTypes), {}, {
  selectedField: PropTypes.any,
  selectedFieldSrc: PropTypes.string,
  selectedOperator: PropTypes.string,
  value: PropTypes.any,
  parentField: PropTypes.string,
  setField: PropTypes.func,
  setFieldSrc: PropTypes.func,
  setOperator: PropTypes.func,
  setValue: PropTypes.func,
  valueError: PropTypes.any
});
const RuleGroupExt$1 = GroupContainer(Draggable("group rule_group_ext")(WithConfirmFn(RuleGroupExt)), "rule_group");
function _callSuper$6(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$6() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$6() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$6 = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var groupActionsPositionList = {
  topLeft: "group--actions--tl",
  topCenter: "group--actions--tc",
  topRight: "group--actions--tr",
  bottomLeft: "group--actions--bl",
  bottomCenter: "group--actions--bc",
  bottomRight: "group--actions--br"
};
var defaultPosition = "topRight";
var SwitchGroupActions = /* @__PURE__ */ function(_PureComponent) {
  function SwitchGroupActions2() {
    _classCallCheck$b(this, SwitchGroupActions2);
    return _callSuper$6(this, SwitchGroupActions2, arguments);
  }
  _inherits$b(SwitchGroupActions2, _PureComponent);
  return _createClass$9(SwitchGroupActions2, [{
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, addCaseGroup3 = _this$props.addCaseGroup, addDefaultCaseGroup3 = _this$props.addDefaultCaseGroup, setLock4 = _this$props.setLock, isLocked = _this$props.isLocked, isTrueLocked = _this$props.isTrueLocked, id2 = _this$props.id, canAddGroup = _this$props.canAddGroup, canAddDefault = _this$props.canAddDefault;
      var _config$settings = config2.settings, immutableGroupsMode = _config$settings.immutableGroupsMode, addCaseLabel = _config$settings.addCaseLabel, addDefaultCaseLabel = _config$settings.addDefaultCaseLabel, groupActionsPosition = _config$settings.groupActionsPosition, renderButton3 = _config$settings.renderButton, renderIcon3 = _config$settings.renderIcon, renderSwitch3 = _config$settings.renderSwitch, renderButtonGroup3 = _config$settings.renderButtonGroup, lockLabel = _config$settings.lockLabel, lockedLabel = _config$settings.lockedLabel, showLock = _config$settings.showLock;
      var Icon3 = function Icon4(pr) {
        return renderIcon3(pr, config2.ctx);
      };
      var Btn = function Btn2(pr) {
        return renderButton3(pr, config2.ctx);
      };
      var Switch2 = function Switch3(pr) {
        return renderSwitch3(pr, config2.ctx);
      };
      var BtnGrp = function BtnGrp2(pr) {
        return renderButtonGroup3(pr, config2.ctx);
      };
      var position = groupActionsPositionList[groupActionsPosition || defaultPosition];
      var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /* @__PURE__ */ React.createElement(Switch2, {
        type: "lock",
        id: id2,
        value: isLocked,
        setValue: setLock4,
        label: lockLabel,
        checkedLabel: lockedLabel,
        config: config2
      });
      var addCaseGroupBtn = !immutableGroupsMode && canAddGroup && !isLocked && /* @__PURE__ */ React.createElement(Btn, {
        type: "addCaseGroup",
        onClick: addCaseGroup3,
        label: addCaseLabel,
        readonly: isLocked,
        config: config2,
        renderIcon: Icon3
      });
      var addDefaultCaseGroupBtn = !immutableGroupsMode && canAddDefault && !isLocked && /* @__PURE__ */ React.createElement(Btn, {
        type: "addDefaultCaseGroup",
        onClick: addDefaultCaseGroup3,
        label: addDefaultCaseLabel,
        readonly: isLocked,
        config: config2,
        renderIcon: Icon3
      });
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--actions ".concat(position)
      }, /* @__PURE__ */ React.createElement(BtnGrp, {
        config: config2
      }, setLockSwitch, addCaseGroupBtn, addDefaultCaseGroupBtn));
    }
  }]);
}(reactExports.PureComponent);
function ownKeys$9(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$9(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$9(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$9(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _callSuper$5(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$5() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$5() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$5 = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var _Utils$TreeUtils$1 = Utils$1.TreeUtils, getTotalReordableNodesCountInTree$1 = _Utils$TreeUtils$1.getTotalReordableNodesCountInTree, getTotalRulesCountInTree$1 = _Utils$TreeUtils$1.getTotalRulesCountInTree;
var SwitchGroup = /* @__PURE__ */ function(_BasicGroup) {
  function SwitchGroup2(props) {
    var _this;
    _classCallCheck$b(this, SwitchGroup2);
    _this = _callSuper$5(this, SwitchGroup2, [props]);
    _this.childrenClassName = function() {
      return "switch_group--children";
    };
    _this.renderFooterWrapper = function() {
      return null;
    };
    _this.hasDefaultCase = function() {
      var _this$props$children;
      return ((_this$props$children = _this.props.children1) === null || _this$props$children === void 0 ? void 0 : _this$props$children.size) && _this.props.children1.filter(function(c2) {
        return c2.get("children1") == null;
      }).size > 0;
    };
    return _this;
  }
  _inherits$b(SwitchGroup2, _BasicGroup);
  return _createClass$9(SwitchGroup2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      _get(_getPrototypeOf$1(SwitchGroup2.prototype), "onPropsChanged", this).call(this, nextProps);
    }
  }, {
    key: "canAddGroup",
    value: function canAddGroup() {
      var _this$props$children2;
      var maxNumberOfCases = this.props.config.settings.maxNumberOfCases;
      var totalCasesCnt = ((_this$props$children2 = this.props.children1) === null || _this$props$children2 === void 0 ? void 0 : _this$props$children2.size) || 0;
      if (maxNumberOfCases) {
        return totalCasesCnt < maxNumberOfCases;
      }
      return true;
    }
  }, {
    key: "canAddRule",
    value: function canAddRule() {
      return false;
    }
  }, {
    key: "reordableNodesCnt",
    value: function reordableNodesCnt() {
      var _this$props$children3;
      var totalCasesCnt = ((_this$props$children3 = this.props.children1) === null || _this$props$children3 === void 0 ? void 0 : _this$props$children3.size) || 0;
      var casesToReorder = totalCasesCnt;
      if (this.hasDefaultCase()) {
        casesToReorder--;
      }
      return casesToReorder;
    }
  }, {
    key: "totalRulesCntForItem",
    value: function totalRulesCntForItem(item) {
      return getTotalRulesCountInTree$1(item);
    }
  }, {
    key: "reordableNodesCntForItem",
    value: function reordableNodesCntForItem(item) {
      var _this$props$children4;
      if (this.props.isLocked) return 0;
      var _this$props$config$se = this.props.config.settings, canLeaveEmptyCase = _this$props$config$se.canLeaveEmptyCase, canRegroupCases = _this$props$config$se.canRegroupCases;
      var totalCasesCnt = ((_this$props$children4 = this.props.children1) === null || _this$props$children4 === void 0 ? void 0 : _this$props$children4.size) || 0;
      var casesToReorder = totalCasesCnt;
      if (this.hasDefaultCase()) {
        casesToReorder--;
      }
      var nodesInCase = getTotalReordableNodesCountInTree$1(item);
      var cnt = nodesInCase;
      if (cnt == 1 && canRegroupCases && canLeaveEmptyCase && casesToReorder > 1) cnt = 111;
      return cnt;
    }
  }, {
    key: "renderHeaderWrapper",
    value: function renderHeaderWrapper() {
      return /* @__PURE__ */ React.createElement("div", {
        key: "group-header",
        className: classNames(
          "group--header",
          this.isOneChild() ? "one--child" : "",
          this.isOneChild() ? "hide--line" : "",
          this.isNoChildren() ? "no--children" : "",
          this.showDragIcon() ? "with--drag" : "hide--drag"
          //this.showConjs() && (!this.isOneChild() || this.showNot()) ? "with--conjs" : "hide--conjs"
        )
      }, this.renderHeader(), this.renderActions());
    }
  }, {
    key: "renderHeader",
    value: function renderHeader() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--conjunctions"
      }, this.renderConjs(), this.renderDrag());
    }
  }, {
    key: "renderConjs",
    value: function renderConjs3() {
      var config2 = this.props.config;
      var renderSwitchPrefix = config2.settings.renderSwitchPrefix;
      return renderSwitchPrefix || null;
    }
  }, {
    key: "showNot",
    value: function showNot() {
      return false;
    }
  }, {
    key: "renderActions",
    value: function renderActions() {
      var _this$props = this.props, config2 = _this$props.config, addCaseGroup3 = _this$props.addCaseGroup, addDefaultCaseGroup3 = _this$props.addDefaultCaseGroup, isLocked = _this$props.isLocked, isTrueLocked = _this$props.isTrueLocked, id2 = _this$props.id;
      return /* @__PURE__ */ React.createElement(SwitchGroupActions, {
        config: config2,
        addCaseGroup: addCaseGroup3,
        addDefaultCaseGroup: addDefaultCaseGroup3,
        canAddDefault: !this.hasDefaultCase(),
        canAddGroup: this.canAddGroup(),
        setLock: this.setLock,
        isLocked,
        isTrueLocked,
        id: id2
      });
    }
  }]);
}(BasicGroup);
SwitchGroup.propTypes = _objectSpread$9({}, BasicGroup.propTypes);
const SwitchGroup$1 = GroupContainer(Draggable("group switch_group")(WithConfirmFn(SwitchGroup)), "switch_group");
function ownKeys$8(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$8(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$8(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$8(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _callSuper$4(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$4() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$4() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$4 = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var CaseGroup = /* @__PURE__ */ function(_BasicGroup) {
  function CaseGroup2(props) {
    var _this;
    _classCallCheck$b(this, CaseGroup2);
    _this = _callSuper$4(this, CaseGroup2, [props]);
    _this.childrenClassName = function() {
      return "case_group--children";
    };
    _this.renderFooterWrapper = function() {
      return null;
    };
    return _this;
  }
  _inherits$b(CaseGroup2, _BasicGroup);
  return _createClass$9(CaseGroup2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var configChanged = !this.renderBeforeCaseValue || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.config) !== (nextProps === null || nextProps === void 0 ? void 0 : nextProps.config);
      _get(_getPrototypeOf$1(CaseGroup2.prototype), "onPropsChanged", this).call(this, nextProps);
      if (configChanged) {
        var config2 = nextProps.config;
        var _config$settings = config2.settings, renderBeforeCaseValue2 = _config$settings.renderBeforeCaseValue, renderAfterCaseValue = _config$settings.renderAfterCaseValue, renderRuleError = _config$settings.renderRuleError;
        this.BeforeCaseValue = getRenderFromConfig(config2, renderBeforeCaseValue2);
        this.AfterCaseValue = getRenderFromConfig(config2, renderAfterCaseValue);
        this.RuleError = getRenderFromConfig(config2, renderRuleError);
      }
    }
  }, {
    key: "isDefaultCase",
    value: function isDefaultCase() {
      return this.props.children1 == void 0;
    }
  }, {
    key: "reordableNodesCnt",
    value: function reordableNodesCnt() {
      return this.props.parentReordableNodesCnt;
    }
  }, {
    key: "reordableNodesCntForItem",
    value: function reordableNodesCntForItem(_item) {
      if (this.props.isLocked) return 0;
      return this.props.reordableNodesCnt;
    }
  }, {
    key: "totalRulesCntForItem",
    value: function totalRulesCntForItem(_item) {
      return this.props.totalRulesCnt;
    }
  }, {
    key: "showDragIcon",
    value: function showDragIcon() {
      if (this.isDefaultCase()) return false;
      return _get(_getPrototypeOf$1(CaseGroup2.prototype), "showDragIcon", this).call(this);
    }
  }, {
    key: "renderHeaderWrapper",
    value: function renderHeaderWrapper() {
      return /* @__PURE__ */ React.createElement("div", {
        key: "group-header",
        className: classNames("group--header", this.isOneChild() ? "one--child" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "", this.showDragIcon() ? "with--drag" : "hide--drag", this.showConjs() && (!this.isOneChild() || this.showNot()) ? "with--conjs" : "hide--conjs")
      }, this.renderHeaderLeft(), this.renderHeaderCenter(), this.renderActions());
    }
  }, {
    key: "renderChildrenWrapper",
    value: function renderChildrenWrapper() {
      if (this.isDefaultCase()) return null;
      return /* @__PURE__ */ React.createElement("div", {
        className: "case_group--body"
      }, this.renderCondition(), this.renderBeforeValue(), this.renderValue(), this.renderAfterValue());
    }
  }, {
    key: "renderHeaderLeft",
    value: function renderHeaderLeft() {
      if (this.isDefaultCase()) {
        var defaultCaseLabel = this.props.config.settings.defaultCaseLabel;
        return defaultCaseLabel || "";
      }
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--conjunctions"
      }, this.renderConjs(), this.renderDrag(), this.renderError());
    }
  }, {
    key: "renderCondition",
    value: function renderCondition() {
      if (this.isDefaultCase()) return null;
      return _get(_getPrototypeOf$1(CaseGroup2.prototype), "renderChildrenWrapper", this).call(this);
    }
  }, {
    key: "renderHeaderCenter",
    value: function renderHeaderCenter() {
      if (this.isDefaultCase()) {
        return /* @__PURE__ */ React.createElement("div", null, this.renderValue(), this.renderError());
      }
      return null;
    }
  }, {
    key: "canAddGroup",
    value: function canAddGroup() {
      if (this.isDefaultCase()) return false;
      return _get(_getPrototypeOf$1(CaseGroup2.prototype), "canAddGroup", this).call(this);
    }
  }, {
    key: "canAddRule",
    value: function canAddRule() {
      if (this.isDefaultCase()) return false;
      return _get(_getPrototypeOf$1(CaseGroup2.prototype), "canAddRule", this).call(this);
    }
  }, {
    key: "renderBeforeValue",
    value: function renderBeforeValue() {
      var BeforeCaseValue = this.BeforeCaseValue;
      if (BeforeCaseValue == void 0) return null;
      return /* @__PURE__ */ React.createElement(BeforeCaseValue, _extends$h({
        key: "values-before"
      }, this.props));
    }
  }, {
    key: "renderAfterValue",
    value: function renderAfterValue() {
      var AfterCaseValue = this.AfterCaseValue;
      if (AfterCaseValue == void 0) return null;
      return /* @__PURE__ */ React.createElement(AfterCaseValue, _extends$h({
        key: "values-after"
      }, this.props));
    }
  }, {
    key: "renderError",
    value: function renderError() {
      var _this$props = this.props, config2 = _this$props.config, valueError = _this$props.valueError;
      var showErrorMessage = config2.settings.showErrorMessage;
      var RuleError = this.RuleError;
      var oneError = _toConsumableArray((valueError === null || valueError === void 0 ? void 0 : valueError.toArray()) || []).filter(function(e2) {
        return !!e2;
      }).shift() || null;
      return showErrorMessage && oneError && /* @__PURE__ */ React.createElement("div", {
        className: "rule--error"
      }, RuleError ? /* @__PURE__ */ React.createElement(RuleError, {
        error: oneError
      }) : oneError);
    }
  }, {
    key: "renderValue",
    value: function renderValue() {
      var _this$props2 = this.props, config2 = _this$props2.config, isLocked = _this$props2.isLocked, value = _this$props2.value, valueSrc = _this$props2.valueSrc, valueError = _this$props2.valueError, setValue4 = _this$props2.setValue, setValueSrc4 = _this$props2.setValueSrc, setFuncValue4 = _this$props2.setFuncValue, id2 = _this$props2.id;
      var immutableValuesMode = config2.settings.immutableValuesMode;
      var widget = /* @__PURE__ */ React.createElement(Widget, {
        key: "values",
        isCaseValue: true,
        field: "!case_value",
        operator: null,
        value,
        valueSrc: valueSrc !== null && valueSrc !== void 0 ? valueSrc : "value",
        valueError,
        fieldError: null,
        config: config2,
        setValue: !immutableValuesMode ? setValue4 : dummyFn,
        setValueSrc: !immutableValuesMode ? setValueSrc4 : dummyFn,
        setFuncValue: !immutableValuesMode ? setFuncValue4 : dummyFn,
        readonly: immutableValuesMode || isLocked,
        id: id2,
        groupId: null
      });
      return /* @__PURE__ */ React.createElement(Col, {
        className: "case_group--value"
      }, widget);
    }
  }, {
    key: "renderActions",
    value: function renderActions() {
      var _this$props3 = this.props, config2 = _this$props3.config, addGroup3 = _this$props3.addGroup, addRule3 = _this$props3.addRule, isLocked = _this$props3.isLocked, isTrueLocked = _this$props3.isTrueLocked, id2 = _this$props3.id;
      return /* @__PURE__ */ React.createElement(GroupActions, {
        config: config2,
        addGroup: addGroup3,
        addRule: addRule3,
        canAddRule: this.canAddRule(),
        canAddGroup: this.canAddGroup(),
        canDeleteGroup: this.canDeleteGroup(),
        removeSelf: this.removeSelf,
        setLock: this.setLock,
        isLocked,
        isTrueLocked,
        id: id2
      });
    }
  }, {
    key: "isEmptyCurrentGroup",
    value: function isEmptyCurrentGroup() {
      var value = this.props.value;
      var oneValue = value && value.size ? value.get(0) : null;
      var hasValue = oneValue != null && (Array.isArray(oneValue) ? oneValue.length > 0 : true);
      return _get(_getPrototypeOf$1(CaseGroup2.prototype), "isEmptyCurrentGroup", this).call(this) && !hasValue;
    }
  }]);
}(BasicGroup);
CaseGroup.propTypes = _objectSpread$8(_objectSpread$8({}, BasicGroup.propTypes), {}, {
  parentReordableNodesCnt: PropTypes.number,
  value: PropTypes.any,
  setValue: PropTypes.func
});
const CaseGroup$1 = GroupContainer(Draggable("group case_group")(WithConfirmFn(CaseGroup)), "case_group");
var _excluded$4 = ["type"];
function _callSuper$3(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$3() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$3() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$3 = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
function ownKeys$7(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$7(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$7(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$7(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var types$3 = ["rule", "group", "rule_group", "switch_group", "case_group"];
var getProperties = function getProperties2(props) {
  var _props$properties;
  var properties = ((_props$properties = props.properties) === null || _props$properties === void 0 ? void 0 : _props$properties.toObject()) || {};
  var result = _objectSpread$7({}, properties);
  if (props.isParentLocked) {
    result.isLocked = true;
  }
  if (properties.isLocked) {
    result.isTrueLocked = true;
  }
  return result;
};
var typeMap = {
  rule: function rule2(props) {
    return /* @__PURE__ */ React.createElement(Rule$1, _extends$h({}, getProperties(props), {
      id: props.id,
      groupId: props.groupId,
      path: props.path,
      actions: props.actions,
      reordableNodesCnt: props.reordableNodesCnt,
      totalRulesCnt: props.totalRulesCnt,
      config: props.config,
      onDragStart: props.onDragStart,
      isDraggingTempo: props.isDraggingTempo,
      parentField: props.parentField,
      parentReordableNodesCnt: props.parentReordableNodesCnt
    }));
  },
  group: function group2(props) {
    return /* @__PURE__ */ React.createElement(Group, _extends$h({}, getProperties(props), {
      id: props.id,
      groupId: props.groupId,
      path: props.path,
      actions: props.actions,
      config: props.config,
      reordableNodesCnt: props.reordableNodesCnt,
      totalRulesCnt: props.totalRulesCnt,
      onDragStart: props.onDragStart,
      isDraggingTempo: props.isDraggingTempo,
      children1: props.children1,
      parentField: null,
      parentReordableNodesCnt: props.parentReordableNodesCnt
    }));
  },
  rule_group: function rule_group(props) {
    return /* @__PURE__ */ React.createElement(RuleGroup$1, _extends$h({}, getProperties(props), {
      id: props.id,
      groupId: props.groupId,
      path: props.path,
      actions: props.actions,
      config: props.config,
      reordableNodesCnt: props.reordableNodesCnt,
      totalRulesCnt: props.totalRulesCnt,
      onDragStart: props.onDragStart,
      isDraggingTempo: props.isDraggingTempo,
      children1: props.children1,
      parentField: props.parentField,
      parentReordableNodesCnt: props.parentReordableNodesCnt
    }));
  },
  rule_group_ext: function rule_group_ext(props) {
    return /* @__PURE__ */ React.createElement(RuleGroupExt$1, _extends$h({}, getProperties(props), {
      id: props.id,
      groupId: props.groupId,
      path: props.path,
      actions: props.actions,
      config: props.config,
      reordableNodesCnt: props.reordableNodesCnt,
      totalRulesCnt: props.totalRulesCnt,
      onDragStart: props.onDragStart,
      isDraggingTempo: props.isDraggingTempo,
      children1: props.children1,
      parentField: props.parentField,
      parentReordableNodesCnt: props.parentReordableNodesCnt
    }));
  },
  switch_group: function switch_group(props) {
    return /* @__PURE__ */ React.createElement(SwitchGroup$1, _extends$h({}, getProperties(props), {
      id: props.id,
      groupId: props.groupId,
      path: props.path,
      actions: props.actions,
      config: props.config,
      reordableNodesCnt: props.reordableNodesCnt,
      totalRulesCnt: props.totalRulesCnt,
      onDragStart: props.onDragStart,
      isDraggingTempo: props.isDraggingTempo,
      children1: props.children1,
      parentField: null,
      parentReordableNodesCnt: props.parentReordableNodesCnt
    }));
  },
  case_group: function case_group(props) {
    return /* @__PURE__ */ React.createElement(CaseGroup$1, _extends$h({}, getProperties(props), {
      id: props.id,
      groupId: props.groupId,
      path: props.path,
      actions: props.actions,
      config: props.config,
      reordableNodesCnt: props.reordableNodesCnt,
      totalRulesCnt: props.totalRulesCnt,
      onDragStart: props.onDragStart,
      isDraggingTempo: props.isDraggingTempo,
      children1: props.children1,
      parentField: null,
      parentReordableNodesCnt: props.parentReordableNodesCnt
    }));
  }
};
var Item = /* @__PURE__ */ function(_PureComponent) {
  function Item2() {
    _classCallCheck$b(this, Item2);
    return _callSuper$3(this, Item2, arguments);
  }
  _inherits$b(Item2, _PureComponent);
  return _createClass$9(Item2, [{
    key: "render",
    value: function render3() {
      var _props$properties2;
      var _this$props = this.props, type2 = _this$props.type, props = _objectWithoutProperties$2(_this$props, _excluded$4);
      var mode = (_props$properties2 = props.properties) === null || _props$properties2 === void 0 ? void 0 : _props$properties2.get("mode");
      var postfix = mode == "array" ? "_ext" : "";
      var renderItem = props.config.settings.renderItem;
      var Cmp = typeMap[type2 + postfix];
      if (renderItem) {
        return renderItem(_objectSpread$7(_objectSpread$7({}, props), {}, {
          type: type2,
          itemComponent: Cmp
        }), props.config.ctx);
      }
      if (!Cmp) return null;
      return Cmp(props);
    }
  }]);
}(reactExports.PureComponent);
Item.propTypes = {
  config: PropTypes.object.isRequired,
  id: PropTypes.string.isRequired,
  groupId: PropTypes.string,
  type: PropTypes.oneOf(types$3).isRequired,
  path: PropTypes.any.isRequired,
  //instanceOf(Immutable.List)
  properties: PropTypes.any,
  //instanceOf(Immutable.Map)
  children1: PropTypes.any,
  //instanceOf(Immutable.OrderedMap)
  actions: PropTypes.object.isRequired,
  reordableNodesCnt: PropTypes.number,
  onDragStart: PropTypes.func,
  parentField: PropTypes.string,
  //from RuleGroup
  isDraggingTempo: PropTypes.bool,
  isParentLocked: PropTypes.bool
};
function _callSuper$2(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$2() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$2() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var _Utils$TreeUtils = Utils$1.TreeUtils, getTotalReordableNodesCountInTree2 = _Utils$TreeUtils.getTotalReordableNodesCountInTree, getTotalRulesCountInTree2 = _Utils$TreeUtils.getTotalRulesCountInTree;
var _Utils$DefaultUtils = Utils$1.DefaultUtils, createListWithOneElement2 = _Utils$DefaultUtils.createListWithOneElement, emptyProperties2 = _Utils$DefaultUtils.emptyProperties;
var Builder = /* @__PURE__ */ function(_Component) {
  function Builder2(props) {
    var _this;
    _classCallCheck$b(this, Builder2);
    _this = _callSuper$2(this, Builder2, [props]);
    _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_this);
    _this._updPath(props);
    return _this;
  }
  _inherits$b(Builder2, _Component);
  return _createClass$9(Builder2, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      var should = this.pureShouldComponentUpdate(nextProps, nextState);
      return should;
    }
  }, {
    key: "_updPath",
    value: function _updPath(props) {
      var id2 = props.tree.get("id");
      this.path = createListWithOneElement2(id2);
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$props = this.props, tree2 = _this$props.tree, config2 = _this$props.config, actions = _this$props.actions, onDragStart = _this$props.onDragStart;
      var rootType = tree2.get("type");
      var isTernary = rootType == "switch_group";
      var reordableNodesCnt = isTernary ? null : getTotalReordableNodesCountInTree2(tree2);
      var totalRulesCnt = isTernary ? null : getTotalRulesCountInTree2(tree2);
      var id2 = tree2.get("id");
      return /* @__PURE__ */ React.createElement(Item, {
        key: id2,
        id: id2,
        path: this.path,
        type: rootType,
        properties: tree2.get("properties") || emptyProperties2(),
        config: config2,
        actions,
        children1: tree2.get("children1") || emptyProperties2(),
        reordableNodesCnt,
        totalRulesCnt,
        parentReordableNodesCnt: 0,
        onDragStart
      });
    }
  }]);
}(reactExports.Component);
Builder.propTypes = {
  tree: PropTypes.any.isRequired,
  //instanceOf(Immutable.Map)
  config: PropTypes.object.isRequired,
  actions: PropTypes.object.isRequired,
  onDragStart: PropTypes.func
};
const Builder$1 = SortableContainer(Builder);
function ownKeys$6(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$6(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$6(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$6(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _callSuper$1(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct$1() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct$1() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var clone = Utils$1.clone;
var _Utils$ConfigUtils = Utils$1.ConfigUtils, getFieldConfig2 = _Utils$ConfigUtils.getFieldConfig, getFieldParts2 = _Utils$ConfigUtils.getFieldParts, getFieldPathParts2 = _Utils$ConfigUtils.getFieldPathParts;
var _Utils$RuleUtils = Utils$1.RuleUtils, getFieldPathLabels2 = _Utils$RuleUtils.getFieldPathLabels, getWidgetForFieldOp2 = _Utils$RuleUtils.getWidgetForFieldOp;
var ValueField = /* @__PURE__ */ function(_Component) {
  function ValueField2(props) {
    var _this;
    _classCallCheck$b(this, ValueField2);
    _this = _callSuper$1(this, ValueField2, [props]);
    useOnPropsChanged(_this);
    _this.onPropsChanged(props);
    return _this;
  }
  _inherits$b(ValueField2, _Component);
  return _createClass$9(ValueField2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForItems = ["config", "field", "fieldSrc", "fieldType", "operator", "isFuncArg", "parentField"];
      var keysForMeta = ["config", "field", "fieldSrc", "fieldType", "operator", "value", "placeholder", "isFuncArg", "parentField"];
      var needUpdateItems = !this.items || keysForItems.map(function(k) {
        return nextProps[k] !== prevProps[k];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      var needUpdateMeta = !this.meta || keysForMeta.map(function(k) {
        return nextProps[k] !== prevProps[k];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      if (needUpdateItems) {
        this.items = this.getItems(nextProps);
      }
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getItems",
    value: function getItems(_ref) {
      var config2 = _ref.config, field = _ref.field, fieldType = _ref.fieldType, operator = _ref.operator, parentField = _ref.parentField, isFuncArg = _ref.isFuncArg, fieldDefinition = _ref.fieldDefinition;
      var canCompareFieldWithField2 = config2.settings.canCompareFieldWithField;
      var parentFieldPath = getFieldParts2(parentField, config2);
      var parentFieldConfig = parentField ? getFieldConfig2(config2, parentField) : null;
      var sourceFields = parentField ? parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.subfields : config2.fields;
      var filteredFields = this.filterFields(config2, sourceFields, field, parentField, parentFieldPath, operator, canCompareFieldWithField2, isFuncArg, fieldDefinition, fieldType);
      var items = this.buildOptions(parentFieldPath, config2, filteredFields, parentFieldPath);
      return items;
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref2) {
      var _leftFieldConfig$widg;
      var config2 = _ref2.config, field = _ref2.field;
      _ref2.fieldType;
      _ref2.operator;
      var value = _ref2.value, customPlaceholder = _ref2.placeholder, isFuncArg = _ref2.isFuncArg, parentField = _ref2.parentField;
      var _config$settings = config2.settings, fieldPlaceholder = _config$settings.fieldPlaceholder, fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay;
      var selectedKey = value;
      var isFieldSelected = !!value;
      var leftFieldConfig = field ? getFieldConfig2(config2, field) : {};
      var leftFieldWidgetField = leftFieldConfig === null || leftFieldConfig === void 0 || (_leftFieldConfig$widg = leftFieldConfig.widgets) === null || _leftFieldConfig$widg === void 0 ? void 0 : _leftFieldConfig$widg.field;
      var leftFieldWidgetFieldProps = (leftFieldWidgetField === null || leftFieldWidgetField === void 0 ? void 0 : leftFieldWidgetField.widgetProps) || {};
      var placeholder2 = isFieldSelected ? null : isFuncArg && customPlaceholder || leftFieldWidgetFieldProps.valuePlaceholder || fieldPlaceholder;
      var currField = isFieldSelected ? getFieldConfig2(config2, selectedKey) : null;
      var selectedOpts = currField || {};
      var selectedKeys = getFieldPathParts2(selectedKey, config2);
      var selectedPath = getFieldPathParts2(selectedKey, config2, true);
      var selectedLabel = this.getFieldLabel(currField, selectedKey, config2);
      var partsLabels = getFieldPathLabels2(selectedKey, config2);
      var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
      if (selectedFullLabel == selectedLabel || parentField) selectedFullLabel = null;
      var selectedAltLabel = selectedOpts.label2 || selectedOpts.tooltip;
      return {
        placeholder: placeholder2,
        selectedKey,
        selectedKeys,
        selectedPath,
        selectedLabel,
        selectedOpts,
        selectedAltLabel,
        selectedFullLabel
      };
    }
  }, {
    key: "filterFields",
    value: function filterFields(config2, fields, leftFieldFullkey, parentField, parentFieldPath, operator, canCompareFieldWithField2, isFuncArg, fieldDefinition, fieldType) {
      fields = clone(fields);
      var fieldSeparator = config2.settings.fieldSeparator;
      var leftFieldConfig = getFieldConfig2(config2, leftFieldFullkey);
      var widget = getWidgetForFieldOp2(config2, leftFieldFullkey, operator, "value");
      config2.widgets[widget];
      var expectedType;
      if (isFuncArg) {
        expectedType = fieldDefinition === null || fieldDefinition === void 0 ? void 0 : fieldDefinition.type;
      } else if (leftFieldConfig) {
        expectedType = leftFieldConfig.type;
      } else {
        expectedType = fieldType;
      }
      function _filter(list2, path) {
        for (var rightFieldKey in list2) {
          var subfields = list2[rightFieldKey].subfields;
          var subpath = (path ? path : []).concat(rightFieldKey);
          var rightFieldFullkey = subpath.join(fieldSeparator);
          var rightFieldConfig = getFieldConfig2(config2, rightFieldFullkey);
          if (!rightFieldConfig) {
            delete list2[rightFieldKey];
          } else if (rightFieldConfig.type == "!struct" || rightFieldConfig.type == "!group") {
            if (_filter(subfields, subpath) == 0) delete list2[rightFieldKey];
          } else {
            var canUse = (!expectedType || rightFieldConfig.type == expectedType) && (isFuncArg ? true : rightFieldFullkey != leftFieldFullkey);
            var fn = canCompareFieldWithField2 || config2.settings.canCompareFieldWithField;
            if (fn) canUse = canUse && fn(leftFieldFullkey, leftFieldConfig, rightFieldFullkey, rightFieldConfig, operator);
            if (!canUse) delete list2[rightFieldKey];
          }
        }
        return keys$9(list2).length;
      }
      _filter(fields, parentFieldPath || []);
      return fields;
    }
  }, {
    key: "buildOptions",
    value: function buildOptions3(parentFieldPath, config2, fields) {
      var _this2 = this;
      var path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      var optGroup = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
      if (!fields) return null;
      var _config$settings2 = config2.settings, fieldSeparator = _config$settings2.fieldSeparator, fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
      var prefix = path !== null && path !== void 0 && path.length ? path.join(fieldSeparator) + fieldSeparator : "";
      return keys$9(fields).map(function(fieldKey) {
        var fullFieldPath = [].concat(_toConsumableArray(path !== null && path !== void 0 ? path : []), [fieldKey]);
        var field = fields[fieldKey];
        var label2 = _this2.getFieldLabel(field, fullFieldPath, config2);
        var partsLabels = getFieldPathLabels2(fullFieldPath, config2);
        var fullLabel = partsLabels.join(fieldSeparatorDisplay);
        if (fullLabel == label2 || parentFieldPath) fullLabel = null;
        var altLabel = field.label2;
        var tooltip = field.tooltip;
        if (field.hideForCompare) return void 0;
        if (field.type == "!struct" || field.type == "!group") {
          return {
            key: fieldKey,
            path: prefix + fieldKey,
            label: label2,
            fullLabel,
            altLabel,
            tooltip,
            items: _this2.buildOptions(parentFieldPath, config2, field.subfields, fullFieldPath, {
              label: label2,
              tooltip
            })
          };
        } else {
          return {
            key: fieldKey,
            path: prefix + fieldKey,
            label: label2,
            fullLabel,
            altLabel,
            tooltip,
            grouplabel: optGroup === null || optGroup === void 0 ? void 0 : optGroup.label,
            group: optGroup
          };
        }
      }).filter(function(o) {
        return !!o;
      });
    }
  }, {
    key: "getFieldLabel",
    value: function getFieldLabel(fieldOpts, fieldKey, config2) {
      if (!fieldKey) return null;
      var maxLabelsLength = config2.settings.maxLabelsLength;
      var fieldParts = getFieldParts2(fieldKey, config2);
      var label2 = (fieldOpts === null || fieldOpts === void 0 ? void 0 : fieldOpts.label) || last$2(fieldParts);
      label2 = truncateString(label2, maxLabelsLength);
      return label2;
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, customProps = _this$props.customProps, setValue4 = _this$props.setValue, readonly = _this$props.readonly, id2 = _this$props.id, groupId = _this$props.groupId;
      var renderField3 = config2.settings.renderField;
      var renderProps = _objectSpread$6({
        isValueField: true,
        config: config2,
        customProps,
        setField: setValue4,
        readonly,
        items: this.items,
        id: id2,
        groupId
      }, this.meta);
      return renderField3(renderProps, config2.ctx);
    }
  }]);
}(reactExports.Component);
ValueField.propTypes = {
  id: PropTypes.string,
  groupId: PropTypes.string,
  setValue: PropTypes.func.isRequired,
  config: PropTypes.object.isRequired,
  field: PropTypes.any,
  fieldSrc: PropTypes.string,
  fieldType: PropTypes.string,
  value: PropTypes.string,
  operator: PropTypes.string,
  customProps: PropTypes.object,
  readonly: PropTypes.bool,
  parentField: PropTypes.string,
  fieldDefinition: PropTypes.object,
  isFuncArg: PropTypes.bool
};
const VanillaBoolean = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var labelYes = props.labelYes, labelNo = props.labelNo, readonly = props.readonly;
  props.widgetId;
  var _props$customProps = props.customProps, customProps = _props$customProps === void 0 ? {} : _props$customProps;
  var customRadioYesProps = customProps.radioYes || {};
  var customRadioNoProps = customProps.radioNo || {};
  var onRadioChange = function onRadioChange2(e2) {
    return setValue4(e2.target.value == "true");
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("input", _extends$h({
    type: "radio",
    value: true,
    checked: !!value,
    disabled: readonly,
    onChange: onRadioChange
  }, customRadioYesProps)), " ", labelYes, /* @__PURE__ */ React.createElement("input", _extends$h({
    type: "radio",
    value: false,
    checked: !value,
    disabled: readonly,
    onChange: onRadioChange
  }, customRadioNoProps)), " ", labelNo);
};
const VanillaText = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var readonly = props.readonly, placeholder2 = props.placeholder, maxLength = props.maxLength, customProps = props.customProps;
  var onChange = function onChange2(e2) {
    var val = e2.target.value;
    if (val === "") val = void 0;
    setValue4(val);
  };
  var textValue = value || "";
  return /* @__PURE__ */ React.createElement("input", _extends$h({
    type: "text",
    value: textValue,
    placeholder: placeholder2,
    disabled: readonly,
    onChange,
    maxLength
  }, customProps));
};
const VanillaTextArea = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var readonly = props.readonly, placeholder2 = props.placeholder, maxLength = props.maxLength;
  props.maxRows;
  var fullWidth2 = props.fullWidth, customProps = props.customProps;
  var onChange = function onChange2(e2) {
    var val = e2.target.value;
    if (val === "") val = void 0;
    setValue4(val);
  };
  var textValue = value || "";
  return /* @__PURE__ */ React.createElement("textarea", _extends$h({
    value: textValue,
    placeholder: placeholder2,
    disabled: readonly,
    onChange,
    maxLength,
    style: {
      width: fullWidth2 ? "100%" : void 0
    }
  }, customProps));
};
Utils$1.moment;
const VanillaDate = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  props.valueFormat;
  var readonly = props.readonly, customProps = props.customProps;
  var onChange = function onChange2(e2) {
    var value2 = e2.target.value;
    if (value2 == "") value2 = void 0;
    setValue4(value2);
  };
  return /* @__PURE__ */ React.createElement("input", _extends$h({
    type: "date",
    value: value || "",
    disabled: readonly,
    onChange
  }, customProps));
};
const VanillaTime = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  props.valueFormat;
  props.use12Hours;
  var readonly = props.readonly, customProps = props.customProps;
  var onChange = function onChange2(e2) {
    var value2 = e2.target.value;
    if (value2 == "") value2 = void 0;
    setValue4(value2);
  };
  return /* @__PURE__ */ React.createElement("input", _extends$h({
    type: "time",
    value: value || "",
    disabled: readonly,
    onChange
  }, customProps));
};
var moment$3 = Utils$1.moment;
const VanillaDateTime = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var valueFormat = props.valueFormat;
  props.use12Hours;
  var readonly = props.readonly, customProps = props.customProps;
  var onChange = function onChange2(e2) {
    var value2 = e2.target.value;
    if (value2 == "") value2 = void 0;
    else value2 = moment$3(new Date(value2)).format(valueFormat);
    setValue4(value2);
  };
  var dtValue = value;
  if (!value) dtValue = "";
  else dtValue = moment$3(value).format("YYYY-MM-DDTHH:mm");
  return /* @__PURE__ */ React.createElement("input", _extends$h({
    type: "datetime-local",
    value: dtValue,
    disabled: readonly,
    onChange
  }, customProps));
};
var mapListValues$4 = Utils$1.ListUtils.mapListValues;
const VanillaMultiSelect = function(_ref) {
  var listValues2 = _ref.listValues, value = _ref.value, setValue4 = _ref.setValue;
  _ref.allowCustomValues;
  var readonly = _ref.readonly, customProps = _ref.customProps;
  var renderOptions = function renderOptions2() {
    return mapListValues$4(listValues2, function(_ref2) {
      var title2 = _ref2.title, value2 = _ref2.value;
      return /* @__PURE__ */ React.createElement("option", {
        key: value2,
        value: value2
      }, title2);
    });
  };
  var getMultiSelectValues = function getMultiSelectValues2(multiselect) {
    var values2 = [];
    var options = multiselect.options;
    for (var i2 = 0; i2 < options.length; i2++) {
      var opt = options[i2];
      if (opt.selected) {
        values2.push(opt.value);
      }
    }
    if (!values2.length) values2 = void 0;
    return values2;
  };
  var onChange = function onChange2(e2) {
    return setValue4(getMultiSelectValues(e2.target));
  };
  return /* @__PURE__ */ React.createElement("select", _extends$h({
    multiple: true,
    onChange,
    value,
    disabled: readonly
  }, omit$1(customProps, ["showSearch", "input", "showCheckboxes"])), renderOptions());
};
var mapListValues$3 = Utils$1.ListUtils.mapListValues;
const VanillaSelect = function(_ref) {
  var listValues2 = _ref.listValues, value = _ref.value, setValue4 = _ref.setValue;
  _ref.allowCustomValues;
  var readonly = _ref.readonly, customProps = _ref.customProps;
  var renderOptions = function renderOptions2() {
    return mapListValues$3(listValues2, function(_ref2) {
      var title2 = _ref2.title, value2 = _ref2.value;
      return /* @__PURE__ */ React.createElement("option", {
        key: value2,
        value: value2
      }, title2);
    });
  };
  var onChange = function onChange2(e2) {
    return setValue4(e2.target.value);
  };
  var hasValue = value != null;
  return /* @__PURE__ */ React.createElement("select", _extends$h({
    onChange,
    value: hasValue ? value : "",
    disabled: readonly
  }, omit$1(customProps, ["showSearch", "input"])), !hasValue && /* @__PURE__ */ React.createElement("option", {
    disabled: true,
    value: ""
  }), renderOptions());
};
const VanillaNumber = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var readonly = props.readonly, min3 = props.min, max3 = props.max, step = props.step, placeholder2 = props.placeholder, customProps = props.customProps;
  var onChange = function onChange2(e2) {
    var val = e2.target.value;
    if (val === "" || val === null) val = void 0;
    else val = Number(val);
    setValue4(val);
  };
  var numberValue = value == void 0 ? "" : value;
  return /* @__PURE__ */ React.createElement("input", _extends$h({
    type: "number",
    value: numberValue,
    placeholder: placeholder2,
    disabled: readonly,
    min: min3,
    max: max3,
    step,
    onChange
  }, customProps));
};
const VanillaSlider = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var readonly = props.readonly, min3 = props.min, max3 = props.max, step = props.step, placeholder2 = props.placeholder, _props$customProps = props.customProps, customProps = _props$customProps === void 0 ? {} : _props$customProps;
  var customInputProps = customProps.input || {};
  var customSliderProps = customProps.slider || customProps;
  var onChange = function onChange2(e2) {
    var val = e2.target.value;
    if (val === "" || val === null) val = void 0;
    else val = Number(val);
    setValue4(val);
  };
  var numberValue = value == void 0 ? "" : value;
  return /* @__PURE__ */ React.createElement("div", {
    style: {
      display: "inline-flex"
    }
  }, /* @__PURE__ */ React.createElement("input", _extends$h({
    key: "number",
    type: "number",
    value: numberValue,
    placeholder: placeholder2,
    disabled: readonly,
    min: min3,
    max: max3,
    step,
    onChange
  }, customInputProps)), /* @__PURE__ */ React.createElement("input", _extends$h({
    key: "range",
    type: "range",
    value: numberValue,
    disabled: readonly,
    min: min3,
    max: max3,
    step,
    onChange
  }, customSliderProps)));
};
const VanillaFieldSelect = function(_ref) {
  var items = _ref.items, setField4 = _ref.setField, selectedKey = _ref.selectedKey, readonly = _ref.readonly, errorText = _ref.errorText;
  var renderOptions = function renderOptions2(fields) {
    return fields.map(function(field) {
      var items2 = field.items, path = field.path, label2 = field.label, disabled = field.disabled, matchesType = field.matchesType;
      if (items2) {
        return /* @__PURE__ */ React.createElement("optgroup", {
          disabled,
          key: path,
          label: label2
        }, renderOptions2(items2));
      } else {
        var style = matchesType ? {
          fontWeight: "bold"
        } : {};
        return /* @__PURE__ */ React.createElement("option", {
          disabled,
          key: path,
          value: path,
          style
        }, label2);
      }
    });
  };
  var onChange = function onChange2(e2) {
    return setField4(e2.target.value);
  };
  var hasValue = selectedKey != null;
  return /* @__PURE__ */ React.createElement("select", {
    onChange,
    value: hasValue ? selectedKey : "",
    disabled: readonly,
    style: {
      color: errorText ? "red" : null
    }
  }, !hasValue && /* @__PURE__ */ React.createElement("option", {
    disabled: true,
    value: ""
  }), renderOptions(items));
};
const VanillaConjs = function(_ref) {
  var id2 = _ref.id, not2 = _ref.not, setNot4 = _ref.setNot, conjunctionOptions = _ref.conjunctionOptions, setConjunction4 = _ref.setConjunction, disabled = _ref.disabled, readonly = _ref.readonly, config2 = _ref.config, showNot = _ref.showNot, notLabel = _ref.notLabel;
  var conjsCount = Object.keys(conjunctionOptions).length;
  var lessThenTwo = disabled;
  var forceShowConj = config2.settings.forceShowConj;
  var showConj = forceShowConj || conjsCount > 1 && !lessThenTwo;
  var renderOptions = function renderOptions2() {
    return Object.keys(conjunctionOptions).map(function(key) {
      var _conjunctionOptions$k = conjunctionOptions[key], id3 = _conjunctionOptions$k.id, name2 = _conjunctionOptions$k.name, label2 = _conjunctionOptions$k.label, checked = _conjunctionOptions$k.checked;
      var postfix = setConjunction4.isDummyFn ? "__dummy" : "";
      if ((readonly || disabled) && !checked) return null;
      return [/* @__PURE__ */ React.createElement("input", {
        key: id3 + postfix,
        type: "radio",
        id: id3 + postfix,
        name: name2 + postfix,
        checked,
        disabled: readonly || disabled,
        value: key,
        onChange
      }), /* @__PURE__ */ React.createElement("label", {
        key: id3 + postfix + "label",
        htmlFor: id3 + postfix
      }, label2)];
    });
  };
  var renderNot = function renderNot2() {
    var postfix = "not";
    return [/* @__PURE__ */ React.createElement("input", {
      key: id2 + postfix,
      type: "checkbox",
      id: id2 + postfix,
      checked: not2,
      disabled: readonly,
      onChange: onNotChange
    }), /* @__PURE__ */ React.createElement("label", {
      key: id2 + postfix + "label",
      htmlFor: id2 + postfix
    }, notLabel || "NOT")];
  };
  var onChange = function onChange2(e2) {
    return setConjunction4(e2.target.value);
  };
  var onNotChange = function onNotChange2(e2) {
    return setNot4(e2.target.checked);
  };
  return [showNot && renderNot(), showConj && renderOptions()];
};
var typeToLabel = {
  "addRuleGroup": "+",
  "addRuleGroupExt": "+",
  "delGroup": "x",
  "delRuleGroup": "x",
  "delRule": "x"
};
const VanillaButton = function(_ref) {
  var type2 = _ref.type, label2 = _ref.label, onClick = _ref.onClick, readonly = _ref.readonly;
  var btnLabel = label2 || typeToLabel[type2];
  return /* @__PURE__ */ React.createElement("button", {
    onClick,
    type: "button",
    disabled: readonly
  }, btnLabel);
};
const VanillaIcon = function(_ref) {
  var type2 = _ref.type;
  var typeToIcon2 = {};
  var icon = typeToIcon2[type2] || null;
  if (!icon && type2 === "drag") {
    icon = /* @__PURE__ */ React.createElement(DragIcon$1, null);
  }
  return icon;
};
const VanillaButtonGroup = function(_ref) {
  var children = _ref.children;
  _ref.config;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
};
const VanillaValueSources = function(_ref) {
  _ref.config;
  var valueSources = _ref.valueSources, valueSrc = _ref.valueSrc;
  _ref.title;
  var setValueSrc4 = _ref.setValueSrc, readonly = _ref.readonly;
  var renderOptions = function renderOptions2(valueSources2) {
    return valueSources2.map(function(_ref2) {
      var _ref3 = _slicedToArray$1(_ref2, 2), srcKey = _ref3[0], info = _ref3[1];
      return /* @__PURE__ */ React.createElement("option", {
        key: srcKey,
        value: srcKey
      }, info.label);
    });
  };
  var onChange = function onChange2(e2) {
    return setValueSrc4(e2.target.value);
  };
  return /* @__PURE__ */ React.createElement("select", {
    onChange,
    value: valueSrc || "",
    disabled: readonly
  }, renderOptions(valueSources));
};
const VanillaSwitch = function(_ref) {
  var value = _ref.value, setValue4 = _ref.setValue, label2 = _ref.label, id2 = _ref.id;
  _ref.config;
  var type2 = _ref.type;
  var onChange = function onChange2(e2) {
    return setValue4(e2.target.checked);
  };
  var postfix = type2;
  return [/* @__PURE__ */ React.createElement("input", {
    key: id2 + postfix,
    type: "checkbox",
    id: id2 + postfix,
    checked: !!value,
    onChange
  }), /* @__PURE__ */ React.createElement("label", {
    key: id2 + postfix + "label",
    htmlFor: id2 + postfix
  }, label2)];
};
const vanillaConfirm = function(_ref) {
  var onOk = _ref.onOk;
  _ref.okText;
  _ref.cancelText;
  var title2 = _ref.title;
  if (confirm(title2)) {
    onOk();
  }
};
var VanillaProvider = function VanillaProvider2(_ref) {
  _ref.config;
  var children = _ref.children;
  return children;
};
const Widgets = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FuncWidget,
  ValueFieldWidget: ValueField,
  VanillaBooleanWidget: VanillaBoolean,
  VanillaButton,
  VanillaButtonGroup,
  VanillaConjs,
  VanillaDateTimeWidget: VanillaDateTime,
  VanillaDateWidget: VanillaDate,
  VanillaFieldSelect,
  VanillaIcon,
  VanillaMultiSelectWidget: VanillaMultiSelect,
  VanillaNumberWidget: VanillaNumber,
  VanillaProvider,
  VanillaSelectWidget: VanillaSelect,
  VanillaSliderWidget: VanillaSlider,
  VanillaSwitch,
  VanillaTextAreaWidget: VanillaTextArea,
  VanillaTextWidget: VanillaText,
  VanillaTimeWidget: VanillaTime,
  VanillaValueSources,
  vanillaConfirm
}, Symbol.toStringTag, { value: "Module" }));
function _callSuper(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$b(t2, _isNativeReflectConstruct() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _isNativeReflectConstruct() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
var Proximity = /* @__PURE__ */ function(_PureComponent) {
  function Proximity2() {
    var _this;
    _classCallCheck$b(this, Proximity2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, Proximity2, [].concat(args));
    _this.handleChange = function(value) {
      _this.props.setOption("proximity", parseInt(value));
    };
    return _this;
  }
  _inherits$b(Proximity2, _PureComponent);
  return _createClass$9(Proximity2, [{
    key: "render",
    value: function render3() {
      var _this$props = this.props, defaults2 = _this$props.defaults, options = _this$props.options, config2 = _this$props.config, optionLabel = _this$props.optionLabel, optionPlaceholder = _this$props.optionPlaceholder, customProps = _this$props.customProps, minProximity = _this$props.minProximity, maxProximity = _this$props.maxProximity, optionTextBefore = _this$props.optionTextBefore, readonly = _this$props.readonly;
      var settings2 = config2.settings, widgets2 = config2.widgets, ctx2 = config2.ctx;
      var defaultProximity = defaults2 ? defaults2.proximity : void 0;
      var showLabels = settings2.showLabels;
      var selectedProximity = options.get("proximity", defaultProximity);
      var proxValues = range$1(minProximity, maxProximity + 1).map(function(item) {
        return {
          title: item,
          value: item
        };
      });
      var factory26 = widgets2.select.factory;
      var Select2 = function Select3(props) {
        return factory26(props, ctx2);
      };
      return /* @__PURE__ */ React.createElement("div", {
        className: "operator--PROXIMITY"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "operator--options"
      }, showLabels && /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, optionLabel), !showLabels && optionTextBefore && /* @__PURE__ */ React.createElement("div", {
        className: "operator--options--sep"
      }, /* @__PURE__ */ React.createElement("span", null, optionTextBefore)), /* @__PURE__ */ React.createElement(Select2, _extends$h({
        config: config2,
        value: selectedProximity,
        listValues: proxValues,
        setValue: this.handleChange,
        readonly,
        placeholder: optionPlaceholder
      }, customProps))), /* @__PURE__ */ React.createElement("div", {
        className: "operator--widgets"
      }, this.props.children));
    }
  }]);
}(reactExports.PureComponent);
Proximity.propTypes = {
  config: PropTypes.object.isRequired,
  setOption: PropTypes.func.isRequired,
  options: PropTypes.any.isRequired,
  //instanceOf(Immutable.Map)
  minProximity: PropTypes.number,
  maxProximity: PropTypes.number,
  optionPlaceholder: PropTypes.string,
  optionTextBefore: PropTypes.string,
  optionLabel: PropTypes.string,
  customProps: PropTypes.object,
  readonly: PropTypes.bool
  //children
};
Proximity.defaultProps = {
  customProps: {},
  minProximity: 2,
  maxProximity: 10,
  optionPlaceholder: "Select words between",
  optionLabel: "Words between",
  optionTextBefore: null
};
const CustomOperators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ProximityOperator: Proximity
}, Symbol.toStringTag, { value: "Module" }));
function ownKeys$5(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$5(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$5(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$5(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var conjunctions$1 = _objectSpread$5({}, CoreConfig.conjunctions);
var operators$1 = _objectSpread$5(_objectSpread$5({}, CoreConfig.operators), {}, {
  proximity: _objectSpread$5(_objectSpread$5({}, CoreConfig.operators.proximity), {}, {
    options: _objectSpread$5(_objectSpread$5({}, CoreConfig.operators.proximity.options), {}, {
      factory: function factory(props, _ref) {
        var RCE2 = _ref.RCE, ProximityOperator = _ref.O.ProximityOperator;
        return RCE2(ProximityOperator, props);
      }
    })
  })
});
var widgets$2 = {
  text: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.text), {}, {
    factory: function factory2(props, _ref2) {
      var RCE2 = _ref2.RCE, VanillaTextWidget = _ref2.W.VanillaTextWidget;
      return RCE2(VanillaTextWidget, props);
    }
  }),
  textarea: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.textarea), {}, {
    factory: function factory3(props, _ref3) {
      var RCE2 = _ref3.RCE, VanillaTextAreaWidget = _ref3.W.VanillaTextAreaWidget;
      return RCE2(VanillaTextAreaWidget, props);
    }
  }),
  number: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.number), {}, {
    factory: function factory4(props, _ref4) {
      var RCE2 = _ref4.RCE, VanillaNumberWidget = _ref4.W.VanillaNumberWidget;
      return RCE2(VanillaNumberWidget, props);
    }
  }),
  slider: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.slider), {}, {
    factory: function factory5(props, _ref5) {
      var RCE2 = _ref5.RCE, VanillaSliderWidget = _ref5.W.VanillaSliderWidget;
      return RCE2(VanillaSliderWidget, props);
    }
  }),
  select: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.select), {}, {
    factory: function factory6(props, _ref6) {
      var RCE2 = _ref6.RCE, VanillaSelectWidget = _ref6.W.VanillaSelectWidget;
      return RCE2(VanillaSelectWidget, props);
    }
  }),
  multiselect: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.multiselect), {}, {
    factory: function factory7(props, _ref7) {
      var RCE2 = _ref7.RCE, VanillaMultiSelectWidget = _ref7.W.VanillaMultiSelectWidget;
      return RCE2(VanillaMultiSelectWidget, props);
    }
  }),
  date: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.date), {}, {
    factory: function factory8(props, _ref8) {
      var RCE2 = _ref8.RCE, VanillaDateWidget = _ref8.W.VanillaDateWidget;
      return RCE2(VanillaDateWidget, props);
    }
  }),
  time: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.time), {}, {
    factory: function factory9(props, _ref9) {
      var RCE2 = _ref9.RCE, VanillaTimeWidget = _ref9.W.VanillaTimeWidget;
      return RCE2(VanillaTimeWidget, props);
    }
  }),
  datetime: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.datetime), {}, {
    factory: function factory10(props, _ref10) {
      var RCE2 = _ref10.RCE, VanillaDateTimeWidget = _ref10.W.VanillaDateTimeWidget;
      return RCE2(VanillaDateTimeWidget, props);
    }
  }),
  "boolean": _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets["boolean"]), {}, {
    factory: function factory11(props, _ref11) {
      var RCE2 = _ref11.RCE, VanillaBooleanWidget = _ref11.W.VanillaBooleanWidget;
      return RCE2(VanillaBooleanWidget, props);
    }
  }),
  field: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.field), {}, {
    factory: function factory12(props, _ref12) {
      var RCE2 = _ref12.RCE, ValueFieldWidget = _ref12.W.ValueFieldWidget;
      return RCE2(ValueFieldWidget, props);
    },
    customProps: {
      showSearch: true
    }
  }),
  func: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.func), {}, {
    factory: function factory13(props, _ref13) {
      var RCE2 = _ref13.RCE, FuncWidget2 = _ref13.W.FuncWidget;
      return RCE2(FuncWidget2, props);
    },
    customProps: {
      //showSearch: true
    }
  }),
  /**
   * @deprecated
   */
  case_value: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.case_value), {}, {
    // simple text value
    factory: function factory14(props, _ref14) {
      var RCE2 = _ref14.RCE, VanillaTextWidget = _ref14.W.VanillaTextWidget;
      return RCE2(VanillaTextWidget, props);
    }
  })
};
var types$2 = _objectSpread$5(_objectSpread$5({}, CoreConfig.types), {}, {
  select: _objectSpread$5(_objectSpread$5({}, CoreConfig.types.select), {}, {
    widgets: _objectSpread$5(_objectSpread$5({}, CoreConfig.types.select.widgets), {}, {
      select: _objectSpread$5(_objectSpread$5({}, CoreConfig.types.select.widgets.select), {}, {
        widgetProps: {
          customProps: {
            showSearch: true
          }
        }
      })
    })
  })
});
var settings$2 = _objectSpread$5(_objectSpread$5({}, CoreConfig.settings), {}, {
  renderField: function renderField(props, _ref15) {
    var RCE2 = _ref15.RCE, VanillaFieldSelect2 = _ref15.W.VanillaFieldSelect;
    return RCE2(VanillaFieldSelect2, props);
  },
  renderOperator: function renderOperator(props, _ref16) {
    var RCE2 = _ref16.RCE, VanillaFieldSelect2 = _ref16.W.VanillaFieldSelect;
    return RCE2(VanillaFieldSelect2, props);
  },
  renderFunc: function renderFunc(props, _ref17) {
    var RCE2 = _ref17.RCE, VanillaFieldSelect2 = _ref17.W.VanillaFieldSelect;
    return RCE2(VanillaFieldSelect2, props);
  },
  renderConjs: function renderConjs(props, _ref18) {
    var RCE2 = _ref18.RCE, VanillaConjs2 = _ref18.W.VanillaConjs;
    return RCE2(VanillaConjs2, props);
  },
  renderSwitch: function renderSwitch(props, _ref19) {
    var RCE2 = _ref19.RCE, VanillaSwitch2 = _ref19.W.VanillaSwitch;
    return RCE2(VanillaSwitch2, props);
  },
  renderButton: function renderButton(props, _ref20) {
    var RCE2 = _ref20.RCE, VanillaButton2 = _ref20.W.VanillaButton;
    return RCE2(VanillaButton2, props);
  },
  renderIcon: function renderIcon(props, _ref21) {
    var RCE2 = _ref21.RCE, VanillaIcon2 = _ref21.W.VanillaIcon;
    return RCE2(VanillaIcon2, props);
  },
  renderButtonGroup: function renderButtonGroup(props, _ref22) {
    var RCE2 = _ref22.RCE, VanillaButtonGroup2 = _ref22.W.VanillaButtonGroup;
    return RCE2(VanillaButtonGroup2, props);
  },
  renderProvider: function renderProvider(props, _ref23) {
    var RCE2 = _ref23.RCE, VanillaProvider3 = _ref23.W.VanillaProvider;
    return RCE2(VanillaProvider3, props);
  },
  renderValueSources: function renderValueSources(props, _ref24) {
    var RCE2 = _ref24.RCE, VanillaValueSources2 = _ref24.W.VanillaValueSources;
    return RCE2(VanillaValueSources2, props);
  },
  renderFieldSources: function renderFieldSources(props, _ref25) {
    var RCE2 = _ref25.RCE, VanillaValueSources2 = _ref25.W.VanillaValueSources;
    return RCE2(VanillaValueSources2, props);
  },
  renderConfirm: function renderConfirm(props, _ref26) {
    var vanillaConfirm2 = _ref26.W.vanillaConfirm;
    return vanillaConfirm2(props);
  },
  renderSwitchPrefix: "IF",
  renderBeforeCaseValue: function renderBeforeCaseValue(props, _ref27) {
    var RCE2 = _ref27.RCE;
    return RCE2("span", {
      children: [" then "]
    });
  },
  customFieldSelectProps: {
    showSearch: true
  },
  customOperatorSelectProps: {
    // showSearch: false
  },
  defaultSliderWidth: "200px",
  defaultSelectWidth: "200px",
  defaultSearchWidth: "100px",
  defaultMaxRows: 5,
  renderSize: "small",
  maxLabelsLength: 100,
  showLock: false,
  showNot: true,
  forceShowConj: false,
  groupActionsPosition: "topRight"
  // oneOf [topLeft, topCenter, topRight, bottomLeft, bottomCenter, bottomRight]
});
var ctx$1 = _objectSpread$5(_objectSpread$5({}, CoreConfig.ctx), {}, {
  W: _objectSpread$5({}, Widgets),
  O: _objectSpread$5({}, CustomOperators),
  RCE: function RCE(C, P) {
    return /* @__PURE__ */ React.createElement(C, P);
  }
});
var config$2 = {
  conjunctions: conjunctions$1,
  operators: operators$1,
  widgets: widgets$2,
  types: types$2,
  settings: settings$2,
  ctx: ctx$1
};
config$2 = Utils$1.ConfigMixins.removeMixins(config$2, ["rangeslider", "treeselect", "treemultiselect"]);
const BasicConfig = config$2;
var root$1 = _root;
var now$2 = function() {
  return root$1.Date.now();
};
var now_1 = now$2;
var isObject$1 = isObject_1, now$1 = now_1, toNumber$1 = toNumber_1;
var FUNC_ERROR_TEXT$3 = "Expected a function";
var nativeMax$2 = Math.max, nativeMin$1 = Math.min;
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$3);
  }
  wait = toNumber$1(wait) || 0;
  if (isObject$1(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$2(toNumber$1(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$1());
  }
  function debounced() {
    var time = now$1(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$1;
const debounce$2 = /* @__PURE__ */ getDefaultExportFromCjs(debounce_1);
function ownKeys$4(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$4(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$4(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$4(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var _Utils$Autocomplete = Utils$1.Autocomplete, mergeListValues2 = _Utils$Autocomplete.mergeListValues, listValueToOption2 = _Utils$Autocomplete.listValueToOption, optionToListValue2 = _Utils$Autocomplete.optionToListValue, optionsToListValues2 = _Utils$Autocomplete.optionsToListValues, fixListValuesGroupOrder2 = _Utils$Autocomplete.fixListValuesGroupOrder;
var _Utils$ListUtils = Utils$1.ListUtils, mapListValues$2 = _Utils$ListUtils.mapListValues, listValuesToArray2 = _Utils$ListUtils.listValuesToArray, getListValue2 = _Utils$ListUtils.getListValue, makeCustomListValue2 = _Utils$ListUtils.makeCustomListValue, searchListValue2 = _Utils$ListUtils.searchListValue;
_Utils$ListUtils.getItemInListValues;
function sleep(delay) {
  return new Promise(function(resolve) {
    setTimeout(resolve, delay);
  });
}
var useListValuesAutocomplete$1 = function useListValuesAutocomplete(_ref, _ref2) {
  var asyncFetch = _ref.asyncFetch, useLoadMore = _ref.useLoadMore, useAsyncSearch = _ref.useAsyncSearch, forceAsyncSearch = _ref.forceAsyncSearch, selectedAsyncListValues = _ref.asyncListValues, staticListValues = _ref.listValues, allowCustomValues = _ref.allowCustomValues, selectedValue = _ref.value, setValue4 = _ref.setValue, placeholder2 = _ref.placeholder, config2 = _ref.config;
  var debounceTimeout = _ref2.debounceTimeout, multiple = _ref2.multiple, uif = _ref2.uif, isFieldAutocomplete = _ref2.isFieldAutocomplete;
  var knownSpecialValues = ["LOAD_MORE", "LOADING_MORE"];
  var loadMoreTitle = "Load more...";
  var loadingMoreTitle = "Loading more...";
  var aPlaceholder = forceAsyncSearch ? "Type to search" : placeholder2;
  var _React$useState = React.useState(false), _React$useState2 = _slicedToArray$1(_React$useState, 2), open = _React$useState2[0], setOpen = _React$useState2[1];
  var _React$useState3 = React.useState(void 0), _React$useState4 = _slicedToArray$1(_React$useState3, 2), asyncFetchMeta = _React$useState4[0], setAsyncFetchMeta = _React$useState4[1];
  var _React$useState5 = React.useState(0), _React$useState6 = _slicedToArray$1(_React$useState5, 2), loadingCnt = _React$useState6[0], setLoadingCnt = _React$useState6[1];
  var _React$useState7 = React.useState(false), _React$useState8 = _slicedToArray$1(_React$useState7, 2), isLoadingMore = _React$useState8[0], setIsLoadingMore = _React$useState8[1];
  var _React$useState9 = React.useState(""), _React$useState10 = _slicedToArray$1(_React$useState9, 2), inputValue2 = _React$useState10[0], setInputValue = _React$useState10[1];
  var _React$useState11 = React.useState(void 0), _React$useState12 = _slicedToArray$1(_React$useState11, 2), asyncListValues = _React$useState12[0], setAsyncListValues = _React$useState12[1];
  var asyncFectchCnt = React.useRef(0);
  var componentIsMounted = React.useRef(0);
  var isSelectedLoadMore = React.useRef(false);
  var nSelectedAsyncListValues = React.useMemo(function() {
    return listValuesToArray2(selectedAsyncListValues);
  }, [selectedAsyncListValues]);
  var listValues2 = React.useMemo(function() {
    return asyncFetch ? selectedAsyncListValues ? mergeListValues2(asyncListValues, nSelectedAsyncListValues, true) : asyncListValues : listValuesToArray2(staticListValues);
  }, [asyncFetch, selectedAsyncListValues, asyncListValues, staticListValues]);
  var listValuesToDisplay = asyncFetch ? asyncListValues : listValuesToArray2(staticListValues);
  if (allowCustomValues && inputValue2 && !searchListValue2(inputValue2, asyncListValues)) {
    listValuesToDisplay = mergeListValues2(listValuesToDisplay, [makeCustomListValue2(inputValue2)], true);
  }
  if (asyncFetch && !asyncListValues && selectedAsyncListValues && !inputValue2 && !open && uif === "antd") {
    listValuesToDisplay = listValues2;
  }
  if (asyncFetch && !allowCustomValues && selectedAsyncListValues && uif === "mui") {
    listValuesToDisplay = mergeListValues2(listValuesToDisplay, nSelectedAsyncListValues, true, true);
  }
  var isLoading = loadingCnt > 0;
  var canInitialLoad = open && asyncFetch && asyncListValues === void 0 && (forceAsyncSearch ? inputValue2 : true);
  var isInitialLoading = canInitialLoad && isLoading;
  var canLoadMore = !isInitialLoading && listValues2 && listValues2.length > 0 && asyncFetchMeta && asyncFetchMeta.hasMore && (asyncFetchMeta.filter || "") === inputValue2;
  var canShowLoadMore = !isLoading && canLoadMore;
  var options = mapListValues$2(listValuesToDisplay, listValueToOption2);
  var hasValue = selectedValue != null;
  var selectedListValue = !multiple && hasValue ? getListValue2(selectedValue, listValues2) : null;
  var fetchListValues = /* @__PURE__ */ function() {
    var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee() {
      var filter4, isLoadMore, offset2, meta, newAsyncFetchCnt, res, isFetchCancelled, _ref4, values2, hasMore, newMeta, nValues, assumeHasMore, newValues, realNewMeta, _args = arguments;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            filter4 = _args.length > 0 && _args[0] !== void 0 ? _args[0] : null;
            isLoadMore = _args.length > 1 && _args[1] !== void 0 ? _args[1] : false;
            if (!isLoadMore && asyncFetchMeta) {
              setAsyncFetchMeta(void 0);
            }
            offset2 = isLoadMore && asyncListValues ? asyncListValues.length : 0;
            meta = isLoadMore && asyncFetchMeta || !useLoadMore && {
              pageSize: 0
            };
            newAsyncFetchCnt = ++asyncFectchCnt.current;
            _context.next = 8;
            return asyncFetch.call(config2 === null || config2 === void 0 ? void 0 : config2.ctx, filter4, offset2, meta);
          case 8:
            res = _context.sent;
            isFetchCancelled = asyncFectchCnt.current != newAsyncFetchCnt;
            if (!(isFetchCancelled || !componentIsMounted.current)) {
              _context.next = 12;
              break;
            }
            return _context.abrupt("return", null);
          case 12:
            _ref4 = res !== null && res !== void 0 && res.values ? res : {
              values: res
            }, values2 = _ref4.values, hasMore = _ref4.hasMore, newMeta = _ref4.meta;
            nValues = listValuesToArray2(values2);
            if (isLoadMore) {
              newValues = mergeListValues2(asyncListValues, nValues, false);
              assumeHasMore = newValues.length > asyncListValues.length;
            } else {
              newValues = nValues;
              if (useLoadMore) {
                assumeHasMore = newValues.length > 0;
              }
            }
            realNewMeta = hasMore != null || newMeta != null || assumeHasMore != null ? _objectSpread$4(_objectSpread$4(_objectSpread$4(_objectSpread$4({}, assumeHasMore != null ? {
              hasMore: assumeHasMore
            } : {}), hasMore != null ? {
              hasMore
            } : {}), newMeta != null ? newMeta : {}), {}, {
              filter: filter4
            }) : void 0;
            if (realNewMeta) {
              setAsyncFetchMeta(realNewMeta);
            }
            return _context.abrupt("return", newValues);
          case 18:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function fetchListValues2() {
      return _ref3.apply(this, arguments);
    };
  }();
  var loadListValues = /* @__PURE__ */ function() {
    var _ref5 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee2() {
      var filter4, isLoadMore, list2, _args2 = arguments;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            filter4 = _args2.length > 0 && _args2[0] !== void 0 ? _args2[0] : null;
            isLoadMore = _args2.length > 1 && _args2[1] !== void 0 ? _args2[1] : false;
            setLoadingCnt(function(x) {
              return x + 1;
            });
            setIsLoadingMore(isLoadMore);
            _context2.next = 6;
            return fetchListValues(filter4, isLoadMore);
          case 6:
            list2 = _context2.sent;
            if (componentIsMounted.current) {
              _context2.next = 9;
              break;
            }
            return _context2.abrupt("return");
          case 9:
            if (list2 != null) {
              setAsyncListValues(list2);
            }
            setLoadingCnt(function(x) {
              return x - 1;
            });
            setIsLoadingMore(false);
          case 12:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function loadListValues2() {
      return _ref5.apply(this, arguments);
    };
  }();
  var loadListValuesDebounced = React.useCallback(debounce$2(loadListValues, debounceTimeout), []);
  React.useEffect(function() {
    componentIsMounted.current++;
    if (canInitialLoad && loadingCnt == 0 && asyncFectchCnt.current == 0) {
      _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee3() {
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return loadListValues();
            case 2:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }))();
    }
    return function() {
      componentIsMounted.current--;
    };
  }, [canInitialLoad]);
  var onOpen = function onOpen2() {
    setOpen(true);
  };
  var onClose = /* @__PURE__ */ function() {
    var _ref7 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee4(_e) {
      var isLoadMoreClick, resetValue;
      return _regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            isLoadMoreClick = isSelectedLoadMore.current;
            if (isLoadMoreClick) {
              isSelectedLoadMore.current = false;
              if (multiple) {
                setOpen(false);
              }
            } else {
              setOpen(false);
            }
            if (!(uif === "mui" && !isLoadMoreClick)) {
              _context4.next = 6;
              break;
            }
            resetValue = "";
            _context4.next = 6;
            return onInputChange(null, resetValue, "my-reset");
          case 6:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return function onClose2(_x) {
      return _ref7.apply(this, arguments);
    };
  }();
  var onDropdownVisibleChange = function onDropdownVisibleChange2(open2) {
    if (open2) {
      onOpen();
    } else {
      onClose();
    }
  };
  var isSpecialValue = function isSpecialValue2(option) {
    var specialValue = (option === null || option === void 0 ? void 0 : option.specialValue) || (option === null || option === void 0 ? void 0 : option.value);
    return knownSpecialValues.includes(specialValue);
  };
  var onChange = /* @__PURE__ */ function() {
    var _ref8 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee5(e2, val, option) {
      var _option2;
      var isClearingAll, isClearingInput, isClearingSingle, _option$value, _option, specialValue, shouldIgnore, isAddingCustomOptionFromSearch, _optionsToListValues, _optionsToListValues2, newSelectedValues, newSelectedListValues, _optionToListValue, _optionToListValue2, v, lvs;
      return _regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            isClearingAll = multiple && uif === "mui" && option === "clear";
            isClearingInput = !multiple && uif === "mui" && option === "clear" && (e2 === null || e2 === void 0 ? void 0 : e2.type) === "change";
            isClearingSingle = !multiple && uif === "mui" && option === "clear" && (e2 === null || e2 === void 0 ? void 0 : e2.type) !== "change";
            if (uif === "mui") {
              option = val;
              if (multiple) {
                val = option.map(function(o) {
                  var _o$value;
                  return (_o$value = o === null || o === void 0 ? void 0 : o.value) !== null && _o$value !== void 0 ? _o$value : o;
                });
              } else {
                val = (_option$value = (_option = option) === null || _option === void 0 ? void 0 : _option.value) !== null && _option$value !== void 0 ? _option$value : option;
              }
            }
            specialValue = multiple && Array.isArray(option) && option.map(function(opt) {
              return opt === null || opt === void 0 ? void 0 : opt.specialValue;
            }).find(function(v2) {
              return !!v2;
            }) || ((_option2 = option) === null || _option2 === void 0 ? void 0 : _option2.specialValue);
            if (multiple && val && !Array.isArray(val)) {
              val = [].concat(_toConsumableArray(selectedValue || []), [val]);
              option = null;
            }
            shouldIgnore = isClearingAll && val.length === 0 && inputValue2 && open || isClearingInput;
            if (!shouldIgnore) {
              _context5.next = 9;
              break;
            }
            return _context5.abrupt("return");
          case 9:
            isAddingCustomOptionFromSearch = multiple && val.length && val.length > (selectedValue || []).length && val[val.length - 1] == inputValue2 && !getListValue2(inputValue2, asyncListValues);
            if (!(specialValue == "LOAD_MORE")) {
              _context5.next = 17;
              break;
            }
            setInputValue(inputValue2);
            isSelectedLoadMore.current = true;
            _context5.next = 15;
            return loadListValues(inputValue2, true);
          case 15:
            _context5.next = 37;
            break;
          case 17:
            if (!(specialValue == "LOADING_MORE")) {
              _context5.next = 21;
              break;
            }
            isSelectedLoadMore.current = true;
            _context5.next = 37;
            break;
          case 21:
            if (!multiple) {
              _context5.next = 31;
              break;
            }
            _optionsToListValues = optionsToListValues2(val, listValues2, allowCustomValues), _optionsToListValues2 = _slicedToArray$1(_optionsToListValues, 2), newSelectedValues = _optionsToListValues2[0], newSelectedListValues = _optionsToListValues2[1];
            setValue4(newSelectedValues, asyncFetch ? newSelectedListValues : void 0);
            if (!isAddingCustomOptionFromSearch) {
              _context5.next = 29;
              break;
            }
            _context5.next = 27;
            return sleep(0);
          case 27:
            _context5.next = 29;
            return onInputChange(null, "", "my-reset");
          case 29:
            _context5.next = 37;
            break;
          case 31:
            _optionToListValue = optionToListValue2(val, listValues2, allowCustomValues), _optionToListValue2 = _slicedToArray$1(_optionToListValue, 2), v = _optionToListValue2[0], lvs = _optionToListValue2[1];
            setValue4(v, asyncFetch ? lvs : void 0);
            if (!(isClearingSingle && isFieldAutocomplete)) {
              _context5.next = 37;
              break;
            }
            _context5.next = 36;
            return sleep(0);
          case 36:
            setOpen(false);
          case 37:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    return function onChange2(_x2, _x3, _x4) {
      return _ref8.apply(this, arguments);
    };
  }();
  var onInputChange = /* @__PURE__ */ function() {
    var _ref9 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee6(e2, newInputValue, eventType) {
      var shouldIgnore, val, canSearchAsync;
      return _regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            shouldIgnore = uif === "mui" && eventType === "reset";
            val = newInputValue;
            if (!(val === loadMoreTitle || val === loadingMoreTitle || shouldIgnore)) {
              _context6.next = 4;
              break;
            }
            return _context6.abrupt("return");
          case 4:
            if (!(newInputValue != inputValue2)) {
              _context6.next = 13;
              break;
            }
            setInputValue(val);
            canSearchAsync = useAsyncSearch && (forceAsyncSearch ? !!val : true);
            if (!canSearchAsync) {
              _context6.next = 12;
              break;
            }
            _context6.next = 10;
            return loadListValuesDebounced(val);
          case 10:
            _context6.next = 13;
            break;
          case 12:
            if (useAsyncSearch && forceAsyncSearch) {
              setAsyncListValues([]);
            }
          case 13:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }));
    return function onInputChange2(_x5, _x6, _x7) {
      return _ref9.apply(this, arguments);
    };
  }();
  var extendOptions = function extendOptions2(options2) {
    var filtered = _toConsumableArray(options2);
    if (useLoadMore) {
      if (canShowLoadMore) {
        filtered.push({
          specialValue: "LOAD_MORE",
          title: loadMoreTitle
        });
      } else if (isLoadingMore) {
        filtered.push({
          specialValue: "LOADING_MORE",
          title: loadingMoreTitle,
          disabled: true
        });
      }
    }
    return filtered;
  };
  var getOptionSelected = function getOptionSelected2(option, valueOrOption) {
    if (valueOrOption == null) return null;
    var selectedValue2 = valueOrOption.value != void 0 ? valueOrOption.value : valueOrOption;
    return option.value === selectedValue2;
  };
  var getOptionDisabled = function getOptionDisabled2(valueOrOption) {
    return valueOrOption && valueOrOption.disabled;
  };
  var getOptionIsCustom = function getOptionIsCustom2(valueOrOption) {
    var _valueOrOption$value;
    if (valueOrOption !== null && valueOrOption !== void 0 && valueOrOption.isCustom) return true;
    var val = (_valueOrOption$value = valueOrOption === null || valueOrOption === void 0 ? void 0 : valueOrOption.value) !== null && _valueOrOption$value !== void 0 ? _valueOrOption$value : valueOrOption;
    var lv = getListValue2(val, listValues2);
    return (lv === null || lv === void 0 ? void 0 : lv.isCustom) || false;
  };
  var getOptionLabel = function getOptionLabel2(valueOrOption) {
    if (valueOrOption == null) return null;
    var option = valueOrOption.value != void 0 ? valueOrOption : listValueToOption2(getListValue2(valueOrOption, listValues2));
    if (!option && valueOrOption.specialValue) {
      return valueOrOption.title;
    }
    if (!option && allowCustomValues) {
      return valueOrOption.toString();
    }
    if (!option) {
      return valueOrOption.toString();
    }
    return option.title || option.label || option.value.toString();
  };
  var fixedOptions = uif === "mui" ? fixListValuesGroupOrder2(options) : options;
  return {
    options: fixedOptions,
    listValues: listValues2,
    hasValue,
    selectedListValue,
    open,
    onOpen,
    onClose,
    onDropdownVisibleChange,
    onChange,
    inputValue: inputValue2,
    onInputChange,
    canShowLoadMore,
    isInitialLoading,
    isLoading,
    isLoadingMore,
    isSpecialValue,
    extendOptions,
    getOptionSelected,
    getOptionDisabled,
    getOptionIsCustom,
    getOptionLabel,
    aPlaceholder
  };
};
function ownKeys$3(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$3(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$3(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$3(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
const Utils = _objectSpread$3(_objectSpread$3({}, Utils$1), {}, {
  ReactUtils,
  DragIcon: DragIcon$1
});
var _xdpPackage$version$s$3, _xdpPackage$version$3;
var moment$2 = Utils.moment;
var xdpVersion$3 = parseInt((_xdpPackage$version$s$3 = xdpPackage === null || xdpPackage === void 0 || (_xdpPackage$version$3 = xdpPackage.version) === null || _xdpPackage$version$3 === void 0 || (_xdpPackage$version$3 = _xdpPackage$version$3.split(".")) === null || _xdpPackage$version$3 === void 0 ? void 0 : _xdpPackage$version$3[0]) !== null && _xdpPackage$version$s$3 !== void 0 ? _xdpPackage$version$s$3 : "0");
const MuiDateWidget = function(props) {
  var value = props.value, setValue4 = props.setValue, readonly = props.readonly, customProps = props.customProps, dateFormat = props.dateFormat, valueFormat = props.valueFormat, placeholder2 = props.placeholder;
  var formatSingleValue = function formatSingleValue2(value2) {
    return value2 && value2.isValid() ? value2.format(valueFormat) : void 0;
  };
  var handleChange = function handleChange2(value2) {
    setValue4(formatSingleValue(value2));
  };
  var renderInput = function renderInput2(params) {
    return /* @__PURE__ */ React.createElement(TextField, _extends$h({
      size: "small",
      variant: "standard"
    }, params));
  };
  var desktopModeMediaQuery = "@media (pointer: fine), (pointer: none)";
  var pickerProps = xdpVersion$3 >= 6 ? {
    format: dateFormat,
    slotProps: {
      textField: {
        size: "small",
        variant: "standard"
      },
      toolbar: {
        toolbarPlaceholder: !readonly ? placeholder2 : ""
      }
    }
  } : {
    inputFormat: dateFormat,
    renderInput,
    toolbarPlaceholder: !readonly ? placeholder2 : ""
  };
  var aValue = value ? xdpVersion$3 >= 6 ? moment$2(value, valueFormat) : value : null;
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(DatePicker, _extends$h({
    desktopModeMediaQuery,
    readOnly: readonly,
    disabled: readonly,
    value: aValue,
    onChange: handleChange
  }, pickerProps, customProps)));
};
var _xdpPackage$version$s$2, _xdpPackage$version$2;
var moment$1 = Utils.moment;
var xdpVersion$2 = parseInt((_xdpPackage$version$s$2 = xdpPackage === null || xdpPackage === void 0 || (_xdpPackage$version$2 = xdpPackage.version) === null || _xdpPackage$version$2 === void 0 || (_xdpPackage$version$2 = _xdpPackage$version$2.split(".")) === null || _xdpPackage$version$2 === void 0 ? void 0 : _xdpPackage$version$2[0]) !== null && _xdpPackage$version$s$2 !== void 0 ? _xdpPackage$version$s$2 : "0");
const MuiDateTimeWidget = function(props) {
  var value = props.value, setValue4 = props.setValue, use12Hours = props.use12Hours, readonly = props.readonly, placeholder2 = props.placeholder, dateFormat = props.dateFormat, timeFormat = props.timeFormat, valueFormat = props.valueFormat, customProps = props.customProps;
  var formatSingleValue = function formatSingleValue2(value2) {
    return value2 && value2.isValid() ? value2.format(valueFormat) : void 0;
  };
  var handleChange = function handleChange2(value2) {
    setValue4(formatSingleValue(value2));
  };
  var dateTimeFormat = dateFormat + " " + timeFormat;
  var renderInput = function renderInput2(params) {
    return /* @__PURE__ */ React.createElement(TextField, _extends$h({
      size: "small",
      variant: "standard"
    }, params));
  };
  var desktopModeMediaQuery = "@media (pointer: fine), (pointer: none)";
  var pickerProps = xdpVersion$2 >= 6 ? {
    format: dateTimeFormat,
    slotProps: {
      textField: {
        size: "small",
        variant: "standard"
      },
      toolbar: {
        toolbarPlaceholder: !readonly ? placeholder2 : ""
      }
    }
  } : {
    inputFormat: dateTimeFormat,
    renderInput,
    toolbarPlaceholder: !readonly ? placeholder2 : ""
  };
  var aValue = value ? xdpVersion$2 >= 6 ? moment$1(value, valueFormat) : value : null;
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(DateTimePicker, _extends$h({
    desktopModeMediaQuery,
    readOnly: readonly,
    disabled: readonly,
    ampm: !!use12Hours,
    value: aValue,
    onChange: handleChange
  }, pickerProps, customProps)));
};
var _xdpPackage$version$s$1, _xdpPackage$version$1;
var moment = Utils.moment;
var xdpVersion$1 = parseInt((_xdpPackage$version$s$1 = xdpPackage === null || xdpPackage === void 0 || (_xdpPackage$version$1 = xdpPackage.version) === null || _xdpPackage$version$1 === void 0 || (_xdpPackage$version$1 = _xdpPackage$version$1.split(".")) === null || _xdpPackage$version$1 === void 0 ? void 0 : _xdpPackage$version$1[0]) !== null && _xdpPackage$version$s$1 !== void 0 ? _xdpPackage$version$s$1 : "0");
const MuiTimeWidget = function(props) {
  var value = props.value, setValue4 = props.setValue, use12Hours = props.use12Hours, readonly = props.readonly, placeholder2 = props.placeholder, timeFormat = props.timeFormat, valueFormat = props.valueFormat, customProps = props.customProps;
  var formatSingleValue = function formatSingleValue2(value2) {
    return value2 && value2.isValid() ? value2.format(valueFormat) : void 0;
  };
  var handleChange = function handleChange2(value2) {
    setValue4(formatSingleValue(value2));
  };
  var hasSeconds = timeFormat.indexOf(":ss") != -1;
  var timeValue = value ? moment(value, timeFormat) : null;
  var renderInput = function renderInput2(params) {
    return /* @__PURE__ */ React.createElement(TextField, _extends$h({
      size: "small",
      variant: "standard"
    }, params));
  };
  var desktopModeMediaQuery = "@media (pointer: fine), (pointer: none)";
  var pickerProps = xdpVersion$1 >= 6 ? {
    format: timeFormat,
    slotProps: {
      textField: {
        size: "small",
        variant: "standard"
      },
      toolbar: {
        toolbarPlaceholder: !readonly ? placeholder2 : ""
      }
    }
  } : {
    inputFormat: timeFormat,
    renderInput,
    toolbarPlaceholder: !readonly ? placeholder2 : ""
  };
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(TimePicker, _extends$h({
    desktopModeMediaQuery,
    readOnly: readonly,
    disabled: readonly,
    ampm: !!use12Hours,
    value: timeValue,
    onChange: handleChange,
    views: hasSeconds ? ["hours", "minutes", "seconds"] : ["hours", "minutes"]
  }, pickerProps, customProps)));
};
var mapListValues$1 = Utils.ListUtils.mapListValues;
const MuiSelectWidget = function(_ref) {
  var listValues2 = _ref.listValues, value = _ref.value, setValue4 = _ref.setValue;
  _ref.allowCustomValues;
  var readonly = _ref.readonly, placeholder2 = _ref.placeholder, customProps = _ref.customProps;
  var renderOptions = function renderOptions2() {
    return mapListValues$1(listValues2, function(_ref2) {
      var title2 = _ref2.title, value2 = _ref2.value;
      return /* @__PURE__ */ React.createElement(MenuItem, {
        key: value2,
        value: value2
      }, title2);
    });
  };
  var onChange = function onChange2(e2) {
    if (e2.target.value === void 0) return;
    setValue4(e2.target.value);
  };
  var renderValue = function renderValue2(selectedValue) {
    if (!readonly && selectedValue == null) return placeholder2;
    return getListValueTitle(selectedValue);
  };
  var getListValueTitle = function getListValueTitle2(selectedValue) {
    return mapListValues$1(listValues2, function(_ref3) {
      var title2 = _ref3.title, value2 = _ref3.value;
      return value2 === selectedValue ? title2 : null;
    }).filter(function(v) {
      return v !== null;
    }).shift();
  };
  var hasValue = value != null;
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(Select, _extends$h({
    variant: "standard",
    autoWidth: true,
    displayEmpty: true,
    placeholder: !readonly ? placeholder2 : "",
    onChange,
    value: hasValue ? value : "",
    disabled: readonly,
    readOnly: readonly,
    renderValue,
    size: "small"
  }, omit$1(customProps, ["showSearch", "input"])), renderOptions()));
};
const MuiNumberWidget = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var readonly = props.readonly, min3 = props.min, max3 = props.max, step = props.step, placeholder2 = props.placeholder, customProps = props.customProps;
  var onChange = function onChange2(e2) {
    var val = e2.target.value;
    if (val === "" || val === null) val = void 0;
    else val = Number(val);
    setValue4(val);
  };
  var numberValue = value == void 0 ? "" : value;
  var InputProps = reactExports.useMemo(function() {
    return {
      readOnly: readonly
    };
  }, [readonly]);
  var inputProps = reactExports.useMemo(function() {
    return {
      min: min3,
      max: max3,
      step
    };
  }, [min3, max3, step]);
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(TextField, _extends$h({
    variant: "standard",
    type: "number",
    value: numberValue,
    placeholder: !readonly ? placeholder2 : "",
    InputProps,
    inputProps,
    disabled: readonly,
    onChange,
    size: "small"
  }, customProps)));
};
var _excluded$3 = ["width"];
const MuiSliderWidget = function(props) {
  var config2 = props.config, placeholder2 = props.placeholder, customProps = props.customProps, value = props.value, setValue4 = props.setValue, min3 = props.min, max3 = props.max, step = props.step, marks = props.marks, readonly = props.readonly;
  var defaultSliderWidth = config2.settings.defaultSliderWidth;
  var handleSliderChange = reactExports.useCallback(function(_e, newValue) {
    setValue4(newValue);
  }, [setValue4]);
  var handleInputChange = reactExports.useCallback(function(e2) {
    var val = e2.target.value;
    if (val === "" || val === null) val = void 0;
    else val = Number(val);
    setValue4(val);
  }, [setValue4]);
  var handleInputBlur = reactExports.useCallback(function(e2) {
    var val = e2.target.value;
    if (val === "" || val === null) val = void 0;
    else val = Number(val);
    if (val < min3) {
      setValue4(min3);
    } else if (val > max3) {
      setValue4(max3);
    }
  }, [setValue4, min3, max3]);
  var _ref = customProps || {}, width = _ref.width, rest2 = _objectWithoutProperties$2(_ref, _excluded$3);
  var customInputProps = rest2.input || {};
  var customSliderProps = rest2.slider || rest2;
  var inputValue2 = typeof value === "number" ? value : "";
  var sliderValue = typeof value === "number" ? value : null;
  var muiMarks = reactExports.useMemo(function() {
    return marks ? Object.keys(marks).map(function(v) {
      return {
        value: Number(v),
        label: _typeof$3(marks[v]) === "object" || typeof marks[v] === "undefined" ? marks[v] : /* @__PURE__ */ React.createElement("p", null, marks[v])
      };
    }) : false;
  }, [marks]);
  var InputProps = reactExports.useMemo(function() {
    return {
      readOnly: readonly
    };
  }, [readonly]);
  var inputProps = reactExports.useMemo(function() {
    return {
      min: min3,
      max: max3,
      step
    };
  }, [min3, max3, step]);
  var InputCmp = /* @__PURE__ */ React.createElement(TextField, _extends$h({
    variant: "standard",
    type: "number",
    value: inputValue2,
    placeholder: placeholder2,
    InputProps,
    inputProps,
    disabled: readonly,
    onChange: handleInputChange,
    onBlur: handleInputBlur,
    size: "small"
  }, customInputProps));
  var SliderCmp = /* @__PURE__ */ React.createElement(Slider$1, _extends$h({
    value: sliderValue,
    onChange: handleSliderChange,
    disabled: readonly,
    min: min3,
    max: max3,
    step,
    marks: muiMarks,
    valueLabelDisplay: "auto",
    size: "small"
  }, customSliderProps));
  var stylesWrapper = {
    display: "inline-flex",
    alignItems: "center",
    flexWrap: "wrap"
  };
  var stylesInputWrapper = {
    marginLeft: "5px"
  };
  var stylesSliderWrapper = {
    marginLeft: "5px",
    paddingLeft: "12px",
    marginBottom: muiMarks && "-16px",
    width: width || defaultSliderWidth
  };
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement("div", {
    style: stylesWrapper
  }, /* @__PURE__ */ React.createElement("div", {
    style: stylesInputWrapper
  }, InputCmp), /* @__PURE__ */ React.createElement("div", {
    style: stylesSliderWrapper
  }, SliderCmp)));
};
var _excluded$2 = ["width"];
const MuiRangeWidget = function(props) {
  var config2 = props.config, placeholders = props.placeholders, customProps = props.customProps, value = props.value, setValue4 = props.setValue, min3 = props.min, max3 = props.max, step = props.step, marks = props.marks, readonly = props.readonly, textSeparators = props.textSeparators;
  var defaultSliderWidth = config2.settings.defaultSliderWidth;
  reactExports.useEffect(function() {
    var _ref = props.value || [void 0, void 0], _ref2 = _slicedToArray$1(_ref, 2), valueFrom2 = _ref2[0], valueTo2 = _ref2[1];
    if (props.value && (valueFrom2 == void 0 || valueTo2 == void 0)) ;
  }, []);
  var handleSliderChange = function handleSliderChange2(_e, newValues) {
    setValue4(newValues);
  };
  var handleInputChangeFrom = function handleInputChangeFrom2(e2) {
    var valueFrom2 = e2.target.value;
    if (valueFrom2 === "" || valueFrom2 == null) valueFrom2 = void 0;
    else valueFrom2 = Number(valueFrom2);
    var value2 = props.value ? _toConsumableArray(props.value) : [void 0, void 0];
    value2[0] = valueFrom2;
    setValue4(value2);
  };
  var handleInputChangeTo = function handleInputChangeTo2(e2) {
    var valueTo2 = e2.target.value;
    if (valueTo2 === "" || valueTo2 == null) valueTo2 = void 0;
    else valueTo2 = Number(valueTo2);
    var value2 = props.value ? _toConsumableArray(props.value) : [void 0, void 0];
    value2[1] = valueTo2;
    setValue4(value2);
  };
  var handleInputBlur = function handleInputBlur2() {
    if (!value) return;
    if (value[0] < min3) {
      setValue4([min3, value[1]]);
    } else if (value[1] > max3) {
      setValue4([value[0], max3]);
    }
  };
  var _ref3 = customProps || {}, width = _ref3.width, rest2 = _objectWithoutProperties$2(_ref3, _excluded$2);
  var customInputProps = rest2.input || {};
  var customSliderProps = rest2.slider || rest2;
  var muiMarks = marks ? Object.keys(marks).map(function(v) {
    return {
      value: Number(v),
      label: _typeof$3(marks[v]) === "object" || typeof marks[v] === "undefined" ? marks[v] : /* @__PURE__ */ React.createElement("p", null, marks[v])
    };
  }) : false;
  var sliderValue = value ? _toConsumableArray(value) : [void 0, void 0];
  var _sliderValue = _slicedToArray$1(sliderValue, 2), valueFrom = _sliderValue[0], valueTo = _sliderValue[1];
  if (valueFrom == void 0) {
    valueFrom = "";
    sliderValue[0] = 0;
  }
  if (valueTo == void 0) {
    valueTo = "";
    sliderValue[1] = 0;
  }
  var FromInputCmp = /* @__PURE__ */ React.createElement(TextField, _extends$h({
    variant: "standard",
    type: "number",
    value: valueFrom,
    placeholder: placeholders[0],
    InputProps: {
      readOnly: readonly
    },
    inputProps: {
      min: min3,
      max: max3,
      step
    },
    disabled: readonly,
    onChange: handleInputChangeFrom,
    onBlur: handleInputBlur,
    size: "small"
  }, customInputProps));
  var ToInputCmp = /* @__PURE__ */ React.createElement(TextField, _extends$h({
    variant: "standard",
    type: "number",
    value: valueTo,
    placeholder: placeholders[1],
    InputProps: {
      readOnly: readonly
    },
    inputProps: {
      min: min3,
      max: max3,
      step
    },
    disabled: readonly,
    onChange: handleInputChangeTo,
    onBlur: handleInputBlur,
    size: "small"
  }, customInputProps));
  var SliderCmp = /* @__PURE__ */ React.createElement(Slider$1, _extends$h({
    value: sliderValue,
    onChange: handleSliderChange,
    disabled: readonly,
    min: min3,
    max: max3,
    step,
    marks: muiMarks,
    valueLabelDisplay: "auto",
    size: "small"
  }, customSliderProps));
  var stylesWrapper = {
    display: "inline-flex",
    flexWrap: "wrap"
  };
  var stylesInputWrapper = {
    marginLeft: "5px"
  };
  var stylesSliderWrapper = {
    marginLeft: "5px",
    paddingLeft: "12px",
    marginBottom: muiMarks && "-16px",
    width: width || defaultSliderWidth
  };
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement("div", {
    style: stylesWrapper
  }, /* @__PURE__ */ React.createElement("div", {
    style: stylesInputWrapper
  }, FromInputCmp), /* @__PURE__ */ React.createElement("div", {
    className: "widget--sep"
  }, /* @__PURE__ */ React.createElement("span", null, textSeparators[1])), /* @__PURE__ */ React.createElement("div", {
    style: stylesInputWrapper
  }, ToInputCmp), /* @__PURE__ */ React.createElement("div", {
    style: stylesSliderWrapper
  }, SliderCmp)));
};
const MuiBooleanWidget = function(props) {
  var customProps = props.customProps, value = props.value, setValue4 = props.setValue, labelYes = props.labelYes, labelNo = props.labelNo, readonly = props.readonly;
  var onChange = function onChange2() {
    setValue4(!value);
  };
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(Typography, {
    component: "div"
  }, /* @__PURE__ */ React.createElement(Grid$1, {
    component: "label",
    container: true,
    alignItems: "center",
    spacing: 0
  }, /* @__PURE__ */ React.createElement(Grid$1, {
    item: true,
    component: "span"
  }, labelNo), /* @__PURE__ */ React.createElement(Grid$1, {
    item: true,
    component: "span"
  }, /* @__PURE__ */ React.createElement(Switch, _extends$h({
    checked: !!value,
    onChange,
    disabled: readonly
  }, customProps))), /* @__PURE__ */ React.createElement(Grid$1, {
    item: true,
    component: "span"
  }, labelYes))));
};
var mapListValues2 = Utils.ListUtils.mapListValues;
const MuiMultiSelectWidget = function(_ref) {
  var listValues2 = _ref.listValues, value = _ref.value, setValue4 = _ref.setValue;
  _ref.allowCustomValues;
  var readonly = _ref.readonly, placeholder2 = _ref.placeholder, customProps = _ref.customProps;
  var renderOptions = function renderOptions2(selectedValues) {
    return mapListValues2(listValues2, function(_ref2) {
      var title2 = _ref2.title, value2 = _ref2.value;
      return /* @__PURE__ */ React.createElement(MenuItem, {
        key: value2,
        value: value2
      }, /* @__PURE__ */ React.createElement(Checkbox, {
        checked: selectedValues.indexOf(value2) > -1
      }), /* @__PURE__ */ React.createElement(ListItemText, {
        primary: title2
      }));
    });
  };
  var renderValue = function renderValue2(selectedValues) {
    if (!readonly && !selectedValues.length) return placeholder2;
    var selectedTitles = mapListValues2(listValues2, function(_ref3) {
      var title2 = _ref3.title, value2 = _ref3.value;
      return selectedValues.indexOf(value2) > -1 ? title2 : null;
    }).filter(function(v) {
      return v !== null;
    });
    return selectedTitles.join(", ");
  };
  var hasValue = value != null && value.length > 0;
  var onChange = function onChange2(e2) {
    if (e2.target.value === void 0) return;
    setValue4(e2.target.value);
  };
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(Select, _extends$h({
    multiple: true,
    variant: "standard",
    autoWidth: true,
    displayEmpty: true,
    label: !readonly ? placeholder2 : "",
    onChange,
    value: hasValue ? value : [],
    disabled: readonly,
    readOnly: readonly,
    renderValue,
    size: "small"
  }, omit$1(customProps, ["showSearch", "input", "showCheckboxes"])), renderOptions(hasValue ? value : [])));
};
var Check = {};
var _interopRequireDefault$i = interopRequireDefaultExports;
Object.defineProperty(Check, "__esModule", {
  value: true
});
var default_1$a = Check.default = void 0;
var _createSvgIcon$a = _interopRequireDefault$i(requireCreateSvgIcon());
var _jsxRuntime$a = jsxRuntimeExports;
default_1$a = Check.default = (0, _createSvgIcon$a.default)(/* @__PURE__ */ (0, _jsxRuntime$a.jsx)("path", {
  d: "M9 16.17 4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"
}), "Check");
var _excluded$1 = ["width"];
function ownKeys$2(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$2(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$2(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var useListValuesAutocomplete2 = useListValuesAutocomplete$1;
var emptyArray = [];
const MuiAutocompleteWidget = function(props) {
  var allowCustomValues = props.allowCustomValues, multiple = props.multiple, disableClearable = props.disableClearable, selectedValue = props.value, customProps = props.customProps, readonly = props.readonly, config2 = props.config, filterOptionsConfig = props.filterOptionsConfig, errorText = props.errorText, tooltipText = props.tooltipText, isFieldAutocomplete = props.isFieldAutocomplete;
  var stringifyOption = reactExports.useCallback(function(option) {
    var keysForFilter = config2.settings.listKeysForSearch;
    var valueForFilter = keysForFilter.map(function(k) {
      return typeof option[k] == "string" ? option[k] : "";
    }).join("\0");
    return valueForFilter;
  }, [config2]);
  var defaultFilterOptionsConfig = {
    stringify: stringifyOption
  };
  var filterOptionsFn = createFilterOptions(filterOptionsConfig || defaultFilterOptionsConfig);
  var _useListValuesAutocom = useListValuesAutocomplete2(props, {
    debounceTimeout: 100,
    multiple,
    uif: "mui",
    isFieldAutocomplete
  }), open = _useListValuesAutocom.open, onOpen = _useListValuesAutocom.onOpen, onClose = _useListValuesAutocom.onClose, onChange = _useListValuesAutocom.onChange, onInputChange = _useListValuesAutocom.onInputChange, inputValue2 = _useListValuesAutocom.inputValue, options = _useListValuesAutocom.options, isInitialLoading = _useListValuesAutocom.isInitialLoading, isLoading = _useListValuesAutocom.isLoading, aPlaceholder = _useListValuesAutocom.aPlaceholder, extendOptions = _useListValuesAutocom.extendOptions, getOptionDisabled = _useListValuesAutocom.getOptionDisabled, getOptionIsCustom = _useListValuesAutocom.getOptionIsCustom, getOptionLabel = _useListValuesAutocom.getOptionLabel, selectedListValue = _useListValuesAutocom.selectedListValue;
  var _config$settings = config2.settings, defaultSelectWidth = _config$settings.defaultSelectWidth, defaultSearchWidth = _config$settings.defaultSearchWidth;
  var _ref = customProps || {}, width = _ref.width, rest2 = _objectWithoutProperties$2(_ref, _excluded$1);
  var customInputProps = rest2.input || {};
  customInputProps.width || defaultSearchWidth;
  customInputProps = omit$1(customInputProps, ["width"]);
  var customAutocompleteProps = omit$1(rest2, ["showSearch", "showCheckboxes"]);
  var fullWidth2 = false;
  var minWidth = width || defaultSelectWidth;
  var style = {
    width: multiple ? void 0 : minWidth,
    minWidth
  };
  var placeholder2 = !readonly ? aPlaceholder : "";
  var ariaLabel = placeholder2 || config2.settings.fieldPlaceholder;
  var hasValue = selectedValue != null;
  var value = hasValue ? selectedValue : multiple ? emptyArray : null;
  var filterOptions = function filterOptions2(options2, params) {
    var filtered = filterOptionsFn(options2, params);
    var extended = extendOptions(filtered);
    return extended;
  };
  var groupBy2 = function groupBy3(option) {
    return option !== null && option !== void 0 && option.group ? JSON.stringify(option.group) : option === null || option === void 0 ? void 0 : option.groupTitle;
  };
  var theme = useTheme();
  var renderInput = function renderInput2(params) {
    var _ref2, _selectedListValue$ti, _ref3;
    var shouldRenderSelected = !multiple && !open;
    var selectedTitle = (_ref2 = (_selectedListValue$ti = selectedListValue === null || selectedListValue === void 0 ? void 0 : selectedListValue.title) !== null && _selectedListValue$ti !== void 0 ? _selectedListValue$ti : value === null || value === void 0 ? void 0 : value.toString()) !== null && _ref2 !== void 0 ? _ref2 : "";
    var shouldHide = multiple && !open;
    var renderValue = shouldRenderSelected ? selectedTitle : shouldHide ? "" : (_ref3 = inputValue2 !== null && inputValue2 !== void 0 ? inputValue2 : value === null || value === void 0 ? void 0 : value.toString()) !== null && _ref3 !== void 0 ? _ref3 : "";
    return /* @__PURE__ */ React.createElement(TextField, _extends$h({
      variant: "standard"
    }, params, {
      inputProps: _objectSpread$2(_objectSpread$2({
        "aria-label": ariaLabel
      }, params.inputProps), {}, {
        value: renderValue
      }),
      InputProps: _objectSpread$2(_objectSpread$2({}, params.InputProps), {}, {
        readOnly: readonly,
        endAdornment: /* @__PURE__ */ React.createElement(React.Fragment, null, isLoading ? /* @__PURE__ */ React.createElement(CircularProgress, {
          color: "inherit",
          size: 20
        }) : null, params.InputProps.endAdornment)
      }),
      disabled: readonly,
      placeholder: placeholder2,
      error: !!errorText
      //onChange={onInputChange}
    }, customInputProps));
  };
  var GroupHeader2 = function GroupHeader3(_ref4) {
    var groupMaybeJson = _ref4.groupMaybeJson;
    if (!groupMaybeJson) return null;
    var group3 = {
      label: groupMaybeJson
    };
    if (typeof groupMaybeJson === "string" && groupMaybeJson[0] === "{") {
      try {
        group3 = JSON.parse(groupMaybeJson);
      } catch (_) {
      }
    }
    var groupLabel = group3.label;
    if (groupLabel && group3.tooltip) {
      groupLabel = /* @__PURE__ */ React.createElement(Tooltip, {
        title: group3.tooltip,
        placement: "left-start"
      }, /* @__PURE__ */ React.createElement("span", null, groupLabel));
    }
    var res2 = /* @__PURE__ */ React.createElement("div", {
      style: {
        position: "sticky",
        top: "-8px",
        padding: "4px 10px",
        color: theme.palette.primary.main,
        backgroundColor: theme.palette.background["default"]
      }
    }, groupLabel);
    return res2;
  };
  var GroupItems = function GroupItems2(_ref5) {
    var children = _ref5.children;
    return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
  };
  var renderGroup = function renderGroup2(params) {
    var res2 = /* @__PURE__ */ React.createElement("div", {
      key: params.key
    }, /* @__PURE__ */ React.createElement(GroupHeader2, {
      groupMaybeJson: params.group
    }), /* @__PURE__ */ React.createElement(GroupItems, null, params.children));
    return res2;
  };
  var renderTags = function renderTags2(value2, getTagProps) {
    return value2.map(function(option, index2) {
      return /* @__PURE__ */ React.createElement(Chip, _extends$h({
        key: option.value,
        label: getOptionLabel(option),
        size: "small",
        variant: getOptionIsCustom(option) ? "outlined" : "filled"
      }, getTagProps({
        index: index2
      })));
    });
  };
  var isOptionEqualToValue = function isOptionEqualToValue2(option, value2) {
    return (option === null || option === void 0 ? void 0 : option.value) == value2;
  };
  var renderOption = function renderOption2(props2, option) {
    var title2 = option.title, renderTitle = option.renderTitle, value2 = option.value, isHidden = option.isHidden, tooltip = option.tooltip, group3 = option.group, groupTitle = option.groupTitle;
    var isGrouped = groupTitle || group3;
    var isSelected = multiple ? (selectedValue || []).includes(value2) : selectedValue == value2;
    var className = getOptionIsCustom(option) ? "customSelectOption" : void 0;
    var prefix = !isFieldAutocomplete && isGrouped ? "  " : "";
    var finalTitle = renderTitle || prefix + title2;
    var titleSpan = /* @__PURE__ */ React.createElement("span", {
      className
    }, finalTitle);
    if (tooltip) {
      titleSpan = /* @__PURE__ */ React.createElement(Tooltip, {
        title: tooltip,
        placement: "left-start"
      }, titleSpan);
    }
    if (isHidden) return null;
    if (option.specialValue) {
      return /* @__PURE__ */ React.createElement("div", props2, finalTitle);
    } else if (multiple) {
      var itemContent = isSelected ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(default_1$a, null)), titleSpan) : /* @__PURE__ */ React.createElement(ListItemText, {
        inset: true
      }, titleSpan);
      return /* @__PURE__ */ React.createElement(MenuItem, _extends$h({}, props2, {
        size: "small",
        selected: isSelected
      }), itemContent);
    } else {
      return /* @__PURE__ */ React.createElement("div", props2, titleSpan);
    }
  };
  var res = /* @__PURE__ */ React.createElement(Autocomplete, _extends$h({
    disableClearable,
    disableCloseOnSelect: multiple,
    fullWidth: fullWidth2,
    multiple,
    style,
    freeSolo: allowCustomValues,
    loading: isInitialLoading,
    open,
    onOpen,
    onClose,
    inputValue: inputValue2,
    onInputChange,
    label: placeholder2,
    onChange,
    value,
    disabled: readonly,
    readOnly: readonly,
    options,
    groupBy: groupBy2,
    getOptionLabel,
    getOptionDisabled,
    renderInput,
    renderGroup,
    renderTags,
    renderOption,
    filterOptions,
    isOptionEqualToValue,
    size: "small"
  }, customAutocompleteProps));
  if (tooltipText) {
    res = /* @__PURE__ */ React.createElement(Tooltip, {
      title: !open ? tooltipText : null,
      placement: "top-start"
    }, res);
  }
  res = /* @__PURE__ */ React.createElement(FormControl, {
    fullWidth: fullWidth2
  }, res);
  return res;
};
const MuiFieldSelect = function(_ref) {
  var items = _ref.items, setField4 = _ref.setField, selectedKey = _ref.selectedKey, readonly = _ref.readonly, placeholder2 = _ref.placeholder, errorText = _ref.errorText, selectedLabel = _ref.selectedLabel;
  _ref.selectedOpts;
  var selectedAltLabel = _ref.selectedAltLabel, selectedFullLabel = _ref.selectedFullLabel;
  var _useState = reactExports.useState(false), _useState2 = _slicedToArray$1(_useState, 2), open = _useState2[0], setOpen = _useState2[1];
  var onOpen = reactExports.useCallback(function() {
    setOpen(true);
  }, [setOpen]);
  var onClose = reactExports.useCallback(function() {
    setOpen(false);
  }, [setOpen]);
  var renderOptions = function renderOptions2(fields) {
    var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return Object.keys(fields).map(function(fieldKey) {
      var field = fields[fieldKey];
      var items2 = field.items, path = field.path, label2 = field.label, disabled = field.disabled, matchesType = field.matchesType, tooltip = field.tooltip;
      var prefix = "  ".repeat(level);
      var finalLabel = /* @__PURE__ */ React.createElement("span", null, prefix && /* @__PURE__ */ React.createElement("span", null, prefix), matchesType ? /* @__PURE__ */ React.createElement("b", null, label2) : label2);
      if (tooltip) {
        finalLabel = /* @__PURE__ */ React.createElement(Tooltip, {
          title: tooltip,
          placement: "left-start"
        }, finalLabel);
      }
      if (items2) {
        return [/* @__PURE__ */ React.createElement(ListSubheader, {
          disabled,
          key: path,
          disableSticky: true
        }, finalLabel), renderOptions2(items2, level + 1)];
      } else {
        return /* @__PURE__ */ React.createElement(MenuItem, {
          disabled,
          key: path,
          value: path
        }, finalLabel);
      }
    });
  };
  var onChange = reactExports.useCallback(function(e2) {
    if (e2.target.value === void 0) return;
    setField4(e2.target.value);
  }, [setField4]);
  var renderValue = reactExports.useCallback(function(selectedValue) {
    if (!readonly && !selectedValue) return placeholder2;
    var findLabel = function findLabel2(fields) {
      return fields.map(function(field) {
        if (!field.items) return field.path === selectedValue ? field.label : null;
        return findLabel2(field.items);
      });
    };
    var label2 = findLabel(items).filter(function(v) {
      if (Array.isArray(v)) {
        return v.some(function(value) {
          return value !== null;
        });
      } else {
        return v !== null;
      }
    }).pop();
    return label2;
  }, [readonly, placeholder2, items]);
  var hasValue = selectedKey != null;
  var tooltipText = selectedAltLabel || selectedFullLabel;
  if (tooltipText == selectedLabel) tooltipText = null;
  var res = /* @__PURE__ */ React.createElement(Select, {
    error: !!errorText,
    variant: "standard",
    autoWidth: true,
    displayEmpty: true,
    placeholder: placeholder2,
    onChange,
    value: hasValue ? selectedKey : "",
    disabled: readonly,
    renderValue,
    size: "small",
    open,
    onOpen,
    onClose
  }, renderOptions(items));
  if (tooltipText) {
    res = /* @__PURE__ */ React.createElement(Tooltip, {
      title: !open ? tooltipText : null
    }, res);
  }
  res = /* @__PURE__ */ React.createElement(FormControl, null, res);
  return res;
};
var _excluded = ["items", "selectedKey", "setField", "isValueField", "selectedLabel", "selectedOpts", "selectedAltLabel", "selectedFullLabel"];
function ownKeys$1(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$1(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var mapFieldItemToOptionKeys = {
  key: "_value2",
  path: "value",
  label: "title",
  altLabel: "_altLabel",
  tooltip: "tooltip",
  grouplabel: "groupTitle"
};
var itemsToListValues = function itemsToListValues2(items) {
  var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return items.map(function(item) {
    var items2 = item.items, path = item.path, key = item.key, label2 = item.label, altLabel = item.altLabel, disabled = item.disabled, grouplabel = item.grouplabel, group3 = item.group, matchesType = item.matchesType, tooltip = item.tooltip;
    var prefix = "  ".repeat(level);
    if (items2) {
      return itemsToListValues2(items2, level + 1);
    } else {
      return {
        title: label2,
        renderTitle: matchesType ? /* @__PURE__ */ React.createElement("b", null, prefix + label2) : prefix + label2,
        value: path,
        disabled,
        groupTitle: level > 0 ? prefix + grouplabel : null,
        group: level > 0 ? _objectSpread$1(_objectSpread$1({}, group3), {}, {
          label: prefix + group3.label
        }) : null,
        tooltip,
        _value2: key,
        _altLabel: altLabel
      };
    }
  }).flat(Infinity);
};
var fieldAdapter = function fieldAdapter2(_ref, config2) {
  var items = _ref.items, selectedKey = _ref.selectedKey, setField4 = _ref.setField, isValueField = _ref.isValueField, selectedLabel = _ref.selectedLabel;
  _ref.selectedOpts;
  var selectedAltLabel = _ref.selectedAltLabel, selectedFullLabel = _ref.selectedFullLabel, rest2 = _objectWithoutProperties$2(_ref, _excluded);
  var tooltipText = selectedAltLabel || selectedFullLabel;
  if (tooltipText == selectedLabel) tooltipText = null;
  var listValues2 = itemsToListValues(items);
  var value = selectedKey;
  var setValue4 = function setValue5(value2, _asyncValues) {
    if (!value2 && !isValueField) return void 0;
    return setField4(value2);
  };
  var filterOptionsConfig = {
    stringify: reactExports.useCallback(function(option) {
      var keysForFilter = config2.settings.fieldItemKeysForSearch.map(function(k) {
        return mapFieldItemToOptionKeys[k];
      });
      var valueForFilter = keysForFilter.map(function(k) {
        return typeof option[k] == "string" ? option[k] : "";
      }).join("\0");
      return valueForFilter;
    }, [config2])
  };
  return _objectSpread$1(_objectSpread$1({}, rest2), {}, {
    tooltipText,
    listValues: listValues2,
    setValue: setValue4,
    filterOptionsConfig,
    allowCustomValues: false,
    multiple: false,
    disableClearable: !isValueField,
    value,
    isFieldAutocomplete: true
  });
};
const MuiFieldAutocomplete = function(props) {
  return /* @__PURE__ */ React.createElement(MuiAutocompleteWidget, fieldAdapter(props, props.config));
};
var DragHandle = {};
var _interopRequireDefault$h = interopRequireDefaultExports;
Object.defineProperty(DragHandle, "__esModule", {
  value: true
});
var default_1$9 = DragHandle.default = void 0;
var _createSvgIcon$9 = _interopRequireDefault$h(requireCreateSvgIcon());
var _jsxRuntime$9 = jsxRuntimeExports;
default_1$9 = DragHandle.default = (0, _createSvgIcon$9.default)(/* @__PURE__ */ (0, _jsxRuntime$9.jsx)("path", {
  d: "M20 9H4v2h16zM4 15h16v-2H4z"
}), "DragHandle");
var DragIcon2 = Utils.DragIcon;
var typeToIcon = {
  "delGroup": /* @__PURE__ */ React.createElement(default_1$q, null),
  "delRuleGroup": /* @__PURE__ */ React.createElement(default_1$q, null),
  "delRule": /* @__PURE__ */ React.createElement(default_1$q, null),
  "addRuleGroup": /* @__PURE__ */ React.createElement(default_1$c, null),
  "addRuleGroupExt": /* @__PURE__ */ React.createElement(default_1$c, null),
  "addRule": /* @__PURE__ */ React.createElement(default_1$c, null),
  "addGroup": /* @__PURE__ */ React.createElement(default_1$c, null),
  "drag": /* @__PURE__ */ React.createElement(default_1$9, null)
};
var typeToColor$1 = {
  // "addRule": "primary",
  // "addGroup": "primary",
  // "delGroup": "secondary",
  // "delRuleGroup": "secondary",
  // "delRule": "secondary",
  "drag": "primary"
};
const MuiIcon = function(_ref) {
  var type2 = _ref.type, readonly = _ref.readonly;
  var icon = typeToIcon[type2] || null;
  if (!icon && type2 === "drag") {
    return /* @__PURE__ */ React.createElement(DragIcon2, null);
  }
  if (type2 === "drag") {
    return /* @__PURE__ */ React.createElement(Icon, {
      size: "small",
      disabled: readonly,
      color: typeToColor$1[type2]
    }, icon);
  } else {
    return icon;
  }
};
var hideLabelsFor = {
  "addRuleGroup": true,
  "addRuleGroupExt": true,
  "delGroup": true,
  "delRuleGroup": true,
  "delRule": true
};
var typeToColor = {
  "addRule": "primary",
  "addGroup": "primary",
  "delGroup": "secondary",
  "delRuleGroup": "secondary",
  "delRule": "secondary"
};
const MuiButton = /* @__PURE__ */ reactExports.memo(function(props) {
  var type2 = props.type, label2 = props.label, onClick = props.onClick, readonly = props.readonly, renderIcon3 = props.renderIcon;
  var iconProps = {
    type: type2,
    readonly
  };
  var icon = renderIcon3 === null || renderIcon3 === void 0 ? void 0 : renderIcon3(iconProps);
  if (!label2 || hideLabelsFor[type2]) {
    return /* @__PURE__ */ React.createElement(IconButton, {
      size: "small",
      disabled: readonly,
      onClick,
      color: typeToColor[type2],
      "aria-label": label2
    }, icon);
  } else {
    return /* @__PURE__ */ React.createElement(Button, {
      size: "small",
      disabled: readonly,
      onClick,
      color: typeToColor[type2],
      startIcon: icon
    }, label2);
  }
});
const MuiButtonGroup = function(_ref) {
  var children = _ref.children;
  _ref.config;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
};
var Conj = /* @__PURE__ */ React.memo(function(_ref) {
  var conjKey = _ref.conjKey, id2 = _ref.id;
  _ref.name;
  var label2 = _ref.label, checked = _ref.checked, setConjunction4 = _ref.setConjunction, readonly = _ref.readonly, disabled = _ref.disabled;
  var onClick = reactExports.useCallback(function() {
    setConjunction4(conjKey);
  }, [conjKey, setConjunction4]);
  var postfix = setConjunction4.isDummyFn ? "__dummy" : "";
  if ((readonly || disabled) && !checked) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(Button, {
    key: id2 + postfix,
    id: id2 + postfix,
    color: checked ? "primary" : "inherit",
    value: conjKey,
    onClick,
    disabled: readonly || disabled
  }, label2);
});
var Conjs = /* @__PURE__ */ React.memo(function(_ref2) {
  var id2 = _ref2.id, not2 = _ref2.not, setNot4 = _ref2.setNot, conjunctionOptions = _ref2.conjunctionOptions, setConjunction4 = _ref2.setConjunction, disabled = _ref2.disabled, readonly = _ref2.readonly, config2 = _ref2.config, showNot = _ref2.showNot, notLabel = _ref2.notLabel;
  var conjsCount = Object.keys(conjunctionOptions).length;
  var lessThenTwo = disabled;
  var forceShowConj = config2.settings.forceShowConj;
  var showConj = forceShowConj || conjsCount > 1 && !lessThenTwo;
  var renderOptions = function renderOptions2() {
    return Object.keys(conjunctionOptions).map(function(conjKey) {
      var _conjunctionOptions$c = conjunctionOptions[conjKey], id3 = _conjunctionOptions$c.id, name2 = _conjunctionOptions$c.name, label2 = _conjunctionOptions$c.label, checked = _conjunctionOptions$c.checked;
      var conjProps = {
        conjKey,
        id: id3,
        name: name2,
        label: label2,
        checked,
        setConjunction: setConjunction4,
        readonly,
        disabled
      };
      return /* @__PURE__ */ React.createElement(Conj, _extends$h({
        key: id3
      }, conjProps));
    });
  };
  var onNotClick = reactExports.useCallback(function() {
    setNot4(!not2);
  }, [not2, setNot4]);
  var renderNot = function renderNot2() {
    if (readonly && !not2) return null;
    return /* @__PURE__ */ React.createElement(Button, {
      key: id2,
      id: id2 + "__not",
      color: not2 ? "error" : "inherit",
      onClick: onNotClick,
      disabled: readonly
    }, notLabel || "NOT");
  };
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(ButtonGroup, {
    disableElevation: true,
    variant: "contained",
    size: "small",
    disabled: readonly
  }, showNot && renderNot(), showConj && renderOptions()));
});
var LockOpen = {};
var _interopRequireDefault$g = interopRequireDefaultExports;
Object.defineProperty(LockOpen, "__esModule", {
  value: true
});
var default_1$8 = LockOpen.default = void 0;
var _createSvgIcon$8 = _interopRequireDefault$g(requireCreateSvgIcon());
var _jsxRuntime$8 = jsxRuntimeExports;
default_1$8 = LockOpen.default = (0, _createSvgIcon$8.default)(/* @__PURE__ */ (0, _jsxRuntime$8.jsx)("path", {
  d: "M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2m0 12H6V10h12z"
}), "LockOpen");
var Lock = {};
var _interopRequireDefault$f = interopRequireDefaultExports;
Object.defineProperty(Lock, "__esModule", {
  value: true
});
var default_1$7 = Lock.default = void 0;
var _createSvgIcon$7 = _interopRequireDefault$f(requireCreateSvgIcon());
var _jsxRuntime$7 = jsxRuntimeExports;
default_1$7 = Lock.default = (0, _createSvgIcon$7.default)(/* @__PURE__ */ (0, _jsxRuntime$7.jsx)("path", {
  d: "M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2m-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2m3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1z"
}), "Lock");
const MuiSwitch = function(_ref) {
  var value = _ref.value, setValue4 = _ref.setValue, label2 = _ref.label, checkedLabel = _ref.checkedLabel, hideLabel = _ref.hideLabel, id2 = _ref.id, config2 = _ref.config, type2 = _ref.type;
  config2.settings.renderSize;
  var onChange = function onChange2(e2) {
    return setValue4(e2.target.checked);
  };
  var onClick = function onClick2() {
    return setValue4(!value);
  };
  var postfix = type2;
  var showLabel = value ? checkedLabel || label2 : label2;
  var icon = value ? /* @__PURE__ */ React.createElement(default_1$7, null) : /* @__PURE__ */ React.createElement(default_1$8, null);
  if (type2 == "lock") {
    if (hideLabel) {
      return /* @__PURE__ */ React.createElement(IconButton, {
        key: id2 + postfix,
        onClick,
        size: "small"
      }, icon);
    } else {
      return /* @__PURE__ */ React.createElement(Button, {
        key: id2 + postfix,
        onClick,
        size: "small",
        startIcon: icon
      }, showLabel);
    }
  }
  return /* @__PURE__ */ React.createElement(FormControlLabel, {
    control: /* @__PURE__ */ React.createElement(Switch, {
      checked: !!value,
      size: "small",
      onChange
    }),
    label: showLabel
  });
};
var ExpandMoreSharp = {};
var _interopRequireDefault$e = interopRequireDefaultExports;
Object.defineProperty(ExpandMoreSharp, "__esModule", {
  value: true
});
var default_1$6 = ExpandMoreSharp.default = void 0;
var _createSvgIcon$6 = _interopRequireDefault$e(requireCreateSvgIcon());
var _jsxRuntime$6 = jsxRuntimeExports;
default_1$6 = ExpandMoreSharp.default = (0, _createSvgIcon$6.default)(/* @__PURE__ */ (0, _jsxRuntime$6.jsx)("path", {
  d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
}), "ExpandMoreSharp");
var ValueSource = /* @__PURE__ */ React.memo(function(_ref) {
  var valueSrc = _ref.valueSrc, srcKey = _ref.srcKey, handleChange = _ref.handleChange, info = _ref.info;
  var isSelected = valueSrc == srcKey || !valueSrc && srcKey == "value";
  var onClick = reactExports.useCallback(function(e2) {
    return handleChange(e2, srcKey);
  }, [handleChange, srcKey]);
  return /* @__PURE__ */ React.createElement(MenuItem, {
    value: srcKey,
    selected: isSelected,
    onClick
  }, !isSelected && /* @__PURE__ */ React.createElement(ListItemText, {
    inset: true
  }, info.label), isSelected && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(default_1$a, null)), info.label));
});
var ValueSources = /* @__PURE__ */ React.memo(function(_ref2) {
  var valueSources = _ref2.valueSources, valueSrc = _ref2.valueSrc, title2 = _ref2.title, setValueSrc4 = _ref2.setValueSrc;
  _ref2.readonly;
  var _React$useState = React.useState(null), _React$useState2 = _slicedToArray$1(_React$useState, 2), anchorEl = _React$useState2[0], setAnchorEl = _React$useState2[1];
  var handleOpen = reactExports.useCallback(function(event) {
    setAnchorEl(event.currentTarget);
  }, [setAnchorEl]);
  var handleClose = reactExports.useCallback(function() {
    setAnchorEl(null);
  }, [setAnchorEl]);
  var toggleOpenClose = reactExports.useCallback(function(event) {
    anchorEl ? handleClose() : handleOpen(event);
  }, [handleClose, handleOpen, anchorEl]);
  var handleChange = reactExports.useCallback(function(_e, srcKey) {
    setValueSrc4(srcKey);
    handleClose();
  }, [handleClose, setValueSrc4]);
  var renderOptions = function renderOptions2(valueSources2) {
    return valueSources2.map(function(_ref3) {
      var _ref4 = _slicedToArray$1(_ref3, 2), srcKey = _ref4[0], info = _ref4[1];
      return /* @__PURE__ */ React.createElement(ValueSource, {
        key: srcKey,
        valueSrc,
        srcKey,
        handleChange,
        info
      });
    });
  };
  var open = Boolean(anchorEl);
  return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(IconButton, {
    size: "small",
    onClick: toggleOpenClose
  }, /* @__PURE__ */ React.createElement(default_1$6, null)), /* @__PURE__ */ React.createElement(Menu, {
    anchorEl,
    open,
    onClose: handleClose
  }, /* @__PURE__ */ React.createElement(FormControl, {
    component: "fieldset",
    sx: {
      p: 0
    }
  }, /* @__PURE__ */ React.createElement(FormLabel, {
    component: "legend",
    sx: {
      p: 2,
      pt: 0,
      pb: 1
    }
  }, title2), renderOptions(valueSources))));
});
const MuiConfirm = function(_ref) {
  var onOk = _ref.onOk, okText = _ref.okText, cancelText = _ref.cancelText, title2 = _ref.title, confirmFn = _ref.confirmFn;
  confirmFn({
    description: title2 || "Are you sure?",
    title: null,
    confirmationText: okText || "Ok",
    cancellationText: cancelText || "Cancel"
  }).then(onOk)["catch"](function() {
  });
};
var _xdpPackage$version$s, _xdpPackage$version;
var xdpVersion = parseInt((_xdpPackage$version$s = xdpPackage === null || xdpPackage === void 0 || (_xdpPackage$version = xdpPackage.version) === null || _xdpPackage$version === void 0 || (_xdpPackage$version = _xdpPackage$version.split(".")) === null || _xdpPackage$version === void 0 ? void 0 : _xdpPackage$version[0]) !== null && _xdpPackage$version$s !== void 0 ? _xdpPackage$version$s : "0");
var MuiProvider = function MuiProvider2(_ref) {
  var config2 = _ref.config, children = _ref.children;
  var settingsTheme = config2.settings.theme || {};
  var settingsLocale = config2.settings.locale || {};
  var momentLocale = settingsLocale.moment;
  var themeConfig = settingsTheme.mui;
  var locale2 = settingsLocale.mui;
  var theme = createTheme(themeConfig, locale2, {
    palette: {
      // neutral: {
      //   main: "#64748B",
      //   contrastText: "#fff"
      // },
    }
  });
  var locProviderProps = xdpVersion >= 6 ? {
    locale: momentLocale
  } : {
    adapterLocale: momentLocale
  };
  var base = /* @__PURE__ */ React.createElement("div", {
    className: "mui"
  }, children);
  var withProviders = /* @__PURE__ */ React.createElement(LocalizationProvider, _extends$h({
    dateAdapter: MomentUtils
  }, locProviderProps), /* @__PURE__ */ React.createElement(ConfirmProvider, null, base));
  var withTheme = theme ? /* @__PURE__ */ React.createElement(ThemeProvider, {
    theme
  }, withProviders) : withProviders;
  return withTheme;
};
const MuiWidgets = {
  MuiTextWidget,
  MuiTextAreaWidget,
  MuiDateWidget,
  MuiDateTimeWidget,
  MuiTimeWidget,
  MuiSelectWidget,
  MuiNumberWidget,
  MuiSliderWidget,
  MuiRangeWidget,
  MuiBooleanWidget,
  MuiMultiSelectWidget,
  MuiAutocompleteWidget,
  MuiFieldSelect,
  MuiFieldAutocomplete,
  MuiIcon,
  MuiButton,
  MuiButtonGroup,
  MuiConjs: Conjs,
  MuiSwitch,
  MuiValueSources: ValueSources,
  MuiConfirm,
  MuiUseConfirm: useConfirm,
  MuiProvider
};
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var settings$1 = _objectSpread(_objectSpread({}, BasicConfig.settings), {}, {
  renderField: function renderField2(props, _ref) {
    var _props$customProps;
    var RCE2 = _ref.RCE, _ref$W = _ref.W, MuiFieldAutocomplete2 = _ref$W.MuiFieldAutocomplete, MuiFieldSelect2 = _ref$W.MuiFieldSelect;
    return props !== null && props !== void 0 && (_props$customProps = props.customProps) !== null && _props$customProps !== void 0 && _props$customProps.showSearch ? RCE2(MuiFieldAutocomplete2, props) : RCE2(MuiFieldSelect2, props);
  },
  renderOperator: function renderOperator2(props, _ref2) {
    var _props$customProps2;
    var RCE2 = _ref2.RCE, _ref2$W = _ref2.W, MuiFieldAutocomplete2 = _ref2$W.MuiFieldAutocomplete, MuiFieldSelect2 = _ref2$W.MuiFieldSelect;
    return props !== null && props !== void 0 && (_props$customProps2 = props.customProps) !== null && _props$customProps2 !== void 0 && _props$customProps2.showSearch ? RCE2(MuiFieldAutocomplete2, props) : RCE2(MuiFieldSelect2, props);
  },
  renderFunc: function renderFunc2(props, _ref3) {
    var RCE2 = _ref3.RCE, MuiFieldSelect2 = _ref3.W.MuiFieldSelect;
    return RCE2(MuiFieldSelect2, props);
  },
  renderConjs: function renderConjs2(props, _ref4) {
    var RCE2 = _ref4.RCE, MuiConjs = _ref4.W.MuiConjs;
    return RCE2(MuiConjs, props);
  },
  renderSwitch: function renderSwitch2(props, _ref5) {
    var RCE2 = _ref5.RCE, MuiSwitch2 = _ref5.W.MuiSwitch;
    return RCE2(MuiSwitch2, props);
  },
  renderButton: function renderButton2(props, _ref6) {
    var RCE2 = _ref6.RCE, MuiButton2 = _ref6.W.MuiButton;
    return RCE2(MuiButton2, props);
  },
  renderIcon: function renderIcon2(props, _ref7) {
    var RCE2 = _ref7.RCE, MuiIcon2 = _ref7.W.MuiIcon;
    return RCE2(MuiIcon2, props);
  },
  renderButtonGroup: function renderButtonGroup2(props, _ref8) {
    var RCE2 = _ref8.RCE, MuiButtonGroup2 = _ref8.W.MuiButtonGroup;
    return RCE2(MuiButtonGroup2, props);
  },
  renderValueSources: function renderValueSources2(props, _ref9) {
    var RCE2 = _ref9.RCE, MuiValueSources = _ref9.W.MuiValueSources;
    return RCE2(MuiValueSources, props);
  },
  renderFieldSources: function renderFieldSources2(props, _ref10) {
    var RCE2 = _ref10.RCE, MuiValueSources = _ref10.W.MuiValueSources;
    return RCE2(MuiValueSources, props);
  },
  renderProvider: function renderProvider2(props, _ref11) {
    var RCE2 = _ref11.RCE, MuiProvider3 = _ref11.W.MuiProvider;
    return RCE2(MuiProvider3, props);
  },
  renderConfirm: function renderConfirm2(props, _ref12) {
    var MuiConfirm2 = _ref12.W.MuiConfirm;
    return MuiConfirm2(props);
  },
  useConfirm: function useConfirm3(_ref13) {
    var MuiUseConfirm = _ref13.W.MuiUseConfirm;
    return MuiUseConfirm();
  }
});
var widgets$1 = _objectSpread(_objectSpread({}, BasicConfig.widgets), {}, {
  text: _objectSpread(_objectSpread({}, BasicConfig.widgets.text), {}, {
    factory: function factory15(props, _ref14) {
      var RCE2 = _ref14.RCE, MuiTextWidget2 = _ref14.W.MuiTextWidget;
      return RCE2(MuiTextWidget2, props);
    }
  }),
  textarea: _objectSpread(_objectSpread({}, BasicConfig.widgets.textarea), {}, {
    factory: function factory16(props, _ref15) {
      var RCE2 = _ref15.RCE, MuiTextAreaWidget2 = _ref15.W.MuiTextAreaWidget;
      return RCE2(MuiTextAreaWidget2, props);
    }
  }),
  number: _objectSpread(_objectSpread({}, BasicConfig.widgets.number), {}, {
    factory: function factory17(props, _ref16) {
      var RCE2 = _ref16.RCE, MuiNumberWidget2 = _ref16.W.MuiNumberWidget;
      return RCE2(MuiNumberWidget2, props);
    }
  }),
  multiselect: _objectSpread(_objectSpread({}, BasicConfig.widgets.multiselect), {}, {
    factory: function factory18(props, _ref17) {
      var RCE2 = _ref17.RCE, _ref17$W = _ref17.W, MuiAutocompleteWidget2 = _ref17$W.MuiAutocompleteWidget, MuiMultiSelectWidget2 = _ref17$W.MuiMultiSelectWidget;
      return props.asyncFetch || props.showSearch ? RCE2(MuiAutocompleteWidget2, _objectSpread(_objectSpread({}, props), {}, {
        multiple: true
      })) : RCE2(MuiMultiSelectWidget2, props);
    }
  }),
  select: _objectSpread(_objectSpread({}, BasicConfig.widgets.select), {}, {
    factory: function factory19(props, _ref18) {
      var RCE2 = _ref18.RCE, _ref18$W = _ref18.W, MuiAutocompleteWidget2 = _ref18$W.MuiAutocompleteWidget, MuiSelectWidget2 = _ref18$W.MuiSelectWidget;
      return props.asyncFetch || props.showSearch ? RCE2(MuiAutocompleteWidget2, props) : RCE2(MuiSelectWidget2, props);
    }
  }),
  slider: _objectSpread(_objectSpread({}, BasicConfig.widgets.slider), {}, {
    factory: function factory20(props, _ref19) {
      var RCE2 = _ref19.RCE, MuiSliderWidget2 = _ref19.W.MuiSliderWidget;
      return RCE2(MuiSliderWidget2, props);
    }
  }),
  "boolean": _objectSpread(_objectSpread({}, BasicConfig.widgets["boolean"]), {}, {
    factory: function factory21(props, _ref20) {
      var RCE2 = _ref20.RCE, MuiBooleanWidget2 = _ref20.W.MuiBooleanWidget;
      return RCE2(MuiBooleanWidget2, props);
    }
  }),
  date: _objectSpread(_objectSpread({}, BasicConfig.widgets.date), {}, {
    factory: function factory22(props, _ref21) {
      var RCE2 = _ref21.RCE, MuiDateWidget2 = _ref21.W.MuiDateWidget;
      return RCE2(MuiDateWidget2, props);
    }
  }),
  time: _objectSpread(_objectSpread({}, BasicConfig.widgets.time), {}, {
    factory: function factory23(props, _ref22) {
      var RCE2 = _ref22.RCE, MuiTimeWidget2 = _ref22.W.MuiTimeWidget;
      return RCE2(MuiTimeWidget2, props);
    }
  }),
  datetime: _objectSpread(_objectSpread({}, BasicConfig.widgets.datetime), {}, {
    factory: function factory24(props, _ref23) {
      var RCE2 = _ref23.RCE, MuiDateTimeWidget2 = _ref23.W.MuiDateTimeWidget;
      return RCE2(MuiDateTimeWidget2, props);
    }
  }),
  rangeslider: _objectSpread(_objectSpread({}, BasicConfig.widgets.rangeslider), {}, {
    factory: function factory25(props, _ref24) {
      var RCE2 = _ref24.RCE, MuiRangeWidget2 = _ref24.W.MuiRangeWidget;
      return RCE2(MuiRangeWidget2, props);
    }
  })
});
var types$1 = _objectSpread({}, BasicConfig.types);
var ctx = _objectSpread(_objectSpread({}, BasicConfig.ctx), {}, {
  W: _objectSpread(_objectSpread({}, BasicConfig.ctx.W), MuiWidgets)
});
var config$1 = _objectSpread(_objectSpread({}, BasicConfig), {}, {
  ctx,
  types: types$1,
  widgets: widgets$1,
  settings: settings$1
});
config$1 = Utils.ConfigMixins.addMixins(config$1, ["rangeslider"]);
const MuiConfig = config$1;
const InitialConfig = MuiConfig;
const wrapField = (field) => {
  return '<span class="logicField">' + field + "</span>";
};
const wrapOperator = (op2) => {
  return '<span class="logicOp">' + op2 + "</span>";
};
const wrapValue = (value, valueTypes) => {
  return '<span class="logicValue">' + (valueTypes == "text" ? '"' + value + '"' : value) + "</span>";
};
const conjunctions = {
  AND: InitialConfig.conjunctions.AND,
  OR: InitialConfig.conjunctions.OR
};
const operators = {
  ...InitialConfig.operators,
  less: {
    ...InitialConfig.operators.less,
    formatOp: (field, op2, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      return "".concat(wrapField(field), " ").concat(wrapOperator("<"), " ").concat(wrapValue(
        value,
        valueTypes
      ));
    }
  },
  less_or_equal: {
    ...InitialConfig.operators.less_or_equal,
    formatOp: (field, op2, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      return "".concat(wrapField(field), " ").concat(wrapOperator("<="), " ").concat(wrapValue(
        value,
        valueTypes
      ));
    }
  },
  greater: {
    ...InitialConfig.operators.greater,
    formatOp: (field, op2, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      return "".concat(wrapField(field), " ").concat(wrapOperator(">"), " ").concat(wrapValue(
        value,
        valueTypes
      ));
    }
  },
  greater_or_equal: {
    ...InitialConfig.operators.greater_or_equal,
    formatOp: (field, op2, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      return "".concat(wrapField(field), " ").concat(wrapOperator(">="), " ").concat(wrapValue(
        value,
        valueTypes
      ));
    }
  },
  equal: {
    ...InitialConfig.operators.equal,
    label: "Equals",
    jsonLogic: "==",
    formatOp: (field, op2, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      const opStr = isForDisplay ? "equals" : opDef.label;
      return "".concat(wrapField(field), " ").concat(wrapOperator(opStr), " ").concat(wrapValue(
        value,
        valueTypes
      ));
    }
  },
  not_equal: {
    ...InitialConfig.operators.not_equal,
    label: "Not Equals",
    jsonLogic: "!=",
    formatOp: (field, op2, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      const opStr = isForDisplay ? "not equals" : opDef.label;
      return "".concat(wrapField(field), " ").concat(wrapOperator(opStr), " ").concat(wrapValue(
        value,
        valueTypes
      ));
    }
  },
  starts_with: {
    ...InitialConfig.operators.starts_with,
    jsonLogic: "startsWith",
    formatOp: (field, op2, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      const opStr = isForDisplay ? "starts with" : opDef.label;
      return "".concat(wrapField(field), " ").concat(wrapOperator(opStr), " ").concat(wrapValue(
        value,
        valueTypes
      ));
    }
  },
  ends_with: {
    ...InitialConfig.operators.ends_with,
    jsonLogic: "endsWith",
    formatOp: (field, op2, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      const opStr = isForDisplay ? "ends with" : opDef.label;
      return "".concat(wrapField(field), " ").concat(wrapOperator(opStr), " ").concat(wrapValue(
        value,
        valueTypes
      ));
    }
  },
  between: {
    ...InitialConfig.operators.between,
    label: "Between",
    jsonLogic: "between",
    formatOp: (field, op2, values2, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) => {
      let valFrom = values2.first();
      let valTo = values2.get(1);
      if (isForDisplay)
        return "".concat(wrapField(field), " ").concat(wrapOperator("between"), " ").concat(wrapValue(
          valFrom,
          valueTypes
        ), " ").concat(wrapOperator("and"), " ").concat(wrapValue(valTo, valueTypes));
      else return "".concat(field, " >= ").concat(valFrom, " && ").concat(field, " <= ").concat(valTo);
    }
  },
  not_between: {
    ...InitialConfig.operators.not_between,
    label: "Not Between",
    jsonLogic: "not_between",
    formatOp: (field, op2, values2, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) => {
      let valFrom = values2.first();
      let valTo = values2.get(1);
      if (isForDisplay)
        return "".concat(wrapField(field), " ").concat(wrapOperator("not between"), " ").concat(wrapValue(
          valFrom,
          valueTypes
        ), " ").concat(wrapOperator("and"), " ").concat(wrapValue(valTo, valueTypes));
      else return "".concat(field, " >= ").concat(valFrom, " && ").concat(field, " <= ").concat(valTo);
    }
  },
  like: {
    ...InitialConfig.operators.like,
    label: "Contains",
    jsonLogic: "contains",
    _jsonLogicIsRevArgs: false,
    formatOp: (field, op2, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      const opStr = isForDisplay ? "contains" : opDef.label;
      return "".concat(wrapField(field), " ").concat(wrapOperator(opStr), " ").concat(wrapValue(
        value,
        valueTypes
      ));
    }
  },
  not_like: {
    ...InitialConfig.operators.not_like,
    label: "Not Contains",
    jsonLogic: "not_contains",
    formatOp: (field, op2, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      const opStr = isForDisplay ? "does not containends with" : opDef.label;
      return "".concat(wrapField(field), " ").concat(wrapOperator(opStr), " ").concat(wrapValue(
        value,
        valueTypes
      ));
    }
  },
  select_any_in: {
    ...InitialConfig.operators.select_any_in,
    label: "Any In",
    jsonLogic: "in",
    formatOp: (field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      let formattedValues = values2.join(", ");
      return "".concat(wrapField(field), " ").concat(wrapOperator("in"), " (").concat(wrapValue(
        formattedValues,
        ""
      ), ")");
    }
  },
  select_not_any_in: {
    ...InitialConfig.operators.select_not_any_in,
    label: "None In",
    jsonLogic: "not_in",
    formatOp: (field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      let formattedValues = values2.join(", ");
      return "".concat(wrapField(field), " ").concat(wrapOperator("not in"), " (").concat(wrapValue(
        formattedValues,
        ""
      ), ")");
    }
  },
  multiselect_equals: {
    ...InitialConfig.operators.multiselect_equals,
    label: "Any In",
    jsonLogic: "any_in",
    formatOp: (field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      let formattedValues = values2.join(", ");
      return "".concat(wrapOperator("Any of"), " (").concat(wrapValue(
        formattedValues,
        ""
      ), ") in ").concat(wrapField(field), " ").concat(wrapOperator("is selected"));
    }
  },
  multiselect_not_equals: {
    ...InitialConfig.operators.multiselect_not_equals,
    label: "None In",
    jsonLogic: "none_in",
    formatOp: (field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      let formattedValues = values2.join(", ");
      return "".concat(wrapOperator("None of"), " (").concat(wrapValue(
        formattedValues,
        ""
      ), ") in ").concat(wrapField(field), " ").concat(wrapOperator("is selected"));
    }
  },
  is_relevant: {
    label: "Is Displayed",
    jsonLogic: "relevance",
    cardinality: 0,
    formatOp: (field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return "".concat(wrapField(field), " ").concat(wrapValue("is shown"));
    }
  },
  is_not_relevant: {
    label: "Is Hidden",
    jsonLogic: "not_relevance",
    cardinality: 0,
    formatOp: (field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return "".concat(wrapField(field), " ").concat(wrapValue("is not shown"));
    }
  },
  is_valid: {
    label: "Is Valid",
    jsonLogic: "validity",
    cardinality: 0,
    formatOp: (field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return "".concat(wrapField(field), " ").concat(wrapValue("is valid"));
    }
  },
  is_not_valid: {
    label: "Is Not Valid",
    jsonLogic: "not_validity",
    cardinality: 0,
    formatOp: (field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return "".concat(wrapField(field), " ").concat(wrapValue("is not valid"));
    }
  },
  is_void: {
    cardinality: 0,
    label: "Is Empty",
    jsonLogic: "is_void",
    formatOp: (field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return "".concat(wrapField(field), " ").concat(wrapValue("is empty"));
    }
  },
  is_online: {
    cardinality: 0,
    label: "Is Online",
    jsonLogic: "is_online",
    formatOp: (field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return "".concat(wrapField(field), " ").concat(wrapValue("is online"));
    }
  },
  is_offline: {
    cardinality: 0,
    label: "Is Offline",
    jsonLogic: "is_offline",
    formatOp: (field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return "".concat(wrapField(field), " ").concat(wrapValue("is Offline"));
    }
  },
  is_not_void: {
    cardinality: 0,
    label: "Is not Empty",
    jsonLogic: "is_not_void",
    formatOp: (field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return "".concat(wrapField(field), " ").concat(wrapValue("is not empty"));
    }
  },
  is_file_void: {
    cardinality: 0,
    label: "Is Empty",
    jsonLogic: "is_file_void",
    formatOp: (field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return "".concat(wrapField(field), " ").concat(wrapValue("is empty"));
    }
  },
  is_file_not_void: {
    cardinality: 0,
    label: "Is not Empty",
    jsonLogic: "is_file_not_void",
    formatOp: (field, op2, values2, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return "".concat(wrapField(field), " ").concat(wrapValue("is not empty"));
    }
  }
};
const widgets = {
  ...InitialConfig.widgets,
  // examples of  overriding
  text: {
    ...InitialConfig.widgets.text
  },
  slider: {
    ...InitialConfig.widgets.slider,
    customProps: {
      width: "300px"
    }
  },
  rangeslider: {
    ...InitialConfig.widgets.rangeslider,
    customProps: {
      width: "300px"
    }
  },
  date: {
    ...InitialConfig.widgets.date,
    dateFormat: "DD.MM.YYYY",
    valueFormat: "YYYY-MM-DD"
  },
  time: {
    ...InitialConfig.widgets.time,
    timeFormat: "HH:mm",
    valueFormat: "HH:mm:ss"
  },
  datetime: {
    ...InitialConfig.widgets.datetime,
    timeFormat: "HH:mm",
    dateFormat: "DD.MM.YYYY",
    valueFormat: "YYYY-MM-DD HH:mm:ss"
  },
  func: {
    ...InitialConfig.widgets.func,
    customProps: {
      showSearch: true
    }
  },
  treeselect: {
    ...InitialConfig.widgets.treeselect,
    customProps: {
      showSearch: true
    }
  }
};
const types = {
  ...InitialConfig.types,
  boolean: merge$5(InitialConfig.types.boolean, {
    widgets: {
      boolean: {
        widgetProps: {
          hideOperator: true,
          operatorInlineLabel: "is"
        }
      }
    }
  })
};
const localeSettings = {
  valueLabel: "Value",
  valuePlaceholder: "Value",
  fieldLabel: "Field",
  operatorLabel: "Operator",
  fieldPlaceholder: "Select field",
  operatorPlaceholder: "Select operator",
  deleteLabel: null,
  addGroupLabel: "Add group",
  addRuleLabel: "Add rule",
  addSubRuleLabel: "Add sub rule",
  delGroupLabel: null,
  notLabel: "Not",
  valueSourcesPopupTitle: "Select value source",
  removeRuleConfirmOptions: {
    title: "Are you sure delete this rule?",
    okText: "Yes",
    okType: "danger"
  },
  removeGroupConfirmOptions: {
    title: "Are you sure delete this group?",
    okText: "Yes",
    okType: "danger"
  }
};
const settings = {
  ...InitialConfig.settings,
  ...localeSettings,
  valueSourcesInfo: {
    value: {
      label: "Value"
    },
    field: {
      label: "Field",
      widget: "field"
    },
    func: {
      label: "Function",
      widget: "func"
    }
  },
  canReorder: false,
  showNot: false,
  maxNesting: 1,
  canLeaveEmptyGroup: false
  //after deletion
};
const funcs = {};
const config = {
  ctx: MuiConfig.ctx,
  conjunctions,
  operators,
  widgets,
  types,
  settings,
  funcs
};
function LogicBuilder(props) {
  const {
    jsonLogicFormat: jsonLogicFormat3,
    queryString: queryString3,
    loadTree: loadTree3,
    uuid: uuid2,
    loadFromJsonLogic: loadFromJsonLogic3,
    checkTree: checkTree3
  } = Utils;
  const config$12 = { ...config, fields: props.fields };
  const initTree = props.logic ? checkTree3(loadFromJsonLogic3(props.logic, config$12), config$12) : loadTree3({ id: uuid2(), type: "group" });
  const [tree2, setTree3] = reactExports.useState(initTree);
  const [html, setHtml] = reactExports.useState(queryString3(tree2, config$12, true));
  const renderBuilder = (props2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { jey: "builder", className: "query-builder-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "query-builder", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Builder$1, { ...props2 }) }) });
  const onChange = (immutableTree) => {
    setTree3(immutableTree);
  };
  const saveState = () => {
    const { logic: logic2, errors } = jsonLogicFormat3(tree2, config$12);
    setHtml(queryString3(tree2, config$12, true));
    props.onChange(logic2);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "query-builder-result", children: [
      props.logic && html ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "pre",
        {
          className: "condition-human-text",
          children: truncateWithEllipsis(stripTags(html), 50)
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "condition-human-text", children: props.t("no_condition") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "icon-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => props.onDialogStateChanged(true), children: /* @__PURE__ */ jsxRuntimeExports.jsx(EditOutlined, {}) }) })
    ] }, "result"),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Dialog,
      {
        fullScreen: true,
        sx: { margin: "200px" },
        open: props.dialogOpen,
        onClose: () => props.onDialogStateChanged(false),
        "aria-labelledby": "alert-dialog-title-logic-builder",
        "aria-describedby": "alert-dialog-description",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { id: "alert-dialog-title-logic-builder", children: props.title }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            QueryContainer,
            {
              ...config$12,
              value: tree2,
              onChange,
              renderBuilder
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => {
                props.onDialogStateChanged(false);
                saveState();
              },
              autoFocus: true,
              variant: "contained",
              children: "Agree"
            }
          ) })
        ]
      }
    )
  ] });
}
const buildFields = (componentIndices, code, state, mainLang, langList) => {
  let dependencies2 = accessibleDependencies(componentIndices, code);
  let returnResult = {
    mode: {
      label: "Mode",
      type: "text",
      valueSources: ["value"],
      operators: ["is_offline", "is_online"]
    },
    survey_lang: {
      label: "Language",
      type: "select",
      valueSources: ["value"],
      operators: ["select_any_in", "select_not_any_in"],
      fieldSettings: {
        listValues: langList
      }
    }
  };
  dependencies2.forEach((el) => {
    if (state[el] && (isQuestion(el) || isGroup(el))) {
      returnResult = {
        ...returnResult,
        ...buildField$1(el, state[el], state, mainLang)
      };
    }
  });
  return returnResult;
};
const buildField$1 = (code, component, state, mainLang) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  const label2 = code + ". " + stripTags(((_b = (_a = component.content) == null ? void 0 : _a.label) == null ? void 0 : _b[mainLang]) || "");
  if (isGroup(code)) {
    return {
      [code]: {
        label: label2,
        type: "text",
        valueSources: ["value"],
        operators: [
          "is_relevant",
          "is_not_relevant",
          "is_valid",
          "is_not_valid"
        ]
      }
    };
  }
  switch (component.type) {
    case "text":
    case "barcode":
    case "email":
      return {
        [code]: {
          label: label2,
          type: "text",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "equal",
            "not_equal",
            "like",
            "not_like",
            "starts_with",
            "ends_with"
          ]
        }
      };
    case "paragraph":
      return {
        [code]: {
          label: label2,
          type: "text",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "like",
            "not_like",
            "starts_with",
            "ends_with"
          ]
        }
      };
    case "number":
      return {
        [code]: {
          label: label2,
          type: "number",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "equal",
            "not_equal",
            "less",
            "less_or_equal",
            "greater",
            "greater_or_equal",
            "between",
            "not_between"
          ]
        }
      };
    case "file_upload":
      return {
        [code]: {
          label: label2,
          type: "text",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_file_void",
            "is_file_not_void"
          ]
        }
      };
    case "signature":
    case "photo_capture":
    case "video_capture":
      return {
        [code]: {
          label: label2,
          type: "text",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_file_void",
            "is_file_not_void"
          ]
        }
      };
    case "date":
      return {
        [code]: {
          label: label2,
          type: "date",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "greater_or_equal",
            "less_or_equal",
            "between"
          ]
        }
      };
    case "time":
      return {
        [code]: {
          label: label2,
          type: "time",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "greater_or_equal",
            "less_or_equal",
            "between"
          ]
        }
      };
    case "date_time":
      return {
        [code]: {
          label: label2,
          type: "datetime",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "greater_or_equal",
            "less_or_equal",
            "between"
          ]
        }
      };
    case "image_scq":
    case "icon_scq":
    case "scq":
      let scqReturnList = {};
      let scqListValues = {};
      (_c = component.children) == null ? void 0 : _c.forEach((element) => {
        var _a2, _b2;
        const label22 = stripTags(
          ((_b2 = (_a2 = state[element.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[mainLang]) || ""
        );
        scqListValues[element.code] = label22 ? element.code + " - " + label22 : element.code;
      });
      scqReturnList[code] = {
        label: label2,
        fieldSettings: {
          listValues: scqListValues
        },
        type: "select",
        valueSources: ["value"],
        operators: [
          "is_relevant",
          "is_not_relevant",
          "is_valid",
          "is_not_valid",
          "is_void",
          "is_not_void",
          "select_any_in",
          "select_not_any_in"
        ]
      };
      let scqOther = (_d = component.children) == null ? void 0 : _d.find((el) => el.code === "Aother");
      if (scqOther && ((_e = state[scqOther.qualifiedCode].children) == null ? void 0 : _e.find(
        (el) => el.code === "Atext"
      ))) {
        scqReturnList[code + "AotherAtext"] = {
          label: "".concat(label2, " [").concat(((_g = (_f = state[scqOther.qualifiedCode].content) == null ? void 0 : _f.label) == null ? void 0 : _g[mainLang]) || "", "]"),
          type: "text",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "equal",
            "not_equal",
            "like",
            "not_like",
            "starts_with",
            "ends_with"
          ]
        };
      }
      return scqReturnList;
    case "image_mcq":
    case "icon_mcq":
    case "mcq":
      let mcqReturnList = {};
      let mcqListValues = {};
      (_h = component.children) == null ? void 0 : _h.forEach((element) => {
        var _a2, _b2;
        const label22 = stripTags(
          ((_b2 = (_a2 = state[element.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[mainLang]) || ""
        );
        mcqListValues[element.code] = label22 ? element.code + " - " + label22 : element.code;
      });
      mcqReturnList[code] = {
        label: label2,
        fieldSettings: {
          listValues: mcqListValues
        },
        type: "multiselect",
        valueSources: ["value"],
        operators: [
          "is_relevant",
          "is_not_relevant",
          "is_valid",
          "is_not_valid",
          "multiselect_equals",
          "multiselect_not_equals"
        ]
      };
      let mcqOther = (_i = component.children) == null ? void 0 : _i.find((el) => el.code === "Aother");
      if (mcqOther && ((_j = state[mcqOther.qualifiedCode].children) == null ? void 0 : _j.find(
        (el) => el.code === "Atext"
      ))) {
        mcqReturnList[code + "AotherAtext"] = {
          label: "".concat(label2, " [").concat(((_l = (_k = state[mcqOther.qualifiedCode].content) == null ? void 0 : _k.label) == null ? void 0 : _l[mainLang]) || "", "]"),
          type: "text",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "equal",
            "not_equal",
            "like",
            "not_like",
            "starts_with",
            "ends_with"
          ]
        };
      }
      return mcqReturnList;
    case "nps":
      let npsReturnList = {};
      (_m = component.children) == null ? void 0 : _m.forEach((element) => {
        var _a2, _b2;
        const label22 = stripTags(
          ((_b2 = (_a2 = state[element.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[mainLang]) || ""
        );
        mcqListValues[element.code] = label22 ? element.code + " - " + label22 : element.code;
      });
      npsReturnList[code] = {
        label: label2,
        fieldSettings: {
          min: 0,
          max: 10
        },
        type: "number",
        valueSources: ["value"],
        operators: [
          "is_void",
          "is_not_void",
          "equal",
          "not_equal",
          "less",
          "less_or_equal",
          "greater",
          "greater_or_equal",
          "between",
          "not_between"
        ]
      };
      return npsReturnList;
    case "scq_icon_array":
    case "scq_array":
      let scqArrayReturnList = {};
      let scqArrayListValues = {};
      (_n = component.children) == null ? void 0 : _n.filter((el) => el.type == "column").forEach((element) => {
        var _a2, _b2;
        const label22 = stripTags(
          ((_b2 = (_a2 = state[element.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[mainLang]) || ""
        );
        scqArrayListValues[element.code] = label22 ? element.code + " - " + label22 : element.code;
      });
      scqArrayReturnList[code] = {
        label: label2,
        type: "text",
        valueSources: ["value"],
        operators: [
          "is_relevant",
          "is_not_relevant",
          "is_valid",
          "is_not_valid"
        ]
      };
      (_o = component.children) == null ? void 0 : _o.filter((el) => el.type == "row").forEach((element) => {
        var _a2, _b2;
        scqArrayReturnList[code + element.code] = {
          label: label2 + " - " + stripTags(
            ((_b2 = (_a2 = state[element.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[mainLang]) || ""
          ),
          type: "select",
          valueSources: ["value"],
          fieldSettings: { listValues: scqArrayListValues },
          operators: ["select_any_in", "select_not_any_in"]
        };
      });
      return scqArrayReturnList;
    case "ranking":
    case "image_ranking":
      let rankingReturnList = {};
      (_p = component.children) == null ? void 0 : _p.forEach((element) => {
        var _a2, _b2;
        rankingReturnList[code + element.code] = {
          label: label2 + " - " + stripTags(
            ((_b2 = (_a2 = state[element.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[mainLang]) || ""
          ),
          type: "number",
          fieldSettings: {
            min: 1,
            max: component.children.length
          },
          valueSources: ["value"],
          operators: [
            "is_void",
            "is_not_void",
            "equal",
            "not_equal",
            "less",
            "less_or_equal",
            "greater",
            "greater_or_equal",
            "between",
            "not_between"
          ]
        };
      });
      return rankingReturnList;
    default:
      return [];
  }
};
const relevance = "_relevance_1j5a5_1";
const relevanceError = "_relevanceError_1j5a5_5";
const errorContainer = "_errorContainer_1j5a5_9";
const styles$b = {
  relevance,
  relevanceError,
  errorContainer
};
function Relevance({ code, t: t2 }) {
  var _a, _b, _c;
  const dispatch = useDispatch();
  const [logicDialogOpen, setLogicDialogOpen] = reactExports.useState(false);
  const designState = useSelector((state2) => {
    return state2.designState;
  });
  const langInfo = React.useMemo(() => designState.langInfo);
  const state = React.useMemo(() => designState[code]);
  const fields = React.useMemo(
    () => buildFields(
      designState.componentIndex,
      code,
      designState,
      langInfo.mainLang,
      langInfo.languagesList.map((lang2) => lang2.code)
    ),
    [designState]
  );
  const instruction = (_a = state.instructionList) == null ? void 0 : _a.find(
    (instruction2) => instruction2.code == "conditional_relevance"
  );
  const errors = (instruction == null ? void 0 : instruction.errors) || [];
  const hasErrors = errors.length > 0;
  const logic2 = (_b = state.relevance) == null ? void 0 : _b.logic;
  const logicDisabled = !hasErrors && Object.keys(fields).length > 0;
  const [rule3, setRule] = reactExports.useState(((_c = state.relevance) == null ? void 0 : _c.rule) || "show_always");
  const shouldHaveLogic = rule3 == "show_if" || rule3 == "hide_if";
  const onRuleChange = (rule22) => {
    setRule(rule22);
    switch (rule22) {
      case "show_always":
        reset2();
        return;
      case "hide_always":
        dispatch(
          changeRelevance({
            code,
            key: "relevance",
            value: { logic: void 0, rule: rule22 }
          })
        );
        return;
      case "show_if":
      case "hide_if":
        if ((logic2 == null ? void 0 : logic2.rule) != "show_if" && (logic2 == null ? void 0 : logic2.rule) != "hide_if") {
          setLogicDialogOpen(true);
        }
        if (logic2) {
          dispatch(
            changeRelevance({
              code,
              key: "relevance",
              value: { logic: logic2, rule: rule22 }
            })
          );
        }
        return;
    }
  };
  const reset2 = () => dispatch(
    changeRelevance({
      code,
      key: "relevance",
      value: { logic: void 0, rule: "show_always" }
    })
  );
  const onLogicChange = (logic22) => {
    setLogicDialogOpen(false);
    if (shouldHaveLogic) {
      dispatch(
        changeRelevance({
          code,
          key: "relevance",
          value: { logic: logic22, rule: rule3 }
        })
      );
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "".concat(hasErrors ? styles$b.relevanceError : ""), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { variant: "standard", fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Select,
      {
        id: "show-hide-select",
        value: rule3,
        label: "Age",
        onChange: (e2) => onRuleChange(e2.target.value),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { disabled: hasErrors, value: "show_always", children: t2("show_always") }, "show_always"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { disabled: !logicDisabled, value: "show_if", children: t2("show_if") }, "show_if"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { disabled: !logicDisabled, value: "hide_if", children: t2("hide_if") }, "hide_if"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { disabled: hasErrors, value: "hide_always", children: t2("hide_always") }, "hide_always")
        ]
      }
    ) }),
    !hasErrors && shouldHaveLogic && /* @__PURE__ */ jsxRuntimeExports.jsx(
      LogicBuilder,
      {
        title: rule3 == "show_if" ? t2("condition_to_show") : t2("condition_to_hide"),
        onChange: onLogicChange,
        onDialogStateChanged: (state2) => setLogicDialogOpen(state2),
        fields,
        t: t2,
        dialogOpen: logicDialogOpen,
        logic: logic2
      }
    ),
    hasErrors ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$b.errorContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Trans, { t: t2, i18nKey: "wrong_logic_err" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", onClick: () => reset2(), children: "OK" })
    ] }) : "",
    shouldHaveLogic && !logic2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trans, { t: t2, i18nKey: "no_logic_err" }) }) : ""
  ] });
}
const buildField = (code, state, mainLang) => {
  var _a, _b;
  const component = state[code];
  const label2 = code + ". " + stripTags((_b = (_a = component.content) == null ? void 0 : _a.label) == null ? void 0 : _b[mainLang]);
  return { code, label: label2 };
};
const jumpDestinations = (componentIndices, code, state, mainLang) => {
  let dependencies2 = [];
  if (!componentIndices) {
    return dependencies2;
  }
  let componentIndex = componentIndices.find(
    (element) => element.code === code
  );
  if (!componentIndex) {
    return dependencies2;
  }
  dependencies2 = dependencies2.concat(
    accessibleSiblings(componentIndices, componentIndex, state, mainLang)
  );
  if (componentIndex.parent) {
    parents(componentIndices, componentIndex).filter((elem) => isQuestion(elem.code) || isGroup(elem.code)).forEach((element) => {
      dependencies2 = dependencies2.concat(
        accessibleSiblings(componentIndices, element, state, mainLang)
      );
    });
  }
  return dependencies2;
};
const parents = (componentIndices, componentIndex) => {
  let result = [];
  let parent2 = componentIndices.find(
    (element) => element.code === componentIndex.parent
  );
  if (parent2 && parent2.parent) {
    result.push(parent2);
    result = result.concat(parents(componentIndices, parent2));
  }
  return result;
};
const accessibleSiblings = (componentIndices, componentIndex, state, mainLang) => {
  let result = [];
  if (!isGroup(componentIndex.code) && !isQuestion(componentIndex.code)) {
    return result;
  }
  let accessibleSiblings2 = componentIndices.filter((elem) => {
    return elem.parent == componentIndex.parent && elem.minIndex > componentIndex.maxIndex && (!componentIndex.prioritisedSiblings || componentIndex.prioritisedSiblings.indexOf(elem.code) === -1);
  });
  accessibleSiblings2.forEach((sibling) => {
    result = result.concat(buildField(sibling.code, state, mainLang));
    result = result.concat(
      childrenDependencies(componentIndices, sibling, state, mainLang)
    );
  });
  return result;
};
const childrenDependencies = (componentIndices, componentIndex, state, mainLang) => {
  let result = [];
  if (!isGroup(componentIndex.code)) {
    return result;
  }
  if (componentIndex.children) {
    componentIndex.children.forEach((childCode) => {
      let child = componentIndices.find(
        (element) => element.code === childCode
      );
      result = result.concat(buildField(child.code, state, mainLang));
      result = result.concat(
        childrenDependencies(componentIndices, child, state, mainLang)
      );
    });
  }
  return result;
};
const skipItem = "_skipItem_1n8m2_1";
const toEnd = "_toEnd_1n8m2_6";
const styles$a = {
  skipItem,
  toEnd
};
function SkipLogic({ code, t: t2 }) {
  const dispatch = useDispatch();
  const skipLogic = useSelector((state) => {
    return state.designState[code].skip_logic || {};
  });
  const destinations = useSelector((state) => {
    const mainLang = state.designState.langInfo.mainLang;
    return jumpDestinations(
      state.designState.componentIndex,
      code,
      state.designState,
      mainLang
    );
  });
  const instructions = useSelector((state) => {
    return state.designState[code].instructionList.filter(
      (el) => el.code.startsWith("skip_to")
    );
  });
  const children = useSelector((state) => {
    var _a, _b;
    const lang2 = state.designState.langInfo.lang;
    return (_b = (_a = state.designState[code]) == null ? void 0 : _a.children) == null ? void 0 : _b.map((child) => {
      var _a2, _b2;
      return {
        code: child.code,
        label: ((_b2 = (_a2 = state.designState[child.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[lang2]) || child.code
      };
    });
  });
  const onChange = (answerCode, targetCode) => {
    if (targetCode == "proceed") {
      dispatch(removeSkipDestination({ code, answerCode }));
    } else {
      dispatch(editSkipDestination({ code, answerCode, skipTo: targetCode }));
    }
  };
  const onToEndChanged = (answerCode, checked) => {
    dispatch(editSkipToEnd({ code, answerCode, toEnd: checked }));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: children == null ? void 0 : children.map((element) => {
    var _a, _b;
    const code2 = element.code;
    const original = skipLogic == null ? void 0 : skipLogic[code2];
    const skipTo = original == null ? void 0 : original.skipTo;
    const skipToCode = skipTo || "proceed";
    const invalidSkipDestination = skipTo && ((_b = (_a = instructions == null ? void 0 : instructions.find((el) => el.code == "skip_to_on_" + code2)) == null ? void 0 : _a.errors) == null ? void 0 : _b.find((el) => el.name == "InvalidSkipReference"));
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$a.skipItem, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Trans,
        {
          t: t2,
          values: { code: element.label },
          i18nKey: "if_answer_is"
        }
      ),
      invalidSkipDestination ? skipValueError(code2, skipTo, onChange, t2) : skipSelectValue(
        code2,
        destinations,
        skipToCode,
        original == null ? void 0 : original.toEnd,
        onChange,
        onToEndChanged,
        t2
      )
    ] }, element.code);
  }) });
}
function skipValueError(answerCode, skipToCode, onChange, t2) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$a.errorDisplay, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorOutlineOutlined, { style: { verticalAlign: "middle" } }),
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Trans,
      {
        t: t2,
        values: { code: skipToCode },
        i18nKey: "invalid_skip_destination_err"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        variant: "contained",
        onClick: () => onChange(answerCode, "proceed"),
        children: t2("ok")
      }
    )
  ] });
}
function skipSelectValue(answerCode, destinations, skipToCode, toEnd2, onChange, onToEndChanged, t2) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { variant: "standard", fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Select,
      {
        id: "skip-action",
        value: skipToCode,
        label: t2("skip_to"),
        onChange: (e2) => onChange(answerCode, e2.target.value),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "proceed", children: t2("proceed_as_usual") }, "proceed"),
          destinations && (destinations == null ? void 0 : destinations.map((element) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: element.code, children: element.label }, element.code);
          }))
        ]
      }
    ) }),
    skipToCode && skipToCode.startsWith("G") && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$a.toEnd, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: t2("to_group_end") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Switch,
        {
          checked: toEnd2 || false,
          onChange: (event) => onToEndChanged(answerCode, event.target.checked)
        }
      )
    ] })
  ] });
}
const sectionTitle = "_sectionTitle_nmfqz_1";
const rightContent = "_rightContent_nmfqz_6";
const close = "_close_nmfqz_13";
const accordionStyle = "_accordionStyle_nmfqz_17";
const styles$9 = {
  sectionTitle,
  rightContent,
  close,
  accordionStyle
};
const errorDisplay$1 = "_errorDisplay_1avr2_1";
const styles$8 = {
  errorDisplay: errorDisplay$1
};
function RandomError({ errors }) {
  const { t: t2 } = useTranslation("design");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: styles$8.errorDisplay, children: errors.map((error2) => {
    if (error2.name == "PriorityGroupItemNotChild") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Trans,
        {
          t: t2,
          i18nKey: "err_priority_group_item_not_child",
          values: { items: error2.items.join(", ") }
        },
        error2.name
      );
    } else if (error2.name == "DuplicatePriorityGroupItems") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Trans,
        {
          t: t2,
          i18nKey: "err_duplicate_priority_group_items",
          values: { items: error2.items.join(", ") }
        },
        error2.name
      );
    } else if (error2.name == "PriorityLimitMismatch") {
      return t2("err_priority_limit_mismatch");
    } else if (error2.name == "RandomGroupItemNotChild") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Trans,
        {
          t: t2,
          i18nKey: "err_random_group_item_not_child",
          values: { items: error2.items.join(", ") }
        },
        error2.name
      );
    } else if (error2.name == "DuplicateRandomGroupItems") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Trans,
        {
          t: t2,
          i18nKey: "err_duplicate_random_group_items",
          values: { items: error2.items.join(", ") }
        },
        error2.name
      );
    }
  }) }, "box");
}
const randomHeader$1 = "_randomHeader_1pjix_1";
const title$3 = "_title_1pjix_6";
const action$1 = "_action_1pjix_11";
const settingIcon$1 = "_settingIcon_1pjix_15";
const randomBody$1 = "_randomBody_1pjix_19";
const list$3 = "_list_1pjix_19";
const weight$1 = "_weight_1pjix_30";
const randomAction$3 = "_randomAction_1pjix_47";
const listItem$3 = "_listItem_1pjix_53";
const label$2 = "_label_1pjix_58";
const input$3 = "_input_1pjix_64";
const listItemError$1 = "_listItemError_1pjix_68";
const randomItem$3 = "_randomItem_1pjix_84";
const highlighted$1 = "_highlighted_1pjix_89";
const styles$7 = {
  randomHeader: randomHeader$1,
  title: title$3,
  action: action$1,
  settingIcon: settingIcon$1,
  randomBody: randomBody$1,
  list: list$3,
  weight: weight$1,
  randomAction: randomAction$3,
  listItem: listItem$3,
  label: label$2,
  input: input$3,
  listItemError: listItemError$1,
  randomItem: randomItem$3,
  highlighted: highlighted$1
};
var Mode = {};
var _interopRequireDefault$d = interopRequireDefaultExports;
Object.defineProperty(Mode, "__esModule", {
  value: true
});
var default_1$5 = Mode.default = void 0;
var _createSvgIcon$5 = _interopRequireDefault$d(requireCreateSvgIcon());
var _jsxRuntime$5 = jsxRuntimeExports;
default_1$5 = Mode.default = (0, _createSvgIcon$5.default)(/* @__PURE__ */ (0, _jsxRuntime$5.jsx)("path", {
  d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 5.63l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83c.39-.39.39-1.02 0-1.41"
}), "Mode");
function PriorityItemDisplay(props) {
  var _a;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Card,
    {
      className: "".concat(styles$7.randomItem, " ").concat(props.isBeingEdited ? styles$7.highlighted : ""),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7.randomHeader, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: styles$7.title, children: props.t("prioritise") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7.action, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => props.onEditClicked(props.index), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$5, { className: styles$7.settingIcon }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => props.onDeleteClicked(props.index), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, { className: styles$7.settingIcon }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7.randomBody, children: [
          props.t("priority_show_limit_from_count", {
            limit: props.data.limit,
            count: (_a = props.data.weights) == null ? void 0 : _a.length
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: styles$7.list, children: props.data && props.data.weights && props.data.weights.map((nestedItem, index2) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              PrioritisedChildDisplay$1,
              {
                label: props.getChildLabelByCode(nestedItem.code),
                code: nestedItem.code,
                childrenCodes: props.childrenCodes,
                weight: nestedItem.weight
              },
              index2
            );
          }) })
        ] })
      ]
    }
  );
}
function PrioritisedChildDisplay$1({ code, label: label2, weight: weight2, childrenCodes }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "li",
    {
      className: childrenCodes.indexOf(code) !== -1 ? styles$7.listItem : styles$7.listItemError,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "".concat(styles$7.content, " ").concat(styles$7.label), children: [
          code,
          ": ",
          label2
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$7.weight, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: weight2 }) })
      ]
    }
  );
}
const title$2 = "_title_5cg20_1";
const randomBody = "_randomBody_5cg20_6";
const list$2 = "_list_5cg20_6";
const weight = "_weight_5cg20_18";
const label$1 = "_label_5cg20_35";
const randomAction$2 = "_randomAction_5cg20_39";
const listItem$2 = "_listItem_5cg20_45";
const input$2 = "_input_5cg20_50";
const randomItem$2 = "_randomItem_5cg20_54";
const styles$6 = {
  title: title$2,
  randomBody,
  list: list$2,
  weight,
  label: label$1,
  randomAction: randomAction$2,
  listItem: listItem$2,
  input: input$2,
  randomItem: randomItem$2
};
var RemoveCircle = {};
var _interopRequireDefault$c = interopRequireDefaultExports;
Object.defineProperty(RemoveCircle, "__esModule", {
  value: true
});
var default_1$4 = RemoveCircle.default = void 0;
var _createSvgIcon$4 = _interopRequireDefault$c(requireCreateSvgIcon());
var _jsxRuntime$4 = jsxRuntimeExports;
default_1$4 = RemoveCircle.default = (0, _createSvgIcon$4.default)(/* @__PURE__ */ (0, _jsxRuntime$4.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m5 11H7v-2h10z"
}), "RemoveCircle");
var AddCircle = {};
var _interopRequireDefault$b = interopRequireDefaultExports;
Object.defineProperty(AddCircle, "__esModule", {
  value: true
});
var default_1$3 = AddCircle.default = void 0;
var _createSvgIcon$3 = _interopRequireDefault$b(requireCreateSvgIcon());
var _jsxRuntime$3 = jsxRuntimeExports;
default_1$3 = AddCircle.default = (0, _createSvgIcon$3.default)(/* @__PURE__ */ (0, _jsxRuntime$3.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m5 11h-4v4h-2v-4H7v-2h4V7h2v4h4z"
}), "AddCircle");
function PriorityItemSetup(props) {
  const t2 = props.t;
  const [checked, setChecked] = reactExports.useState(props.checked);
  const [data, setData] = reactExports.useState(props.data);
  const isSubmitEnabled = () => {
    const checkCount = checked.filter((x) => x).length;
    return checkCount >= 2 && data.limit <= checkCount - 1 && data.limit >= 1;
  };
  const onSubmit = () => {
    const selected = checked.filter((x) => x).length;
    if (selected < 2) {
      return false;
    }
    const submitData = { ...data };
    const weightsData = checked.reduce((sum, el, i2) => {
      if (el) {
        sum.push(submitData.weights[i2]);
      }
      return sum;
    }, []);
    props.onSubmit({
      ...submitData,
      weights: weightsData
    });
  };
  const handleCheckboxChange = (e2, i2) => {
    const cloneChecked = [...checked];
    cloneChecked[i2] = e2;
    setChecked([...cloneChecked]);
  };
  const changeLimit = (limit) => {
    setData({
      ...data,
      limit
    });
  };
  const changeWeight = (e2, i2) => {
    const newData = { ...data };
    newData.weights = [...data.weights];
    newData.weights[i2] = { ...data.weights[i2], weight: e2 };
    setData(newData);
  };
  const decreaseLimit = (limit) => {
    if (limit === 1) {
      return false;
    }
    limit--;
    changeLimit(limit);
  };
  const increaseLimit = (limit) => {
    if (limit === data.weights.length - 1) {
      return false;
    }
    limit++;
    changeLimit(limit);
  };
  const decreaseWeight = (e2, i2) => {
    if (e2 === 1) {
      return false;
    }
    e2--;
    changeWeight(e2, i2);
  };
  const increaseWeight = (e2, i2) => {
    e2++;
    changeWeight(e2, i2);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: styles$6.randomItem, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: styles$6.title, children: props.title }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.randomBody, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PriorityLimitController,
        {
          t: t2,
          increaseLimit,
          decreaseLimit,
          limit: data.limit
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "".concat(styles$6.list, " ").concat(styles$6.active), children: data && data.weights && data.weights.map((nestedItem, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        PrioritisedChildDisplay,
        {
          code: nestedItem.code,
          weight: nestedItem.weight,
          handleChange: (checked2) => handleCheckboxChange(checked2, index2),
          decreaseWeight: (weight2) => decreaseWeight(weight2, index2),
          increaseWeight: (weight2) => increaseWeight(weight2, index2),
          checked: (checked == null ? void 0 : checked[index2]) || false,
          label: props.getChildLabelByCode(nestedItem.code)
        },
        index2
      )) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.randomAction, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "text", onClick: (e2) => props.onCancel(), children: t2("cancel") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "contained",
          onClick: (e2) => onSubmit(),
          disabled: !isSubmitEnabled(),
          children: t2("submit")
        }
      )
    ] })
  ] });
}
function PrioritisedChildDisplay({
  code,
  checked,
  label: label2,
  weight: weight2,
  handleChange,
  increaseWeight,
  decreaseWeight
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles$6.listItem, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        checked,
        onChange: (e2) => handleChange(e2.target.checked)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "".concat(styles$6.content, " ").concat(styles$6.label), children: [
      code,
      ": ",
      label2
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.weight, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", onClick: (e2) => decreaseWeight(weight2), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$4, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: weight2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", onClick: (e2) => increaseWeight(weight2), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$3, {}) })
    ] })
  ] });
}
function PriorityLimitController({ limit, increaseLimit, decreaseLimit, t: t2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    t2("priority_show"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", onClick: (e2) => decreaseLimit(limit), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$4, {}) }),
    limit,
    /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", onClick: (e2) => increaseLimit(limit), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$3, {}) })
  ] });
}
function CustomPriority({ t: t2, type: type2, code, hideErrors }) {
  var _a, _b;
  const dispatch = useDispatch();
  const [action2, setAction] = reactExports.useState({});
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const childrenCodes = useSelector((state2) => {
    var _a2, _b2, _c, _d;
    return ((_d = (_c = (_b2 = (_a2 = state2.designState[code]) == null ? void 0 : _a2.children) == null ? void 0 : _b2.filter((el) => type2 ? el.type == type2 : true)) == null ? void 0 : _c.filter(
      (el) => {
        var _a3, _b3;
        return ((_a3 = el.groupType) == null ? void 0 : _a3.toLowerCase()) != "welcome" && ((_b3 = el.groupType) == null ? void 0 : _b3.toLowerCase()) != "end";
      }
    )) == null ? void 0 : _d.map((el) => el.code)) || [];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  const childrenLabels = useSelector((state2) => {
    var _a2, _b2, _c;
    return ((_c = (_b2 = (_a2 = state2.designState[code]) == null ? void 0 : _a2.children) == null ? void 0 : _b2.filter((el) => type2 ? el.type == type2 : true)) == null ? void 0 : _c.map((child) => {
      var _a3, _b3;
      return {
        code: child.code,
        label: (_b3 = (_a3 = state2.designState[child.qualifiedCode].content) == null ? void 0 : _a3.label) == null ? void 0 : _b3[lang2]
      };
    })) || [];
  });
  const priorityInstruction = instructionByCode(state, "priority_groups");
  const priorities2 = ((_a = priorityInstruction == null ? void 0 : priorityInstruction.priorities) == null ? void 0 : _a.filter(
    (priority) => type2 ? priority.weights.some((el) => childrenCodes.includes(el.code)) : true
  )) || [];
  let allCodesinPriority = priorities2.map((priority) => priority.weights).flat().map((weight2) => weight2.code).flat();
  const priorityErrors = ((_b = priorityInstruction == null ? void 0 : priorityInstruction.errors) == null ? void 0 : _b.filter(
    (error2) => error2.items.some((item) => allCodesinPriority.includes(item))
  )) || [];
  const updatePriorities = (priorities22) => {
    dispatch(
      type2 ? updatePriorityByType({ code, priorities: priorities22, type: type2 }) : updatePriority({ code, priorities: priorities22 })
    );
  };
  const getChildLabelByCode = (code2) => {
    var _a2;
    const label2 = (_a2 = childrenLabels.find((el) => el.code == code2)) == null ? void 0 : _a2.label;
    return label2 == null ? void 0 : label2.replace(/<[^>]*>/g, "");
  };
  const getUnPrioritisedChildrenCodes = () => {
    return childrenCodes.filter((el) => !allCodesinPriority.includes(el));
  };
  const onDeleteClicked = (index2) => {
    if (window.confirm(t2("are_you_sure"))) {
      updatePriorities(priorities2.filter((el, i2) => i2 !== index2));
    }
  };
  const isActionEmpty = !action2 || Object.keys(action2).length == 0;
  const onEditClicked = (index2) => {
    let checked = [];
    let data = [];
    data.weights = [];
    const unPrioritised = getUnPrioritisedChildrenCodes();
    childrenCodes.forEach((code2) => {
      if (unPrioritised.includes(code2)) {
        data.weights.push({ code: code2, weight: 1 });
        checked.push(false);
      } else {
        let weightIndex = priorities2[index2].weights.findIndex(
          (weight2) => weight2.code == code2
        );
        if (weightIndex > -1) {
          data.weights.push(priorities2[index2].weights[weightIndex]);
          checked.push(true);
        }
      }
      data.limit = priorities2[index2].limit;
    });
    setAction({
      index: index2,
      checked,
      title: t2("edit_priority_rule"),
      data
    });
  };
  const resetData = () => {
    setAction({});
  };
  const onSubmit = (value, index2) => {
    const newPriorities = priorities2 ? [...priorities2] : [];
    newPriorities[index2] = { ...value };
    updatePriorities(newPriorities);
    resetData();
  };
  const addNewPriority = () => {
    const listQuestionCode = getUnPrioritisedChildrenCodes();
    const weights = listQuestionCode.map((el) => ({
      code: el,
      weight: 1
    }));
    setAction({
      title: t2("add_priority_rule"),
      checked: listQuestionCode.map((el) => false),
      data: {
        limit: 1,
        weights
      },
      index: priorities2 ? priorities2.length : 0,
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$j, {})
    });
  };
  const sortPriorityItem = (item) => {
    let newWeights = [...item.weights].sort(function(a2, b) {
      return childrenCodes.findIndex((x) => x === a2.code) - childrenCodes.findIndex((x) => x === b.code);
    });
    return { ...item, weights: newWeights };
  };
  const sanitize = (data, childrenCodes2) => {
    let weights = [...data.weights].filter(
      (el) => childrenCodes2.includes(el.code)
    );
    if (weights.length <= 1) {
      resetData();
    }
    return {
      limit: Math.min(data.limit, weights.length - 1),
      weights
    };
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    priorities2 && priorities2.map((item, i2) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        PriorityItemDisplay,
        {
          t: t2,
          data: sortPriorityItem(item),
          index: i2,
          childrenCodes,
          isBeingEdited: action2.index == i2,
          onDeleteClicked: (index2) => {
            setAction({});
            onDeleteClicked(index2);
          },
          onEditClicked: (index2) => onEditClicked(index2),
          getChildLabelByCode
        },
        i2
      );
    }),
    !hideErrors && priorityErrors.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(RandomError, { errors: priorityErrors }) : "",
    isActionEmpty && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button,
      {
        variant: "contained",
        disabled: getUnPrioritisedChildrenCodes().length < 2,
        onClick: addNewPriority,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$j, { sx: { paddingRight: "8px" } }),
          " ",
          t2("add_priority_rule")
        ]
      }
    ),
    action2 && action2.data && /* @__PURE__ */ jsxRuntimeExports.jsx(
      PriorityItemSetup,
      {
        t: t2,
        title: action2.title,
        data: sanitize(action2.data, childrenCodes),
        index: action2.index,
        getChildLabelByCode,
        checked: action2.checked,
        onSubmit: (data) => onSubmit(data, action2.index),
        onCancel: resetData
      }
    )
  ] });
}
const selectValue = "_selectValue_14l81_1";
const styles$5 = {
  selectValue
};
const errorDisplay = "_errorDisplay_1vtlj_1";
const addNew = "_addNew_1vtlj_10";
const styles$4 = {
  errorDisplay,
  addNew
};
const title$1 = "_title_1p7e9_1";
const list$1 = "_list_1p7e9_6";
const randomAction$1 = "_randomAction_1p7e9_19";
const listItem$1 = "_listItem_1p7e9_25";
const input$1 = "_input_1p7e9_30";
const randomItem$1 = "_randomItem_1p7e9_34";
const styles$3 = {
  title: title$1,
  list: list$1,
  randomAction: randomAction$1,
  listItem: listItem$1,
  input: input$1,
  randomItem: randomItem$1
};
function RandomItemSetup(props) {
  const t2 = props.t;
  const [checked, setChecked] = reactExports.useState(props.checked);
  const [randomOption, setRandomOption] = reactExports.useState(props.randomOption);
  const isSubmitEnabled = () => {
    return checked.filter((x) => x).length >= 2;
  };
  const labels = [t2("random_order"), t2("flip_order"), t2("sort_by_label")];
  const values2 = ["RANDOM", "FLIP", "ALPHA"];
  const onSubmit = () => {
    const selected = checked.filter((x) => x).length;
    if (selected < 2) {
      return false;
    }
    const submitList = checked.reduce((sum, el, i2) => {
      if (el) {
        sum.push(props.data[i2]);
      }
      return sum;
    }, []);
    props.onSubmit(submitList, randomOption);
  };
  const handleCheckboxChange = (e2, i2) => {
    const cloneChecked = [...checked];
    cloneChecked[i2] = e2;
    setChecked([...cloneChecked]);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: styles$3.randomItem, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: styles$3.title, children: props.title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { variant: "standard", fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Select,
      {
        id: "select-value",
        value: randomOption,
        label: "Select Value",
        onChange: (e2) => {
          setRandomOption(e2.target.value);
        },
        children: labels.map((element, index2) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: values2[index2], children: element }, element);
        })
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: styles$3.list, children: props.data && props.data.map((code, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      RandomisedChildDisplay$1,
      {
        code,
        handleChange: (checked2) => handleCheckboxChange(checked2, index2),
        checked: (checked == null ? void 0 : checked[index2]) || false,
        label: props.getChildLabelByCode(code)
      },
      index2
    )) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.randomAction, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "text", onClick: (e2) => props.onCancel(), children: t2("cancel") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "contained",
          onClick: (e2) => onSubmit(),
          disabled: !isSubmitEnabled(),
          children: t2("submit")
        }
      )
    ] })
  ] });
}
function RandomisedChildDisplay$1({ code, label: label2, checked, handleChange }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles$3.listItem, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        checked,
        onChange: (e2) => handleChange(e2.target.checked)
      }
    ),
    code,
    ": ",
    label2
  ] });
}
const randomHeader = "_randomHeader_10d2m_1";
const title = "_title_10d2m_6";
const action = "_action_10d2m_11";
const settingIcon = "_settingIcon_10d2m_15";
const list = "_list_10d2m_19";
const randomAction = "_randomAction_10d2m_30";
const listItem = "_listItem_10d2m_36";
const label = "_label_10d2m_41";
const input = "_input_10d2m_47";
const listItemError = "_listItemError_10d2m_51";
const randomItem = "_randomItem_10d2m_63";
const highlighted = "_highlighted_10d2m_68";
const styles$2 = {
  randomHeader,
  title,
  action,
  settingIcon,
  list,
  randomAction,
  listItem,
  label,
  input,
  listItemError,
  randomItem,
  highlighted
};
const randomOptionToText = (randomOption, t2) => {
  switch (randomOption) {
    case "ALPHA":
      return t2("sort_by_label");
    case "RANDOM":
      return t2("random_order");
    case "FLIP":
      return t2("flip_order");
  }
  throw "unidentified randomOption: " + randomOption;
};
function RandomItemDisplay(props) {
  const t2 = props.t;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Card,
    {
      className: "".concat(styles$2.randomItem, " ").concat(props.isBeingEdited ? styles$2.highlighted : ""),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.randomHeader, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: styles$2.title, children: randomOptionToText(props.randomOption, t2) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.action, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => props.onEditClicked(props.index), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$5, { className: styles$2.settingIcon }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => props.onDeleteClicked(props.index), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, { className: styles$2.settingIcon }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: styles$2.list, children: props.data && props.data.map((code, index2) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            RandomisedChildDisplay,
            {
              label: props.getChildLabelByCode(code),
              code,
              childrenCodes: props.childrenCodes
            },
            index2
          );
        }) })
      ]
    }
  );
}
function RandomisedChildDisplay({ code, label: label2, childrenCodes }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "li",
    {
      className: childrenCodes.indexOf(code) !== -1 ? styles$2.listItem : styles$2.listItemError,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "".concat(styles$2.content, " ").concat(styles$2.label), children: [
        code,
        ": ",
        label2
      ] })
    }
  );
}
function CustomRandom({ t: t2, type: type2, code, hideErrors }) {
  var _a, _b;
  const dispatch = useDispatch();
  const [action2, setAction] = reactExports.useState({});
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const childrenCodes = useSelector((state2) => {
    var _a2, _b2, _c, _d;
    return ((_d = (_c = (_b2 = (_a2 = state2.designState[code]) == null ? void 0 : _a2.children) == null ? void 0 : _b2.filter((el) => type2 ? el.type == type2 : true)) == null ? void 0 : _c.filter(
      (el) => {
        var _a3, _b3;
        return ((_a3 = el.groupType) == null ? void 0 : _a3.toLowerCase()) != "welcome" && ((_b3 = el.groupType) == null ? void 0 : _b3.toLowerCase()) != "end";
      }
    )) == null ? void 0 : _d.map((el) => el.code)) || [];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  const childrenLabels = useSelector((state2) => {
    var _a2, _b2, _c;
    return ((_c = (_b2 = (_a2 = state2.designState[code]) == null ? void 0 : _a2.children) == null ? void 0 : _b2.filter((el) => type2 ? el.type == type2 : true)) == null ? void 0 : _c.map((child) => {
      var _a3, _b3;
      return {
        code: child.code,
        label: (_b3 = (_a3 = state2.designState[child.qualifiedCode].content) == null ? void 0 : _a3.label) == null ? void 0 : _b3[lang2]
      };
    })) || [];
  });
  const randomInstruction = instructionByCode(state, "random_group");
  const randomOrders = ((_a = randomInstruction == null ? void 0 : randomInstruction.groups) == null ? void 0 : _a.filter(
    (group3) => type2 ? group3.codes.some((code2) => childrenCodes.includes(code2)) : true
  )) || [];
  const allCodesinRandomOrders = randomOrders.map((it) => it.codes).flat();
  const randomErrors = ((_b = randomInstruction == null ? void 0 : randomInstruction.errors) == null ? void 0 : _b.filter(
    (error2) => error2.items.some((item) => allCodesinRandomOrders.includes(item))
  )) || [];
  const updateRandomOrders = (groups) => {
    dispatch(
      type2 ? updateRandomByType({ code, groups, type: type2 }) : updateRandom({ code, groups })
    );
  };
  const getChildLabelByCode = (code2) => {
    var _a2;
    const label2 = (_a2 = childrenLabels.find((el) => el.code == code2)) == null ? void 0 : _a2.label;
    return label2 == null ? void 0 : label2.replace(/<[^>]*>/g, "");
  };
  const getUnrandomisedChildrenCodes = (data) => {
    return childrenCodes.filter((el) => !allCodesinRandomOrders.includes(el));
  };
  const onDeleteClicked = (index2) => {
    if (window.confirm(t2("are_you_sure"))) {
      updateRandomOrders(randomOrders.filter((el, i2) => i2 !== index2));
    }
  };
  const sortRandomItem = (item) => {
    return [...item.codes].sort(function(a2, b) {
      return childrenCodes.findIndex((x) => x === a2) - childrenCodes.findIndex((x) => x === b);
    });
  };
  const onEditClicked = (index2) => {
    let checked = [];
    let data = [];
    let unrandomized = getUnrandomisedChildrenCodes();
    data = childrenCodes.filter(
      (el) => unrandomized.includes(el) || randomOrders[index2].codes.includes(el)
    );
    checked = data.map(
      (el) => randomOrders[index2].codes.includes(el) ? true : false
    );
    setAction({
      index: index2,
      checked,
      randomOption: randomOrders[index2].randomOption || "RANDOM",
      title: t2("edit_random_rule"),
      data
    });
  };
  const resetData = () => {
    setAction({});
  };
  const isActionEmpty = !action2 || Object.keys(action2).length == 0;
  const onSubmit = (value, randomOption, index2) => {
    const newRandomOrders = randomOrders ? [...randomOrders] : [];
    newRandomOrders[index2] = { codes: value, randomOption };
    updateRandomOrders(newRandomOrders);
    resetData();
  };
  const addNewRule = () => {
    const data = getUnrandomisedChildrenCodes();
    setAction({
      title: t2("add_new_random_rule"),
      data,
      checked: [],
      randomOption: "RANDOM",
      index: randomOrders ? randomOrders.length : 0
    });
  };
  const sanitize = (data, childrenCodes2) => {
    let groups = [...data].filter((code2) => childrenCodes2.includes(code2));
    if (groups.length <= 1) {
      resetData();
    }
    return groups;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    randomOrders && randomOrders.map((item, i2) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        RandomItemDisplay,
        {
          t: t2,
          data: sortRandomItem(item),
          randomOption: item.randomOption,
          index: i2,
          isBeingEdited: action2.index == i2,
          childrenCodes,
          getChildLabelByCode,
          onDeleteClicked: (index2) => {
            setAction({});
            onDeleteClicked(index2);
          },
          onEditClicked: (index2) => onEditClicked(index2)
        },
        i2
      );
    }),
    !hideErrors && randomErrors.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(RandomError, { errors: randomErrors }) : "",
    isActionEmpty && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button,
      {
        className: styles$4.addNew,
        variant: "contained",
        disabled: getUnrandomisedChildrenCodes().length < 2,
        onClick: addNewRule,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$k, { sx: { paddingRight: "8px" } }),
          " ",
          t2("add_random_rule")
        ]
      }
    ),
    action2 && action2.data && /* @__PURE__ */ jsxRuntimeExports.jsx(
      RandomItemSetup,
      {
        t: t2,
        title: action2.title,
        data: sanitize(action2.data, childrenCodes),
        randomOption: action2.randomOption,
        getChildLabelByCode,
        checked: action2.checked,
        onSubmit: (data, randomOption) => onSubmit(data, randomOption, action2.index),
        onCancel: resetData
      }
    )
  ] });
}
function OrderPrioritySetup({ t: t2, rule: rule3, code }) {
  const dispatch = useDispatch();
  const value = useSelector((state) => {
    return state.designState[code][rule3] || "NONE";
  });
  let title2 = "";
  let labels = [];
  let values2 = [];
  switch (rule3) {
    case "randomize_questions":
      title2 = t2("questions_order");
      labels = [
        t2("as_is"),
        t2("random_order"),
        t2("flip_order"),
        t2("custom_random")
      ];
      values2 = ["NONE", "RANDOM", "FLIP", "custom"];
      break;
    case "prioritize_questions":
      title2 = t2("questions_priority");
      labels = [t2("no_priority"), t2("prioritise_questions")];
      values2 = ["NONE", "prioritize"];
      break;
    case "randomize_groups":
      title2 = t2("groups_order");
      labels = [
        t2("as_is"),
        t2("random_order"),
        t2("flip_order"),
        t2("custom_random")
      ];
      values2 = ["NONE", "RANDOM", "FLIP", "custom"];
      break;
    case "prioritize_groups":
      title2 = t2("groups_priority");
      labels = [t2("no_priority"), t2("prioritise_groups")];
      values2 = ["NONE", "prioritize"];
      break;
    case "randomize_options":
      title2 = t2("options_order");
      labels = [
        t2("as_is"),
        t2("random_order"),
        t2("flip_order"),
        t2("sort_by_label"),
        t2("custom_random")
      ];
      values2 = ["NONE", "RANDOM", "FLIP", "ALPHA", "custom"];
      break;
    case "prioritize_options":
      title2 = t2("options_priority");
      labels = [t2("no_priority"), t2("prioritise_options")];
      values2 = ["NONE", "prioritize"];
      break;
    case "randomize_rows":
      title2 = t2("rows_order");
      labels = [
        t2("as_is"),
        t2("random_order"),
        t2("flip_order"),
        t2("sort_by_label"),
        t2("custom_random")
      ];
      values2 = ["NONE", "RANDOM", "FLIP", "ALPHA", "custom"];
      break;
    case "prioritize_rows":
      title2 = t2("rows_priority");
      labels = [t2("no_priority"), t2("prioritise_rows")];
      values2 = ["NONE", "prioritize"];
      break;
    case "randomize_columns":
      title2 = t2("columns_order");
      labels = [
        t2("as_is"),
        t2("random_order"),
        t2("flip_order"),
        t2("sort_by_label"),
        t2("custom_random")
      ];
      values2 = ["NONE", "RANDOM", "FLIP", "ALPHA", "custom"];
      break;
    case "prioritize_columns":
      title2 = t2("columns_priority");
      labels = [t2("no_priority"), t2("prioritise_columns")];
      values2 = ["NONE", "prioritize"];
      break;
  }
  const onChange = (value2) => {
    const finalValue = value2 == "NONE" ? void 0 : value2;
    dispatch(changeAttribute({ code, key: rule3, value: finalValue }));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: title2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { className: styles$5.selectValue, variant: "standard", fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Select,
      {
        id: "select-value",
        value,
        label: "Select Value",
        onChange: (e2) => {
          onChange(e2.target.value);
        },
        children: labels.map((element, index2) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: values2[index2], children: element }, element);
        })
      }
    ) }),
    value == "custom" && [
      "randomize_questions",
      "randomize_options",
      "randomize_groups"
    ].indexOf(rule3) !== -1 && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomRandom, { label: "", code, t: t2 }),
    value == "custom" && "randomize_rows" == rule3 && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomRandom, { label: "", type: "row", code, t: t2 }),
    value == "prioritize" && "prioritize_rows" == rule3 && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomPriority, { label: "", type: "row", code, t: t2 }),
    value == "custom" && "randomize_columns" == rule3 && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomRandom, { label: "", type: "column", code, t: t2 }),
    value == "prioritize" && "prioritize_columns" == rule3 && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomPriority, { label: "", type: "column", code, t: t2 }),
    value == "prioritize" && [
      "prioritize_questions",
      "prioritize_options",
      "prioritize_groups"
    ].indexOf(rule3) !== -1 && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomPriority, { label: "", code, t: t2 })
  ] });
}
const NavigationMode = () => {
  const { t: t2 } = useTranslation("design");
  const dispatch = useDispatch();
  const value = useSelector((state) => {
    return state.designState.Survey.navigationMode || NAVIGATION_MODE.GROUP_BY_GROUP;
  });
  const onNavigationModeChanged = (event) => {
    dispatch(
      changeAttribute({
        code: "Survey",
        key: "navigationMode",
        value: event.target.value
      })
    );
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl, { fullWidth: true, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { id: "navigation-mode-label", children: t2("navigation_mode") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Select,
      {
        labelId: "navigation-mode-label",
        id: "demo-simple-select",
        value,
        label: t2("label.navigation_mode"),
        onChange: onNavigationModeChanged,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: NAVIGATION_MODE.GROUP_BY_GROUP, children: t2("group_by_group") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: NAVIGATION_MODE.QUESTION_BY_QUESTION, children: t2("question_by_question") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: NAVIGATION_MODE.ALL_IN_ONE, children: t2("all_in_one") })
        ]
      }
    )
  ] });
};
const theming = "_theming_1v217_1";
const chooseImage = "_chooseImage_1v217_12";
const resetButton = "_resetButton_1v217_21";
const fontText = "_fontText_1v217_24";
const selectDropdown$1 = "_selectDropdown_1v217_27";
const colorBox = "_colorBox_1v217_33";
const colorPickerContainer = "_colorPickerContainer_1v217_40";
const styles$1 = {
  theming,
  chooseImage,
  resetButton,
  fontText,
  selectDropdown: selectDropdown$1,
  colorBox,
  colorPickerContainer
};
const themingItem = "_themingItem_11qn9_1";
const themingItemBody = "_themingItemBody_11qn9_6";
const selectDropdown = "_selectDropdown_11qn9_13";
const styles = {
  themingItem,
  themingItemBody,
  selectDropdown
};
function ThemingItem(props) {
  const listFontSize = Array.from({ length: 12 }, (_, index2) => index2 * 2 + 10);
  function handleChange(key, value) {
    props.onChange({ ...props.value, [key]: value });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles.themingItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles.themingItemBody, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Select,
    {
      size: "small",
      value: props.value.size || props.default.size,
      onChange: (e2) => handleChange("size", e2.target.value),
      IconComponent: KeyboardArrowDown,
      className: styles.selectDropdown,
      sx: {
        "& .MuiSvgIcon-root": {
          color: "#16205b"
        }
      },
      children: listFontSize && listFontSize.length > 0 && listFontSize.map((el, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: el, children: el }, "fontSize-".concat(index2)))
    },
    "fontSize"
  ) }) });
}
var lib = {};
var flattenNames$1 = {};
var baseGetTag$1 = _baseGetTag, isArray$2 = isArray_1, isObjectLike$1 = isObjectLike_1;
var stringTag$2 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray$2(value) && isObjectLike$1(value) && baseGetTag$1(value) == stringTag$2;
}
var isString_1 = isString;
var identity$1 = identity_1;
function castFunction$2(value) {
  return typeof value == "function" ? value : identity$1;
}
var _castFunction = castFunction$2;
var baseForOwn$2 = _baseForOwn, castFunction$1 = _castFunction;
function forOwn(object, iteratee) {
  return object && baseForOwn$2(object, castFunction$1(iteratee));
}
var forOwn_1 = forOwn;
var isArrayLike$2 = isArrayLike_1;
function createBaseEach$2(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$2(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach$2;
var baseForOwn$1 = _baseForOwn, createBaseEach$1 = _createBaseEach;
var baseEach$2 = createBaseEach$1(baseForOwn$1);
var _baseEach = baseEach$2;
var baseEach$1 = _baseEach, isArrayLike$1 = isArrayLike_1;
function baseMap$2(collection, iteratee) {
  var index2 = -1, result = isArrayLike$1(collection) ? Array(collection.length) : [];
  baseEach$1(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
var _baseMap = baseMap$2;
var arrayMap$1 = _arrayMap, baseIteratee$1 = _baseIteratee, baseMap$1 = _baseMap, isArray$1 = isArray_1;
function map$1(collection, iteratee) {
  var func = isArray$1(collection) ? arrayMap$1 : baseMap$1;
  return func(collection, baseIteratee$1(iteratee));
}
var map_1 = map$1;
Object.defineProperty(flattenNames$1, "__esModule", {
  value: true
});
flattenNames$1.flattenNames = void 0;
var _isString2 = isString_1;
var _isString3 = _interopRequireDefault$a(_isString2);
var _forOwn2$2 = forOwn_1;
var _forOwn3$2 = _interopRequireDefault$a(_forOwn2$2);
var _isPlainObject2 = isPlainObject_1;
var _isPlainObject3 = _interopRequireDefault$a(_isPlainObject2);
var _map2 = map_1;
var _map3 = _interopRequireDefault$a(_map2);
function _interopRequireDefault$a(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var flattenNames = flattenNames$1.flattenNames = function flattenNames2() {
  var things = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var names2 = [];
  (0, _map3.default)(things, function(thing) {
    if (Array.isArray(thing)) {
      flattenNames2(thing).map(function(name2) {
        return names2.push(name2);
      });
    } else if ((0, _isPlainObject3.default)(thing)) {
      (0, _forOwn3$2.default)(thing, function(value, key) {
        value === true && names2.push(key);
        names2.push(key + "-" + value);
      });
    } else if ((0, _isString3.default)(thing)) {
      names2.push(thing);
    }
  });
  return names2;
};
flattenNames$1.default = flattenNames;
var mergeClasses$1 = {};
var baseClone = _baseClone;
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var cloneDeep_1 = cloneDeep;
Object.defineProperty(mergeClasses$1, "__esModule", {
  value: true
});
mergeClasses$1.mergeClasses = void 0;
var _forOwn2$1 = forOwn_1;
var _forOwn3$1 = _interopRequireDefault$9(_forOwn2$1);
var _cloneDeep2 = cloneDeep_1;
var _cloneDeep3 = _interopRequireDefault$9(_cloneDeep2);
var _extends$e = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
function _interopRequireDefault$9(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var mergeClasses = mergeClasses$1.mergeClasses = function mergeClasses2(classes) {
  var activeNames = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var styles2 = classes.default && (0, _cloneDeep3.default)(classes.default) || {};
  activeNames.map(function(name2) {
    var toMerge = classes[name2];
    if (toMerge) {
      (0, _forOwn3$1.default)(toMerge, function(value, key) {
        if (!styles2[key]) {
          styles2[key] = {};
        }
        styles2[key] = _extends$e({}, styles2[key], toMerge[key]);
      });
    }
    return name2;
  });
  return styles2;
};
mergeClasses$1.default = mergeClasses;
var autoprefix$1 = {};
Object.defineProperty(autoprefix$1, "__esModule", {
  value: true
});
autoprefix$1.autoprefix = void 0;
var _forOwn2 = forOwn_1;
var _forOwn3 = _interopRequireDefault$8(_forOwn2);
var _extends$d = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
function _interopRequireDefault$8(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var transforms = {
  borderRadius: function borderRadius(value) {
    return {
      msBorderRadius: value,
      MozBorderRadius: value,
      OBorderRadius: value,
      WebkitBorderRadius: value,
      borderRadius: value
    };
  },
  boxShadow: function boxShadow(value) {
    return {
      msBoxShadow: value,
      MozBoxShadow: value,
      OBoxShadow: value,
      WebkitBoxShadow: value,
      boxShadow: value
    };
  },
  userSelect: function userSelect(value) {
    return {
      WebkitTouchCallout: value,
      KhtmlUserSelect: value,
      MozUserSelect: value,
      msUserSelect: value,
      WebkitUserSelect: value,
      userSelect: value
    };
  },
  flex: function flex(value) {
    return {
      WebkitBoxFlex: value,
      MozBoxFlex: value,
      WebkitFlex: value,
      msFlex: value,
      flex: value
    };
  },
  flexBasis: function flexBasis(value) {
    return {
      WebkitFlexBasis: value,
      flexBasis: value
    };
  },
  justifyContent: function justifyContent(value) {
    return {
      WebkitJustifyContent: value,
      justifyContent: value
    };
  },
  transition: function transition(value) {
    return {
      msTransition: value,
      MozTransition: value,
      OTransition: value,
      WebkitTransition: value,
      transition: value
    };
  },
  transform: function transform(value) {
    return {
      msTransform: value,
      MozTransform: value,
      OTransform: value,
      WebkitTransform: value,
      transform: value
    };
  },
  absolute: function absolute(value) {
    var direction = value && value.split(" ");
    return {
      position: "absolute",
      top: direction && direction[0],
      right: direction && direction[1],
      bottom: direction && direction[2],
      left: direction && direction[3]
    };
  },
  extend: function extend3(name2, otherElementStyles) {
    var otherStyle = otherElementStyles[name2];
    if (otherStyle) {
      return otherStyle;
    }
    return {
      "extend": name2
    };
  }
};
var autoprefix = autoprefix$1.autoprefix = function autoprefix2(elements) {
  var prefixed = {};
  (0, _forOwn3.default)(elements, function(styles2, element) {
    var expanded = {};
    (0, _forOwn3.default)(styles2, function(value, key) {
      var transform2 = transforms[key];
      if (transform2) {
        expanded = _extends$d({}, expanded, transform2(value));
      } else {
        expanded[key] = value;
      }
    });
    prefixed[element] = expanded;
  });
  return prefixed;
};
autoprefix$1.default = autoprefix;
var hover$1 = {};
Object.defineProperty(hover$1, "__esModule", {
  value: true
});
hover$1.hover = void 0;
var _extends$c = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react$3 = reactExports;
var _react2$3 = _interopRequireDefault$7(_react$3);
function _interopRequireDefault$7(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck$9(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$9(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var hover = hover$1.hover = function hover2(Component) {
  var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
  return function(_React$Component) {
    _inherits$9(Hover, _React$Component);
    function Hover() {
      var _ref;
      var _temp, _this, _ret;
      _classCallCheck$9(this, Hover);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _ret = (_temp = (_this = _possibleConstructorReturn$9(this, (_ref = Hover.__proto__ || Object.getPrototypeOf(Hover)).call.apply(_ref, [this].concat(args))), _this), _this.state = { hover: false }, _this.handleMouseOver = function() {
        return _this.setState({ hover: true });
      }, _this.handleMouseOut = function() {
        return _this.setState({ hover: false });
      }, _this.render = function() {
        return _react2$3.default.createElement(
          Span,
          { onMouseOver: _this.handleMouseOver, onMouseOut: _this.handleMouseOut },
          _react2$3.default.createElement(Component, _extends$c({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn$9(_this, _ret);
    }
    return Hover;
  }(_react2$3.default.Component);
};
hover$1.default = hover;
var active$1 = {};
Object.defineProperty(active$1, "__esModule", {
  value: true
});
active$1.active = void 0;
var _extends$b = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react$2 = reactExports;
var _react2$2 = _interopRequireDefault$6(_react$2);
function _interopRequireDefault$6(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck$8(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$8(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var active = active$1.active = function active2(Component) {
  var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
  return function(_React$Component) {
    _inherits$8(Active, _React$Component);
    function Active() {
      var _ref;
      var _temp, _this, _ret;
      _classCallCheck$8(this, Active);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _ret = (_temp = (_this = _possibleConstructorReturn$8(this, (_ref = Active.__proto__ || Object.getPrototypeOf(Active)).call.apply(_ref, [this].concat(args))), _this), _this.state = { active: false }, _this.handleMouseDown = function() {
        return _this.setState({ active: true });
      }, _this.handleMouseUp = function() {
        return _this.setState({ active: false });
      }, _this.render = function() {
        return _react2$2.default.createElement(
          Span,
          { onMouseDown: _this.handleMouseDown, onMouseUp: _this.handleMouseUp },
          _react2$2.default.createElement(Component, _extends$b({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn$8(_this, _ret);
    }
    return Active;
  }(_react2$2.default.Component);
};
active$1.default = active;
var loop = {};
Object.defineProperty(loop, "__esModule", {
  value: true
});
var loopable = function loopable2(i2, length) {
  var props = {};
  var setProp2 = function setProp3(name2) {
    var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    props[name2] = value;
  };
  i2 === 0 && setProp2("first-child");
  i2 === length - 1 && setProp2("last-child");
  (i2 === 0 || i2 % 2 === 0) && setProp2("even");
  Math.abs(i2 % 2) === 1 && setProp2("odd");
  setProp2("nth-child", i2);
  return props;
};
loop.default = loopable;
Object.defineProperty(lib, "__esModule", {
  value: true
});
lib.ReactCSS = lib.loop = lib.handleActive = handleHover = lib.handleHover = lib.hover = void 0;
var _flattenNames = flattenNames$1;
var _flattenNames2 = _interopRequireDefault$5(_flattenNames);
var _mergeClasses = mergeClasses$1;
var _mergeClasses2 = _interopRequireDefault$5(_mergeClasses);
var _autoprefix = autoprefix$1;
var _autoprefix2 = _interopRequireDefault$5(_autoprefix);
var _hover2 = hover$1;
var _hover3 = _interopRequireDefault$5(_hover2);
var _active = active$1;
var _active2 = _interopRequireDefault$5(_active);
var _loop2 = loop;
var _loop3 = _interopRequireDefault$5(_loop2);
function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
lib.hover = _hover3.default;
var handleHover = lib.handleHover = _hover3.default;
lib.handleActive = _active2.default;
lib.loop = _loop3.default;
var ReactCSS = lib.ReactCSS = function ReactCSS2(classes) {
  for (var _len = arguments.length, activations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    activations[_key - 1] = arguments[_key];
  }
  var activeNames = (0, _flattenNames2.default)(activations);
  var merged = (0, _mergeClasses2.default)(classes, activeNames);
  return (0, _autoprefix2.default)(merged);
};
var _default$2 = lib.default = ReactCSS;
var calculateChange$2 = function calculateChange(e2, hsl, direction, initialA, container2) {
  var containerWidth = container2.clientWidth;
  var containerHeight = container2.clientHeight;
  var x = typeof e2.pageX === "number" ? e2.pageX : e2.touches[0].pageX;
  var y = typeof e2.pageY === "number" ? e2.pageY : e2.touches[0].pageY;
  var left = x - (container2.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container2.getBoundingClientRect().top + window.pageYOffset);
  if (direction === "vertical") {
    var a2 = void 0;
    if (top < 0) {
      a2 = 0;
    } else if (top > containerHeight) {
      a2 = 1;
    } else {
      a2 = Math.round(top * 100 / containerHeight) / 100;
    }
    if (hsl.a !== a2) {
      return {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: a2,
        source: "rgb"
      };
    }
  } else {
    var _a = void 0;
    if (left < 0) {
      _a = 0;
    } else if (left > containerWidth) {
      _a = 1;
    } else {
      _a = Math.round(left * 100 / containerWidth) / 100;
    }
    if (initialA !== _a) {
      return {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: _a,
        source: "rgb"
      };
    }
  }
  return null;
};
var checkboardCache = {};
var render = function render2(c1, c2, size, serverCanvas) {
  if (typeof document === "undefined" && !serverCanvas) {
    return null;
  }
  var canvas = serverCanvas ? new serverCanvas() : document.createElement("canvas");
  canvas.width = size * 2;
  canvas.height = size * 2;
  var ctx2 = canvas.getContext("2d");
  if (!ctx2) {
    return null;
  }
  ctx2.fillStyle = c1;
  ctx2.fillRect(0, 0, canvas.width, canvas.height);
  ctx2.fillStyle = c2;
  ctx2.fillRect(0, 0, size, size);
  ctx2.translate(size, size);
  ctx2.fillRect(0, 0, size, size);
  return canvas.toDataURL();
};
var get$1 = function get10(c1, c2, size, serverCanvas) {
  var key = c1 + "-" + c2 + "-" + size + (serverCanvas ? "-server" : "");
  if (checkboardCache[key]) {
    return checkboardCache[key];
  }
  var checkboard = render(c1, c2, size, serverCanvas);
  checkboardCache[key] = checkboard;
  return checkboard;
};
var _extends$a = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var Checkboard = function Checkboard2(_ref) {
  var white = _ref.white, grey = _ref.grey, size = _ref.size, renderers = _ref.renderers, borderRadius2 = _ref.borderRadius, boxShadow2 = _ref.boxShadow, children = _ref.children;
  var styles2 = _default$2({
    "default": {
      grid: {
        borderRadius: borderRadius2,
        boxShadow: boxShadow2,
        absolute: "0px 0px 0px 0px",
        background: "url(" + get$1(white, grey, size, renderers.canvas) + ") center left"
      }
    }
  });
  return reactExports.isValidElement(children) ? React.cloneElement(children, _extends$a({}, children.props, { style: _extends$a({}, children.props.style, styles2.grid) })) : React.createElement("div", { style: styles2.grid });
};
Checkboard.defaultProps = {
  size: 8,
  white: "transparent",
  grey: "rgba(0,0,0,.08)",
  renderers: {}
};
var _extends$9 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass$7 = /* @__PURE__ */ function() {
  function defineProperties2(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties2(Constructor.prototype, protoProps);
    if (staticProps) defineProperties2(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$7(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$7(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Alpha = function(_ref) {
  _inherits$7(Alpha2, _ref);
  function Alpha2() {
    var _ref2;
    var _temp, _this, _ret;
    _classCallCheck$7(this, Alpha2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = _possibleConstructorReturn$7(this, (_ref2 = Alpha2.__proto__ || Object.getPrototypeOf(Alpha2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e2) {
      var change = calculateChange$2(e2, _this.props.hsl, _this.props.direction, _this.props.a, _this.container);
      change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e2);
    }, _this.handleMouseDown = function(e2) {
      _this.handleChange(e2);
      window.addEventListener("mousemove", _this.handleChange);
      window.addEventListener("mouseup", _this.handleMouseUp);
    }, _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    }, _this.unbindEventListeners = function() {
      window.removeEventListener("mousemove", _this.handleChange);
      window.removeEventListener("mouseup", _this.handleMouseUp);
    }, _temp), _possibleConstructorReturn$7(_this, _ret);
  }
  _createClass$7(Alpha2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var rgb = this.props.rgb;
      var styles2 = _default$2({
        "default": {
          alpha: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius
          },
          checkboard: {
            absolute: "0px 0px 0px 0px",
            overflow: "hidden",
            borderRadius: this.props.radius
          },
          gradient: {
            absolute: "0px 0px 0px 0px",
            background: "linear-gradient(to right, rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 0) 0%,\n           rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 1) 100%)",
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          container: {
            position: "relative",
            height: "100%",
            margin: "0 3px"
          },
          pointer: {
            position: "absolute",
            left: rgb.a * 100 + "%"
          },
          slider: {
            width: "4px",
            borderRadius: "1px",
            height: "8px",
            boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
            background: "#fff",
            marginTop: "1px",
            transform: "translateX(-2px)"
          }
        },
        "vertical": {
          gradient: {
            background: "linear-gradient(to bottom, rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 0) 0%,\n           rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 1) 100%)"
          },
          pointer: {
            left: 0,
            top: rgb.a * 100 + "%"
          }
        },
        "overwrite": _extends$9({}, this.props.style)
      }, {
        vertical: this.props.direction === "vertical",
        overwrite: true
      });
      return React.createElement(
        "div",
        { style: styles2.alpha },
        React.createElement(
          "div",
          { style: styles2.checkboard },
          React.createElement(Checkboard, { renderers: this.props.renderers })
        ),
        React.createElement("div", { style: styles2.gradient }),
        React.createElement(
          "div",
          {
            style: styles2.container,
            ref: function ref2(container2) {
              return _this2.container = container2;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          React.createElement(
            "div",
            { style: styles2.pointer },
            this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement("div", { style: styles2.slider })
          )
        )
      );
    }
  }]);
  return Alpha2;
}(reactExports.PureComponent || reactExports.Component);
var _createClass$6 = /* @__PURE__ */ function() {
  function defineProperties2(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties2(Constructor.prototype, protoProps);
    if (staticProps) defineProperties2(Constructor, staticProps);
    return Constructor;
  };
}();
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$6(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$6(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var DEFAULT_ARROW_OFFSET = 1;
var UP_KEY_CODE = 38;
var DOWN_KEY_CODE = 40;
var VALID_KEY_CODES = [UP_KEY_CODE, DOWN_KEY_CODE];
var isValidKeyCode = function isValidKeyCode2(keyCode) {
  return VALID_KEY_CODES.indexOf(keyCode) > -1;
};
var getNumberValue = function getNumberValue2(value) {
  return Number(String(value).replace(/%/g, ""));
};
var idCounter = 1;
var EditableInput = function(_ref) {
  _inherits$6(EditableInput2, _ref);
  function EditableInput2(props) {
    _classCallCheck$6(this, EditableInput2);
    var _this = _possibleConstructorReturn$6(this, (EditableInput2.__proto__ || Object.getPrototypeOf(EditableInput2)).call(this));
    _this.handleBlur = function() {
      if (_this.state.blurValue) {
        _this.setState({ value: _this.state.blurValue, blurValue: null });
      }
    };
    _this.handleChange = function(e2) {
      _this.setUpdatedValue(e2.target.value, e2);
    };
    _this.handleKeyDown = function(e2) {
      var value = getNumberValue(e2.target.value);
      if (!isNaN(value) && isValidKeyCode(e2.keyCode)) {
        var offset2 = _this.getArrowOffset();
        var updatedValue = e2.keyCode === UP_KEY_CODE ? value + offset2 : value - offset2;
        _this.setUpdatedValue(updatedValue, e2);
      }
    };
    _this.handleDrag = function(e2) {
      if (_this.props.dragLabel) {
        var newValue = Math.round(_this.props.value + e2.movementX);
        if (newValue >= 0 && newValue <= _this.props.dragMax) {
          _this.props.onChange && _this.props.onChange(_this.getValueObjectWithLabel(newValue), e2);
        }
      }
    };
    _this.handleMouseDown = function(e2) {
      if (_this.props.dragLabel) {
        e2.preventDefault();
        _this.handleDrag(e2);
        window.addEventListener("mousemove", _this.handleDrag);
        window.addEventListener("mouseup", _this.handleMouseUp);
      }
    };
    _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    };
    _this.unbindEventListeners = function() {
      window.removeEventListener("mousemove", _this.handleDrag);
      window.removeEventListener("mouseup", _this.handleMouseUp);
    };
    _this.state = {
      value: String(props.value).toUpperCase(),
      blurValue: String(props.value).toUpperCase()
    };
    _this.inputId = "rc-editable-input-" + idCounter++;
    return _this;
  }
  _createClass$6(EditableInput2, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.props.value !== this.state.value && (prevProps.value !== this.props.value || prevState.value !== this.state.value)) {
        if (this.input === document.activeElement) {
          this.setState({ blurValue: String(this.props.value).toUpperCase() });
        } else {
          this.setState({ value: String(this.props.value).toUpperCase(), blurValue: !this.state.blurValue && String(this.props.value).toUpperCase() });
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "getValueObjectWithLabel",
    value: function getValueObjectWithLabel(value) {
      return _defineProperty({}, this.props.label, value);
    }
  }, {
    key: "getArrowOffset",
    value: function getArrowOffset() {
      return this.props.arrowOffset || DEFAULT_ARROW_OFFSET;
    }
  }, {
    key: "setUpdatedValue",
    value: function setUpdatedValue(value, e2) {
      var onChangeValue = this.props.label ? this.getValueObjectWithLabel(value) : value;
      this.props.onChange && this.props.onChange(onChangeValue, e2);
      this.setState({ value });
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var styles2 = _default$2({
        "default": {
          wrap: {
            position: "relative"
          }
        },
        "user-override": {
          wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
          input: this.props.style && this.props.style.input ? this.props.style.input : {},
          label: this.props.style && this.props.style.label ? this.props.style.label : {}
        },
        "dragLabel-true": {
          label: {
            cursor: "ew-resize"
          }
        }
      }, {
        "user-override": true
      }, this.props);
      return React.createElement(
        "div",
        { style: styles2.wrap },
        React.createElement("input", {
          id: this.inputId,
          style: styles2.input,
          ref: function ref2(input2) {
            return _this2.input = input2;
          },
          value: this.state.value,
          onKeyDown: this.handleKeyDown,
          onChange: this.handleChange,
          onBlur: this.handleBlur,
          placeholder: this.props.placeholder,
          spellCheck: "false"
        }),
        this.props.label && !this.props.hideLabel ? React.createElement(
          "label",
          {
            htmlFor: this.inputId,
            style: styles2.label,
            onMouseDown: this.handleMouseDown
          },
          this.props.label
        ) : null
      );
    }
  }]);
  return EditableInput2;
}(reactExports.PureComponent || reactExports.Component);
var calculateChange$1 = function calculateChange2(e2, direction, hsl, container2) {
  var containerWidth = container2.clientWidth;
  var containerHeight = container2.clientHeight;
  var x = typeof e2.pageX === "number" ? e2.pageX : e2.touches[0].pageX;
  var y = typeof e2.pageY === "number" ? e2.pageY : e2.touches[0].pageY;
  var left = x - (container2.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container2.getBoundingClientRect().top + window.pageYOffset);
  if (direction === "vertical") {
    var h = void 0;
    if (top < 0) {
      h = 359;
    } else if (top > containerHeight) {
      h = 0;
    } else {
      var percent = -(top * 100 / containerHeight) + 100;
      h = 360 * percent / 100;
    }
    if (hsl.h !== h) {
      return {
        h,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        source: "hsl"
      };
    }
  } else {
    var _h = void 0;
    if (left < 0) {
      _h = 0;
    } else if (left > containerWidth) {
      _h = 359;
    } else {
      var _percent = left * 100 / containerWidth;
      _h = 360 * _percent / 100;
    }
    if (hsl.h !== _h) {
      return {
        h: _h,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        source: "hsl"
      };
    }
  }
  return null;
};
var _createClass$5 = /* @__PURE__ */ function() {
  function defineProperties2(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties2(Constructor.prototype, protoProps);
    if (staticProps) defineProperties2(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$5(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$5(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Hue = function(_ref) {
  _inherits$5(Hue2, _ref);
  function Hue2() {
    var _ref2;
    var _temp, _this, _ret;
    _classCallCheck$5(this, Hue2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = _possibleConstructorReturn$5(this, (_ref2 = Hue2.__proto__ || Object.getPrototypeOf(Hue2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e2) {
      var change = calculateChange$1(e2, _this.props.direction, _this.props.hsl, _this.container);
      change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e2);
    }, _this.handleMouseDown = function(e2) {
      _this.handleChange(e2);
      window.addEventListener("mousemove", _this.handleChange);
      window.addEventListener("mouseup", _this.handleMouseUp);
    }, _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    }, _temp), _possibleConstructorReturn$5(_this, _ret);
  }
  _createClass$5(Hue2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "unbindEventListeners",
    value: function unbindEventListeners() {
      window.removeEventListener("mousemove", this.handleChange);
      window.removeEventListener("mouseup", this.handleMouseUp);
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var _props$direction = this.props.direction, direction = _props$direction === void 0 ? "horizontal" : _props$direction;
      var styles2 = _default$2({
        "default": {
          hue: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius,
            boxShadow: this.props.shadow
          },
          container: {
            padding: "0 2px",
            position: "relative",
            height: "100%",
            borderRadius: this.props.radius
          },
          pointer: {
            position: "absolute",
            left: this.props.hsl.h * 100 / 360 + "%"
          },
          slider: {
            marginTop: "1px",
            width: "4px",
            borderRadius: "1px",
            height: "8px",
            boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
            background: "#fff",
            transform: "translateX(-2px)"
          }
        },
        "vertical": {
          pointer: {
            left: "0px",
            top: -(this.props.hsl.h * 100 / 360) + 100 + "%"
          }
        }
      }, { vertical: direction === "vertical" });
      return React.createElement(
        "div",
        { style: styles2.hue },
        React.createElement(
          "div",
          {
            className: "hue-" + direction,
            style: styles2.container,
            ref: function ref2(container2) {
              return _this2.container = container2;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          React.createElement(
            "style",
            null,
            "\n            .hue-horizontal {\n              background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0\n                33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to right, #f00 0%, #ff0\n                17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n\n            .hue-vertical {\n              background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,\n                #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%,\n                #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n          "
          ),
          React.createElement(
            "div",
            { style: styles2.pointer },
            this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement("div", { style: styles2.slider })
          )
        )
      );
    }
  }]);
  return Hue2;
}(reactExports.PureComponent || reactExports.Component);
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice2 = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice2.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache(entries3) {
  var index2 = -1, length = entries3 == null ? 0 : entries3.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries3[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var Symbol$1 = root.Symbol;
var objectProto$e = Object.prototype;
var hasOwnProperty$b = objectProto$e.hasOwnProperty;
var nativeObjectToString$1 = objectProto$e.toString;
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$d = Object.prototype;
var nativeObjectToString = objectProto$d.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObject7(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject7(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject7(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var Map$1 = getNative(root, "Map");
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$9.call(data, key) ? data[key] : void 0;
}
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries3) {
  var index2 = -1, length = entries3 == null ? 0 : entries3.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries3[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map3, key) {
  var data = map3.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries3) {
  var index2 = -1, length = entries3 == null ? 0 : entries3.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries3[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries3) {
  var data = this.__data__ = new ListCache(entries3);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty) {
    defineProperty(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root.Buffer : void 0;
Buffer$2 ? Buffer$2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  {
    return buffer.slice();
  }
}
var Uint8Array$1 = root.Uint8Array;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = cloneArrayBuffer(typedArray.buffer);
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
function copyArray(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto2) {
    if (!isObject7(proto2)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto2);
    }
    object.prototype = proto2;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var objectProto$9 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$9;
  return value === proto2;
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;
var isArguments4 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$7.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArray2 = Array.isArray;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
function stubFalse() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer$1 = moduleExports$1 ? root.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype, objectProto$7 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject2(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto2 = getPrototype(value);
  if (proto2 === null) {
    return true;
  }
  var Ctor = hasOwnProperty$6.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal.process;
var nodeUtil = function() {
  try {
    var types2 = freeModule && freeModule.require && freeModule.require("util").types;
    if (types2) {
      return types2;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
function baseTimes(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type2 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray2(value), isArg = !isArr && isArguments4(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject7(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray2(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue);
      } else {
        newValue = [];
      }
    } else if (isPlainObject2(srcValue) || isArguments4(srcValue)) {
      newValue = objValue;
      if (isArguments4(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject7(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue(object, key, newValue);
}
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack());
    if (isObject7(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
function identity(value) {
  return value;
}
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var nativeMax$1 = Math.max;
function overRest(func, start, transform2) {
  start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax$1(args.length - start, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform2(array);
    return apply(func, this, otherArgs);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var setToString = shortOut(baseSetToString);
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + "");
}
function isIterateeCall(value, index2, object) {
  if (!isObject7(object)) {
    return false;
  }
  var type2 = typeof index2;
  if (type2 == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type2 == "string" && index2 in object) {
    return eq(object[index2], value);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
var Raised = function Raised2(_ref) {
  var zDepth = _ref.zDepth, radius = _ref.radius, background = _ref.background, children = _ref.children, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles;
  var styles2 = _default$2(merge({
    "default": {
      wrap: {
        position: "relative",
        display: "inline-block"
      },
      content: {
        position: "relative"
      },
      bg: {
        absolute: "0px 0px 0px 0px",
        boxShadow: "0 " + zDepth + "px " + zDepth * 4 + "px rgba(0,0,0,.24)",
        borderRadius: radius,
        background
      }
    },
    "zDepth-0": {
      bg: {
        boxShadow: "none"
      }
    },
    "zDepth-1": {
      bg: {
        boxShadow: "0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)"
      }
    },
    "zDepth-2": {
      bg: {
        boxShadow: "0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)"
      }
    },
    "zDepth-3": {
      bg: {
        boxShadow: "0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)"
      }
    },
    "zDepth-4": {
      bg: {
        boxShadow: "0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)"
      }
    },
    "zDepth-5": {
      bg: {
        boxShadow: "0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)"
      }
    },
    "square": {
      bg: {
        borderRadius: "0"
      }
    },
    "circle": {
      bg: {
        borderRadius: "50%"
      }
    }
  }, passedStyles), { "zDepth-1": zDepth === 1 });
  return React.createElement(
    "div",
    { style: styles2.wrap },
    React.createElement("div", { style: styles2.bg }),
    React.createElement(
      "div",
      { style: styles2.content },
      children
    )
  );
};
Raised.propTypes = {
  background: PropTypes.string,
  zDepth: PropTypes.oneOf([0, 1, 2, 3, 4, 5]),
  radius: PropTypes.number,
  styles: PropTypes.object
};
Raised.defaultProps = {
  background: "#fff",
  zDepth: 1,
  radius: 2,
  styles: {}
};
var now2 = function() {
  return root.Date.now();
};
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var symbolTag$1 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject7(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject7(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var FUNC_ERROR_TEXT$2 = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  wait = toNumber(wait) || 0;
  if (isObject7(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now2();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now2());
  }
  function debounced() {
    var time = now2(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var FUNC_ERROR_TEXT$1 = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  if (isObject7(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var calculateChange3 = function calculateChange4(e2, hsl, container2) {
  var _container$getBoundin = container2.getBoundingClientRect(), containerWidth = _container$getBoundin.width, containerHeight = _container$getBoundin.height;
  var x = typeof e2.pageX === "number" ? e2.pageX : e2.touches[0].pageX;
  var y = typeof e2.pageY === "number" ? e2.pageY : e2.touches[0].pageY;
  var left = x - (container2.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container2.getBoundingClientRect().top + window.pageYOffset);
  if (left < 0) {
    left = 0;
  } else if (left > containerWidth) {
    left = containerWidth;
  }
  if (top < 0) {
    top = 0;
  } else if (top > containerHeight) {
    top = containerHeight;
  }
  var saturation = left / containerWidth;
  var bright = 1 - top / containerHeight;
  return {
    h: hsl.h,
    s: saturation,
    v: bright,
    a: hsl.a,
    source: "hsv"
  };
};
var _createClass$4 = /* @__PURE__ */ function() {
  function defineProperties2(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties2(Constructor.prototype, protoProps);
    if (staticProps) defineProperties2(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$4(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$4(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Saturation = function(_ref) {
  _inherits$4(Saturation2, _ref);
  function Saturation2(props) {
    _classCallCheck$4(this, Saturation2);
    var _this = _possibleConstructorReturn$4(this, (Saturation2.__proto__ || Object.getPrototypeOf(Saturation2)).call(this, props));
    _this.handleChange = function(e2) {
      typeof _this.props.onChange === "function" && _this.throttle(_this.props.onChange, calculateChange3(e2, _this.props.hsl, _this.container), e2);
    };
    _this.handleMouseDown = function(e2) {
      _this.handleChange(e2);
      var renderWindow = _this.getContainerRenderWindow();
      renderWindow.addEventListener("mousemove", _this.handleChange);
      renderWindow.addEventListener("mouseup", _this.handleMouseUp);
    };
    _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    };
    _this.throttle = throttle(function(fn, data, e2) {
      fn(data, e2);
    }, 50);
    return _this;
  }
  _createClass$4(Saturation2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.throttle.cancel();
      this.unbindEventListeners();
    }
  }, {
    key: "getContainerRenderWindow",
    value: function getContainerRenderWindow() {
      var container2 = this.container;
      var renderWindow = window;
      while (!renderWindow.document.contains(container2) && renderWindow.parent !== renderWindow) {
        renderWindow = renderWindow.parent;
      }
      return renderWindow;
    }
  }, {
    key: "unbindEventListeners",
    value: function unbindEventListeners() {
      var renderWindow = this.getContainerRenderWindow();
      renderWindow.removeEventListener("mousemove", this.handleChange);
      renderWindow.removeEventListener("mouseup", this.handleMouseUp);
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var _ref2 = this.props.style || {}, color = _ref2.color, white = _ref2.white, black = _ref2.black, pointer = _ref2.pointer, circle = _ref2.circle;
      var styles2 = _default$2({
        "default": {
          color: {
            absolute: "0px 0px 0px 0px",
            background: "hsl(" + this.props.hsl.h + ",100%, 50%)",
            borderRadius: this.props.radius
          },
          white: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius
          },
          black: {
            absolute: "0px 0px 0px 0px",
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          pointer: {
            position: "absolute",
            top: -(this.props.hsv.v * 100) + 100 + "%",
            left: this.props.hsv.s * 100 + "%",
            cursor: "default"
          },
          circle: {
            width: "4px",
            height: "4px",
            boxShadow: "0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),\n            0 0 1px 2px rgba(0,0,0,.4)",
            borderRadius: "50%",
            cursor: "hand",
            transform: "translate(-2px, -2px)"
          }
        },
        "custom": {
          color,
          white,
          black,
          pointer,
          circle
        }
      }, { "custom": !!this.props.style });
      return React.createElement(
        "div",
        {
          style: styles2.color,
          ref: function ref2(container2) {
            return _this2.container = container2;
          },
          onMouseDown: this.handleMouseDown,
          onTouchMove: this.handleChange,
          onTouchStart: this.handleChange
        },
        React.createElement(
          "style",
          null,
          "\n          .saturation-white {\n            background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0));\n            background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n          }\n          .saturation-black {\n            background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0));\n            background: linear-gradient(to top, #000, rgba(0,0,0,0));\n          }\n        "
        ),
        React.createElement(
          "div",
          { style: styles2.white, className: "saturation-white" },
          React.createElement("div", { style: styles2.black, className: "saturation-black" }),
          React.createElement(
            "div",
            { style: styles2.pointer },
            this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement("div", { style: styles2.circle })
          )
        )
      );
    }
  }]);
  return Saturation2;
}(reactExports.PureComponent || reactExports.Component);
function arrayEach(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var nativeKeys = overArg(Object.keys, Object);
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$2.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys3(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys3);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = -1, iterable = Object(collection);
    while (++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn);
function castFunction(value) {
  return typeof value == "function" ? value : identity;
}
function forEach2(collection, iteratee) {
  var func = isArray2(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};
  if (color instanceof tinycolor) {
    return color;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1) this._r = Math.round(this._r);
  if (this._g < 1) this._g = Math.round(this._g);
  if (this._b < 1) this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid2() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G, B;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) R = RsRGB / 12.92;
    else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928) G = GsRGB / 12.92;
    else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928) B = BsRGB / 12.92;
    else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h = Math.round(hsv.h * 360), s2 = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h + ", " + s2 + "%, " + v + "%)" : "hsva(" + h + ", " + s2 + "%, " + v + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h = Math.round(hsl.h * 360), s2 = Math.round(hsl.s * 100), l = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h + ", " + s2 + "%, " + l + "%)" : "hsla(" + h + ", " + s2 + "%, " + l + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s2 = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s2._r, s2._g, s2._b, s2._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString4(format2) {
    var formatSet = !!format2;
    format2 = format2 || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
    if (needsAlphaFormat) {
      if (format2 === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format2 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format2 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format2 === "hex" || format2 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format2 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format2 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format2 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format2 === "name") {
      formattedString = this.toName();
    }
    if (format2 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format2 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone2() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args) {
    var color = fn.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args) {
    return fn.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color, opts) {
  if (_typeof(color) == "object") {
    var newColor = {};
    for (var i2 in color) {
      if (color.hasOwnProperty(i2)) {
        if (i2 === "a") {
          newColor[i2] = color[i2];
        } else {
          newColor[i2] = convertToPercentage(color[i2]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a2 = 1;
  var s2 = null;
  var v = null;
  var l = null;
  var ok = false;
  var format2 = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s2 = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s2, v);
      ok = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s2 = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s2, l);
      ok = true;
      format2 = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a2 = color.a;
    }
  }
  a2 = boundAlpha(a2);
  return {
    ok,
    format: color.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a2
  };
}
function rgbToRgb(r2, g, b) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r2, g, b) {
  r2 = bound01(r2, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max3 = Math.max(r2, g, b), min3 = Math.min(r2, g, b);
  var h, s2, l = (max3 + min3) / 2;
  if (max3 == min3) {
    h = s2 = 0;
  } else {
    var d = max3 - min3;
    s2 = l > 0.5 ? d / (2 - max3 - min3) : d / (max3 + min3);
    switch (max3) {
      case r2:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r2) / d + 2;
        break;
      case b:
        h = (r2 - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s: s2,
    l
  };
}
function hslToRgb(h, s2, l) {
  var r2, g, b;
  h = bound01(h, 360);
  s2 = bound01(s2, 100);
  l = bound01(l, 100);
  function hue2rgb(p2, q2, t2) {
    if (t2 < 0) t2 += 1;
    if (t2 > 1) t2 -= 1;
    if (t2 < 1 / 6) return p2 + (q2 - p2) * 6 * t2;
    if (t2 < 1 / 2) return q2;
    if (t2 < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
    return p2;
  }
  if (s2 === 0) {
    r2 = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s2) : l + s2 - l * s2;
    var p = 2 * l - q;
    r2 = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return {
    r: r2 * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHsv(r2, g, b) {
  r2 = bound01(r2, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max3 = Math.max(r2, g, b), min3 = Math.min(r2, g, b);
  var h, s2, v = max3;
  var d = max3 - min3;
  s2 = max3 === 0 ? 0 : d / max3;
  if (max3 == min3) {
    h = 0;
  } else {
    switch (max3) {
      case r2:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r2) / d + 2;
        break;
      case b:
        h = (r2 - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s: s2,
    v
  };
}
function hsvToRgb(h, s2, v) {
  h = bound01(h, 360) * 6;
  s2 = bound01(s2, 100);
  v = bound01(v, 100);
  var i2 = Math.floor(h), f = h - i2, p = v * (1 - s2), q = v * (1 - f * s2), t2 = v * (1 - (1 - f) * s2), mod2 = i2 % 6, r2 = [v, q, p, p, t2, v][mod2], g = [t2, v, v, q, p, p][mod2], b = [p, p, t2, v, v, q][mod2];
  return {
    r: r2 * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHex(r2, g, b, allow3Char) {
  var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r2, g, b, a2, allow4Char) {
  var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a2))];
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function rgbaToArgbHex(r2, g, b, a2) {
  var hex = [pad2(convertDecimalToHex(a2)), pad2(Math.round(r2).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  return hex.join("");
}
tinycolor.equals = function(color1, color2) {
  if (!color1 || !color2) return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}
function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number;
  for (var i2 = 1; i2 < number; i2++) {
    result.push(tinycolor({
      h: (hsl.h + i2 * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var h = hsv.h, s2 = hsv.s, v = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h,
      s: s2,
      v
    }));
    v = (v + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b,
    a: (rgb2.a - rgb1.a) * p + rgb1.a
  };
  return tinycolor(rgba);
};
tinycolor.readability = function(color1, color2) {
  var c1 = tinycolor(color1);
  var c2 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i2 = 0; i2 < colorList.length; i2++) {
    readability = tinycolor.readability(baseColor, colorList[i2]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i2]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip2(names);
function flip2(o) {
  var flipped = {};
  for (var i2 in o) {
    if (o.hasOwnProperty(i2)) {
      flipped[o[i2]] = i2;
    }
  }
  return flipped;
}
function boundAlpha(a2) {
  a2 = parseFloat(a2);
  if (isNaN(a2) || a2 < 0 || a2 > 1) {
    a2 = 1;
  }
  return a2;
}
function bound01(n2, max3) {
  if (isOnePointZero(n2)) n2 = "100%";
  var processPercent = isPercentage(n2);
  n2 = Math.min(max3, Math.max(0, parseFloat(n2)));
  if (processPercent) {
    n2 = parseInt(n2 * max3, 10) / 100;
  }
  if (Math.abs(n2 - max3) < 1e-6) {
    return 1;
  }
  return n2 % max3 / parseFloat(max3);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n2) {
  return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") != -1;
}
function pad2(c2) {
  return c2.length == 1 ? "0" + c2 : "" + c2;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    n2 = n2 * 100 + "%";
  }
  return n2;
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level,
    size
  };
}
var simpleCheckForValidColor = function simpleCheckForValidColor2(data) {
  var keysToCheck = ["r", "g", "b", "a", "h", "s", "l", "v"];
  var checked = 0;
  var passed = 0;
  forEach2(keysToCheck, function(letter) {
    if (data[letter]) {
      checked += 1;
      if (!isNaN(data[letter])) {
        passed += 1;
      }
      if (letter === "s" || letter === "l") {
        var percentPatt = /^\d+%$/;
        if (percentPatt.test(data[letter])) {
          passed += 1;
        }
      }
    }
  });
  return checked === passed ? data : false;
};
var toState = function toState2(data, oldHue) {
  var color = data.hex ? tinycolor(data.hex) : tinycolor(data);
  var hsl = color.toHsl();
  var hsv = color.toHsv();
  var rgb = color.toRgb();
  var hex = color.toHex();
  if (hsl.s === 0) {
    hsl.h = oldHue || 0;
    hsv.h = oldHue || 0;
  }
  var transparent = hex === "000000" && rgb.a === 0;
  return {
    hsl,
    hex: transparent ? "transparent" : "#" + hex,
    rgb,
    hsv,
    oldHue: data.h || oldHue || hsl.h,
    source: data.source
  };
};
var isValidHex = function isValidHex2(hex) {
  if (hex === "transparent") {
    return true;
  }
  var lh = String(hex).charAt(0) === "#" ? 1 : 0;
  return hex.length !== 4 + lh && hex.length < 7 + lh && tinycolor(hex).isValid();
};
var getContrastingColor = function getContrastingColor2(data) {
  if (!data) {
    return "#fff";
  }
  var col = toState(data);
  if (col.hex === "transparent") {
    return "rgba(0,0,0,0.4)";
  }
  var yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1e3;
  return yiq >= 128 ? "#000" : "#fff";
};
var isvalidColorString = function isvalidColorString2(string, type2) {
  var stringWithoutDegree = string.replace("°", "");
  return tinycolor(type2 + " (" + stringWithoutDegree + ")")._ok;
};
var _extends$8 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass$3 = /* @__PURE__ */ function() {
  function defineProperties2(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties2(Constructor.prototype, protoProps);
    if (staticProps) defineProperties2(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$3(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$3(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ColorWrap = function ColorWrap2(Picker) {
  var ColorPicker = function(_ref) {
    _inherits$3(ColorPicker2, _ref);
    function ColorPicker2(props) {
      _classCallCheck$3(this, ColorPicker2);
      var _this = _possibleConstructorReturn$3(this, (ColorPicker2.__proto__ || Object.getPrototypeOf(ColorPicker2)).call(this));
      _this.handleChange = function(data, event) {
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors = toState(data, data.h || _this.state.oldHue);
          _this.setState(colors);
          _this.props.onChangeComplete && _this.debounce(_this.props.onChangeComplete, colors, event);
          _this.props.onChange && _this.props.onChange(colors, event);
        }
      };
      _this.handleSwatchHover = function(data, event) {
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors = toState(data, data.h || _this.state.oldHue);
          _this.props.onSwatchHover && _this.props.onSwatchHover(colors, event);
        }
      };
      _this.state = _extends$8({}, toState(props.color, 0));
      _this.debounce = debounce(function(fn, data, event) {
        fn(data, event);
      }, 100);
      return _this;
    }
    _createClass$3(ColorPicker2, [{
      key: "render",
      value: function render3() {
        var optionalEvents = {};
        if (this.props.onSwatchHover) {
          optionalEvents.onSwatchHover = this.handleSwatchHover;
        }
        return React.createElement(Picker, _extends$8({}, this.props, this.state, {
          onChange: this.handleChange
        }, optionalEvents));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(nextProps, state) {
        return _extends$8({}, toState(nextProps.color, state.oldHue));
      }
    }]);
    return ColorPicker2;
  }(reactExports.PureComponent || reactExports.Component);
  ColorPicker.propTypes = _extends$8({}, Picker.propTypes);
  ColorPicker.defaultProps = _extends$8({}, Picker.defaultProps, {
    color: {
      h: 250,
      s: 0.5,
      l: 0.2,
      a: 1
    }
  });
  return ColorPicker;
};
var _extends$7 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass$2 = /* @__PURE__ */ function() {
  function defineProperties2(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties2(Constructor.prototype, protoProps);
    if (staticProps) defineProperties2(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$2(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$2(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var handleFocus = function handleFocus2(Component) {
  var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
  return function(_React$Component) {
    _inherits$2(Focus, _React$Component);
    function Focus() {
      var _ref;
      var _temp, _this, _ret;
      _classCallCheck$2(this, Focus);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _ret = (_temp = (_this = _possibleConstructorReturn$2(this, (_ref = Focus.__proto__ || Object.getPrototypeOf(Focus)).call.apply(_ref, [this].concat(args))), _this), _this.state = { focus: false }, _this.handleFocus = function() {
        return _this.setState({ focus: true });
      }, _this.handleBlur = function() {
        return _this.setState({ focus: false });
      }, _temp), _possibleConstructorReturn$2(_this, _ret);
    }
    _createClass$2(Focus, [{
      key: "render",
      value: function render3() {
        return React.createElement(
          Span,
          { onFocus: this.handleFocus, onBlur: this.handleBlur },
          React.createElement(Component, _extends$7({}, this.props, this.state))
        );
      }
    }]);
    return Focus;
  }(React.Component);
};
var _extends$6 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var ENTER = 13;
var Swatch = function Swatch2(_ref) {
  var color = _ref.color, style = _ref.style, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onHover = _ref.onHover, _ref$title = _ref.title, title2 = _ref$title === void 0 ? color : _ref$title, children = _ref.children, focus = _ref.focus, _ref$focusStyle = _ref.focusStyle, focusStyle = _ref$focusStyle === void 0 ? {} : _ref$focusStyle;
  var transparent = color === "transparent";
  var styles2 = _default$2({
    default: {
      swatch: _extends$6({
        background: color,
        height: "100%",
        width: "100%",
        cursor: "pointer",
        position: "relative",
        outline: "none"
      }, style, focus ? focusStyle : {})
    }
  });
  var handleClick = function handleClick2(e2) {
    return onClick(color, e2);
  };
  var handleKeyDown = function handleKeyDown2(e2) {
    return e2.keyCode === ENTER && onClick(color, e2);
  };
  var handleHover2 = function handleHover3(e2) {
    return onHover(color, e2);
  };
  var optionalEvents = {};
  if (onHover) {
    optionalEvents.onMouseOver = handleHover2;
  }
  return React.createElement(
    "div",
    _extends$6({
      style: styles2.swatch,
      onClick: handleClick,
      title: title2,
      tabIndex: 0,
      onKeyDown: handleKeyDown
    }, optionalEvents),
    children,
    transparent && React.createElement(Checkboard, {
      borderRadius: styles2.swatch.borderRadius,
      boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
    })
  );
};
const Swatch$1 = handleFocus(Swatch);
var AlphaPointer = function AlphaPointer2(_ref) {
  var direction = _ref.direction;
  var styles2 = _default$2({
    "default": {
      picker: {
        width: "18px",
        height: "18px",
        borderRadius: "50%",
        transform: "translate(-9px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    },
    "vertical": {
      picker: {
        transform: "translate(-3px, -9px)"
      }
    }
  }, { vertical: direction === "vertical" });
  return React.createElement("div", { style: styles2.picker });
};
var _extends$5 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var AlphaPicker = function AlphaPicker2(_ref) {
  var rgb = _ref.rgb, hsl = _ref.hsl, width = _ref.width, height = _ref.height, onChange = _ref.onChange, direction = _ref.direction, style = _ref.style, renderers = _ref.renderers, pointer = _ref.pointer, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$2({
    "default": {
      picker: {
        position: "relative",
        width,
        height
      },
      alpha: {
        radius: "2px",
        style
      }
    }
  });
  return React.createElement(
    "div",
    { style: styles2.picker, className: "alpha-picker " + className },
    React.createElement(Alpha, _extends$5({}, styles2.alpha, {
      rgb,
      hsl,
      pointer,
      renderers,
      onChange,
      direction
    }))
  );
};
AlphaPicker.defaultProps = {
  width: "316px",
  height: "16px",
  direction: "horizontal",
  pointer: AlphaPointer
};
ColorWrap(AlphaPicker);
function arrayMap(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values2) {
  var index2 = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache();
  while (++index2 < length) {
    this.add(values2[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key) {
  return cache.has(key);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
function mapToArray(map3) {
  var index2 = -1, result = Array(map3.size);
  map3.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
function setToArray(set3) {
  var index2 = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$1 = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]";
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag$1:
      var convert = mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
function arrayPush(array, values2) {
  var index2 = -1, length = values2.length, offset2 = array.length;
  while (++index2 < length) {
    array[offset2 + index2] = values2[index2];
  }
  return array;
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
}
function arrayFilter(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
function getAllKeys(object) {
  return baseGetAllKeys(object, keys3, getSymbols);
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var DataView$1 = getNative(root, "DataView");
var Promise$1 = getNative(root, "Promise");
var Set$1 = getNative(root, "Set");
var WeakMap$1 = getNative(root, "WeakMap");
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag(new Map$1()) != mapTag || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index2 = matchData.length, length = index2;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      var result;
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject7(value);
}
function getMatchData(object) {
  var result = keys3(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray2(value)) {
    return false;
  }
  var type2 = typeof value;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath2 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray2(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
function toString5(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object) {
  if (isArray2(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath2(toString5(value));
}
var INFINITY = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function baseGet(object, path) {
  path = castPath(path, object);
  var index2 = 0, length = path.length;
  while (object != null && index2 < length) {
    object = object[toKey(path[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
function get11(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key = toKey(path[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments4(object));
}
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get11(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
function map2(collection, iteratee) {
  var func = isArray2(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee));
}
var BlockSwatches = function BlockSwatches2(_ref) {
  var colors = _ref.colors, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
  var styles2 = _default$2({
    "default": {
      swatches: {
        marginRight: "-10px"
      },
      swatch: {
        width: "22px",
        height: "22px",
        float: "left",
        marginRight: "10px",
        marginBottom: "10px",
        borderRadius: "4px"
      },
      clear: {
        clear: "both"
      }
    }
  });
  return React.createElement(
    "div",
    { style: styles2.swatches },
    map2(colors, function(c2) {
      return React.createElement(Swatch$1, {
        key: c2,
        color: c2,
        style: styles2.swatch,
        onClick,
        onHover: onSwatchHover,
        focusStyle: {
          boxShadow: "0 0 4px " + c2
        }
      });
    }),
    React.createElement("div", { style: styles2.clear })
  );
};
var Block = function Block2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex = _ref.hex, colors = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var transparent = hex === "transparent";
  var handleChange = function handleChange2(hexCode, e2) {
    isValidHex(hexCode) && onChange({
      hex: hexCode,
      source: "hex"
    }, e2);
  };
  var styles2 = _default$2(merge({
    "default": {
      card: {
        width,
        background: "#fff",
        boxShadow: "0 1px rgba(0,0,0,.1)",
        borderRadius: "6px",
        position: "relative"
      },
      head: {
        height: "110px",
        background: hex,
        borderRadius: "6px 6px 0 0",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        position: "relative"
      },
      body: {
        padding: "10px"
      },
      label: {
        fontSize: "18px",
        color: getContrastingColor(hex),
        position: "relative"
      },
      triangle: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 10px 10px 10px",
        borderColor: "transparent transparent " + hex + " transparent",
        position: "absolute",
        top: "-10px",
        left: "50%",
        marginLeft: "-10px"
      },
      input: {
        width: "100%",
        fontSize: "12px",
        color: "#666",
        border: "0px",
        outline: "none",
        height: "22px",
        boxShadow: "inset 0 0 0 1px #ddd",
        borderRadius: "4px",
        padding: "0 7px",
        boxSizing: "border-box"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      }
    }
  }, passedStyles), { "hide-triangle": triangle === "hide" });
  return React.createElement(
    "div",
    { style: styles2.card, className: "block-picker " + className },
    React.createElement("div", { style: styles2.triangle }),
    React.createElement(
      "div",
      { style: styles2.head },
      transparent && React.createElement(Checkboard, { borderRadius: "6px 6px 0 0" }),
      React.createElement(
        "div",
        { style: styles2.label },
        hex
      )
    ),
    React.createElement(
      "div",
      { style: styles2.body },
      React.createElement(BlockSwatches, { colors, onClick: handleChange, onSwatchHover }),
      React.createElement(EditableInput, {
        style: { input: styles2.input },
        value: hex,
        onChange: handleChange
      })
    )
  );
};
Block.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  colors: PropTypes.arrayOf(PropTypes.string),
  triangle: PropTypes.oneOf(["top", "hide"]),
  styles: PropTypes.object
};
Block.defaultProps = {
  width: 170,
  colors: ["#D9E3F0", "#F47373", "#697689", "#37D67A", "#2CCCE4", "#555555", "#dce775", "#ff8a65", "#ba68c8"],
  triangle: "top",
  styles: {}
};
ColorWrap(Block);
var red = { "50": "#ffebee", "100": "#ffcdd2", "200": "#ef9a9a", "300": "#e57373", "400": "#ef5350", "500": "#f44336", "600": "#e53935", "700": "#d32f2f", "800": "#c62828", "900": "#b71c1c", "a100": "#ff8a80", "a200": "#ff5252", "a400": "#ff1744", "a700": "#d50000" };
var pink = { "50": "#fce4ec", "100": "#f8bbd0", "200": "#f48fb1", "300": "#f06292", "400": "#ec407a", "500": "#e91e63", "600": "#d81b60", "700": "#c2185b", "800": "#ad1457", "900": "#880e4f", "a100": "#ff80ab", "a200": "#ff4081", "a400": "#f50057", "a700": "#c51162" };
var purple = { "50": "#f3e5f5", "100": "#e1bee7", "200": "#ce93d8", "300": "#ba68c8", "400": "#ab47bc", "500": "#9c27b0", "600": "#8e24aa", "700": "#7b1fa2", "800": "#6a1b9a", "900": "#4a148c", "a100": "#ea80fc", "a200": "#e040fb", "a400": "#d500f9", "a700": "#aa00ff" };
var deepPurple = { "50": "#ede7f6", "100": "#d1c4e9", "200": "#b39ddb", "300": "#9575cd", "400": "#7e57c2", "500": "#673ab7", "600": "#5e35b1", "700": "#512da8", "800": "#4527a0", "900": "#311b92", "a100": "#b388ff", "a200": "#7c4dff", "a400": "#651fff", "a700": "#6200ea" };
var indigo = { "50": "#e8eaf6", "100": "#c5cae9", "200": "#9fa8da", "300": "#7986cb", "400": "#5c6bc0", "500": "#3f51b5", "600": "#3949ab", "700": "#303f9f", "800": "#283593", "900": "#1a237e", "a100": "#8c9eff", "a200": "#536dfe", "a400": "#3d5afe", "a700": "#304ffe" };
var blue = { "50": "#e3f2fd", "100": "#bbdefb", "200": "#90caf9", "300": "#64b5f6", "400": "#42a5f5", "500": "#2196f3", "600": "#1e88e5", "700": "#1976d2", "800": "#1565c0", "900": "#0d47a1", "a100": "#82b1ff", "a200": "#448aff", "a400": "#2979ff", "a700": "#2962ff" };
var lightBlue = { "50": "#e1f5fe", "100": "#b3e5fc", "200": "#81d4fa", "300": "#4fc3f7", "400": "#29b6f6", "500": "#03a9f4", "600": "#039be5", "700": "#0288d1", "800": "#0277bd", "900": "#01579b", "a100": "#80d8ff", "a200": "#40c4ff", "a400": "#00b0ff", "a700": "#0091ea" };
var cyan = { "50": "#e0f7fa", "100": "#b2ebf2", "200": "#80deea", "300": "#4dd0e1", "400": "#26c6da", "500": "#00bcd4", "600": "#00acc1", "700": "#0097a7", "800": "#00838f", "900": "#006064", "a100": "#84ffff", "a200": "#18ffff", "a400": "#00e5ff", "a700": "#00b8d4" };
var teal = { "50": "#e0f2f1", "100": "#b2dfdb", "200": "#80cbc4", "300": "#4db6ac", "400": "#26a69a", "500": "#009688", "600": "#00897b", "700": "#00796b", "800": "#00695c", "900": "#004d40", "a100": "#a7ffeb", "a200": "#64ffda", "a400": "#1de9b6", "a700": "#00bfa5" };
var green = { "50": "#e8f5e9", "100": "#c8e6c9", "200": "#a5d6a7", "300": "#81c784", "400": "#66bb6a", "500": "#4caf50", "600": "#43a047", "700": "#388e3c", "800": "#2e7d32", "900": "#1b5e20", "a100": "#b9f6ca", "a200": "#69f0ae", "a400": "#00e676", "a700": "#00c853" };
var lightGreen = { "50": "#f1f8e9", "100": "#dcedc8", "200": "#c5e1a5", "300": "#aed581", "400": "#9ccc65", "500": "#8bc34a", "600": "#7cb342", "700": "#689f38", "800": "#558b2f", "900": "#33691e", "a100": "#ccff90", "a200": "#b2ff59", "a400": "#76ff03", "a700": "#64dd17" };
var lime = { "50": "#f9fbe7", "100": "#f0f4c3", "200": "#e6ee9c", "300": "#dce775", "400": "#d4e157", "500": "#cddc39", "600": "#c0ca33", "700": "#afb42b", "800": "#9e9d24", "900": "#827717", "a100": "#f4ff81", "a200": "#eeff41", "a400": "#c6ff00", "a700": "#aeea00" };
var yellow = { "50": "#fffde7", "100": "#fff9c4", "200": "#fff59d", "300": "#fff176", "400": "#ffee58", "500": "#ffeb3b", "600": "#fdd835", "700": "#fbc02d", "800": "#f9a825", "900": "#f57f17", "a100": "#ffff8d", "a200": "#ffff00", "a400": "#ffea00", "a700": "#ffd600" };
var amber = { "50": "#fff8e1", "100": "#ffecb3", "200": "#ffe082", "300": "#ffd54f", "400": "#ffca28", "500": "#ffc107", "600": "#ffb300", "700": "#ffa000", "800": "#ff8f00", "900": "#ff6f00", "a100": "#ffe57f", "a200": "#ffd740", "a400": "#ffc400", "a700": "#ffab00" };
var orange = { "50": "#fff3e0", "100": "#ffe0b2", "200": "#ffcc80", "300": "#ffb74d", "400": "#ffa726", "500": "#ff9800", "600": "#fb8c00", "700": "#f57c00", "800": "#ef6c00", "900": "#e65100", "a100": "#ffd180", "a200": "#ffab40", "a400": "#ff9100", "a700": "#ff6d00" };
var deepOrange = { "50": "#fbe9e7", "100": "#ffccbc", "200": "#ffab91", "300": "#ff8a65", "400": "#ff7043", "500": "#ff5722", "600": "#f4511e", "700": "#e64a19", "800": "#d84315", "900": "#bf360c", "a100": "#ff9e80", "a200": "#ff6e40", "a400": "#ff3d00", "a700": "#dd2c00" };
var brown = { "50": "#efebe9", "100": "#d7ccc8", "200": "#bcaaa4", "300": "#a1887f", "400": "#8d6e63", "500": "#795548", "600": "#6d4c41", "700": "#5d4037", "800": "#4e342e", "900": "#3e2723" };
var blueGrey = { "50": "#eceff1", "100": "#cfd8dc", "200": "#b0bec5", "300": "#90a4ae", "400": "#78909c", "500": "#607d8b", "600": "#546e7a", "700": "#455a64", "800": "#37474f", "900": "#263238" };
var CircleSwatch = function CircleSwatch2(_ref) {
  var color = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, hover3 = _ref.hover, active3 = _ref.active, circleSize = _ref.circleSize, circleSpacing = _ref.circleSpacing;
  var styles2 = _default$2({
    "default": {
      swatch: {
        width: circleSize,
        height: circleSize,
        marginRight: circleSpacing,
        marginBottom: circleSpacing,
        transform: "scale(1)",
        transition: "100ms transform ease"
      },
      Swatch: {
        borderRadius: "50%",
        background: "transparent",
        boxShadow: "inset 0 0 0 " + (circleSize / 2 + 1) + "px " + color,
        transition: "100ms box-shadow ease"
      }
    },
    "hover": {
      swatch: {
        transform: "scale(1.2)"
      }
    },
    "active": {
      Swatch: {
        boxShadow: "inset 0 0 0 3px " + color
      }
    }
  }, { hover: hover3, active: active3 });
  return React.createElement(
    "div",
    { style: styles2.swatch },
    React.createElement(Swatch$1, {
      style: styles2.Swatch,
      color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: styles2.Swatch.boxShadow + ", 0 0 5px " + color }
    })
  );
};
CircleSwatch.defaultProps = {
  circleSize: 28,
  circleSpacing: 14
};
const CircleSwatch$1 = handleHover(CircleSwatch);
var Circle = function Circle2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, circleSize = _ref.circleSize, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, circleSpacing = _ref.circleSpacing, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$2(merge({
    "default": {
      card: {
        width,
        display: "flex",
        flexWrap: "wrap",
        marginRight: -circleSpacing,
        marginBottom: -circleSpacing
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(hexCode, e2) {
    return onChange({ hex: hexCode, source: "hex" }, e2);
  };
  return React.createElement(
    "div",
    { style: styles2.card, className: "circle-picker " + className },
    map2(colors, function(c2) {
      return React.createElement(CircleSwatch$1, {
        key: c2,
        color: c2,
        onClick: handleChange,
        onSwatchHover,
        active: hex === c2.toLowerCase(),
        circleSize,
        circleSpacing
      });
    })
  );
};
Circle.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  circleSize: PropTypes.number,
  circleSpacing: PropTypes.number,
  styles: PropTypes.object
};
Circle.defaultProps = {
  width: 252,
  circleSize: 28,
  circleSpacing: 14,
  colors: [red["500"], pink["500"], purple["500"], deepPurple["500"], indigo["500"], blue["500"], lightBlue["500"], cyan["500"], teal["500"], green["500"], lightGreen["500"], lime["500"], yellow["500"], amber["500"], orange["500"], deepOrange["500"], brown["500"], blueGrey["500"]],
  styles: {}
};
ColorWrap(Circle);
function isUndefined(value) {
  return value === void 0;
}
var UnfoldMoreHorizontalIcon = {};
Object.defineProperty(UnfoldMoreHorizontalIcon, "__esModule", {
  value: true
});
var _extends$4 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react$1 = reactExports;
var _react2$1 = _interopRequireDefault$4(_react$1);
function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _objectWithoutProperties$1(obj, keys4) {
  var target = {};
  for (var i2 in obj) {
    if (keys4.indexOf(i2) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i2)) continue;
    target[i2] = obj[i2];
  }
  return target;
}
var DEFAULT_SIZE$1 = 24;
var _default$1 = UnfoldMoreHorizontalIcon.default = function(_ref) {
  var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE$1 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE$1 : _ref$height, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties$1(_ref, ["fill", "width", "height", "style"]);
  return _react2$1.default.createElement(
    "svg",
    _extends$4({
      viewBox: "0 0 " + DEFAULT_SIZE$1 + " " + DEFAULT_SIZE$1,
      style: _extends$4({ fill, width, height }, style)
    }, props),
    _react2$1.default.createElement("path", { d: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z" })
  );
};
var _createClass$1 = /* @__PURE__ */ function() {
  function defineProperties2(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties2(Constructor.prototype, protoProps);
    if (staticProps) defineProperties2(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$1(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$1(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ChromeFields = function(_React$Component) {
  _inherits$1(ChromeFields2, _React$Component);
  function ChromeFields2(props) {
    _classCallCheck$1(this, ChromeFields2);
    var _this = _possibleConstructorReturn$1(this, (ChromeFields2.__proto__ || Object.getPrototypeOf(ChromeFields2)).call(this));
    _this.toggleViews = function() {
      if (_this.state.view === "hex") {
        _this.setState({ view: "rgb" });
      } else if (_this.state.view === "rgb") {
        _this.setState({ view: "hsl" });
      } else if (_this.state.view === "hsl") {
        if (_this.props.hsl.a === 1) {
          _this.setState({ view: "hex" });
        } else {
          _this.setState({ view: "rgb" });
        }
      }
    };
    _this.handleChange = function(data, e2) {
      if (data.hex) {
        isValidHex(data.hex) && _this.props.onChange({
          hex: data.hex,
          source: "hex"
        }, e2);
      } else if (data.r || data.g || data.b) {
        _this.props.onChange({
          r: data.r || _this.props.rgb.r,
          g: data.g || _this.props.rgb.g,
          b: data.b || _this.props.rgb.b,
          source: "rgb"
        }, e2);
      } else if (data.a) {
        if (data.a < 0) {
          data.a = 0;
        } else if (data.a > 1) {
          data.a = 1;
        }
        _this.props.onChange({
          h: _this.props.hsl.h,
          s: _this.props.hsl.s,
          l: _this.props.hsl.l,
          a: Math.round(data.a * 100) / 100,
          source: "rgb"
        }, e2);
      } else if (data.h || data.s || data.l) {
        if (typeof data.s === "string" && data.s.includes("%")) {
          data.s = data.s.replace("%", "");
        }
        if (typeof data.l === "string" && data.l.includes("%")) {
          data.l = data.l.replace("%", "");
        }
        if (data.s == 1) {
          data.s = 0.01;
        } else if (data.l == 1) {
          data.l = 0.01;
        }
        _this.props.onChange({
          h: data.h || _this.props.hsl.h,
          s: Number(!isUndefined(data.s) ? data.s : _this.props.hsl.s),
          l: Number(!isUndefined(data.l) ? data.l : _this.props.hsl.l),
          source: "hsl"
        }, e2);
      }
    };
    _this.showHighlight = function(e2) {
      e2.currentTarget.style.background = "#eee";
    };
    _this.hideHighlight = function(e2) {
      e2.currentTarget.style.background = "transparent";
    };
    if (props.hsl.a !== 1 && props.view === "hex") {
      _this.state = {
        view: "rgb"
      };
    } else {
      _this.state = {
        view: props.view
      };
    }
    return _this;
  }
  _createClass$1(ChromeFields2, [{
    key: "render",
    value: function render3() {
      var _this2 = this;
      var styles2 = _default$2({
        "default": {
          wrap: {
            paddingTop: "16px",
            display: "flex"
          },
          fields: {
            flex: "1",
            display: "flex",
            marginLeft: "-6px"
          },
          field: {
            paddingLeft: "6px",
            width: "100%"
          },
          alpha: {
            paddingLeft: "6px",
            width: "100%"
          },
          toggle: {
            width: "32px",
            textAlign: "right",
            position: "relative"
          },
          icon: {
            marginRight: "-4px",
            marginTop: "12px",
            cursor: "pointer",
            position: "relative"
          },
          iconHighlight: {
            position: "absolute",
            width: "24px",
            height: "28px",
            background: "#eee",
            borderRadius: "4px",
            top: "10px",
            left: "12px",
            display: "none"
          },
          input: {
            fontSize: "11px",
            color: "#333",
            width: "100%",
            borderRadius: "2px",
            border: "none",
            boxShadow: "inset 0 0 0 1px #dadada",
            height: "21px",
            textAlign: "center"
          },
          label: {
            textTransform: "uppercase",
            fontSize: "11px",
            lineHeight: "11px",
            color: "#969696",
            textAlign: "center",
            display: "block",
            marginTop: "12px"
          },
          svg: {
            fill: "#333",
            width: "24px",
            height: "24px",
            border: "1px transparent solid",
            borderRadius: "5px"
          }
        },
        "disableAlpha": {
          alpha: {
            display: "none"
          }
        }
      }, this.props, this.state);
      var fields = void 0;
      if (this.state.view === "hex") {
        fields = React.createElement(
          "div",
          { style: styles2.fields, className: "flexbox-fix" },
          React.createElement(
            "div",
            { style: styles2.field },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "hex",
              value: this.props.hex,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === "rgb") {
        fields = React.createElement(
          "div",
          { style: styles2.fields, className: "flexbox-fix" },
          React.createElement(
            "div",
            { style: styles2.field },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "r",
              value: this.props.rgb.r,
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.field },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "g",
              value: this.props.rgb.g,
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.field },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "b",
              value: this.props.rgb.b,
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.alpha },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "a",
              value: this.props.rgb.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === "hsl") {
        fields = React.createElement(
          "div",
          { style: styles2.fields, className: "flexbox-fix" },
          React.createElement(
            "div",
            { style: styles2.field },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "h",
              value: Math.round(this.props.hsl.h),
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.field },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "s",
              value: Math.round(this.props.hsl.s * 100) + "%",
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.field },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "l",
              value: Math.round(this.props.hsl.l * 100) + "%",
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.alpha },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "a",
              value: this.props.hsl.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      }
      return React.createElement(
        "div",
        { style: styles2.wrap, className: "flexbox-fix" },
        fields,
        React.createElement(
          "div",
          { style: styles2.toggle },
          React.createElement(
            "div",
            { style: styles2.icon, onClick: this.toggleViews, ref: function ref2(icon) {
              return _this2.icon = icon;
            } },
            React.createElement(_default$1, {
              style: styles2.svg,
              onMouseOver: this.showHighlight,
              onMouseEnter: this.showHighlight,
              onMouseOut: this.hideHighlight
            })
          )
        )
      );
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, state) {
      if (nextProps.hsl.a !== 1 && state.view === "hex") {
        return { view: "rgb" };
      }
      return null;
    }
  }]);
  return ChromeFields2;
}(React.Component);
ChromeFields.defaultProps = {
  view: "hex"
};
var ChromePointer = function ChromePointer2() {
  var styles2 = _default$2({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        transform: "translate(-6px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    }
  });
  return React.createElement("div", { style: styles2.picker });
};
var ChromePointerCircle = function ChromePointerCircle2() {
  var styles2 = _default$2({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        boxShadow: "inset 0 0 0 1px #fff",
        transform: "translate(-6px, -6px)"
      }
    }
  });
  return React.createElement("div", { style: styles2.picker });
};
var Chrome = function Chrome2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, disableAlpha = _ref.disableAlpha, rgb = _ref.rgb, hsl = _ref.hsl, hsv = _ref.hsv, hex = _ref.hex, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className, defaultView = _ref.defaultView;
  var styles2 = _default$2(merge({
    "default": {
      picker: {
        width,
        background: "#fff",
        borderRadius: "2px",
        boxShadow: "0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)",
        boxSizing: "initial",
        fontFamily: "Menlo"
      },
      saturation: {
        width: "100%",
        paddingBottom: "55%",
        position: "relative",
        borderRadius: "2px 2px 0 0",
        overflow: "hidden"
      },
      Saturation: {
        radius: "2px 2px 0 0"
      },
      body: {
        padding: "16px 16px 12px"
      },
      controls: {
        display: "flex"
      },
      color: {
        width: "32px"
      },
      swatch: {
        marginTop: "6px",
        width: "16px",
        height: "16px",
        borderRadius: "8px",
        position: "relative",
        overflow: "hidden"
      },
      active: {
        absolute: "0px 0px 0px 0px",
        borderRadius: "8px",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.1)",
        background: "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", " + rgb.a + ")",
        zIndex: "2"
      },
      toggles: {
        flex: "1"
      },
      hue: {
        height: "10px",
        position: "relative",
        marginBottom: "8px"
      },
      Hue: {
        radius: "2px"
      },
      alpha: {
        height: "10px",
        position: "relative"
      },
      Alpha: {
        radius: "2px"
      }
    },
    "disableAlpha": {
      color: {
        width: "22px"
      },
      alpha: {
        display: "none"
      },
      hue: {
        marginBottom: "0px"
      },
      swatch: {
        width: "10px",
        height: "10px",
        marginTop: "0px"
      }
    }
  }, passedStyles), { disableAlpha });
  return React.createElement(
    "div",
    { style: styles2.picker, className: "chrome-picker " + className },
    React.createElement(
      "div",
      { style: styles2.saturation },
      React.createElement(Saturation, {
        style: styles2.Saturation,
        hsl,
        hsv,
        pointer: ChromePointerCircle,
        onChange
      })
    ),
    React.createElement(
      "div",
      { style: styles2.body },
      React.createElement(
        "div",
        { style: styles2.controls, className: "flexbox-fix" },
        React.createElement(
          "div",
          { style: styles2.color },
          React.createElement(
            "div",
            { style: styles2.swatch },
            React.createElement("div", { style: styles2.active }),
            React.createElement(Checkboard, { renderers })
          )
        ),
        React.createElement(
          "div",
          { style: styles2.toggles },
          React.createElement(
            "div",
            { style: styles2.hue },
            React.createElement(Hue, {
              style: styles2.Hue,
              hsl,
              pointer: ChromePointer,
              onChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.alpha },
            React.createElement(Alpha, {
              style: styles2.Alpha,
              rgb,
              hsl,
              pointer: ChromePointer,
              renderers,
              onChange
            })
          )
        )
      ),
      React.createElement(ChromeFields, {
        rgb,
        hsl,
        hex,
        view: defaultView,
        onChange,
        disableAlpha
      })
    )
  );
};
Chrome.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  disableAlpha: PropTypes.bool,
  styles: PropTypes.object,
  defaultView: PropTypes.oneOf(["hex", "rgb", "hsl"])
};
Chrome.defaultProps = {
  width: 225,
  disableAlpha: false,
  styles: {}
};
const ChromePicker = ColorWrap(Chrome);
var CompactColor = function CompactColor2(_ref) {
  var color = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, active3 = _ref.active;
  var styles2 = _default$2({
    "default": {
      color: {
        background: color,
        width: "15px",
        height: "15px",
        float: "left",
        marginRight: "5px",
        marginBottom: "5px",
        position: "relative",
        cursor: "pointer"
      },
      dot: {
        absolute: "5px 5px 5px 5px",
        background: getContrastingColor(color),
        borderRadius: "50%",
        opacity: "0"
      }
    },
    "active": {
      dot: {
        opacity: "1"
      }
    },
    "color-#FFFFFF": {
      color: {
        boxShadow: "inset 0 0 0 1px #ddd"
      },
      dot: {
        background: "#000"
      }
    },
    "transparent": {
      dot: {
        background: "#000"
      }
    }
  }, { active: active3, "color-#FFFFFF": color === "#FFFFFF", "transparent": color === "transparent" });
  return React.createElement(
    Swatch$1,
    {
      style: styles2.color,
      color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: "0 0 4px " + color }
    },
    React.createElement("div", { style: styles2.dot })
  );
};
var CompactFields = function CompactFields2(_ref) {
  var hex = _ref.hex, rgb = _ref.rgb, onChange = _ref.onChange;
  var styles2 = _default$2({
    "default": {
      fields: {
        display: "flex",
        paddingBottom: "6px",
        paddingRight: "5px",
        position: "relative"
      },
      active: {
        position: "absolute",
        top: "6px",
        left: "5px",
        height: "9px",
        width: "9px",
        background: hex
      },
      HEXwrap: {
        flex: "6",
        position: "relative"
      },
      HEXinput: {
        width: "80%",
        padding: "0px",
        paddingLeft: "20%",
        border: "none",
        outline: "none",
        background: "none",
        fontSize: "12px",
        color: "#333",
        height: "16px"
      },
      HEXlabel: {
        display: "none"
      },
      RGBwrap: {
        flex: "3",
        position: "relative"
      },
      RGBinput: {
        width: "70%",
        padding: "0px",
        paddingLeft: "30%",
        border: "none",
        outline: "none",
        background: "none",
        fontSize: "12px",
        color: "#333",
        height: "16px"
      },
      RGBlabel: {
        position: "absolute",
        top: "3px",
        left: "0px",
        lineHeight: "16px",
        textTransform: "uppercase",
        fontSize: "12px",
        color: "#999"
      }
    }
  });
  var handleChange = function handleChange2(data, e2) {
    if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: "rgb"
      }, e2);
    } else {
      onChange({
        hex: data.hex,
        source: "hex"
      }, e2);
    }
  };
  return React.createElement(
    "div",
    { style: styles2.fields, className: "flexbox-fix" },
    React.createElement("div", { style: styles2.active }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.HEXwrap, input: styles2.HEXinput, label: styles2.HEXlabel },
      label: "hex",
      value: hex,
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "r",
      value: rgb.r,
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "g",
      value: rgb.g,
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "b",
      value: rgb.b,
      onChange: handleChange
    })
  );
};
var Compact = function Compact2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, rgb = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$2(merge({
    "default": {
      Compact: {
        background: "#f6f6f6",
        radius: "4px"
      },
      compact: {
        paddingTop: "5px",
        paddingLeft: "5px",
        boxSizing: "initial",
        width: "240px"
      },
      clear: {
        clear: "both"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e2) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e2);
    } else {
      onChange(data, e2);
    }
  };
  return React.createElement(
    Raised,
    { style: styles2.Compact, styles: passedStyles },
    React.createElement(
      "div",
      { style: styles2.compact, className: "compact-picker " + className },
      React.createElement(
        "div",
        null,
        map2(colors, function(c2) {
          return React.createElement(CompactColor, {
            key: c2,
            color: c2,
            active: c2.toLowerCase() === hex,
            onClick: handleChange,
            onSwatchHover
          });
        }),
        React.createElement("div", { style: styles2.clear })
      ),
      React.createElement(CompactFields, { hex, rgb, onChange: handleChange })
    )
  );
};
Compact.propTypes = {
  colors: PropTypes.arrayOf(PropTypes.string),
  styles: PropTypes.object
};
Compact.defaultProps = {
  colors: ["#4D4D4D", "#999999", "#FFFFFF", "#F44E3B", "#FE9200", "#FCDC00", "#DBDF00", "#A4DD00", "#68CCCA", "#73D8FF", "#AEA1FF", "#FDA1FF", "#333333", "#808080", "#cccccc", "#D33115", "#E27300", "#FCC400", "#B0BC00", "#68BC00", "#16A5A5", "#009CE0", "#7B64FF", "#FA28FF", "#000000", "#666666", "#B3B3B3", "#9F0500", "#C45100", "#FB9E00", "#808900", "#194D33", "#0C797D", "#0062B1", "#653294", "#AB149E"],
  styles: {}
};
ColorWrap(Compact);
var GithubSwatch = function GithubSwatch2(_ref) {
  var hover3 = _ref.hover, color = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
  var hoverSwatch = {
    position: "relative",
    zIndex: "2",
    outline: "2px solid #fff",
    boxShadow: "0 0 5px 2px rgba(0,0,0,0.25)"
  };
  var styles2 = _default$2({
    "default": {
      swatch: {
        width: "25px",
        height: "25px",
        fontSize: "0"
      }
    },
    "hover": {
      swatch: hoverSwatch
    }
  }, { hover: hover3 });
  return React.createElement(
    "div",
    { style: styles2.swatch },
    React.createElement(Swatch$1, {
      color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: hoverSwatch
    })
  );
};
const GithubSwatch$1 = handleHover(GithubSwatch);
var Github = function Github2(_ref) {
  var width = _ref.width, colors = _ref.colors, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$2(merge({
    "default": {
      card: {
        width,
        background: "#fff",
        border: "1px solid rgba(0,0,0,0.2)",
        boxShadow: "0 3px 12px rgba(0,0,0,0.15)",
        borderRadius: "4px",
        position: "relative",
        padding: "5px",
        display: "flex",
        flexWrap: "wrap"
      },
      triangle: {
        position: "absolute",
        border: "7px solid transparent",
        borderBottomColor: "#fff"
      },
      triangleShadow: {
        position: "absolute",
        border: "8px solid transparent",
        borderBottomColor: "rgba(0,0,0,0.15)"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      },
      triangleShadow: {
        display: "none"
      }
    },
    "top-left-triangle": {
      triangle: {
        top: "-14px",
        left: "10px"
      },
      triangleShadow: {
        top: "-16px",
        left: "9px"
      }
    },
    "top-right-triangle": {
      triangle: {
        top: "-14px",
        right: "10px"
      },
      triangleShadow: {
        top: "-16px",
        right: "9px"
      }
    },
    "bottom-left-triangle": {
      triangle: {
        top: "35px",
        left: "10px",
        transform: "rotate(180deg)"
      },
      triangleShadow: {
        top: "37px",
        left: "9px",
        transform: "rotate(180deg)"
      }
    },
    "bottom-right-triangle": {
      triangle: {
        top: "35px",
        right: "10px",
        transform: "rotate(180deg)"
      },
      triangleShadow: {
        top: "37px",
        right: "9px",
        transform: "rotate(180deg)"
      }
    }
  }, passedStyles), {
    "hide-triangle": triangle === "hide",
    "top-left-triangle": triangle === "top-left",
    "top-right-triangle": triangle === "top-right",
    "bottom-left-triangle": triangle === "bottom-left",
    "bottom-right-triangle": triangle === "bottom-right"
  });
  var handleChange = function handleChange2(hex, e2) {
    return onChange({ hex, source: "hex" }, e2);
  };
  return React.createElement(
    "div",
    { style: styles2.card, className: "github-picker " + className },
    React.createElement("div", { style: styles2.triangleShadow }),
    React.createElement("div", { style: styles2.triangle }),
    map2(colors, function(c2) {
      return React.createElement(GithubSwatch$1, {
        color: c2,
        key: c2,
        onClick: handleChange,
        onSwatchHover
      });
    })
  );
};
Github.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  colors: PropTypes.arrayOf(PropTypes.string),
  triangle: PropTypes.oneOf(["hide", "top-left", "top-right", "bottom-left", "bottom-right"]),
  styles: PropTypes.object
};
Github.defaultProps = {
  width: 200,
  colors: ["#B80000", "#DB3E00", "#FCCB00", "#008B02", "#006B76", "#1273DE", "#004DCF", "#5300EB", "#EB9694", "#FAD0C3", "#FEF3BD", "#C1E1C5", "#BEDADC", "#C4DEF6", "#BED3F3", "#D4C4FB"],
  triangle: "top-left",
  styles: {}
};
ColorWrap(Github);
var SliderPointer$1 = function SliderPointer(_ref) {
  var direction = _ref.direction;
  var styles2 = _default$2({
    "default": {
      picker: {
        width: "18px",
        height: "18px",
        borderRadius: "50%",
        transform: "translate(-9px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    },
    "vertical": {
      picker: {
        transform: "translate(-3px, -9px)"
      }
    }
  }, { vertical: direction === "vertical" });
  return React.createElement("div", { style: styles2.picker });
};
var _extends$3 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var HuePicker = function HuePicker2(_ref) {
  var width = _ref.width, height = _ref.height, onChange = _ref.onChange, hsl = _ref.hsl, direction = _ref.direction, pointer = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$2(merge({
    "default": {
      picker: {
        position: "relative",
        width,
        height
      },
      hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data) {
    return onChange({ a: 1, h: data.h, l: 0.5, s: 1 });
  };
  return React.createElement(
    "div",
    { style: styles2.picker, className: "hue-picker " + className },
    React.createElement(Hue, _extends$3({}, styles2.hue, {
      hsl,
      pointer,
      onChange: handleChange,
      direction
    }))
  );
};
HuePicker.propTypes = {
  styles: PropTypes.object
};
HuePicker.defaultProps = {
  width: "316px",
  height: "16px",
  direction: "horizontal",
  pointer: SliderPointer$1,
  styles: {}
};
ColorWrap(HuePicker);
var Material = function Material2(_ref) {
  var onChange = _ref.onChange, hex = _ref.hex, rgb = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$2(merge({
    "default": {
      material: {
        width: "98px",
        height: "98px",
        padding: "16px",
        fontFamily: "Roboto"
      },
      HEXwrap: {
        position: "relative"
      },
      HEXinput: {
        width: "100%",
        marginTop: "12px",
        fontSize: "15px",
        color: "#333",
        padding: "0px",
        border: "0px",
        borderBottom: "2px solid " + hex,
        outline: "none",
        height: "30px"
      },
      HEXlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        fontSize: "11px",
        color: "#999999",
        textTransform: "capitalize"
      },
      Hex: {
        style: {}
      },
      RGBwrap: {
        position: "relative"
      },
      RGBinput: {
        width: "100%",
        marginTop: "12px",
        fontSize: "15px",
        color: "#333",
        padding: "0px",
        border: "0px",
        borderBottom: "1px solid #eee",
        outline: "none",
        height: "30px"
      },
      RGBlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        fontSize: "11px",
        color: "#999999",
        textTransform: "capitalize"
      },
      split: {
        display: "flex",
        marginRight: "-10px",
        paddingTop: "11px"
      },
      third: {
        flex: "1",
        paddingRight: "10px"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e2) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e2);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: "rgb"
      }, e2);
    }
  };
  return React.createElement(
    Raised,
    { styles: passedStyles },
    React.createElement(
      "div",
      { style: styles2.material, className: "material-picker " + className },
      React.createElement(EditableInput, {
        style: { wrap: styles2.HEXwrap, input: styles2.HEXinput, label: styles2.HEXlabel },
        label: "hex",
        value: hex,
        onChange: handleChange
      }),
      React.createElement(
        "div",
        { style: styles2.split, className: "flexbox-fix" },
        React.createElement(
          "div",
          { style: styles2.third },
          React.createElement(EditableInput, {
            style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
            label: "r",
            value: rgb.r,
            onChange: handleChange
          })
        ),
        React.createElement(
          "div",
          { style: styles2.third },
          React.createElement(EditableInput, {
            style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
            label: "g",
            value: rgb.g,
            onChange: handleChange
          })
        ),
        React.createElement(
          "div",
          { style: styles2.third },
          React.createElement(EditableInput, {
            style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
            label: "b",
            value: rgb.b,
            onChange: handleChange
          })
        )
      )
    )
  );
};
ColorWrap(Material);
var PhotoshopPicker = function PhotoshopPicker2(_ref) {
  var onChange = _ref.onChange, rgb = _ref.rgb, hsv = _ref.hsv, hex = _ref.hex;
  var styles2 = _default$2({
    "default": {
      fields: {
        paddingTop: "5px",
        paddingBottom: "9px",
        width: "80px",
        position: "relative"
      },
      divider: {
        height: "5px"
      },
      RGBwrap: {
        position: "relative"
      },
      RGBinput: {
        marginLeft: "40%",
        width: "40%",
        height: "18px",
        border: "1px solid #888888",
        boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
        marginBottom: "5px",
        fontSize: "13px",
        paddingLeft: "3px",
        marginRight: "10px"
      },
      RGBlabel: {
        left: "0px",
        top: "0px",
        width: "34px",
        textTransform: "uppercase",
        fontSize: "13px",
        height: "18px",
        lineHeight: "22px",
        position: "absolute"
      },
      HEXwrap: {
        position: "relative"
      },
      HEXinput: {
        marginLeft: "20%",
        width: "80%",
        height: "18px",
        border: "1px solid #888888",
        boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
        marginBottom: "6px",
        fontSize: "13px",
        paddingLeft: "3px"
      },
      HEXlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        width: "14px",
        textTransform: "uppercase",
        fontSize: "13px",
        height: "18px",
        lineHeight: "22px"
      },
      fieldSymbols: {
        position: "absolute",
        top: "5px",
        right: "-7px",
        fontSize: "13px"
      },
      symbol: {
        height: "20px",
        lineHeight: "22px",
        paddingBottom: "7px"
      }
    }
  });
  var handleChange = function handleChange2(data, e2) {
    if (data["#"]) {
      isValidHex(data["#"]) && onChange({
        hex: data["#"],
        source: "hex"
      }, e2);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: "rgb"
      }, e2);
    } else if (data.h || data.s || data.v) {
      onChange({
        h: data.h || hsv.h,
        s: data.s || hsv.s,
        v: data.v || hsv.v,
        source: "hsv"
      }, e2);
    }
  };
  return React.createElement(
    "div",
    { style: styles2.fields },
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "h",
      value: Math.round(hsv.h),
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "s",
      value: Math.round(hsv.s * 100),
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "v",
      value: Math.round(hsv.v * 100),
      onChange: handleChange
    }),
    React.createElement("div", { style: styles2.divider }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "r",
      value: rgb.r,
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "g",
      value: rgb.g,
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "b",
      value: rgb.b,
      onChange: handleChange
    }),
    React.createElement("div", { style: styles2.divider }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.HEXwrap, input: styles2.HEXinput, label: styles2.HEXlabel },
      label: "#",
      value: hex.replace("#", ""),
      onChange: handleChange
    }),
    React.createElement(
      "div",
      { style: styles2.fieldSymbols },
      React.createElement(
        "div",
        { style: styles2.symbol },
        "°"
      ),
      React.createElement(
        "div",
        { style: styles2.symbol },
        "%"
      ),
      React.createElement(
        "div",
        { style: styles2.symbol },
        "%"
      )
    )
  );
};
var PhotoshopPointerCircle$1 = function PhotoshopPointerCircle(_ref) {
  var hsl = _ref.hsl;
  var styles2 = _default$2({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        boxShadow: "inset 0 0 0 1px #fff",
        transform: "translate(-6px, -6px)"
      }
    },
    "black-outline": {
      picker: {
        boxShadow: "inset 0 0 0 1px #000"
      }
    }
  }, { "black-outline": hsl.l > 0.5 });
  return React.createElement("div", { style: styles2.picker });
};
var PhotoshopPointerCircle2 = function PhotoshopPointerCircle3() {
  var styles2 = _default$2({
    "default": {
      triangle: {
        width: 0,
        height: 0,
        borderStyle: "solid",
        borderWidth: "4px 0 4px 6px",
        borderColor: "transparent transparent transparent #fff",
        position: "absolute",
        top: "1px",
        left: "1px"
      },
      triangleBorder: {
        width: 0,
        height: 0,
        borderStyle: "solid",
        borderWidth: "5px 0 5px 8px",
        borderColor: "transparent transparent transparent #555"
      },
      left: {
        Extend: "triangleBorder",
        transform: "translate(-13px, -4px)"
      },
      leftInside: {
        Extend: "triangle",
        transform: "translate(-8px, -5px)"
      },
      right: {
        Extend: "triangleBorder",
        transform: "translate(20px, -14px) rotate(180deg)"
      },
      rightInside: {
        Extend: "triangle",
        transform: "translate(-8px, -5px)"
      }
    }
  });
  return React.createElement(
    "div",
    { style: styles2.pointer },
    React.createElement(
      "div",
      { style: styles2.left },
      React.createElement("div", { style: styles2.leftInside })
    ),
    React.createElement(
      "div",
      { style: styles2.right },
      React.createElement("div", { style: styles2.rightInside })
    )
  );
};
var PhotoshopButton = function PhotoshopButton2(_ref) {
  var onClick = _ref.onClick, label2 = _ref.label, children = _ref.children, active3 = _ref.active;
  var styles2 = _default$2({
    "default": {
      button: {
        backgroundImage: "linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)",
        border: "1px solid #878787",
        borderRadius: "2px",
        height: "20px",
        boxShadow: "0 1px 0 0 #EAEAEA",
        fontSize: "14px",
        color: "#000",
        lineHeight: "20px",
        textAlign: "center",
        marginBottom: "10px",
        cursor: "pointer"
      }
    },
    "active": {
      button: {
        boxShadow: "0 0 0 1px #878787"
      }
    }
  }, { active: active3 });
  return React.createElement(
    "div",
    { style: styles2.button, onClick },
    label2 || children
  );
};
var PhotoshopPreviews = function PhotoshopPreviews2(_ref) {
  var rgb = _ref.rgb, currentColor = _ref.currentColor;
  var styles2 = _default$2({
    "default": {
      swatches: {
        border: "1px solid #B3B3B3",
        borderBottom: "1px solid #F0F0F0",
        marginBottom: "2px",
        marginTop: "1px"
      },
      new: {
        height: "34px",
        background: "rgb(" + rgb.r + "," + rgb.g + ", " + rgb.b + ")",
        boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000"
      },
      current: {
        height: "34px",
        background: currentColor,
        boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000"
      },
      label: {
        fontSize: "14px",
        color: "#000",
        textAlign: "center"
      }
    }
  });
  return React.createElement(
    "div",
    null,
    React.createElement(
      "div",
      { style: styles2.label },
      "new"
    ),
    React.createElement(
      "div",
      { style: styles2.swatches },
      React.createElement("div", { style: styles2.new }),
      React.createElement("div", { style: styles2.current })
    ),
    React.createElement(
      "div",
      { style: styles2.label },
      "current"
    )
  );
};
var _createClass = /* @__PURE__ */ function() {
  function defineProperties2(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties2(Constructor.prototype, protoProps);
    if (staticProps) defineProperties2(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Photoshop = function(_React$Component) {
  _inherits(Photoshop2, _React$Component);
  function Photoshop2(props) {
    _classCallCheck(this, Photoshop2);
    var _this = _possibleConstructorReturn(this, (Photoshop2.__proto__ || Object.getPrototypeOf(Photoshop2)).call(this));
    _this.state = {
      currentColor: props.hex
    };
    return _this;
  }
  _createClass(Photoshop2, [{
    key: "render",
    value: function render3() {
      var _props = this.props, _props$styles = _props.styles, passedStyles = _props$styles === void 0 ? {} : _props$styles, _props$className = _props.className, className = _props$className === void 0 ? "" : _props$className;
      var styles2 = _default$2(merge({
        "default": {
          picker: {
            background: "#DCDCDC",
            borderRadius: "4px",
            boxShadow: "0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)",
            boxSizing: "initial",
            width: "513px"
          },
          head: {
            backgroundImage: "linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)",
            borderBottom: "1px solid #B1B1B1",
            boxShadow: "inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)",
            height: "23px",
            lineHeight: "24px",
            borderRadius: "4px 4px 0 0",
            fontSize: "13px",
            color: "#4D4D4D",
            textAlign: "center"
          },
          body: {
            padding: "15px 15px 0",
            display: "flex"
          },
          saturation: {
            width: "256px",
            height: "256px",
            position: "relative",
            border: "2px solid #B3B3B3",
            borderBottom: "2px solid #F0F0F0",
            overflow: "hidden"
          },
          hue: {
            position: "relative",
            height: "256px",
            width: "19px",
            marginLeft: "10px",
            border: "2px solid #B3B3B3",
            borderBottom: "2px solid #F0F0F0"
          },
          controls: {
            width: "180px",
            marginLeft: "10px"
          },
          top: {
            display: "flex"
          },
          previews: {
            width: "60px"
          },
          actions: {
            flex: "1",
            marginLeft: "20px"
          }
        }
      }, passedStyles));
      return React.createElement(
        "div",
        { style: styles2.picker, className: "photoshop-picker " + className },
        React.createElement(
          "div",
          { style: styles2.head },
          this.props.header
        ),
        React.createElement(
          "div",
          { style: styles2.body, className: "flexbox-fix" },
          React.createElement(
            "div",
            { style: styles2.saturation },
            React.createElement(Saturation, {
              hsl: this.props.hsl,
              hsv: this.props.hsv,
              pointer: PhotoshopPointerCircle$1,
              onChange: this.props.onChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.hue },
            React.createElement(Hue, {
              direction: "vertical",
              hsl: this.props.hsl,
              pointer: PhotoshopPointerCircle2,
              onChange: this.props.onChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.controls },
            React.createElement(
              "div",
              { style: styles2.top, className: "flexbox-fix" },
              React.createElement(
                "div",
                { style: styles2.previews },
                React.createElement(PhotoshopPreviews, {
                  rgb: this.props.rgb,
                  currentColor: this.state.currentColor
                })
              ),
              React.createElement(
                "div",
                { style: styles2.actions },
                React.createElement(PhotoshopButton, { label: "OK", onClick: this.props.onAccept, active: true }),
                React.createElement(PhotoshopButton, { label: "Cancel", onClick: this.props.onCancel }),
                React.createElement(PhotoshopPicker, {
                  onChange: this.props.onChange,
                  rgb: this.props.rgb,
                  hsv: this.props.hsv,
                  hex: this.props.hex
                })
              )
            )
          )
        )
      );
    }
  }]);
  return Photoshop2;
}(React.Component);
Photoshop.propTypes = {
  header: PropTypes.string,
  styles: PropTypes.object
};
Photoshop.defaultProps = {
  header: "Color Picker",
  styles: {}
};
ColorWrap(Photoshop);
var SketchFields = function SketchFields2(_ref) {
  var onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hex = _ref.hex, disableAlpha = _ref.disableAlpha;
  var styles2 = _default$2({
    "default": {
      fields: {
        display: "flex",
        paddingTop: "4px"
      },
      single: {
        flex: "1",
        paddingLeft: "6px"
      },
      alpha: {
        flex: "1",
        paddingLeft: "6px"
      },
      double: {
        flex: "2"
      },
      input: {
        width: "80%",
        padding: "4px 10% 3px",
        border: "none",
        boxShadow: "inset 0 0 0 1px #ccc",
        fontSize: "11px"
      },
      label: {
        display: "block",
        textAlign: "center",
        fontSize: "11px",
        color: "#222",
        paddingTop: "3px",
        paddingBottom: "4px",
        textTransform: "capitalize"
      }
    },
    "disableAlpha": {
      alpha: {
        display: "none"
      }
    }
  }, { disableAlpha });
  var handleChange = function handleChange2(data, e2) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e2);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        a: rgb.a,
        source: "rgb"
      }, e2);
    } else if (data.a) {
      if (data.a < 0) {
        data.a = 0;
      } else if (data.a > 100) {
        data.a = 100;
      }
      data.a /= 100;
      onChange({
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: data.a,
        source: "rgb"
      }, e2);
    }
  };
  return React.createElement(
    "div",
    { style: styles2.fields, className: "flexbox-fix" },
    React.createElement(
      "div",
      { style: styles2.double },
      React.createElement(EditableInput, {
        style: { input: styles2.input, label: styles2.label },
        label: "hex",
        value: hex.replace("#", ""),
        onChange: handleChange
      })
    ),
    React.createElement(
      "div",
      { style: styles2.single },
      React.createElement(EditableInput, {
        style: { input: styles2.input, label: styles2.label },
        label: "r",
        value: rgb.r,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    React.createElement(
      "div",
      { style: styles2.single },
      React.createElement(EditableInput, {
        style: { input: styles2.input, label: styles2.label },
        label: "g",
        value: rgb.g,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    React.createElement(
      "div",
      { style: styles2.single },
      React.createElement(EditableInput, {
        style: { input: styles2.input, label: styles2.label },
        label: "b",
        value: rgb.b,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    React.createElement(
      "div",
      { style: styles2.alpha },
      React.createElement(EditableInput, {
        style: { input: styles2.input, label: styles2.label },
        label: "a",
        value: Math.round(rgb.a * 100),
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "100"
      })
    )
  );
};
var _extends$2 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var SketchPresetColors = function SketchPresetColors2(_ref) {
  var colors = _ref.colors, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover;
  var styles2 = _default$2({
    "default": {
      colors: {
        margin: "0 -10px",
        padding: "10px 0 0 10px",
        borderTop: "1px solid #eee",
        display: "flex",
        flexWrap: "wrap",
        position: "relative"
      },
      swatchWrap: {
        width: "16px",
        height: "16px",
        margin: "0 10px 10px 0"
      },
      swatch: {
        borderRadius: "3px",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15)"
      }
    },
    "no-presets": {
      colors: {
        display: "none"
      }
    }
  }, {
    "no-presets": !colors || !colors.length
  });
  var handleClick = function handleClick2(hex, e2) {
    onClick({
      hex,
      source: "hex"
    }, e2);
  };
  return React.createElement(
    "div",
    { style: styles2.colors, className: "flexbox-fix" },
    colors.map(function(colorObjOrString) {
      var c2 = typeof colorObjOrString === "string" ? { color: colorObjOrString } : colorObjOrString;
      var key = "" + c2.color + (c2.title || "");
      return React.createElement(
        "div",
        { key, style: styles2.swatchWrap },
        React.createElement(Swatch$1, _extends$2({}, c2, {
          style: styles2.swatch,
          onClick: handleClick,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px " + c2.color
          }
        }))
      );
    })
  );
};
SketchPresetColors.propTypes = {
  colors: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
    color: PropTypes.string,
    title: PropTypes.string
  })])).isRequired
};
var _extends$1 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var Sketch = function Sketch2(_ref) {
  var width = _ref.width, rgb = _ref.rgb, hex = _ref.hex, hsv = _ref.hsv, hsl = _ref.hsl, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, disableAlpha = _ref.disableAlpha, presetColors = _ref.presetColors, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$2(merge({
    "default": _extends$1({
      picker: {
        width,
        padding: "10px 10px 0",
        boxSizing: "initial",
        background: "#fff",
        borderRadius: "4px",
        boxShadow: "0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)"
      },
      saturation: {
        width: "100%",
        paddingBottom: "75%",
        position: "relative",
        overflow: "hidden"
      },
      Saturation: {
        radius: "3px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      controls: {
        display: "flex"
      },
      sliders: {
        padding: "4px 0",
        flex: "1"
      },
      color: {
        width: "24px",
        height: "24px",
        position: "relative",
        marginTop: "4px",
        marginLeft: "4px",
        borderRadius: "3px"
      },
      activeColor: {
        absolute: "0px 0px 0px 0px",
        borderRadius: "2px",
        background: "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + rgb.a + ")",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      hue: {
        position: "relative",
        height: "10px",
        overflow: "hidden"
      },
      Hue: {
        radius: "2px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      alpha: {
        position: "relative",
        height: "10px",
        marginTop: "4px",
        overflow: "hidden"
      },
      Alpha: {
        radius: "2px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      }
    }, passedStyles),
    "disableAlpha": {
      color: {
        height: "10px"
      },
      hue: {
        height: "10px"
      },
      alpha: {
        display: "none"
      }
    }
  }, passedStyles), { disableAlpha });
  return React.createElement(
    "div",
    { style: styles2.picker, className: "sketch-picker " + className },
    React.createElement(
      "div",
      { style: styles2.saturation },
      React.createElement(Saturation, {
        style: styles2.Saturation,
        hsl,
        hsv,
        onChange
      })
    ),
    React.createElement(
      "div",
      { style: styles2.controls, className: "flexbox-fix" },
      React.createElement(
        "div",
        { style: styles2.sliders },
        React.createElement(
          "div",
          { style: styles2.hue },
          React.createElement(Hue, {
            style: styles2.Hue,
            hsl,
            onChange
          })
        ),
        React.createElement(
          "div",
          { style: styles2.alpha },
          React.createElement(Alpha, {
            style: styles2.Alpha,
            rgb,
            hsl,
            renderers,
            onChange
          })
        )
      ),
      React.createElement(
        "div",
        { style: styles2.color },
        React.createElement(Checkboard, null),
        React.createElement("div", { style: styles2.activeColor })
      )
    ),
    React.createElement(SketchFields, {
      rgb,
      hsl,
      hex,
      onChange,
      disableAlpha
    }),
    React.createElement(SketchPresetColors, {
      colors: presetColors,
      onClick: onChange,
      onSwatchHover
    })
  );
};
Sketch.propTypes = {
  disableAlpha: PropTypes.bool,
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  styles: PropTypes.object
};
Sketch.defaultProps = {
  disableAlpha: false,
  width: 200,
  styles: {},
  presetColors: ["#D0021B", "#F5A623", "#F8E71C", "#8B572A", "#7ED321", "#417505", "#BD10E0", "#9013FE", "#4A90E2", "#50E3C2", "#B8E986", "#000000", "#4A4A4A", "#9B9B9B", "#FFFFFF"]
};
ColorWrap(Sketch);
var SliderSwatch = function SliderSwatch2(_ref) {
  var hsl = _ref.hsl, offset2 = _ref.offset, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, active3 = _ref.active, first3 = _ref.first, last4 = _ref.last;
  var styles2 = _default$2({
    "default": {
      swatch: {
        height: "12px",
        background: "hsl(" + hsl.h + ", 50%, " + offset2 * 100 + "%)",
        cursor: "pointer"
      }
    },
    "first": {
      swatch: {
        borderRadius: "2px 0 0 2px"
      }
    },
    "last": {
      swatch: {
        borderRadius: "0 2px 2px 0"
      }
    },
    "active": {
      swatch: {
        transform: "scaleY(1.8)",
        borderRadius: "3.6px/2px"
      }
    }
  }, { active: active3, first: first3, last: last4 });
  var handleClick = function handleClick2(e2) {
    return onClick({
      h: hsl.h,
      s: 0.5,
      l: offset2,
      source: "hsl"
    }, e2);
  };
  return React.createElement("div", { style: styles2.swatch, onClick: handleClick });
};
var SliderSwatches = function SliderSwatches2(_ref) {
  var onClick = _ref.onClick, hsl = _ref.hsl;
  var styles2 = _default$2({
    "default": {
      swatches: {
        marginTop: "20px"
      },
      swatch: {
        boxSizing: "border-box",
        width: "20%",
        paddingRight: "1px",
        float: "left"
      },
      clear: {
        clear: "both"
      }
    }
  });
  var epsilon = 0.1;
  return React.createElement(
    "div",
    { style: styles2.swatches },
    React.createElement(
      "div",
      { style: styles2.swatch },
      React.createElement(SliderSwatch, {
        hsl,
        offset: ".80",
        active: Math.abs(hsl.l - 0.8) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick,
        first: true
      })
    ),
    React.createElement(
      "div",
      { style: styles2.swatch },
      React.createElement(SliderSwatch, {
        hsl,
        offset: ".65",
        active: Math.abs(hsl.l - 0.65) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick
      })
    ),
    React.createElement(
      "div",
      { style: styles2.swatch },
      React.createElement(SliderSwatch, {
        hsl,
        offset: ".50",
        active: Math.abs(hsl.l - 0.5) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick
      })
    ),
    React.createElement(
      "div",
      { style: styles2.swatch },
      React.createElement(SliderSwatch, {
        hsl,
        offset: ".35",
        active: Math.abs(hsl.l - 0.35) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick
      })
    ),
    React.createElement(
      "div",
      { style: styles2.swatch },
      React.createElement(SliderSwatch, {
        hsl,
        offset: ".20",
        active: Math.abs(hsl.l - 0.2) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick,
        last: true
      })
    ),
    React.createElement("div", { style: styles2.clear })
  );
};
var SliderPointer2 = function SliderPointer3() {
  var styles2 = _default$2({
    "default": {
      picker: {
        width: "14px",
        height: "14px",
        borderRadius: "6px",
        transform: "translate(-7px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    }
  });
  return React.createElement("div", { style: styles2.picker });
};
var Slider = function Slider3(_ref) {
  var hsl = _ref.hsl, onChange = _ref.onChange, pointer = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$2(merge({
    "default": {
      hue: {
        height: "12px",
        position: "relative"
      },
      Hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  return React.createElement(
    "div",
    { style: styles2.wrap || {}, className: "slider-picker " + className },
    React.createElement(
      "div",
      { style: styles2.hue },
      React.createElement(Hue, {
        style: styles2.Hue,
        hsl,
        pointer,
        onChange
      })
    ),
    React.createElement(
      "div",
      { style: styles2.swatches },
      React.createElement(SliderSwatches, { hsl, onClick: onChange })
    )
  );
};
Slider.propTypes = {
  styles: PropTypes.object
};
Slider.defaultProps = {
  pointer: SliderPointer2,
  styles: {}
};
ColorWrap(Slider);
var CheckIcon = {};
Object.defineProperty(CheckIcon, "__esModule", {
  value: true
});
var _extends = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react = reactExports;
var _react2 = _interopRequireDefault$3(_react);
function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _objectWithoutProperties(obj, keys4) {
  var target = {};
  for (var i2 in obj) {
    if (keys4.indexOf(i2) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i2)) continue;
    target[i2] = obj[i2];
  }
  return target;
}
var DEFAULT_SIZE = 24;
var _default = CheckIcon.default = function(_ref) {
  var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE : _ref$height, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties(_ref, ["fill", "width", "height", "style"]);
  return _react2.default.createElement(
    "svg",
    _extends({
      viewBox: "0 0 " + DEFAULT_SIZE + " " + DEFAULT_SIZE,
      style: _extends({ fill, width, height }, style)
    }, props),
    _react2.default.createElement("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" })
  );
};
var SwatchesColor = function SwatchesColor2(_ref) {
  var color = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, first3 = _ref.first, last4 = _ref.last, active3 = _ref.active;
  var styles2 = _default$2({
    "default": {
      color: {
        width: "40px",
        height: "24px",
        cursor: "pointer",
        background: color,
        marginBottom: "1px"
      },
      check: {
        color: getContrastingColor(color),
        marginLeft: "8px",
        display: "none"
      }
    },
    "first": {
      color: {
        overflow: "hidden",
        borderRadius: "2px 2px 0 0"
      }
    },
    "last": {
      color: {
        overflow: "hidden",
        borderRadius: "0 0 2px 2px"
      }
    },
    "active": {
      check: {
        display: "block"
      }
    },
    "color-#FFFFFF": {
      color: {
        boxShadow: "inset 0 0 0 1px #ddd"
      },
      check: {
        color: "#333"
      }
    },
    "transparent": {
      check: {
        color: "#333"
      }
    }
  }, {
    first: first3,
    last: last4,
    active: active3,
    "color-#FFFFFF": color === "#FFFFFF",
    "transparent": color === "transparent"
  });
  return React.createElement(
    Swatch$1,
    {
      color,
      style: styles2.color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: "0 0 4px " + color }
    },
    React.createElement(
      "div",
      { style: styles2.check },
      React.createElement(_default, null)
    )
  );
};
var SwatchesGroup = function SwatchesGroup2(_ref) {
  var onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, group3 = _ref.group, active3 = _ref.active;
  var styles2 = _default$2({
    "default": {
      group: {
        paddingBottom: "10px",
        width: "40px",
        float: "left",
        marginRight: "10px"
      }
    }
  });
  return React.createElement(
    "div",
    { style: styles2.group },
    map2(group3, function(color, i2) {
      return React.createElement(SwatchesColor, {
        key: color,
        color,
        active: color.toLowerCase() === active3,
        first: i2 === 0,
        last: i2 === group3.length - 1,
        onClick,
        onSwatchHover
      });
    })
  );
};
var Swatches = function Swatches2(_ref) {
  var width = _ref.width, height = _ref.height, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$2(merge({
    "default": {
      picker: {
        width,
        height
      },
      overflow: {
        height,
        overflowY: "scroll"
      },
      body: {
        padding: "16px 0 6px 16px"
      },
      clear: {
        clear: "both"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e2) {
    return onChange({ hex: data, source: "hex" }, e2);
  };
  return React.createElement(
    "div",
    { style: styles2.picker, className: "swatches-picker " + className },
    React.createElement(
      Raised,
      null,
      React.createElement(
        "div",
        { style: styles2.overflow },
        React.createElement(
          "div",
          { style: styles2.body },
          map2(colors, function(group3) {
            return React.createElement(SwatchesGroup, {
              key: group3.toString(),
              group: group3,
              active: hex,
              onClick: handleChange,
              onSwatchHover
            });
          }),
          React.createElement("div", { style: styles2.clear })
        )
      )
    )
  );
};
Swatches.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  colors: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),
  styles: PropTypes.object
  /* eslint-disable max-len */
};
Swatches.defaultProps = {
  width: 320,
  height: 240,
  colors: [[red["900"], red["700"], red["500"], red["300"], red["100"]], [pink["900"], pink["700"], pink["500"], pink["300"], pink["100"]], [purple["900"], purple["700"], purple["500"], purple["300"], purple["100"]], [deepPurple["900"], deepPurple["700"], deepPurple["500"], deepPurple["300"], deepPurple["100"]], [indigo["900"], indigo["700"], indigo["500"], indigo["300"], indigo["100"]], [blue["900"], blue["700"], blue["500"], blue["300"], blue["100"]], [lightBlue["900"], lightBlue["700"], lightBlue["500"], lightBlue["300"], lightBlue["100"]], [cyan["900"], cyan["700"], cyan["500"], cyan["300"], cyan["100"]], [teal["900"], teal["700"], teal["500"], teal["300"], teal["100"]], ["#194D33", green["700"], green["500"], green["300"], green["100"]], [lightGreen["900"], lightGreen["700"], lightGreen["500"], lightGreen["300"], lightGreen["100"]], [lime["900"], lime["700"], lime["500"], lime["300"], lime["100"]], [yellow["900"], yellow["700"], yellow["500"], yellow["300"], yellow["100"]], [amber["900"], amber["700"], amber["500"], amber["300"], amber["100"]], [orange["900"], orange["700"], orange["500"], orange["300"], orange["100"]], [deepOrange["900"], deepOrange["700"], deepOrange["500"], deepOrange["300"], deepOrange["100"]], [brown["900"], brown["700"], brown["500"], brown["300"], brown["100"]], [blueGrey["900"], blueGrey["700"], blueGrey["500"], blueGrey["300"], blueGrey["100"]], ["#000000", "#525252", "#969696", "#D9D9D9", "#FFFFFF"]],
  styles: {}
};
ColorWrap(Swatches);
var Twitter = function Twitter2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex = _ref.hex, colors = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$2(merge({
    "default": {
      card: {
        width,
        background: "#fff",
        border: "0 solid rgba(0,0,0,0.25)",
        boxShadow: "0 1px 4px rgba(0,0,0,0.25)",
        borderRadius: "4px",
        position: "relative"
      },
      body: {
        padding: "15px 9px 9px 15px"
      },
      label: {
        fontSize: "18px",
        color: "#fff"
      },
      triangle: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 9px 10px 9px",
        borderColor: "transparent transparent #fff transparent",
        position: "absolute"
      },
      triangleShadow: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 9px 10px 9px",
        borderColor: "transparent transparent rgba(0,0,0,.1) transparent",
        position: "absolute"
      },
      hash: {
        background: "#F0F0F0",
        height: "30px",
        width: "30px",
        borderRadius: "4px 0 0 4px",
        float: "left",
        color: "#98A1A4",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      },
      input: {
        width: "100px",
        fontSize: "14px",
        color: "#666",
        border: "0px",
        outline: "none",
        height: "28px",
        boxShadow: "inset 0 0 0 1px #F0F0F0",
        boxSizing: "content-box",
        borderRadius: "0 4px 4px 0",
        float: "left",
        paddingLeft: "8px"
      },
      swatch: {
        width: "30px",
        height: "30px",
        float: "left",
        borderRadius: "4px",
        margin: "0 6px 6px 0"
      },
      clear: {
        clear: "both"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      },
      triangleShadow: {
        display: "none"
      }
    },
    "top-left-triangle": {
      triangle: {
        top: "-10px",
        left: "12px"
      },
      triangleShadow: {
        top: "-11px",
        left: "12px"
      }
    },
    "top-right-triangle": {
      triangle: {
        top: "-10px",
        right: "12px"
      },
      triangleShadow: {
        top: "-11px",
        right: "12px"
      }
    }
  }, passedStyles), {
    "hide-triangle": triangle === "hide",
    "top-left-triangle": triangle === "top-left",
    "top-right-triangle": triangle === "top-right"
  });
  var handleChange = function handleChange2(hexcode, e2) {
    isValidHex(hexcode) && onChange({
      hex: hexcode,
      source: "hex"
    }, e2);
  };
  return React.createElement(
    "div",
    { style: styles2.card, className: "twitter-picker " + className },
    React.createElement("div", { style: styles2.triangleShadow }),
    React.createElement("div", { style: styles2.triangle }),
    React.createElement(
      "div",
      { style: styles2.body },
      map2(colors, function(c2, i2) {
        return React.createElement(Swatch$1, {
          key: i2,
          color: c2,
          hex: c2,
          style: styles2.swatch,
          onClick: handleChange,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: "0 0 4px " + c2
          }
        });
      }),
      React.createElement(
        "div",
        { style: styles2.hash },
        "#"
      ),
      React.createElement(EditableInput, {
        label: null,
        style: { input: styles2.input },
        value: hex.replace("#", ""),
        onChange: handleChange
      }),
      React.createElement("div", { style: styles2.clear })
    )
  );
};
Twitter.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  triangle: PropTypes.oneOf(["hide", "top-left", "top-right"]),
  colors: PropTypes.arrayOf(PropTypes.string),
  styles: PropTypes.object
};
Twitter.defaultProps = {
  width: 276,
  colors: ["#FF6900", "#FCB900", "#7BDCB5", "#00D084", "#8ED1FC", "#0693E3", "#ABB8C3", "#EB144C", "#F78DA7", "#9900EF"],
  triangle: "top-left",
  styles: {}
};
ColorWrap(Twitter);
var GooglePointerCircle = function GooglePointerCircle2(props) {
  var styles2 = _default$2({
    "default": {
      picker: {
        width: "20px",
        height: "20px",
        borderRadius: "22px",
        border: "2px #fff solid",
        transform: "translate(-12px, -13px)",
        background: "hsl(" + Math.round(props.hsl.h) + ", " + Math.round(props.hsl.s * 100) + "%, " + Math.round(props.hsl.l * 100) + "%)"
      }
    }
  });
  return React.createElement("div", { style: styles2.picker });
};
GooglePointerCircle.propTypes = {
  hsl: PropTypes.shape({
    h: PropTypes.number,
    s: PropTypes.number,
    l: PropTypes.number,
    a: PropTypes.number
  })
};
GooglePointerCircle.defaultProps = {
  hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
};
var GooglePointer = function GooglePointer2(props) {
  var styles2 = _default$2({
    "default": {
      picker: {
        width: "20px",
        height: "20px",
        borderRadius: "22px",
        transform: "translate(-10px, -7px)",
        background: "hsl(" + Math.round(props.hsl.h) + ", 100%, 50%)",
        border: "2px white solid"
      }
    }
  });
  return React.createElement("div", { style: styles2.picker });
};
GooglePointer.propTypes = {
  hsl: PropTypes.shape({
    h: PropTypes.number,
    s: PropTypes.number,
    l: PropTypes.number,
    a: PropTypes.number
  })
};
GooglePointer.defaultProps = {
  hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
};
var GoogleFields = function GoogleFields2(_ref) {
  var onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hex = _ref.hex, hsv = _ref.hsv;
  var handleChange = function handleChange2(data, e2) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e2);
    } else if (data.rgb) {
      var values2 = data.rgb.split(",");
      isvalidColorString(data.rgb, "rgb") && onChange({
        r: values2[0],
        g: values2[1],
        b: values2[2],
        a: 1,
        source: "rgb"
      }, e2);
    } else if (data.hsv) {
      var _values = data.hsv.split(",");
      if (isvalidColorString(data.hsv, "hsv")) {
        _values[2] = _values[2].replace("%", "");
        _values[1] = _values[1].replace("%", "");
        _values[0] = _values[0].replace("°", "");
        if (_values[1] == 1) {
          _values[1] = 0.01;
        } else if (_values[2] == 1) {
          _values[2] = 0.01;
        }
        onChange({
          h: Number(_values[0]),
          s: Number(_values[1]),
          v: Number(_values[2]),
          source: "hsv"
        }, e2);
      }
    } else if (data.hsl) {
      var _values2 = data.hsl.split(",");
      if (isvalidColorString(data.hsl, "hsl")) {
        _values2[2] = _values2[2].replace("%", "");
        _values2[1] = _values2[1].replace("%", "");
        _values2[0] = _values2[0].replace("°", "");
        if (hsvValue[1] == 1) {
          hsvValue[1] = 0.01;
        } else if (hsvValue[2] == 1) {
          hsvValue[2] = 0.01;
        }
        onChange({
          h: Number(_values2[0]),
          s: Number(_values2[1]),
          v: Number(_values2[2]),
          source: "hsl"
        }, e2);
      }
    }
  };
  var styles2 = _default$2({
    "default": {
      wrap: {
        display: "flex",
        height: "100px",
        marginTop: "4px"
      },
      fields: {
        width: "100%"
      },
      column: {
        paddingTop: "10px",
        display: "flex",
        justifyContent: "space-between"
      },
      double: {
        padding: "0px 4.4px",
        boxSizing: "border-box"
      },
      input: {
        width: "100%",
        height: "38px",
        boxSizing: "border-box",
        padding: "4px 10% 3px",
        textAlign: "center",
        border: "1px solid #dadce0",
        fontSize: "11px",
        textTransform: "lowercase",
        borderRadius: "5px",
        outline: "none",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      input2: {
        height: "38px",
        width: "100%",
        border: "1px solid #dadce0",
        boxSizing: "border-box",
        fontSize: "11px",
        textTransform: "lowercase",
        borderRadius: "5px",
        outline: "none",
        paddingLeft: "10px",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      label: {
        textAlign: "center",
        fontSize: "12px",
        background: "#fff",
        position: "absolute",
        textTransform: "uppercase",
        color: "#3c4043",
        width: "35px",
        top: "-6px",
        left: "0",
        right: "0",
        marginLeft: "auto",
        marginRight: "auto",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      label2: {
        left: "10px",
        textAlign: "center",
        fontSize: "12px",
        background: "#fff",
        position: "absolute",
        textTransform: "uppercase",
        color: "#3c4043",
        width: "32px",
        top: "-6px",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      single: {
        flexGrow: "1",
        margin: "0px 4.4px"
      }
    }
  });
  var rgbValue = rgb.r + ", " + rgb.g + ", " + rgb.b;
  var hslValue = Math.round(hsl.h) + "°, " + Math.round(hsl.s * 100) + "%, " + Math.round(hsl.l * 100) + "%";
  var hsvValue = Math.round(hsv.h) + "°, " + Math.round(hsv.s * 100) + "%, " + Math.round(hsv.v * 100) + "%";
  return React.createElement(
    "div",
    { style: styles2.wrap, className: "flexbox-fix" },
    React.createElement(
      "div",
      { style: styles2.fields },
      React.createElement(
        "div",
        { style: styles2.double },
        React.createElement(EditableInput, {
          style: { input: styles2.input, label: styles2.label },
          label: "hex",
          value: hex,
          onChange: handleChange
        })
      ),
      React.createElement(
        "div",
        { style: styles2.column },
        React.createElement(
          "div",
          { style: styles2.single },
          React.createElement(EditableInput, {
            style: { input: styles2.input2, label: styles2.label2 },
            label: "rgb",
            value: rgbValue,
            onChange: handleChange
          })
        ),
        React.createElement(
          "div",
          { style: styles2.single },
          React.createElement(EditableInput, {
            style: { input: styles2.input2, label: styles2.label2 },
            label: "hsv",
            value: hsvValue,
            onChange: handleChange
          })
        ),
        React.createElement(
          "div",
          { style: styles2.single },
          React.createElement(EditableInput, {
            style: { input: styles2.input2, label: styles2.label2 },
            label: "hsl",
            value: hslValue,
            onChange: handleChange
          })
        )
      )
    )
  );
};
var Google = function Google2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hsv = _ref.hsv, hex = _ref.hex, header2 = _ref.header, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$2(merge({
    "default": {
      picker: {
        width,
        background: "#fff",
        border: "1px solid #dfe1e5",
        boxSizing: "initial",
        display: "flex",
        flexWrap: "wrap",
        borderRadius: "8px 8px 0px 0px"
      },
      head: {
        height: "57px",
        width: "100%",
        paddingTop: "16px",
        paddingBottom: "16px",
        paddingLeft: "16px",
        fontSize: "20px",
        boxSizing: "border-box",
        fontFamily: "Roboto-Regular,HelveticaNeue,Arial,sans-serif"
      },
      saturation: {
        width: "70%",
        padding: "0px",
        position: "relative",
        overflow: "hidden"
      },
      swatch: {
        width: "30%",
        height: "228px",
        padding: "0px",
        background: "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", 1)",
        position: "relative",
        overflow: "hidden"
      },
      body: {
        margin: "auto",
        width: "95%"
      },
      controls: {
        display: "flex",
        boxSizing: "border-box",
        height: "52px",
        paddingTop: "22px"
      },
      color: {
        width: "32px"
      },
      hue: {
        height: "8px",
        position: "relative",
        margin: "0px 16px 0px 16px",
        width: "100%"
      },
      Hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  return React.createElement(
    "div",
    { style: styles2.picker, className: "google-picker " + className },
    React.createElement(
      "div",
      { style: styles2.head },
      header2
    ),
    React.createElement("div", { style: styles2.swatch }),
    React.createElement(
      "div",
      { style: styles2.saturation },
      React.createElement(Saturation, {
        hsl,
        hsv,
        pointer: GooglePointerCircle,
        onChange
      })
    ),
    React.createElement(
      "div",
      { style: styles2.body },
      React.createElement(
        "div",
        { style: styles2.controls, className: "flexbox-fix" },
        React.createElement(
          "div",
          { style: styles2.hue },
          React.createElement(Hue, {
            style: styles2.Hue,
            hsl,
            radius: "4px",
            pointer: GooglePointer,
            onChange
          })
        )
      ),
      React.createElement(GoogleFields, {
        rgb,
        hsl,
        hex,
        hsv,
        onChange
      })
    )
  );
};
Google.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  styles: PropTypes.object,
  header: PropTypes.string
};
Google.defaultProps = {
  width: 652,
  styles: {},
  header: "Color picker"
};
ColorWrap(Google);
const listFont = [
  "Merriweather",
  "Roboto",
  "Open Sans",
  "Lato",
  "Poppins",
  "Raleway",
  "Rubik",
  "Times New Roman",
  "Arial",
  "Courier New",
  "Georgia"
];
function Theming({ t: t2 }) {
  const designService = useService("design");
  const dispatch = useDispatch();
  const theme = useSelector((state) => {
    return state.designState.Survey.theme;
  });
  function handleChange(key, val) {
    if (key === "font") {
      const updatedTextStyles = { ...theme.textStyles };
      updatedTextStyles.group = { ...updatedTextStyles.group, font: val };
      updatedTextStyles.question = { ...updatedTextStyles.question, font: val };
      updatedTextStyles.text = { ...updatedTextStyles.text, font: val };
      dispatch(
        changeAttribute({
          code: "Survey",
          key: "theme",
          value: { ...theme, textStyles: updatedTextStyles }
        })
      );
    } else if (key === "textColor") {
      const updatedTextStyles = { ...theme.textStyles };
      updatedTextStyles.group = { ...updatedTextStyles.group, color: val };
      updatedTextStyles.question = {
        ...updatedTextStyles.question,
        color: val
      };
      updatedTextStyles.text = { ...updatedTextStyles.text, color: val };
      dispatch(
        changeAttribute({
          code: "Survey",
          key: "theme",
          value: { ...theme, textStyles: updatedTextStyles }
        })
      );
    } else if (key === "bgColor") {
      const rgbaMatch = val.match(
        /rgba?\((\d+),\s*(\d+),\s*(\d+),?\s*(\d?\.?\d+)?\)/
      );
      if (rgbaMatch) {
        const r2 = rgbaMatch[1];
        const g = rgbaMatch[2];
        const b = rgbaMatch[3];
        let a2 = rgbaMatch[4];
        if (!a2 || a2 === "0" || a2 === "0.0") {
          a2 = "1";
        }
        const newVal = "rgba(".concat(r2, ", ").concat(g, ", ").concat(b, ", ").concat(a2, ")");
        dispatch(
          changeAttribute({
            code: "Survey",
            key: "theme",
            value: { ...theme, bgColor: newVal }
          })
        );
      } else {
        dispatch(
          changeAttribute({
            code: "Survey",
            key: "theme",
            value: { ...theme, bgColor: val }
          })
        );
      }
    } else {
      dispatch(
        changeAttribute({
          code: "Survey",
          key: "theme",
          value: { ...theme, [key]: val }
        })
      );
    }
  }
  function handleBannerUpload(e2) {
    e2.preventDefault();
    let file = e2.target.files[0];
    designService.uploadResource(file).then((response) => {
      dispatch(
        changeResources({
          code: "Survey",
          key: "headerImage",
          value: response.name
        })
      );
    }).catch((err) => {
      console.error(err);
    });
  }
  const handleBannerReset = () => {
    dispatch(
      changeResources({
        code: "Survey",
        key: "headerImage",
        value: null
      })
    );
  };
  function handleBackgroundUpload(e2) {
    e2.preventDefault();
    let file = e2.target.files[0];
    designService.uploadResource(file).then((response) => {
      dispatch(
        changeResources({
          code: "Survey",
          key: "backgroundImage",
          value: response.name
        })
      );
      dispatch(
        changeAttribute({
          code: "Survey",
          key: "theme",
          value: { ...theme, bgColor: "rgba(0, 0, 0, 0)" }
        })
      );
    }).catch((err) => {
      console.error(err);
    });
  }
  const handleBackgroundReset = () => {
    dispatch(
      changeResources({
        code: "Survey",
        key: "backgroundImage",
        value: null
      })
    );
  };
  const showPrimaryPicker = useBoolean();
  const showBgPicker = useBoolean();
  const showPaperPicker = useBoolean();
  const showTextPicker = useBoolean();
  const closeAllPickers = () => {
    showPrimaryPicker.onFalse();
    showBgPicker.onFalse();
    showPaperPicker.onFalse();
    showTextPicker.onFalse();
  };
  const primaryPickerRef = reactExports.useRef();
  const bgPickerRef = reactExports.useRef();
  const paperPickerRef = reactExports.useRef();
  const textPickerRef = reactExports.useRef();
  function useClickOutside(ref2, callback) {
    reactExports.useEffect(() => {
      function handleClickOutside(event) {
        if (ref2.current && !ref2.current.contains(event.target)) {
          callback();
        }
      }
      document.addEventListener("mousedown", handleClickOutside);
      return () => {
        document.removeEventListener("mousedown", handleClickOutside);
      };
    }, [ref2, callback]);
  }
  useClickOutside(primaryPickerRef, closeAllPickers);
  useClickOutside(bgPickerRef, closeAllPickers);
  useClickOutside(paperPickerRef, closeAllPickers);
  useClickOutside(textPickerRef, closeAllPickers);
  const togglePicker = (picker) => {
    if (picker.value) {
      picker.onFalse();
    } else {
      closeAllPickers();
      picker.onToggle();
    }
  };
  const backgroundImage = useSelector(
    (state) => {
      var _a, _b;
      return (_b = (_a = state.designState["Survey"]) == null ? void 0 : _a.resources) == null ? void 0 : _b.backgroundImage;
    }
  );
  const bannerImage = useSelector(
    (state) => {
      var _a, _b;
      return (_b = (_a = state.designState["Survey"]) == null ? void 0 : _a.resources) == null ? void 0 : _b.headerImage;
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.theming, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$1.fontText, children: [
      " ",
      t2("font")
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Select,
      {
        sx: {
          "& .MuiSvgIcon-root": {
            color: "#16205b"
          }
        },
        IconComponent: KeyboardArrowDown,
        size: "small",
        className: styles$1.selectDropdown,
        value: theme.textStyles.group.font,
        onChange: (e2) => handleChange("font", e2.target.value),
        children: listFont && listFont.length > 0 && listFont.map((el, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          MenuItem,
          {
            sx: { fontFamily: el },
            value: el,
            children: el
          },
          "fontFamily-".concat(index2)
        ))
      },
      "fontFamily"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Stack$7,
      {
        display: "flex",
        justifyContent: "space-between",
        width: "100%",
        flexDirection: "row",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", alignSelf: "center", children: t2("group_title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ThemingItem,
            {
              value: theme.textStyles.group,
              default: defaultSurveyTheme.textStyles.group,
              onChange: (val) => {
                handleChange("textStyles", {
                  ...theme.textStyles,
                  ["group"]: val
                });
              }
            },
            "group"
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Stack$7,
      {
        display: "flex",
        justifyContent: "space-between",
        width: "100%",
        flexDirection: "row",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", alignSelf: "center", children: t2("question_title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ThemingItem,
            {
              value: theme.textStyles.question,
              default: defaultSurveyTheme.textStyles.question,
              onChange: (val) => handleChange("textStyles", {
                ...theme.textStyles,
                ["question"]: val
              })
            },
            "question"
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Stack$7,
      {
        display: "flex",
        justifyContent: "space-between",
        width: "100%",
        flexDirection: "row",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", alignSelf: "center", children: t2("theme_text") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ThemingItem,
            {
              value: theme.textStyles.text,
              default: defaultSurveyTheme.textStyles.text,
              onChange: (val) => handleChange("textStyles", {
                ...theme.textStyles,
                ["text"]: val
              })
            },
            "text"
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Stack$7,
      {
        display: "flex",
        justifyContent: "space-between",
        width: "100%",
        flexDirection: "row",
        position: "relative",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", alignSelf: "center", children: t2("highlight_color") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => togglePicker(showPrimaryPicker),
              style: { backgroundColor: theme.primaryColor },
              className: styles$1.colorBox
            }
          ),
          showPrimaryPicker.value && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ref: primaryPickerRef, className: styles$1.colorPickerContainer, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                onClick: () => togglePicker(showPrimaryPicker),
                style: {
                  marginLeft: "auto",
                  color: "#333"
                },
                "aria-label": "close",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, {})
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ChromePicker,
              {
                color: theme.primaryColor,
                onChange: (color) => {
                  handleChange(
                    "primaryColor",
                    "rgba(".concat(color.rgb.r, ", ").concat(color.rgb.g, ", ").concat(color.rgb.b, ", ").concat(color.rgb.a, ")")
                  );
                }
              }
            )
          ] })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Stack$7,
      {
        display: "flex",
        justifyContent: "space-between",
        width: "100%",
        flexDirection: "row",
        position: "relative",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", alignSelf: "center", children: t2("background_color") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => togglePicker(showBgPicker),
              style: { backgroundColor: theme.bgColor },
              className: styles$1.colorBox
            }
          ),
          showBgPicker.value && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ref: bgPickerRef, className: styles$1.colorPickerContainer, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                onClick: () => togglePicker(showBgPicker),
                style: {
                  marginLeft: "auto",
                  color: "#333"
                },
                "aria-label": "close",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, {})
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ChromePicker,
              {
                color: theme.bgColor,
                onChange: (color) => {
                  handleChange(
                    "bgColor",
                    "rgba(".concat(color.rgb.r, ", ").concat(color.rgb.g, ", ").concat(color.rgb.b, ", ").concat(color.rgb.a, ")")
                  );
                }
              }
            )
          ] })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Stack$7,
      {
        display: "flex",
        justifyContent: "space-between",
        width: "100%",
        flexDirection: "row",
        position: "relative",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", alignSelf: "center", children: t2("foreground_color") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => togglePicker(showPaperPicker),
              style: { backgroundColor: theme.paperColor },
              className: styles$1.colorBox
            }
          ),
          showPaperPicker.value && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ref: paperPickerRef, className: styles$1.colorPickerContainer, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                onClick: () => togglePicker(showPaperPicker),
                style: {
                  marginLeft: "auto",
                  color: "#333"
                },
                "aria-label": "close",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, {})
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ChromePicker,
              {
                color: theme.paperColor,
                onChange: (color) => {
                  handleChange(
                    "paperColor",
                    "rgba(".concat(color.rgb.r, ", ").concat(color.rgb.g, ", ").concat(color.rgb.b, ", ").concat(color.rgb.a, ")")
                  );
                }
              }
            )
          ] })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Stack$7,
      {
        display: "flex",
        justifyContent: "space-between",
        width: "100%",
        flexDirection: "row",
        position: "relative",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", alignSelf: "center", children: t2("text_color") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => togglePicker(showTextPicker),
              style: { backgroundColor: theme.textStyles.group.color },
              className: styles$1.colorBox
            }
          ),
          showTextPicker.value && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ref: textPickerRef, className: styles$1.colorPickerContainer, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                onClick: () => togglePicker(showTextPicker),
                style: {
                  marginLeft: "auto",
                  color: "#333"
                },
                "aria-label": "close",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, {})
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ChromePicker,
              {
                color: theme.textStyles.group.color,
                onChange: (color) => {
                  handleChange(
                    "textColor",
                    "rgba(".concat(color.rgb.r, ", ").concat(color.rgb.g, ", ").concat(color.rgb.b, ", ").concat(color.rgb.a, ")")
                  );
                }
              }
            )
          ] })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Stack$7,
      {
        display: "flex",
        justifyContent: "space-between",
        width: "100%",
        flexDirection: "row",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", alignSelf: "center", children: t2("upload_banner") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { component: "label", className: styles$1.chooseImage, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$r, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                hidden: true,
                accept: "image/*",
                type: "file",
                onChange: handleBannerUpload
              }
            )
          ] }),
          bannerImage && /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              className: styles$1.resetButton,
              onClick: handleBannerReset,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Close, {})
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Stack$7,
      {
        display: "flex",
        justifyContent: "space-between",
        width: "100%",
        flexDirection: "row",
        gap: 1,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", alignSelf: "center", children: t2("upload_background") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { component: "label", className: styles$1.chooseImage, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$r, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                hidden: true,
                accept: "image/*",
                type: "file",
                onChange: handleBackgroundUpload
              }
            )
          ] }),
          backgroundImage && /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              className: styles$1.resetButton,
              onClick: handleBackgroundReset,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Close, {})
            }
          )
        ]
      }
    )
  ] });
}
function SetupPanel({ t: t2 }) {
  const dispatch = useDispatch();
  const toggleExpand = reactExports.useCallback((key) => {
    dispatch(setupToggleExpand(key));
  });
  const theme = useTheme$1();
  const selectSetupInfo = (state) => state.designState.setup || {};
  const selectSetupData = createSelector([selectSetupInfo], (setupInfo) => {
    var _a;
    return {
      code: setupInfo.code,
      expanded: setupInfo.expanded,
      highlighted: setupInfo.highlighted,
      rules: setupInfo.rules,
      isSingleRule: ((_a = setupInfo.rules) == null ? void 0 : _a.length) === 1
    };
  });
  const { code, expanded, highlighted: highlighted2, rules, isSingleRule } = useSelector(selectSetupData);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: styles$9.rightContent,
      style: {
        left: theme.direction == "rtl" ? "0px" : ""
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$9.close, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            onClick: () => {
              dispatch(resetSetup());
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, {})
          }
        ) }),
        rules == null ? void 0 : rules.map((rule3) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          SetupSection,
          {
            expanded: (expanded == null ? void 0 : expanded.includes(rule3.key)) || isSingleRule || false,
            isSingleRule,
            code,
            t: t2,
            toggleExpand,
            highlighted: rule3.key == highlighted2,
            rule: rule3
          },
          code + rule3.title
        ))
      ]
    }
  );
}
const SetupPanel$1 = React.memo(SetupPanel);
const SetupComponent = React.memo(({ code, rule: rule3, t: t2 }) => {
  if (rule3.startsWith("validation_")) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ValidationSetupItem$1, { t: t2, rule: rule3, code }, code + rule3);
  }
  switch (rule3) {
    case "theme":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Theming, { t: t2 }, code + rule3);
    case "language":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ManageLanguages, { t: t2 }, code + rule3);
    case "maxChars":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        FieldSize$1,
        {
          label: t2("text_field_size"),
          rule: rule3,
          lowerBound: 1,
          t: t2,
          upperBound: 500,
          defaultValue: 20,
          code
        },
        code + rule3
      );
    case "minRows":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        FieldSize$1,
        {
          label: t2("textarea_lines"),
          lowerBound: 1,
          t: t2,
          upperBound: 500,
          code,
          defaultValue: 20
        },
        code + rule3
      );
    case "hideText":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToggleValue,
        {
          label: t2("hide_text"),
          rule: rule3,
          code
        },
        code + rule3
      );
    case "showDescription":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToggleValue,
        {
          label: t2("show_description"),
          rule: rule3,
          code
        },
        code + rule3
      );
    case "showWordCount":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToggleValue,
        {
          label: t2("show_word_count"),
          rule: rule3,
          code
        },
        code + rule3
      );
    case "navigationMode":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationMode, {}, code + rule3);
    case "allowPrevious":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToggleValue,
        {
          label: t2("allow_previous"),
          rule: rule3,
          code
        },
        code + rule3
      );
    case "allowIncomplete":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToggleValue,
        {
          label: t2("allow_incomplete"),
          rule: rule3,
          code
        },
        code + rule3
      );
    case "allowJump":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToggleValue,
        {
          label: t2("allow_jump"),
          rule: rule3,
          code
        },
        code + rule3
      );
    case "skipInvalid":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToggleValue,
        {
          label: t2("skip_invalid"),
          rule: rule3,
          code
        },
        code + rule3
      );
    case "hint":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ShowHint, { t: t2, code }, code + rule3);
    case "lower_bound_hint":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ContentEditor,
        {
          title: t2("lower_bound_hint"),
          objectName: "lower_bound_hint",
          code
        },
        code + rule3
      );
    case "higher_bound_hint":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ContentEditor,
        {
          title: t2("upper_bound_hint"),
          objectName: "higher_bound_hint",
          code
        },
        code + rule3
      );
    case "loop":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToggleValue,
        {
          rule: rule3,
          code,
          label: t2("loop_video")
        },
        code + rule3
      );
    case "audio_only":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToggleValue,
        {
          rule: rule3,
          code,
          label: t2("audio_only")
        },
        code + rule3
      );
    case "fullDayFormat":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToggleValue,
        {
          rule: rule3,
          code,
          label: t2("fullday_format")
        },
        code + rule3
      );
    case "randomize_questions":
    case "prioritize_questions":
    case "randomize_options":
    case "prioritize_options":
    case "randomize_groups":
    case "prioritize_groups":
    case "randomize_rows":
    case "prioritize_rows":
    case "randomize_columns":
    case "prioritize_columns":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(OrderPrioritySetup, { t: t2, rule: rule3, code }, code + rule3);
    case "maxDate":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectDate,
        {
          lowerBound: 1,
          code,
          label: t2("max_date"),
          rule: rule3
        },
        code + rule3
      );
    case "minDate":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectDate,
        {
          label: t2("min_date"),
          rule: rule3,
          code
        },
        code + rule3
      );
    case "dateFormat":
      const listDateFormat = [
        "DD.MM.YYYY",
        "MM.DD.YYYY",
        "YYYY.MM.DD",
        "DD/MM/YYYY",
        "MM/DD/YYYY",
        "YYYY/MM/DD"
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectValue,
        {
          values: listDateFormat,
          defaultValue: "DD.MM.YYYY",
          label: t2("date_format"),
          rule: rule3,
          code
        },
        code + rule3
      );
    case "decimal_separator":
      const decimalValues = ["", ",", "."];
      const labels = [t2("no_decimals_allowed"), ",", "."];
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectValue,
        {
          values: decimalValues,
          labels,
          defaultValue: "",
          label: t2("decimal_separator"),
          rule: rule3,
          code
        },
        code + rule3
      );
    case "imageAspectRatio":
      const aspectLabels = ["1:1", "16:9", "4:3", "3:2", "9:16", "3:4", "2:3"];
      const aspectValues = [1, 1.7778, 1.3333, 1.5, 0.562, 0.75, 0.6667];
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectValue,
        {
          values: aspectValues,
          labels: aspectLabels,
          defaultValue: "1:1",
          label: t2("image_aspect_ratio"),
          rule: rule3,
          code
        },
        code + rule3
      );
    case "reorder_setup":
      const reorderLabels = [
        t2("collapse_groups"),
        t2("collapse_questions")
      ];
      const reorderValues = [
        "collapse_groups",
        "collapse_questions"
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectValue,
        {
          values: reorderValues,
          labels: reorderLabels,
          defaultValue: "collapse_none",
          label: t2("order_mode"),
          rule: rule3,
          code
        },
        code + rule3
      );
    case "iconSize":
      const iconSizes = ["50", "100", "150", "200"];
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectValue,
        {
          values: iconSizes,
          defaultValue: "1:1",
          label: t2("image_icon_size"),
          rule: rule3,
          code
        },
        code + rule3
      );
    case "columns":
      const columnsOptions = ["1", "2", "3", "4", "6"];
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectValue,
        {
          values: columnsOptions,
          defaultValue: "2",
          label: t2("columns_number"),
          rule: rule3,
          code
        },
        code + rule3
      );
    case "imageHeight":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        FieldSize$1,
        {
          label: t2("image_height"),
          lowerBound: 50,
          upperBound: 500,
          t: t2,
          code,
          defaultValue: 250,
          rule: rule3
        },
        code + rule3
      );
    case "spacing":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        FieldSize$1,
        {
          label: t2("spacing"),
          lowerBound: 2,
          upperBound: 32,
          code,
          t: t2,
          defaultValue: 8,
          rule: rule3
        },
        code + rule3
      );
    case "skip_logic":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SkipLogic, { t: t2, code }, code + rule3);
    case "relevance":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Relevance, { t: t2, code }, code + rule3);
    default:
      return "";
  }
});
const SetupSection = React.memo(
  ({ expanded, highlighted: highlighted2, code, rule: rule3, isSingleRule, t: t2, toggleExpand }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Accordion,
      {
        expanded,
        className: styles$9.accordionStyle,
        slotProps: { transition: { unmountOnExit: true } },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            AccordionSummary,
            {
              onClick: () => toggleExpand(rule3.key),
              className: styles$9.setupHeader,
              expandIcon: isSingleRule ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$s, {}),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$9.sectionTitle, children: t2(rule3.title) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            AccordionDetails,
            {
              sx: { backgroundColor: highlighted2 ? "#fff" : "background.paper" },
              children: rule3.rules.map((el) => /* @__PURE__ */ jsxRuntimeExports.jsx(SetupComponent, { code, rule: el, t: t2 }, el))
            }
          )
        ]
      }
    );
  }
);
function LeftPanel({ t: t2 }) {
  const show = useSelector((state) => {
    var _a;
    return (((_a = state.designState) == null ? void 0 : _a.designMode) || DESIGN_SURVEY_MODE.DESIGN) == DESIGN_SURVEY_MODE.DESIGN && (!state.designState.setup || Object.keys(state.designState.setup) == 0);
  });
  const setup2 = useSelector((state) => {
    var _a;
    return ((_a = state.designState) == null ? void 0 : _a.setup) || {};
  });
  const hasSetup = Object.keys(setup2).length > 0;
  useTheme$1();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { width: "22rem", flex: "0 0 auto" }, children: [
    show && /* @__PURE__ */ jsxRuntimeExports.jsx(NewComponentsPanel, { t: t2 }),
    hasSetup && /* @__PURE__ */ jsxRuntimeExports.jsx(SetupPanel$1, { t: t2 })
  ] });
}
const LeftPanel$1 = React.memo(LeftPanel);
var Translate = {};
var _interopRequireDefault$2 = interopRequireDefaultExports;
Object.defineProperty(Translate, "__esModule", {
  value: true
});
var default_1$2 = Translate.default = void 0;
var _createSvgIcon$2 = _interopRequireDefault$2(requireCreateSvgIcon());
var _jsxRuntime$2 = jsxRuntimeExports;
default_1$2 = Translate.default = (0, _createSvgIcon$2.default)(/* @__PURE__ */ (0, _jsxRuntime$2.jsx)("path", {
  d: "m12.87 15.07-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2zm-2.62 7 1.62-4.33L19.12 17z"
}), "Translate");
var Reorder = {};
var _interopRequireDefault$1 = interopRequireDefaultExports;
Object.defineProperty(Reorder, "__esModule", {
  value: true
});
var default_1$1 = Reorder.default = void 0;
var _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon());
var _jsxRuntime$1 = jsxRuntimeExports;
default_1$1 = Reorder.default = (0, _createSvgIcon$1.default)(/* @__PURE__ */ (0, _jsxRuntime$1.jsx)("path", {
  d: "M3 15h18v-2H3zm0 4h18v-2H3zm0-8h18V9H3zm0-6v2h18V5z"
}), "Reorder");
var MoreHoriz = {};
var _interopRequireDefault = interopRequireDefaultExports;
Object.defineProperty(MoreHoriz, "__esModule", {
  value: true
});
var default_1 = MoreHoriz.default = void 0;
var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
var _jsxRuntime = jsxRuntimeExports;
default_1 = MoreHoriz.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
  d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
}), "MoreHoriz");
function RightPanel({ t: t2 }) {
  const setup2 = useSelector((state) => {
    var _a;
    return ((_a = state.designState) == null ? void 0 : _a.setup) || {};
  });
  useTheme$1();
  const hasSetup = Object.keys(setup2).length > 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Collapse,
    {
      in: hasSetup,
      sx: { flex: "0 0 auto" },
      orientation: "horizontal",
      timeout: 200,
      easing: {
        enter: "linear",
        // Easing for the "entering" animation
        exit: "linear"
        // Easing for the "exiting" animation
      },
      unmountOnExit: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(SetupPanel$1, { t: t2 })
    }
  );
}
React.memo(RightPanel);
function DesignSurvey() {
  const { t: t2, i18n: i18n2 } = useTranslation(["design", "run"]);
  const childI18n = i18n2.cloneInstance();
  const contentRef = reactExports.useRef(null);
  const [optionsOpen, setOptionsOpen] = React.useState(false);
  const containerRef = reactExports.useRef();
  const langInfo = useSelector((state) => {
    return state.designState.langInfo;
  });
  const dispatch = useDispatch();
  const designMode = useSelector((state) => {
    return state.designState.designMode;
  });
  const toDesign = () => {
    dispatch(resetSetup());
  };
  const lang2 = langInfo == null ? void 0 : langInfo.lang;
  const isRtl = isSessionRtl();
  console.log(isRtl);
  const theme = useSelector((state) => {
    var _a;
    return (_a = state.designState["Survey"]) == null ? void 0 : _a.theme;
  });
  function changeLanguage(lang22) {
    return new Promise((resolve, reject) => {
      const dir = rtlLanguage.includes(lang22) ? "rtl" : "ltr";
      const contentPanel2 = contentRef.current;
      if (contentPanel2.dir != dir) {
        contentPanel2.dir = dir;
      }
      contentPanel2.scrollTop = 0;
      if (lang22 && childI18n && lang22 != childI18n.language) {
        childI18n.changeLanguage(lang22);
      }
      resolve();
    });
  }
  reactExports.useEffect(() => {
    if (contentRef.current) {
      changeLanguage(lang2);
    }
  }, [lang2, contentRef]);
  const cacheRtlMemo = reactExports.useMemo(() => cacheRtl(lang2), [lang2]);
  const surveyTheme = React.useCallback(
    createTheme({
      ...defualtTheme(theme),
      direction: rtlLanguage.includes(lang2) ? "rtl" : "ltr"
    }),
    [theme]
  );
  const backgroundImage = useSelector(
    (state) => {
      var _a, _b;
      return (_b = (_a = state.designState["Survey"]) == null ? void 0 : _a.resources) == null ? void 0 : _b.backgroundImage;
    }
  );
  const backgroundStyle = backgroundImage ? {
    backgroundImage: "url(".concat(buildResourceUrl(backgroundImage), ")"),
    backgroundSize: "cover",
    backgroundRepeat: "no-repeat",
    // backgroundSize: "100% 100%",
    backgroundPosition: "center"
  } : {};
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      className: styles$K.mainContainer,
      ref: containerRef,
      sx: backgroundStyle,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DndProvider, { backend: isTouchDevice() ? TouchBackend : HTML5Backend, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CacheProvider, { value: cacheRtlMemo, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(LeftPanel$1, { t: t2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider, { theme: surveyTheme, children: /* @__PURE__ */ jsxRuntimeExports.jsx(I18nextProvider, { i18n: childI18n, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ContentPanel$1,
          {
            designMode,
            ref: contentRef,
            className: styles$K.contentPanel
          }
        ) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DesignChip, { onCancel: toDesign, designMode, isRtl }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          DesignOptions,
          {
            designMode,
            isRtl,
            optionsOpen,
            setOptionsOpen
          }
        )
      ] }) })
    }
  );
}
const index = React.memo(DesignSurvey);
function DesignOptions({ setOptionsOpen, optionsOpen, designMode, isRtl }) {
  const dispatch = useDispatch();
  const actions = [
    {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$2, {}),
      name: "Language",
      onClick: () => {
        setOptionsOpen(false);
        dispatch(setDesignModeToLang());
      }
    },
    {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Palette, {}),
      name: "Theme",
      onClick: () => {
        setOptionsOpen(false);
        dispatch(setDesignModeToTheme());
      }
    },
    {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$1, {}),
      name: "Reorder",
      onClick: () => {
        setOptionsOpen(false);
        dispatch(setDesignModeToReorder());
      }
    }
  ];
  return designMode == DESIGN_SURVEY_MODE.DESIGN && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Backdrop, { style: { zIndex: 1 }, open: optionsOpen }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SpeedDial,
      {
        open: optionsOpen,
        dir: "rtl",
        onClick: () => setOptionsOpen(!optionsOpen),
        ariaLabel: "SpeedDial basic example",
        sx: isRtl ? { position: "absolute", bottom: 16, left: 16 } : { position: "absolute", bottom: 16, right: 16 },
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1, {}),
        children: actions.map((action2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          SpeedDialAction,
          {
            onClick: action2.onClick,
            dir: "rtl",
            icon: action2.icon,
            tooltipOpen: true,
            tooltipTitle: action2.name
          },
          action2.name
        ))
      }
    )
  ] });
}
function DesignChip({ designMode, onCancel, isRtl }) {
  return designMode != DESIGN_SURVEY_MODE.DESIGN && /* @__PURE__ */ jsxRuntimeExports.jsx(
    Chip,
    {
      sx: {
        borderRadius: "48px",
        height: "48px",
        fontSize: "24px",
        padding: "8px"
      },
      style: isRtl ? { position: "absolute", bottom: 16, left: 16 } : { position: "absolute", bottom: 16, right: 16 },
      label: "Back to Design",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Cancel, {}),
      color: "primary",
      onClick: onCancel
    }
  );
}
export {
  index as default
};
//# sourceMappingURL=index-BLgmNN1v.js.map
